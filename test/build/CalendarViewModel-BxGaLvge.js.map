{"version":3,"file":"CalendarViewModel-BxGaLvge.js","names":["logins: LoginController","createCalendarEventEditModel: CalendarEventEditModelsFactory","createCalendarEventPreviewModel: CalendarEventPreviewModelFactory","createCalendarContactPreviewModel: CalendarContactPreviewModelFactory","calendarModel: CalendarModel","eventsRepository: CalendarEventsRepository","entityClient: EntityClient","eventController: EventController","progressTracker: ProgressTracker","deviceConfig: DeviceConfig","calendarInvitationsModel: ReceivedGroupInvitationsModel<GroupType.Calendar>","timeZone: string","mailboxModel: MailboxModel","contactModel: ContactModel","expanded: boolean","progressMonitor: IProgressMonitor","event: CalendarEvent","originalEvent: CalendarEvent","timeToMoveBy: number","mode: CalendarOperation | null","newHiddenCalendars: Set<Id>","time: Time | undefined","days: Array<Date>","longEvents: Map<string, CalendarEvent>","shortEvents: Array<Array<CalendarEvent>>","shortEventsForDay: Array<CalendarEvent>","shortEventsForDay: CalendarEvent[]","calendar: CalendarInfo","diff: number","mode: CalendarOperation","event: CalendarEvent | null","previewModel: CalendarPreviewModels","updates: ReadonlyArray<EntityUpdateData>","eventId: IdTuple","transientEvent","daysInMonths: Array<Date>","newPosition: number","dom: HTMLElement","by: number","groupSettings: GroupSettings | null","longErrorMessage: boolean","groupInfo: GroupInfo","newGroupSettings: GroupSettings","eventClone: CalendarEvent","mouseDiff: number"],"sources":["../../src/calendar-app/calendar/view/CalendarViewModel.ts"],"sourcesContent":["import {\n\t$Promisable,\n\tassertNotNull,\n\tclone,\n\tdebounce,\n\tdeepEqual,\n\tdowncast,\n\tfindAndRemove,\n\tgetStartOfDay,\n\tgroupByAndMapUniquely,\n\tlast,\n} from \"@tutao/tutanota-utils\"\nimport { CalendarEvent, CalendarEventTypeRef, Contact, ContactTypeRef, GroupSettings } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport {\n\tCLIENT_ONLY_CALENDARS,\n\tEXTERNAL_CALENDAR_SYNC_INTERVAL,\n\tgetWeekStart,\n\tGroupType,\n\tOperationType,\n\tWeekStart,\n} from \"../../../common/api/common/TutanotaConstants\"\nimport { NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError\"\nimport { getElementId, getListId, isSameId, listIdPart } from \"../../../common/api/common/utils/EntityUtils\"\nimport { LoginController } from \"../../../common/api/main/LoginController\"\nimport { IProgressMonitor } from \"../../../common/api/common/utils/ProgressMonitor\"\nimport { CustomerInfoTypeRef, GroupInfo, ReceivedGroupInvitation } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport stream from \"mithril/stream\"\nimport Stream from \"mithril/stream\"\nimport {\n\textractContactIdFromEvent,\n\tgetDiffIn60mIntervals,\n\tgetMonthRange,\n\tisClientOnlyCalendar,\n\tisEventBetweenDays,\n} from \"../../../common/calendar/date/CalendarUtils\"\nimport { isAllDayEvent } from \"../../../common/api/common/utils/CommonCalendarUtils\"\nimport { CalendarEventModel, CalendarOperation, EventSaveResult, EventType, getNonOrganizerAttendees } from \"../gui/eventeditor-model/CalendarEventModel.js\"\nimport { askIfShouldSendCalendarUpdatesToAttendees, getClientOnlyColors, getEventType, getGroupColors, shouldDisplayEvent } from \"../gui/CalendarGuiUtils.js\"\nimport { ReceivedGroupInvitationsModel } from \"../../../common/sharing/model/ReceivedGroupInvitationsModel\"\nimport type { CalendarInfo, CalendarModel } from \"../model/CalendarModel\"\nimport { EventController } from \"../../../common/api/main/EventController\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport { ProgressTracker } from \"../../../common/api/main/ProgressTracker\"\nimport { deviceConfig, DeviceConfig } from \"../../../common/misc/DeviceConfig\"\nimport type { EventDragHandlerCallbacks } from \"./EventDragHandler\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError.js\"\nimport { Time } from \"../../../common/calendar/date/Time.js\"\nimport { CalendarEventsRepository, DaysToEvents } from \"../../../common/calendar/date/CalendarEventsRepository.js\"\nimport { CalendarEventPreviewViewModel } from \"../gui/eventpopup/CalendarEventPreviewViewModel.js\"\nimport { EntityUpdateData, isUpdateFor, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport { MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { getEnabledMailAddressesWithUser } from \"../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { ContactModel } from \"../../../common/contactsFunctionality/ContactModel.js\"\nimport type { GroupColors } from \"./CalendarView.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel.js\"\nimport { CalendarContactPreviewViewModel } from \"../gui/eventpopup/CalendarContactPreviewViewModel.js\"\n\nexport type EventsOnDays = {\n\tdays: Array<Date>\n\tshortEventsPerDay: Array<Array<CalendarEvent>>\n\tlongEvents: Array<CalendarEvent>\n}\n\n/** container to for the information needed to render & handle a reschedule with drag-and-drop */\nexport type DraggedEvent = {\n\t/** the event instance the user grabbed with the mouse */\n\toriginalEvent: CalendarEvent\n\t/** the temporary event that's shown during the drag */\n\teventClone: CalendarEvent\n}\n\nexport type MouseOrPointerEvent = MouseEvent | PointerEvent\nexport type CalendarEventBubbleClickHandler = (arg0: CalendarEvent, arg1: MouseOrPointerEvent) => unknown\nexport type CalendarEventBubbleKeyDownHandler = (arg0: CalendarEvent, arg1: KeyboardEvent) => unknown\nexport type CalendarEventEditModelsFactory = (mode: CalendarOperation, event: CalendarEvent) => Promise<CalendarEventModel | null>\n\nexport type CalendarEventPreviewModelFactory = (\n\tselectedEvent: CalendarEvent,\n\tcalendars: ReadonlyMap<string, CalendarInfo>,\n) => Promise<CalendarEventPreviewViewModel>\nexport type CalendarContactPreviewModelFactory = (event: CalendarEvent, contact: Contact, canEdit: boolean) => Promise<CalendarContactPreviewViewModel>\nexport type CalendarPreviewModels = CalendarEventPreviewViewModel | CalendarContactPreviewViewModel\n\nexport class CalendarViewModel implements EventDragHandlerCallbacks {\n\t// Should not be changed directly but only through the URL\n\treadonly selectedDate: Stream<Date> = stream(getStartOfDay(new Date()))\n\n\t/**\n\t * An event currently being displayed (non-modally)\n\t * the {@code model} is {@code null} until it is loaded.\n\t *\n\t * We keep track of event separately to avoid races with selecting multiple events shortly one after another.\n\t */\n\tprivate previewedEvent: { event: CalendarEvent; model: CalendarPreviewModels | null } | null = null\n\n\tprivate _hiddenCalendars: Set<Id>\n\t/** Events that have been dropped but still need to be rendered as temporary while waiting for entity updates. */\n\t// visible for tests\n\treadonly _transientEvents: Array<CalendarEvent>\n\t// visible for tests\n\t_draggedEvent: DraggedEvent | null = null\n\tprivate readonly _redrawStream: Stream<void> = stream()\n\tselectedTime: Time | undefined\n\t// When set to true, ignores the next setting of selectedTime\n\tignoreNextValidTimeSelection: boolean\n\n\tprivate scrollPosition: number = 0 // size.calendar_hour_height * DEFAULT_HOUR_OF_DAY\n\t// The maximum scroll value of the list in the view\n\tprivate scrollMax: number | null = null\n\t// The size of the list in the view\n\tprivate viewSize: number | null = null\n\n\tprivate _isNewPaidPlan: boolean = false\n\tprivate localCalendars: Map<Id, CalendarInfo> = new Map<Id, CalendarInfo>()\n\tprivate _calendarColors: GroupColors = new Map()\n\n\tconstructor(\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly createCalendarEventEditModel: CalendarEventEditModelsFactory,\n\t\tprivate readonly createCalendarEventPreviewModel: CalendarEventPreviewModelFactory,\n\t\tprivate readonly createCalendarContactPreviewModel: CalendarContactPreviewModelFactory,\n\t\tprivate readonly calendarModel: CalendarModel,\n\t\tprivate readonly eventsRepository: CalendarEventsRepository,\n\t\tprivate readonly entityClient: EntityClient,\n\t\teventController: EventController,\n\t\tprivate readonly progressTracker: ProgressTracker,\n\t\tprivate readonly deviceConfig: DeviceConfig,\n\t\tprivate readonly calendarInvitationsModel: ReceivedGroupInvitationsModel<GroupType.Calendar>,\n\t\tprivate readonly timeZone: string,\n\t\tprivate readonly mailboxModel: MailboxModel,\n\t\tprivate readonly contactModel: ContactModel,\n\t) {\n\t\tthis._transientEvents = []\n\n\t\tconst userId = logins.getUserController().user._id\n\t\tconst today = new Date()\n\n\t\tthis._hiddenCalendars = new Set(this.deviceConfig.getHiddenCalendars(userId))\n\n\t\tthis.selectedDate.map(() => {\n\t\t\tthis.updatePreviewedEvent(null)\n\t\t\tthis.preloadMonthsAroundSelectedDate()\n\t\t})\n\t\tthis.selectedTime = Time.fromDate(today)\n\t\tthis.ignoreNextValidTimeSelection = false\n\t\tthis.calendarModel.getCalendarInfosStream().map((newInfos) => {\n\t\t\tconst event = this.previewedEvent?.event ?? null\n\t\t\tif (event != null) {\n\t\t\t\t// redraw if we lost access to the events' list\n\t\t\t\tconst groupRoots = Array.from(newInfos.values()).map((i) => i.groupRoot)\n\t\t\t\tconst lists = [...groupRoots.map((g) => g.longEvents), ...groupRoots.map((g) => g.shortEvents)]\n\t\t\t\tconst previewListId = getListId(event)\n\t\t\t\tif (!lists.some((id) => isSameId(previewListId, id))) {\n\t\t\t\t\tthis.updatePreviewedEvent(null)\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.preloadMonthsAroundSelectedDate()\n\t\t})\n\n\t\teventController.addEntityListener((updates) => this.entityEventReceived(updates))\n\n\t\tcalendarInvitationsModel.init()\n\n\t\tthis.eventsRepository.getEventsForMonths().map(() => {\n\t\t\tthis.doRedraw()\n\t\t})\n\n\t\tthis.loadCalendarColors()\n\n\t\tlogins\n\t\t\t.getUserController()\n\t\t\t.isNewPaidPlan()\n\t\t\t.then((isNewPaidPlan) => {\n\t\t\t\tthis._isNewPaidPlan = isNewPaidPlan\n\t\t\t\tthis.prepareClientCalendars()\n\t\t\t})\n\t}\n\n\tisDaySelectorExpanded(): boolean {\n\t\treturn this.deviceConfig.isCalendarDaySelectorExpanded()\n\t}\n\n\tsetDaySelectorExpanded(expanded: boolean) {\n\t\tthis.deviceConfig.setCalendarDaySelectorExpanded(expanded)\n\t}\n\n\tloadCalendarColors() {\n\t\tconst clientOnlyColors = getClientOnlyColors(this.logins.getUserController().userId, deviceConfig.getClientOnlyCalendars())\n\t\tconst groupColors = getGroupColors(this.logins.getUserController().userSettingsGroupRoot)\n\t\tfor (let [calendarId, color] of clientOnlyColors.entries()) {\n\t\t\tgroupColors.set(calendarId, color)\n\t\t}\n\n\t\tif (!deepEqual(this._calendarColors, groupColors)) {\n\t\t\tthis._calendarColors = new Map(groupColors)\n\t\t}\n\t}\n\n\t/**\n\t * Load client only calendars or generate them if missing\n\t */\n\tprivate prepareClientCalendars() {\n\t\tfor (const [clientOnlyCalendarBaseId, name] of CLIENT_ONLY_CALENDARS) {\n\t\t\tconst calendarID = `${this.logins.getUserController().userId}#${clientOnlyCalendarBaseId}`\n\t\t\tconst clientOnlyCalendarConfig = deviceConfig.getClientOnlyCalendars().get(calendarID)\n\n\t\t\tthis.localCalendars.set(\n\t\t\t\tcalendarID,\n\t\t\t\tdowncast({\n\t\t\t\t\tgroupRoot: { _id: calendarID },\n\t\t\t\t\tgroupInfo: clientOnlyCalendarConfig\n\t\t\t\t\t\t? { name: clientOnlyCalendarConfig.name, group: calendarID }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tname: lang.get(name),\n\t\t\t\t\t\t\t\tgroup: calendarID,\n\t\t\t\t\t\t  },\n\t\t\t\t\tgroup: { _id: calendarID },\n\t\t\t\t\tshared: false,\n\t\t\t\t\tuserIsOwner: true,\n\t\t\t\t}),\n\t\t\t)\n\n\t\t\tif (!this.isNewPaidPlan && !this.hiddenCalendars.has(calendarID)) {\n\t\t\t\tthis._hiddenCalendars.add(calendarID)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * react to changes to the calendar data by making sure we have the current month + the two adjacent months\n\t * ready to be rendered\n\t */\n\tprivate preloadMonthsAroundSelectedDate = debounce(200, async () => {\n\t\t// load all calendars. if there is no calendar yet, create one\n\t\t// for each calendar we load short events for three months +3\n\t\tconst workPerCalendar = 3\n\t\tconst totalWork = this.logins.getUserController().getCalendarMemberships().length * workPerCalendar\n\t\tconst monitorHandle = this.progressTracker.registerMonitorSync(totalWork)\n\t\tconst progressMonitor: IProgressMonitor = assertNotNull(this.progressTracker.getMonitor(monitorHandle))\n\n\t\tconst newSelectedDate = this.selectedDate()\n\t\tconst thisMonthStart = getMonthRange(newSelectedDate, this.timeZone).start\n\t\tconst previousMonthDate = new Date(thisMonthStart)\n\t\tpreviousMonthDate.setMonth(new Date(thisMonthStart).getMonth() - 1)\n\t\tconst nextMonthDate = new Date(thisMonthStart)\n\t\tnextMonthDate.setMonth(new Date(thisMonthStart).getMonth() + 1)\n\n\t\ttry {\n\t\t\tconst hasNewPaidPlan = await this.eventsRepository.canLoadBirthdaysCalendar()\n\t\t\tif (hasNewPaidPlan) {\n\t\t\t\tawait this.eventsRepository.loadContactsBirthdays()\n\t\t\t}\n\t\t\tawait this.loadMonthsIfNeeded([new Date(thisMonthStart), nextMonthDate, previousMonthDate], progressMonitor)\n\t\t} finally {\n\t\t\tprogressMonitor.completed()\n\t\t\tthis.doRedraw()\n\t\t}\n\t})\n\n\tget calendarInvitations(): Stream<Array<ReceivedGroupInvitation>> {\n\t\treturn this.calendarInvitationsModel.invitations\n\t}\n\n\tget calendarColors(): GroupColors {\n\t\treturn this._calendarColors\n\t}\n\n\tget clientOnlyCalendars(): ReadonlyMap<Id, CalendarInfo> {\n\t\treturn this.localCalendars\n\t}\n\n\tget calendarInfos(): ReadonlyMap<Id, CalendarInfo> {\n\t\treturn this.calendarModel.getCalendarInfosStream()()\n\t}\n\n\tget hiddenCalendars(): ReadonlySet<Id> {\n\t\treturn this._hiddenCalendars\n\t}\n\n\tget eventsForDays(): DaysToEvents {\n\t\treturn this.eventsRepository.getEventsForMonths()()\n\t}\n\n\tget redraw(): Stream<void> {\n\t\treturn this._redrawStream\n\t}\n\n\tget weekStart(): WeekStart {\n\t\treturn getWeekStart(this.logins.getUserController().userSettingsGroupRoot)\n\t}\n\n\t// visibleForTesting\n\tallowDrag(event: CalendarEvent): boolean {\n\t\treturn this.canFullyEditEvent(event)\n\t}\n\n\t/**\n\t * Partially mirrors the logic from CalendarEventModel.prototype.isFullyWritable() to determine\n\t * if the user can edit more than just alarms for a given event\n\t */\n\tprivate canFullyEditEvent(event: CalendarEvent): boolean {\n\t\tconst userController = this.logins.getUserController()\n\t\tconst userMailGroup = userController.getUserMailGroupMembership().group\n\t\tconst mailboxDetailsArray = this.mailboxModel.mailboxDetails()\n\t\tconst mailboxDetails = assertNotNull(mailboxDetailsArray.find((md) => md.mailGroup._id === userMailGroup))\n\t\tconst ownMailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, userController.userGroupInfo)\n\t\tconst eventType = getEventType(event, this.calendarInfos, ownMailAddresses, userController)\n\t\treturn eventType === EventType.OWN || eventType === EventType.SHARED_RW\n\t}\n\n\tonDragStart(originalEvent: CalendarEvent, timeToMoveBy: number) {\n\t\tif (this.allowDrag(originalEvent)) {\n\t\t\tlet eventClone = clone(originalEvent)\n\t\t\tupdateTemporaryEventWithDiff(eventClone, originalEvent, timeToMoveBy)\n\t\t\tthis._draggedEvent = {\n\t\t\t\toriginalEvent,\n\t\t\t\teventClone,\n\t\t\t}\n\t\t}\n\t}\n\n\tonDragUpdate(timeToMoveBy: number) {\n\t\tif (this._draggedEvent) {\n\t\t\tupdateTemporaryEventWithDiff(this._draggedEvent.eventClone, this._draggedEvent.originalEvent, timeToMoveBy)\n\t\t}\n\t}\n\n\t/**\n\t * This is called when the event is dropped.\n\t */\n\tasync onDragEnd(timeToMoveBy: number, mode: CalendarOperation | null): Promise<void> {\n\t\t//if the time of the dragged event is the same as of the original we only cancel the drag\n\t\tif (timeToMoveBy !== 0 && mode != null) {\n\t\t\tif (this._draggedEvent == null) return\n\n\t\t\tconst { originalEvent, eventClone } = this._draggedEvent\n\t\t\tthis._draggedEvent = null\n\t\t\tupdateTemporaryEventWithDiff(eventClone, originalEvent, timeToMoveBy)\n\n\t\t\tthis._addTransientEvent(eventClone)\n\n\t\t\ttry {\n\t\t\t\tconst didUpdate = await this.moveEvent(originalEvent, timeToMoveBy, mode)\n\n\t\t\t\tif (didUpdate !== EventSaveResult.Saved) {\n\t\t\t\t\tthis._removeTransientEvent(eventClone)\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis._removeTransientEvent(eventClone)\n\n\t\t\t\tthrow e\n\t\t\t}\n\t\t} else {\n\t\t\tthis._draggedEvent = null\n\t\t}\n\t}\n\n\tonDragCancel() {\n\t\tthis._draggedEvent = null\n\t}\n\n\tget temporaryEvents(): Array<CalendarEvent> {\n\t\treturn this._transientEvents.concat(this._draggedEvent ? [this._draggedEvent.eventClone] : [])\n\t}\n\n\tsetHiddenCalendars(newHiddenCalendars: Set<Id>) {\n\t\tthis._hiddenCalendars = newHiddenCalendars\n\n\t\tthis.deviceConfig.setHiddenCalendars(this.logins.getUserController().user._id, [...newHiddenCalendars])\n\t}\n\n\tsetSelectedTime(time: Time | undefined) {\n\t\t// only ignore an actual time, setting to undefined is fine\n\t\tif (time != undefined && this.ignoreNextValidTimeSelection) {\n\t\t\tthis.ignoreNextValidTimeSelection = false\n\t\t} else {\n\t\t\tthis.selectedTime = time\n\t\t}\n\t}\n\n\t/**\n\t * Given an event and days, return the long and short events of that range of days\n\t * we detect events that should be removed based on their UID + start and end time\n\t *\n\t * @param days The range of days from which events should be returned\n\t * @returns    shortEvents: Array<Array<CalendarEvent>>, short events per day\n\t *             longEvents: Array<CalendarEvent>: long events over the whole range,\n\t *             days: Array<Date>: the original days that were passed in\n\t */\n\tgetEventsOnDaysToRender(days: Array<Date>): EventsOnDays {\n\t\t// addDaysForRecurringEvents produces some weeks that have non-referentially-identical objects for the same event instance (occurrence)\n\t\t// in particular, this happens for the weeks straddling a month border because each month adds a different clone of the occurrence to its part of the week\n\t\t// this means we can't use a set to deduplicate these.\n\n\t\t/** A map from event id and start time to the event instance. It is not enough to just use an id because different occurrences will have the same id. */\n\t\tconst longEvents: Map<string, CalendarEvent> = new Map()\n\t\tlet shortEvents: Array<Array<CalendarEvent>> = []\n\t\t// It might be the case that a UID is shared by events across calendars, so we need to differentiate them by list ID aswell\n\t\tconst transientEventUidsByCalendar = groupByAndMapUniquely(\n\t\t\tthis._transientEvents,\n\t\t\t(event) => getListId(event),\n\t\t\t(event) => event.uid,\n\t\t)\n\n\t\tconst sortEvent = (event: CalendarEvent, shortEventsForDay: Array<CalendarEvent>) => {\n\t\t\tif (isAllDayEvent(event) || getDiffIn60mIntervals(event.startTime, event.endTime) >= 24) {\n\t\t\t\tlongEvents.set(getElementId(event) + event.startTime.toString(), event)\n\t\t\t} else {\n\t\t\t\tshortEventsForDay.push(event)\n\t\t\t}\n\t\t}\n\n\t\tfor (const day of days) {\n\t\t\tconst shortEventsForDay: CalendarEvent[] = []\n\t\t\tconst eventsForDay = this.eventsRepository.getEventsForMonths()().get(day.getTime()) || []\n\n\t\t\tfor (const event of eventsForDay) {\n\t\t\t\tif (transientEventUidsByCalendar.get(getListId(event))?.has(event.uid)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif (this._draggedEvent?.originalEvent !== event && shouldDisplayEvent(event, this._hiddenCalendars)) {\n\t\t\t\t\t// this is not the dragged event (not rendered) and does not belong to a hidden calendar, so we should render it.\n\t\t\t\t\tsortEvent(event, shortEventsForDay)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const event of this._transientEvents) {\n\t\t\t\tif (isEventBetweenDays(event, day, day, this.timeZone)) {\n\t\t\t\t\tsortEvent(event, shortEventsForDay)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst temporaryEvent = this._draggedEvent?.eventClone\n\n\t\t\tif (temporaryEvent && isEventBetweenDays(temporaryEvent, day, day, this.timeZone)) {\n\t\t\t\tsortEvent(temporaryEvent, shortEventsForDay)\n\t\t\t}\n\n\t\t\tshortEvents.push(shortEventsForDay)\n\t\t}\n\n\t\tconst longEventsArray = Array.from(longEvents.values())\n\t\treturn {\n\t\t\tdays,\n\t\t\tlongEvents: longEventsArray,\n\t\t\tshortEventsPerDay: shortEvents,\n\t\t}\n\t}\n\n\tasync deleteCalendar(calendar: CalendarInfo): Promise<void> {\n\t\tawait this.calendarModel.deleteCalendar(calendar)\n\t}\n\n\t_addTransientEvent(event: CalendarEvent) {\n\t\tthis._transientEvents.push(event)\n\t}\n\n\t_removeTransientEvent(event: CalendarEvent) {\n\t\tfindAndRemove(this._transientEvents, (transient) => transient.uid === event.uid)\n\t}\n\n\t/**\n\t * move an event to a new start time\n\t * @param event the actually dragged event (may be a repeated instance)\n\t * @param diff the amount of milliseconds to shift the event by\n\t * @param mode which parts of the series should be rescheduled?\n\t */\n\tprivate async moveEvent(event: CalendarEvent, diff: number, mode: CalendarOperation): Promise<EventSaveResult> {\n\t\tif (event.uid == null) {\n\t\t\tthrow new ProgrammingError(\"called moveEvent for an event without uid\")\n\t\t}\n\n\t\tconst editModel = await this.createCalendarEventEditModel(mode, event)\n\t\tif (editModel == null) {\n\t\t\treturn EventSaveResult.Failed\n\t\t}\n\t\teditModel.editModels.whenModel.rescheduleEvent({ millisecond: diff })\n\n\t\tif (getNonOrganizerAttendees(event).length > 0) {\n\t\t\tconst response = await askIfShouldSendCalendarUpdatesToAttendees()\n\t\t\tif (response === \"yes\") {\n\t\t\t\teditModel.editModels.whoModel.shouldSendUpdates = true\n\t\t\t} else if (response === \"cancel\") {\n\t\t\t\treturn EventSaveResult.Failed\n\t\t\t}\n\t\t}\n\n\t\t// Errors are handled in the individual views\n\t\treturn await editModel.apply()\n\t}\n\n\tget eventPreviewModel(): CalendarPreviewModels | null {\n\t\treturn this.previewedEvent?.model ?? null\n\t}\n\n\t/**\n\t * there are several reasons why we might no longer want to preview an event and need to redraw without\n\t * a previewed event:\n\t * * it was deleted\n\t * * it was moved away from the day we're looking at (or the day was moved away)\n\t * * the calendar was unshared or deleted\n\t *\n\t * we would want to keep the selection if the event merely shifted its start time but still intersects the viewed day,\n\t * but that would require going through the UID index because moving events changes their ID.\n\t * because of this and because previewedEvent is the event _before_ we got the update that caused us to reconsider the\n\t * selection, with the old times, this function only works if the selected date changed, but not if the event times\n\t * changed.\n\t */\n\tasync updatePreviewedEvent(event: CalendarEvent | null) {\n\t\tif (event == null) {\n\t\t\tthis.previewedEvent = null\n\t\t\tthis.doRedraw()\n\t\t} else {\n\t\t\tconst previewedEvent = (this.previewedEvent = { event, model: null })\n\t\t\tconst calendarInfos = await this.calendarModel.getCalendarInfosCreateIfNeeded()\n\t\t\tlet previewModel: CalendarPreviewModels\n\t\t\tif (isClientOnlyCalendar(listIdPart(event._id))) {\n\t\t\t\tconst idParts = event._id[1].split(\"#\")!\n\t\t\t\tconst contactId = extractContactIdFromEvent(last(idParts))!\n\t\t\t\tconst contactIdParts = contactId.split(\"/\")\n\t\t\t\tconst contact = await this.contactModel.loadContactFromId([contactIdParts[0], contactIdParts[1]])\n\t\t\t\tpreviewModel = await this.createCalendarContactPreviewModel(event, contact, true)\n\t\t\t} else {\n\t\t\t\tpreviewModel = await this.createCalendarEventPreviewModel(event, calendarInfos)\n\t\t\t}\n\t\t\t// check that we didn't start previewing another event or changed the date in the meantime\n\t\t\tif (this.previewedEvent === previewedEvent) {\n\t\t\t\tthis.previewedEvent.model = previewModel\n\t\t\t\tthis.doRedraw()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async entityEventReceived<T>(updates: ReadonlyArray<EntityUpdateData>): Promise<void> {\n\t\tfor (const update of updates) {\n\t\t\tif (isUpdateForTypeRef(CalendarEventTypeRef, update)) {\n\t\t\t\tconst eventId: IdTuple = [update.instanceListId, update.instanceId]\n\t\t\t\tif (this.previewedEvent != null && isUpdateFor(this.previewedEvent.event, update)) {\n\t\t\t\t\tif (update.operation === OperationType.DELETE) {\n\t\t\t\t\t\tthis.previewedEvent = null\n\t\t\t\t\t\tthis.doRedraw()\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst event = await this.entityClient.load(CalendarEventTypeRef, eventId)\n\t\t\t\t\t\t\tawait this.updatePreviewedEvent(event)\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\t\t\t\t\t// return updates that are not in cache Range if NotAuthorizedError (for those updates that are in cache range)\n\t\t\t\t\t\t\t\tconsole.log(\"NotAuthorizedError for event in entityEventsReceived of view\", e)\n\t\t\t\t\t\t\t} else if (e instanceof NotFoundError) {\n\t\t\t\t\t\t\t\tconsole.log(\"Not found event in entityEventsReceived of view\", e)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst transientEvent = this._transientEvents.find((transientEvent) => isSameId(transientEvent._id, eventId))\n\t\t\t\tif (transientEvent) {\n\t\t\t\t\tthis._removeTransientEvent(transientEvent)\n\t\t\t\t\tthis.doRedraw()\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(ContactTypeRef, update) && this.isNewPaidPlan) {\n\t\t\t\tawait this.eventsRepository.loadContactsBirthdays(true)\n\t\t\t\tthis.eventsRepository.refreshBirthdayCalendar(this.selectedDate())\n\t\t\t\tthis.doRedraw()\n\t\t\t} else if (isUpdateForTypeRef(CustomerInfoTypeRef, update)) {\n\t\t\t\tthis.logins\n\t\t\t\t\t.getUserController()\n\t\t\t\t\t.isNewPaidPlan()\n\t\t\t\t\t.then((isNewPaidPlan) => (this._isNewPaidPlan = isNewPaidPlan))\n\t\t\t}\n\t\t}\n\t}\n\n\tgetCalendarInfosCreateIfNeeded(): $Promisable<ReadonlyMap<Id, CalendarInfo>> {\n\t\treturn this.calendarModel.getCalendarInfosCreateIfNeeded()\n\t}\n\n\tloadMonthsIfNeeded(daysInMonths: Array<Date>, progressMonitor: IProgressMonitor): Promise<void> {\n\t\treturn this.eventsRepository.loadMonthsIfNeeded(daysInMonths, progressMonitor, stream(false))\n\t}\n\n\tprivate doRedraw() {\n\t\t// Need to pass some argument to make it a \"set\" operation\n\t\tthis._redrawStream(undefined)\n\t}\n\n\tgetScrollPosition(): number {\n\t\treturn this.scrollPosition\n\t}\n\n\tsetScrollPosition(newPosition: number): void {\n\t\tif (newPosition < 0) {\n\t\t\tthis.scrollPosition = 0\n\t\t} else if (this.scrollMax !== null && newPosition > this.scrollMax) {\n\t\t\tthis.scrollPosition = this.scrollMax\n\t\t} else {\n\t\t\tthis.scrollPosition = newPosition\n\t\t}\n\t}\n\n\tgetScrollMaximum(): number | null {\n\t\treturn this.scrollMax\n\t}\n\n\tgetViewSize(): number | null {\n\t\treturn this.viewSize\n\t}\n\n\tsetViewParameters(dom: HTMLElement): void {\n\t\tthis.scrollMax = dom.scrollHeight - dom.clientHeight\n\t\tthis.viewSize = dom.clientHeight\n\t}\n\n\tscroll(by: number): void {\n\t\tthis.setScrollPosition(this.scrollPosition + by)\n\t}\n\n\tforceSyncExternal(groupSettings: GroupSettings | null, longErrorMessage: boolean = false) {\n\t\tif (!groupSettings) {\n\t\t\treturn\n\t\t}\n\n\t\treturn this.calendarModel.syncExternalCalendars([groupSettings], EXTERNAL_CALENDAR_SYNC_INTERVAL, longErrorMessage, true)\n\t}\n\n\tpublic getCalendarModel() {\n\t\treturn this.calendarModel\n\t}\n\n\thandleClientOnlyUpdate(groupInfo: GroupInfo, newGroupSettings: GroupSettings) {\n\t\tthis.deviceConfig.updateClientOnlyCalendars(groupInfo.group, newGroupSettings)\n\t}\n\n\tget isNewPaidPlan(): Readonly<boolean> {\n\t\treturn this._isNewPaidPlan\n\t}\n}\n\nfunction updateTemporaryEventWithDiff(eventClone: CalendarEvent, originalEvent: CalendarEvent, mouseDiff: number) {\n\teventClone.startTime = new Date(originalEvent.startTime.getTime() + mouseDiff)\n\teventClone.endTime = new Date(originalEvent.endTime.getTime() + mouseDiff)\n}\n"],"mappings":"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"}