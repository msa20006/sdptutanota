{"version":3,"file":"PriceUtils-DA-dFW8L.js","names":["dataProvider: FeatureListProvider | null","IOS_EXCLUDED_FEATURES: TranslationKey[]","domainConfig: DomainConfig","categories: FeatureCategory[]","targetSubscription: PlanType","featureList: any","features: { categories: FeatureCategory[] }","planType: PlanType","referenceDate: Date","paymentInterval: string | number","paymentMethod: PaymentMethodType","value: number","includeCurrency: boolean","subscriptionPrice: number","paymentInterval: PaymentInterval","formattedPrice: string","taxIncluded: boolean","registrationDataId: string | null","serviceExecutor: IServiceExecutor","referralCode: string | null","subscription: PlanType","type: UpgradePriceType","price","rawPrice: string","upgrade: UpgradePriceType","prices: WebsitePlanPrices","bonusMonths: number","isReferralCodeSignup: boolean"],"sources":["../../src/common/subscription/FeatureListProvider.ts","../../src/common/misc/CyberMondayUtils.ts","../../src/common/subscription/PriceUtils.ts"],"sourcesContent":["import Stream from \"mithril/stream\"\nimport { PlanPrices } from \"../api/entities/sys/TypeRefs\"\nimport { TranslationKey } from \"../misc/LanguageViewModel\"\nimport { PaymentInterval } from \"./PriceUtils.js\"\nimport { AvailablePlans, PlanName, PlanType, PlanTypeToName } from \"../api/common/TutanotaConstants.js\"\nimport { downcast, getFromMap } from \"@tutao/tutanota-utils\"\nimport { isIOSApp } from \"../api/common/Env.js\"\n\nlet dataProvider: FeatureListProvider | null = null\n\nconst IOS_EXCLUDED_FEATURES: TranslationKey[] = [\"pricing.family_label\"]\n\nexport class FeatureListProvider {\n\tprivate featureList: FeatureLists | null = null\n\n\tprivate constructor(private readonly domainConfig: DomainConfig) {}\n\n\tprivate async init(): Promise<void> {\n\t\tif (\"undefined\" === typeof fetch) return\n\t\tconst listResourceUrl = `${this.domainConfig.websiteBaseUrl}/resources/data/features.json`\n\t\ttry {\n\t\t\tconst featureList = await fetch(listResourceUrl).then((r) => r.json())\n\t\t\tif (isIOSApp()) {\n\t\t\t\tthis.stripUnsupportedIosFeatures(featureList)\n\t\t\t}\n\t\t\tthis.countFeatures([...featureList.Free.categories, ...featureList.Revolutionary.categories, ...featureList.Legend.categories])\n\t\t\tthis.countFeatures([...featureList.Essential.categories, ...featureList.Advanced.categories, ...featureList.Unlimited.categories])\n\t\t\tthis.featureList = featureList\n\t\t} catch (e) {\n\t\t\tconsole.warn(`failed to fetch feature list from  ${listResourceUrl}`, e)\n\t\t}\n\t}\n\n\tprivate countFeatures(categories: FeatureCategory[]): void {\n\t\tconst featureCounts = new Map<string, { max: number }>()\n\t\tfor (const category of categories) {\n\t\t\tconst count = featureCounts.get(category.title)\n\t\t\tconst numberOfFeatures = category.features.length\n\t\t\tif (count == null || numberOfFeatures > count.max) {\n\t\t\t\tfeatureCounts.set(category.title, { max: numberOfFeatures })\n\t\t\t}\n\t\t}\n\t\tfor (const category of categories) {\n\t\t\tcategory.featureCount = getFromMap(featureCounts, category.title, () => {\n\t\t\t\treturn { max: 0 }\n\t\t\t})\n\t\t}\n\t}\n\n\tstatic async getInitializedInstance(domainConfig: DomainConfig): Promise<FeatureListProvider> {\n\t\tif (dataProvider == null) {\n\t\t\tdataProvider = new FeatureListProvider(domainConfig)\n\t\t\tawait dataProvider.init()\n\t\t}\n\t\treturn dataProvider\n\t}\n\n\tgetFeatureList(targetSubscription: PlanType): FeatureLists[PlanName] {\n\t\tif (this.featureList == null) {\n\t\t\treturn { subtitle: \"emptyString_msg\", categories: [] }\n\t\t} else {\n\t\t\treturn this.featureList[PlanTypeToName[targetSubscription]]\n\t\t}\n\t}\n\n\tfeatureLoadingDone(): boolean {\n\t\treturn this.featureList != null\n\t}\n\n\t/**\n\t * Remove features from the feature list that are unsupported for iOS and shouldn't be displayed to iOS users.\n\t * @param featureList feature list obtained from the server\n\t * @private\n\t */\n\tprivate stripUnsupportedIosFeatures(featureList: any) {\n\t\tfor (const plan of AvailablePlans) {\n\t\t\tconst features: { categories: FeatureCategory[] } = featureList[PlanTypeToName[plan]]\n\t\t\tfor (const category of features.categories) {\n\t\t\t\tcategory.features = category.features.filter(({ text }) => {\n\t\t\t\t\treturn !IOS_EXCLUDED_FEATURES.includes(text)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * tutanota-3 has a typeRef for plan prices, while the web site defines the type with only\n * some of the properties of the model type. using this method to maintain symmetry.\n */\nexport type WebsitePlanPrices = Pick<PlanPrices, \"additionalUserPriceMonthly\" | \"firstYearDiscount\" | \"monthlyPrice\" | \"monthlyReferencePrice\">\n\nexport type SelectedSubscriptionOptions = {\n\tbusinessUse: Stream<boolean>\n\tpaymentInterval: Stream<PaymentInterval>\n}\n\n/**\n * since some translations contain slots that will be populated with\n * dynamic content (depending on options & locale),\n * we have to provide functions to produce it. these\n * are used to select the correct one.\n **/\nexport type ReplacementKey = \"customDomains\" | \"mailAddressAliases\" | \"storage\"\n\n/**\n * A category of features to be shown\n * title: translation key for the title\n * features: List of features in this category\n * omit: whether this can be omitted from the compact feature list,\n */\nexport type FeatureCategory = {\n\ttitle: TranslationKey\n\tfeatures: Array<FeatureListItem>\n\tfeatureCount: { max: number }\n}\n\n/**\n * one item in the list that's shown below a subscription box,\n * text: translation key for the label,\n * toolTip: translation key for the tooltip that will be shown on hover,\n * omit: whether this can be omitted from the compact feature list,\n * antiFeature: some list items are denoting the lack of a feature and are\n *   rendered with an different icon.\n * replacements: a key to select the correct content to replace the slots in the translation\n */\nexport type FeatureListItem = {\n\ttext: TranslationKey\n\ttoolTip?: TranslationKey\n\tomit: boolean\n\tantiFeature?: boolean\n\treplacements?: ReplacementKey\n\theart?: boolean\n}\n\n/**\n * subtitle: the short text shown below the subscription name in the buy box\n * features: flat, ordered list of features for this subscription type\n */\ntype FeatureLists = { [K in PlanName]: { subtitle: string; categories: Array<FeatureCategory> } }\n\n/**\n * @returns the name to show to the user for the current subscription (PremiumBusiness -> Premium etc.)\n */\nexport function getDisplayNameOfPlanType(planType: PlanType): string {\n\tswitch (planType) {\n\t\tcase PlanType.PremiumBusiness:\n\t\t\treturn downcast(PlanTypeToName[PlanType.Premium])\n\t\tcase PlanType.TeamsBusiness:\n\t\t\treturn downcast(PlanTypeToName[PlanType.Teams])\n\t\tdefault:\n\t\t\treturn downcast(PlanTypeToName[planType])\n\t}\n}\n\nexport type SubscriptionPlanPrices = Record<PlanType, PlanPrices>\n\nexport const enum UpgradePriceType {\n\tPlanReferencePrice = \"0\",\n\tPlanActualPrice = \"1\",\n\tPlanNextYearsPrice = \"2\",\n\tAdditionalUserPrice = \"3\",\n\tContactFormPrice_UNUSED = \"4\",\n}\n","import { DateTime, Interval } from \"luxon\"\n\nexport function isReferenceDateWithinCyberMondayCampaign(referenceDate: Date) {\n\tconst startIso = \"2024-11-15T10:00:00+01:00\"\n\tconst endIso = \"2024-12-05T10:00:00+01:00\"\n\n\tconst cyberMonday2024Interval = Interval.fromDateTimes(DateTime.fromISO(startIso), DateTime.fromISO(endIso))\n\n\treturn cyberMonday2024Interval.contains(DateTime.fromJSDate(referenceDate))\n}\n","import { BookingItemFeatureType, Const, PaymentMethodType, PlanType, PlanTypeToName } from \"../api/common/TutanotaConstants\"\nimport { assertTranslation, lang, TranslationKey } from \"../misc/LanguageViewModel\"\nimport { assertNotNull, downcast, NBSP, neverNull } from \"@tutao/tutanota-utils\"\nimport type { AccountingInfo, PlanPrices, PriceData, PriceItemData } from \"../api/entities/sys/TypeRefs.js\"\nimport { createUpgradePriceServiceData, UpgradePriceServiceReturn } from \"../api/entities/sys/TypeRefs.js\"\nimport { UpgradePriceType, WebsitePlanPrices } from \"./FeatureListProvider\"\nimport { UpgradePriceService } from \"../api/entities/sys/Services\"\nimport { IServiceExecutor } from \"../api/common/ServiceRequest\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\nimport { UserError } from \"../api/main/UserError.js\"\nimport { isIOSApp } from \"../api/common/Env\"\nimport { MobilePlanPrice } from \"../native/common/generatedipc/MobilePlanPrice\"\nimport { locator } from \"../api/main/CommonLocator.js\"\nimport { isReferenceDateWithinCyberMondayCampaign } from \"../misc/CyberMondayUtils.js\"\n\nexport const enum PaymentInterval {\n\tMonthly = 1,\n\tYearly = 12,\n}\n\nexport function asPaymentInterval(paymentInterval: string | number): PaymentInterval {\n\tif (typeof paymentInterval === \"string\") {\n\t\tpaymentInterval = Number(paymentInterval)\n\t}\n\tswitch (paymentInterval) {\n\t\t// additional cast to make this robust against changes to the PaymentInterval enum.\n\t\tcase Number(PaymentInterval.Monthly):\n\t\t\treturn PaymentInterval.Monthly\n\t\tcase Number(PaymentInterval.Yearly):\n\t\t\treturn PaymentInterval.Yearly\n\t\tdefault:\n\t\t\tthrow new ProgrammingError(`invalid payment interval: ${paymentInterval}`)\n\t}\n}\n\nexport function getPaymentMethodName(paymentMethod: PaymentMethodType): string {\n\tif (paymentMethod === PaymentMethodType.Invoice) {\n\t\treturn lang.get(\"paymentMethodOnAccount_label\")\n\t} else if (paymentMethod === PaymentMethodType.CreditCard) {\n\t\treturn lang.get(\"paymentMethodCreditCard_label\")\n\t} else if (paymentMethod === PaymentMethodType.Sepa) {\n\t\treturn \"SEPA\"\n\t} else if (paymentMethod === PaymentMethodType.Paypal) {\n\t\treturn \"PayPal\"\n\t} else if (paymentMethod === PaymentMethodType.AccountBalance) {\n\t\treturn lang.get(\"paymentMethodAccountBalance_label\")\n\t} else if (paymentMethod === PaymentMethodType.AppStore) {\n\t\treturn \"App Store\"\n\t} else {\n\t\treturn \"<\" + lang.get(\"comboBoxSelectionNone_msg\") + \">\"\n\t}\n}\n\nexport function getPaymentMethodInfoText(accountingInfo: AccountingInfo): string {\n\tif (accountingInfo.paymentMethodInfo) {\n\t\treturn accountingInfo.paymentMethod === PaymentMethodType.CreditCard\n\t\t\t? lang.get(\"endsWith_label\") + \" \" + neverNull(accountingInfo.paymentMethodInfo)\n\t\t\t: neverNull(accountingInfo.paymentMethodInfo)\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nexport function formatPriceDataWithInfo(priceData: PriceData): string {\n\treturn formatPriceWithInfo(formatPrice(Number(priceData.price), true), asPaymentInterval(priceData.paymentInterval), priceData.taxIncluded)\n}\n\n// Used on website, keep it in sync\nexport function formatPrice(value: number, includeCurrency: boolean): string {\n\t// round to two digits first because small deviations may exist at far away decimal places\n\tvalue = Math.round(value * 100) / 100\n\n\tif (includeCurrency) {\n\t\treturn value % 1 !== 0 ? lang.formats.priceWithCurrency.format(value) : lang.formats.priceWithCurrencyWithoutFractionDigits.format(value)\n\t} else {\n\t\treturn value % 1 !== 0 ? lang.formats.priceWithoutCurrency.format(value) : lang.formats.priceWithoutCurrencyWithoutFractionDigits.format(value)\n\t}\n}\n\n/**\n * Formats the monthly price of the subscription (even for yearly subscriptions).\n */\nexport function formatMonthlyPrice(subscriptionPrice: number, paymentInterval: PaymentInterval): string {\n\tconst monthlyPrice = paymentInterval === PaymentInterval.Yearly ? subscriptionPrice / Number(PaymentInterval.Yearly) : subscriptionPrice\n\treturn formatPrice(monthlyPrice, true)\n}\n\nexport function formatPriceWithInfo(formattedPrice: string, paymentInterval: PaymentInterval, taxIncluded: boolean): string {\n\tconst netOrGross = taxIncluded ? lang.get(\"gross_label\") : lang.get(\"net_label\")\n\tconst yearlyOrMonthly = paymentInterval === PaymentInterval.Yearly ? lang.get(\"pricing.perYear_label\") : lang.get(\"pricing.perMonth_label\")\n\treturn `${formattedPrice} ${yearlyOrMonthly} (${netOrGross})`\n}\n\n/**\n * Provides the price item from the given priceData for the given featureType. Returns null if no such item is available.\n */\nexport function getPriceItem(priceData: PriceData | null, featureType: NumberString): PriceItemData | null {\n\treturn priceData?.items.find((item) => item.featureType === featureType) ?? null\n}\n\nexport function getCountFromPriceData(priceData: PriceData | null, featureType: BookingItemFeatureType): number {\n\tconst priceItem = getPriceItem(priceData, featureType)\n\treturn priceItem ? Number(priceItem.count) : 0\n}\n\n/**\n * Returns the price for the feature type from the price data if available. otherwise 0.\n * @return The price\n */\nexport function getPriceFromPriceData(priceData: PriceData | null, featureType: NumberString): number {\n\tlet item = getPriceItem(priceData, featureType)\n\n\tif (item) {\n\t\treturn Number(item.price)\n\t} else {\n\t\treturn 0\n\t}\n}\n\n// Contains the price of a subscription as both formatted and unformatted strings\nexport type SubscriptionPrice = {\n\t// The locale formatted price of a description in the local currency on iOS and in Euro elsewhere\n\tdisplayPrice: string\n\t// The raw price in the local currency on iOS and in Euro elsewhere as a float\n\trawPrice: string\n}\n\nexport class PriceAndConfigProvider {\n\tprivate upgradePriceData: UpgradePriceServiceReturn | null = null\n\tprivate planPrices: Array<PlanPrices> | null = null\n\tprivate isReferralCodeSignup: boolean = false\n\tprivate mobilePrices: Map<string, MobilePlanPrice> | null = null\n\n\tprivate constructor() {}\n\n\tprivate async init(registrationDataId: string | null, serviceExecutor: IServiceExecutor, referralCode: string | null): Promise<void> {\n\t\tconst data = createUpgradePriceServiceData({\n\t\t\tdate: Const.CURRENT_DATE,\n\t\t\tcampaign: registrationDataId,\n\t\t\treferralCode: referralCode,\n\t\t})\n\t\tthis.upgradePriceData = await serviceExecutor.get(UpgradePriceService, data)\n\t\tif (isIOSApp()) {\n\t\t\tthis.mobilePrices = new Map()\n\n\t\t\tconst allPrices = await locator.mobilePaymentsFacade.getPlanPrices()\n\t\t\tfor (const plan of allPrices) {\n\t\t\t\tthis.mobilePrices.set(plan.name, plan)\n\t\t\t}\n\t\t}\n\t\tthis.isReferralCodeSignup = referralCode != null\n\t\tthis.planPrices = this.upgradePriceData.plans\n\t}\n\n\tstatic async getInitializedInstance(\n\t\tregistrationDataId: string | null,\n\t\tserviceExecutor: IServiceExecutor,\n\t\treferralCode: string | null,\n\t): Promise<PriceAndConfigProvider> {\n\t\t// There should be only one method to request a discount either referralCode or a promotion\n\t\tif (referralCode != null && registrationDataId != null) {\n\t\t\tthrow new UserError(\"referralSignupCampaignError_msg\")\n\t\t}\n\n\t\tconst priceDataProvider = new PriceAndConfigProvider()\n\t\tawait priceDataProvider.init(registrationDataId, serviceExecutor, referralCode)\n\t\treturn priceDataProvider\n\t}\n\n\tgetSubscriptionPrice(paymentInterval: PaymentInterval, subscription: PlanType, type: UpgradePriceType): number {\n\t\treturn paymentInterval === PaymentInterval.Yearly\n\t\t\t? this.getYearlySubscriptionPrice(subscription, type)\n\t\t\t: this.getMonthlySubscriptionPrice(subscription, type)\n\t}\n\n\t/**\n\t * Returns the subscription price with the currency formatting on iOS and as a plain period seperated number on other platforms\n\t */\n\tgetSubscriptionPriceWithCurrency(paymentInterval: PaymentInterval, subscription: PlanType, type: UpgradePriceType): SubscriptionPrice {\n\t\tconst price = this.getSubscriptionPrice(paymentInterval, subscription, type)\n\t\tconst rawPrice = price.toString()\n\n\t\tif (isIOSApp()) {\n\t\t\treturn this.getAppStorePaymentsSubscriptionPrice(subscription, paymentInterval, rawPrice, type)\n\t\t} else {\n\t\t\tconst price = this.getSubscriptionPrice(paymentInterval, subscription, type)\n\t\t\treturn { displayPrice: formatPrice(price, true), rawPrice: price.toString() }\n\t\t}\n\t}\n\n\tprivate getAppStorePaymentsSubscriptionPrice(subscription: PlanType, paymentInterval: PaymentInterval, rawPrice: string, type: UpgradePriceType) {\n\t\tconst planName = PlanTypeToName[subscription]\n\t\tconst applePrices = this.getMobilePrices().get(planName.toLowerCase())\n\n\t\tif (!applePrices) {\n\t\t\tthrow new Error(`no such iOS plan ${planName}`)\n\t\t}\n\n\t\tconst isCyberMonday = isReferenceDateWithinCyberMondayCampaign(Const.CURRENT_DATE ?? new Date())\n\n\t\tswitch (paymentInterval) {\n\t\t\tcase PaymentInterval.Monthly:\n\t\t\t\treturn { displayPrice: applePrices.displayMonthlyPerMonth, rawPrice: applePrices.rawMonthlyPerMonth }\n\t\t\tcase PaymentInterval.Yearly:\n\t\t\t\treturn { displayPrice: applePrices.displayYearlyPerYear, rawPrice: applePrices.rawYearlyPerYear }\n\t\t}\n\t}\n\n\tgetRawPricingData(): UpgradePriceServiceReturn {\n\t\treturn assertNotNull(this.upgradePriceData)\n\t}\n\n\tprivate getYearlySubscriptionPrice(subscription: PlanType, upgrade: UpgradePriceType): number {\n\t\tconst prices = this.getPlanPricesForPlan(subscription)\n\t\tconst monthlyPrice = getPriceForUpgradeType(upgrade, prices)\n\t\tconst discount = upgrade === UpgradePriceType.PlanActualPrice ? Number(prices.firstYearDiscount) : 0\n\t\treturn monthlyPrice * 10 - discount\n\t}\n\n\tprivate getMonthlySubscriptionPrice(subscription: PlanType, upgrade: UpgradePriceType): number {\n\t\tconst prices = this.getPlanPricesForPlan(subscription)\n\t\treturn getPriceForUpgradeType(upgrade, prices)\n\t}\n\n\tgetMobilePrices(): Map<string, MobilePlanPrice> {\n\t\treturn assertNotNull(this.mobilePrices)\n\t}\n\n\tgetPlanPricesForPlan(subscription: PlanType): PlanPrices {\n\t\tconst planPrices = assertNotNull(this.planPrices, \"called getPlanPricesForPlan before init\")\n\t\treturn assertNotNull(\n\t\t\tplanPrices.find((prices) => PlanTypeToName[subscription] === prices.planName),\n\t\t\t\"plan type not found\",\n\t\t)\n\t}\n\n\tgetPriceInfoMessage(): TranslationKey | null {\n\t\tconst rawData = this.getRawPricingData()\n\t\tconst bonusMonthMessage = getReasonForBonusMonths(Number(rawData.bonusMonthsForYearlyPlan), this.isReferralCodeSignup)\n\t\tif (bonusMonthMessage) {\n\t\t\treturn bonusMonthMessage\n\t\t} else if (rawData.messageTextId) {\n\t\t\t// text id that is specified by a promotion.\n\t\t\treturn assertTranslation(rawData.messageTextId)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n}\n\nfunction getPriceForUpgradeType(upgrade: UpgradePriceType, prices: WebsitePlanPrices): number {\n\tswitch (upgrade) {\n\t\tcase UpgradePriceType.PlanReferencePrice:\n\t\t\treturn Number(prices.monthlyReferencePrice)\n\t\tcase UpgradePriceType.PlanActualPrice:\n\t\tcase UpgradePriceType.PlanNextYearsPrice:\n\t\t\treturn Number(prices.monthlyPrice)\n\t\tcase UpgradePriceType.AdditionalUserPrice:\n\t\t\treturn Number(prices.additionalUserPriceMonthly)\n\t\tcase UpgradePriceType.ContactFormPrice_UNUSED:\n\t\t\tthrow new ProgrammingError(\"invalid price type\")\n\t}\n}\n\nfunction descendingSubscriptionOrder(): Array<PlanType> {\n\treturn [PlanType.Unlimited, PlanType.Advanced, PlanType.Legend, PlanType.Essential, PlanType.Revolutionary]\n}\n\n/**\n * Returns true if the targetSubscription plan is considered to be a lower (~ cheaper) subscription plan\n * Is based on the order of business and non-business subscriptions as defined in descendingSubscriptionOrder\n */\nexport function isSubscriptionDowngrade(targetSubscription: PlanType, currentSubscription: PlanType): boolean {\n\tconst order = descendingSubscriptionOrder()\n\tif (Object.values(PlanType).includes(downcast(currentSubscription))) {\n\t\treturn order.indexOf(targetSubscription) > order.indexOf(downcast(currentSubscription))\n\t} else {\n\t\treturn false\n\t}\n}\n\n/**\n * Helper function to determine the reason for bonus months that have be provided by the UpgradePriceService\n * @param bonusMonths The amount of bonus month\n * @param isReferralCodeSignup Indication if a referral code has been used to query the bonus months.\n */\nfunction getReasonForBonusMonths(bonusMonths: number, isReferralCodeSignup: boolean): TranslationKey | null {\n\tif (bonusMonths == 12) {\n\t\treturn \"chooseYearlyForOffer_msg\"\n\t} else if (bonusMonths == 1) {\n\t\treturn \"referralSignup_msg\"\n\t} else if (bonusMonths == 0 && isReferralCodeSignup) {\n\t\treturn \"referralSignupInvalid_msg\"\n\t} else {\n\t\treturn null\n\t}\n}\n"],"mappings":"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"}