{"version":3,"file":"UsageTestModel-CjGx3RZo.js","names":["UsageTestAssignmentTypeRef: TypeRef<UsageTestAssignment>","UsageTestAssignmentInTypeRef: TypeRef<UsageTestAssignmentIn>","values: StrippedEntity<UsageTestAssignmentIn>","UsageTestAssignmentOutTypeRef: TypeRef<UsageTestAssignmentOut>","UsageTestMetricConfigTypeRef: TypeRef<UsageTestMetricConfig>","UsageTestMetricConfigValueTypeRef: TypeRef<UsageTestMetricConfigValue>","UsageTestMetricDataTypeRef: TypeRef<UsageTestMetricData>","values: StrippedEntity<UsageTestMetricData>","UsageTestParticipationInTypeRef: TypeRef<UsageTestParticipationIn>","values: StrippedEntity<UsageTestParticipationIn>","UsageTestStageTypeRef: TypeRef<UsageTestStage>","persistedAssignmentData: PersistedAssignmentData","testDeviceId: string","storages: { [key in StorageBehavior]: UsageTestStorage }","dateProvider: DateProvider","serviceExecutor: IServiceExecutor","entityClient: EntityClient","loginController: LoginController","eventController: EventController","usageTestController: () => UsageTestController","updates: ReadonlyArray<EntityUpdateData>","test: string","variant: number","storageBehavior: StorageBehavior","decision: boolean","response: UsageTestAssignmentOut","assignments: UsageTestAssignment[]","test: UsageTest","stage: Stage"],"sources":["../../src/common/api/entities/usage/TypeRefs.ts","../../packages/tutanota-usagetests/dist/model/Stage.js","../../packages/tutanota-usagetests/dist/model/UsageTest.js","../../packages/tutanota-usagetests/dist/model/UsageTestController.js","../../src/common/api/entities/usage/Services.ts","../../src/common/misc/UsageTestModel.ts"],"sourcesContent":["import { create, Stripped, StrippedEntity } from \"../../common/utils/EntityUtils.js\"\nimport { TypeRef } from \"@tutao/tutanota-utils\"\nimport { typeModels } from \"./TypeModels.js\"\n\n\nexport const UsageTestAssignmentTypeRef: TypeRef<UsageTestAssignment> = new TypeRef(\"usage\", \"UsageTestAssignment\")\n\nexport function createUsageTestAssignment(values: StrippedEntity<UsageTestAssignment>): UsageTestAssignment {\n\treturn Object.assign(create(typeModels.UsageTestAssignment, UsageTestAssignmentTypeRef), values)\n}\n\nexport type UsageTestAssignment = {\n\t_type: TypeRef<UsageTestAssignment>;\n\n\t_id: Id;\n\tname: string;\n\tsendPings: boolean;\n\ttestId: Id;\n\tvariant: null | NumberString;\n\n\tstages: UsageTestStage[];\n}\nexport const UsageTestAssignmentInTypeRef: TypeRef<UsageTestAssignmentIn> = new TypeRef(\"usage\", \"UsageTestAssignmentIn\")\n\nexport function createUsageTestAssignmentIn(values: StrippedEntity<UsageTestAssignmentIn>): UsageTestAssignmentIn {\n\treturn Object.assign(create(typeModels.UsageTestAssignmentIn, UsageTestAssignmentInTypeRef), values)\n}\n\nexport type UsageTestAssignmentIn = {\n\t_type: TypeRef<UsageTestAssignmentIn>;\n\n\t_format: NumberString;\n\ttestDeviceId: null | Id;\n}\nexport const UsageTestAssignmentOutTypeRef: TypeRef<UsageTestAssignmentOut> = new TypeRef(\"usage\", \"UsageTestAssignmentOut\")\n\nexport function createUsageTestAssignmentOut(values: StrippedEntity<UsageTestAssignmentOut>): UsageTestAssignmentOut {\n\treturn Object.assign(create(typeModels.UsageTestAssignmentOut, UsageTestAssignmentOutTypeRef), values)\n}\n\nexport type UsageTestAssignmentOut = {\n\t_type: TypeRef<UsageTestAssignmentOut>;\n\n\t_format: NumberString;\n\ttestDeviceId: Id;\n\n\tassignments: UsageTestAssignment[];\n}\nexport const UsageTestMetricConfigTypeRef: TypeRef<UsageTestMetricConfig> = new TypeRef(\"usage\", \"UsageTestMetricConfig\")\n\nexport function createUsageTestMetricConfig(values: StrippedEntity<UsageTestMetricConfig>): UsageTestMetricConfig {\n\treturn Object.assign(create(typeModels.UsageTestMetricConfig, UsageTestMetricConfigTypeRef), values)\n}\n\nexport type UsageTestMetricConfig = {\n\t_type: TypeRef<UsageTestMetricConfig>;\n\n\t_id: Id;\n\tname: string;\n\ttype: NumberString;\n\n\tconfigValues: UsageTestMetricConfigValue[];\n}\nexport const UsageTestMetricConfigValueTypeRef: TypeRef<UsageTestMetricConfigValue> = new TypeRef(\"usage\", \"UsageTestMetricConfigValue\")\n\nexport function createUsageTestMetricConfigValue(values: StrippedEntity<UsageTestMetricConfigValue>): UsageTestMetricConfigValue {\n\treturn Object.assign(create(typeModels.UsageTestMetricConfigValue, UsageTestMetricConfigValueTypeRef), values)\n}\n\nexport type UsageTestMetricConfigValue = {\n\t_type: TypeRef<UsageTestMetricConfigValue>;\n\n\t_id: Id;\n\tkey: string;\n\tvalue: string;\n}\nexport const UsageTestMetricDataTypeRef: TypeRef<UsageTestMetricData> = new TypeRef(\"usage\", \"UsageTestMetricData\")\n\nexport function createUsageTestMetricData(values: StrippedEntity<UsageTestMetricData>): UsageTestMetricData {\n\treturn Object.assign(create(typeModels.UsageTestMetricData, UsageTestMetricDataTypeRef), values)\n}\n\nexport type UsageTestMetricData = {\n\t_type: TypeRef<UsageTestMetricData>;\n\n\t_id: Id;\n\tname: string;\n\tvalue: string;\n}\nexport const UsageTestParticipationInTypeRef: TypeRef<UsageTestParticipationIn> = new TypeRef(\"usage\", \"UsageTestParticipationIn\")\n\nexport function createUsageTestParticipationIn(values: StrippedEntity<UsageTestParticipationIn>): UsageTestParticipationIn {\n\treturn Object.assign(create(typeModels.UsageTestParticipationIn, UsageTestParticipationInTypeRef), values)\n}\n\nexport type UsageTestParticipationIn = {\n\t_type: TypeRef<UsageTestParticipationIn>;\n\n\t_format: NumberString;\n\tstage: NumberString;\n\ttestDeviceId: Id;\n\ttestId: Id;\n\n\tmetrics: UsageTestMetricData[];\n}\nexport const UsageTestStageTypeRef: TypeRef<UsageTestStage> = new TypeRef(\"usage\", \"UsageTestStage\")\n\nexport function createUsageTestStage(values: StrippedEntity<UsageTestStage>): UsageTestStage {\n\treturn Object.assign(create(typeModels.UsageTestStage, UsageTestStageTypeRef), values)\n}\n\nexport type UsageTestStage = {\n\t_type: TypeRef<UsageTestStage>;\n\n\t_id: Id;\n\tmaxPings: NumberString;\n\tminPings: NumberString;\n\tname: string;\n\n\tmetrics: UsageTestMetricConfig[];\n}\n","/** One part of the test. Has multiple metrics that are sent together. */\nexport class Stage {\n    number;\n    test;\n    minPings;\n    maxPings;\n    collectedMetrics = new Map();\n    metricConfigs = new Map();\n    constructor(number, test, minPings, maxPings) {\n        this.number = number;\n        this.test = test;\n        this.minPings = minPings;\n        this.maxPings = maxPings;\n    }\n    /**\n     * Attempts to complete the stage and returns true if a ping has been sent successfully.\n     */\n    async complete() {\n        return await this.test.completeStage(this);\n    }\n    setMetric(metric) {\n        this.collectedMetrics.set(metric.name, metric);\n    }\n    setMetricConfig(metricConfig) {\n        this.metricConfigs.set(metricConfig.name, metricConfig);\n    }\n}\nexport class ObsoleteStage extends Stage {\n    async complete() {\n        return true;\n    }\n    setMetric(metric) {\n        // no op\n    }\n}\n","import { ObsoleteStage } from \"./Stage.js\";\nconst NO_PARTICIPATION_VARIANT = 0;\nconst ASSIGNMENT_STAGE = -1;\n/** Holds all variants and can render current variant. Combines a test's config and the user's assignment. */\nexport class UsageTest {\n    testId;\n    testName;\n    variant;\n    active;\n    stages = new Map();\n    pingAdapter;\n    lastCompletedStage = 0;\n    // storage for data that is aggregated across stages and sent at some point\n    meta = {};\n    /**\n     * Enabling this makes it possible to restart a test even if the last stage has not been sent.\n     */\n    allowEarlyRestarts = false;\n    sentPings = 0;\n    started = false;\n    // Enables recording the time that has passed since the last ping (and attaching it as a metric 'secondsPassed')\n    recordTime = false;\n    lastPingDate;\n    constructor(testId, testName, variant, active) {\n        this.testId = testId;\n        this.testName = testName;\n        this.variant = variant;\n        this.active = active;\n    }\n    /**\n    Tries to restart the test (by sending stage 0) regardless of the allowEarlyRestarts setting\n     */\n    forceRestart() {\n        return this.completeStage(this.getStage(0), true);\n    }\n    isStarted() {\n        return this.started;\n    }\n    getStage(stageNum) {\n        const stage = this.stages.get(stageNum);\n        if (!stage) {\n            console.log(`Stage ${stageNum} is not registered, meaning that test '${this.testName}' is likely misconfigured`);\n            return new ObsoleteStage(0, this, 0, 0);\n        }\n        return stage;\n    }\n    addStage(stage) {\n        if (this.stages.get(stage.number)) {\n            throw new Error(`Stage ${stage.number} is already registered`);\n        }\n        this.stages.set(stage.number, stage);\n        return stage;\n    }\n    getVariant(variants) {\n        return variants[this.variant]();\n    }\n    /**\n     * Completes a range of stages in the case that we want to make sure that previous stages are/have been sent.\n     *\n     * Useful when reaching a stage necessitates (and implies) that all previous stages have been sent successfully.\n     */\n    async completeRange(start, end) {\n        for (let i = start; i <= end; i++) {\n            await this.getStage(i).complete();\n        }\n    }\n    /**\n     * Should not be used directly. Use stage.complete() instead.\n     */\n    async completeStage(stage, forceRestart = false) {\n        if (!this.pingAdapter) {\n            throw new Error(\"no ping adapter has been registered\");\n        }\n        else if (this.variant === NO_PARTICIPATION_VARIANT || !this.active) {\n            return false;\n        }\n        else if (this.sentPings >= stage.maxPings && this.lastCompletedStage === stage.number && (stage.number !== 0 || !this.allowEarlyRestarts)) {\n            console.log(`Not sending ping for stage (${stage.number}) of test '${this.testId}' because maxPings=${stage.maxPings} has been reached`);\n            return false;\n        }\n        else if (!forceRestart && !this.allowEarlyRestarts && this.isStarted() && stage.number === 0 && this.lastCompletedStage !== this.stages.size - 1) {\n            // we were not configured to restart and got a complete() for the first stage and have not finished the test yet\n            // -> this would be a restart in the middle of the test\n            console.log(`Cannot restart test '${this.testName}' because allowEarlyRestarts=false and the final stage has not been reached`);\n            return false;\n        }\n        else if (stage.number < this.lastCompletedStage && stage.number !== 0) {\n            console.log(`Cannot send ping for stage (${stage.number}) of test '${this.testId}' because stage ${this.lastCompletedStage} has already been sent`);\n            return false;\n        }\n        for (let i = this.lastCompletedStage + 1; i < stage.number; i++) {\n            let currentStage = this.stages.get(i);\n            if (!!currentStage && currentStage.minPings != 0) {\n                console.log(`Not sending ping for stage (${stage.number}) in wrong order of test '${this.testId}' because stage ${currentStage.number} is not finished`);\n                return false;\n            }\n        }\n        console.log(`Test '${this.testName}': Completing stage ${stage.number}, variant ${this.variant}`);\n        this.sentPings = stage.number === this.lastCompletedStage ? this.sentPings + 1 : 1;\n        this.lastCompletedStage = stage.number;\n        if (this.recordTime) {\n            const currentDate = new Date();\n            if (stage.number > 0) {\n                const secondsPassed = this.lastPingDate ? (currentDate.getTime() - this.lastPingDate.getTime()) / 1000 : 0;\n                stage.setMetric({\n                    name: \"secondsPassed\",\n                    value: secondsPassed.toString(),\n                });\n            }\n            this.lastPingDate = currentDate;\n        }\n        await this.pingAdapter.sendPing(this, stage);\n        this.started = true;\n        return true;\n    }\n}\nexport class ObsoleteUsageTest extends UsageTest {\n    obsoleteStage;\n    constructor(testId, testName, variant) {\n        super(testId, testName, variant, false);\n        this.obsoleteStage = new ObsoleteStage(0, this, 1, 1);\n    }\n    getStage(stageNum) {\n        return this.obsoleteStage;\n    }\n    addStage(stage) {\n        return this.obsoleteStage;\n    }\n    getVariant(variants) {\n        return variants[0]();\n    }\n    async completeStage(stage) {\n        return true;\n    }\n}\n","import { ObsoleteUsageTest } from \"./UsageTest.js\";\n/** Centralized place which holds all the {@link UsageTest}s. */\nexport class UsageTestController {\n    pingAdapter;\n    tests = new Map();\n    obsoleteUsageTest = new ObsoleteUsageTest(\"obsolete\", \"obsolete\", 0);\n    constructor(pingAdapter) {\n        this.pingAdapter = pingAdapter;\n    }\n    addTest(test) {\n        test.pingAdapter = this.pingAdapter;\n        this.tests.set(test.testId, test);\n    }\n    addTests(tests) {\n        for (let test of tests) {\n            this.addTest(test);\n        }\n    }\n    setTests(tests) {\n        this.tests.clear();\n        this.addTests(tests);\n    }\n    /**\n     * Searches a test first by its ID and then, if no match is found, by its name.\n     * If no test matches by name either, then we assume that the test is finished and the server no longer sends assignments for it.\n     * In that case, we want to render the no-participation variant, so a sham test instance needs to be returned.\n     *\n     * @param testIdOrName The test's ID or its name\n     */\n    getTest(testIdOrName) {\n        let result = this.tests.get(testIdOrName);\n        if (result) {\n            return result;\n        }\n        for (let test of this.tests.values()) {\n            if (test.testName === testIdOrName) {\n                return test;\n            }\n        }\n        console.log(`Test '${testIdOrName}' not found, using obsolete...`);\n        return this.obsoleteUsageTest;\n    }\n    /**\n     * some components are used in multiple places, but only want to do a test in one of them.\n     * use this to get a test that always renders variant 0 and doesn't send pings.\n     */\n    getObsoleteTest() {\n        return this.obsoleteUsageTest;\n    }\n}\n","import { UsageTestAssignmentInTypeRef } from \"./TypeRefs.js\"\nimport { UsageTestAssignmentOutTypeRef } from \"./TypeRefs.js\"\nimport { UsageTestParticipationInTypeRef } from \"./TypeRefs.js\"\n\nexport const UsageTestAssignmentService = Object.freeze({\n\tapp: \"usage\",\n\tname: \"UsageTestAssignmentService\",\n\tget: null,\n\tpost: { data: UsageTestAssignmentInTypeRef, return: UsageTestAssignmentOutTypeRef },\n\tput: { data: UsageTestAssignmentInTypeRef, return: UsageTestAssignmentOutTypeRef },\n\tdelete: null,\n} as const)\n\nexport const UsageTestParticipationService = Object.freeze({\n\tapp: \"usage\",\n\tname: \"UsageTestParticipationService\",\n\tget: null,\n\tpost: { data: UsageTestParticipationInTypeRef, return: null },\n\tput: null,\n\tdelete: null,\n} as const)","import {\n\tcreateUsageTestAssignmentIn,\n\tcreateUsageTestMetricData,\n\tcreateUsageTestParticipationIn,\n\tUsageTestAssignment,\n\tUsageTestAssignmentOut,\n\tUsageTestAssignmentTypeRef,\n} from \"../api/entities/usage/TypeRefs.js\"\nimport { PingAdapter, Stage, UsageTest, UsageTestController } from \"@tutao/tutanota-usagetests\"\nimport { assertNotNull, filterInt, lazy, neverNull } from \"@tutao/tutanota-utils\"\nimport { BadRequestError, NotFoundError, PreconditionFailedError } from \"../api/common/error/RestError\"\nimport { UsageTestMetricType } from \"../api/common/TutanotaConstants\"\nimport { SuspensionError } from \"../api/common/error/SuspensionError\"\nimport { SuspensionBehavior } from \"../api/worker/rest/RestClient\"\nimport { DateProvider } from \"../api/common/DateProvider.js\"\nimport { IServiceExecutor } from \"../api/common/ServiceRequest\"\nimport { UsageTestAssignmentService, UsageTestParticipationService } from \"../api/entities/usage/Services.js\"\nimport { resolveTypeReference } from \"../api/common/EntityFunctions\"\nimport { lang, TranslationKey } from \"./LanguageViewModel\"\nimport stream from \"mithril/stream\"\nimport { Dialog, DialogType } from \"../gui/base/Dialog\"\nimport { DropDownSelector, SelectorItem } from \"../gui/base/DropDownSelector\"\nimport m, { Children } from \"mithril\"\nimport { isOfflineError } from \"../api/common/utils/ErrorUtils.js\"\nimport { LoginController } from \"../api/main/LoginController.js\"\nimport { CustomerProperties, CustomerPropertiesTypeRef, CustomerTypeRef } from \"../api/entities/sys/TypeRefs.js\"\nimport { EntityClient } from \"../api/common/EntityClient.js\"\nimport { EventController } from \"../api/main/EventController.js\"\nimport { createUserSettingsGroupRoot, UserSettingsGroupRootTypeRef } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../api/common/utils/EntityUpdateUtils.js\"\n\nconst PRESELECTED_LIKERT_VALUE = null\n\ntype ExperienceSamplingOptions = {\n\ttitle?: TranslationKey\n\texplanationText?: TranslationKey\n\tperMetric: {\n\t\t[key: string]: {\n\t\t\tquestion: TranslationKey\n\t\t\tanswerOptions: Array<string>\n\t\t}\n\t}\n}\n\nexport async function showExperienceSamplingDialog(stage: Stage, experienceSamplingOptions: ExperienceSamplingOptions): Promise<void> {\n\tconst likertMetrics = Array.from(stage.metricConfigs.values()).filter(\n\t\t(metricConfig) => (metricConfig.type as UsageTestMetricType) === UsageTestMetricType.Likert,\n\t)\n\tconst selectedValues = new Map(likertMetrics.map((likertMetric) => [likertMetric.name, stream(PRESELECTED_LIKERT_VALUE)]))\n\n\tDialog.showActionDialog({\n\t\ttype: DialogType.EditMedium,\n\t\tokAction: (dialog: Dialog) => {\n\t\t\tfor (let [metricName, selectedValue] of selectedValues) {\n\t\t\t\tconst selection = selectedValue()\n\n\t\t\t\tif (selection === null) {\n\t\t\t\t\t// User did not select an answer\n\t\t\t\t\treturn Dialog.message(\"experienceSamplingSelectAnswer_msg\")\n\t\t\t\t}\n\n\t\t\t\tstage.setMetric({\n\t\t\t\t\tname: metricName,\n\t\t\t\t\tvalue: selection,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tstage.complete().then(() => dialog.close())\n\t\t\treturn Dialog.message(\"experienceSamplingThankYou_msg\")\n\t\t},\n\t\ttitle: experienceSamplingOptions.title ?? \"experienceSamplingHeader_label\",\n\t\tchild: () => {\n\t\t\tconst children: Array<Children> = []\n\n\t\t\tif (experienceSamplingOptions.explanationText) {\n\t\t\t\tconst explanationTextLines = lang.getTranslationText(experienceSamplingOptions.explanationText).split(\"\\n\")\n\n\t\t\t\tchildren.push(\n\t\t\t\t\tm(\"#dialog-message.text-break.text-prewrap.selectable.scroll\", [explanationTextLines.map((line) => m(\".text-break.selectable\", line))]),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tfor (let likertMetricConfig of likertMetrics) {\n\t\t\t\tconst metricOptions = experienceSamplingOptions[\"perMetric\"][likertMetricConfig.name]\n\n\t\t\t\tconst answerOptionItems: Array<SelectorItem<string>> = metricOptions.answerOptions.map((answerOption, index) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: answerOption,\n\t\t\t\t\t\tvalue: (index + 1).toString(),\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tchildren.push(m(\"p.text-prewrap.scroll\", lang.getTranslationText(metricOptions.question)))\n\n\t\t\t\tchildren.push(\n\t\t\t\t\tm(DropDownSelector, {\n\t\t\t\t\t\tlabel: \"experienceSamplingAnswer_label\",\n\t\t\t\t\t\titems: answerOptionItems,\n\t\t\t\t\t\tselectedValue: selectedValues.get(likertMetricConfig.name)!,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn children\n\t\t},\n\t})\n}\n\nexport interface PersistedAssignmentData {\n\tupdatedAt: number\n\tassignments: UsageTestAssignment[]\n\tusageModelVersion: number\n}\n\nexport interface UsageTestStorage {\n\tgetTestDeviceId(): Promise<string | null>\n\n\tstoreTestDeviceId(testDeviceId: string): Promise<void>\n\n\tgetAssignments(): Promise<PersistedAssignmentData | null>\n\n\tstoreAssignments(persistedAssignmentData: PersistedAssignmentData): Promise<void>\n}\n\nexport class EphemeralUsageTestStorage implements UsageTestStorage {\n\tprivate assignments: PersistedAssignmentData | null = null\n\tprivate testDeviceId: string | null = null\n\n\tgetAssignments(): Promise<PersistedAssignmentData | null> {\n\t\treturn Promise.resolve(this.assignments)\n\t}\n\n\tgetTestDeviceId(): Promise<string | null> {\n\t\treturn Promise.resolve(this.testDeviceId)\n\t}\n\n\tstoreAssignments(persistedAssignmentData: PersistedAssignmentData): Promise<void> {\n\t\tthis.assignments = persistedAssignmentData\n\t\treturn Promise.resolve()\n\t}\n\n\tstoreTestDeviceId(testDeviceId: string): Promise<void> {\n\t\tthis.testDeviceId = testDeviceId\n\t\treturn Promise.resolve()\n\t}\n}\n\nexport const ASSIGNMENT_UPDATE_INTERVAL_MS = 1000 * 60 * 60 // 1h\n\nexport const enum StorageBehavior {\n\t/* Store usage test assignments in the \"persistent\" storage. Currently, this is the client's instance of DeviceConfig, which uses the browser's local storage.\n\tUse if the user is logged in and has opted in to sending usage data. */\n\tPersist,\n\t/* Store usage test assignments in the \"ephemeral\" storage. Currently, this is an instance of EphemeralUsageTestStorage.\n\tUse if the user is not logged in. */\n\tEphemeral,\n}\n\nexport class UsageTestModel implements PingAdapter {\n\tprivate storageBehavior = StorageBehavior.Ephemeral\n\tprivate customerProperties?: CustomerProperties\n\tprivate lastOptInDecision: boolean | null = null\n\tprivate lastPing = Promise.resolve()\n\n\tconstructor(\n\t\tprivate readonly storages: { [key in StorageBehavior]: UsageTestStorage },\n\t\tprivate readonly dateProvider: DateProvider,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly loginController: LoginController,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly usageTestController: () => UsageTestController,\n\t) {\n\t\teventController.addEntityListener((updates: ReadonlyArray<EntityUpdateData>) => {\n\t\t\treturn this.entityEventsReceived(updates)\n\t\t})\n\t}\n\n\tasync entityEventsReceived(updates: ReadonlyArray<EntityUpdateData>) {\n\t\tfor (const update of updates) {\n\t\t\tif (isUpdateForTypeRef(CustomerPropertiesTypeRef, update)) {\n\t\t\t\tawait this.loginController.waitForFullLogin()\n\t\t\t\tawait this.updateCustomerProperties()\n\t\t\t} else if (isUpdateForTypeRef(UserSettingsGroupRootTypeRef, update)) {\n\t\t\t\tawait this.loginController.waitForFullLogin()\n\t\t\t\tconst updatedOptInDecision = this.loginController.getUserController().userSettingsGroupRoot.usageDataOptedIn\n\n\t\t\t\tif (this.lastOptInDecision === updatedOptInDecision) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Opt-in decision has changed, load tests\n\t\t\t\tconst tests = await this.loadActiveUsageTests()\n\t\t\t\tthis.usageTestController().setTests(tests)\n\t\t\t\tthis.lastOptInDecision = updatedOptInDecision\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * only for usage from the console. may have unintended consequences when used too early or too late.\n\t * @param test the name of the test to change the variant on\n\t * @param variant the number of the variant to use from here on\n\t */\n\tprivate setVariant(test: string, variant: number) {\n\t\tthis.usageTestController().getTest(test).variant = variant\n\t}\n\n\tprivate async updateCustomerProperties() {\n\t\tconst customer = await this.entityClient.load(CustomerTypeRef, neverNull(this.loginController.getUserController().user.customer))\n\t\tthis.customerProperties = await this.entityClient.load(CustomerPropertiesTypeRef, neverNull(customer.properties))\n\t}\n\n\t/**\n\t * Needs to be called after construction, ideally after login, so that the logged-in user's CustomerProperties are loaded.\n\t */\n\tasync init() {\n\t\tawait this.updateCustomerProperties()\n\t}\n\n\tsetStorageBehavior(storageBehavior: StorageBehavior) {\n\t\tthis.storageBehavior = storageBehavior\n\t}\n\n\tprivate storage() {\n\t\treturn this.storages[this.storageBehavior]\n\t}\n\n\t/**\n\t * Returns true if the customer has opted out.\n\t * Defaults to true if init() has not been called.\n\t */\n\tisCustomerOptedOut(): boolean {\n\t\treturn this.customerProperties?.usageDataOptedOut ?? true\n\t}\n\n\t/**\n\t * Returns true if the opt-in dialog indicator should be shown, depending on the user's and the customer's decisions.\n\t * Defaults to false if init() has not been called.\n\t */\n\tshowOptInIndicator(): boolean {\n\t\tif (!this.loginController.isUserLoggedIn() || this.isCustomerOptedOut()) {\n\t\t\t// shortcut if customer has opted out (or is not logged in)\n\t\t\treturn false\n\t\t}\n\n\t\treturn this.loginController.getUserController().userSettingsGroupRoot.usageDataOptedIn === null\n\t}\n\n\t/**\n\t * Sets the user's usage data opt-in decision. True means they opt in.\n\t *\n\t * Immediately refetches the user's active usage tests if they opted in.\n\t */\n\tpublic async setOptInDecision(decision: boolean) {\n\t\tconst userSettingsGroupRoot = createUserSettingsGroupRoot(this.loginController.getUserController().userSettingsGroupRoot)\n\t\tuserSettingsGroupRoot.usageDataOptedIn = decision\n\n\t\tawait this.entityClient.update(userSettingsGroupRoot)\n\t\tthis.lastOptInDecision = decision\n\n\t\t// we need to unset the tests in case of an opt-out because otherwise we might keep using them\n\t\t// in case of an opt-in we need to load them because they might not yet have been loaded\n\t\tconst tests = decision ? await this.doLoadActiveUsageTests() : []\n\t\tthis.usageTestController().setTests(tests)\n\t}\n\n\tprivate getOptInDecision(): boolean {\n\t\tif (!this.loginController.isUserLoggedIn()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst userOptIn = this.loginController.getUserController().userSettingsGroupRoot.usageDataOptedIn\n\n\t\tif (!userOptIn) {\n\t\t\t// shortcut if userOptIn not set or equal to false\n\t\t\treturn false\n\t\t}\n\n\t\t// customer opt-out overrides the user setting\n\t\treturn !assertNotNull(this.customerProperties).usageDataOptedOut\n\t}\n\n\t/**\n\t * If the storageBehavior is set to StorageBehavior.Persist, then init() must have been called before calling this method.\n\t */\n\tasync loadActiveUsageTests() {\n\t\tif (this.storageBehavior === StorageBehavior.Persist && !this.getOptInDecision()) {\n\t\t\treturn []\n\t\t}\n\n\t\treturn await this.doLoadActiveUsageTests()\n\t}\n\n\tprivate async doLoadActiveUsageTests() {\n\t\tconst persistedData = await this.storage().getAssignments()\n\t\tconst modelVersion = await this.modelVersion()\n\n\t\tif (persistedData == null || persistedData.usageModelVersion !== modelVersion || Date.now() - persistedData.updatedAt > ASSIGNMENT_UPDATE_INTERVAL_MS) {\n\t\t\treturn this.assignmentsToTests(await this.loadAssignments())\n\t\t} else {\n\t\t\treturn this.assignmentsToTests(persistedData.assignments)\n\t\t}\n\t}\n\n\tprivate async modelVersion(): Promise<number> {\n\t\tconst model = await resolveTypeReference(UsageTestAssignmentTypeRef)\n\t\treturn filterInt(model.version)\n\t}\n\n\tprivate async loadAssignments(): Promise<UsageTestAssignment[]> {\n\t\tconst testDeviceId = await this.storage().getTestDeviceId()\n\t\tconst data = createUsageTestAssignmentIn({\n\t\t\ttestDeviceId: testDeviceId,\n\t\t})\n\n\t\ttry {\n\t\t\tconst response: UsageTestAssignmentOut = testDeviceId\n\t\t\t\t? await this.serviceExecutor.put(UsageTestAssignmentService, data, {\n\t\t\t\t\t\tsuspensionBehavior: SuspensionBehavior.Throw,\n\t\t\t\t  })\n\t\t\t\t: await this.serviceExecutor.post(UsageTestAssignmentService, data, {\n\t\t\t\t\t\tsuspensionBehavior: SuspensionBehavior.Throw,\n\t\t\t\t  })\n\t\t\tawait this.storage().storeTestDeviceId(response.testDeviceId)\n\t\t\tawait this.storage().storeAssignments({\n\t\t\t\tassignments: response.assignments,\n\t\t\t\tupdatedAt: this.dateProvider.now(),\n\t\t\t\tusageModelVersion: await this.modelVersion(),\n\t\t\t})\n\n\t\t\treturn response.assignments\n\t\t} catch (e) {\n\t\t\tif (e instanceof SuspensionError) {\n\t\t\t\tconsole.log(\"rate-limit for new assignments reached, disabling tests\")\n\t\t\t\treturn []\n\t\t\t} else if (isOfflineError(e)) {\n\t\t\t\tconsole.log(\"offline, disabling tests\")\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tprivate assignmentsToTests(assignments: UsageTestAssignment[]): UsageTest[] {\n\t\treturn assignments.map((usageTestAssignment) => {\n\t\t\tconst test = new UsageTest(usageTestAssignment.testId, usageTestAssignment.name, Number(usageTestAssignment.variant), usageTestAssignment.sendPings)\n\n\t\t\tfor (const [index, stageConfig] of usageTestAssignment.stages.entries()) {\n\t\t\t\tconst stage = new Stage(index, test, Number(stageConfig.minPings), Number(stageConfig.maxPings))\n\t\t\t\tfor (const metricConfig of stageConfig.metrics) {\n\t\t\t\t\tconst configValues = new Map<string, string>()\n\n\t\t\t\t\tfor (const metricConfigValue of metricConfig.configValues) {\n\t\t\t\t\t\tconfigValues.set(metricConfigValue.key, metricConfigValue.value)\n\t\t\t\t\t}\n\n\t\t\t\t\tstage.setMetricConfig({\n\t\t\t\t\t\tname: metricConfig.name,\n\t\t\t\t\t\ttype: metricConfig.type,\n\t\t\t\t\t\tconfigValues,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\ttest.addStage(stage)\n\t\t\t}\n\n\t\t\treturn test\n\t\t})\n\t}\n\n\tasync sendPing(test: UsageTest, stage: Stage): Promise<void> {\n\t\tthis.lastPing = this.lastPing.then(\n\t\t\t() => this.doSendPing(stage, test),\n\t\t\t() => this.doSendPing(stage, test),\n\t\t)\n\t\treturn this.lastPing\n\t}\n\n\tprivate async doSendPing(stage: Stage, test: UsageTest) {\n\t\t// Immediately stop sending pings if the user has opted out.\n\t\t// Only applicable if the user opts out and then does not re-log.\n\t\tif (this.storageBehavior === StorageBehavior.Persist && !this.getOptInDecision()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst testDeviceId = await this.storage().getTestDeviceId()\n\t\tif (testDeviceId == null) {\n\t\t\tconsole.warn(\"No device id set before sending pings\")\n\t\t\treturn\n\t\t}\n\n\t\tconst metrics = Array.from(stage.collectedMetrics).map(([key, { name, value }]) =>\n\t\t\tcreateUsageTestMetricData({\n\t\t\t\tname: name,\n\t\t\t\tvalue: value,\n\t\t\t}),\n\t\t)\n\n\t\tconst data = createUsageTestParticipationIn({\n\t\t\ttestId: test.testId,\n\t\t\tmetrics,\n\t\t\tstage: stage.number.toString(),\n\t\t\ttestDeviceId: testDeviceId,\n\t\t})\n\n\t\ttry {\n\t\t\tawait this.serviceExecutor.post(UsageTestParticipationService, data, {\n\t\t\t\tsuspensionBehavior: SuspensionBehavior.Throw,\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tif (e instanceof SuspensionError) {\n\t\t\t\ttest.active = false\n\t\t\t\tconsole.log(\"rate-limit for pings reached\")\n\t\t\t} else if (e instanceof PreconditionFailedError) {\n\t\t\t\tif (e.data === \"invalid_state\") {\n\t\t\t\t\ttest.active = false\n\t\t\t\t\tconsole.log(`Tried to send ping for paused test ${test.testName}`, e)\n\t\t\t\t} else if (e.data === \"invalid_restart\") {\n\t\t\t\t\ttest.active = false\n\t\t\t\t\tconsole.log(`Tried to restart test '${test.testName}' in ParticipationMode.Once that device has already participated in`, e)\n\t\t\t\t} else if (e.data === \"invalid_stage\") {\n\t\t\t\t\tconsole.log(`Tried to send ping for wrong stage ${stage.number} of test '${test.testName}'`, e)\n\t\t\t\t} else if (e.data === \"invalid_stage_skip\") {\n\t\t\t\t\tconsole.log(`Tried to skip a required stage before stage ${stage.number} of test '${test.testName}'`, e)\n\t\t\t\t} else if (e.data === \"invalid_stage_repetition\") {\n\t\t\t\t\tconsole.log(`Tried to repeat stage ${stage.number} of test '${test.testName}' too many times`, e)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t} else if (e instanceof NotFoundError) {\n\t\t\t\t// Cached assignments are likely out of date if we run into a NotFoundError here.\n\t\t\t\t// We should not attempt to re-send pings, as the relevant test has likely been deleted.\n\t\t\t\t// Hence, we just remove the cached assignment and disable the test.\n\t\t\t\ttest.active = false\n\t\t\t\tconsole.log(`Tried to send ping. Removing test '${test.testName}' from storage`, e)\n\n\t\t\t\tconst storedAssignments = await this.storage().getAssignments()\n\t\t\t\tif (storedAssignments) {\n\t\t\t\t\tawait this.storage().storeAssignments({\n\t\t\t\t\t\tupdatedAt: storedAssignments.updatedAt,\n\t\t\t\t\t\tusageModelVersion: storedAssignments.usageModelVersion,\n\t\t\t\t\t\tassignments: storedAssignments.assignments.filter((assignment) => assignment.testId !== test.testId),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if (e instanceof BadRequestError) {\n\t\t\t\ttest.active = false\n\t\t\t\tconsole.log(`Tried to send ping. Setting test '${test.testName}' inactive because it is misconfigured`, e)\n\t\t\t} else if (isOfflineError(e)) {\n\t\t\t\tconsole.log(\"Tried to send ping, but we are offline\", e)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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"}