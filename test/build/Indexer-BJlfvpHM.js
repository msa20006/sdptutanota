
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, contains, daysToMillis, defer, downcast, getFromMap, isNotNull, isSameTypeRef, isSameTypeRefByAttr, millisToDays, neverNull, noOp, ofClass, pMap, stringToUtf8Uint8Array, tokenize, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import { TutanotaError } from "./dist-Rk9U8Iqn.js";
import { assertWorkerOrNode } from "./Env-D5xGlXfw.js";
import { ENTITY_EVENT_BATCH_TTL_DAYS, FULL_INDEXED_TIMESTAMP, GroupType, NOTHING_INDEXED_TIMESTAMP, OperationType, getMembershipGroupType } from "./TutanotaConstants-3bwAESYA.js";
import { ConnectionError, NotAuthorizedError, NotFoundError } from "./RestError-D17JEBMr.js";
import { OutOfSyncError } from "./OutOfSyncError-Ck2yBBO8.js";
import { DbError } from "./DbError-CcwZaPG2.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { GENERATED_MAX_ID, firstBiggerThanSecond, generatedIdToTimestamp, getElementId, isSameId, timestampToGeneratedId } from "./EntityUtils-RQxXZlcV.js";
import { typeModels$3 as typeModels } from "./TypeModels-XIXYys8J.js";
import { ContactListTypeRef, ContactTypeRef, ImportMailStateTypeRef, MailTypeRef } from "./TypeRefs-CR3TLWn0.js";
import { EntityEventBatchTypeRef, UserTypeRef } from "./TypeRefs-BP1jvX9p.js";
import { EntityClient } from "./EntityClient-B0RSdk2i.js";
import { IV_BYTE_LENGTH, aes256EncryptSearchIndexEntry, aes256RandomKey, decryptKey, random, unauthenticatedAesDecrypt } from "./dist-DcZ1Y4qd.js";
import { EventQueue } from "./EventQueue-c-5UmjJa.js";
import { encryptKeyWithVersionedKey } from "./CryptoWrapper-BTtEczdP.js";
import { DbFacade, b64UserIdHash } from "./DbFacade-DYw6Nyfw.js";
import { ElementDataOS, GroupDataOS, MetaDataOS, Metadata, SearchIndexMetaDataOS, SearchIndexOS, SearchIndexWordsIndex, SearchTermSuggestionsOS } from "./IndexTables-C5S9WDY9.js";
import { getIndexerMetaData, updateEncryptionMetadata } from "./ConfigurationDatabase-ClkJ3kmL.js";
import { _createNewIndexUpdate, filterIndexMemberships, markEnd, markStart, typeRefToTypeInfo } from "./IndexUtils-K27esrGs.js";
import { IndexingErrorReason } from "./SearchTypes-BQT7nl8f.js";
import { IndexerCore, InvalidDatabaseStateError } from "./IndexerCore-CrLYpsA5.js";

//#region ../src/mail-app/workerUtils/index/ContactIndexer.ts
var ContactIndexer = class {
	_core;
	_db;
	_entity;
	suggestionFacade;
	constructor(core, db, entity, suggestionFacade) {
		this._core = core;
		this._db = db;
		this._entity = entity;
		this.suggestionFacade = suggestionFacade;
	}
	createContactIndexEntries(contact) {
		const ContactModel = typeModels.Contact;
		let keyToIndexEntries = this._core.createIndexEntriesForAttributes(contact, [
			{
				attribute: ContactModel.values["firstName"],
				value: () => contact.firstName
			},
			{
				attribute: ContactModel.values["lastName"],
				value: () => contact.lastName
			},
			{
				attribute: ContactModel.values["nickname"],
				value: () => contact.nickname || ""
			},
			{
				attribute: ContactModel.values["role"],
				value: () => contact.role
			},
			{
				attribute: ContactModel.values["title"],
				value: () => contact.title || ""
			},
			{
				attribute: ContactModel.values["comment"],
				value: () => contact.comment
			},
			{
				attribute: ContactModel.values["company"],
				value: () => contact.company
			},
			{
				attribute: ContactModel.associations["addresses"],
				value: () => contact.addresses.map((a) => a.address).join(",")
			},
			{
				attribute: ContactModel.associations["mailAddresses"],
				value: () => contact.mailAddresses.map((cma) => cma.address).join(",")
			},
			{
				attribute: ContactModel.associations["phoneNumbers"],
				value: () => contact.phoneNumbers.map((pn) => pn.number).join(",")
			},
			{
				attribute: ContactModel.associations["socialIds"],
				value: () => contact.socialIds.map((s) => s.socialId).join(",")
			}
		]);
		this.suggestionFacade.addSuggestions(this._getSuggestionWords(contact));
		return keyToIndexEntries;
	}
	_getSuggestionWords(contact) {
		return tokenize(contact.firstName + " " + contact.lastName + " " + contact.mailAddresses.map((ma) => ma.address).join(" "));
	}
	processNewContact(event) {
		return this._entity.load(ContactTypeRef, [event.instanceListId, event.instanceId]).then((contact) => {
			let keyToIndexEntries = this.createContactIndexEntries(contact);
			return this.suggestionFacade.store().then(() => {
				return {
					contact,
					keyToIndexEntries
				};
			});
		}).catch(ofClass(NotFoundError, () => {
			console.log("tried to index non existing contact");
			return null;
		})).catch(ofClass(NotAuthorizedError, () => {
			console.log("tried to index contact without permission");
			return null;
		}));
	}
	async getIndexTimestamp(contactList) {
		const t = await this._db.dbFacade.createTransaction(true, [MetaDataOS, GroupDataOS]);
		const groupId = neverNull(contactList._ownerGroup);
		return t.get(GroupDataOS, groupId).then((groupData) => {
			return groupData ? groupData.indexTimestamp : null;
		});
	}
	/**
	* Indexes the contact list if it is not yet indexed.
	*/
	async indexFullContactList(contactList) {
		const groupId = neverNull(contactList._ownerGroup);
		let indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(ContactTypeRef));
		try {
			const contacts = await this._entity.loadAll(ContactTypeRef, contactList.contacts);
			for (const contact of contacts) {
				let keyToIndexEntries = this.createContactIndexEntries(contact);
				this._core.encryptSearchIndexEntries(contact._id, neverNull(contact._ownerGroup), keyToIndexEntries, indexUpdate);
			}
			return Promise.all([this._core.writeIndexUpdate([{
				groupId,
				indexTimestamp: FULL_INDEXED_TIMESTAMP
			}], indexUpdate), this.suggestionFacade.store()]);
		} catch (e) {
			if (e instanceof NotFoundError) return Promise.resolve();
			throw e;
		}
	}
	processEntityEvents(events, groupId, batchId, indexUpdate) {
		return pMap(events, async (event) => {
			if (event.operation === OperationType.CREATE) await this.processNewContact(event).then((result) => {
				if (result) this._core.encryptSearchIndexEntries(result.contact._id, neverNull(result.contact._ownerGroup), result.keyToIndexEntries, indexUpdate);
			});
else if (event.operation === OperationType.UPDATE) await Promise.all([this._core._processDeleted(event, indexUpdate), this.processNewContact(event).then((result) => {
				if (result) this._core.encryptSearchIndexEntries(result.contact._id, neverNull(result.contact._ownerGroup), result.keyToIndexEntries, indexUpdate);
			})]);
else if (event.operation === OperationType.DELETE) await this._core._processDeleted(event, indexUpdate);
		}).then(noOp);
	}
};

//#endregion
//#region ../src/mail-app/workerUtils/index/SuggestionFacade.ts
var SuggestionFacade = class {
	_db;
	type;
	_suggestions;
	constructor(type, db) {
		this.type = type;
		this._db = db;
		this._suggestions = {};
	}
	load() {
		return this._db.initialized.then(() => {
			return this._db.dbFacade.createTransaction(true, [SearchTermSuggestionsOS]).then((t) => {
				return t.get(SearchTermSuggestionsOS, this.type.type.toLowerCase()).then((encSuggestions) => {
					if (encSuggestions) this._suggestions = JSON.parse(utf8Uint8ArrayToString(unauthenticatedAesDecrypt(this._db.key, encSuggestions, true)));
else this._suggestions = {};
				});
			});
		});
	}
	addSuggestions(words) {
		for (const word of words) if (word.length > 0) {
			let key = word.charAt(0);
			if (this._suggestions[key]) {
				let existingValues = this._suggestions[key];
				if (existingValues.indexOf(word) === -1) {
					let insertIndex = existingValues.findIndex((v) => word < v);
					if (insertIndex === -1) existingValues.push(word);
else existingValues.splice(insertIndex, 0, word);
				}
			} else this._suggestions[key] = [word];
		}
	}
	getSuggestions(word) {
		if (word.length > 0) {
			let key = word.charAt(0);
			let result = this._suggestions[key];
			return result ? result.filter((r) => r.startsWith(word)) : [];
		} else return [];
	}
	store() {
		return this._db.initialized.then(() => {
			return this._db.dbFacade.createTransaction(false, [SearchTermSuggestionsOS]).then((t) => {
				let encSuggestions = aes256EncryptSearchIndexEntry(this._db.key, stringToUtf8Uint8Array(JSON.stringify(this._suggestions)));
				t.put(SearchTermSuggestionsOS, this.type.type.toLowerCase(), encSuggestions);
				return t.wait();
			});
		});
	}
};

//#endregion
//#region ../src/common/api/common/error/MembershipRemovedError.ts
var MembershipRemovedError = class extends TutanotaError {
	constructor(message) {
		super("MembershipRemovedError", message);
	}
};

//#endregion
//#region ../src/common/api/worker/utils/DbUtils.ts
assertWorkerOrNode();
function deleteObjectStores(db, ...oss) {
	for (let os of oss) try {
		db.deleteObjectStore(os);
	} catch (e) {
		console.warn("Error while deleting old os", os, "ignoring", e);
	}
}

//#endregion
//#region ../src/mail-app/workerUtils/index/Indexer.ts
const DB_VERSION = 3;
function newSearchIndexDB() {
	return new DbFacade(DB_VERSION, (event, db) => {
		if (event.oldVersion !== DB_VERSION && event.oldVersion !== 0) deleteObjectStores(db, SearchIndexOS, ElementDataOS, MetaDataOS, GroupDataOS, SearchTermSuggestionsOS, SearchIndexMetaDataOS);
		db.createObjectStore(SearchIndexOS, { autoIncrement: true });
		const metaOS = db.createObjectStore(SearchIndexMetaDataOS, {
			autoIncrement: true,
			keyPath: "id"
		});
		db.createObjectStore(ElementDataOS);
		db.createObjectStore(MetaDataOS);
		db.createObjectStore(GroupDataOS);
		db.createObjectStore(SearchTermSuggestionsOS);
		metaOS.createIndex(SearchIndexWordsIndex, "word", { unique: true });
	});
}
var Indexer = class {
	db;
	_dbInitializedDeferredObject;
	_initParams;
	_contact;
	_mail;
	/**
	* Last batch id per group from initial loading.
	* In case we get duplicate events from loading and websocket we want to filter them out to avoid processing duplicates.
	* */
	_initiallyLoadedBatchIdsPerGroup;
	/**
	* Queue which gets all the websocket events and dispatches them to the core. It is paused until we load initial events to avoid
	* putting events from websocket before initial events.
	*/
	_realtimeEventQueue;
	_core;
	_entity;
	_entityRestClient;
	_indexedGroupIds;
	constructor(entityRestClient, infoMessageHandler, browserData, defaultEntityRestCache, makeMailIndexer) {
		this.infoMessageHandler = infoMessageHandler;
		let deferred = defer();
		this._dbInitializedDeferredObject = deferred;
		this.db = {
			dbFacade: newSearchIndexDB(),
			key: downcast(null),
			iv: downcast(null),
			initialized: deferred.promise
		};
		this._core = new IndexerCore(this.db, new EventQueue("indexer_core", true, (batch) => this._processEntityEvents(batch)), browserData);
		this._entityRestClient = entityRestClient;
		this._entity = new EntityClient(defaultEntityRestCache);
		this._contact = new ContactIndexer(this._core, this.db, this._entity, new SuggestionFacade(ContactTypeRef, this.db));
		this._mail = makeMailIndexer(this._core, this.db);
		this._indexedGroupIds = [];
		this._initiallyLoadedBatchIdsPerGroup = new Map();
		this._realtimeEventQueue = new EventQueue("indexer_realtime", false, (nextElement) => {
			const loadedIdForGroup = this._initiallyLoadedBatchIdsPerGroup.get(nextElement.groupId);
			if (loadedIdForGroup == null || firstBiggerThanSecond(nextElement.batchId, loadedIdForGroup)) this._core.addBatchesToQueue([nextElement]);
			return Promise.resolve();
		});
		this._realtimeEventQueue.pause();
	}
	/**
	* Opens a new DbFacade and initializes the metadata if it is not there yet
	*/
	async init({ user, keyLoaderFacade, retryOnError, cacheInfo }) {
		this._initParams = {
			user,
			keyLoaderFacade
		};
		try {
			await this.db.dbFacade.open(this.getDbId(user));
			const metaData = await getIndexerMetaData(this.db.dbFacade, MetaDataOS);
			if (metaData == null) {
				const userGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey();
				await this.createIndexTables(user, userGroupKey);
			} else {
				const userGroupKey = await keyLoaderFacade.loadSymUserGroupKey(metaData.userGroupKeyVersion);
				await this.loadIndexTables(user, userGroupKey, metaData);
			}
			await this.infoMessageHandler.onSearchIndexStateUpdate({
				initializing: false,
				mailIndexEnabled: this._mail.mailIndexingEnabled,
				progress: 0,
				currentMailIndexTimestamp: this._mail.currentIndexTimestamp,
				aimedMailIndexTimestamp: this._mail.currentIndexTimestamp,
				indexedMailCount: 0,
				failedIndexingUpTo: null
			});
			this._core.startProcessing();
			await this.indexOrLoadContactListIfNeeded(user, cacheInfo);
			await this._mail.mailboxIndexingPromise;
			await this._mail.indexMailboxes(user, this._mail.currentIndexTimestamp);
			const groupIdToEventBatches = await this._loadPersistentGroupData(user);
			await this._loadNewEntities(groupIdToEventBatches).catch(ofClass(OutOfSyncError, (e) => this.disableMailIndexing()));
		} catch (e) {
			if (retryOnError !== false && (e instanceof MembershipRemovedError || e instanceof InvalidDatabaseStateError)) {
				console.log("disable mail indexing and init again", e);
				return this._reCreateIndex();
			} else {
				await this.infoMessageHandler.onSearchIndexStateUpdate({
					initializing: false,
					mailIndexEnabled: this._mail.mailIndexingEnabled,
					progress: 0,
					currentMailIndexTimestamp: this._mail.currentIndexTimestamp,
					aimedMailIndexTimestamp: this._mail.currentIndexTimestamp,
					indexedMailCount: 0,
					failedIndexingUpTo: this._mail.currentIndexTimestamp,
					error: e instanceof ConnectionError ? IndexingErrorReason.ConnectionLost : IndexingErrorReason.Unknown
				});
				this._dbInitializedDeferredObject.reject(e);
				throw e;
			}
		}
	}
	getDbId(user) {
		return b64UserIdHash(user._id);
	}
	async indexOrLoadContactListIfNeeded(user, cacheInfo) {
		try {
			const contactList = await this._entity.loadRoot(ContactListTypeRef, user.userGroup.group);
			const indexTimestamp = await this._contact.getIndexTimestamp(contactList);
			if (indexTimestamp === NOTHING_INDEXED_TIMESTAMP) await this._contact.indexFullContactList(contactList);
else if (cacheInfo?.isNewOfflineDb) await this._entity.loadAll(ContactTypeRef, contactList.contacts);
		} catch (e) {
			if (!(e instanceof NotFoundError)) throw e;
		}
	}
	enableMailIndexing() {
		return this.db.initialized.then(() => {
			return this._mail.enableMailIndexing(this._initParams.user).then(() => {
				this._mail.mailboxIndexingPromise.catch(ofClass(CancelledError, noOp));
			});
		});
	}
	async disableMailIndexing() {
		await this.db.initialized;
		if (!this._core.isStoppedProcessing()) {
			await this.deleteIndex(this._initParams.user._id);
			await this.init({
				user: this._initParams.user,
				keyLoaderFacade: this._initParams.keyLoaderFacade
			});
		}
	}
	async deleteIndex(userId) {
		this._core.stopProcessing();
		await this._mail.disableMailIndexing(userId);
	}
	extendMailIndex(newOldestTimestamp) {
		return this._mail.extendIndexIfNeeded(this._initParams.user, newOldestTimestamp);
	}
	cancelMailIndexing() {
		return this._mail.cancelMailIndexing();
	}
	addBatchesToQueue(batches) {
		this._realtimeEventQueue.addBatches(batches);
	}
	startProcessing() {
		this._core.queue.start();
	}
	async onVisibilityChanged(visible) {
		this._core.onVisibilityChanged(visible);
	}
	_reCreateIndex() {
		const mailIndexingWasEnabled = this._mail.mailIndexingEnabled;
		return this._mail.disableMailIndexing(assertNotNull(this._initParams.user._id)).then(() => {
			return this.init({
				user: this._initParams.user,
				keyLoaderFacade: this._initParams.keyLoaderFacade,
				retryOnError: false
			}).then(() => {
				if (mailIndexingWasEnabled) return this.enableMailIndexing();
			});
		});
	}
	async createIndexTables(user, userGroupKey) {
		this.db.key = aes256RandomKey();
		this.db.iv = random.generateRandomData(IV_BYTE_LENGTH);
		const groupBatches = await this._loadGroupData(user);
		const userEncDbKey = encryptKeyWithVersionedKey(userGroupKey, this.db.key);
		const transaction = await this.db.dbFacade.createTransaction(false, [MetaDataOS, GroupDataOS]);
		await transaction.put(MetaDataOS, Metadata.userEncDbKey, userEncDbKey.key);
		await transaction.put(MetaDataOS, Metadata.mailIndexingEnabled, this._mail.mailIndexingEnabled);
		await transaction.put(MetaDataOS, Metadata.encDbIv, aes256EncryptSearchIndexEntry(this.db.key, this.db.iv));
		await transaction.put(MetaDataOS, Metadata.userGroupKeyVersion, userEncDbKey.encryptingKeyVersion);
		await transaction.put(MetaDataOS, Metadata.lastEventIndexTimeMs, this._entityRestClient.getRestClient().getServerTimestampMs());
		await this._initGroupData(groupBatches, transaction);
		await this._updateIndexedGroups();
		this._dbInitializedDeferredObject.resolve();
	}
	async loadIndexTables(user, userGroupKey, metaData) {
		this.db.key = decryptKey(userGroupKey, metaData.userEncDbKey);
		this.db.iv = unauthenticatedAesDecrypt(this.db.key, neverNull(metaData.encDbIv), true);
		this._mail.mailIndexingEnabled = metaData.mailIndexingEnabled;
		const groupDiff = await this._loadGroupDiff(user);
		await this._updateGroups(user, groupDiff);
		await this._mail.updateCurrentIndexTimestamp(user);
		await this._updateIndexedGroups();
		this._dbInitializedDeferredObject.resolve();
		await this._contact.suggestionFacade.load();
	}
	async _updateIndexedGroups() {
		const t = await this.db.dbFacade.createTransaction(true, [GroupDataOS]);
		const indexedGroupIds = await pMap(await t.getAll(GroupDataOS), (groupDataEntry) => downcast(groupDataEntry.key));
		if (indexedGroupIds.length === 0) {
			console.log("no group ids in database, disabling indexer");
			this.disableMailIndexing();
		}
		this._indexedGroupIds = indexedGroupIds;
	}
	_loadGroupDiff(user) {
		let currentGroups = filterIndexMemberships(user).map((m) => {
			return {
				id: m.group,
				type: getMembershipGroupType(m)
			};
		});
		return this.db.dbFacade.createTransaction(true, [GroupDataOS]).then((t) => {
			return t.getAll(GroupDataOS).then((loadedGroups) => {
				if (!Array.isArray(loadedGroups)) throw new InvalidDatabaseStateError("loadedGroups is not an array");
				let oldGroups = loadedGroups.map((group) => {
					if (typeof group?.key !== "string" || typeof group?.value?.groupType !== "string") throw new InvalidDatabaseStateError(`loaded group is malformed: ${group} ${JSON.stringify(group)}`);
					const id = group.key;
					return {
						id,
						type: group.value.groupType
					};
				});
				let deletedGroups = oldGroups.filter((oldGroup) => !currentGroups.some((m) => m.id === oldGroup.id));
				let newGroups = currentGroups.filter((m) => !oldGroups.some((oldGroup) => m.id === oldGroup.id));
				return {
					deletedGroups,
					newGroups
				};
			});
		});
	}
	/**
	*
	* Initializes the index db for new groups of the user, but does not start the actual indexing for those groups.
	* If the user was removed from a contact or mail group the function throws a CancelledError to delete the complete mail index afterwards.
	*/
	_updateGroups(user, groupDiff) {
		if (groupDiff.deletedGroups.some((g) => g.type === GroupType.Mail || g.type === GroupType.Contact)) return Promise.reject(new MembershipRemovedError("user has been removed from contact or mail group"));
else if (groupDiff.newGroups.length > 0) return this._loadGroupData(user, groupDiff.newGroups.map((g) => g.id)).then((groupBatches) => {
			return this.db.dbFacade.createTransaction(false, [GroupDataOS]).then((t) => {
				return this._initGroupData(groupBatches, t);
			});
		});
		return Promise.resolve();
	}
	/**
	* Provides a GroupData object including the last 100 event batch ids for all indexed membership groups of the given user.
	*/
	_loadGroupData(user, restrictToTheseGroups) {
		let memberships = filterIndexMemberships(user);
		const restrictTo = restrictToTheseGroups;
		if (restrictTo) memberships = memberships.filter((membership) => contains(restrictTo, membership.group));
		return pMap(memberships, (membership) => {
			return this._entity.loadRange(EntityEventBatchTypeRef, membership.group, GENERATED_MAX_ID, 1, true).then((eventBatches) => {
				return {
					groupId: membership.group,
					groupData: {
						lastBatchIds: eventBatches.map((eventBatch) => eventBatch._id[1]),
						indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
						groupType: getMembershipGroupType(membership)
					}
				};
			}).catch(ofClass(NotAuthorizedError, () => {
				console.log("could not download entity updates => lost permission on list");
				return null;
			}));
		}).then((data) => data.filter(isNotNull));
	}
	/**
	* creates the initial group data for all provided group ids
	*/
	_initGroupData(groupBatches, t2) {
		for (const groupIdToLastBatchId of groupBatches) t2.put(GroupDataOS, groupIdToLastBatchId.groupId, groupIdToLastBatchId.groupData);
		return t2.wait();
	}
	async _loadNewEntities(groupIdToEventBatches) {
		const batchesOfAllGroups = [];
		const lastLoadedBatchIdInGroup = new Map();
		const transaction = await this.db.dbFacade.createTransaction(true, [MetaDataOS]);
		const lastIndexTimeMs = await transaction.get(MetaDataOS, Metadata.lastEventIndexTimeMs);
		await this._throwIfOutOfDate();
		try {
			for (let groupIdToEventBatch of groupIdToEventBatches) if (groupIdToEventBatch.eventBatchIds.length > 0) {
				let startId = this._getStartIdForLoadingMissedEventBatches(groupIdToEventBatch.eventBatchIds);
				let eventBatchesOnServer = [];
				eventBatchesOnServer = await this._entity.loadAll(EntityEventBatchTypeRef, groupIdToEventBatch.groupId, startId);
				const batchesToQueue = [];
				for (let batch of eventBatchesOnServer) {
					const batchId = getElementId(batch);
					if (groupIdToEventBatch.eventBatchIds.indexOf(batchId) === -1 && firstBiggerThanSecond(batchId, startId)) {
						batchesToQueue.push({
							groupId: groupIdToEventBatch.groupId,
							batchId,
							events: batch.events
						});
						const lastBatch = lastLoadedBatchIdInGroup.get(groupIdToEventBatch.groupId);
						if (lastBatch == null || firstBiggerThanSecond(batchId, lastBatch)) lastLoadedBatchIdInGroup.set(groupIdToEventBatch.groupId, batchId);
					}
				}
				if (lastIndexTimeMs == null && eventBatchesOnServer.length === batchesToQueue.length) throw new OutOfSyncError(`We lost entity events for group ${groupIdToEventBatch.groupId}. start id was ${startId}`);
				batchesOfAllGroups.push(...batchesToQueue);
			}
		} catch (e) {
			if (e instanceof NotAuthorizedError) {
				console.log("could not download entity updates => lost permission on list");
				return;
			}
			throw e;
		}
		this._core.addBatchesToQueue(batchesOfAllGroups);
		this._initiallyLoadedBatchIdsPerGroup = lastLoadedBatchIdInGroup;
		this._realtimeEventQueue.resume();
		this.startProcessing();
		await this._writeServerTimestamp();
	}
	_getStartIdForLoadingMissedEventBatches(lastEventBatchIds) {
		let newestBatchId = lastEventBatchIds[0];
		let oldestBatchId = lastEventBatchIds[lastEventBatchIds.length - 1];
		let startId = timestampToGeneratedId(generatedIdToTimestamp(newestBatchId) - 6e4);
		if (!firstBiggerThanSecond(startId, oldestBatchId)) startId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1);
		return startId;
	}
	/**
	* @private a map from group id to event batches
	*/
	_loadPersistentGroupData(user) {
		return this.db.dbFacade.createTransaction(true, [GroupDataOS]).then((t) => {
			return Promise.all(filterIndexMemberships(user).map((membership) => {
				return t.get(GroupDataOS, membership.group).then((groupData) => {
					if (groupData) return {
						groupId: membership.group,
						eventBatchIds: groupData.lastBatchIds
					};
else throw new InvalidDatabaseStateError("no group data for group " + membership.group + " indexedGroupIds: " + this._indexedGroupIds.join(","));
				});
			}));
		});
	}
	_processEntityEvents(batch) {
		const { events, groupId, batchId } = batch;
		return this.db.initialized.then(async () => {
			if (!this.db.dbFacade.indexingSupported) return Promise.resolve();
			if (filterIndexMemberships(this._initParams.user).map((m) => m.group).indexOf(groupId) === -1) return Promise.resolve();
			if (this._indexedGroupIds.indexOf(groupId) === -1) return Promise.resolve();
			markStart("processEntityEvents");
			const groupedEvents = new Map();
			events.reduce((all, update) => {
				if (isSameTypeRefByAttr(MailTypeRef, update.application, update.type)) getFromMap(all, MailTypeRef, () => []).push(update);
else if (isSameTypeRefByAttr(ContactTypeRef, update.application, update.type)) getFromMap(all, ContactTypeRef, () => []).push(update);
else if (isSameTypeRefByAttr(UserTypeRef, update.application, update.type)) getFromMap(all, UserTypeRef, () => []).push(update);
else if (isSameTypeRefByAttr(ImportMailStateTypeRef, update.application, update.type)) getFromMap(all, ImportMailStateTypeRef, () => []).push(update);
				return all;
			}, groupedEvents);
			markStart("processEvent");
			return pMap(groupedEvents.entries(), ([key, value]) => {
				let promise = Promise.resolve();
				if (isSameTypeRef(UserTypeRef, key)) return this._processUserEntityEvents(value);
				const typeInfoToIndex = isSameTypeRef(ImportMailStateTypeRef, key) || isSameTypeRef(MailTypeRef, key) ? typeRefToTypeInfo(MailTypeRef) : typeRefToTypeInfo(key);
				const indexUpdate = _createNewIndexUpdate(typeInfoToIndex);
				if (isSameTypeRef(MailTypeRef, key)) promise = this._mail.processEntityEvents(value, groupId, batchId, indexUpdate);
else if (isSameTypeRef(ContactTypeRef, key)) promise = this._contact.processEntityEvents(value, groupId, batchId, indexUpdate);
else if (isSameTypeRef(ImportMailStateTypeRef, key)) promise = this._mail.processImportStateEntityEvents(value, groupId, batchId, indexUpdate);
				return promise.then(() => {
					markEnd("processEvent");
					markStart("writeIndexUpdate");
					return this._core.writeIndexUpdateWithBatchId(groupId, batchId, indexUpdate);
				}).then(() => {
					markEnd("writeIndexUpdate");
					markEnd("processEntityEvents");
				});
			});
		}).catch(ofClass(CancelledError, noOp)).catch(ofClass(DbError, (e) => {
			if (this._core.isStoppedProcessing()) console.log("Ignoring DBerror when indexing is disabled", e);
else throw e;
		})).catch(ofClass(InvalidDatabaseStateError, (e) => {
			console.log("InvalidDatabaseStateError during _processEntityEvents");
			this._core.stopProcessing();
			return this._reCreateIndex();
		}));
	}
	/**
	* @VisibleForTesting
	* @param events
	*/
	async _processUserEntityEvents(events) {
		for (const event of events) {
			if (!(event.operation === OperationType.UPDATE && isSameId(this._initParams.user._id, event.instanceId))) continue;
			this._initParams.user = await this._entity.load(UserTypeRef, event.instanceId);
			await updateEncryptionMetadata(this.db.dbFacade, this._initParams.keyLoaderFacade, MetaDataOS);
		}
	}
	async _throwIfOutOfDate() {
		const transaction = await this.db.dbFacade.createTransaction(true, [MetaDataOS]);
		const lastIndexTimeMs = await transaction.get(MetaDataOS, Metadata.lastEventIndexTimeMs);
		if (lastIndexTimeMs != null) {
			const now = this._entityRestClient.getRestClient().getServerTimestampMs();
			const timeSinceLastIndex = now - lastIndexTimeMs;
			if (timeSinceLastIndex >= daysToMillis(ENTITY_EVENT_BATCH_TTL_DAYS)) throw new OutOfSyncError(`we haven't updated the index in ${millisToDays(timeSinceLastIndex)} days. last update was ${new Date(neverNull(lastIndexTimeMs)).toString()}`);
		}
	}
	async _writeServerTimestamp() {
		const transaction = await this.db.dbFacade.createTransaction(false, [MetaDataOS]);
		const now = this._entityRestClient.getRestClient().getServerTimestampMs();
		await transaction.put(MetaDataOS, Metadata.lastEventIndexTimeMs, now);
	}
};

//#endregion
export { ContactIndexer, Indexer, MembershipRemovedError, SuggestionFacade, newSearchIndexDB };
//# sourceMappingURL=Indexer-BJlfvpHM.js.map