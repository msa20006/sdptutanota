
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { arrayEqualsWithPredicate, assert, assertNonNull, assertNotNull, clamp, clone, defer, findAll, getStartOfDay, identity, incrementDate, isSameDay, isSameDayOfDate, memoized, noOp, numberRange, remove, trisectingDiff, typedValues } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { isValidColorCode, size } from "./HtmlUtils-C-ecR7U7.js";
import { AccountType, CLIENT_ONLY_CALENDARS, CalendarAttendeeStatus, ConversationType, DEFAULT_CLIENT_ONLY_CALENDAR_COLORS, EndType, RepeatPeriod, ShareCapability, defaultCalendarColor } from "./TutanotaConstants-3bwAESYA.js";
import { ButtonType } from "./Icon-BuqNK7vz.js";
import { Icons } from "./Icons-Dl3nFav5.js";
import { Dialog, createAsyncDropdown } from "./Dialog-B6-HFvZd.js";
import { NotFoundError, PayloadTooLargeError, TooManyRequestsError } from "./RestError-D17JEBMr.js";
import { DateTime, Duration } from "./luxon-D6cgmg6Q.js";
import { CalendarEventWhenModel, Time } from "./CalendarEventWhenModel-DEedSoEH.js";
import { getStrippedClone, haveSameId } from "./EntityUtils-RQxXZlcV.js";
import { cleanMailAddress, findRecipientWithAddress, generateEventElementId, isAllDayEvent, serializeAlarmInterval } from "./CommonCalendarUtils-DKaO7v1K.js";
import { formatDateTime, formatDateWithMonth, formatTime } from "./Formatter-zB15D6XI.js";
import { createCalendarEvent, createCalendarEventAttendee, createEncryptedMailAddress } from "./TypeRefs-CR3TLWn0.js";
import { AlarmIntervalUnit, DefaultDateProvider, StandardAlarmInterval, alarmIntervalToLuxonDurationLikeObject, areRepeatRulesEqual, findFirstPrivateCalendar, generateUid, getEventEnd, getEventStart, getTimeZone, hasSourceUrl, incrementByRepeatPeriod, incrementSequence, parseAlarmInterval } from "./CalendarUtils-C6jeYrj9.js";
import { assertEventValidity } from "./CalendarModel-DK762b35.js";
import { hasCapabilityOnGroup } from "./GroupUtils-CpT2lvVS.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import { RecipientField, getDefaultSender } from "./SharedMailUtils-AmFaSJP6.js";
import { getPasswordStrengthForUser, isSecurePassword } from "./PasswordUtils-C4jlV9GF.js";
import { RecipientType } from "./Recipient-BFxhfecW.js";
import { getContactDisplayName } from "./ContactUtils-Bbon2oOk.js";
import { ResolveMode } from "./RecipientsModel-DxwXuUvL.js";
import { UpgradeRequiredError } from "./UpgradeRequiredError-CbZr7beN.js";

//#region ../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventWhoModel.ts
var CalendarEventWhoModel = class {
	/** we need to resolve recipients to know if we need to show an external password field. */
	resolvedRecipients = new Map();
	pendingRecipients = 0;
	_recipientsSettled = defer();
	/** it's possible that the consumer cares about all the recipient information being resolved, but that's only possible in an async way. */
	get recipientsSettled() {
		return this._recipientsSettled.promise;
	}
	/** external password for an external attendee with an address */
	externalPasswords = new Map();
	/** to know who to update, we need to know who was already on the guest list.
	* we keep the attendees in maps for deduplication, keyed by their address.
	* */
	initialAttendees = new Map();
	initialOwnAttendeeStatus = null;
	/** we only show the send update checkbox if there are attendees that require updates from us. */
	initiallyHadOtherAttendees;
	/** the current list of attendees. */
	_attendees = new Map();
	/** organizer MUST be set if _ownAttendee is - we're either both, we're invited and someone else is organizer or there are no guests at all. */
	_organizer = null;
	/** the attendee that has one of our mail addresses. MUST NOT be in _attendees */
	_ownAttendee = null;
	isConfidential;
	/**
	* whether this user will send updates for this event.
	* * this needs to be our event.
	* * we need a paid account
	* * there need to be changes that require updating the attendees (eg alarms do not)
	* * there also need to be attendees that require updates/invites/cancellations/response
	*/
	shouldSendUpdates = false;
	/**
	*
	* @param initialValues
	* @param eventType
	* @param operation the operation the user is currently attempting. we could use recurrenceId on initialvalues for this information, but this is safer.
	* @param calendars
	* @param _selectedCalendar
	* @param userController
	* @param isNew whether the event is new (never been saved)
	* @param ownMailAddresses an array of the mail addresses this user could be mentioned as as an attendee or organizer.
	* @param recipientsModel
	* @param responseTo
	* @param passwordStrengthModel
	* @param sendMailModelFactory
	* @param uiUpdateCallback
	*/
	constructor(initialValues, eventType, operation, calendars, _selectedCalendar, userController, isNew, ownMailAddresses, recipientsModel, responseTo, passwordStrengthModel, sendMailModelFactory, uiUpdateCallback = noOp) {
		this.eventType = eventType;
		this.operation = operation;
		this.calendars = calendars;
		this._selectedCalendar = _selectedCalendar;
		this.userController = userController;
		this.isNew = isNew;
		this.ownMailAddresses = ownMailAddresses;
		this.recipientsModel = recipientsModel;
		this.responseTo = responseTo;
		this.passwordStrengthModel = passwordStrengthModel;
		this.sendMailModelFactory = sendMailModelFactory;
		this.uiUpdateCallback = uiUpdateCallback;
		this.setupAttendees(initialValues);
		const resolvePromises = initialValues.attendees?.map((a) => this.resolveAndCacheAddress(a.address)).concat() ?? [];
		if (initialValues.organizer) resolvePromises.push(this.resolveAndCacheAddress(initialValues.organizer));
		Promise.all(resolvePromises).then(this.uiUpdateCallback);
		this.initiallyHadOtherAttendees = this.hasNotifyableOtherAttendees();
		this.isConfidential = initialValues.invitedConfidentially ?? false;
	}
	set selectedCalendar(v) {
		/**
		* when changing the calendar of an event, if the user is the organiser
		* they can link any of their owned calendars(private or shared) to said event
		* even if the event has guests
		**/
		if (!v.userIsOwner && v.shared && this._attendees.size > 0) throw new ProgrammingError("tried to select shared calendar while there are guests.");
else if (!v.userIsOwner && v.shared && this.isNew && this._organizer != null) this._organizer = null;
		this._selectedCalendar = v;
		this.uiUpdateCallback();
	}
	get selectedCalendar() {
		return this._selectedCalendar;
	}
	/**
	* whether the current user can modify the guest list of the event depending on event type and the calendar it's in.
	*
	* * at the moment, we can never modify guests when editing only part of a series.
	* * selected calendar is our own:
	*   * event is invite (we're not organizer): can't modify guest list, any edit operation will be local only.
	*   * event is our own: can do what we want.
	* * if the selected calendar is a shared one:
	*   * ro: don't show editor at all
	*   * rw, new event: don't show attendee list editor - we can't invite in shared calendars.
	*   * rw, existing event without attendees: not our own calendar, can't invite, don't show attendee list.
	*   * rw, existing event with attendees:  this is the case where we can see attendees, but can't edit them.
	*                                         but we also can't edit the event since there are attendees and we're
	*                                         unable to send updates.
	*/
	get canModifyGuests() {
		/**
		* if the user is the event's organiser and the owner of its linked calendar, the user can modify the guests freely
		**/
		const userIsOwner = this.eventType === EventType.OWN && this.selectedCalendar.userIsOwner;
		return userIsOwner || !(this.selectedCalendar?.shared || this.eventType === EventType.INVITE || this.operation === CalendarOperation.EditThis);
	}
	/**
	* filter the calendars an event can be saved to depending on the event type, attendee status and edit operation.
	* Prevent moving the event to another calendar if you only have read permission or if the event has attendees.
	* */
	getAvailableCalendars() {
		const { groupSettings } = this.userController.userSettingsGroupRoot;
		const calendarArray = Array.from(this.calendars.values()).filter((cal) => !this.isExternalCalendar(groupSettings, cal.group._id));
		if (this.eventType === EventType.LOCKED || this.operation === CalendarOperation.EditThis) return [this.selectedCalendar];
else if (this.isNew && this._attendees.size > 0)
 /**
		* when changing the calendar of an event, if the user is the organiser
		* they can link any of their owned calendars(private or shared) to said event
		* even if the event has guests
		**/
		return calendarArray.filter((calendarInfo) => calendarInfo.userIsOwner || !calendarInfo.shared);
else if (this._attendees.size > 0 && this.eventType === EventType.OWN) return calendarArray.filter((calendarInfo) => calendarInfo.userIsOwner);
else if (this._attendees.size > 0 || this.eventType === EventType.INVITE) return calendarArray.filter((calendarInfo) => !calendarInfo.shared || haveSameId(calendarInfo.group, this.selectedCalendar.group));
else return calendarArray.filter((calendarInfo) => hasCapabilityOnGroup(this.userController.user, calendarInfo.group, ShareCapability.Write));
	}
	isExternalCalendar(groupSettings, groupId) {
		const existingGroupSettings = groupSettings.find((gc) => gc.group === groupId);
		return hasSourceUrl(existingGroupSettings);
	}
	async resolveAndCacheAddress(a) {
		if (this.resolvedRecipients.has(a.address)) return;
		this.pendingRecipients = this.pendingRecipients + 1;
		const recipient = await this.recipientsModel.resolve(a, ResolveMode.Eager).resolved();
		this.cacheRecipient(recipient);
		this.pendingRecipients = this.pendingRecipients - 1;
		if (this.pendingRecipients === 0) {
			this._recipientsSettled.resolve();
			this._recipientsSettled = defer();
		}
	}
	cacheRecipient(recipient) {
		this.resolvedRecipients.set(recipient.address, recipient);
		if (recipient.type !== RecipientType.EXTERNAL) return;
		this.externalPasswords.set(recipient.address, recipient.contact?.presharedPassword ?? "");
		if (recipient.contact != null && this._attendees.has(recipient.address)) {
			const attendee = this._attendees.get(recipient.address);
			attendee.address.name = getContactDisplayName(recipient.contact);
		}
	}
	/**
	* internally, we want to keep ourselves and the organizer separate from the other attendees
	*/
	setupAttendees(initialValues) {
		const ownAddresses = this.ownMailAddresses.map((a) => cleanMailAddress(a.address));
		for (const a of initialValues.attendees ?? []) {
			const attendee = createCalendarEventAttendee({
				status: a.status,
				address: createEncryptedMailAddress({
					name: a.address.name,
					address: cleanMailAddress(a.address.address)
				})
			});
			this.initialAttendees.set(attendee.address.address, attendee);
		}
		const initialOrganizerAddress = initialValues.organizer == null ? null : createEncryptedMailAddress({
			address: cleanMailAddress(initialValues.organizer.address),
			name: initialValues.organizer.name
		});
		if (initialOrganizerAddress != null) {
			const organizerAttendee = this.initialAttendees.get(initialOrganizerAddress.address);
			this._organizer = organizerAttendee ?? createCalendarEventAttendee({
				address: initialOrganizerAddress,
				status: CalendarAttendeeStatus.NEEDS_ACTION
			});
			this.initialAttendees.delete(this._organizer.address.address);
		}
		const ownAttendeeAddresses = findAll(Array.from(this.initialAttendees.keys()), (address) => ownAddresses.includes(address));
		this._ownAttendee = this.initialAttendees.get(ownAttendeeAddresses[0]) ?? null;
		this.initialOwnAttendeeStatus = this._ownAttendee?.status ?? null;
		for (const match of ownAttendeeAddresses) this.initialAttendees.delete(match);
		for (const [initialAttendeeAddress, initialAttendee] of this.initialAttendees.entries()) this._attendees.set(initialAttendeeAddress, clone(initialAttendee));
		if (this._organizer != null && this._attendees.size === 0 && this._ownAttendee == null) this._organizer = null;
		if (this.eventType === EventType.OWN && this._organizer != null && !ownAddresses.includes(this._organizer.address.address) && Array.from(this._attendees.values()).some((a) => a.status !== CalendarAttendeeStatus.ADDED)) {
			console.warn("got an event with attendees and an organizer that's not the owner of the calendar, replacing organizer.");
			this._attendees.set(this._organizer.address.address, this._organizer);
			this._organizer = this._ownAttendee ?? createCalendarEventAttendee({
				address: createEncryptedMailAddress({
					address: ownAddresses[0],
					name: ""
				}),
				status: CalendarAttendeeStatus.ACCEPTED
			});
		}
		if (this._organizer && ownAddresses.includes(this._organizer.address.address) && this._organizer.address.address !== this._ownAttendee?.address.address) this._ownAttendee = this._organizer;
	}
	/**
	* figure out if there are currently other people that might need to be notified if this event is modified.
	* attendees that were just added and not invited yet are ignored for this.
	* @private
	*/
	hasNotifyableOtherAttendees() {
		return !this.isNew && Array.from(this.initialAttendees.values()).some((a) => a.status !== CalendarAttendeeStatus.ADDED);
	}
	get possibleOrganizers() {
		if (this.eventType !== EventType.OWN) return this._organizer ? [this._organizer.address] : [];
else if (!this.hasNotifyableOtherAttendees()) return this.ownMailAddresses;
else if (this._organizer != null && this.ownGuest?.address === this._organizer?.address.address) return [this._organizer.address];
else if (this.eventType === EventType.OWN) return this.ownMailAddresses;
else throw new ProgrammingError("could not figure out which addresses are a valid organizer for this event.");
	}
	/**
	* get our own guest, if any
	*/
	get ownGuest() {
		return this._ownAttendee && this.getGuestForAttendee(this._ownAttendee);
	}
	/**
	* get the current organizer of the event
	*
	* there is no setter - if we're changing attendees, we're ensured to be the organizer.
	*/
	get organizer() {
		return this._organizer && this.getGuestForAttendee(this._organizer);
	}
	/**
	* a list of the attendees of the event that are not the organizer or ourselves, with their status and type
	*/
	get guests() {
		return Array.from(this._attendees.values()).map((a) => this.getGuestForAttendee(a));
	}
	getGuestForAttendee(a) {
		if (this.resolvedRecipients.has(a.address.address)) {
			const recipient = this.resolvedRecipients.get(a.address.address);
			return {
				...recipient,
				status: a.status
			};
		} else return {
			address: a.address.address,
			name: a.address.name,
			status: a.status,
			type: RecipientType.UNKNOWN,
			contact: null
		};
	}
	/**
	* add a mail address to the list of invitees.
	* the organizer will always be set to the last of the current user's mail addresses that has been added.
	*
	* if an attendee is deleted an re-added, the status is retained.
	*
	* @param address the mail address to send the invite to
	* @param contact a contact for a display name.
	*/
	addAttendee(address, contact = null) {
		if (!this.canModifyGuests) throw new UserError(lang.makeTranslation("cannotAddAttendees_msg", "Cannot add attendees"));
		const cleanAddress = cleanMailAddress(address);
		if (this._attendees.has(cleanAddress) || this._organizer?.address.address === cleanAddress || this._ownAttendee?.address.address === cleanAddress) return;
		const ownAttendee = findRecipientWithAddress(this.ownMailAddresses, cleanAddress);
		if (ownAttendee != null) this.addOwnAttendee(ownAttendee);
else {
			const name = contact != null ? getContactDisplayName(contact) : "";
			this.addOtherAttendee(createEncryptedMailAddress({
				address: cleanAddress,
				name
			}));
		}
	}
	/**
	* this is a no-op if there are already
	* @param address MUST be one of ours and MUST NOT be in the attendees array or set on _organizer
	* @private
	*/
	addOwnAttendee(address) {
		if (this.hasNotifyableOtherAttendees()) {
			console.log("can't change organizer if there are other invitees already");
			return;
		}
		const attendeeToAdd = createCalendarEventAttendee({
			address,
			status: CalendarAttendeeStatus.ACCEPTED
		});
		this._ownAttendee = attendeeToAdd;
		this._organizer = attendeeToAdd;
		if (!this.resolvedRecipients.has(address.address)) this.resolveAndCacheAddress(address).then(this.uiUpdateCallback);
		this.uiUpdateCallback();
	}
	/**
	*
	* @param address must NOT be one of ours.
	* @private
	*/
	addOtherAttendee(address) {
		if (this._ownAttendee == null) this.addOwnAttendee(this.ownMailAddresses[0]);
		address.address = cleanMailAddress(address.address);
		const previousAttendee = this.initialAttendees.get(address.address);
		if (previousAttendee != null) this._attendees.set(address.address, previousAttendee);
else this._attendees.set(address.address, createCalendarEventAttendee({
			address,
			status: CalendarAttendeeStatus.ADDED
		}));
		if (!this.resolvedRecipients.has(address.address)) this.resolveAndCacheAddress(address).then(this.uiUpdateCallback);
		this.uiUpdateCallback();
	}
	/**
	* remove a single attendee from the list.
	* * if it's the organizer AND there are other attendees, this is a no-op - if there are attendees, someone must be organizer (and it's us)
	* * if it's the organizer AND there are no other attendees, this sets the organizer and ownAttendee
	* * if it's not the organizer, but the last non-organizer attendee, only removes the attendee from the list, but the
	*   result will have an empty attendee list and no organizer if no other attendees are added in the meantime.
	* * if it's not the organizer but not the last non-organizer attendee, just removes that attendee from the list.
	* @param address the attendee to remove.
	*/
	removeAttendee(address) {
		const cleanRemoveAddress = cleanMailAddress(address);
		if (this._organizer?.address.address === cleanRemoveAddress) if (this._attendees.size > 0) {
			console.log("tried to remove organizer while there are other attendees, ignoring.");
			return;
		} else {
			this._organizer = null;
			this._ownAttendee = null;
			this.uiUpdateCallback();
		}
else if (this._attendees.has(cleanRemoveAddress)) {
			this._attendees.delete(cleanRemoveAddress);
			if (this._attendees.size === 0) {
				this._organizer = null;
				this._ownAttendee = null;
			}
			this.uiUpdateCallback();
		}
	}
	/**
	* modify your own attendance to the selected value.
	* is a no-op if we're not actually an attendee
	* @param status
	*/
	setOwnAttendance(status) {
		if (this._ownAttendee) this._ownAttendee.status = status;
	}
	setPresharedPassword(address, password) {
		this.externalPasswords.set(address, password);
	}
	/** for a stored address, get the preshared password and an indicator value for its strength */
	getPresharedPassword(address) {
		const password = this.externalPasswords.get(address) ?? "";
		const recipient = this.resolvedRecipients.get(address);
		const strength = recipient != null ? this.passwordStrengthModel(password, recipient) : 0;
		return {
			password,
			strength
		};
	}
	/**
	* return whether any of the attendees have a password set that warrants asking the user if they really want to use it.
	*
	* ignores empty passwords since those are always a hard fail when sending external mail.
	*/
	hasInsecurePasswords() {
		if (!this.isConfidential) return false;
		for (const g of this._attendees.values()) {
			const { password, strength } = this.getPresharedPassword(g.address.address);
			if (password === "" || isSecurePassword(strength)) continue;
			return true;
		}
		return false;
	}
	prepareSendModel(attendees) {
		if (!this._ownAttendee) return null;
		const recipients = attendees.map(({ address }) => address);
		const model = this.sendMailModelFactory();
		model.initWithTemplate([], "", "");
		for (const recipient of recipients) {
			model.addRecipient(RecipientField.BCC, recipient);
			if (this.externalPasswords.has(recipient.address)) {
				const password = assertNotNull(this.externalPasswords.get(recipient.address));
				model.setPassword(recipient.address, password);
			}
		}
		model.setSender(this._ownAttendee.address.address);
		model.setConfidential(this.isConfidential);
		return model;
	}
	prepareResponseModel() {
		if (this.eventType !== EventType.INVITE || this._ownAttendee === null || this._organizer == null || this._ownAttendee == null) return null;
		const initialOwnAttendeeStatus = assertNotNull(this.initialOwnAttendeeStatus, "somehow managed to become an attendee on an invite we weren't invited to before");
		if (!(initialOwnAttendeeStatus !== this._ownAttendee.status && this._ownAttendee.status !== CalendarAttendeeStatus.NEEDS_ACTION)) return null;
		const responseModel = this.sendMailModelFactory();
		if (this.responseTo != null) responseModel.initAsResponse({
			previousMail: this.responseTo,
			conversationType: ConversationType.REPLY,
			senderMailAddress: this._ownAttendee.address.address,
			recipients: [],
			attachments: [],
			bodyText: "",
			subject: "",
			replyTos: []
		}, new Map());
else responseModel.initWithTemplate({}, "", "");
		responseModel.addRecipient(RecipientField.TO, this._organizer.address);
		return responseModel;
	}
	get result() {
		if (this._selectedCalendar == null) throw new UserError("noCalendar_msg");
		const isOrganizer = this._organizer != null && this._ownAttendee?.address.address === this._organizer.address.address;
		const { kept: attendeesToUpdate, deleted: attendeesToCancel, added: attendeesToInvite } = getRecipientLists(this.initialAttendees, this._attendees, isOrganizer, this.isNew);
		const { allAttendees, organizerToPublish } = assembleAttendees(attendeesToInvite, attendeesToUpdate, this._organizer, this._ownAttendee);
		return {
			attendees: allAttendees,
			organizer: organizerToPublish,
			isConfidential: this.isConfidential,
			cancelModel: isOrganizer && attendeesToCancel.length > 0 ? this.prepareSendModel(attendeesToCancel) : null,
			inviteModel: isOrganizer && attendeesToInvite.length > 0 ? this.prepareSendModel(attendeesToInvite) : null,
			updateModel: isOrganizer && attendeesToUpdate.length > 0 && this.shouldSendUpdates ? this.prepareSendModel(attendeesToUpdate) : null,
			responseModel: !isOrganizer && organizerToPublish != null ? this.prepareResponseModel() : null,
			calendar: this._selectedCalendar
		};
	}
};
function getRecipientLists(initialAttendees, currentAttendees, isOrganizer, isNew) {
	if (!isOrganizer) return {
		added: [],
		deleted: [],
		kept: Array.from(initialAttendees.values())
	};
else if (isNew) return {
		added: Array.from(currentAttendees.values()),
		deleted: [],
		kept: []
	};
else return trisectingDiff(initialAttendees, currentAttendees);
}
/** get the list of attendees and the organizer address to publish.
* the array contains the organizer as an attendee.
*
* if there's only an organizer but no other attendees, no attendees or organizers are returned.
* */
function assembleAttendees(attendeesToInvite, attendeesToUpdate, organizer, ownAttendee) {
	if (organizer == null || attendeesToInvite.length + attendeesToUpdate.length === 0 && (ownAttendee == null || ownAttendee.address.address === organizer?.address.address)) return {
		allAttendees: [],
		organizerToPublish: null
	};
	const allAttendees = [];
	if (organizer.address.address !== ownAttendee?.address.address) allAttendees.push(organizer);
	if (ownAttendee != null) allAttendees.push(ownAttendee);
	allAttendees.push(...attendeesToUpdate);
	allAttendees.push(...attendeesToInvite);
	return {
		allAttendees,
		organizerToPublish: organizer.address
	};
}

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventAlarmModel.ts
var CalendarEventAlarmModel = class {
	_alarms = [];
	/** we can set reminders only if we're able to edit the event on the server because we have to add them to the entity. */
	canEditReminders;
	constructor(eventType, alarms = [], dateProvider, uiUpdateCallback = noOp) {
		this.dateProvider = dateProvider;
		this.uiUpdateCallback = uiUpdateCallback;
		this.canEditReminders = eventType === EventType.OWN || eventType === EventType.SHARED_RW || eventType === EventType.LOCKED || eventType === EventType.INVITE;
		this._alarms = [...alarms];
	}
	/**
	* @param trigger the interval to add.
	*/
	addAlarm(trigger) {
		if (trigger == null) return;
		const alreadyHasAlarm = this._alarms.some((e) => this.isEqualAlarms(trigger, e));
		if (alreadyHasAlarm) return;
		this._alarms.push(trigger);
		this.uiUpdateCallback();
	}
	/**
	* deactivate the alarm for the given interval.
	*/
	removeAlarm(alarmInterval) {
		remove(this._alarms, alarmInterval);
		this.uiUpdateCallback();
	}
	removeAll() {
		this._alarms.splice(0);
	}
	addAll(alarmIntervalList) {
		this._alarms.push(...alarmIntervalList);
	}
	get alarms() {
		return this._alarms;
	}
	get result() {
		return { alarms: Array.from(this._alarms.values()).map((t) => this.makeNewAlarm(t)) };
	}
	makeNewAlarm(alarmInterval) {
		return {
			alarmIdentifier: generateEventElementId(this.dateProvider.now()),
			trigger: serializeAlarmInterval(alarmInterval)
		};
	}
	/**
	* Compares two AlarmIntervals if they have the same duration
	* eg: 60 minutes === 1 hour
	* @param alarmOne base interval
	* @param alarmTwo interval to be compared with
	* @return true if they have the same duration
	*/
	isEqualAlarms(alarmOne, alarmTwo) {
		const luxonAlarmOne = Duration.fromDurationLike(alarmIntervalToLuxonDurationLikeObject(alarmOne)).shiftToAll();
		const luxonAlarmTwo = Duration.fromDurationLike(alarmIntervalToLuxonDurationLikeObject(alarmTwo)).shiftToAll();
		return luxonAlarmOne.equals(luxonAlarmTwo);
	}
};

//#endregion
//#region ../src/common/misc/SanitizedTextViewModel.ts
var SanitizedTextViewModel = class {
	sanitizedText = null;
	constructor(text, sanitizer, uiUpdateCallback = noOp) {
		this.text = text;
		this.sanitizer = sanitizer;
		this.uiUpdateCallback = uiUpdateCallback;
	}
	set content(v) {
		this.sanitizedText = null;
		this.text = v;
		this.uiUpdateCallback();
	}
	get content() {
		if (this.sanitizedText == null) this.sanitizedText = this.sanitizer.sanitizeHTML(this.text, { blockExternalContent: false }).html;
		return this.sanitizedText;
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-model/CalendarNotificationModel.ts
var CalendarNotificationModel = class {
	constructor(notificationSender, loginController) {
		this.notificationSender = notificationSender;
		this.loginController = loginController;
	}
	/**
	* send all notifications required for the new event, determined by the contents of the sendModels parameter.
	*
	* will modify the attendee list of newEvent if invites/cancellations are sent.
	*/
	async send(event, recurrenceIds, sendModels) {
		if (sendModels.updateModel == null && sendModels.cancelModel == null && sendModels.inviteModel == null && sendModels.responseModel == null) return;
		if ((sendModels.updateModel != null || sendModels.cancelModel != null || sendModels.inviteModel != null) && !await hasPlanWithInvites(this.loginController)) {
			const { getAvailablePlansWithCalendarInvites } = await import("./SubscriptionUtils-j-oFQxhJ.js");
			throw new UpgradeRequiredError("upgradeRequired_msg", await getAvailablePlansWithCalendarInvites());
		}
		const recurrenceTimes = recurrenceIds.map((date) => date.getTime());
		const originalExclusions = event.repeatRule?.excludedDates ?? [];
		const filteredExclusions = originalExclusions.filter(({ date }) => !recurrenceTimes.includes(date.getTime()));
		if (event.repeatRule != null) event.repeatRule.excludedDates = filteredExclusions;
		try {
			const invitePromise = sendModels.inviteModel != null ? this.sendInvites(event, sendModels.inviteModel) : Promise.resolve();
			const cancelPromise = sendModels.cancelModel != null ? this.sendCancellation(event, sendModels.cancelModel) : Promise.resolve();
			const updatePromise = sendModels.updateModel != null ? this.sendUpdates(event, sendModels.updateModel) : Promise.resolve();
			const responsePromise = sendModels.responseModel != null ? this.respondToOrganizer(event, sendModels.responseModel) : Promise.resolve();
			await Promise.all([
				invitePromise,
				cancelPromise,
				updatePromise,
				responsePromise
			]);
		} finally {
			if (event.repeatRule != null) event.repeatRule.excludedDates = originalExclusions;
		}
	}
	/**
	* invite all new attendees for an event and set their status from "ADDED" to "NEEDS_ACTION"
	* @param event will be modified if invites are sent.
	* @param inviteModel
	* @private
	*/
	async sendInvites(event, inviteModel) {
		if (event.organizer == null || inviteModel?.allRecipients().length === 0) throw new ProgrammingError("event has no organizer or no invitable attendees, can't send invites.");
		const newAttendees = getNonOrganizerAttendees(event).filter((a) => a.status === CalendarAttendeeStatus.ADDED);
		await inviteModel.waitForResolvedRecipients();
		if (event.invitedConfidentially != null) inviteModel.setConfidential(event.invitedConfidentially);
		await this.notificationSender.sendInvite(event, inviteModel);
		for (const attendee of newAttendees) if (attendee.status === CalendarAttendeeStatus.ADDED) attendee.status = CalendarAttendeeStatus.NEEDS_ACTION;
	}
	async sendCancellation(event, cancelModel) {
		const updatedEvent = clone(event);
		try {
			if (event.invitedConfidentially != null) cancelModel.setConfidential(event.invitedConfidentially);
			await this.notificationSender.sendCancellation(updatedEvent, cancelModel);
		} catch (e) {
			if (e instanceof TooManyRequestsError) throw new UserError("mailAddressDelay_msg");
else throw e;
		}
	}
	async sendUpdates(event, updateModel) {
		await updateModel.waitForResolvedRecipients();
		if (event.invitedConfidentially != null) updateModel.setConfidential(event.invitedConfidentially);
		await this.notificationSender.sendUpdate(event, updateModel);
	}
	/**
	* send a response mail to the organizer as stated on the original event. calling this for an event that is not an invite or
	* does not contain address as an attendee or that has no organizer is an error.
	* @param newEvent the event to send the update for, this should be identical to existingEvent except for the own status.
	* @param responseModel
	* @private
	*/
	async respondToOrganizer(newEvent, responseModel) {
		await responseModel.waitForResolvedRecipients();
		if (newEvent.invitedConfidentially != null) responseModel.setConfidential(newEvent.invitedConfidentially);
		await this.notificationSender.sendResponse(newEvent, responseModel);
		responseModel.dispose();
	}
};
async function hasPlanWithInvites(loginController) {
	const userController = loginController.getUserController();
	const { user } = userController;
	if (user.accountType === AccountType.FREE || user.accountType === AccountType.EXTERNAL) return false;
	const customer = await loginController.getUserController().loadCustomer();
	return (await userController.getPlanConfig()).eventInvites;
}

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventModelStrategy.ts
var CalendarEventApplyStrategies = class {
	constructor(calendarModel, logins, notificationModel, lazyRecurrenceIds, showProgress = identity, zone) {
		this.calendarModel = calendarModel;
		this.logins = logins;
		this.notificationModel = notificationModel;
		this.lazyRecurrenceIds = lazyRecurrenceIds;
		this.showProgress = showProgress;
		this.zone = zone;
	}
	/**
	* save a new event to the selected calendar, invite all attendees except for the organizer and set up alarms.
	*/
	async saveNewEvent(editModels) {
		const { eventValues, newAlarms, sendModels, calendar } = assembleCalendarEventEditResult(editModels);
		const uid = generateUid(calendar.group._id, Date.now());
		const newEvent = assignEventIdentity(eventValues, { uid });
		assertEventValidity(newEvent);
		const { groupRoot } = calendar;
		await this.showProgress((async () => {
			await this.notificationModel.send(newEvent, [], sendModels);
			await this.calendarModel.createEvent(newEvent, newAlarms, this.zone, groupRoot);
		})());
	}
	/** all instances of an event will be updated. if the recurrenceIds are invalidated (rrule or startTime changed),
	* will delete all altered instances and exclusions. */
	async saveEntireExistingEvent(editModelsForProgenitor, existingEvent) {
		const uid = assertNotNull(existingEvent.uid, "no uid to update existing event");
		assertNotNull(existingEvent?._id, "no id to update existing event");
		assertNotNull(existingEvent?._ownerGroup, "no ownerGroup to update existing event");
		assertNotNull(existingEvent?._permissions, "no permissions to update existing event");
		const { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(existingEvent, editModelsForProgenitor, CalendarOperation.EditAll);
		const { groupRoot } = calendar;
		await this.showProgress((async () => {
			const recurrenceIds = await this.lazyRecurrenceIds(uid);
			await this.notificationModel.send(newEvent, recurrenceIds, sendModels);
			await this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, existingEvent);
			const invalidateAlteredInstances = newEvent.repeatRule && newEvent.repeatRule.excludedDates.length === 0;
			const newDuration = editModelsForProgenitor.whenModel.duration;
			const index = await this.calendarModel.getEventsByUid(uid);
			if (index == null) return;
			for (const occurrence of index.alteredInstances) if (invalidateAlteredInstances) {
				editModelsForProgenitor.whoModel.shouldSendUpdates = true;
				const { sendModels: sendModels$1 } = assembleEditResultAndAssignFromExisting(occurrence, editModelsForProgenitor, CalendarOperation.EditThis);
				for (const recipient of sendModels$1.cancelModel?.allRecipients() ?? []) sendModels$1.updateModel?.addRecipient(RecipientField.BCC, recipient);
				sendModels$1.cancelModel = sendModels$1.updateModel;
				sendModels$1.updateModel = null;
				sendModels$1.inviteModel = null;
				await this.notificationModel.send(occurrence, [], sendModels$1);
				await this.calendarModel.deleteEvent(occurrence);
			} else {
				const { newEvent: newEvent$1, newAlarms: newAlarms$1, sendModels: sendModels$1 } = assembleEditResultAndAssignFromExisting(occurrence, editModelsForProgenitor, CalendarOperation.EditThis);
				newEvent$1.startTime = occurrence.startTime;
				newEvent$1.endTime = DateTime.fromJSDate(newEvent$1.startTime, { zone: this.zone }).plus(newDuration).toJSDate();
				newEvent$1.repeatRule = null;
				await this.notificationModel.send(newEvent$1, [], sendModels$1);
				await this.calendarModel.updateEvent(newEvent$1, newAlarms$1, this.zone, groupRoot, occurrence);
			}
		})());
	}
	async saveNewAlteredInstance({ editModels, editModelsForProgenitor, existingInstance, progenitor }) {
		await this.showProgress((async () => {
			const { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(existingInstance, editModels, CalendarOperation.EditThis);
			await this.notificationModel.send(newEvent, [], sendModels);
			editModelsForProgenitor.whoModel.shouldSendUpdates = true;
			editModelsForProgenitor.whenModel.excludeDate(existingInstance.startTime);
			const { newEvent: newProgenitor, sendModels: progenitorSendModels, newAlarms: progenitorAlarms } = assembleEditResultAndAssignFromExisting(progenitor, editModelsForProgenitor, CalendarOperation.EditAll);
			const recurrenceIds = await this.lazyRecurrenceIds(progenitor.uid);
			recurrenceIds.push(existingInstance.startTime);
			await this.notificationModel.send(newProgenitor, recurrenceIds, progenitorSendModels);
			await this.calendarModel.updateEvent(newProgenitor, progenitorAlarms, this.zone, calendar.groupRoot, progenitor);
			const { groupRoot } = calendar;
			await this.calendarModel.createEvent(newEvent, newAlarms, this.zone, groupRoot);
		})());
	}
	async saveExistingAlteredInstance(editModels, existingInstance) {
		const { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(existingInstance, editModels, CalendarOperation.EditThis);
		const { groupRoot } = calendar;
		await this.showProgress((async () => {
			await this.notificationModel.send(newEvent, [], sendModels);
			await this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, existingInstance);
		})());
	}
	/** delete a whole event and all the instances generated by it */
	async deleteEntireExistingEvent(editModels, existingEvent) {
		editModels.whoModel.shouldSendUpdates = true;
		const { sendModels } = assembleCalendarEventEditResult(editModels);
		await this.showProgress((async () => {
			const alteredOccurrences = await this.calendarModel.getEventsByUid(assertNotNull(existingEvent.uid));
			if (alteredOccurrences) for (const occurrence of alteredOccurrences.alteredInstances) {
				if (occurrence.attendees.length === 0) continue;
				const { sendModels: sendModels$1 } = assembleEditResultAndAssignFromExisting(occurrence, editModels, CalendarOperation.DeleteAll);
				sendModels$1.cancelModel = sendModels$1.updateModel;
				sendModels$1.updateModel = null;
				await this.notificationModel.send(occurrence, [], sendModels$1);
			}
			sendModels.cancelModel = sendModels.updateModel;
			sendModels.updateModel = null;
			await this.notificationModel.send(existingEvent, [], sendModels);
			if (existingEvent.uid != null) await this.calendarModel.deleteEventsByUid(existingEvent.uid);
			await this.calendarModel.deleteEvent(existingEvent);
		})());
	}
	/** add an exclusion to the progenitor and send an update. */
	async excludeSingleInstance(editModelsForProgenitor, existingInstance, progenitor) {
		await this.showProgress((async () => {
			editModelsForProgenitor.whoModel.shouldSendUpdates = true;
			editModelsForProgenitor.whenModel.excludeDate(existingInstance.startTime);
			const { newEvent, sendModels, calendar, newAlarms } = assembleEditResultAndAssignFromExisting(progenitor, editModelsForProgenitor, CalendarOperation.DeleteThis);
			const recurrenceIds = await this.lazyRecurrenceIds(progenitor.uid);
			recurrenceIds.push(existingInstance.startTime);
			await this.notificationModel.send(newEvent, recurrenceIds, sendModels);
			await this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, calendar.groupRoot, progenitor);
		})());
	}
	/** only remove a single altered instance from the server & the uid index. will not modify the progenitor. */
	async deleteAlteredInstance(editModels, existingAlteredInstance) {
		editModels.whoModel.shouldSendUpdates = true;
		const { sendModels } = assembleCalendarEventEditResult(editModels);
		sendModels.cancelModel = sendModels.updateModel;
		sendModels.updateModel = null;
		await this.showProgress((async () => {
			await this.notificationModel.send(existingAlteredInstance, [], sendModels);
			await this.calendarModel.deleteEvent(existingAlteredInstance);
		})());
	}
};

//#endregion
//#region ../src/common/misc/SimpleTextViewModel.ts
var SimpleTextViewModel = class {
	constructor(text, uiUpdateCallback = noOp) {
		this.text = text;
		this.uiUpdateCallback = uiUpdateCallback;
	}
	set content(text) {
		this.text = text;
		this.uiUpdateCallback();
	}
	get content() {
		return this.text;
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventModel.ts
let EventType = function(EventType$1) {
	/** event in our own calendar and we are organizer */
	EventType$1["OWN"] = "own";
	/** event in shared calendar with read permission */
	EventType$1["SHARED_RO"] = "shared_ro";
	/** event in shared calendar with write permission, that has no attendees */
	EventType$1["SHARED_RW"] = "shared_rw";
	/** shared with write permissions, but we can't edit anything but alarms because it has attendees. might be something the calendar owner was invited to. */
	EventType$1["LOCKED"] = "locked";
	/** invite from calendar invitation which is not stored in calendar yet, or event stored in **own calendar** and we are not organizer. */
	EventType$1["INVITE"] = "invite";
	/** we are an external user and see an event in our mailbox */
	EventType$1["EXTERNAL"] = "external";
	return EventType$1;
}({});
let ReadonlyReason = function(ReadonlyReason$1) {
	/** it's a shared event, so at least the attendees are read-only */
	ReadonlyReason$1[ReadonlyReason$1["SHARED"] = 0] = "SHARED";
	/** this edit operation applies to only part of a series, so attendees and calendar are read-only */
	ReadonlyReason$1[ReadonlyReason$1["SINGLE_INSTANCE"] = 1] = "SINGLE_INSTANCE";
	/** the organizer is not the current user */
	ReadonlyReason$1[ReadonlyReason$1["NOT_ORGANIZER"] = 2] = "NOT_ORGANIZER";
	/** the event cannot be edited for an unspecified reason. This is the default value */
	ReadonlyReason$1[ReadonlyReason$1["UNKNOWN"] = 3] = "UNKNOWN";
	/** we can edit anything here */
	ReadonlyReason$1[ReadonlyReason$1["NONE"] = 4] = "NONE";
	return ReadonlyReason$1;
}({});
let CalendarOperation = function(CalendarOperation$1) {
	/** create a new event */
	CalendarOperation$1[CalendarOperation$1["Create"] = 0] = "Create";
	/** only apply an edit to only one particular instance of the series */
	CalendarOperation$1[CalendarOperation$1["EditThis"] = 1] = "EditThis";
	/** Delete a single instance from a series, altered or not */
	CalendarOperation$1[CalendarOperation$1["DeleteThis"] = 2] = "DeleteThis";
	/** apply the edit operation to all instances of the series*/
	CalendarOperation$1[CalendarOperation$1["EditAll"] = 3] = "EditAll";
	/** delete the whole series */
	CalendarOperation$1[CalendarOperation$1["DeleteAll"] = 4] = "DeleteAll";
	return CalendarOperation$1;
}({});
async function makeCalendarEventModel(operation, initialValues, recipientsModel, calendarModel, logins, mailboxDetail, mailboxProperties, sendMailModelFactory, notificationSender, entityClient, responseTo, zone = getTimeZone(), showProgress = identity, uiUpdateCallback = mithril_default.redraw) {
	const { htmlSanitizer } = await import("./HtmlSanitizer-DJqF9m1z.js");
	const ownMailAddresses = getOwnMailAddressesWithDefaultSenderInFront(logins, mailboxDetail, mailboxProperties);
	if (operation === CalendarOperation.DeleteAll || operation === CalendarOperation.EditAll) {
		assertNonNull(initialValues.uid, "tried to edit/delete all with nonexistent uid");
		const index = await calendarModel.getEventsByUid(initialValues.uid);
		if (index != null && index.progenitor != null) initialValues = index.progenitor;
	}
	const user = logins.getUserController().user;
	const [alarms, calendars] = await Promise.all([resolveAlarmsForEvent(initialValues.alarmInfos ?? [], calendarModel, user), calendarModel.getCalendarInfos()]);
	const selectedCalendar = getPreselectedCalendar(calendars, initialValues);
	const getPasswordStrength = (password, recipientInfo) => getPasswordStrengthForUser(password, recipientInfo, mailboxDetail, logins);
	const eventType = getEventType(initialValues, calendars, ownMailAddresses.map(({ address }) => address), logins.getUserController());
	const makeEditModels = (initializationEvent) => ({
		whenModel: new CalendarEventWhenModel(initializationEvent, zone, uiUpdateCallback),
		whoModel: new CalendarEventWhoModel(initializationEvent, eventType, operation, calendars, selectedCalendar, logins.getUserController(), operation === CalendarOperation.Create, ownMailAddresses, recipientsModel, responseTo, getPasswordStrength, sendMailModelFactory, uiUpdateCallback),
		alarmModel: new CalendarEventAlarmModel(eventType, alarms, new DefaultDateProvider(), uiUpdateCallback),
		location: new SimpleTextViewModel(initializationEvent.location, uiUpdateCallback),
		summary: new SimpleTextViewModel(initializationEvent.summary, uiUpdateCallback),
		description: new SanitizedTextViewModel(initializationEvent.description, htmlSanitizer, uiUpdateCallback)
	});
	const recurrenceIds = async (uid) => uid == null ? [] : (await calendarModel.getEventsByUid(uid))?.alteredInstances.map((i) => i.recurrenceId) ?? [];
	const notificationModel = new CalendarNotificationModel(notificationSender, logins);
	const applyStrategies = new CalendarEventApplyStrategies(calendarModel, logins, notificationModel, recurrenceIds, showProgress, zone);
	const initialOrDefaultValues = Object.assign(makeEmptyCalendarEvent(), initialValues);
	const cleanInitialValues = cleanupInitialValuesForEditing(initialOrDefaultValues);
	const progenitor = () => calendarModel.resolveCalendarEventProgenitor(cleanInitialValues);
	const strategy = await selectStrategy(makeEditModels, applyStrategies, operation, progenitor, createCalendarEvent(initialOrDefaultValues), cleanInitialValues);
	return strategy && new CalendarEventModel(strategy, eventType, operation, logins.getUserController(), notificationSender, entityClient, calendars);
}
async function selectStrategy(makeEditModels, applyStrategies, operation, resolveProgenitor, existingInstanceIdentity, cleanInitialValues) {
	let editModels;
	let apply;
	let mayRequireSendingUpdates;
	if (operation === CalendarOperation.Create) {
		editModels = makeEditModels(cleanInitialValues);
		apply = () => applyStrategies.saveNewEvent(editModels);
		mayRequireSendingUpdates = () => true;
	} else if (operation === CalendarOperation.EditThis) {
		cleanInitialValues.repeatRule = null;
		if (cleanInitialValues.recurrenceId == null) {
			const progenitor = await resolveProgenitor();
			if (progenitor == null || progenitor.repeatRule == null) {
				console.warn("no repeating progenitor during EditThis operation?");
				return null;
			}
			apply = () => applyStrategies.saveNewAlteredInstance({
				editModels,
				editModelsForProgenitor: makeEditModels(progenitor),
				existingInstance: existingInstanceIdentity,
				progenitor
			});
			mayRequireSendingUpdates = () => true;
			editModels = makeEditModels(cleanInitialValues);
		} else {
			editModels = makeEditModels(cleanInitialValues);
			apply = () => applyStrategies.saveExistingAlteredInstance(editModels, existingInstanceIdentity);
			mayRequireSendingUpdates = () => assembleEditResultAndAssignFromExisting(existingInstanceIdentity, editModels, operation).hasUpdateWorthyChanges;
		}
	} else if (operation === CalendarOperation.DeleteThis) if (cleanInitialValues.recurrenceId == null) {
		const progenitor = await resolveProgenitor();
		if (progenitor == null) return null;
		editModels = makeEditModels(progenitor);
		apply = () => applyStrategies.excludeSingleInstance(editModels, existingInstanceIdentity, progenitor);
		mayRequireSendingUpdates = () => true;
	} else {
		editModels = makeEditModels(cleanInitialValues);
		apply = () => applyStrategies.deleteAlteredInstance(editModels, existingInstanceIdentity);
		mayRequireSendingUpdates = () => true;
	}
else if (operation === CalendarOperation.EditAll) {
		const progenitor = await resolveProgenitor();
		if (progenitor == null) return null;
		editModels = makeEditModels(cleanInitialValues);
		apply = () => applyStrategies.saveEntireExistingEvent(editModels, progenitor);
		mayRequireSendingUpdates = () => assembleEditResultAndAssignFromExisting(existingInstanceIdentity, editModels, operation).hasUpdateWorthyChanges;
	} else if (operation === CalendarOperation.DeleteAll) {
		editModels = makeEditModels(cleanInitialValues);
		apply = () => applyStrategies.deleteEntireExistingEvent(editModels, existingInstanceIdentity);
		mayRequireSendingUpdates = () => assembleEditResultAndAssignFromExisting(existingInstanceIdentity, editModels, operation).hasUpdateWorthyChanges;
	} else throw new ProgrammingError(`unknown calendar operation: ${operation}`);
	return {
		apply,
		mayRequireSendingUpdates,
		editModels
	};
}
function getNonOrganizerAttendees({ organizer, attendees }) {
	if (attendees == null) return [];
	if (organizer == null) return attendees;
	const organizerAddress = cleanMailAddress(organizer.address);
	return attendees.filter((a) => cleanMailAddress(a.address.address) !== organizerAddress) ?? [];
}
var CalendarEventModel = class {
	processing = false;
	get editModels() {
		return this.strategy.editModels;
	}
	constructor(strategy, eventType, operation, userController, distributor, entityClient, calendars) {
		this.strategy = strategy;
		this.eventType = eventType;
		this.operation = operation;
		this.userController = userController;
		this.distributor = distributor;
		this.entityClient = entityClient;
		this.calendars = calendars;
		this.calendars = calendars;
	}
	async apply() {
		if (this.userController.user.accountType === AccountType.EXTERNAL) {
			console.log("did not apply event changes, we're an external user.");
			return EventSaveResult.Failed;
		}
		if (this.processing) return EventSaveResult.Failed;
		this.processing = true;
		try {
			await this.strategy.apply();
			return EventSaveResult.Saved;
		} catch (e) {
			if (e instanceof PayloadTooLargeError) throw new UserError("requestTooLarge_msg");
else if (e instanceof NotFoundError) return EventSaveResult.NotFound;
else throw e;
		} finally {
			this.processing = false;
		}
	}
	/** false if the event is only partially or not at all writable */
	isFullyWritable() {
		return this.eventType === EventType.OWN || this.eventType === EventType.SHARED_RW;
	}
	/** some edit operations apply to the whole event series.
	* they are not possible if the operation the model was created with only applies to a single instance.
	*
	* returns true if such operations can be attempted.
	* */
	canEditSeries() {
		return this.operation !== CalendarOperation.EditThis && (this.eventType === EventType.OWN || this.eventType === EventType.SHARED_RW);
	}
	canChangeCalendar() {
		return this.operation !== CalendarOperation.EditThis && (this.eventType === EventType.OWN || this.eventType === EventType.SHARED_RW || this.eventType === EventType.INVITE);
	}
	isAskingForUpdatesNeeded() {
		return this.eventType === EventType.OWN && !this.editModels.whoModel.shouldSendUpdates && this.editModels.whoModel.initiallyHadOtherAttendees && this.strategy.mayRequireSendingUpdates();
	}
	getReadonlyReason() {
		const isFullyWritable = this.isFullyWritable();
		const canEditSeries = this.canEditSeries();
		const canModifyGuests = this.editModels.whoModel.canModifyGuests;
		if (isFullyWritable && canEditSeries && canModifyGuests) return ReadonlyReason.NONE;
		if (!isFullyWritable && !canEditSeries && !canModifyGuests) return ReadonlyReason.NOT_ORGANIZER;
		if (!canModifyGuests) if (canEditSeries) return ReadonlyReason.SHARED;
else return ReadonlyReason.SINGLE_INSTANCE;
		return ReadonlyReason.UNKNOWN;
	}
};
function eventHasChanged(now, previous) {
	if (previous == null) return true;
	return now.startTime.getTime() !== previous?.startTime?.getTime() || now.description !== previous?.description || now.summary !== previous.summary || now.location !== previous.location || now.endTime.getTime() !== previous?.endTime?.getTime() || now.invitedConfidentially !== previous.invitedConfidentially || now.uid !== previous.uid || !areRepeatRulesEqual(now.repeatRule, previous?.repeatRule ?? null) || !arrayEqualsWithPredicate(now.attendees, previous?.attendees ?? [], (a1, a2) => a1.status === a2.status && cleanMailAddress(a1.address.address) === cleanMailAddress(a2.address.address)) || now.organizer !== previous.organizer && now.organizer?.address !== previous.organizer?.address;
}
function assembleCalendarEventEditResult(models) {
	const whenResult = models.whenModel.result;
	const whoResult = models.whoModel.result;
	const alarmResult = models.alarmModel.result;
	const summary = models.summary.content;
	const description = models.description.content;
	const location = models.location.content;
	return {
		eventValues: {
			startTime: whenResult.startTime,
			endTime: whenResult.endTime,
			repeatRule: whenResult.repeatRule,
			summary,
			description,
			location,
			invitedConfidentially: whoResult.isConfidential,
			organizer: whoResult.organizer,
			attendees: whoResult.attendees,
			alarmInfos: []
		},
		newAlarms: alarmResult.alarms,
		sendModels: whoResult,
		calendar: whoResult.calendar
	};
}
function assembleEditResultAndAssignFromExisting(existingEvent, editModels, operation) {
	const assembleResult = assembleCalendarEventEditResult(editModels);
	const { uid: oldUid, sequence: oldSequence, recurrenceId } = existingEvent;
	const newEvent = assignEventIdentity(assembleResult.eventValues, {
		uid: oldUid,
		sequence: incrementSequence(oldSequence),
		recurrenceId: operation === CalendarOperation.EditThis && recurrenceId == null ? existingEvent.startTime : recurrenceId
	});
	assertEventValidity(newEvent);
	newEvent._id = existingEvent._id;
	newEvent._ownerGroup = existingEvent._ownerGroup;
	newEvent._permissions = existingEvent._permissions;
	return {
		hasUpdateWorthyChanges: eventHasChanged(newEvent, existingEvent),
		newEvent,
		calendar: assembleResult.calendar,
		newAlarms: assembleResult.newAlarms,
		sendModels: assembleResult.sendModels
	};
}
function assignEventIdentity(values, identity$1) {
	return createCalendarEvent({
		sequence: "0",
		recurrenceId: null,
		hashedUid: null,
		...values,
		...identity$1
	});
}
async function resolveAlarmsForEvent(alarms, calendarModel, user) {
	const alarmInfos = await calendarModel.loadAlarms(alarms, user);
	return alarmInfos.map(({ alarmInfo }) => parseAlarmInterval(alarmInfo.trigger));
}
function makeEmptyCalendarEvent() {
	return {
		alarmInfos: [],
		invitedConfidentially: null,
		hashedUid: null,
		uid: null,
		recurrenceId: null,
		endTime: new Date(),
		summary: "",
		startTime: new Date(),
		location: "",
		repeatRule: null,
		description: "",
		attendees: [],
		organizer: null,
		sequence: ""
	};
}
function cleanupInitialValuesForEditing(initialValues) {
	const stripped = getStrippedClone(initialValues);
	const result = createCalendarEvent(stripped);
	result.alarmInfos = [];
	return result;
}
let EventSaveResult = function(EventSaveResult$1) {
	EventSaveResult$1[EventSaveResult$1["Saved"] = 0] = "Saved";
	EventSaveResult$1[EventSaveResult$1["Failed"] = 1] = "Failed";
	EventSaveResult$1[EventSaveResult$1["NotFound"] = 2] = "NotFound";
	return EventSaveResult$1;
}({});
/**
* return the calendar the given event belongs to, if any, otherwise get the first one from the given calendars.
* @param calendars must contain at least one calendar
* @param event
*/
function getPreselectedCalendar(calendars, event) {
	const ownerGroup = event?._ownerGroup ?? null;
	if (ownerGroup == null || !calendars.has(ownerGroup)) {
		const calendar = findFirstPrivateCalendar(calendars);
		if (!calendar) throw new Error("Can't find a private calendar");
		return calendar;
	} else return assertNotNull(calendars.get(ownerGroup), "invalid ownergroup for existing event?");
}
/** get the list of mail addresses that are enabled for this mailbox with the configured sender names
* will put the sender that matches the default sender address in the first spot. this enables us to use
* it as an easy default without having to pass it around separately */
function getOwnMailAddressesWithDefaultSenderInFront(logins, mailboxDetail, mailboxProperties) {
	const defaultSender = getDefaultSender(logins, mailboxDetail);
	const ownMailAddresses = mailboxProperties.mailAddressProperties.map(({ mailAddress, senderName }) => createEncryptedMailAddress({
		address: mailAddress,
		name: senderName
	}));
	const defaultIndex = ownMailAddresses.findIndex((address) => address.address === defaultSender);
	if (defaultIndex < 0) return ownMailAddresses;
	const defaultEncryptedMailAddress = ownMailAddresses.splice(defaultIndex, 1);
	return [...defaultEncryptedMailAddress, ...ownMailAddresses];
}

//#endregion
//#region ../src/calendar-app/calendar/gui/CalendarGuiUtils.ts
function askIfShouldSendCalendarUpdatesToAttendees() {
	return new Promise((resolve) => {
		let alertDialog;
		const cancelButton = {
			label: "cancel_action",
			click: () => {
				resolve("cancel");
				alertDialog.close();
			},
			type: ButtonType.Secondary
		};
		const noButton = {
			label: "no_label",
			click: () => {
				resolve("no");
				alertDialog.close();
			},
			type: ButtonType.Secondary
		};
		const yesButton = {
			label: "yes_label",
			click: () => {
				resolve("yes");
				alertDialog.close();
			},
			type: ButtonType.Primary
		};
		const onclose = (positive) => positive ? resolve("yes") : resolve("cancel");
		alertDialog = Dialog.confirmMultiple("sendUpdates_msg", [
			cancelButton,
			noButton,
			yesButton
		], onclose);
	});
}
function getDateFromMousePos({ x, y, targetWidth, targetHeight }, weeks) {
	assert(weeks.length > 0, "Weeks must not be zero length");
	const unitHeight = targetHeight / weeks.length;
	const currentSquareY = Math.floor(y / unitHeight);
	const week = weeks[clamp(currentSquareY, 0, weeks.length - 1)];
	assert(week.length > 0, "Week must not be zero length");
	const unitWidth = targetWidth / week.length;
	const currentSquareX = Math.floor(x / unitWidth);
	return week[clamp(currentSquareX, 0, week.length - 1)];
}
function getTimeFromMousePos({ y, targetHeight }, hourDivision) {
	const sectionHeight = targetHeight / 24;
	const hour = y / sectionHeight;
	const hourRounded = Math.floor(hour);
	const minutesInc = 60 / hourDivision;
	const minute = Math.floor((hour - hourRounded) * hourDivision) * minutesInc;
	return new Time(hourRounded, minute);
}
function getCalendarMonth(date, firstDayOfWeekFromOffset, weekdayNarrowFormat) {
	const weeks = [[]];
	const calculationDate = getStartOfDay(date);
	calculationDate.setDate(1);
	const beginningOfMonth = new Date(calculationDate);
	let currentYear = calculationDate.getFullYear();
	let month = calculationDate.getMonth();
	let firstDay;
	if (firstDayOfWeekFromOffset > calculationDate.getDay()) firstDay = calculationDate.getDay() + 7 - firstDayOfWeekFromOffset;
else firstDay = calculationDate.getDay() - firstDayOfWeekFromOffset;
	let dayCount;
	incrementDate(calculationDate, -firstDay);
	for (dayCount = 0; dayCount < firstDay; dayCount++) {
		weeks[0].push({
			date: new Date(calculationDate),
			day: calculationDate.getDate(),
			month: calculationDate.getMonth(),
			year: calculationDate.getFullYear(),
			isPaddingDay: true
		});
		incrementDate(calculationDate, 1);
	}
	while (calculationDate.getMonth() === month) {
		if (weeks[0].length && dayCount % 7 === 0) weeks.push([]);
		const dayInfo = {
			date: new Date(currentYear, month, calculationDate.getDate()),
			year: currentYear,
			month,
			day: calculationDate.getDate(),
			isPaddingDay: false
		};
		weeks[weeks.length - 1].push(dayInfo);
		incrementDate(calculationDate, 1);
		dayCount++;
	}
	while (dayCount < 42) {
		if (dayCount % 7 === 0) weeks.push([]);
		weeks[weeks.length - 1].push({
			day: calculationDate.getDate(),
			year: calculationDate.getFullYear(),
			month: calculationDate.getMonth(),
			date: new Date(calculationDate),
			isPaddingDay: true
		});
		incrementDate(calculationDate, 1);
		dayCount++;
	}
	const weekdays = [];
	const weekdaysDate = new Date();
	incrementDate(weekdaysDate, -weekdaysDate.getDay() + firstDayOfWeekFromOffset);
	for (let i = 0; i < 7; i++) {
		weekdays.push(weekdayNarrowFormat ? lang.formats.weekdayNarrow.format(weekdaysDate) : lang.formats.weekdayShort.format(weekdaysDate));
		incrementDate(weekdaysDate, 1);
	}
	return {
		beginningOfMonth,
		weekdays,
		weeks
	};
}
function formatEventDuration(event, zone, includeTimezone) {
	if (isAllDayEvent(event)) {
		const startTime = getEventStart(event, zone);
		const startString = formatDateWithMonth(startTime);
		const endTime = incrementByRepeatPeriod(getEventEnd(event, zone), RepeatPeriod.DAILY, -1, zone);
		if (isSameDayOfDate(startTime, endTime)) return `${lang.get("allDay_label")}, ${startString}`;
else return `${lang.get("allDay_label")}, ${startString} - ${formatDateWithMonth(endTime)}`;
	} else {
		const startString = formatDateTime(event.startTime);
		let endString;
		if (isSameDay(event.startTime, event.endTime)) endString = formatTime(event.endTime);
else endString = formatDateTime(event.endTime);
		return `${startString} - ${endString} ${includeTimezone ? getTimeZone() : ""}`;
	}
}
const createRepeatRuleFrequencyValues = () => {
	return [
		{
			name: lang.get("calendarRepeatIntervalNoRepeat_label"),
			value: null
		},
		{
			name: lang.get("calendarRepeatIntervalDaily_label"),
			value: RepeatPeriod.DAILY
		},
		{
			name: lang.get("calendarRepeatIntervalWeekly_label"),
			value: RepeatPeriod.WEEKLY
		},
		{
			name: lang.get("calendarRepeatIntervalMonthly_label"),
			value: RepeatPeriod.MONTHLY
		},
		{
			name: lang.get("calendarRepeatIntervalAnnually_label"),
			value: RepeatPeriod.ANNUALLY
		}
	];
};
const createRepeatRuleOptions = () => {
	return [
		{
			name: "calendarRepeatIntervalNoRepeat_label",
			value: null
		},
		{
			name: "calendarRepeatIntervalDaily_label",
			value: RepeatPeriod.DAILY
		},
		{
			name: "calendarRepeatIntervalWeekly_label",
			value: RepeatPeriod.WEEKLY
		},
		{
			name: "calendarRepeatIntervalMonthly_label",
			value: RepeatPeriod.MONTHLY
		},
		{
			name: "calendarRepeatIntervalAnnually_label",
			value: RepeatPeriod.ANNUALLY
		},
		{
			name: "custom_label",
			value: "CUSTOM"
		}
	];
};
const customFrequenciesOptions = [
	{
		name: {
			singular: "day_label",
			plural: "days_label"
		},
		value: RepeatPeriod.DAILY
	},
	{
		name: {
			singular: "week_label",
			plural: "weeks_label"
		},
		value: RepeatPeriod.WEEKLY
	},
	{
		name: {
			singular: "month_label",
			plural: "months_label"
		},
		value: RepeatPeriod.MONTHLY
	},
	{
		name: {
			singular: "year_label",
			plural: "years_label"
		},
		value: RepeatPeriod.ANNUALLY
	}
];
const createCustomEndTypeOptions = () => {
	return [
		{
			name: "calendarRepeatStopConditionNever_label",
			value: EndType.Never
		},
		{
			name: "calendarRepeatStopConditionOccurrences_label",
			value: EndType.Count
		},
		{
			name: "calendarRepeatStopConditionDate_label",
			value: EndType.UntilDate
		}
	];
};
const createIntervalValues = () => numberRange(1, 256).map((n) => ({
	name: String(n),
	value: n,
	ariaValue: String(n)
}));
function humanDescriptionForAlarmInterval(value, locale) {
	if (value.value === 0) return lang.get("calendarReminderIntervalAtEventStart_label");
	return Duration.fromObject(alarmIntervalToLuxonDurationLikeObject(value)).reconfigure({ locale }).toHuman();
}
const createAlarmIntervalItems = (locale) => typedValues(StandardAlarmInterval).map((value) => {
	return {
		value,
		name: humanDescriptionForAlarmInterval(value, locale)
	};
});
const createAttendingItems = () => [
	{
		name: lang.get("attending_label"),
		value: CalendarAttendeeStatus.ACCEPTED,
		ariaValue: lang.get("attending_label")
	},
	{
		name: lang.get("maybeAttending_label"),
		value: CalendarAttendeeStatus.TENTATIVE,
		ariaValue: lang.get("maybeAttending_label")
	},
	{
		name: lang.get("notAttending_label"),
		value: CalendarAttendeeStatus.DECLINED,
		ariaValue: lang.get("notAttending_label")
	},
	{
		name: lang.get("pending_label"),
		value: CalendarAttendeeStatus.NEEDS_ACTION,
		selectable: false,
		ariaValue: lang.get("pending_label")
	}
];
function humanDescriptionForAlarmIntervalUnit(unit) {
	switch (unit) {
		case AlarmIntervalUnit.MINUTE: return lang.get("calendarReminderIntervalUnitMinutes_label");
		case AlarmIntervalUnit.HOUR: return lang.get("calendarReminderIntervalUnitHours_label");
		case AlarmIntervalUnit.DAY: return lang.get("calendarReminderIntervalUnitDays_label");
		case AlarmIntervalUnit.WEEK: return lang.get("calendarReminderIntervalUnitWeeks_label");
	}
}
const createCustomRepeatRuleUnitValues = () => {
	return [
		{
			name: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.MINUTE),
			value: AlarmIntervalUnit.MINUTE
		},
		{
			name: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.HOUR),
			value: AlarmIntervalUnit.HOUR
		},
		{
			name: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.DAY),
			value: AlarmIntervalUnit.DAY
		},
		{
			name: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.WEEK),
			value: AlarmIntervalUnit.WEEK
		}
	];
};
const CALENDAR_EVENT_HEIGHT = size.calendar_line_height + 2;
let EventLayoutMode = function(EventLayoutMode$1) {
	/** Take event start and end times into account when laying out. */
	EventLayoutMode$1[EventLayoutMode$1["TimeBasedColumn"] = 0] = "TimeBasedColumn";
	/** Each event is treated as if it would take the whole day when laying out. */
	EventLayoutMode$1[EventLayoutMode$1["DayBasedColumn"] = 1] = "DayBasedColumn";
	return EventLayoutMode$1;
}({});
function getEventColor(event, groupColors) {
	return (event._ownerGroup && groupColors.get(event._ownerGroup)) ?? defaultCalendarColor;
}
function calendarAttendeeStatusSymbol(status) {
	switch (status) {
		case CalendarAttendeeStatus.ADDED:
		case CalendarAttendeeStatus.NEEDS_ACTION: return "";
		case CalendarAttendeeStatus.TENTATIVE: return "?";
		case CalendarAttendeeStatus.ACCEPTED: return "✓";
		case CalendarAttendeeStatus.DECLINED: return "❌";
		default: throw new Error("Unknown calendar attendee status: " + status);
	}
}
const iconForAttendeeStatus = Object.freeze({
	[CalendarAttendeeStatus.ACCEPTED]: Icons.CircleCheckmark,
	[CalendarAttendeeStatus.TENTATIVE]: Icons.CircleHelp,
	[CalendarAttendeeStatus.DECLINED]: Icons.CircleReject,
	[CalendarAttendeeStatus.NEEDS_ACTION]: Icons.CircleHelp,
	[CalendarAttendeeStatus.ADDED]: Icons.CircleHelp
});
const getGroupColors = memoized((userSettingsGroupRoot) => {
	return userSettingsGroupRoot.groupSettings.reduce((acc, { group, color }) => {
		if (!isValidColorCode("#" + color)) color = defaultCalendarColor;
		acc.set(group, color);
		return acc;
	}, new Map());
});
const getClientOnlyColors = (userId, clientOnlyCalendarsInfo) => {
	const colors = new Map();
	for (const [id, _] of CLIENT_ONLY_CALENDARS) {
		const calendarId = `${userId}#${id}`;
		colors.set(calendarId, clientOnlyCalendarsInfo.get(calendarId)?.color ?? DEFAULT_CLIENT_ONLY_CALENDAR_COLORS.get(id));
	}
	return colors;
};
const getClientOnlyCalendars = (userId, clientOnlyCalendarInfo) => {
	const userCalendars = [];
	for (const [id, key] of CLIENT_ONLY_CALENDARS) {
		const calendarId = `${userId}#${id}`;
		const calendar = clientOnlyCalendarInfo.get(calendarId);
		if (calendar) userCalendars.push({
			...calendar,
			id: calendarId,
			name: calendar.name ? calendar.name : lang.get(key)
		});
	}
	return userCalendars;
};
function getEventType(existingEvent, calendars, ownMailAddresses, userController) {
	const { user, userSettingsGroupRoot } = userController;
	if (user.accountType === AccountType.EXTERNAL) return EventType.EXTERNAL;
	const existingOrganizer = existingEvent.organizer;
	const isOrganizer = existingOrganizer != null && ownMailAddresses.some((a) => cleanMailAddress(a) === existingOrganizer.address);
	if (existingEvent._ownerGroup == null) if (existingOrganizer != null && !isOrganizer) return EventType.INVITE;
else return EventType.OWN;
	const calendarInfoForEvent = calendars.get(existingEvent._ownerGroup) ?? null;
	if (calendarInfoForEvent == null || calendarInfoForEvent.isExternal) return EventType.SHARED_RO;
	/**
	* if the event has a _ownerGroup, it means there is a calendar set to it
	* so, if the user is the owner of said calendar they are free to manage the event however they want
	**/
	if ((isOrganizer || existingOrganizer === null) && calendarInfoForEvent.userIsOwner) return EventType.OWN;
	if (calendarInfoForEvent.shared) {
		const canWrite = hasCapabilityOnGroup(user, calendarInfoForEvent.group, ShareCapability.Write);
		if (canWrite) {
			const organizerAddress = cleanMailAddress(existingOrganizer?.address ?? "");
			const wouldRequireUpdates = existingEvent.attendees != null && existingEvent.attendees.some((a) => cleanMailAddress(a.address.address) !== organizerAddress);
			return wouldRequireUpdates ? EventType.LOCKED : EventType.SHARED_RW;
		} else return EventType.SHARED_RO;
	}
	if (existingOrganizer == null || existingEvent.attendees?.length === 0 || isOrganizer) return EventType.OWN;
else return EventType.INVITE;
}
function shouldDisplayEvent(e, hiddenCalendars) {
	return !hiddenCalendars.has(assertNotNull(e._ownerGroup, "event without ownerGroup in getEventsOnDays"));
}
async function showDeletePopup(model, ev, receiver, onClose) {
	if (await model.isRepeatingForDeleting()) createAsyncDropdown({
		lazyButtons: () => Promise.resolve([{
			label: "deleteSingleEventRecurrence_action",
			click: async () => {
				await model.deleteSingle();
				onClose?.();
			}
		}, {
			label: "deleteAllEventRecurrence_action",
			click: () => confirmDeleteClose(model, onClose)
		}]),
		width: 300
	})(ev, receiver);
else confirmDeleteClose(model, onClose);
}
async function confirmDeleteClose(model, onClose) {
	if (!await Dialog.confirm("deleteEventConfirmation_msg")) return;
	await model.deleteAll();
	onClose?.();
}
function getDisplayEventTitle(title) {
	return title ?? title !== "" ? title : lang.get("noTitle_label");
}
function renderCalendarColor(selectedCalendar, groupColors) {
	const color = selectedCalendar ? groupColors.get(selectedCalendar.groupInfo.group) ?? defaultCalendarColor : null;
	return mithril_default(".mt-xs", { style: {
		width: "100px",
		height: "10px",
		background: color ? "#" + color : "transparent"
	} });
}

//#endregion
export { CalendarEventAlarmModel, CalendarEventModel, CalendarEventWhoModel, CalendarNotificationModel, CalendarOperation, EventSaveResult, EventType, ReadonlyReason, askIfShouldSendCalendarUpdatesToAttendees, assembleCalendarEventEditResult, assembleEditResultAndAssignFromExisting, assignEventIdentity, calendarAttendeeStatusSymbol, createAlarmIntervalItems, createAttendingItems, createCustomEndTypeOptions, createCustomRepeatRuleUnitValues, createIntervalValues, createRepeatRuleFrequencyValues, createRepeatRuleOptions, customFrequenciesOptions, eventHasChanged, formatEventDuration, getCalendarMonth, getClientOnlyCalendars, getClientOnlyColors, getDateFromMousePos, getDisplayEventTitle, getEventColor, getEventType, getGroupColors, getNonOrganizerAttendees, getTimeFromMousePos, hasPlanWithInvites, humanDescriptionForAlarmInterval, humanDescriptionForAlarmIntervalUnit, iconForAttendeeStatus, makeCalendarEventModel, renderCalendarColor, shouldDisplayEvent, showDeletePopup };
//# sourceMappingURL=CalendarGuiUtils-CkzhFM1K.js.map