{"version":3,"file":"ContactModel-toSAU5Gg.js","names":["entityClient: EntityClient","loginController: LoginController","eventController: EventController","contactSearch: (query: string, field: string, minSuggestionCount: number, maxResults?: number) => Promise<SearchResult>","mailAddress: string","query: string","field: string","minSuggestionCount: number","contactId: IdTuple","rlm: GroupMembership","groupInfo: GroupInfo","updates: ReadonlyArray<EntityUpdateData>","eventOwnerGroupId: Id","logins: LoginController","contactList: ContactList"],"sources":["../../src/common/contactsFunctionality/ContactModel.ts"],"sourcesContent":["import { assertMainOrNode } from \"../api/common/Env.js\"\nimport { Group, GroupInfo, GroupInfoTypeRef, GroupMembership, GroupTypeRef } from \"../api/entities/sys/TypeRefs.js\"\nimport {\n\tContact,\n\tContactList,\n\tContactListGroupRoot,\n\tContactListGroupRootTypeRef,\n\tContactListTypeRef,\n\tContactTypeRef,\n} from \"../api/entities/tutanota/TypeRefs.js\"\nimport { getFirstOrThrow, isNotNull, LazyLoaded, ofClass, promiseMap } from \"@tutao/tutanota-utils\"\nimport Stream from \"mithril/stream\"\nimport stream from \"mithril/stream\"\nimport { EntityClient, loadMultipleFromLists } from \"../api/common/EntityClient.js\"\nimport { LoginController } from \"../api/main/LoginController.js\"\nimport { EntityEventsListener, EventController } from \"../api/main/EventController.js\"\nimport { LoginIncompleteError } from \"../api/common/error/LoginIncompleteError.js\"\nimport { cleanMailAddress } from \"../api/common/utils/CommonCalendarUtils.js\"\nimport { DbError } from \"../api/common/error/DbError.js\"\nimport { compareOldestFirst, getEtId } from \"../api/common/utils/EntityUtils.js\"\nimport { NotAuthorizedError, NotFoundError } from \"../api/common/error/RestError.js\"\nimport { ShareCapability } from \"../api/common/TutanotaConstants.js\"\nimport { EntityUpdateData } from \"../api/common/utils/EntityUpdateUtils.js\"\nimport type { SearchResult } from \"../api/worker/search/SearchTypes.js\"\n\nassertMainOrNode()\n\nexport type ContactListInfo = {\n\tname: string\n\tgroupInfo: GroupInfo\n\tgroup: Group\n\tgroupRoot: ContactListGroupRoot\n\tisOwner: boolean\n\tcanEdit: boolean\n}\n\nexport class ContactModel {\n\tprivate contactListId: LazyLoaded<Id | null>\n\tprivate contactListInfo: Stream<ReadonlyArray<ContactListInfo>> = stream()\n\n\tconstructor(\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly loginController: LoginController,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly contactSearch: (query: string, field: string, minSuggestionCount: number, maxResults?: number) => Promise<SearchResult>,\n\t) {\n\t\tthis.contactListId = lazyContactListId(loginController, this.entityClient)\n\t\tthis.eventController.addEntityListener(this.entityEventsReceived)\n\t}\n\n\tasync getLoadedContactListInfos(): Promise<ReadonlyArray<ContactListInfo>> {\n\t\t// prevent re-loading them when we already have them\n\t\t// this is not perfect and might still start loads in parallel\n\t\tif (this.contactListInfo() === undefined) {\n\t\t\tawait this.loadContactLists()\n\t\t}\n\t\treturn this.contactListInfo()\n\t}\n\n\t/** might be empty if not loaded yet */\n\tgetOwnContactListInfos(): Stream<ReadonlyArray<ContactListInfo>> {\n\t\treturn this.contactListInfo.map((contactListInfos) => contactListInfos.filter((info) => info.isOwner))\n\t}\n\n\t/** might be empty if not loaded yet */\n\tgetSharedContactListInfos(): Stream<ReadonlyArray<ContactListInfo>> {\n\t\treturn this.contactListInfo.map((contactListInfos) => contactListInfos.filter((info) => !info.isOwner))\n\t}\n\n\t/** Id of the contact list. Is null for external users. */\n\tgetContactListId(): Promise<Id | null> {\n\t\treturn this.contactListId.getAsync()\n\t}\n\n\t/**\n\t * Provides the first contact (starting with oldest contact) that contains the given email address. Uses the index search if available, otherwise loads all contacts.\n\t */\n\tasync searchForContact(mailAddress: string): Promise<Contact | null> {\n\t\t//searching for contacts depends on searchFacade._db to be initialized. If the user has not logged in online the respective promise will never resolve.\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contacts as online login is not completed\")\n\t\t}\n\t\tconst cleanedMailAddress = cleanMailAddress(mailAddress)\n\t\tlet result\n\t\ttry {\n\t\t\tresult = await this.contactSearch('\"' + cleanedMailAddress + '\"', \"mailAddress\", 0)\n\t\t} catch (e) {\n\t\t\t// If IndexedDB is not supported or isn't working for some reason we load contacts from the server and\n\t\t\t// search manually.\n\t\t\tif (e instanceof DbError) {\n\t\t\t\tconst listId = await this.getContactListId()\n\t\t\t\tif (listId) {\n\t\t\t\t\tconst contacts = await this.entityClient.loadAll(ContactTypeRef, listId)\n\t\t\t\t\treturn contacts.find((contact) => contact.mailAddresses.some((a) => cleanMailAddress(a.address) === cleanedMailAddress)) ?? null\n\t\t\t\t} else {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t\t// the result is sorted from newest to oldest, but we want to return the oldest first like before\n\t\tresult.results.sort(compareOldestFirst)\n\n\t\tfor (const contactId of result.results) {\n\t\t\ttry {\n\t\t\t\tconst contact = await this.entityClient.load(ContactTypeRef, contactId)\n\t\t\t\tif (contact.mailAddresses.some((a) => cleanMailAddress(a.address) === cleanedMailAddress)) {\n\t\t\t\t\treturn contact\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\t/**\n\t * @pre locator.search.indexState().indexingSupported\n\t */\n\tasync searchForContacts(query: string, field: string, minSuggestionCount: number): Promise<Contact[]> {\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contacts as online login is not completed\")\n\t\t}\n\t\tconst result = await this.contactSearch(query, field, minSuggestionCount)\n\t\treturn await loadMultipleFromLists(ContactTypeRef, this.entityClient, result.results)\n\t}\n\n\tasync searchForContactLists(query: string): Promise<ContactListInfo[]> {\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contact lists as online login is not completed\")\n\t\t}\n\n\t\tconst contactLists = await this.getLoadedContactListInfos()\n\n\t\treturn contactLists.filter((contactList) => contactList.name.toLowerCase().includes(query))\n\t}\n\n\tasync loadContactFromId(contactId: IdTuple) {\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contact lists as online login is not completed\")\n\t\t}\n\n\t\treturn await this.entityClient.load(ContactTypeRef, contactId)\n\t}\n\n\tasync getContactGroupId(): Promise<Id> {\n\t\treturn getFirstOrThrow(this.loginController.getUserController().getContactGroupMemberships()).group\n\t}\n\n\tprivate async loadContactLists() {\n\t\tconst userController = this.loginController.getUserController()\n\t\tconst contactListMemberships = userController.getContactListMemberships()\n\t\tconst contactListInfo = (\n\t\t\tawait promiseMap(\n\t\t\t\tawait promiseMap(contactListMemberships, (rlm: GroupMembership) => this.entityClient.load(GroupInfoTypeRef, rlm.groupInfo)),\n\t\t\t\t// need to catch both NotFoundError and NotAuthorizedError, as we might still have a membership for a short time\n\t\t\t\t// when the group root is already deleted, or we deleted our membership\n\t\t\t\t(groupInfo) =>\n\t\t\t\t\tthis.getContactListInfo(groupInfo)\n\t\t\t\t\t\t.catch(ofClass(NotFoundError, () => null))\n\t\t\t\t\t\t.catch(ofClass(NotAuthorizedError, () => null)),\n\t\t\t)\n\t\t).filter(isNotNull)\n\n\t\tthis.contactListInfo(contactListInfo)\n\t}\n\n\tprivate async getContactListInfo(groupInfo: GroupInfo): Promise<ContactListInfo> {\n\t\tconst group = await this.entityClient.load(GroupTypeRef, groupInfo.group)\n\t\tconst groupRoot = await this.entityClient.load(ContactListGroupRootTypeRef, groupInfo.group)\n\t\tconst userController = this.loginController.getUserController()\n\t\tconst { getSharedGroupName } = await import(\"../sharing/GroupUtils.js\")\n\t\tconst { hasCapabilityOnGroup, isSharedGroupOwner } = await import(\"../sharing/GroupUtils.js\")\n\n\t\treturn {\n\t\t\tname: getSharedGroupName(groupInfo, userController, true),\n\t\t\tgroup,\n\t\t\tgroupInfo,\n\t\t\tgroupRoot,\n\t\t\tisOwner: isSharedGroupOwner(group, getEtId(userController.user)),\n\t\t\tcanEdit: hasCapabilityOnGroup(userController.user, group, ShareCapability.Write),\n\t\t}\n\t}\n\n\tprivate readonly entityEventsReceived: EntityEventsListener = async (updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: Id): Promise<void> => {\n\t\tfor (const update of updates) {\n\t\t\tif (this.loginController.getUserController().isUpdateForLoggedInUserInstance(update, eventOwnerGroupId)) {\n\t\t\t\tawait this.loadContactLists()\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function lazyContactListId(logins: LoginController, entityClient: EntityClient): LazyLoaded<Id | null> {\n\treturn new LazyLoaded(() => {\n\t\treturn entityClient\n\t\t\t.loadRoot(ContactListTypeRef, logins.getUserController().user.userGroup.group)\n\t\t\t.then((contactList: ContactList) => {\n\t\t\t\treturn contactList.contacts\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, (e) => {\n\t\t\t\t\tif (!logins.getUserController().isInternalUser()) {\n\t\t\t\t\t\treturn null // external users have no contact list.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t)\n\t})\n}\n"],"mappings":"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"}