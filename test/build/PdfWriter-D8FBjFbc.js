
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { concat, hexToUint8Array } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { Deflater, GENERATION_NUMBER, NEW_LINE, PDF_DEFAULT_OBJECTS, PDF_METADATA, PdfStreamEncoding } from "./Deflater-VR1UiLhC.js";

//#region ../src/common/api/worker/pdf/PdfObject.ts
var PdfObject = class {
	objectNumber;
	bytePosition = -1;
	objectDictionary = new Map();
	constructor(objectNumber, objectDictionary) {
		this.objectNumber = objectNumber;
		this.objectDictionary = objectDictionary;
	}
	getDictionary() {
		return this.objectDictionary;
	}
	getObjectNumber() {
		return this.objectNumber;
	}
	getBytePosition() {
		return this.bytePosition;
	}
	/**
	* Set the dictionary of the object to be one with all references resolved (string, string)
	*/
	setResolvedDictionary(map) {
		this.objectDictionary = map;
	}
	/**
	* Set the byte-position of the object which is the byte in the PDF file at which the object's declaration starts
	*/
	setBytePosition(bytePosition) {
		this.bytePosition = bytePosition;
	}
	/**
	* Encode the object into a Uint8Array to enable writing it into a buffer / file
	* @param textEncoder
	*/
	encodeToUInt8Array(textEncoder) {
		return new Uint8Array([...textEncoder.encode(this.parseObjectHead()), ...textEncoder.encode(this.parseObjectTail())]);
	}
	/**
	* Convert the object's head data into PDF syntax
	*/
	parseObjectHead() {
		let head = `${this.objectNumber} ${GENERATION_NUMBER} obj${NEW_LINE}<<${NEW_LINE}`;
		for (const [key, val] of this.objectDictionary) {
			if (typeof val !== "string") throw new Error(`Unresolved reference in object: ${this.objectNumber}. Unresolved reference found as value of: "${key}". Cannot encode an object that has unresolved references, aborting...`);
			head += `/${key} ${val}`;
		}
		head += `${NEW_LINE}>>${NEW_LINE}`;
		return head;
	}
	/**
	* Convert the object's tail data into PDF syntax
	*/
	parseObjectTail() {
		return `endobj${NEW_LINE}`;
	}
};

//#endregion
//#region ../src/common/api/worker/pdf/PdfStreamObject.ts
var PdfStreamObject = class extends PdfObject {
	stream;
	constructor(objectNumber, objectDictionary, stream, streamEncoding) {
		super(objectNumber, objectDictionary);
		this.stream = stream;
		if (streamEncoding !== "NONE") this.objectDictionary.set("Filter", streamEncoding);
		this.objectDictionary.set("Length", stream.byteLength.toString());
	}
	encodeToUInt8Array(textEncoder) {
		return new Uint8Array([
			...textEncoder.encode(this.parseObjectHead()),
			...this.stream,
			...textEncoder.encode(this.parseObjectTail())
		]);
	}
	parseObjectHead() {
		let head = `${this.objectNumber} ${GENERATION_NUMBER} obj${NEW_LINE}<<${NEW_LINE}`;
		for (const [key, val] of this.objectDictionary) head += `/${key} ${val}`;
		head += `${NEW_LINE}>>${NEW_LINE}stream${NEW_LINE}`;
		return head;
	}
	parseObjectTail() {
		return `${NEW_LINE}endstream${NEW_LINE}endobj${NEW_LINE}`;
	}
};

//#endregion
//#region ../src/common/api/worker/pdf/PdfWriter.ts
const PDF_HEADER = hexToUint8Array("255044462d322e300a25e2e3cfd30a");
const ZERO_OBJECT_ENTRY = "0000000000 65535 f";
var PdfWriter = class {
	textEncoder;
	customFetch;
	deflater;
	byteLengthPosition = PDF_HEADER.byteLength;
	pdfObjectList = [];
	referenceTable = new Map();
	cachedResources;
	constructor(textEncoder, customFetch) {
		this.textEncoder = textEncoder;
		this.customFetch = customFetch;
		this.deflater = new Deflater();
		this.cachedResources = undefined;
	}
	/**
	* Add all PDF default objects to this writer that are necessary for any functioning document, see "PdfConstants"
	*/
	setupDefaultObjects() {
		for (const object of PDF_DEFAULT_OBJECTS) this.createObject(object.dictionary, object.refId);
	}
	/**
	* Create a new PDF object
	* @param objectDictionary Map of the object dictionary
	* @param refId ID by which other objects can reference this object
	*/
	createObject(objectDictionary, refId = "") {
		if (this.referenceTable.has(refId)) throw new ProgrammingError(`already defined object refId ${refId}`);
		const obj = new PdfObject(this.pdfObjectList.length + 1, objectDictionary);
		if (refId.length > 0) this.referenceTable.set(refId, obj);
		this.pdfObjectList.push(obj);
	}
	/**
	* Create a new PDF object with stream data
	* @param objectDictionary Map of the object dictionary. Must not provide stream-specific data
	* @param stream The stream of the object
	* @param streamEncoding The encoding of the stream
	* @param refId ID by which other objects can reference this object
	*/
	createStreamObject(objectDictionary, stream, streamEncoding, refId = "") {
		if (this.referenceTable.has(refId)) throw new ProgrammingError(`already defined stream refId ${refId}`);
		const obj = new PdfStreamObject(this.pdfObjectList.length + 1, objectDictionary, stream, streamEncoding);
		if (refId.length > 0) this.referenceTable.set(refId, obj);
		this.pdfObjectList.push(obj);
	}
	/**
	* Get a PDF object added to this writer by its ID
	* @param refId The id of the desired object
	*/
	getObjectByRefId(refId) {
		const obj = this.referenceTable.get(refId);
		if (obj != null) return obj;
else throw new Error(`Invalid ReferenceId: ${refId}. No object was found that has this refId. Reference can't be resolved, aborting...`);
	}
	/**
	* Write the cross-reference table of the PDF which is a special object lookup table for PDF readers
	*/
	makeXRefTable() {
		let xref = `xref${NEW_LINE}0 ${this.pdfObjectList.length + 1}${NEW_LINE}${ZERO_OBJECT_ENTRY} ${NEW_LINE}`;
		for (const pdfObject of this.pdfObjectList) {
			if (pdfObject.getBytePosition() === -1) throw new Error(`Found an object with invalid byte-position! ${pdfObject.getObjectNumber()}`);
			xref += `${("0000000000" + pdfObject.getBytePosition()).slice(-10)} 00000 n ${NEW_LINE}`;
		}
		return xref;
	}
	/**
	* Write the trailer of the PDF which is a special object pointing at the "Catalog object" and additional metadata
	* @param identifier A preferably unique string
	*/
	makeTrailer(identifier) {
		let trailer = `trailer${NEW_LINE}<<${NEW_LINE}`;
		trailer += `/Size ${this.pdfObjectList.length + 1}`;
		trailer += `/Root ${this.pdfReferenceToString({ refId: "CATALOG" })}`;
		trailer += `/ID [(${identifier})(${identifier})]`;
		trailer += `${NEW_LINE}>>${NEW_LINE}startxref${NEW_LINE}${this.byteLengthPosition}${NEW_LINE}%%EOF`;
		return trailer;
	}
	/**
	* Resolve all references to other objects in a PDF dictionary
	* This replaces every refId with the string "objNumber 0 R" which is PDF syntax for referencing other objects
	* Returns the PDF dictionary as Map of <string, string> allowing it to be encoded
	* @param objDictionary The dictionary t
	*/
	resolveReferences(objDictionary) {
		const newMap = new Map();
		for (const [key, value] of objDictionary) newMap.set(key, this.resolveDictValue(value));
		return newMap;
	}
	/**
	* Resolve a PdfDictValue into its string equivalent
	* @param value Value to resolve
	*/
	resolveDictValue(value) {
		if (typeof value !== "string") if (value instanceof Map) return this.pdfDictionaryToString(value);
else if (Array.isArray(value)) return this.pdfListToString(value);
else return this.pdfReferenceToString(value);
else return value;
	}
	pdfReferenceToString(objectReference) {
		const referencedObject = this.getObjectByRefId(objectReference.refId);
		return `${referencedObject.getObjectNumber()} ${GENERATION_NUMBER} R`;
	}
	pdfListToString(objectReferences) {
		let referenceString = "[ ";
		for (const objRef of objectReferences) referenceString += this.resolveDictValue(objRef) + " ";
		referenceString += "]";
		return referenceString;
	}
	pdfDictionaryToString(objectReferenceDict) {
		let referenceString = "<< ";
		for (const [key, value] of objectReferenceDict) referenceString += `/${key} ${this.resolveDictValue(value)} `;
		referenceString += ">>";
		return referenceString;
	}
	/**
	* Calculate the byte-position for a given object
	* @param object The object that should have its byte-position be calculated
	* @param encodedObject The provided object in encoded format to allow calculation for the next object
	*/
	calculateBytePositions(object, encodedObject) {
		object.setBytePosition(this.byteLengthPosition);
		this.byteLengthPosition += encodedObject.byteLength;
	}
	/**
	* Add all resource objects (stream objects) to the PDF. These are referenced by the "default objects" but need to be dynamically generated because they
	* include a huge amount of stream data / need to read their stream data in from external resources (base64 encoded)
	*/
	async setupResourceObjects() {
		const baseUrl = typeof location === "undefined" ? "" : location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "");
		if (!this.cachedResources) this.cachedResources = await Promise.all([
			"/pdf/SourceSans3-Regular.ttf",
			"/pdf/SourceSans3-Bold.ttf",
			"/pdf/sRGB2014.icc",
			"/pdf/identity_h.cmap",
			"/pdf/tutanota_logo_en.jpg"
		].map((url) => typeof this.customFetch !== "undefined" ? this.customFetch(baseUrl + url).then((r) => r.arrayBuffer()) : fetch(baseUrl + url).then((r) => r.arrayBuffer())));
		const [fontRegular, fontBold, colorProfile, cmap, tutaImage] = this.cachedResources;
		this.createStreamObject(new Map([["Length1", fontRegular.byteLength.toString()]]), await this.deflater.deflate(fontRegular), PdfStreamEncoding.FLATE, "FONT_REGULAR_FILE");
		this.createStreamObject(new Map([["Length1", fontBold.byteLength.toString()]]), await this.deflater.deflate(fontBold), PdfStreamEncoding.FLATE, "FONT_BOLD_FILE");
		this.createStreamObject(new Map([
			["Type", "/CMap"],
			["CMapName", "/Identity-H "],
			["CIDSystemInfo", "<< /Registry (Adobe) /Ordering (Identity) /Supplement 0 >>"]
		]), await this.deflater.deflate(cmap), PdfStreamEncoding.FLATE, "CMAP");
		this.createStreamObject(new Map([["Length1", colorProfile.byteLength.toString()], ["N", "3"]]), await this.deflater.deflate(colorProfile), PdfStreamEncoding.FLATE, "DEST_OUTPUT_PROFILE");
		this.createStreamObject(new Map([
			["Name", "/Im1"],
			["Type", "/XObject"],
			["Subtype", "/Image"],
			["Width", "600"],
			["Height", "209"],
			["BitsPerComponent", "8"],
			["ColorSpace", "/DeviceRGB"]
		]), new Uint8Array(tutaImage), PdfStreamEncoding.DCT, "IMG_TUTA_LOGO");
		const todayDate = new Date();
		const metaData = PDF_METADATA.replace("{slotCreateDate}", todayDate.toISOString()).replace("{slotModifyDate}", todayDate.toISOString());
		this.createStreamObject(new Map([["Type", "/Metadata"], ["Subtype", "/XML"]]), new Uint8Array(this.textEncoder.encode(metaData)), PdfStreamEncoding.NONE, "METADATA");
	}
	/**
	* Writes the PDF file and return its entire data as a Uint8Array
	* @pre baseUrl must be defined
	*/
	async writePdfFile() {
		await this.setupResourceObjects();
		const encodedObjects = [];
		encodedObjects.push(PDF_HEADER);
		for (const obj of this.pdfObjectList) {
			obj.setResolvedDictionary(this.resolveReferences(obj.getDictionary()));
			const encodedObject = obj.encodeToUInt8Array(this.textEncoder);
			this.calculateBytePositions(obj, encodedObject);
			encodedObjects.push(encodedObject);
		}
		encodedObjects.push(this.textEncoder.encode(this.makeXRefTable()));
		encodedObjects.push(this.textEncoder.encode(this.makeTrailer(Date.now().toString())));
		return concat(...encodedObjects);
	}
};

//#endregion
export { PdfObject, PdfStreamObject, PdfWriter };
//# sourceMappingURL=PdfWriter-D8FBjFbc.js.map