
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import { CryptoError } from "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import { OfflineDbClosedError } from "./OfflineDbClosedError-CAwHTI6J.js";
import "./SqlValue-CkGu32Qd.js";
import { usql } from "./Sql-C9YhYNym.js";
import { index } from "./better-sqlite3-BmG0PAc2.js";
import { log } from "./DesktopLog-yAgEoQsh.js";
import { CredentialEncryptionMode } from "./CredentialEncryptionMode-BR0DkQpJ.js";
import { CredentialType } from "./CredentialType-DXeA2MQH.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import fs from "node:fs";

//#region ../src/common/desktop/db/DesktopCredentialsStorage.ts
const TableDefinitions = Object.freeze({
	meta: "key TEXT NOT NULL, value",
	credentials: "login TEXT NOT NULL, userId TEXT NOT NULL, type TEXT NOT NULL, accessToken BLOB NOT NULL, databaseKey BLOB, encryptedPassword TEXT NOT NULL, PRIMARY KEY (userId), UNIQUE(login)",
	credentialEncryptionMode: "id INTEGER NOT NULL, credentialEncryptionMode TEXT NOT NULL, FOREIGN KEY(credentialEncryptionMode) REFERENCES credentialEncryptionModeEnum(mode), PRIMARY KEY (id), CHECK (id=0)",
	credentialEncryptionKey: "id INTEGER NOT NULL, credentialEncryptionKey BLOB NOT NULL, PRIMARY KEY (id), CHECK (id=0)"
});
var DesktopCredentialsStorage = class {
	_db = null;
	get db() {
		if (this._db == null) throw new OfflineDbClosedError();
		return this._db;
	}
	_sqliteNativePath = null;
	constructor(sqliteNativePath, dbPath, app) {
		this.dbPath = dbPath;
		this._sqliteNativePath = sqliteNativePath;
		if (this._db == null) this.create().then(() => {
			app.on("will-quit", () => this.closeDb());
		});
	}
	async create(retry = true) {
		try {
			this.openDb();
			this.createTables();
		} catch (e) {
			if (!retry) throw e;
			log.debug("retrying to create credentials db");
			await this.deleteDb();
			return this.create(false);
		}
	}
	openDb() {
		this._db = new index(this.dbPath, { nativeBinding: this._sqliteNativePath });
		try {
			this.initSql();
		} catch (e) {
			this.db.close();
			this._db = null;
			throw e;
		}
	}
	initSql() {
		this.db.pragma("cipher_memory_security = ON");
		const errors = this.db.pragma("cipher_integrity_check");
		if (errors.length > 0) throw new CryptoError(`Integrity check failed with result : ${JSON.stringify(errors)}`);
	}
	async closeDb() {
		this.db.close();
		this._db = null;
	}
	async deleteDb() {
		log.debug("deleting credentials db");
		await fs.promises.rm(this.dbPath, {
			maxRetries: 3,
			force: true
		});
	}
	createTables() {
		log.debug(`Creating tables...`);
		this.createEnumTable();
		for (let [name, definition] of Object.entries(TableDefinitions)) this.run({
			query: `CREATE TABLE IF NOT EXISTS ${name} (${definition})`,
			params: []
		});
		const version = this.get(usql`SELECT value FROM meta WHERE key = 'version'`)?.value;
		log.debug(`Current credentials version: ${version}`);
		if (version == null) {
			log.debug(`Migrating to v1`);
			this.db.transaction(() => {
				this.run({
					query: `ALTER TABLE credentials ADD COLUMN encryptedPassphraseKey BLOB`,
					params: []
				});
				this.run({
					query: `INSERT INTO meta VALUES ('version', 1)`,
					params: []
				});
			})();
		}
		log.debug(`Tables created successfully!`);
	}
	store(credentials) {
		const formattedQuery = usql`INSERT OR REPLACE INTO credentials (login, userId, type, accessToken, databaseKey, encryptedPassword, encryptedPassphraseKey) VALUES (
${credentials.credentialInfo.login}, ${credentials.credentialInfo.userId}, ${credentials.credentialInfo.type},
${credentials.accessToken}, ${credentials.databaseKey}, ${credentials.encryptedPassword}, ${credentials.encryptedPassphraseKey})`;
		return this.run(formattedQuery);
	}
	getAllCredentials() {
		const records = this.all(usql`SELECT * FROM credentials`);
		return records.map((row) => this.unmapCredentials(row));
	}
	getCredentialsByUserId(userId) {
		const row = this.get(usql`SELECT * FROM credentials WHERE userId = ${userId}`);
		if (!row) return null;
		return this.unmapCredentials(row);
	}
	deleteByUserId(userId) {
		return this.run(usql`DELETE FROM credentials WHERE userId = ${userId}`);
	}
	deleteAllCredentials() {
		this.run(usql`DELETE FROM credentials`);
	}
	createEnumTable() {
		this.run({
			query: `CREATE TABLE IF NOT EXISTS credentialEncryptionModeEnum (mode TEXT UNIQUE)`,
			params: []
		});
		for (let i in CredentialEncryptionMode) {
			const insertQuery = usql`INSERT OR REPLACE INTO credentialEncryptionModeEnum (mode) VALUES (${i})`;
			this.run(insertQuery);
		}
	}
	unmapCredentials(row) {
		const credentialType = row.type;
		return {
			credentialInfo: {
				login: row.login,
				userId: row.userId,
				type: credentialType
			},
			encryptedPassword: row.encryptedPassword,
			encryptedPassphraseKey: row.encryptedPassphraseKey,
			accessToken: row.accessToken,
			databaseKey: row.databaseKey
		};
	}
	run({ query, params }) {
		this.db.prepare(query).run(params);
	}
	/**
	* Execute a query
	* @returns a single object or undefined if the query returns nothing
	*/
	get({ query, params }) {
		return this.db.prepare(query).get(params) ?? null;
	}
	/**
	* Execute a query
	* @returns a list of objects or an empty list if the query returns nothing
	*/
	all({ query, params }) {
		return this.db.prepare(query).all(params);
	}
	getCredentialEncryptionMode() {
		const row = this.get(usql`SELECT credentialEncryptionMode FROM credentialEncryptionMode LIMIT 1`);
		if (!row) return null;
		return row.credentialEncryptionMode;
	}
	getCredentialEncryptionKey() {
		const row = this.get(usql`SELECT credentialEncryptionKey FROM credentialEncryptionKey LIMIT 1`);
		if (!row) return null;
		return row.credentialEncryptionKey;
	}
	setCredentialEncryptionMode(encryptionMode) {
		if (encryptionMode != null) this.run(usql`INSERT OR REPLACE INTO credentialEncryptionMode (id, credentialEncryptionMode) VALUES (0, ${encryptionMode})`);
else this.run(usql`DELETE FROM credentialEncryptionMode`);
	}
	setCredentialEncryptionKey(encryptionKey) {
		if (encryptionKey != null) this.run(usql`INSERT OR REPLACE INTO credentialEncryptionKey (id, credentialEncryptionKey) VALUES (0, ${encryptionKey})`);
else this.run(usql`DELETE FROM credentialEncryptionKey`);
	}
};

//#endregion
//#region tests/desktop/credentials/DesktopCredentialsStorageTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
const encryptedCredentials1 = {
	credentialInfo: {
		login: "login1@test.com",
		type: CredentialType.Internal,
		userId: "user1"
	},
	encryptedPassword: "pw1",
	encryptedPassphraseKey: null,
	databaseKey: new Uint8Array([
		1,
		13,
		14
	]),
	accessToken: new Uint8Array([
		1,
		10,
		14
	])
};
const encryptedCredentials2 = {
	credentialInfo: {
		login: "login2@test.com",
		type: CredentialType.Internal,
		userId: "user2"
	},
	encryptedPassword: "pw2",
	encryptedPassphraseKey: new Uint8Array([
		2,
		11,
		14
	]),
	databaseKey: new Uint8Array([
		2,
		13,
		14
	]),
	accessToken: new Uint8Array([
		2,
		10,
		14
	])
};
dist_default.spec("DesktopCredentialsStorage", () => {
	let storage;
	dist_default.beforeEach(() => {
		storage = new DesktopCredentialsStorage(__NODE_GYP_better_sqlite3, ":memory:", (0, import_testdouble.object)());
	});
	dist_default.afterEach(async () => {
		await storage.closeDb();
	});
	dist_default.spec("credentialEncryptionKey", () => {
		dist_default.test("when there is none it returns null", () => {
			dist_default(storage.getCredentialEncryptionKey()).equals(null);
		});
		dist_default.test("it returns one after writing", () => {
			const key = new Uint8Array([
				4,
				14,
				4
			]);
			storage.setCredentialEncryptionKey(key);
			dist_default(storage.getCredentialEncryptionKey()).deepEquals(key);
		});
		dist_default.test("it returns one after overwriting", () => {
			const key1 = new Uint8Array([
				4,
				14,
				4,
				1
			]);
			const key2 = new Uint8Array([
				4,
				14,
				4,
				2
			]);
			storage.setCredentialEncryptionKey(key1);
			storage.setCredentialEncryptionKey(key2);
			dist_default(storage.getCredentialEncryptionKey()).deepEquals(key2);
		});
		dist_default.test("it returns null after writing null", () => {
			const key = new Uint8Array([
				4,
				14,
				4
			]);
			storage.setCredentialEncryptionKey(key);
			storage.setCredentialEncryptionKey(null);
			dist_default(storage.getCredentialEncryptionKey()).deepEquals(null);
		});
	});
	dist_default.spec("credentialEncryptionMode", () => {
		dist_default.test("when there is none it returns null", () => {
			dist_default(storage.getCredentialEncryptionMode()).equals(null);
		});
		dist_default.test("it returns one after writing", () => {
			storage.setCredentialEncryptionMode(CredentialEncryptionMode.APP_PASSWORD);
			dist_default(storage.getCredentialEncryptionMode()).deepEquals(CredentialEncryptionMode.APP_PASSWORD);
		});
		dist_default.test("it returns one after overwriting", () => {
			storage.setCredentialEncryptionMode(CredentialEncryptionMode.APP_PASSWORD);
			storage.setCredentialEncryptionMode(CredentialEncryptionMode.DEVICE_LOCK);
			dist_default(storage.getCredentialEncryptionMode()).deepEquals(CredentialEncryptionMode.DEVICE_LOCK);
		});
		dist_default.test("it returns null after writing null", () => {
			storage.setCredentialEncryptionMode(CredentialEncryptionMode.DEVICE_LOCK);
			storage.setCredentialEncryptionMode(null);
			dist_default(storage.getCredentialEncryptionMode()).deepEquals(null);
		});
	});
	dist_default.spec("credentials", () => {
		dist_default.beforeEach(() => {
			storage.store(encryptedCredentials1);
			storage.store(encryptedCredentials2);
		});
		dist_default.test("getCredentialsByUserId() returns credentials after storing", () => {
			dist_default(storage.getCredentialsByUserId(encryptedCredentials1.credentialInfo.userId)).deepEquals(encryptedCredentials1);
		});
		dist_default.test("getAllCredentials() returns all after storing", () => {
			dist_default(storage.getAllCredentials()).deepEquals([encryptedCredentials1, encryptedCredentials2]);
		});
		dist_default.test("doesn't return after deleteByUserId", () => {
			storage.deleteByUserId(encryptedCredentials1.credentialInfo.userId);
			dist_default(storage.getAllCredentials()).deepEquals([encryptedCredentials2]);
		});
		dist_default.test("doesn't return after deleteAll()", () => {
			storage.deleteAllCredentials();
			dist_default(storage.getAllCredentials()).deepEquals([]);
		});
	});
});

//#endregion
//# sourceMappingURL=DesktopCredentialsStorageTest-C8qZJYdF.js.map