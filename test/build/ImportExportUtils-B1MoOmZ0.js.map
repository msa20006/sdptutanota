{"version":3,"file":"ImportExportUtils-B1MoOmZ0.js","names":["dateString: string","obj: ICalObject","tag: string","optional: boolean","parameterStringValueParser: Parser<string>","escapedStringValueParser: Parser<string>","iterator: StringIterator","propertyParametersKeyValueParser: Parser<[string, string, string]>","anyStringUnescapeParser: Parser<string>","lastCharacter: string | null","propertyStringValueParser: Parser<string>","separatedByCommaParser: Parser<Array<string>>","propertySequenceParser: Parser<[string, [string, Array<[string, string, string]>] | null, string, string]>","data: string","params: Record<string, string>","name","value","propertyKeyValueParser: Parser<[string, string, string]>","valuesSeparatedBySemicolonParser: Parser<Array<[string, string, string]>>","result: Record<string, string>","iterator: Iterator<string>","properties: Property[]","children: ICalObject[]","stringData: string","alarmObject: ICalObject","startTime: Date","alarmInterval: AlarmInterval | null","eventStart: Date","triggerValue: string","smallestUnit: AlarmIntervalUnit","rawRruleValue: string","tzId: string | null","endType: EndType","rrule: Record<string, string>","advancedRepeatRules: CalendarAdvancedRepeatRule[]","excludedDatesProps: Property[]","allExDates: Map<number, DateWrapper>","recurrenceIdProp: Property","durationValue: string","prop: Property","WindowsZones","allDay: boolean","zone: string","value: string","calendarAttendeeStatusToParstat: Record<CalendarAttendeeStatus, string>","parstatToCalendarAttendeeStatus: Record<string, CalendarAttendeeStatus>","icalObject: ICalObject","eventObjects: ICalObject[]","uid: string | null","recurrenceId: Date | null","summary: string","location: string","repeatRule: RepeatRule | null","sequence: string","organizer: EncryptedMailAddress | null","alarms: AlarmInfoTemplate[]","eventObj: ICalObject","attendees: CalendarEventAttendee[]","repeatPeriod: RepeatPeriod","mapping: Record<RepeatPeriod, string>","zone: string | null","zone?: string","dateTime: DateTime","secondDurationParser: Parser<[number, string]>","minuteDurationParser: Parser<[number, string]>","hourDurationParser: Parser<[number, string]>","durationDayParser: Parser<[number, string]>","durationWeekParser: Parser<[number, string]>","event: CalendarEvent","instanceIdentifierToEventMap: Map<string, CalendarEvent>","parsedEvents: ParsedEvent[]","existingEvents: Array<CalendarEvent>","calendarGroupRoot: CalendarGroupRoot","zone: string","rejectedEvents: RejectedEvents","eventsForCreation: Array<{ event: CalendarEvent; alarms: Array<AlarmInfoTemplate> }>","progenitor: { event: CalendarEvent; alarms: Array<AlarmInfoTemplate> } | null","alteredInstances: Array<{ event: CalendarEvent; alarms: Array<AlarmInfoTemplate> }>","value: string"],"sources":["../../src/calendar-app/calendar/export/WindowsZones.ts","../../src/calendar-app/calendar/export/CalendarParser.ts","../../src/common/calendar/import/ImportExportUtils.ts"],"sourcesContent":["// Autogenerated file with mapping from Windows zones to IANA zones\n// See Unicode CLDR project\nexport default {\n\t\"Afghanistan Standard Time\": \"Asia/Kabul\",\n\t\"Alaskan Standard Time\": \"America/Anchorage\",\n\t\"Aleutian Standard Time\": \"America/Adak\",\n\t\"Altai Standard Time\": \"Asia/Barnaul\",\n\t\"Arab Standard Time\": \"Asia/Riyadh\",\n\t\"Arabian Standard Time\": \"Asia/Dubai\",\n\t\"Arabic Standard Time\": \"Asia/Baghdad\",\n\t\"Argentina Standard Time\": \"America/Buenos_Aires\",\n\t\"Astrakhan Standard Time\": \"Europe/Astrakhan\",\n\t\"Atlantic Standard Time\": \"America/Halifax\",\n\t\"AUS Central Standard Time\": \"Australia/Darwin\",\n\t\"Aus Central W. Standard Time\": \"Australia/Eucla\",\n\t\"AUS Eastern Standard Time\": \"Australia/Sydney\",\n\t\"Azerbaijan Standard Time\": \"Asia/Baku\",\n\t\"Azores Standard Time\": \"Atlantic/Azores\",\n\t\"Bahia Standard Time\": \"America/Bahia\",\n\t\"Bangladesh Standard Time\": \"Asia/Dhaka\",\n\t\"Belarus Standard Time\": \"Europe/Minsk\",\n\t\"Bougainville Standard Time\": \"Pacific/Bougainville\",\n\t\"Canada Central Standard Time\": \"America/Regina\",\n\t\"Cape Verde Standard Time\": \"Atlantic/Cape_Verde\",\n\t\"Caucasus Standard Time\": \"Asia/Yerevan\",\n\t\"Cen. Australia Standard Time\": \"Australia/Adelaide\",\n\t\"Central America Standard Time\": \"America/Guatemala\",\n\t\"Central Asia Standard Time\": \"Asia/Almaty\",\n\t\"Central Brazilian Standard Time\": \"America/Cuiaba\",\n\t\"Central Europe Standard Time\": \"Europe/Budapest\",\n\t\"Central European Standard Time\": \"Europe/Warsaw\",\n\t\"Central Pacific Standard Time\": \"Pacific/Guadalcanal\",\n\t\"Central Standard Time\": \"America/Chicago\",\n\t\"Central Standard Time (Mexico)\": \"America/Mexico_City\",\n\t\"Chatham Islands Standard Time\": \"Pacific/Chatham\",\n\t\"China Standard Time\": \"Asia/Shanghai\",\n\t\"Cuba Standard Time\": \"America/Havana\",\n\t\"Dateline Standard Time\": \"Etc/GMT+12\",\n\t\"E. Africa Standard Time\": \"Africa/Nairobi\",\n\t\"E. Australia Standard Time\": \"Australia/Brisbane\",\n\t\"E. Europe Standard Time\": \"Europe/Chisinau\",\n\t\"E. South America Standard Time\": \"America/Sao_Paulo\",\n\t\"Easter Island Standard Time\": \"Pacific/Easter\",\n\t\"Eastern Standard Time\": \"America/New_York\",\n\t\"Eastern Standard Time (Mexico)\": \"America/Cancun\",\n\t\"Egypt Standard Time\": \"Africa/Cairo\",\n\t\"Ekaterinburg Standard Time\": \"Asia/Yekaterinburg\",\n\t\"Fiji Standard Time\": \"Pacific/Fiji\",\n\t\"FLE Standard Time\": \"Europe/Kiev\",\n\t\"Georgian Standard Time\": \"Asia/Tbilisi\",\n\t\"GMT Standard Time\": \"Europe/London\",\n\t\"Greenland Standard Time\": \"America/Godthab\",\n\t\"Greenwich Standard Time\": \"Atlantic/Reykjavik\",\n\t\"GTB Standard Time\": \"Europe/Bucharest\",\n\t\"Haiti Standard Time\": \"America/Port-au-Prince\",\n\t\"Hawaiian Standard Time\": \"Pacific/Honolulu\",\n\t\"India Standard Time\": \"Asia/Calcutta\",\n\t\"Iran Standard Time\": \"Asia/Tehran\",\n\t\"Israel Standard Time\": \"Asia/Jerusalem\",\n\t\"Jordan Standard Time\": \"Asia/Amman\",\n\t\"Kaliningrad Standard Time\": \"Europe/Kaliningrad\",\n\t\"Korea Standard Time\": \"Asia/Seoul\",\n\t\"Libya Standard Time\": \"Africa/Tripoli\",\n\t\"Line Islands Standard Time\": \"Pacific/Kiritimati\",\n\t\"Lord Howe Standard Time\": \"Australia/Lord_Howe\",\n\t\"Magadan Standard Time\": \"Asia/Magadan\",\n\t\"Magallanes Standard Time\": \"America/Punta_Arenas\",\n\t\"Marquesas Standard Time\": \"Pacific/Marquesas\",\n\t\"Mauritius Standard Time\": \"Indian/Mauritius\",\n\t\"Middle East Standard Time\": \"Asia/Beirut\",\n\t\"Montevideo Standard Time\": \"America/Montevideo\",\n\t\"Morocco Standard Time\": \"Africa/Casablanca\",\n\t\"Mountain Standard Time\": \"America/Denver\",\n\t\"Mountain Standard Time (Mexico)\": \"America/Chihuahua\",\n\t\"Myanmar Standard Time\": \"Asia/Rangoon\",\n\t\"N. Central Asia Standard Time\": \"Asia/Novosibirsk\",\n\t\"Namibia Standard Time\": \"Africa/Windhoek\",\n\t\"Nepal Standard Time\": \"Asia/Katmandu\",\n\t\"New Zealand Standard Time\": \"Pacific/Auckland\",\n\t\"Newfoundland Standard Time\": \"America/St_Johns\",\n\t\"Norfolk Standard Time\": \"Pacific/Norfolk\",\n\t\"North Asia East Standard Time\": \"Asia/Irkutsk\",\n\t\"North Asia Standard Time\": \"Asia/Krasnoyarsk\",\n\t\"North Korea Standard Time\": \"Asia/Pyongyang\",\n\t\"Omsk Standard Time\": \"Asia/Omsk\",\n\t\"Pacific SA Standard Time\": \"America/Santiago\",\n\t\"Pacific Standard Time\": \"America/Los_Angeles\",\n\t\"Pacific Standard Time (Mexico)\": \"America/Tijuana\",\n\t\"Pakistan Standard Time\": \"Asia/Karachi\",\n\t\"Paraguay Standard Time\": \"America/Asuncion\",\n\t\"Romance Standard Time\": \"Europe/Paris\",\n\t\"Russia Time Zone 3\": \"Europe/Samara\",\n\t\"Russia Time Zone 10\": \"Asia/Srednekolymsk\",\n\t\"Russia Time Zone 11\": \"Asia/Kamchatka\",\n\t\"Russian Standard Time\": \"Europe/Moscow\",\n\t\"SA Eastern Standard Time\": \"America/Cayenne\",\n\t\"SA Pacific Standard Time\": \"America/Bogota\",\n\t\"SA Western Standard Time\": \"America/La_Paz\",\n\t\"Saint Pierre Standard Time\": \"America/Miquelon\",\n\t\"Sakhalin Standard Time\": \"Asia/Sakhalin\",\n\t\"Samoa Standard Time\": \"Pacific/Apia\",\n\t\"Sao Tome Standard Time\": \"Africa/Sao_Tome\",\n\t\"Saratov Standard Time\": \"Europe/Saratov\",\n\t\"SE Asia Standard Time\": \"Asia/Bangkok\",\n\t\"Singapore Standard Time\": \"Asia/Singapore\",\n\t\"South Africa Standard Time\": \"Africa/Johannesburg\",\n\t\"Sri Lanka Standard Time\": \"Asia/Colombo\",\n\t\"Sudan Standard Time\": \"Africa/Khartoum\",\n\t\"Syria Standard Time\": \"Asia/Damascus\",\n\t\"Taipei Standard Time\": \"Asia/Taipei\",\n\t\"Tasmania Standard Time\": \"Australia/Hobart\",\n\t\"Tocantins Standard Time\": \"America/Araguaina\",\n\t\"Tokyo Standard Time\": \"Asia/Tokyo\",\n\t\"Tomsk Standard Time\": \"Asia/Tomsk\",\n\t\"Tonga Standard Time\": \"Pacific/Tongatapu\",\n\t\"Transbaikal Standard Time\": \"Asia/Chita\",\n\t\"Turkey Standard Time\": \"Europe/Istanbul\",\n\t\"Turks And Caicos Standard Time\": \"America/Grand_Turk\",\n\t\"Ulaanbaatar Standard Time\": \"Asia/Ulaanbaatar\",\n\t\"US Eastern Standard Time\": \"America/Indianapolis\",\n\t\"US Mountain Standard Time\": \"America/Phoenix\",\n\tUTC: \"Etc/GMT\",\n\t\"UTC-02\": \"Etc/GMT+2\",\n\t\"UTC-08\": \"Etc/GMT+8\",\n\t\"UTC-09\": \"Etc/GMT+9\",\n\t\"UTC-11\": \"Etc/GMT+11\",\n\t\"UTC+12\": \"Etc/GMT-12\",\n\t\"UTC+13\": \"Etc/GMT-13\",\n\t\"Venezuela Standard Time\": \"America/Caracas\",\n\t\"Vladivostok Standard Time\": \"Asia/Vladivostok\",\n\t\"W. Australia Standard Time\": \"Australia/Perth\",\n\t\"W. Central Africa Standard Time\": \"Africa/Lagos\",\n\t\"W. Europe Standard Time\": \"Europe/Berlin\",\n\t\"W. Mongolia Standard Time\": \"Asia/Hovd\",\n\t\"West Asia Standard Time\": \"Asia/Tashkent\",\n\t\"West Bank Standard Time\": \"Asia/Hebron\",\n\t\"West Pacific Standard Time\": \"Pacific/Port_Moresby\",\n\t\"Yakutsk Standard Time\": \"Asia/Yakutsk\",\n}\n","import { DAY_IN_MILLIS, filterInt, neverNull, Require } from \"@tutao/tutanota-utils\"\nimport { DateTime, Duration, IANAZone } from \"luxon\"\nimport {\n\tCalendarEvent,\n\tCalendarEventAttendee,\n\tcreateCalendarEvent,\n\tcreateCalendarEventAttendee,\n\tcreateEncryptedMailAddress,\n\tEncryptedMailAddress,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { CalendarAdvancedRepeatRule, createCalendarAdvancedRepeatRule, DateWrapper, RepeatRule } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { createDateWrapper, createRepeatRule } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport type { Parser } from \"../../../common/misc/parsing/ParserCombinator\"\nimport {\n\tcombineParsers,\n\tmakeCharacterParser,\n\tmakeEitherParser,\n\tmakeNotCharacterParser,\n\tmakeSeparatedByParser,\n\tmakeZeroOrMoreParser,\n\tmapParser,\n\tmaybeParse,\n\tnumberParser,\n\tParserError,\n\tStringIterator,\n} from \"../../../common/misc/parsing/ParserCombinator\"\nimport WindowsZones from \"./WindowsZones\"\nimport type { ParsedCalendarData } from \"../../../common/calendar/import/CalendarImporter.js\"\nimport { isMailAddress } from \"../../../common/misc/FormatValidator\"\nimport { CalendarAttendeeStatus, CalendarMethod, EndType, RepeatPeriod, reverse } from \"../../../common/api/common/TutanotaConstants\"\nimport { AlarmInterval, AlarmIntervalUnit } from \"../../../common/calendar/date/CalendarUtils.js\"\nimport { AlarmInfoTemplate } from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport { serializeAlarmInterval } from \"../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { BYRULE_MAP } from \"../../../common/calendar/import/ImportExportUtils.js\"\n\nfunction parseDateString(dateString: string): {\n\tyear: number\n\tmonth: number\n\tday: number\n} {\n\tconst year = parseInt(dateString.slice(0, 4))\n\tconst month = parseInt(dateString.slice(4, 6))\n\tconst day = parseInt(dateString.slice(6, 8))\n\treturn {\n\t\tyear,\n\t\tmonth,\n\t\tday,\n\t}\n}\n\ntype PropertyParamValue = string\ntype Property = {\n\tname: string\n\tparams: Record<string, PropertyParamValue>\n\tvalue: string\n}\ntype ICalObject = {\n\ttype: string\n\tproperties: Array<Property>\n\tchildren: Array<ICalObject>\n}\n\nfunction getProp(obj: ICalObject, tag: string, optional: false): Property\nfunction getProp(obj: ICalObject, tag: string, optional: true): Property | null | undefined\nfunction getProp(obj: ICalObject, tag: string, optional: boolean): Property | null | undefined\nfunction getProp(obj: ICalObject, tag: string, optional: boolean): Property | null | undefined {\n\tconst prop = obj.properties.find((p) => p.name === tag)\n\tif (!optional && prop == null) throw new ParserError(`Missing prop ${tag}`)\n\treturn prop\n}\n\nfunction getPropStringValue(obj: ICalObject, tag: string, optional: false): string\nfunction getPropStringValue(obj: ICalObject, tag: string, optional: true): string | null | undefined\nfunction getPropStringValue(obj: ICalObject, tag: string, optional: boolean): string | null | undefined {\n\tconst prop = getProp(obj, tag, optional)\n\tif (!optional && typeof prop?.value !== \"string\") throw new ParserError(`value of ${tag} is not of type string, got ${JSON.stringify(prop)}`)\n\treturn prop?.value\n}\n\n// Left side of the semicolon\nconst parameterStringValueParser: Parser<string> = (iterator) => {\n\tlet value = \"\"\n\n\tlet next\n\twhile ((next = iterator.peek()) && /[:;,]/.test(next) === false) {\n\t\tvalue += neverNull(iterator.next().value)\n\t}\n\n\treturn value\n}\n\nconst escapedStringValueParser: Parser<string> = (iterator: StringIterator) => {\n\tif (iterator.next().value !== '\"') {\n\t\tthrow new ParserError(\"Not a quoted value\")\n\t}\n\n\tlet value = \"\"\n\n\twhile (iterator.peek() && iterator.peek() !== '\"') {\n\t\tvalue += neverNull(iterator.next().value)\n\t}\n\n\tif (!(iterator.peek() === '\"')) {\n\t\tthrow new Error(\"Not a quoted value, does not end with quote: \" + value)\n\t}\n\n\titerator.next()\n\treturn value\n}\n\nconst propertyParametersKeyValueParser: Parser<[string, string, string]> = combineParsers(\n\tparsePropertyName,\n\tmakeCharacterParser(\"=\"),\n\tmakeEitherParser(escapedStringValueParser, parameterStringValueParser),\n)\n\nconst parsePropertyParameters = combineParsers(\n\tmakeCharacterParser(\";\"),\n\tmakeSeparatedByParser(/*separator*/ makeCharacterParser(\";\"), /*value*/ propertyParametersKeyValueParser),\n)\n\n// make sure the slashes are _always_ replaced first\n// unless you're using an actual parser for this.\n// otherwise we get fun stuff like \";\\\" -> \"\\;\\\" -> \"\\\\;\\\\\"\n// instead of \";\\\" -> \";\\\\\" -> \"\\;\\\\\"\nexport const iCalReplacements = {\n\t\"\\\\\": \"\\\\\\\\\",\n\t\";\": \"\\\\;\",\n\t\",\": \"\\\\,\",\n\t\"\\n\": \"\\\\n\",\n}\n\nconst revICalReplacements = reverse(iCalReplacements)\n\n// Right side of the semicolon\n\n/**\n * Parses everything until the end of the string and unescapes what it should\n */\nconst anyStringUnescapeParser: Parser<string> = (iterator) => {\n\tlet value = \"\"\n\tlet lastCharacter: string | null = null\n\n\twhile (iterator.peek()) {\n\t\tlastCharacter = iterator.next().value\n\n\t\tif (lastCharacter === \"\\\\\") {\n\t\t\tconst next = iterator.peek()\n\t\t\tif (next != null && next in iCalReplacements) {\n\t\t\t\tcontinue\n\t\t\t} else if (iterator.peek() === \"n\") {\n\t\t\t\titerator.next()\n\t\t\t\tvalue += \"\\n\"\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tvalue += neverNull(lastCharacter)\n\t}\n\n\treturn value\n}\n\n/**\n * Parses everything until the semicolon character\n */\nconst propertyStringValueParser: Parser<string> = (iterator) => {\n\tlet value = \"\"\n\n\tlet next\n\twhile ((next = iterator.peek()) && /[;]/.test(next) === false) {\n\t\tvalue += neverNull(iterator.next().value)\n\t}\n\n\treturn value\n}\n\n/**\n * Parses values separated by commas\n */\nconst separatedByCommaParser: Parser<Array<string>> = makeSeparatedByParser(\n\tmakeCharacterParser(\",\"),\n\tmapParser(makeZeroOrMoreParser(makeNotCharacterParser(\",\")), (arr) => arr.join(\"\")),\n)\n\n/**\n * Parses the whole property (both sides)\n */\nexport const propertySequenceParser: Parser<[string, [string, Array<[string, string, string]>] | null, string, string]> = combineParsers(\n\tparsePropertyName,\n\tmaybeParse(parsePropertyParameters),\n\tmakeCharacterParser(\":\"),\n\tanyStringUnescapeParser,\n)\n\nexport function parseProperty(data: string): Property | null {\n\ttry {\n\t\tconst sequence = propertySequenceParser(new StringIterator(data))\n\t\tconst name = sequence[0]\n\t\tconst params: Record<string, string> = {}\n\n\t\tif (sequence[1]) {\n\t\t\tfor (const [name, _eq, value] of sequence[1][1]) {\n\t\t\t\tparams[name] = value\n\t\t\t}\n\t\t}\n\n\t\tconst value = sequence[3]\n\t\treturn {\n\t\t\tname,\n\t\t\tparams,\n\t\t\tvalue,\n\t\t}\n\t} catch (e) {\n\t\treturn null // Returning null to avoid raising parser errors so we can ignore the current broken data/property\n\t}\n}\n\n/**\n * Parses single key=value pair on the right side of the semicolon (value side)\n */\nconst propertyKeyValueParser: Parser<[string, string, string]> = combineParsers(parsePropertyName, makeCharacterParser(\"=\"), propertyStringValueParser)\n\n/**\n * Parses multiple key=value pair on the right side of the semicolon (value side)\n */\nconst valuesSeparatedBySemicolonParser: Parser<Array<[string, string, string]>> = makeSeparatedByParser(makeCharacterParser(\";\"), propertyKeyValueParser)\n\n/**\n * Parses multiple key=value pair on the right side of the semicolon (value side)\n */\nexport function parsePropertyKeyValue(data: string): Record<string, string> {\n\tconst values = valuesSeparatedBySemicolonParser(new StringIterator(data))\n\tconst result: Record<string, string> = {}\n\tfor (const [key, _eq, value] of values) {\n\t\tresult[key] = value\n\t}\n\treturn result\n}\n\nfunction parseIcalObject(tag: string, iterator: Iterator<string>): ICalObject {\n\tlet iteration = iterator.next()\n\tlet properties: Property[] = []\n\tlet children: ICalObject[] = []\n\n\twhile (!iteration.done && iteration.value) {\n\t\tconst property = parseProperty(iteration.value)\n\n\t\tif (!property) {\n\t\t\t// Ignoring broken properties, if there is any mandatory properties missing the function getContents will raise an error later\n\t\t\titeration = iterator.next()\n\t\t\tcontinue\n\t\t}\n\n\t\tif (property.name === \"END\" && property.value === tag) {\n\t\t\treturn {\n\t\t\t\ttype: tag,\n\t\t\t\tproperties,\n\t\t\t\tchildren,\n\t\t\t}\n\t\t}\n\n\t\tif (property.name === \"BEGIN\") {\n\t\t\tif (typeof property.value !== \"string\") throw new ParserError(\"BEGIN with array value\")\n\t\t\tchildren.push(parseIcalObject(property.value, iterator))\n\t\t} else {\n\t\t\tproperties.push(property)\n\t\t}\n\n\t\titeration = iterator.next()\n\t}\n\n\tthrow new ParserError(\"no end for tag \" + tag)\n}\n\nexport function parseICalendar(stringData: string): ICalObject {\n\tconst withFoldedLines = stringData\n\t\t.replace(/\\r?\\n\\s/g, \"\")\n\t\t.split(/\\r?\\n/)\n\t\t.filter((e) => e !== \"\")\n\tconst iterator = withFoldedLines.values()\n\tconst firstLine = iterator.next()\n\n\tif (firstLine.value !== \"BEGIN:VCALENDAR\") {\n\t\tthrow new ParserError(\"Not a VCALENDAR: \" + String(firstLine.value))\n\t}\n\n\treturn parseIcalObject(\"VCALENDAR\", iterator)\n}\n\nfunction parseAlarm(alarmObject: ICalObject, startTime: Date): AlarmInfoTemplate | null {\n\tconst triggerValue = getPropStringValue(alarmObject, \"TRIGGER\", false)\n\tconst alarmInterval: AlarmInterval | null = triggerToAlarmInterval(startTime, triggerValue)\n\treturn alarmInterval != null\n\t\t? {\n\t\t\t\ttrigger: serializeAlarmInterval(alarmInterval),\n\t\t\t\talarmIdentifier: \"\",\n\t\t  }\n\t\t: null\n}\n\n/** visible for testing */\nexport function triggerToAlarmInterval(eventStart: Date, triggerValue: string): AlarmInterval | null {\n\t// Absolute time\n\tif (triggerValue.endsWith(\"Z\")) {\n\t\t// For absolute time we just convert the trigger to minutes. There might be a bigger unit that can express it but we don't have to take care about time\n\t\t// zones or daylight saving in this case and it's simpler this way.\n\t\tconst triggerTime = parseTime(triggerValue).date\n\t\tconst tillEvent = eventStart.getTime() - triggerTime.getTime()\n\t\tconst minutes = Duration.fromMillis(tillEvent).as(\"minutes\")\n\t\treturn { unit: AlarmIntervalUnit.MINUTE, value: minutes }\n\t} else {\n\t\t// If we have relative trigger expressed in units we want to find the smallest unit that will fit. Unlike iCal we do not support multiple units so\n\t\t// we have to pick one.\n\t\tconst duration = parseDuration(triggerValue)\n\n\t\tif (duration.positive) {\n\t\t\treturn null\n\t\t}\n\n\t\tlet smallestUnit: AlarmIntervalUnit = AlarmIntervalUnit.MINUTE\n\t\tif (duration.week) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.WEEK\n\t\t}\n\t\tif (duration.day) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.DAY\n\t\t}\n\t\tif (duration.hour) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.HOUR\n\t\t}\n\t\tif (duration.minute) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.MINUTE\n\t\t}\n\t\tconst luxonDuration = { week: duration.week, day: duration.day, minute: duration.minute, hour: duration.hour }\n\t\tlet value\n\t\tswitch (smallestUnit) {\n\t\t\tcase AlarmIntervalUnit.WEEK:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"weeks\")\n\t\t\t\tbreak\n\t\t\tcase AlarmIntervalUnit.DAY:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"days\")\n\t\t\t\tbreak\n\t\t\tcase AlarmIntervalUnit.HOUR:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"hours\")\n\t\t\t\tbreak\n\t\t\tcase AlarmIntervalUnit.MINUTE:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"minutes\")\n\t\t\t\tbreak\n\t\t}\n\t\treturn { unit: smallestUnit, value }\n\t}\n}\n\nexport function parseRrule(rawRruleValue: string, tzId: string | null): RepeatRule {\n\tlet rruleValue\n\n\ttry {\n\t\trruleValue = parsePropertyKeyValue(rawRruleValue)\n\t} catch (e) {\n\t\tif (e instanceof ParserError) {\n\t\t\tthrow new ParserError(\"RRULE is not an object \" + e.message)\n\t\t} else {\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tconst frequency = icalFrequencyToRepeatPeriod(rruleValue[\"FREQ\"])\n\tconst until = rruleValue[\"UNTIL\"] ? parseUntilRruleTime(rruleValue[\"UNTIL\"], tzId) : null\n\tconst count = rruleValue[\"COUNT\"] ? parseInt(rruleValue[\"COUNT\"]) : null\n\tconst endType: EndType = until != null ? EndType.UntilDate : count != null ? EndType.Count : EndType.Never\n\tconst interval = rruleValue[\"INTERVAL\"] ? parseInt(rruleValue[\"INTERVAL\"]) : 1\n\tconst repeatRule = createRepeatRule({\n\t\tendValue: until ? String(until.getTime()) : count ? String(count) : null,\n\t\tendType: endType,\n\t\tinterval: String(interval),\n\t\tfrequency: frequency,\n\t\texcludedDates: [],\n\t\ttimeZone: \"\",\n\t\tadvancedRules: parseAdvancedRule(rruleValue),\n\t})\n\n\tif (typeof tzId === \"string\") {\n\t\trepeatRule.timeZone = tzId\n\t}\n\n\treturn repeatRule\n}\n\nexport function parseAdvancedRule(rrule: Record<string, string>): CalendarAdvancedRepeatRule[] {\n\tconst advancedRepeatRules: CalendarAdvancedRepeatRule[] = []\n\tfor (const rruleKey in rrule) {\n\t\tif (!BYRULE_MAP.has(rruleKey)) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor (const interval of rrule[rruleKey].split(\",\")) {\n\t\t\tif (interval === \"\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tadvancedRepeatRules.push(\n\t\t\t\tcreateCalendarAdvancedRepeatRule({\n\t\t\t\t\truleType: BYRULE_MAP.get(rruleKey)!.toString(),\n\t\t\t\t\tinterval,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n\treturn advancedRepeatRules\n}\n\nexport function parseExDates(excludedDatesProps: Property[]): DateWrapper[] {\n\t// it's possible that we have duplicated entries since this data comes from whereever, this deduplicates it.\n\tconst allExDates: Map<number, DateWrapper> = new Map<number, DateWrapper>()\n\tfor (let excludedDatesProp of excludedDatesProps) {\n\t\tconst tzId = getTzId(excludedDatesProp)\n\t\tconst values = separatedByCommaParser(new StringIterator(excludedDatesProp.value))\n\t\tfor (let value of values) {\n\t\t\tconst { date: exDate } = parseTime(value, tzId ?? undefined)\n\t\t\tallExDates.set(exDate.getTime(), createDateWrapper({ date: exDate }))\n\t\t}\n\t}\n\treturn [...allExDates.values()].sort((dateWrapper1, dateWrapper2) => dateWrapper1.date.getTime() - dateWrapper2.date.getTime())\n}\n\nexport function parseRecurrenceId(recurrenceIdProp: Property, tzId: string | null): Date {\n\tconst components = parseTimeIntoComponents(recurrenceIdProp.value)\n\t// rrule until is inclusive in ical but exclusive in Tutanota\n\tconst filledComponents = components\n\t// if minute is not provided it is an all day date YYYYMMDD\n\tconst allDay = !(\"minute\" in components)\n\t// We don't use the zone from the components (RRULE) but the one from start time if it was given.\n\t// Don't ask me why but that's how it is.\n\tconst effectiveZone = allDay ? \"UTC\" : components.zone ?? getTzId(recurrenceIdProp) ?? tzId ?? undefined\n\tdelete filledComponents[\"zone\"]\n\tconst luxonDate = DateTime.fromObject(filledComponents, { zone: effectiveZone })\n\treturn toValidJSDate(luxonDate, recurrenceIdProp.value, tzId)\n}\n\n/**\n * @returns new end time\n */\nfunction parseEventDuration(durationValue: string, startTime: Date): Date {\n\tconst duration = parseDuration(durationValue)\n\tlet durationInMillis = 0\n\n\tif (duration.week) {\n\t\tdurationInMillis += DAY_IN_MILLIS * 7 * duration.week\n\t}\n\n\tif (duration.day) {\n\t\tdurationInMillis += DAY_IN_MILLIS * duration.day\n\t}\n\n\tif (duration.hour) {\n\t\tdurationInMillis += 1000 * 60 * 60 * duration.hour\n\t}\n\n\tif (duration.minute) {\n\t\tdurationInMillis += 1000 * 60 * duration.minute\n\t}\n\n\treturn new Date(startTime.getTime() + durationInMillis)\n}\n\nfunction getTzId(prop: Property): string | null {\n\tlet tzId: string | null = null\n\tconst tzIdValue = prop.params[\"TZID\"]\n\n\tif (tzIdValue) {\n\t\tif (IANAZone.isValidZone(tzIdValue)) {\n\t\t\ttzId = tzIdValue\n\t\t} else if (tzIdValue in WindowsZones) {\n\t\t\ttzId = WindowsZones[tzIdValue as keyof typeof WindowsZones]\n\t\t}\n\t}\n\n\treturn tzId\n}\n\nfunction oneDayDurationEnd(startTime: Date, allDay: boolean, tzId: string | null, zone: string): Date {\n\treturn DateTime.fromJSDate(startTime, {\n\t\tzone: allDay ? \"UTC\" : tzId || zone,\n\t})\n\t\t.plus({\n\t\t\tday: 1,\n\t\t})\n\t\t.toJSDate()\n}\n\nconst MAILTO_PREFIX_REGEX = /^mailto:(.*)/i\n\nfunction parseMailtoValue(value: string) {\n\tconst match = value.match(MAILTO_PREFIX_REGEX)\n\treturn match && match[1]\n}\n\nexport const calendarAttendeeStatusToParstat: Record<CalendarAttendeeStatus, string> = {\n\t// WE map ADDED to NEEDS-ACTION for sending out invites\n\t[CalendarAttendeeStatus.ADDED]: \"NEEDS-ACTION\",\n\t[CalendarAttendeeStatus.NEEDS_ACTION]: \"NEEDS-ACTION\",\n\t[CalendarAttendeeStatus.ACCEPTED]: \"ACCEPTED\",\n\t[CalendarAttendeeStatus.DECLINED]: \"DECLINED\",\n\t[CalendarAttendeeStatus.TENTATIVE]: \"TENTATIVE\",\n}\nconst parstatToCalendarAttendeeStatus: Record<string, CalendarAttendeeStatus> = reverse(calendarAttendeeStatusToParstat)\n\nexport function parseCalendarEvents(icalObject: ICalObject, zone: string): ParsedCalendarData {\n\tconst methodProp = getProp(icalObject, \"METHOD\", true)\n\tconst method = methodProp ? methodProp.value : CalendarMethod.PUBLISH\n\tconst eventObjects = icalObject.children.filter((obj) => obj.type === \"VEVENT\")\n\tconst contents = getContents(eventObjects, zone)\n\n\treturn {\n\t\tmethod,\n\t\tcontents,\n\t}\n}\n\nfunction getContents(eventObjects: ICalObject[], zone: string) {\n\treturn eventObjects.map((eventObj, index) => {\n\t\tconst startProp = getProp(eventObj, \"DTSTART\", false)\n\t\tconst tzId = getTzId(startProp)\n\t\tconst { date: startTime, allDay } = parseTime(startProp.value, tzId ?? undefined)\n\n\t\t// start time and tzid is sorted, so we can worry about event identity now before proceeding...\n\t\tlet hasValidUid = false\n\t\tlet uid: string | null = null\n\t\ttry {\n\t\t\tuid = getPropStringValue(eventObj, \"UID\", false)\n\t\t\thasValidUid = true\n\t\t} catch (e) {\n\t\t\tif (e instanceof ParserError) {\n\t\t\t\t// Also parse event and create new UID if none is set\n\t\t\t\tuid = `import-${Date.now()}-${index}@tuta.com`\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tconst recurrenceIdProp = getProp(eventObj, \"RECURRENCE-ID\", true)\n\t\tlet recurrenceId: Date | null = null\n\t\tif (recurrenceIdProp != null && hasValidUid) {\n\t\t\t// if we generated the UID, we have no way of knowing which event series this recurrenceId refers to.\n\t\t\t// in that case, we just don't add the recurrenceId and import the event as a standalone.\n\t\t\trecurrenceId = parseRecurrenceId(recurrenceIdProp, tzId)\n\t\t}\n\n\t\tconst endTime = parseEndTime(eventObj, allDay, startTime, tzId, zone)\n\n\t\tlet summary: string = \"\"\n\t\tconst maybeSummary = parseICalText(eventObj, \"SUMMARY\")\n\t\tif (maybeSummary) summary = maybeSummary\n\n\t\tlet location: string = \"\"\n\t\tconst maybeLocation = parseICalText(eventObj, \"LOCATION\")\n\t\tif (maybeLocation) location = maybeLocation\n\n\t\tconst rruleProp = getPropStringValue(eventObj, \"RRULE\", true)\n\t\tconst excludedDateProps = eventObj.properties.filter((p) => p.name === \"EXDATE\")\n\n\t\tlet repeatRule: RepeatRule | null = null\n\t\tif (rruleProp != null) {\n\t\t\trepeatRule = parseRrule(rruleProp, tzId)\n\t\t\trepeatRule.excludedDates = parseExDates(excludedDateProps)\n\t\t}\n\n\t\tconst description = parseICalText(eventObj, \"DESCRIPTION\") ?? \"\"\n\n\t\tconst sequenceProp = getProp(eventObj, \"SEQUENCE\", true)\n\t\tlet sequence: string = \"0\"\n\t\tif (sequenceProp) {\n\t\t\tconst sequenceNumber = filterInt(sequenceProp.value)\n\n\t\t\tif (Number.isNaN(sequenceNumber)) {\n\t\t\t\tthrow new ParserError(\"SEQUENCE value is not a number\")\n\t\t\t}\n\n\t\t\t// Convert it back to NumberString. Could use original one but this feels more robust.\n\t\t\tsequence = String(sequenceNumber)\n\t\t}\n\n\t\tconst attendees = getAttendees(eventObj)\n\n\t\tconst organizerProp = getProp(eventObj, \"ORGANIZER\", true)\n\t\tlet organizer: EncryptedMailAddress | null = null\n\t\tif (organizerProp) {\n\t\t\tconst organizerAddress = parseMailtoValue(organizerProp.value)\n\n\t\t\tif (organizerAddress && isMailAddress(organizerAddress, false)) {\n\t\t\t\torganizer = createEncryptedMailAddress({\n\t\t\t\t\taddress: organizerAddress,\n\t\t\t\t\tname: organizerProp.params[\"name\"] || \"\",\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconsole.log(\"organizer has no address or address is invalid, ignoring: \", organizerAddress)\n\t\t\t}\n\t\t}\n\n\t\tconst event = createCalendarEvent({\n\t\t\tdescription,\n\t\t\tstartTime,\n\t\t\tendTime,\n\t\t\tuid,\n\t\t\trecurrenceId,\n\t\t\tsummary,\n\t\t\tlocation,\n\t\t\trepeatRule,\n\t\t\tsequence,\n\t\t\tattendees,\n\t\t\torganizer,\n\t\t\thashedUid: null,\n\t\t\tinvitedConfidentially: null,\n\t\t\talarmInfos: [],\n\t\t}) as Require<\"uid\", CalendarEvent>\n\n\t\tlet alarms: AlarmInfoTemplate[] = []\n\n\t\ttry {\n\t\t\talarms = getAlarms(eventObj, startTime)\n\t\t} catch (e) {\n\t\t\tconsole.log(\"alarm is invalid for event: \", event.summary, event.startTime)\n\t\t}\n\n\t\treturn {\n\t\t\tevent,\n\t\t\talarms,\n\t\t}\n\t})\n}\n\nfunction getAttendees(eventObj: ICalObject) {\n\tlet attendees: CalendarEventAttendee[] = []\n\tfor (const property of eventObj.properties) {\n\t\tif (property.name === \"ATTENDEE\") {\n\t\t\tconst attendeeAddress = parseMailtoValue(property.value)\n\n\t\t\tif (!attendeeAddress || !isMailAddress(attendeeAddress, false)) {\n\t\t\t\tconsole.log(\"attendee has no address or address is invalid, ignoring: \", attendeeAddress)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst partStatString = property.params[\"PARTSTAT\"]\n\t\t\tconst status = partStatString ? parstatToCalendarAttendeeStatus[partStatString] : CalendarAttendeeStatus.NEEDS_ACTION\n\n\t\t\tif (!status) {\n\t\t\t\tconsole.log(`attendee has invalid partsat: ${partStatString}, ignoring`)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tattendees.push(\n\t\t\t\tcreateCalendarEventAttendee({\n\t\t\t\t\taddress: createEncryptedMailAddress({\n\t\t\t\t\t\taddress: attendeeAddress,\n\t\t\t\t\t\tname: property.params[\"CN\"] || \"\",\n\t\t\t\t\t}),\n\t\t\t\t\tstatus,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n\treturn attendees\n}\n\nfunction getAlarms(eventObj: ICalObject, startTime: Date): AlarmInfoTemplate[] {\n\tconst alarms: AlarmInfoTemplate[] = []\n\tfor (const alarmChild of eventObj.children) {\n\t\tif (alarmChild.type === \"VALARM\") {\n\t\t\tconst newAlarm = parseAlarm(alarmChild, startTime)\n\t\t\tif (newAlarm) alarms.push(newAlarm)\n\t\t}\n\t}\n\treturn alarms\n}\n\n/**\n * Parses text properties according to the iCal standard.\n * https://icalendar.org/iCalendar-RFC-5545/3-3-11-text.html\n * @param eventObj\n * @param tag\n */\nfunction parseICalText(eventObj: ICalObject, tag: string) {\n\tlet text = getPropStringValue(eventObj, tag, true)\n\tfor (const rawEscape in revICalReplacements) {\n\t\tif (rawEscape === \"\\\\n\") {\n\t\t\ttext = text?.replace(\"\\\\N\", revICalReplacements[rawEscape])\n\t\t}\n\t\ttext = text?.replace(rawEscape, revICalReplacements[rawEscape])\n\t}\n\treturn text\n}\n\nfunction parseEndTime(eventObj: ICalObject, allDay: boolean, startTime: Date, tzId: string | null, zone: string): Date {\n\tconst endProp = getProp(eventObj, \"DTEND\", true)\n\n\tif (endProp) {\n\t\tif (typeof endProp.value !== \"string\") throw new ParserError(\"DTEND value is not a string\")\n\t\tconst endTzId = getTzId(endProp)\n\t\tconst parsedEndTime = parseTime(endProp.value, typeof endTzId === \"string\" ? endTzId : undefined)\n\t\tconst endTime = parsedEndTime.date\n\t\tif (endTime > startTime) return endTime\n\n\t\t// as per RFC, these are _technically_ illegal: https://tools.ietf.org/html/rfc5545#section-3.8.2.2\n\t\tif (allDay) {\n\t\t\t// if the startTime indicates an all-day event, we want to preserve that.\n\t\t\t// we'll assume a 1-day duration.\n\t\t\treturn DateTime.fromJSDate(startTime).plus({ day: 1 }).toJSDate()\n\t\t} else {\n\t\t\t// we make a best effort to deliver alarms at the set interval before startTime and set the\n\t\t\t// event duration to be 1 second\n\t\t\t// as of now:\n\t\t\t// * this displays as ending the same minute it starts in the tutanota calendar\n\t\t\t// * gets exported with a duration of 1 second\n\t\t\treturn DateTime.fromJSDate(startTime).plus({ second: 1 }).toJSDate()\n\t\t}\n\t} else {\n\t\tconst durationValue = getPropStringValue(eventObj, \"DURATION\", true)\n\n\t\tif (durationValue) {\n\t\t\treturn parseEventDuration(durationValue, startTime)\n\t\t} else {\n\t\t\t// >For cases where a \"VEVENT\" calendar component specifies a \"DTSTART\" property with a DATE value type but no \"DTEND\" nor\n\t\t\t// \"DURATION\" property, the event's duration is taken to be one day.\n\t\t\t//\n\t\t\t// https://tools.ietf.org/html/rfc5545#section-3.6.1\n\t\t\treturn oneDayDurationEnd(startTime, allDay, tzId, zone)\n\t\t}\n\t}\n}\n\ntype ICalDuration = {\n\tpositive: boolean\n\tday?: number\n\tweek?: number\n\thour?: number\n\tminute?: number\n}\n\nfunction icalFrequencyToRepeatPeriod(value: string): RepeatPeriod {\n\tconst convertedValue = {\n\t\tDAILY: RepeatPeriod.DAILY,\n\t\tWEEKLY: RepeatPeriod.WEEKLY,\n\t\tMONTHLY: RepeatPeriod.MONTHLY,\n\t\tYEARLY: RepeatPeriod.ANNUALLY,\n\t}[value]\n\tif (convertedValue == null) {\n\t\tthrow new ParserError(\"Invalid frequency: \" + value)\n\t}\n\treturn convertedValue\n}\n\nexport function repeatPeriodToIcalFrequency(repeatPeriod: RepeatPeriod) {\n\t// Separate variable to declare mapping type\n\tconst mapping: Record<RepeatPeriod, string> = {\n\t\t[RepeatPeriod.DAILY]: \"DAILY\",\n\t\t[RepeatPeriod.WEEKLY]: \"WEEKLY\",\n\t\t[RepeatPeriod.MONTHLY]: \"MONTHLY\",\n\t\t[RepeatPeriod.ANNUALLY]: \"YEARLY\",\n\t}\n\treturn mapping[repeatPeriod]\n}\n\ntype DateComponents = {\n\tyear: number\n\tmonth: number\n\tday: number\n\tzone?: string\n}\ntype TimeComponents = {\n\thour: number\n\tminute: number\n}\ntype DateTimeComponents = DateComponents & TimeComponents\n\n/** parse a time */\nexport function parseTimeIntoComponents(value: string): DateComponents | DateTimeComponents {\n\tconst trimmedValue = value.trim()\n\n\tif (/[0-9]{8}T[0-9]{6}Z/.test(trimmedValue)) {\n\t\t// date with time in UTC\n\t\tconst { year, month, day } = parseDateString(trimmedValue)\n\t\tconst hour = parseInt(trimmedValue.slice(9, 11))\n\t\tconst minute = parseInt(trimmedValue.slice(11, 13))\n\t\treturn {\n\t\t\tyear,\n\t\t\tmonth,\n\t\t\tday,\n\t\t\thour,\n\t\t\tminute,\n\t\t\tzone: \"UTC\",\n\t\t}\n\t} else if (/[0-9]{8}T[0-9]{6}/.test(trimmedValue)) {\n\t\t// date with time in local timezone\n\t\tconst { year, month, day } = parseDateString(trimmedValue)\n\t\tconst hour = parseInt(trimmedValue.slice(9, 11))\n\t\tconst minute = parseInt(trimmedValue.slice(11, 13))\n\t\treturn {\n\t\t\tyear,\n\t\t\tmonth,\n\t\t\tday,\n\t\t\thour,\n\t\t\tminute,\n\t\t}\n\t} else if (/[0-9]{8}/.test(trimmedValue)) {\n\t\t// all day events\n\t\treturn Object.assign({}, parseDateString(trimmedValue))\n\t} else {\n\t\tthrow new ParserError(\"Failed to parse time: \" + trimmedValue)\n\t}\n}\n\nexport function parseUntilRruleTime(value: string, zone: string | null): Date {\n\tconst components = parseTimeIntoComponents(value)\n\t// rrule until is inclusive in ical but exclusive in Tutanota\n\tconst filledComponents = components\n\t// if minute is not provided it is an all day date YYYYMMDD\n\tconst allDay = !(\"minute\" in components)\n\t// We don't use the zone from the components (RRULE) but the one from start time if it was given.\n\t// Don't ask me why but that's how it is.\n\tconst effectiveZone = allDay ? \"UTC\" : zone ?? undefined\n\tdelete filledComponents[\"zone\"]\n\tconst luxonDate = DateTime.fromObject(filledComponents, { zone: effectiveZone })\n\tconst startOfNextDay = luxonDate\n\t\t.plus({\n\t\t\tday: 1,\n\t\t})\n\t\t.startOf(\"day\")\n\treturn toValidJSDate(startOfNextDay, value, zone)\n}\n\n/**\n * parse a ical time string and return a JS Date object along with a flag that determines\n * whether the time should be considered part of an all-day event\n * @param value {string} the time string to be parsed\n * @param zone {string} the time zone to use\n */\nexport function parseTime(\n\tvalue: string,\n\tzone?: string,\n): {\n\tdate: Date\n\tallDay: boolean\n} {\n\tconst components = parseTimeIntoComponents(value)\n\t// if minute is not provided it is an all day date YYYYMMDD\n\tconst allDay = !(\"minute\" in components)\n\tconst effectiveZone = allDay ? \"UTC\" : components.zone ?? zone\n\tdelete components[\"zone\"]\n\tconst filledComponents = Object.assign(\n\t\t{},\n\t\tallDay\n\t\t\t? {\n\t\t\t\t\thour: 0,\n\t\t\t\t\tminute: 0,\n\t\t\t\t\tsecond: 0,\n\t\t\t\t\tmillisecond: 0,\n\t\t\t  }\n\t\t\t: {},\n\t\tcomponents,\n\t)\n\n\ttry {\n\t\tconst dateTime = DateTime.fromObject(filledComponents, { zone: effectiveZone })\n\t\treturn { date: toValidJSDate(dateTime, value, zone ?? null), allDay }\n\t} catch (e) {\n\t\tif (e instanceof ParserError) {\n\t\t\tthrow e\n\t\t}\n\t\tthrow new ParserError(\n\t\t\t`failed to parse time from ${value} to ${JSON.stringify(filledComponents)}, effectiveZone: ${effectiveZone}, original error: ${e.message}`,\n\t\t)\n\t}\n}\n\nfunction toValidJSDate(dateTime: DateTime, value: string, zone: string | null): Date {\n\tif (!dateTime.isValid) {\n\t\tthrow new ParserError(`Date value ${value} is invalid in zone ${String(zone)}`)\n\t}\n\n\treturn dateTime.toJSDate()\n}\n\nfunction parsePropertyName(iterator: StringIterator): string {\n\tlet text = \"\"\n\n\tlet next\n\twhile ((next = iterator.peek()) && /[a-zA-Z0-9-_]/.test(next)) {\n\t\ttext += neverNull(iterator.next().value)\n\t}\n\n\tif (text === \"\") {\n\t\tthrow new ParserError(\"could not parse property name: \" + iterator.peek())\n\t}\n\n\treturn text\n}\n\nconst secondDurationParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"S\"))\nconst minuteDurationParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"M\"))\nconst hourDurationParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"H\"))\ntype TimeDuration = {\n\ttype: \"time\"\n\thour?: number\n\tminute?: number\n\tsecond?: number\n}\ntype DateDuration = {\n\ttype: \"date\"\n\tday: number\n\ttime: TimeDuration | null\n}\ntype WeekDuration = {\n\ttype: \"week\"\n\tweek: number\n}\nconst durationTimeParser = mapParser(\n\tcombineParsers(makeCharacterParser(\"T\"), maybeParse(hourDurationParser), maybeParse(minuteDurationParser), maybeParse(secondDurationParser)),\n\t(parsed) => {\n\t\t//Note: we parse for seconds in case they are there, but do not have that as an option, so they are ignored\n\t\tlet hour, minute\n\n\t\t// the first item in parsed is T (if time is there)\n\t\tif (parsed[1]) {\n\t\t\thour = parsed[1][0]\n\t\t}\n\t\tif (parsed[2]) {\n\t\t\tminute = parsed[2][0]\n\t\t}\n\n\t\treturn {\n\t\t\thour,\n\t\t\tminute,\n\t\t}\n\t},\n)\nconst durationDayParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"D\"))\nconst durationWeekParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"W\"))\nconst durationParser = mapParser(\n\tcombineParsers(\n\t\tmaybeParse(makeEitherParser(makeCharacterParser(\"+\"), makeCharacterParser(\"-\"))),\n\t\tmakeCharacterParser(\"P\"),\n\t\tmaybeParse(durationWeekParser),\n\t\tmaybeParse(durationDayParser),\n\t\tmaybeParse(durationTimeParser),\n\t),\n\t(parsed) => {\n\t\tconst positive = parsed[0] !== \"-\"\n\t\tlet week, day, hour, minute\n\t\tif (parsed[2]) {\n\t\t\tweek = parsed[2][0]\n\t\t}\n\t\tif (parsed[3]) {\n\t\t\tday = parsed[3][0]\n\t\t}\n\n\t\treturn {\n\t\t\tpositive,\n\t\t\tweek,\n\t\t\tday,\n\t\t\thour: parsed[4]?.hour,\n\t\t\tminute: parsed[4]?.minute,\n\t\t}\n\t},\n)\n\nexport function parseDuration(value: string): ICalDuration {\n\tconst iterator = new StringIterator(value)\n\tconst duration = durationParser(iterator)\n\n\tif (iterator.peek()) {\n\t\tthrow new ParserError(\"Could not parse duration completely\")\n\t}\n\n\treturn duration\n}\n","import { CalendarEvent, CalendarGroupRoot } from \"../../api/entities/tutanota/TypeRefs.js\"\nimport type { AlarmInfoTemplate } from \"../../api/worker/facades/lazy/CalendarFacade.js\"\nimport { assignEventId, CalendarEventValidity, checkEventValidity, getTimeZone } from \"../date/CalendarUtils.js\"\nimport { ParsedCalendarData, ParsedEvent } from \"./CalendarImporter.js\"\nimport { freezeMap, getFromMap, groupBy, insertIntoSortedArray } from \"@tutao/tutanota-utils\"\nimport { generateEventElementId } from \"../../api/common/utils/CommonCalendarUtils.js\"\nimport { createDateWrapper } from \"../../api/entities/sys/TypeRefs.js\"\nimport { parseCalendarEvents, parseICalendar } from \"../../../calendar-app/calendar/export/CalendarParser.js\"\nimport { lang, type TranslationKey } from \"../../misc/LanguageViewModel.js\"\nimport { assertValidURL } from \"@tutao/tutanota-utils/dist/Utils.js\"\n\nexport enum EventImportRejectionReason {\n\tPre1970,\n\tInversed,\n\tInvalidDate,\n\tDuplicate,\n}\n\nexport type EventWrapper = {\n\tevent: CalendarEvent\n\talarms: ReadonlyArray<AlarmInfoTemplate>\n}\n\n/** check if the event should be skipped because it's invalid or already imported. if not, add it to the map. */\nfunction shouldBeSkipped(event: CalendarEvent, instanceIdentifierToEventMap: Map<string, CalendarEvent>): EventImportRejectionReason | null {\n\tif (!event.uid) {\n\t\t// should not happen because calendar parser will generate uids if they do not exist\n\t\tthrow new Error(\"Uid is not set for imported event\")\n\t}\n\n\tswitch (checkEventValidity(event)) {\n\t\tcase CalendarEventValidity.InvalidContainsInvalidDate:\n\t\t\treturn EventImportRejectionReason.InvalidDate\n\t\tcase CalendarEventValidity.InvalidEndBeforeStart:\n\t\t\treturn EventImportRejectionReason.Inversed\n\t\tcase CalendarEventValidity.InvalidPre1970:\n\t\t\treturn EventImportRejectionReason.Pre1970\n\t}\n\tconst instanceIdentifier = makeInstanceIdentifier(event)\n\tif (!instanceIdentifierToEventMap.has(instanceIdentifier)) {\n\t\tinstanceIdentifierToEventMap.set(instanceIdentifier, event)\n\t\treturn null\n\t} else {\n\t\treturn EventImportRejectionReason.Duplicate\n\t}\n}\n\n/** we try to enforce that each calendar only contains each uid once, but we need to take into consideration\n * that altered instances have the same uid as their progenitor.*/\nfunction makeInstanceIdentifier(event: CalendarEvent): string {\n\treturn `${event.uid}-${event.recurrenceId?.getTime() ?? \"progenitor\"}`\n}\n\nexport type RejectedEvents = Map<EventImportRejectionReason, Array<CalendarEvent>>\n\n/** sort the parsed events into the ones we want to create and the ones we want to reject (stating a rejection reason)\n * will assign event id according to the calendarGroupRoot and the long/short event status */\nexport function sortOutParsedEvents(\n\tparsedEvents: ParsedEvent[],\n\texistingEvents: Array<CalendarEvent>,\n\tcalendarGroupRoot: CalendarGroupRoot,\n\tzone: string,\n): {\n\trejectedEvents: RejectedEvents\n\teventsForCreation: Array<EventWrapper>\n} {\n\tconst instanceIdentifierToEventMap = new Map()\n\tfor (const existingEvent of existingEvents) {\n\t\tif (existingEvent.uid == null) continue\n\t\tinstanceIdentifierToEventMap.set(makeInstanceIdentifier(existingEvent), existingEvent)\n\t}\n\n\tconst rejectedEvents: RejectedEvents = new Map()\n\tconst eventsForCreation: Array<{ event: CalendarEvent; alarms: Array<AlarmInfoTemplate> }> = []\n\tfor (const [_, flatParsedEvents] of groupBy(parsedEvents, (e) => e.event.uid)) {\n\t\tlet progenitor: { event: CalendarEvent; alarms: Array<AlarmInfoTemplate> } | null = null\n\t\tlet alteredInstances: Array<{ event: CalendarEvent; alarms: Array<AlarmInfoTemplate> }> = []\n\n\t\tfor (const { event, alarms } of flatParsedEvents) {\n\t\t\tif (flatParsedEvents.length > 1)\n\t\t\t\tconsole.warn(\"[ImportExportUtils] Found events with same uid: flatParsedEvents with more than one entry\", { flatParsedEvents })\n\t\t\tconst rejectionReason = shouldBeSkipped(event, instanceIdentifierToEventMap)\n\t\t\tif (rejectionReason != null) {\n\t\t\t\tgetFromMap(rejectedEvents, rejectionReason, () => []).push(event)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// hashedUid will be set later in calendarFacade to avoid importing the hash function here\n\t\t\tconst repeatRule = event.repeatRule\n\t\t\tevent._ownerGroup = calendarGroupRoot._id\n\n\t\t\tif (repeatRule != null && repeatRule.timeZone === \"\") {\n\t\t\t\trepeatRule.timeZone = getTimeZone()\n\t\t\t}\n\n\t\t\tfor (let alarmInfo of alarms) {\n\t\t\t\talarmInfo.alarmIdentifier = generateEventElementId(Date.now())\n\t\t\t}\n\n\t\t\tassignEventId(event, zone, calendarGroupRoot)\n\t\t\tif (event.recurrenceId == null) {\n\t\t\t\t// the progenitor must be null here since we would have\n\t\t\t\t// rejected the second uid-progenitor event in shouldBeSkipped.\n\t\t\t\tprogenitor = { event, alarms }\n\t\t\t} else {\n\t\t\t\tif (progenitor?.event.repeatRule != null) {\n\t\t\t\t\tinsertIntoSortedArray(\n\t\t\t\t\t\tcreateDateWrapper({ date: event.recurrenceId }),\n\t\t\t\t\t\tprogenitor.event.repeatRule.excludedDates,\n\t\t\t\t\t\t(left, right) => left.date.getTime() - right.date.getTime(),\n\t\t\t\t\t\t() => true,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\talteredInstances.push({ event, alarms })\n\t\t\t}\n\t\t}\n\t\tif (progenitor != null) eventsForCreation.push(progenitor)\n\t\teventsForCreation.push(...alteredInstances)\n\t}\n\n\treturn { rejectedEvents, eventsForCreation }\n}\n\n/** importer internals exported for testing */\nexport function parseCalendarStringData(value: string, zone: string): ParsedCalendarData {\n\tconst tree = parseICalendar(value)\n\treturn parseCalendarEvents(tree, zone)\n}\n\nexport function isIcal(iCalStr: string): boolean {\n\treturn iCalStr.trimStart().split(/\\r?\\n/, 1)[0] === \"BEGIN:VCALENDAR\"\n}\n\nexport function getExternalCalendarName(iCalStr: string): string {\n\tlet calName = iCalStr.match(/X-WR-CALNAME:(.*)\\r?\\n/)\n\tconst name = calName ? calName[1] : iCalStr.match(/PRODID:-\\/\\/(.*)\\/\\//)?.[1]!\n\treturn name ?? lang.get(\"noTitle_label\")\n}\n\nexport const enum SyncStatus {\n\tFailed = \"Failed\",\n\tSuccess = \"Success\",\n}\n\nexport function checkURLString(url: string): TranslationKey | URL {\n\tconst assertResult = assertValidURL(url)\n\tif (!assertResult) return \"invalidURL_msg\"\n\tif (!hasValidProtocol(assertResult, [\"https:\"])) return \"invalidURLProtocol_msg\"\n\treturn assertResult\n}\n\nexport function hasValidProtocol(url: URL, validProtocols: string[]) {\n\treturn validProtocols.includes(url.protocol)\n}\n\nexport const enum ByRule {\n\tBYMINUTE,\n\tBYHOUR,\n\tBYDAY,\n\tBYMONTHDAY,\n\tBYYEARDAY,\n\tBYWEEKNO,\n\tBYMONTH,\n\tBYSETPOS,\n\tWKST,\n}\n\nexport const BYRULE_MAP = freezeMap(\n\tnew Map([\n\t\t[\"BYMINUTE\", ByRule.BYMINUTE],\n\t\t[\"BYHOUR\", ByRule.BYHOUR],\n\t\t[\"BYDAY\", ByRule.BYDAY],\n\t\t[\"BYMONTHDAY\", ByRule.BYMONTHDAY],\n\t\t[\"BYYEARDAY\", ByRule.BYYEARDAY],\n\t\t[\"BYWEEKNO\", ByRule.BYWEEKNO],\n\t\t[\"BYMONTH\", ByRule.BYMONTH],\n\t\t[\"BYSETPOS\", ByRule.BYSETPOS],\n\t\t[\"WKST\", ByRule.WKST],\n\t]),\n)\n"],"mappings":"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"}