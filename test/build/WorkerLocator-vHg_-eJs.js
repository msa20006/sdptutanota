
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { LazyLoaded, TypeRef, arrayEquals, assertNotNull, base64ToBase64Url, base64ToUint8Array, byteArraysToBytes, bytesToByteArrays, clone, concat, debounce, deduplicate, defer, delay, downcast, first, getDayShifted, getFirstOrThrow, getFromMap, getStartOfDay, groupBy, isEmpty, isNotNull, isSameTypeRef, isSameTypeRefByAttr, lazyMemoized, neverNull, noOp, ofClass, pMap, remove, stringToUtf8Uint8Array, uint8ArrayToBase64, uint8ArrayToHex, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertWorkerOrNode, getWebsocketBaseUrl, isAdminClient, isAndroidApp, isApp, isBrowser, isIOSApp, isOfflineStorageAvailable, isTest } from "./Env-D5xGlXfw.js";
import { AccountType, BlobAccessTokenKind, BucketPermissionType, Const, CryptoProtocolVersion, EncryptionAuthStatus, GroupKeyRotationType, GroupType, OperationType, PermissionType, PublicKeyIdentifierType, SYSTEM_GROUP_MAIL_ADDRESS, asCryptoProtoocolVersion, assertEnumValue } from "./TutanotaConstants-3bwAESYA.js";
import { ConnectionError, LockedError, NotFoundError, PayloadTooLargeError, ServiceUnavailableError, TooManyRequestsError } from "./RestError-D17JEBMr.js";
import { LoginIncompleteError } from "./LoginIncompleteError-CpiW0a0l.js";
import { CryptoError } from "./CryptoError-PqdvQky4.js";
import { RecipientNotResolvedError, SessionKeyNotFoundError } from "./ErrorUtils-o1-v67Dd.js";
import { RecipientsNotFoundError } from "./RecipientsNotFoundError-D8oGE7A_.js";
import { AssociationType, Cardinality, Type, ValueType, customIdToString, customIdToUint8array, elementIdPart, firstBiggerThanSecond, getElementId, getListId, isSameId, listIdPart, stringToCustomId } from "./EntityUtils-RQxXZlcV.js";
import { ContactTypeRef, FileTypeRef, InternalRecipientKeyDataTypeRef, MailTypeRef, TutanotaPropertiesTypeRef, createEncryptTutanotaPropertiesData, createEntropyData, createInternalRecipientKeyData, createSymEncInternalRecipientKeyData } from "./TypeRefs-CR3TLWn0.js";
import { BucketKeyTypeRef, BucketPermissionTypeRef, CustomerTypeRef, GroupInfoTypeRef, GroupKeyTypeRef, GroupKeyUpdateTypeRef, GroupMemberTypeRef, GroupTypeRef, KeyRotationTypeRef, PermissionTypeRef, PushIdentifierTypeRef, SentGroupInvitationTypeRef, UserGroupKeyDistributionTypeRef, UserGroupRootTypeRef, UserTypeRef, createAdminGroupKeyAuthenticationData, createAdminGroupKeyRotationPostIn, createGroupKeyRotationData, createGroupKeyRotationPostIn, createGroupKeyUpdateData, createGroupMembershipKeyData, createGroupMembershipUpdateData, createInstanceSessionKey, createKeyPair, createMembershipPutIn, createPubEncKeyData, createPublicKeyGetIn, createPublicKeyPutIn, createRecoverCodeData, createUpdatePermissionKeyData, createUpdateSessionKeysPostIn, createUserGroupKeyRotationData, createUserGroupKeyRotationPostIn, createWebsocketLeaderStatus } from "./TypeRefs-BP1jvX9p.js";
import { HttpMethod, MediaType, modelInfos, resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import { EntityClient } from "./EntityClient-B0RSdk2i.js";
import { ENABLE_MAC, IV_BYTE_LENGTH, KEY_LENGTH_BYTES_AES_256, KYBER_RAND_AMOUNT_OF_ENTROPY, KeyPairType, aes256RandomKey, aesDecrypt, aesEncrypt, authenticatedAesDecrypt, bitArrayToUint8Array, createAuthVerifier, decapsulate, decryptKey, decryptKeyPair, eccDecapsulate, eccEncapsulate, encapsulate, encryptKey, generateEccKeyPair, generateKeyFromPassphrase, generateKeyPair, getKeyLengthBytes, hexToRsaPublicKey, hkdf, isPqKeyPairs, isPqPublicKey, isRsaEccKeyPair, isRsaOrRsaEccKeyPair, isRsaPublicKey, keyToBase64, keyToUint8Array, kyberPublicKeyToBytes, pqKeyPairsToPublicKeys, random, rsaDecrypt, rsaEncrypt, sha256Hash, uint8ArrayToBitArray, uint8ArrayToKey } from "./dist-DcZ1Y4qd.js";
import { AdminGroupKeyRotationService, GroupKeyRotationInfoService, GroupKeyRotationService, MembershipService, PublicKeyService, UpdatePermissionKeyService, UpdateSessionKeysService, UserGroupKeyRotationService } from "./Services-CZFE0084.js";
import { EncryptTutanotaPropertiesService, EntropyService } from "./Services-DCx-CeM7.js";
import { getUserGroupMemberships } from "./GroupUtils-0ZkLIAeC.js";
import { birthdayToIsoDate, oldBirthdayToBirthday } from "./BirthdayUtils-BcCMglSq.js";
import { SessionType } from "./SessionType-rxSDsswH.js";
import { CustomCacheHandlerMap, DefaultEntityRestCache, EntityRestClient, EventBusClient, OfflineStorage, customIdToBase64Url, ensureBase64Ext, expandId, typeRefToPath } from "./EntityRestClient--6dT7ZRF.js";
import { RestClient } from "./RestClient-CmoHrId4.js";
import { BlobAccessTokenService, createBlobAccessTokenPostIn, createBlobReadData, createBlobWriteData, createInstanceId } from "./Services-CtomUk-n.js";
import { CryptoWrapper, encryptBytes, encryptKeyWithVersionedKey } from "./CryptoWrapper-BTtEczdP.js";
import { compress, uncompress } from "./Compression-CvN1IyGQ.js";
import { ExportFacadeSendDispatcher, FileFacadeSendDispatcher, NativeFileApp, NativePushFacadeSendDispatcher } from "./ExportFacadeSendDispatcher-B0ubUu3N.js";
import { InterWindowEventFacadeSendDispatcher } from "./InterWindowEventFacadeSendDispatcher-BTmViZah.js";
import { DomainConfigProvider, NoZoneDateProvider, SchedulerImpl } from "./Scheduler-B2H65_EO.js";
import { LoginFacade } from "./LoginFacade-zvyZiAr1.js";
import { OFFLINE_STORAGE_MIGRATIONS, OfflineStorageMigrator } from "./OfflineStorageMigrator-CQqO_-Qy.js";
import { loadWasm$1 as loadWasm } from "./_wasm-loader_argon2-Be2iJ7_O.js";
import { loadWasm as loadWasm$1 } from "./_wasm-loader_liboqs-CtTp3DnG.js";
import { MailOfflineCleaner } from "./MailOfflineCleaner-BHMPStjr.js";

//#region ../src/common/api/worker/SuspensionHandler.ts
var SuspensionHandler = class {
	_isSuspended;
	_suspendedUntil;
	_deferredRequests;
	_hasSentInfoMessage;
	_timeout;
	constructor(infoMessageHandler, systemTimeout) {
		this.infoMessageHandler = infoMessageHandler;
		this._isSuspended = false;
		this._suspendedUntil = 0;
		this._deferredRequests = [];
		this._hasSentInfoMessage = false;
		this._timeout = systemTimeout;
	}
	/**
	* Activates suspension states for the given amount of seconds. After the end of the suspension time all deferred requests are executed.
	*/
	activateSuspensionIfInactive(suspensionDurationSeconds, resourceURL) {
		if (!this.isSuspended()) {
			console.log(`Activating suspension (${resourceURL}):  ${suspensionDurationSeconds}s`);
			this._isSuspended = true;
			const suspensionStartTime = Date.now();
			this._timeout.setTimeout(async () => {
				this._isSuspended = false;
				console.log(`Suspension released after ${(Date.now() - suspensionStartTime) / 1e3}s`);
				await this._onSuspensionComplete();
			}, suspensionDurationSeconds * 1e3);
			if (!this._hasSentInfoMessage) {
				this.infoMessageHandler.onInfoMessage({
					translationKey: "clientSuspensionWait_label",
					args: {}
				});
				this._hasSentInfoMessage = true;
			}
		}
	}
	isSuspended() {
		return this._isSuspended;
	}
	/**
	* Adds a request to the deferred queue.
	* @param request
	* @returns {Promise<T>}
	*/
	deferRequest(request) {
		if (this._isSuspended) {
			const deferredObject = defer();
			this._deferredRequests.push(deferredObject);
			deferredObject.promise = deferredObject.promise.then(() => request());
			return deferredObject.promise;
		} else return request();
	}
	async _onSuspensionComplete() {
		const deferredRequests = this._deferredRequests;
		this._deferredRequests = [];
		for (let deferredRequest of deferredRequests) {
			deferredRequest.resolve(null);
			await deferredRequest.promise.catch(noOp);
		}
	}
};

//#endregion
//#region ../src/common/api/worker/facades/DeviceEncryptionFacade.ts
var DeviceEncryptionFacade = class {
	/**
	* Generates an encryption key.
	*/
	async generateKey() {
		return bitArrayToUint8Array(aes256RandomKey());
	}
	/**
	* Encrypts {@param data} using {@param deviceKey}.
	* @param deviceKey Key used for encryption
	* @param data Data to encrypt.
	*/
	async encrypt(deviceKey, data) {
		return aesEncrypt(uint8ArrayToBitArray(deviceKey), data);
	}
	/**
	* Decrypts {@param encryptedData} using {@param deviceKey}.
	* @param deviceKey Key used for encryption
	* @param encryptedData Data to be decrypted.
	*/
	async decrypt(deviceKey, encryptedData) {
		return aesDecrypt(uint8ArrayToBitArray(deviceKey), encryptedData);
	}
};

//#endregion
//#region ../src/common/native/worker/AesApp.ts
var AesApp = class {
	constructor(nativeCryptoFacade, random$1) {
		this.nativeCryptoFacade = nativeCryptoFacade;
		this.random = random$1;
	}
	/**
	* Encrypts a file with the provided key
	* @return Returns the URI of the decrypted file. Resolves to an exception if the encryption failed.
	*/
	aesEncryptFile(key, fileUrl) {
		const iv = this.random.generateRandomData(IV_BYTE_LENGTH);
		const encodedKey = keyToUint8Array(key);
		return this.nativeCryptoFacade.aesEncryptFile(encodedKey, fileUrl, iv);
	}
	/**
	* Decrypt bytes with the provided key
	* @return Returns the URI of the decrypted file. Resolves to an exception if the encryption failed.
	*/
	aesDecryptFile(key, fileUrl) {
		const encodedKey = keyToUint8Array(key);
		return this.nativeCryptoFacade.aesDecryptFile(encodedKey, fileUrl);
	}
};

//#endregion
//#region ../src/common/native/common/generatedipc/NativeCryptoFacadeSendDispatcher.ts
var NativeCryptoFacadeSendDispatcher = class {
	constructor(transport) {
		this.transport = transport;
	}
	async rsaEncrypt(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"rsaEncrypt",
			...args
		]);
	}
	async rsaDecrypt(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"rsaDecrypt",
			...args
		]);
	}
	async aesEncryptFile(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"aesEncryptFile",
			...args
		]);
	}
	async aesDecryptFile(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"aesDecryptFile",
			...args
		]);
	}
	async argon2idGeneratePassphraseKey(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"argon2idGeneratePassphraseKey",
			...args
		]);
	}
	async generateKyberKeypair(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"generateKyberKeypair",
			...args
		]);
	}
	async kyberEncapsulate(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"kyberEncapsulate",
			...args
		]);
	}
	async kyberDecapsulate(...args) {
		return this.transport.invokeNative("ipc", [
			"NativeCryptoFacade",
			"kyberDecapsulate",
			...args
		]);
	}
};

//#endregion
//#region ../src/common/api/worker/crypto/RsaImplementation.ts
async function createRsaImplementation(native) {
	if (isApp()) {
		const { RsaApp } = await import("./RsaApp-BXy_tFBC.js");
		return new RsaApp(new NativeCryptoFacadeSendDispatcher(native), random);
	} else return new RsaWeb();
}
var RsaWeb = class {
	async encrypt(publicKey, bytes) {
		const seed = random.generateRandomData(32);
		return rsaEncrypt(publicKey, bytes, seed);
	}
	async decrypt(privateKey, bytes) {
		return rsaDecrypt(privateKey, bytes);
	}
};

//#endregion
//#region ../src/common/api/worker/crypto/AsymmetricCryptoFacade.ts
assertWorkerOrNode();
var AsymmetricCryptoFacade = class {
	constructor(rsa, pqFacade, keyLoaderFacade, cryptoWrapper, serviceExecutor) {
		this.rsa = rsa;
		this.pqFacade = pqFacade;
		this.keyLoaderFacade = keyLoaderFacade;
		this.cryptoWrapper = cryptoWrapper;
		this.serviceExecutor = serviceExecutor;
	}
	/**
	* Verifies whether the key that the public key service returns is the same as the one used for encryption.
	* When we have key verification we should stop verifying against the PublicKeyService but against the verified key.
	*
	* @param identifier the identifier to load the public key to verify that it matches the one used in the protocol run.
	* @param senderIdentityPubKey the senderIdentityPubKey that was used to encrypt/authenticate the data.
	* @param senderKeyVersion the version of the senderIdentityPubKey.
	*/
	async authenticateSender(identifier, senderIdentityPubKey, senderKeyVersion) {
		const keyData = createPublicKeyGetIn({
			identifier: identifier.identifier,
			identifierType: identifier.identifierType,
			version: senderKeyVersion.toString()
		});
		const publicKeyGetOut = await this.serviceExecutor.get(PublicKeyService, keyData);
		return publicKeyGetOut.pubEccKey != null && arrayEquals(publicKeyGetOut.pubEccKey, senderIdentityPubKey) ? EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED : EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED;
	}
	/**
	* Decrypts the pubEncSymKey with the recipientKeyPair and authenticates it if the protocol supports authentication.
	* If the protocol does not support authentication this method will only decrypt.
	* @param recipientKeyPair the recipientKeyPair. Must match the cryptoProtocolVersion and must be of the required recipientKeyVersion.
	* @param pubEncKeyData the encrypted symKey with the metadata (versions, group identifier etc.) for decryption and authentication.
	* @param senderIdentifier the identifier for the sender's key group
	* @throws CryptoError in case the authentication fails.
	*/
	async decryptSymKeyWithKeyPairAndAuthenticate(recipientKeyPair, pubEncKeyData, senderIdentifier) {
		const cryptoProtocolVersion = asCryptoProtoocolVersion(pubEncKeyData.protocolVersion);
		const decapsulatedAesKey = await this.decryptSymKeyWithKeyPair(recipientKeyPair, cryptoProtocolVersion, pubEncKeyData.pubEncSymKey);
		if (cryptoProtocolVersion === CryptoProtocolVersion.TUTA_CRYPT) {
			const encryptionAuthStatus = await this.authenticateSender(senderIdentifier, assertNotNull(decapsulatedAesKey.senderIdentityPubKey), Number(assertNotNull(pubEncKeyData.senderKeyVersion)));
			if (encryptionAuthStatus !== EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED) throw new CryptoError("the provided public key could not be authenticated");
		}
		return decapsulatedAesKey;
	}
	/**
	* Decrypts the pubEncSymKey with the recipientKeyPair.
	* @param pubEncSymKey the asymmetrically encrypted session key
	* @param cryptoProtocolVersion asymmetric protocol to decrypt pubEncSymKey (RSA or TutaCrypt)
	* @param recipientKeyPair the recipientKeyPair. Must match the cryptoProtocolVersion.
	*/
	async decryptSymKeyWithKeyPair(recipientKeyPair, cryptoProtocolVersion, pubEncSymKey) {
		switch (cryptoProtocolVersion) {
			case CryptoProtocolVersion.RSA: {
				if (!isRsaOrRsaEccKeyPair(recipientKeyPair)) throw new CryptoError("wrong key type. expected rsa. got " + recipientKeyPair.keyPairType);
				const privateKey = recipientKeyPair.privateKey;
				const decryptedSymKey = await this.rsa.decrypt(privateKey, pubEncSymKey);
				return {
					decryptedAesKey: uint8ArrayToBitArray(decryptedSymKey),
					senderIdentityPubKey: null
				};
			}
			case CryptoProtocolVersion.TUTA_CRYPT: {
				if (!isPqKeyPairs(recipientKeyPair)) throw new CryptoError("wrong key type. expected TutaCrypt. got " + recipientKeyPair.keyPairType);
				const { decryptedSymKeyBytes, senderIdentityPubKey } = await this.pqFacade.decapsulateEncoded(pubEncSymKey, recipientKeyPair);
				return {
					decryptedAesKey: uint8ArrayToBitArray(decryptedSymKeyBytes),
					senderIdentityPubKey
				};
			}
			default: throw new CryptoError("invalid cryptoProtocolVersion: " + cryptoProtocolVersion);
		}
	}
	/**
	* Loads the recipient key pair in the required version and decrypts the pubEncSymKey with it.
	*/
	async loadKeyPairAndDecryptSymKey(recipientKeyPairGroupId, recipientKeyVersion, cryptoProtocolVersion, pubEncSymKey) {
		const keyPair = await this.keyLoaderFacade.loadKeypair(recipientKeyPairGroupId, recipientKeyVersion);
		return await this.decryptSymKeyWithKeyPair(keyPair, cryptoProtocolVersion, pubEncSymKey);
	}
	/**
	* Encrypts the symKey asymmetrically with the provided public keys.
	* @param symKey the symmetric key  to be encrypted
	* @param recipientPublicKeys the public key(s) of the recipient in the current version
	* @param senderGroupId the group id of the sender. will only be used in case we also need the sender's key pair, e.g. with TutaCrypt.
	*/
	async asymEncryptSymKey(symKey, recipientPublicKeys, senderGroupId) {
		const recipientPublicKey = this.extractRecipientPublicKey(recipientPublicKeys.object);
		const keyPairType = recipientPublicKey.keyPairType;
		if (isPqPublicKey(recipientPublicKey)) {
			const senderKeyPair = await this.keyLoaderFacade.loadCurrentKeyPair(senderGroupId);
			const senderEccKeyPair = await this.getOrMakeSenderIdentityKeyPair(senderKeyPair.object, senderGroupId);
			return this.tutaCryptEncryptSymKeyImpl({
				object: recipientPublicKey,
				version: recipientPublicKeys.version
			}, symKey, {
				object: senderEccKeyPair,
				version: senderKeyPair.version
			});
		} else if (isRsaPublicKey(recipientPublicKey)) {
			const pubEncSymKeyBytes = await this.rsa.encrypt(recipientPublicKey, bitArrayToUint8Array(symKey));
			return {
				pubEncSymKeyBytes,
				cryptoProtocolVersion: CryptoProtocolVersion.RSA,
				senderKeyVersion: null,
				recipientKeyVersion: recipientPublicKeys.version
			};
		}
		throw new CryptoError("unknown public key type: " + keyPairType);
	}
	/**
	* Encrypts the symKey asymmetrically with the provided public keys using the TutaCrypt protocol.
	* @param symKey the key to be encrypted
	* @param recipientPublicKeys MUST be a pq key pair
	* @param senderEccKeyPair the sender's key pair (needed for authentication)
	* @throws ProgrammingError if the recipientPublicKeys are not suitable for TutaCrypt
	*/
	async tutaCryptEncryptSymKey(symKey, recipientPublicKeys, senderEccKeyPair) {
		const recipientPublicKey = this.extractRecipientPublicKey(recipientPublicKeys.object);
		if (!isPqPublicKey(recipientPublicKey)) throw new ProgrammingError("the recipient does not have pq key pairs");
		return this.tutaCryptEncryptSymKeyImpl({
			object: recipientPublicKey,
			version: recipientPublicKeys.version
		}, symKey, senderEccKeyPair);
	}
	async tutaCryptEncryptSymKeyImpl(recipientPublicKey, symKey, senderEccKeyPair) {
		const ephemeralKeyPair = this.cryptoWrapper.generateEccKeyPair();
		const pubEncSymKeyBytes = await this.pqFacade.encapsulateAndEncode(senderEccKeyPair.object, ephemeralKeyPair, recipientPublicKey.object, bitArrayToUint8Array(symKey));
		const senderKeyVersion = senderEccKeyPair.version;
		return {
			pubEncSymKeyBytes,
			cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT,
			senderKeyVersion,
			recipientKeyVersion: recipientPublicKey.version
		};
	}
	extractRecipientPublicKey(publicKeys) {
		if (publicKeys.pubRsaKey) return hexToRsaPublicKey(uint8ArrayToHex(publicKeys.pubRsaKey));
else if (publicKeys.pubKyberKey && publicKeys.pubEccKey) {
			const eccPublicKey = publicKeys.pubEccKey;
			const kyberPublicKey = this.cryptoWrapper.bytesToKyberPublicKey(publicKeys.pubKyberKey);
			return {
				keyPairType: KeyPairType.TUTA_CRYPT,
				eccPublicKey,
				kyberPublicKey
			};
		} else throw new Error("Inconsistent Keypair");
	}
	/**
	* Returns the SenderIdentityKeyPair that is either already on the KeyPair that is being passed in,
	* or creates a new one and writes it to the respective Group.
	* @param senderKeyPair
	* @param keyGroupId Id for the Group that Public Key Service might write a new IdentityKeyPair for.
	* 						This is necessary as a User might send an E-Mail from a shared mailbox,
	* 						for which the KeyPair should be created.
	*/
	async getOrMakeSenderIdentityKeyPair(senderKeyPair, keyGroupId) {
		const algo = senderKeyPair.keyPairType;
		if (isPqKeyPairs(senderKeyPair)) return senderKeyPair.eccKeyPair;
else if (isRsaEccKeyPair(senderKeyPair)) return {
			publicKey: senderKeyPair.publicEccKey,
			privateKey: senderKeyPair.privateEccKey
		};
else if (isRsaOrRsaEccKeyPair(senderKeyPair)) {
			const symGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(keyGroupId);
			const newIdentityKeyPair = this.cryptoWrapper.generateEccKeyPair();
			const symEncPrivEccKey = this.cryptoWrapper.encryptEccKey(symGroupKey.object, newIdentityKeyPair.privateKey);
			const data = createPublicKeyPutIn({
				pubEccKey: newIdentityKeyPair.publicKey,
				symEncPrivEccKey,
				keyGroup: keyGroupId
			});
			await this.serviceExecutor.put(PublicKeyService, data);
			return newIdentityKeyPair;
		} else throw new CryptoError("unknown key pair type: " + algo);
	}
};
function convertToVersionedPublicKeys(publicKeyGetOut) {
	return {
		object: {
			pubRsaKey: publicKeyGetOut.pubRsaKey,
			pubKyberKey: publicKeyGetOut.pubKyberKey,
			pubEccKey: publicKeyGetOut.pubEccKey
		},
		version: Number(publicKeyGetOut.pubKeyVersion)
	};
}

//#endregion
//#region ../src/common/api/worker/crypto/CryptoFacade.ts
assertWorkerOrNode();
var CryptoFacade = class {
	constructor(userFacade, entityClient, restClient, serviceExecutor, instanceMapper, ownerEncSessionKeysUpdateQueue, cache, keyLoaderFacade, asymmetricCryptoFacade) {
		this.userFacade = userFacade;
		this.entityClient = entityClient;
		this.restClient = restClient;
		this.serviceExecutor = serviceExecutor;
		this.instanceMapper = instanceMapper;
		this.ownerEncSessionKeysUpdateQueue = ownerEncSessionKeysUpdateQueue;
		this.cache = cache;
		this.keyLoaderFacade = keyLoaderFacade;
		this.asymmetricCryptoFacade = asymmetricCryptoFacade;
	}
	async applyMigrationsForInstance(decryptedInstance) {
		const instanceType = downcast(decryptedInstance)._type;
		if (isSameTypeRef(instanceType, ContactTypeRef)) {
			const contact = downcast(decryptedInstance);
			try {
				if (!contact.birthdayIso && contact.oldBirthdayAggregate) {
					contact.birthdayIso = birthdayToIsoDate(contact.oldBirthdayAggregate);
					contact.oldBirthdayAggregate = null;
					contact.oldBirthdayDate = null;
					await this.entityClient.update(contact);
				} else if (!contact.birthdayIso && contact.oldBirthdayDate) {
					contact.birthdayIso = birthdayToIsoDate(oldBirthdayToBirthday(contact.oldBirthdayDate));
					contact.oldBirthdayDate = null;
					await this.entityClient.update(contact);
				} else if (contact.birthdayIso && (contact.oldBirthdayAggregate || contact.oldBirthdayDate)) {
					contact.oldBirthdayAggregate = null;
					contact.oldBirthdayDate = null;
					await this.entityClient.update(contact);
				}
			} catch (e) {
				if (!(e instanceof LockedError)) throw e;
			}
		}
		return decryptedInstance;
	}
	async resolveSessionKeyForInstance(instance) {
		const typeModel = await resolveTypeReference(instance._type);
		return this.resolveSessionKey(typeModel, instance);
	}
	/** Helper for the rare cases when we needed it on the client side. */
	async resolveSessionKeyForInstanceBinary(instance) {
		const key = await this.resolveSessionKeyForInstance(instance);
		return key == null ? null : bitArrayToUint8Array(key);
	}
	/** Resolve a session key an {@param instance} using an already known {@param ownerKey}. */
	resolveSessionKeyWithOwnerKey(instance, ownerKey) {
		let key = instance._ownerEncSessionKey;
		if (typeof key === "string") key = base64ToUint8Array(key);
		return decryptKey(ownerKey, key);
	}
	async decryptSessionKey(instance, ownerEncSessionKey) {
		const gk = await this.keyLoaderFacade.loadSymGroupKey(instance._ownerGroup, ownerEncSessionKey.encryptingKeyVersion);
		return decryptKey(gk, ownerEncSessionKey.key);
	}
	/**
	* Returns the session key for the provided type/instance:
	* * null, if the instance is unencrypted
	* * the decrypted _ownerEncSessionKey, if it is available
	* * the public decrypted session key, otherwise
	*
	* @param typeModel the type model of the instance
	* @param instance The unencrypted (client-side) instance or encrypted (server-side) object literal
	*/
	async resolveSessionKey(typeModel, instance) {
		try {
			if (!typeModel.encrypted) return null;
			if (instance.bucketKey) {
				const bucketKey = await this.convertBucketKeyToInstanceIfNecessary(instance.bucketKey);
				const resolvedSessionKeys = await this.resolveWithBucketKey(bucketKey, instance, typeModel);
				return resolvedSessionKeys.resolvedSessionKeyForInstance;
			} else if (instance._ownerEncSessionKey && this.userFacade.isFullyLoggedIn() && this.userFacade.hasGroup(instance._ownerGroup)) {
				const gk = await this.keyLoaderFacade.loadSymGroupKey(instance._ownerGroup, Number(instance._ownerKeyVersion ?? 0));
				return this.resolveSessionKeyWithOwnerKey(instance, gk);
			} else if (instance.ownerEncSessionKey) {
				const gk = await this.keyLoaderFacade.loadSymGroupKey(this.userFacade.getGroupId(GroupType.Mail), Number(instance.ownerKeyVersion ?? 0));
				return this.resolveSessionKeyWithOwnerKey(instance, gk);
			} else {
				const permissions = await this.entityClient.loadAll(PermissionTypeRef, instance._permissions);
				return await this.trySymmetricPermission(permissions) ?? await this.resolveWithPublicOrExternalPermission(permissions, instance, typeModel);
			}
		} catch (e) {
			if (e instanceof CryptoError) {
				console.log("failed to resolve session key", e);
				throw new SessionKeyNotFoundError("Crypto error while resolving session key for instance " + instance._id);
			} else throw e;
		}
	}
	/**
	* Takes a freshly JSON-parsed, unmapped object and apply migrations as necessary
	* @param typeRef
	* @param data
	* @return the unmapped and still encrypted instance
	*/
	async applyMigrations(typeRef, data) {
		if (isSameTypeRef(typeRef, GroupInfoTypeRef) && data._ownerGroup == null) return this.applyCustomerGroupOwnershipToGroupInfo(data);
else if (isSameTypeRef(typeRef, TutanotaPropertiesTypeRef) && data._ownerEncSessionKey == null) return this.encryptTutanotaProperties(data);
else if (isSameTypeRef(typeRef, PushIdentifierTypeRef) && data._ownerEncSessionKey == null) return this.addSessionKeyToPushIdentifier(data);
else return data;
	}
	/**
	* In case the given bucketKey is a literal the literal will be converted to an instance and return. In case the BucketKey is already an instance the
	* instance is returned.
	* @param bucketKeyInstanceOrLiteral The bucket key as literal or instance
	*/
	async convertBucketKeyToInstanceIfNecessary(bucketKeyInstanceOrLiteral) {
		if (this.isLiteralInstance(bucketKeyInstanceOrLiteral)) {
			const bucketKeyTypeModel = await resolveTypeReference(BucketKeyTypeRef);
			return await this.instanceMapper.decryptAndMapToInstance(bucketKeyTypeModel, bucketKeyInstanceOrLiteral, null);
		} else return bucketKeyInstanceOrLiteral;
	}
	async resolveWithBucketKey(bucketKey, instance, typeModel) {
		const instanceElementId = this.getElementIdFromInstance(instance);
		let decryptedBucketKey;
		let unencryptedSenderAuthStatus = null;
		let pqMessageSenderKey = null;
		if (bucketKey.keyGroup && bucketKey.pubEncBucketKey) {
			const { decryptedAesKey, senderIdentityPubKey } = await this.asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(bucketKey.keyGroup, Number(bucketKey.recipientKeyVersion), asCryptoProtoocolVersion(bucketKey.protocolVersion), bucketKey.pubEncBucketKey);
			decryptedBucketKey = decryptedAesKey;
			pqMessageSenderKey = senderIdentityPubKey;
		} else if (bucketKey.groupEncBucketKey) {
			let keyGroup;
			const groupKeyVersion = Number(bucketKey.recipientKeyVersion);
			if (bucketKey.keyGroup) keyGroup = bucketKey.keyGroup;
else keyGroup = neverNull(instance._ownerGroup);
			decryptedBucketKey = await this.resolveWithGroupReference(keyGroup, groupKeyVersion, bucketKey.groupEncBucketKey);
			unencryptedSenderAuthStatus = EncryptionAuthStatus.AES_NO_AUTHENTICATION;
		} else throw new SessionKeyNotFoundError(`encrypted bucket key not set on instance ${typeModel.name}`);
		const resolvedSessionKeys = await this.collectAllInstanceSessionKeysAndAuthenticate(bucketKey, decryptedBucketKey, instanceElementId, instance, typeModel, unencryptedSenderAuthStatus, pqMessageSenderKey);
		await this.ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(resolvedSessionKeys.instanceSessionKeys, typeModel);
		const groupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(instance._ownerGroup);
		this.setOwnerEncSessionKeyUnmapped(instance, encryptKeyWithVersionedKey(groupKey, resolvedSessionKeys.resolvedSessionKeyForInstance));
		return resolvedSessionKeys;
	}
	/**
	* Calculates the SHA-256 checksum of a string value as UTF-8 bytes and returns it as a base64-encoded string
	*/
	async sha256(value) {
		return uint8ArrayToBase64(sha256Hash(stringToUtf8Uint8Array(value)));
	}
	/**
	* Decrypts the given encrypted bucket key with the group key of the given group. In case the current user is not
	* member of the key group the function tries to resolve the group key using the adminEncGroupKey.
	* This is necessary for resolving the BucketKey when receiving a reply from an external Mailbox.
	* @param keyGroup The group that holds the encryption key.
	* @param groupKeyVersion the version of the key from the keyGroup
	* @param groupEncBucketKey The group key encrypted bucket key.
	*/
	async resolveWithGroupReference(keyGroup, groupKeyVersion, groupEncBucketKey) {
		if (this.userFacade.hasGroup(keyGroup)) {
			const groupKey = await this.keyLoaderFacade.loadSymGroupKey(keyGroup, groupKeyVersion);
			return decryptKey(groupKey, groupEncBucketKey);
		} else {
			const externalMailGroupId = keyGroup;
			const externalMailGroupKeyVersion = groupKeyVersion;
			const externalMailGroup = await this.entityClient.load(GroupTypeRef, externalMailGroupId);
			const externalUserGroupdId = externalMailGroup.admin;
			if (!externalUserGroupdId) throw new SessionKeyNotFoundError("no admin group on key group: " + externalMailGroupId);
			const externalUserGroupKeyVersion = Number(externalMailGroup.adminGroupKeyVersion ?? 0);
			const externalUserGroup = await this.entityClient.load(GroupTypeRef, externalUserGroupdId);
			const internalUserGroupId = externalUserGroup.admin;
			const internalUserGroupKeyVersion = Number(externalUserGroup.adminGroupKeyVersion ?? 0);
			if (!(internalUserGroupId && this.userFacade.hasGroup(internalUserGroupId))) throw new SessionKeyNotFoundError("no admin group or no membership of admin group: " + internalUserGroupId);
			const internalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(internalUserGroupId, internalUserGroupKeyVersion);
			const currentExternalUserGroupKey = decryptKey(internalUserGroupKey, assertNotNull(externalUserGroup.adminGroupEncGKey));
			const externalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(externalUserGroupdId, externalUserGroupKeyVersion, {
				object: currentExternalUserGroupKey,
				version: Number(externalUserGroup.groupKeyVersion)
			});
			const currentExternalMailGroupKey = decryptKey(externalUserGroupKey, assertNotNull(externalMailGroup.adminGroupEncGKey));
			const externalMailGroupKey = await this.keyLoaderFacade.loadSymGroupKey(externalMailGroupId, externalMailGroupKeyVersion, {
				object: currentExternalMailGroupKey,
				version: Number(externalMailGroup.groupKeyVersion)
			});
			return decryptKey(externalMailGroupKey, groupEncBucketKey);
		}
	}
	async addSessionKeyToPushIdentifier(data) {
		const userGroupKey = this.userFacade.getCurrentUserGroupKey();
		const typeModel = await resolveTypeReference(PushIdentifierTypeRef);
		await this.updateOwnerEncSessionKey(typeModel, data, userGroupKey, aes256RandomKey());
		return data;
	}
	async encryptTutanotaProperties(data) {
		const userGroupKey = this.userFacade.getCurrentUserGroupKey();
		const groupEncSessionKey = encryptKeyWithVersionedKey(userGroupKey, aes256RandomKey());
		this.setOwnerEncSessionKeyUnmapped(data, groupEncSessionKey, this.userFacade.getUserGroupId());
		const migrationData = createEncryptTutanotaPropertiesData({
			properties: data._id,
			symKeyVersion: String(groupEncSessionKey.encryptingKeyVersion),
			symEncSessionKey: groupEncSessionKey.key
		});
		await this.serviceExecutor.post(EncryptTutanotaPropertiesService, migrationData);
		return data;
	}
	async applyCustomerGroupOwnershipToGroupInfo(data) {
		const customerGroupMembership = assertNotNull(this.userFacade.getLoggedInUser().memberships.find((g) => g.groupType === GroupType.Customer));
		const listPermissions = await this.entityClient.loadAll(PermissionTypeRef, data._id[0]);
		const customerGroupPermission = listPermissions.find((p) => p.group === customerGroupMembership.group);
		if (!customerGroupPermission) throw new SessionKeyNotFoundError("Permission not found, could not apply OwnerGroup migration");
		const customerGroupKeyVersion = Number(customerGroupPermission.symKeyVersion ?? 0);
		const customerGroupKey = await this.keyLoaderFacade.loadSymGroupKey(customerGroupMembership.group, customerGroupKeyVersion);
		const versionedCustomerGroupKey = {
			object: customerGroupKey,
			version: customerGroupKeyVersion
		};
		const listKey = decryptKey(customerGroupKey, assertNotNull(customerGroupPermission.symEncSessionKey));
		const groupInfoSk = decryptKey(listKey, base64ToUint8Array(data._listEncSessionKey));
		this.setOwnerEncSessionKeyUnmapped(data, encryptKeyWithVersionedKey(versionedCustomerGroupKey, groupInfoSk), customerGroupMembership.group);
		return data;
	}
	setOwnerEncSessionKeyUnmapped(unmappedInstance, key, ownerGroup) {
		unmappedInstance._ownerEncSessionKey = uint8ArrayToBase64(key.key);
		unmappedInstance._ownerKeyVersion = key.encryptingKeyVersion.toString();
		if (ownerGroup) unmappedInstance._ownerGroup = ownerGroup;
	}
	setOwnerEncSessionKey(instance, key) {
		instance._ownerEncSessionKey = key.key;
		instance._ownerKeyVersion = key.encryptingKeyVersion.toString();
	}
	/**
	* @return Whether the {@param elementOrLiteral} is a unmapped type, as used in JSON for transport or if it's a runtime representation of a type.
	*/
	isLiteralInstance(elementOrLiteral) {
		return typeof elementOrLiteral._type === "undefined";
	}
	async trySymmetricPermission(listPermissions) {
		const symmetricPermission = listPermissions.find((p) => (p.type === PermissionType.Public_Symmetric || p.type === PermissionType.Symmetric) && p._ownerGroup && this.userFacade.hasGroup(p._ownerGroup)) ?? null;
		if (symmetricPermission) {
			const gk = await this.keyLoaderFacade.loadSymGroupKey(assertNotNull(symmetricPermission._ownerGroup), Number(symmetricPermission._ownerKeyVersion ?? 0));
			return decryptKey(gk, assertNotNull(symmetricPermission._ownerEncSessionKey));
		} else return null;
	}
	/**
	* Resolves the session key for the provided instance and collects all other instances'
	* session keys in order to update them.
	*/
	async collectAllInstanceSessionKeysAndAuthenticate(bucketKey, decBucketKey, instanceElementId, instance, typeModel, encryptionAuthStatus, pqMessageSenderKey) {
		let resolvedSessionKeyForInstance = undefined;
		const instanceSessionKeys = await pMap(bucketKey.bucketEncSessionKeys, async (instanceSessionKey) => {
			const decryptedSessionKey = decryptKey(decBucketKey, instanceSessionKey.symEncSessionKey);
			const groupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(instance._ownerGroup);
			const ownerEncSessionKey = encryptKeyWithVersionedKey(groupKey, decryptedSessionKey);
			const instanceSessionKeyWithOwnerEncSessionKey = createInstanceSessionKey(instanceSessionKey);
			if (instanceElementId == instanceSessionKey.instanceId) {
				resolvedSessionKeyForInstance = decryptedSessionKey;
				await this.authenticateMainInstance(typeModel, encryptionAuthStatus, pqMessageSenderKey, bucketKey.protocolVersion === CryptoProtocolVersion.TUTA_CRYPT ? Number(bucketKey.senderKeyVersion ?? 0) : null, instance, resolvedSessionKeyForInstance, instanceSessionKeyWithOwnerEncSessionKey, decryptedSessionKey);
			}
			instanceSessionKeyWithOwnerEncSessionKey.symEncSessionKey = ownerEncSessionKey.key;
			instanceSessionKeyWithOwnerEncSessionKey.symKeyVersion = String(ownerEncSessionKey.encryptingKeyVersion);
			return instanceSessionKeyWithOwnerEncSessionKey;
		});
		if (resolvedSessionKeyForInstance) return {
			resolvedSessionKeyForInstance,
			instanceSessionKeys
		};
else throw new SessionKeyNotFoundError("no session key for instance " + instance._id);
	}
	async authenticateMainInstance(typeModel, encryptionAuthStatus, pqMessageSenderKey, pqMessageSenderKeyVersion, instance, resolvedSessionKeyForInstance, instanceSessionKeyWithOwnerEncSessionKey, decryptedSessionKey) {
		const isMailInstance = isSameTypeRefByAttr(MailTypeRef, typeModel.app, typeModel.name);
		if (isMailInstance) {
			if (!encryptionAuthStatus) if (!pqMessageSenderKey) encryptionAuthStatus = EncryptionAuthStatus.RSA_NO_AUTHENTICATION;
else {
				const mail = this.isLiteralInstance(instance) ? await this.instanceMapper.decryptAndMapToInstance(typeModel, instance, resolvedSessionKeyForInstance) : instance;
				const senderMailAddress = mail.confidential ? mail.sender.address : SYSTEM_GROUP_MAIL_ADDRESS;
				encryptionAuthStatus = await this.tryAuthenticateSenderOfMainInstance(senderMailAddress, pqMessageSenderKey, pqMessageSenderKeyVersion);
			}
			instanceSessionKeyWithOwnerEncSessionKey.encryptionAuthStatus = aesEncrypt(decryptedSessionKey, stringToUtf8Uint8Array(encryptionAuthStatus));
		}
	}
	async tryAuthenticateSenderOfMainInstance(senderMailAddress, pqMessageSenderKey, pqMessageSenderKeyVersion) {
		try {
			return await this.asymmetricCryptoFacade.authenticateSender({
				identifier: senderMailAddress,
				identifierType: PublicKeyIdentifierType.MAIL_ADDRESS
			}, pqMessageSenderKey, assertNotNull(pqMessageSenderKeyVersion));
		} catch (e) {
			console.error("Could not authenticate sender", e);
			return EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED;
		}
	}
	async resolveWithPublicOrExternalPermission(listPermissions, instance, typeModel) {
		const pubOrExtPermission = listPermissions.find((p) => p.type === PermissionType.Public || p.type === PermissionType.External) ?? null;
		if (pubOrExtPermission == null) {
			const typeName = `${typeModel.app}/${typeModel.name}`;
			throw new SessionKeyNotFoundError(`could not find permission for instance of type ${typeName} with id ${this.getElementIdFromInstance(instance)}`);
		}
		const bucketPermissions = await this.entityClient.loadAll(BucketPermissionTypeRef, assertNotNull(pubOrExtPermission.bucket).bucketPermissions);
		const bucketPermission = bucketPermissions.find((bp) => (bp.type === BucketPermissionType.Public || bp.type === BucketPermissionType.External) && pubOrExtPermission._ownerGroup === bp._ownerGroup);
		if (bucketPermission == null) throw new SessionKeyNotFoundError("no corresponding bucket permission found");
		if (bucketPermission.type === BucketPermissionType.External) return this.decryptWithExternalBucket(bucketPermission, pubOrExtPermission, instance);
else return this.decryptWithPublicBucketWithoutAuthentication(bucketPermission, instance, pubOrExtPermission, typeModel);
	}
	async decryptWithExternalBucket(bucketPermission, pubOrExtPermission, instance) {
		let bucketKey;
		if (bucketPermission.ownerEncBucketKey != null) {
			const ownerGroupKey = await this.keyLoaderFacade.loadSymGroupKey(neverNull(bucketPermission._ownerGroup), Number(bucketPermission.ownerKeyVersion ?? 0));
			bucketKey = decryptKey(ownerGroupKey, bucketPermission.ownerEncBucketKey);
		} else if (bucketPermission.symEncBucketKey) {
			const userGroupKey = await this.keyLoaderFacade.loadSymUserGroupKey(Number(bucketPermission.symKeyVersion ?? 0));
			bucketKey = decryptKey(userGroupKey, bucketPermission.symEncBucketKey);
		} else throw new SessionKeyNotFoundError(`BucketEncSessionKey is not defined for Permission ${pubOrExtPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`);
		return decryptKey(bucketKey, neverNull(pubOrExtPermission.bucketEncSessionKey));
	}
	async decryptWithPublicBucketWithoutAuthentication(bucketPermission, instance, pubOrExtPermission, typeModel) {
		const pubEncBucketKey = bucketPermission.pubEncBucketKey;
		if (pubEncBucketKey == null) throw new SessionKeyNotFoundError(`PubEncBucketKey is not defined for BucketPermission ${bucketPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`);
		const bucketEncSessionKey = pubOrExtPermission.bucketEncSessionKey;
		if (bucketEncSessionKey == null) throw new SessionKeyNotFoundError(`BucketEncSessionKey is not defined for Permission ${pubOrExtPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`);
		const { decryptedAesKey } = await this.asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(bucketPermission.group, Number(bucketPermission.pubKeyVersion ?? 0), asCryptoProtoocolVersion(bucketPermission.protocolVersion), pubEncBucketKey);
		const sk = decryptKey(decryptedAesKey, bucketEncSessionKey);
		if (bucketPermission._ownerGroup) {
			let bucketPermissionOwnerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(neverNull(bucketPermission._ownerGroup));
			await this.updateWithSymPermissionKey(typeModel, instance, pubOrExtPermission, bucketPermission, bucketPermissionOwnerGroupKey, sk).catch(ofClass(NotFoundError, () => {
				console.log("w> could not find instance to update permission");
			}));
		}
		return sk;
	}
	/**
	* Returns the session key for the provided service response:
	* * null, if the instance is unencrypted
	* * the decrypted _ownerPublicEncSessionKey, if it is available
	* @param instance The unencrypted (client-side) or encrypted (server-side) instance
	*
	*/
	async resolveServiceSessionKey(instance) {
		if (instance._ownerPublicEncSessionKey) {
			const keypair = await this.keyLoaderFacade.loadCurrentKeyPair(instance._ownerGroup);
			return (await this.asymmetricCryptoFacade.decryptSymKeyWithKeyPair(keypair.object, assertEnumValue(CryptoProtocolVersion, instance._publicCryptoProtocolVersion), base64ToUint8Array(instance._ownerPublicEncSessionKey))).decryptedAesKey;
		}
		return null;
	}
	/**
	* Creates a new _ownerEncSessionKey and assigns it to the provided entity
	* the entity must already have an _ownerGroup
	* @returns the generated key
	*/
	async setNewOwnerEncSessionKey(model, entity, keyToEncryptSessionKey) {
		if (!entity._ownerGroup) throw new Error(`no owner group set  ${JSON.stringify(entity)}`);
		if (model.encrypted) {
			if (entity._ownerEncSessionKey) throw new Error(`ownerEncSessionKey already set ${JSON.stringify(entity)}`);
			const sessionKey = aes256RandomKey();
			const effectiveKeyToEncryptSessionKey = keyToEncryptSessionKey ?? await this.keyLoaderFacade.getCurrentSymGroupKey(entity._ownerGroup);
			const encryptedSessionKey = encryptKeyWithVersionedKey(effectiveKeyToEncryptSessionKey, sessionKey);
			this.setOwnerEncSessionKey(entity, encryptedSessionKey);
			return sessionKey;
		} else return null;
	}
	async encryptBucketKeyForInternalRecipient(senderUserGroupId, bucketKey, recipientMailAddress, notFoundRecipients) {
		const keyData = createPublicKeyGetIn({
			identifier: recipientMailAddress,
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS,
			version: null
		});
		try {
			const publicKeyGetOut = await this.serviceExecutor.get(PublicKeyService, keyData);
			if (notFoundRecipients.length !== 0) return null;
			const isExternalSender = this.userFacade.getUser()?.accountType === AccountType.EXTERNAL;
			if (publicKeyGetOut.pubKyberKey && isExternalSender) return this.createSymEncInternalRecipientKeyData(recipientMailAddress, bucketKey);
else return this.createPubEncInternalRecipientKeyData(bucketKey, recipientMailAddress, publicKeyGetOut, senderUserGroupId);
		} catch (e) {
			if (e instanceof NotFoundError) {
				notFoundRecipients.push(recipientMailAddress);
				return null;
			} else if (e instanceof TooManyRequestsError) throw new RecipientNotResolvedError("");
else throw e;
		}
	}
	async createPubEncInternalRecipientKeyData(bucketKey, recipientMailAddress, publicKeyGetOut, senderGroupId) {
		const recipientPublicKeys = convertToVersionedPublicKeys(publicKeyGetOut);
		const pubEncBucketKey = await this.asymmetricCryptoFacade.asymEncryptSymKey(bucketKey, recipientPublicKeys, senderGroupId);
		return createInternalRecipientKeyData({
			mailAddress: recipientMailAddress,
			pubEncBucketKey: pubEncBucketKey.pubEncSymKeyBytes,
			recipientKeyVersion: pubEncBucketKey.recipientKeyVersion.toString(),
			senderKeyVersion: pubEncBucketKey.senderKeyVersion != null ? pubEncBucketKey.senderKeyVersion.toString() : null,
			protocolVersion: pubEncBucketKey.cryptoProtocolVersion
		});
	}
	async createSymEncInternalRecipientKeyData(recipientMailAddress, bucketKey) {
		const keyGroup = this.userFacade.getGroupId(GroupType.Mail);
		const externalMailGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(keyGroup);
		return createSymEncInternalRecipientKeyData({
			mailAddress: recipientMailAddress,
			symEncBucketKey: encryptKey(externalMailGroupKey.object, bucketKey),
			keyGroup,
			symKeyVersion: String(externalMailGroupKey.version)
		});
	}
	/**
	* Updates the given public permission with the given symmetric key for faster access if the client is the leader and otherwise does nothing.
	* @param typeModel The type model of the instance
	* @param instance The unencrypted (client-side) or encrypted (server-side) instance
	* @param permission The permission.
	* @param bucketPermission The bucket permission.
	* @param permissionOwnerGroupKey The symmetric group key for the owner group on the permission.
	* @param sessionKey The symmetric session key.
	*/
	async updateWithSymPermissionKey(typeModel, instance, permission, bucketPermission, permissionOwnerGroupKey, sessionKey) {
		if (!this.isLiteralInstance(instance) || !this.userFacade.isLeader()) return;
		if (!instance._ownerEncSessionKey && permission._ownerGroup === instance._ownerGroup) return this.updateOwnerEncSessionKey(typeModel, instance, permissionOwnerGroupKey, sessionKey);
else {
			const encryptedKey = encryptKeyWithVersionedKey(permissionOwnerGroupKey, sessionKey);
			let updateService = createUpdatePermissionKeyData({
				ownerKeyVersion: String(encryptedKey.encryptingKeyVersion),
				ownerEncSessionKey: encryptedKey.key,
				permission: permission._id,
				bucketPermission: bucketPermission._id
			});
			await this.serviceExecutor.post(UpdatePermissionKeyService, updateService);
		}
	}
	/**
	* Resolves the ownerEncSessionKey of a mail. This might be needed if it wasn't updated yet
	* by the OwnerEncSessionKeysUpdateQueue but the file is already downloaded.
	* @param mainInstance the instance that has the bucketKey
	* @param childInstances the files that belong to the mainInstance
	*/
	async enforceSessionKeyUpdateIfNeeded(mainInstance, childInstances) {
		if (!childInstances.some((f) => f._ownerEncSessionKey == null)) return childInstances.slice();
		const typeModel = await resolveTypeReference(mainInstance._type);
		const outOfSyncInstances = childInstances.filter((f) => f._ownerEncSessionKey == null);
		if (mainInstance.bucketKey) {
			const bucketKey = await this.convertBucketKeyToInstanceIfNecessary(mainInstance.bucketKey);
			const resolvedSessionKeys = await this.resolveWithBucketKey(bucketKey, mainInstance, typeModel);
			await this.ownerEncSessionKeysUpdateQueue.postUpdateSessionKeysService(resolvedSessionKeys.instanceSessionKeys);
		} else console.warn("files are out of sync refreshing", outOfSyncInstances.map((f) => f._id).join(", "));
		for (const childInstance of outOfSyncInstances) await this.cache?.deleteFromCacheIfExists(FileTypeRef, getListId(childInstance), getElementId(childInstance));
		return await this.entityClient.loadMultiple(FileTypeRef, getListId(childInstances[0]), childInstances.map((childInstance) => getElementId(childInstance)));
	}
	updateOwnerEncSessionKey(typeModel, instance, ownerGroupKey, sessionKey) {
		this.setOwnerEncSessionKeyUnmapped(instance, encryptKeyWithVersionedKey(ownerGroupKey, sessionKey));
		const path = typeRefToPath(new TypeRef(typeModel.app, typeModel.name)) + "/" + (instance._id instanceof Array ? instance._id.join("/") : instance._id);
		const headers = this.userFacade.createAuthHeaders();
		headers.v = typeModel.version;
		return this.restClient.request(path, HttpMethod.PUT, {
			headers,
			body: JSON.stringify(instance),
			queryParams: { updateOwnerEncSessionKey: "true" }
		}).catch(ofClass(PayloadTooLargeError, (e) => {
			console.log("Could not update owner enc session key - PayloadTooLargeError", e);
		}));
	}
	getElementIdFromInstance(instance) {
		if (typeof instance._id === "string") return instance._id;
else {
			const idTuple = instance._id;
			return elementIdPart(idTuple);
		}
	}
};
if (!("toJSON" in Error.prototype)) Object.defineProperty(Error.prototype, "toJSON", {
	value: function() {
		const alt = {};
		for (let key of Object.getOwnPropertyNames(this)) alt[key] = this[key];
		return alt;
	},
	configurable: true,
	writable: true
});

//#endregion
//#region ../src/common/api/worker/crypto/InstanceMapper.ts
assertWorkerOrNode();
var InstanceMapper = class {
	/**
	* Decrypts an object literal as received from the DB and maps it to an entity class (e.g. Mail)
	* @param model The TypeModel of the instance
	* @param instance The object literal as received from the DB
	* @param sk The session key, must be provided for encrypted instances
	* @returns The decrypted and mapped instance
	*/
	decryptAndMapToInstance(model, instance, sk) {
		let decrypted = { _type: new TypeRef(model.app, model.name) };
		for (let key of Object.keys(model.values)) {
			let valueType = model.values[key];
			let value = instance[key];
			try {
				decrypted[key] = decryptValue(key, valueType, value, sk);
			} catch (e) {
				if (decrypted._errors == null) decrypted._errors = {};
				decrypted._errors[key] = JSON.stringify(e);
				console.log("error when decrypting value on type:", `[${model.app},${model.name}]`, "key:", key, e);
			} finally {
				if (valueType.encrypted) {
					if (valueType.final) decrypted["_finalEncrypted_" + key] = value;
else if (value === "") decrypted["_defaultEncrypted_" + key] = decrypted[key];
				}
			}
		}
		return pMap(Object.keys(model.associations), async (associationName) => {
			if (model.associations[associationName].type === AssociationType.Aggregation) {
				const dependency = model.associations[associationName].dependency;
				const aggregateTypeModel = await resolveTypeReference(new TypeRef(dependency || model.app, model.associations[associationName].refType));
				let aggregation = model.associations[associationName];
				if (aggregation.cardinality === Cardinality.ZeroOrOne && instance[associationName] == null) decrypted[associationName] = null;
else if (instance[associationName] == null) throw new ProgrammingError(`Undefined aggregation ${model.name}:${associationName}`);
else if (aggregation.cardinality === Cardinality.Any) return pMap(instance[associationName], (aggregate) => {
					return this.decryptAndMapToInstance(aggregateTypeModel, downcast(aggregate), sk);
				}).then((decryptedAggregates) => {
					decrypted[associationName] = decryptedAggregates;
				});
else return this.decryptAndMapToInstance(aggregateTypeModel, instance[associationName], sk).then((decryptedAggregate) => {
					decrypted[associationName] = decryptedAggregate;
				});
			} else decrypted[associationName] = instance[associationName];
		}).then(() => {
			return decrypted;
		});
	}
	encryptAndMapToLiteral(model, instance, sk) {
		if (model.encrypted && sk == null) throw new ProgrammingError(`Encrypting ${model.app}/${model.name} requires a session key!`);
		let encrypted = {};
		let i = instance;
		for (let key of Object.keys(model.values)) {
			let valueType = model.values[key];
			let value = i[key];
			let encryptedValue;
			if (valueType.encrypted && valueType.final && i["_finalEncrypted_" + key] != null) encryptedValue = i["_finalEncrypted_" + key];
else if (valueType.encrypted && (i["_finalIvs"]?.[key])?.length === 0 && isDefaultValue(valueType.type, value)) encryptedValue = "";
else if (valueType.encrypted && valueType.final && i["_finalIvs"]?.[key] != null) {
				const finalIv = i["_finalIvs"][key];
				encryptedValue = encryptValue(key, valueType, value, sk, finalIv);
			} else if (valueType.encrypted && i["_defaultEncrypted_" + key] === value) encryptedValue = "";
else encryptedValue = encryptValue(key, valueType, value, sk);
			encrypted[key] = encryptedValue;
		}
		if (model.type === Type.Aggregated && !encrypted._id) encrypted._id = base64ToBase64Url(uint8ArrayToBase64(random.generateRandomData(4)));
		return pMap(Object.keys(model.associations), async (associationName) => {
			if (model.associations[associationName].type === AssociationType.Aggregation) {
				const dependency = model.associations[associationName].dependency;
				const aggregateTypeModel = await resolveTypeReference(new TypeRef(dependency || model.app, model.associations[associationName].refType));
				let aggregation = model.associations[associationName];
				if (aggregation.cardinality === Cardinality.ZeroOrOne && i[associationName] == null) encrypted[associationName] = null;
else if (i[associationName] == null) throw new ProgrammingError(`Undefined attribute ${model.name}:${associationName}`);
else if (aggregation.cardinality === Cardinality.Any) return pMap(i[associationName], (aggregate) => {
					return this.encryptAndMapToLiteral(aggregateTypeModel, aggregate, sk);
				}).then((encryptedAggregates) => {
					encrypted[associationName] = encryptedAggregates;
				});
else return this.encryptAndMapToLiteral(aggregateTypeModel, i[associationName], sk).then((encryptedAggregate) => {
					encrypted[associationName] = encryptedAggregate;
				});
			} else encrypted[associationName] = i[associationName];
		}).then(() => {
			return encrypted;
		});
	}
};
function encryptValue(valueName, valueType, value, sk, iv = random.generateRandomData(IV_BYTE_LENGTH)) {
	if (valueName === "_id" || valueName === "_permissions") return value;
else if (value == null) if (valueType.cardinality === Cardinality.ZeroOrOne) return null;
else throw new ProgrammingError(`Value ${valueName} with cardinality ONE can not be null`);
else if (valueType.encrypted) {
		let bytes = value;
		if (valueType.type !== ValueType.Bytes) {
			const dbType = assertNotNull(convertJsToDbType(valueType.type, value));
			bytes = typeof dbType === "string" ? stringToUtf8Uint8Array(dbType) : dbType;
		}
		return uint8ArrayToBase64(aesEncrypt(assertNotNull(sk), bytes, iv, true, ENABLE_MAC));
	} else {
		const dbType = convertJsToDbType(valueType.type, value);
		if (typeof dbType === "string") return dbType;
else return uint8ArrayToBase64(dbType);
	}
}
function decryptValue(valueName, valueType, value, sk) {
	if (value == null) if (valueType.cardinality === Cardinality.ZeroOrOne) return null;
else throw new ProgrammingError(`Value ${valueName} with cardinality ONE can not be null`);
else if (valueType.cardinality === Cardinality.One && value === "") return valueToDefault(valueType.type);
else if (valueType.encrypted) {
		if (sk == null) throw new CryptoError("session key is null, but value is encrypted. valueName: " + valueName + " valueType: " + valueType);
		let decryptedBytes = aesDecrypt(sk, base64ToUint8Array(value));
		if (valueType.type === ValueType.Bytes) return decryptedBytes;
else if (valueType.type === ValueType.CompressedString) return decompressString(decryptedBytes);
else return convertDbToJsType(valueType.type, utf8Uint8ArrayToString(decryptedBytes));
	} else return convertDbToJsType(valueType.type, value);
}
/**
* Returns bytes when the type === Bytes or type === CompressedString, otherwise returns a string
* @param type
* @param value
* @returns {string|string|NodeJS.Global.Uint8Array|*}
*/
function convertJsToDbType(type, value) {
	if (type === ValueType.Bytes && value != null) return value;
else if (type === ValueType.Boolean) return value ? "1" : "0";
else if (type === ValueType.Date) return value.getTime().toString();
else if (type === ValueType.CompressedString) return compressString(value);
else return value;
}
function convertDbToJsType(type, value) {
	if (type === ValueType.Bytes) return base64ToUint8Array(value);
else if (type === ValueType.Boolean) return value !== "0";
else if (type === ValueType.Date) return new Date(parseInt(value));
else if (type === ValueType.CompressedString) return decompressString(base64ToUint8Array(value));
else return value;
}
function compressString(uncompressed) {
	return compress(stringToUtf8Uint8Array(uncompressed));
}
function decompressString(compressed) {
	if (compressed.length === 0) return "";
	const output = uncompress(compressed);
	return utf8Uint8ArrayToString(output);
}
function valueToDefault(type) {
	switch (type) {
		case ValueType.String: return "";
		case ValueType.Number: return "0";
		case ValueType.Bytes: return new Uint8Array(0);
		case ValueType.Date: return new Date(0);
		case ValueType.Boolean: return false;
		case ValueType.CompressedString: return "";
		default: throw new ProgrammingError(`${type} is not a valid value type`);
	}
}
function isDefaultValue(type, value) {
	switch (type) {
		case ValueType.String: return value === "";
		case ValueType.Number: return value === "0";
		case ValueType.Bytes: return value.length === 0;
		case ValueType.Date: return value.getTime() === 0;
		case ValueType.Boolean: return value === false;
		case ValueType.CompressedString: return value === "";
		default: throw new ProgrammingError(`${type} is not a valid value type`);
	}
}

//#endregion
//#region ../src/common/api/worker/rest/AdminClientDummyEntityRestCache.ts
var AdminClientDummyEntityRestCache = class {
	async entityEventsReceived(batch) {
		return batch.events;
	}
	async erase(instance) {
		throw new ProgrammingError("erase not implemented");
	}
	async load(_typeRef, _id, _opts) {
		throw new ProgrammingError("load not implemented");
	}
	async loadMultiple(typeRef, listId, elementIds) {
		throw new ProgrammingError("loadMultiple not implemented");
	}
	async loadRange(typeRef, listId, start, count, reverse) {
		throw new ProgrammingError("loadRange not implemented");
	}
	async purgeStorage() {
		return;
	}
	async setup(listId, instance, extraHeaders) {
		throw new ProgrammingError("setup not implemented");
	}
	async setupMultiple(listId, instances) {
		throw new ProgrammingError("setupMultiple not implemented");
	}
	async update(instance) {
		throw new ProgrammingError("update not implemented");
	}
	async getLastEntityEventBatchForGroup(groupId) {
		return null;
	}
	async setLastEntityEventBatchForGroup(groupId, batchId) {
		return;
	}
	async recordSyncTime() {
		return;
	}
	async timeSinceLastSyncMs() {
		return null;
	}
	async isOutOfSync() {
		return false;
	}
};

//#endregion
//#region ../src/common/api/worker/utils/SleepDetector.ts
const CHECK_INTERVAL = 5e3;
const SLEEP_INTERVAL = 15e3;
var SleepDetector = class {
	scheduledState = null;
	constructor(scheduler, dateProvider) {
		this.scheduler = scheduler;
		this.dateProvider = dateProvider;
	}
	start(onSleep) {
		this.stop();
		this.scheduledState = {
			scheduledId: this.scheduler.schedulePeriodic(() => this.check(), CHECK_INTERVAL),
			lastTime: this.dateProvider.now(),
			onSleep
		};
	}
	check() {
		if (this.scheduledState == null) return;
		const now = this.dateProvider.now();
		if (now - this.scheduledState.lastTime > SLEEP_INTERVAL) this.scheduledState.onSleep();
		this.scheduledState.lastTime = now;
	}
	stop() {
		if (this.scheduledState) {
			this.scheduler.unschedulePeriodic(this.scheduledState.scheduledId);
			this.scheduledState = null;
		}
	}
};

//#endregion
//#region ../src/common/api/worker/rest/EphemeralCacheStorage.ts
var EphemeralCacheStorage = class {
	/** Path to id to entity map. */
	entities = new Map();
	lists = new Map();
	blobEntities = new Map();
	customCacheHandlerMap = new CustomCacheHandlerMap();
	lastUpdateTime = null;
	userId = null;
	lastBatchIdPerGroup = new Map();
	init({ userId }) {
		this.userId = userId;
	}
	deinit() {
		this.userId = null;
		this.entities.clear();
		this.lists.clear();
		this.blobEntities.clear();
		this.lastUpdateTime = null;
		this.lastBatchIdPerGroup.clear();
	}
	/**
	* Get a given entity from the cache, expects that you have already checked for existence
	*/
	async get(typeRef, listId, elementId) {
		const path = typeRefToPath(typeRef);
		const typeModel = await resolveTypeReference(typeRef);
		elementId = ensureBase64Ext(typeModel, elementId);
		switch (typeModel.type) {
			case Type.Element: return clone(this.entities.get(path)?.get(elementId) ?? null);
			case Type.ListElement: return clone(this.lists.get(path)?.get(assertNotNull(listId))?.elements.get(elementId) ?? null);
			case Type.BlobElement: return clone(this.blobEntities.get(path)?.get(assertNotNull(listId))?.elements.get(elementId) ?? null);
			default: throw new ProgrammingError("must be a persistent type");
		}
	}
	async deleteIfExists(typeRef, listId, elementId) {
		const path = typeRefToPath(typeRef);
		let typeModel;
		typeModel = await resolveTypeReference(typeRef);
		elementId = ensureBase64Ext(typeModel, elementId);
		switch (typeModel.type) {
			case Type.Element:
				this.entities.get(path)?.delete(elementId);
				break;
			case Type.ListElement: {
				const cache = this.lists.get(path)?.get(assertNotNull(listId));
				if (cache != null) {
					cache.elements.delete(elementId);
					remove(cache.allRange, elementId);
				}
				break;
			}
			case Type.BlobElement:
				this.blobEntities.get(path)?.get(assertNotNull(listId))?.elements.delete(elementId);
				break;
			default: throw new ProgrammingError("must be a persistent type");
		}
	}
	addElementEntity(typeRef, id, entity) {
		getFromMap(this.entities, typeRefToPath(typeRef), () => new Map()).set(id, entity);
	}
	async isElementIdInCacheRange(typeRef, listId, elementId) {
		const typeModel = await resolveTypeReference(typeRef);
		elementId = ensureBase64Ext(typeModel, elementId);
		const cache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		return cache != null && !firstBiggerThanSecond(elementId, cache.upperRangeId) && !firstBiggerThanSecond(cache.lowerRangeId, elementId);
	}
	async put(originalEntity) {
		const entity = clone(originalEntity);
		const typeRef = entity._type;
		const typeModel = await resolveTypeReference(typeRef);
		let { listId, elementId } = expandId(originalEntity._id);
		elementId = ensureBase64Ext(typeModel, elementId);
		switch (typeModel.type) {
			case Type.Element: {
				const elementEntity = entity;
				this.addElementEntity(elementEntity._type, elementId, elementEntity);
				break;
			}
			case Type.ListElement: {
				const listElementEntity = entity;
				const listElementTypeRef = typeRef;
				listId = listId;
				await this.putListElement(listElementTypeRef, listId, elementId, listElementEntity);
				break;
			}
			case Type.BlobElement: {
				const blobElementEntity = entity;
				const blobTypeRef = typeRef;
				listId = listId;
				await this.putBlobElement(blobTypeRef, listId, elementId, blobElementEntity);
				break;
			}
			default: throw new ProgrammingError("must be a persistent type");
		}
	}
	async putBlobElement(typeRef, listId, elementId, entity) {
		const cache = this.blobEntities.get(typeRefToPath(typeRef))?.get(listId);
		if (cache == null) {
			const newCache = { elements: new Map([[elementId, entity]]) };
			getFromMap(this.blobEntities, typeRefToPath(typeRef), () => new Map()).set(listId, newCache);
		} else cache.elements.set(elementId, entity);
	}
	/** prcondition: elementId is converted to base64ext if necessary */
	async putListElement(typeRef, listId, elementId, entity) {
		const cache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		if (cache == null) {
			const newCache = {
				allRange: [elementId],
				lowerRangeId: elementId,
				upperRangeId: elementId,
				elements: new Map([[elementId, entity]])
			};
			getFromMap(this.lists, typeRefToPath(typeRef), () => new Map()).set(listId, newCache);
		} else {
			cache.elements.set(elementId, entity);
			const typeModel = await resolveTypeReference(typeRef);
			if (await this.isElementIdInCacheRange(typeRef, listId, customIdToBase64Url(typeModel, elementId))) this.insertIntoRange(cache.allRange, elementId);
		}
	}
	/** precondition: elementId is converted to base64ext if necessary */
	insertIntoRange(allRange, elementId) {
		for (let i = 0; i < allRange.length; i++) {
			const rangeElement = allRange[i];
			if (firstBiggerThanSecond(rangeElement, elementId)) {
				allRange.splice(i, 0, elementId);
				return;
			}
			if (rangeElement === elementId) return;
		}
		allRange.push(elementId);
	}
	async provideFromRange(typeRef, listId, startElementId, count, reverse) {
		const typeModel = await resolveTypeReference(typeRef);
		startElementId = ensureBase64Ext(typeModel, startElementId);
		const listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		if (listCache == null) return [];
		let range = listCache.allRange;
		let ids = [];
		if (reverse) {
			let i;
			for (i = range.length - 1; i >= 0; i--) if (firstBiggerThanSecond(startElementId, range[i])) break;
			if (i >= 0) {
				let startIndex = i + 1 - count;
				if (startIndex < 0) startIndex = 0;
				ids = range.slice(startIndex, i + 1);
				ids.reverse();
			} else ids = [];
		} else {
			const i = range.findIndex((id) => firstBiggerThanSecond(id, startElementId));
			ids = range.slice(i, i + count);
		}
		let result = [];
		for (let a = 0; a < ids.length; a++) result.push(clone(listCache.elements.get(ids[a])));
		return result;
	}
	async provideMultiple(typeRef, listId, elementIds) {
		const listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		const typeModel = await resolveTypeReference(typeRef);
		elementIds = elementIds.map((el) => ensureBase64Ext(typeModel, el));
		if (listCache == null) return [];
		let result = [];
		for (let a = 0; a < elementIds.length; a++) result.push(clone(listCache.elements.get(elementIds[a])));
		return result;
	}
	async getRangeForList(typeRef, listId) {
		const listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		if (listCache == null) return null;
		const typeModel = await resolveTypeReference(typeRef);
		return {
			lower: customIdToBase64Url(typeModel, listCache.lowerRangeId),
			upper: customIdToBase64Url(typeModel, listCache.upperRangeId)
		};
	}
	async setUpperRangeForList(typeRef, listId, upperId) {
		const typeModel = await resolveTypeReference(typeRef);
		upperId = ensureBase64Ext(typeModel, upperId);
		const listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		if (listCache == null) throw new Error("list does not exist");
		listCache.upperRangeId = upperId;
	}
	async setLowerRangeForList(typeRef, listId, lowerId) {
		const typeModel = await resolveTypeReference(typeRef);
		lowerId = ensureBase64Ext(typeModel, lowerId);
		const listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		if (listCache == null) throw new Error("list does not exist");
		listCache.lowerRangeId = lowerId;
	}
	/**
	* Creates a new list cache if there is none. Resets everything but elements.
	* @param typeRef
	* @param listId
	* @param lower
	* @param upper
	*/
	async setNewRangeForList(typeRef, listId, lower, upper) {
		const typeModel = await resolveTypeReference(typeRef);
		lower = ensureBase64Ext(typeModel, lower);
		upper = ensureBase64Ext(typeModel, upper);
		const listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		if (listCache == null) getFromMap(this.lists, typeRefToPath(typeRef), () => new Map()).set(listId, {
			allRange: [],
			lowerRangeId: lower,
			upperRangeId: upper,
			elements: new Map()
		});
else {
			listCache.lowerRangeId = lower;
			listCache.upperRangeId = upper;
			listCache.allRange = [];
		}
	}
	async getIdsInRange(typeRef, listId) {
		const typeModel = await resolveTypeReference(typeRef);
		return this.lists.get(typeRefToPath(typeRef))?.get(listId)?.allRange.map((elementId) => {
			return customIdToBase64Url(typeModel, elementId);
		}) ?? [];
	}
	async getLastBatchIdForGroup(groupId) {
		return this.lastBatchIdPerGroup.get(groupId) ?? null;
	}
	async putLastBatchIdForGroup(groupId, batchId) {
		this.lastBatchIdPerGroup.set(groupId, batchId);
	}
	purgeStorage() {
		return Promise.resolve();
	}
	async getLastUpdateTime() {
		return this.lastUpdateTime ? {
			type: "recorded",
			time: this.lastUpdateTime
		} : { type: "never" };
	}
	async putLastUpdateTime(value) {
		this.lastUpdateTime = value;
	}
	async getWholeList(typeRef, listId) {
		const listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId);
		if (listCache == null) return [];
		return listCache.allRange.map((id) => clone(listCache.elements.get(id)));
	}
	getCustomCacheHandlerMap(entityRestClient) {
		return this.customCacheHandlerMap;
	}
	getUserId() {
		return assertNotNull(this.userId, "No user id, not initialized?");
	}
	async deleteAllOwnedBy(owner) {
		for (const typeMap of this.entities.values()) for (const [id, entity] of typeMap.entries()) if (entity._ownerGroup === owner) typeMap.delete(id);
		for (const cacheForType of this.lists.values()) this.deleteAllOwnedByFromCache(cacheForType, owner);
		for (const cacheForType of this.blobEntities.values()) this.deleteAllOwnedByFromCache(cacheForType, owner);
		this.lastBatchIdPerGroup.delete(owner);
	}
	async deleteWholeList(typeRef, listId) {
		this.lists.get(typeRef.type)?.delete(listId);
	}
	deleteAllOwnedByFromCache(cacheForType, owner) {
		const listIdsToDelete = [];
		for (const [listId, listCache] of cacheForType.entries()) for (const [id, element] of listCache.elements.entries()) if (element._ownerGroup === owner) {
			listIdsToDelete.push(listId);
			break;
		}
		for (const listId of listIdsToDelete) cacheForType.delete(listId);
	}
	clearExcludedData() {
		return Promise.resolve();
	}
	/**
	* We want to lock the access to the "ranges" db when updating / reading the
	* offline available mail list ranges for each mail list (referenced using the listId)
	* @param listId the mail list that we want to lock
	*/
	lockRangesDbAccess(listId) {
		return Promise.resolve();
	}
	/**
	* This is the counterpart to the function "lockRangesDbAccess(listId)"
	* @param listId the mail list that we want to unlock
	*/
	unlockRangesDbAccess(listId) {
		return Promise.resolve();
	}
};

//#endregion
//#region ../src/common/api/worker/rest/CacheStorageProxy.ts
var LateInitializedCacheStorageImpl = class {
	_inner = null;
	constructor(sendError, offlineStorageProvider) {
		this.sendError = sendError;
		this.offlineStorageProvider = offlineStorageProvider;
	}
	get inner() {
		if (this._inner == null) throw new ProgrammingError("Cache storage is not initialized");
		return this._inner;
	}
	async initialize(args) {
		const { storage, isPersistent, isNewOfflineDb } = await this.getStorage(args);
		this._inner = storage;
		return {
			isPersistent,
			isNewOfflineDb
		};
	}
	async deInitialize() {
		this._inner?.deinit();
	}
	async getStorage(args) {
		if (args.type === "offline") try {
			const storage$1 = await this.offlineStorageProvider();
			if (storage$1 != null) {
				const isNewOfflineDb = await storage$1.init(args);
				return {
					storage: storage$1,
					isPersistent: true,
					isNewOfflineDb
				};
			}
		} catch (e) {
			console.error("Error while initializing offline cache storage", e);
			this.sendError(e);
		}
		const storage = new EphemeralCacheStorage();
		await storage.init(args);
		return {
			storage,
			isPersistent: false,
			isNewOfflineDb: false
		};
	}
	deleteIfExists(typeRef, listId, id) {
		return this.inner.deleteIfExists(typeRef, listId, id);
	}
	get(typeRef, listId, id) {
		return this.inner.get(typeRef, listId, id);
	}
	getIdsInRange(typeRef, listId) {
		return this.inner.getIdsInRange(typeRef, listId);
	}
	getLastBatchIdForGroup(groupId) {
		return this.inner.getLastBatchIdForGroup(groupId);
	}
	async getLastUpdateTime() {
		return this._inner ? this.inner.getLastUpdateTime() : { type: "uninitialized" };
	}
	getRangeForList(typeRef, listId) {
		return this.inner.getRangeForList(typeRef, listId);
	}
	isElementIdInCacheRange(typeRef, listId, id) {
		return this.inner.isElementIdInCacheRange(typeRef, listId, id);
	}
	provideFromRange(typeRef, listId, start, count, reverse) {
		return this.inner.provideFromRange(typeRef, listId, start, count, reverse);
	}
	provideMultiple(typeRef, listId, elementIds) {
		return this.inner.provideMultiple(typeRef, listId, elementIds);
	}
	getWholeList(typeRef, listId) {
		return this.inner.getWholeList(typeRef, listId);
	}
	purgeStorage() {
		return this.inner.purgeStorage();
	}
	put(originalEntity) {
		return this.inner.put(originalEntity);
	}
	putLastBatchIdForGroup(groupId, batchId) {
		return this.inner.putLastBatchIdForGroup(groupId, batchId);
	}
	putLastUpdateTime(value) {
		return this.inner.putLastUpdateTime(value);
	}
	setLowerRangeForList(typeRef, listId, id) {
		return this.inner.setLowerRangeForList(typeRef, listId, id);
	}
	setNewRangeForList(typeRef, listId, lower, upper) {
		return this.inner.setNewRangeForList(typeRef, listId, lower, upper);
	}
	setUpperRangeForList(typeRef, listId, id) {
		return this.inner.setUpperRangeForList(typeRef, listId, id);
	}
	getCustomCacheHandlerMap(entityRestClient) {
		return this.inner.getCustomCacheHandlerMap(entityRestClient);
	}
	getUserId() {
		return this.inner.getUserId();
	}
	async deleteAllOwnedBy(owner) {
		return this.inner.deleteAllOwnedBy(owner);
	}
	async deleteWholeList(typeRef, listId) {
		return this.inner.deleteWholeList(typeRef, listId);
	}
	clearExcludedData() {
		return this.inner.clearExcludedData();
	}
	/**
	* We want to lock the access to the "ranges" db when updating / reading the
	* offline available mail list ranges for each mail list (referenced using the listId)
	* @param listId the mail list that we want to lock
	*/
	lockRangesDbAccess(listId) {
		return this.inner.lockRangesDbAccess(listId);
	}
	/**
	* This is the counterpart to the function "lockRangesDbAccess(listId)"
	* @param listId the mail list that we want to unlock
	*/
	unlockRangesDbAccess(listId) {
		return this.inner.unlockRangesDbAccess(listId);
	}
};

//#endregion
//#region ../src/common/api/worker/rest/ServiceExecutor.ts
assertWorkerOrNode();
var ServiceExecutor = class {
	constructor(restClient, authDataProvider, instanceMapper, cryptoFacade) {
		this.restClient = restClient;
		this.authDataProvider = authDataProvider;
		this.instanceMapper = instanceMapper;
		this.cryptoFacade = cryptoFacade;
	}
	get(service, data, params) {
		return this.executeServiceRequest(service, HttpMethod.GET, data, params);
	}
	post(service, data, params) {
		return this.executeServiceRequest(service, HttpMethod.POST, data, params);
	}
	put(service, data, params) {
		return this.executeServiceRequest(service, HttpMethod.PUT, data, params);
	}
	delete(service, data, params) {
		return this.executeServiceRequest(service, HttpMethod.DELETE, data, params);
	}
	async executeServiceRequest(service, method, requestEntity, params) {
		const methodDefinition = this.getMethodDefinition(service, method);
		if (methodDefinition.return && params?.sessionKey == null && (await resolveTypeReference(methodDefinition.return)).encrypted && !this.authDataProvider.isFullyLoggedIn()) throw new LoginIncompleteError(`Tried to make service request with encrypted return type but is not fully logged in yet, service: ${service.name}`);
		const modelVersion = await this.getModelVersion(methodDefinition);
		const path = `/rest/${service.app.toLowerCase()}/${service.name.toLowerCase()}`;
		const headers = {
			...this.authDataProvider.createAuthHeaders(),
			...params?.extraHeaders,
			v: modelVersion
		};
		const encryptedEntity = await this.encryptDataIfNeeded(methodDefinition, requestEntity, service, method, params ?? null);
		const data = await this.restClient.request(path, method, {
			queryParams: params?.queryParams,
			headers,
			responseType: MediaType.Json,
			body: encryptedEntity ?? undefined,
			suspensionBehavior: params?.suspensionBehavior,
			baseUrl: params?.baseUrl
		});
		if (methodDefinition.return) return await this.decryptResponse(methodDefinition.return, data, params);
	}
	getMethodDefinition(service, method) {
		switch (method) {
			case HttpMethod.GET: return service["get"];
			case HttpMethod.POST: return service["post"];
			case HttpMethod.PUT: return service["put"];
			case HttpMethod.DELETE: return service["delete"];
		}
	}
	async getModelVersion(methodDefinition) {
		const someTypeRef = methodDefinition.data ?? methodDefinition.return;
		if (someTypeRef == null) throw new ProgrammingError("Need either data or return for the service method!");
		const model = await resolveTypeReference(someTypeRef);
		return model.version;
	}
	async encryptDataIfNeeded(methodDefinition, requestEntity, service, method, params) {
		if (methodDefinition.data != null) {
			if (requestEntity == null || !isSameTypeRef(methodDefinition.data, requestEntity._type)) throw new ProgrammingError(`Invalid service data! ${service.name} ${method}`);
			const requestTypeModel = await resolveTypeReference(methodDefinition.data);
			if (requestTypeModel.encrypted && params?.sessionKey == null) throw new ProgrammingError("Must provide a session key for an encrypted data transfer type!: " + service);
			const encryptedEntity = await this.instanceMapper.encryptAndMapToLiteral(requestTypeModel, requestEntity, params?.sessionKey ?? null);
			return JSON.stringify(encryptedEntity);
		} else return null;
	}
	async decryptResponse(typeRef, data, params) {
		const responseTypeModel = await resolveTypeReference(typeRef);
		const instance = JSON.parse(data, (k, v) => k === "__proto__" ? undefined : v);
		const resolvedSessionKey = await this.cryptoFacade().resolveServiceSessionKey(instance);
		return this.instanceMapper.decryptAndMapToInstance(responseTypeModel, instance, resolvedSessionKey ?? params?.sessionKey ?? null);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/UserFacade.ts
var UserFacade = class {
	user = null;
	accessToken = null;
	leaderStatus;
	constructor(keyCache, cryptoWrapper) {
		this.keyCache = keyCache;
		this.cryptoWrapper = cryptoWrapper;
		this.reset();
	}
	setAccessToken(accessToken) {
		this.accessToken = accessToken;
	}
	getAccessToken() {
		return this.accessToken;
	}
	setUser(user) {
		if (this.accessToken == null) throw new ProgrammingError("invalid state: no access token");
		this.user = user;
	}
	unlockUserGroupKey(userPassphraseKey) {
		if (this.user == null) throw new ProgrammingError("Invalid state: no user");
		const userGroupMembership = this.user.userGroup;
		const currentUserGroupKey = {
			version: Number(userGroupMembership.groupKeyVersion),
			object: decryptKey(userPassphraseKey, userGroupMembership.symEncGKey)
		};
		this.keyCache.setCurrentUserGroupKey(currentUserGroupKey);
		this.setUserGroupKeyDistributionKey(userPassphraseKey);
	}
	setUserGroupKeyDistributionKey(userPassphraseKey) {
		if (this.user == null) throw new ProgrammingError("Invalid state: no user");
		const userGroupMembership = this.user.userGroup;
		const userGroupKeyDistributionKey = this.deriveUserGroupKeyDistributionKey(userGroupMembership.group, userPassphraseKey);
		this.keyCache.setUserGroupKeyDistributionKey(userGroupKeyDistributionKey);
	}
	deriveUserGroupKeyDistributionKey(userGroupId, userPassphraseKey) {
		return this.cryptoWrapper.deriveKeyWithHkdf({
			salt: userGroupId,
			key: userPassphraseKey,
			context: "userGroupKeyDistributionKey"
		});
	}
	async updateUser(user) {
		if (this.user == null) throw new ProgrammingError("Update user is called without logging in. This function is not for you.");
		this.user = user;
		await this.keyCache.removeOutdatedGroupKeys(user);
	}
	getUser() {
		return this.user;
	}
	/**
	* @return The map which contains authentication data for the logged-in user.
	*/
	createAuthHeaders() {
		return this.accessToken ? { accessToken: this.accessToken } : {};
	}
	getUserGroupId() {
		return this.getLoggedInUser().userGroup.group;
	}
	getAllGroupIds() {
		let groups = this.getLoggedInUser().memberships.map((membership) => membership.group);
		groups.push(this.getLoggedInUser().userGroup.group);
		return groups;
	}
	getCurrentUserGroupKey() {
		const currentUserGroupKey = this.keyCache.getCurrentUserGroupKey();
		if (currentUserGroupKey == null) if (this.isPartiallyLoggedIn()) throw new LoginIncompleteError("userGroupKey not available");
else throw new ProgrammingError("Invalid state: userGroupKey is not available");
		return currentUserGroupKey;
	}
	getMembership(groupId) {
		let membership = this.getLoggedInUser().memberships.find((g) => isSameId(g.group, groupId));
		if (!membership) throw new Error(`No group with groupId ${groupId} found!`);
		return membership;
	}
	hasGroup(groupId) {
		if (!this.user) return false;
else return groupId === this.user.userGroup.group || this.user.memberships.some((m) => m.group === groupId);
	}
	getGroupId(groupType) {
		if (groupType === GroupType.User) return this.getUserGroupId();
else {
			let membership = this.getLoggedInUser().memberships.find((m) => m.groupType === groupType);
			if (!membership) throw new Error("could not find groupType " + groupType + " for user " + this.getLoggedInUser()._id);
			return membership.group;
		}
	}
	getGroupIds(groupType) {
		return this.getLoggedInUser().memberships.filter((m) => m.groupType === groupType).map((gm) => gm.group);
	}
	isPartiallyLoggedIn() {
		return this.user != null;
	}
	isFullyLoggedIn() {
		return this.keyCache.getCurrentUserGroupKey() != null;
	}
	getLoggedInUser() {
		return assertNotNull(this.user);
	}
	setLeaderStatus(status) {
		this.leaderStatus = status;
		console.log("New leader status set:", status.leaderStatus);
	}
	isLeader() {
		return this.leaderStatus.leaderStatus;
	}
	reset() {
		this.user = null;
		this.accessToken = null;
		this.keyCache.reset();
		this.leaderStatus = createWebsocketLeaderStatus({ leaderStatus: false });
	}
	updateUserGroupKey(userGroupKeyDistribution) {
		const userGroupKeyDistributionKey = this.keyCache.getUserGroupKeyDistributionKey();
		if (userGroupKeyDistributionKey == null) {
			console.log("could not update userGroupKey because distribution key is not available");
			return;
		}
		let newUserGroupKeyBytes;
		try {
			newUserGroupKeyBytes = decryptKey(userGroupKeyDistributionKey, userGroupKeyDistribution.distributionEncUserGroupKey);
		} catch (e) {
			console.log(`Could not decrypt userGroupKeyUpdate`, e);
			return;
		}
		const newUserGroupKey = {
			object: newUserGroupKeyBytes,
			version: Number(userGroupKeyDistribution.userGroupKeyVersion)
		};
		console.log(`updating userGroupKey. new version: ${userGroupKeyDistribution.userGroupKeyVersion}`);
		this.keyCache.setCurrentUserGroupKey(newUserGroupKey);
	}
};

//#endregion
//#region ../src/common/native/common/generatedipc/SqlCipherFacadeSendDispatcher.ts
var SqlCipherFacadeSendDispatcher = class {
	constructor(transport) {
		this.transport = transport;
	}
	async openDb(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"openDb",
			...args
		]);
	}
	async closeDb(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"closeDb",
			...args
		]);
	}
	async deleteDb(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"deleteDb",
			...args
		]);
	}
	async run(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"run",
			...args
		]);
	}
	async get(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"get",
			...args
		]);
	}
	async all(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"all",
			...args
		]);
	}
	async lockRangesDbAccess(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"lockRangesDbAccess",
			...args
		]);
	}
	async unlockRangesDbAccess(...args) {
		return this.transport.invokeNative("ipc", [
			"SqlCipherFacade",
			"unlockRangesDbAccess",
			...args
		]);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/EntropyFacade.ts
var EntropyFacade = class {
	newEntropy = -1;
	lastEntropyUpdate = Date.now();
	constructor(userFacade, serviceExecutor, random$1, lazyKeyLoaderFacade) {
		this.userFacade = userFacade;
		this.serviceExecutor = serviceExecutor;
		this.random = random$1;
		this.lazyKeyLoaderFacade = lazyKeyLoaderFacade;
	}
	/**
	* Adds entropy to the randomizer. Updated the stored entropy for a user when enough entropy has been collected.
	*/
	addEntropy(entropy) {
		try {
			return this.random.addEntropy(entropy);
		} finally {
			this.newEntropy = this.newEntropy + entropy.reduce((sum, value) => value.entropy + sum, 0);
			const now = new Date().getTime();
			if (this.newEntropy > 5e3 && now - this.lastEntropyUpdate > 3e5) {
				this.lastEntropyUpdate = now;
				this.newEntropy = 0;
				this.storeEntropy();
			}
		}
	}
	storeEntropy() {
		if (!this.userFacade.isFullyLoggedIn() || !this.userFacade.isLeader()) return Promise.resolve();
		const userGroupKey = this.userFacade.getCurrentUserGroupKey();
		const entropyData = createEntropyData({
			userEncEntropy: encryptBytes(userGroupKey.object, this.random.generateRandomData(32)),
			userKeyVersion: userGroupKey.version.toString()
		});
		return this.serviceExecutor.put(EntropyService, entropyData).catch(ofClass(LockedError, noOp)).catch(ofClass(ConnectionError, (e) => {
			console.log("could not store entropy", e);
		})).catch(ofClass(ServiceUnavailableError, (e) => {
			console.log("could not store entropy", e);
		}));
	}
	/**
	* Loads entropy from the last logout.
	*/
	async loadEntropy(tutanotaProperties) {
		if (tutanotaProperties.userEncEntropy) try {
			const keyLoaderFacade = this.lazyKeyLoaderFacade();
			const userGroupKey = await keyLoaderFacade.loadSymUserGroupKey(Number(tutanotaProperties.userKeyVersion ?? 0));
			const entropy = authenticatedAesDecrypt(userGroupKey, tutanotaProperties.userEncEntropy);
			random.addStaticEntropy(entropy);
		} catch (error) {
			console.log("could not decrypt entropy", error);
		}
	}
};

//#endregion
//#region ../src/common/api/worker/facades/BlobAccessTokenFacade.ts
assertWorkerOrNode();
var BlobAccessTokenFacade = class {
	readCache;
	writeCache;
	constructor(serviceExecutor, authDataProvider, dateProvider) {
		this.serviceExecutor = serviceExecutor;
		this.authDataProvider = authDataProvider;
		this.readCache = new BlobAccessTokenCache(dateProvider);
		this.writeCache = new BlobAccessTokenCache(dateProvider);
	}
	/**
	* Requests a token that allows uploading blobs for the given ArchiveDataType and ownerGroup.
	* @param archiveDataType The type of data that should be stored.
	* @param ownerGroupId The ownerGroup were the data belongs to (e.g. group of type mail)
	*/
	async requestWriteToken(archiveDataType, ownerGroupId) {
		const requestNewToken = async () => {
			const tokenRequest = createBlobAccessTokenPostIn({
				archiveDataType,
				write: createBlobWriteData({ archiveOwnerGroup: ownerGroupId }),
				read: null
			});
			const { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest);
			return blobAccessInfo;
		};
		const key = this.makeWriteCacheKey(ownerGroupId, archiveDataType);
		return this.writeCache.getToken(key, [], requestNewToken);
	}
	makeWriteCacheKey(ownerGroupId, archiveDataType) {
		return ownerGroupId + archiveDataType;
	}
	/**
	* Remove a given write token from the cache.
	* @param archiveDataType
	* @param ownerGroupId
	*/
	evictWriteToken(archiveDataType, ownerGroupId) {
		const key = this.makeWriteCacheKey(ownerGroupId, archiveDataType);
		this.writeCache.evictArchiveOrGroupKey(key);
	}
	/**
	* Requests a token that grants read access to all blobs that are referenced by the given instances.
	* A user must be owner of the instance but must not be owner of the archive where the blobs are stored in.
	*
	* @param archiveDataType specify the data type
	* @param referencingInstances the instances that references the blobs
	* @param blobLoadOptions load options when loading blobs
	* @throws ProgrammingError if instances are not part of the same list or blobs are not part of the same archive.
	*/
	async requestReadTokenMultipleInstances(archiveDataType, referencingInstances, blobLoadOptions) {
		if (isEmpty(referencingInstances)) throw new ProgrammingError("Must pass at least one referencing instance");
		const instanceListId = referencingInstances[0].listId;
		if (!referencingInstances.every((instance) => instance.listId === instanceListId)) throw new ProgrammingError("All referencing instances must be part of the same list");
		const archiveId = this.getArchiveId(referencingInstances);
		const requestNewToken = lazyMemoized(async () => {
			const instanceIds = referencingInstances.map(({ elementId }) => createInstanceId({ instanceId: elementId }));
			const tokenRequest = createBlobAccessTokenPostIn({
				archiveDataType,
				read: createBlobReadData({
					archiveId,
					instanceListId,
					instanceIds
				}),
				write: null
			});
			const { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest, blobLoadOptions);
			return blobAccessInfo;
		});
		return this.readCache.getToken(archiveId, referencingInstances.map((instance) => instance.elementId), requestNewToken);
	}
	/**
	* Requests a token that grants read access to all blobs that are referenced by the given instance.
	* A user must be owner of the instance but must not be owner of the archive were the blobs are stored in.
	* @param archiveDataType specify the data type
	* @param referencingInstance the instance that references the blobs
	* @param blobLoadOptions load options when loading blobs
	*/
	async requestReadTokenBlobs(archiveDataType, referencingInstance, blobLoadOptions) {
		const archiveId = this.getArchiveId([referencingInstance]);
		const requestNewToken = async () => {
			const instanceListId = referencingInstance.listId;
			const instanceId = referencingInstance.elementId;
			const instanceIds = [createInstanceId({ instanceId })];
			const tokenRequest = createBlobAccessTokenPostIn({
				archiveDataType,
				read: createBlobReadData({
					archiveId,
					instanceListId,
					instanceIds
				}),
				write: null
			});
			const { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest, blobLoadOptions);
			return blobAccessInfo;
		};
		return this.readCache.getToken(archiveId, [referencingInstance.elementId], requestNewToken);
	}
	/**
	* Remove a given read blobs token from the cache.
	* @param referencingInstance
	*/
	evictReadBlobsToken(referencingInstance) {
		this.readCache.evictInstanceId(referencingInstance.elementId);
		const archiveId = this.getArchiveId([referencingInstance]);
		this.readCache.evictArchiveOrGroupKey(archiveId);
	}
	/**
	* Remove a given read blobs token from the cache.
	* @param referencingInstances
	*/
	evictReadBlobsTokenMultipleBlobs(referencingInstances) {
		this.readCache.evictAll(referencingInstances.map((instance) => instance.elementId));
		const archiveId = this.getArchiveId(referencingInstances);
		this.readCache.evictArchiveOrGroupKey(archiveId);
	}
	/**
	* Requests a token that grants access to all blobs stored in the given archive. The user must own the archive (member of group)
	* @param archiveId ID for the archive to read blobs from
	*/
	async requestReadTokenArchive(archiveId) {
		const requestNewToken = async () => {
			const tokenRequest = createBlobAccessTokenPostIn({
				archiveDataType: null,
				read: createBlobReadData({
					archiveId,
					instanceIds: [],
					instanceListId: null
				}),
				write: null
			});
			const { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest);
			return blobAccessInfo;
		};
		return this.readCache.getToken(archiveId, [], requestNewToken);
	}
	/**
	* Remove a given read archive token from the cache.
	* @param archiveId
	*/
	evictArchiveToken(archiveId) {
		this.readCache.evictArchiveOrGroupKey(archiveId);
	}
	getArchiveId(referencingInstances) {
		if (isEmpty(referencingInstances)) throw new ProgrammingError("Must pass at least one referencing instance");
		const archiveIds = new Set();
		for (const referencingInstance of referencingInstances) {
			if (isEmpty(referencingInstance.blobs)) throw new ProgrammingError("must pass blobs");
			for (const blob of referencingInstance.blobs) archiveIds.add(blob.archiveId);
		}
		if (archiveIds.size != 1) throw new Error(`only one archive id allowed, but was ${archiveIds}`);
		return referencingInstances[0].blobs[0].archiveId;
	}
	/**
	*
	* @param blobServerAccessInfo
	* @param additionalRequestParams
	* @param typeRef the typeRef that shall be used to determine the correct model version
	*/
	async createQueryParams(blobServerAccessInfo, additionalRequestParams, typeRef) {
		const typeModel = await resolveTypeReference(typeRef);
		return Object.assign(additionalRequestParams, {
			blobAccessToken: blobServerAccessInfo.blobAccessToken,
			v: typeModel.version
		}, this.authDataProvider.createAuthHeaders());
	}
};
/**
* Checks if the given access token can be used for another blob service requests.
* @param blobServerAccessInfo
* @param dateProvider
*/
function canBeUsedForAnotherRequest(blobServerAccessInfo, dateProvider) {
	return blobServerAccessInfo.expires.getTime() > dateProvider.now();
}
var BlobAccessTokenCache = class {
	instanceMap = new Map();
	archiveMap = new Map();
	constructor(dateProvider) {
		this.dateProvider = dateProvider;
	}
	/**
	* Get a token from the cache or from {@param loader}.
	* First will try to use the token keyed by {@param archiveOrGroupKey}, otherwise it will try to find a token valid for all of {@param instanceIds}.
	*/
	async getToken(archiveOrGroupKey, instanceIds, loader) {
		const archiveToken = archiveOrGroupKey ? this.archiveMap.get(archiveOrGroupKey) : null;
		if (archiveToken != null && canBeUsedForAnotherRequest(archiveToken, this.dateProvider)) return archiveToken;
		const tokens = deduplicate(instanceIds.map((id) => this.instanceMap.get(id) ?? null));
		const firstTokenFound = first(tokens);
		if (tokens.length != 1 || firstTokenFound == null || !canBeUsedForAnotherRequest(firstTokenFound, this.dateProvider)) {
			const newToken = await loader();
			if (archiveOrGroupKey != null && newToken.tokenKind === BlobAccessTokenKind.Archive) this.archiveMap.set(archiveOrGroupKey, newToken);
else for (const id of instanceIds) this.instanceMap.set(id, newToken);
			return newToken;
		} else return firstTokenFound;
	}
	evictInstanceId(id) {
		this.evictAll([id]);
	}
	evictArchiveOrGroupKey(id) {
		this.archiveMap.delete(id);
	}
	evictAll(ids) {
		for (const id of ids) this.instanceMap.delete(id);
	}
};

//#endregion
//#region ../src/common/api/worker/crypto/OwnerEncSessionKeysUpdateQueue.ts
assertWorkerOrNode();
const UPDATE_SESSION_KEYS_SERVICE_DEBOUNCE_MS = 50;
var OwnerEncSessionKeysUpdateQueue = class {
	updateInstanceSessionKeyQueue = [];
	invokeUpdateSessionKeyService;
	senderAuthStatusForMailInstance = null;
	constructor(userFacade, serviceExecutor, debounceTimeoutMs = UPDATE_SESSION_KEYS_SERVICE_DEBOUNCE_MS) {
		this.userFacade = userFacade;
		this.serviceExecutor = serviceExecutor;
		this.invokeUpdateSessionKeyService = debounce(debounceTimeoutMs, () => this.sendUpdateRequest());
	}
	/**
	* Add the ownerEncSessionKey updates to the queue and debounce the update request.
	*
	* @param instanceSessionKeys all instanceSessionKeys from one bucketKey containing the ownerEncSessionKey as symEncSessionKey
	* @param typeModel of the main instance that we are updating session keys for
	*/
	async updateInstanceSessionKeys(instanceSessionKeys, typeModel) {
		if (this.userFacade.isLeader()) {
			const groupKeyUpdateTypeModel = await resolveTypeReference(GroupKeyUpdateTypeRef);
			if (groupKeyUpdateTypeModel.id !== typeModel.id) {
				this.updateInstanceSessionKeyQueue.push(...instanceSessionKeys);
				this.invokeUpdateSessionKeyService();
			}
		}
	}
	async sendUpdateRequest() {
		const instanceSessionKeys = this.updateInstanceSessionKeyQueue;
		this.updateInstanceSessionKeyQueue = [];
		try {
			if (instanceSessionKeys.length > 0) await this.postUpdateSessionKeysService(instanceSessionKeys);
		} catch (e) {
			if (e instanceof LockedError) {
				this.updateInstanceSessionKeyQueue.push(...instanceSessionKeys);
				this.invokeUpdateSessionKeyService();
			} else {
				console.log("error during session key update:", e.name, instanceSessionKeys.length);
				throw e;
			}
		}
	}
	async postUpdateSessionKeysService(instanceSessionKeys) {
		const input = createUpdateSessionKeysPostIn({ ownerEncSessionKeys: instanceSessionKeys });
		await this.serviceExecutor.post(UpdateSessionKeysService, input);
	}
};

//#endregion
//#region ../src/common/api/worker/EventBusEventCoordinator.ts
var EventBusEventCoordinator = class {
	constructor(connectivityListener, mailFacade, userFacade, entityClient, eventController, configurationDatabase, keyRotationFacade, cacheManagementFacade, sendError, appSpecificBatchHandling) {
		this.connectivityListener = connectivityListener;
		this.mailFacade = mailFacade;
		this.userFacade = userFacade;
		this.entityClient = entityClient;
		this.eventController = eventController;
		this.configurationDatabase = configurationDatabase;
		this.keyRotationFacade = keyRotationFacade;
		this.cacheManagementFacade = cacheManagementFacade;
		this.sendError = sendError;
		this.appSpecificBatchHandling = appSpecificBatchHandling;
	}
	onWebsocketStateChanged(state) {
		this.connectivityListener.updateWebSocketState(state);
	}
	async onEntityEventsReceived(events, batchId, groupId) {
		await this.entityEventsReceived(events);
		await (await this.mailFacade()).entityEventsReceived(events);
		await this.eventController.onEntityUpdateReceived(events, groupId);
		if (!isTest() && !isAdminClient()) {
			const queuedBatch = {
				groupId,
				batchId,
				events
			};
			const configurationDatabase = await this.configurationDatabase();
			await configurationDatabase.onEntityEventsReceived(queuedBatch);
			this.appSpecificBatchHandling([queuedBatch]);
		}
	}
	/**
	* @param markers only phishing (not spam) marker will be sent as websocket updates
	*/
	async onPhishingMarkersReceived(markers) {
		(await this.mailFacade()).phishingMarkersUpdateReceived(markers);
	}
	onError(tutanotaError) {
		this.sendError(tutanotaError);
	}
	onLeaderStatusChanged(leaderStatus) {
		this.connectivityListener.onLeaderStatusChanged(leaderStatus);
		if (!isAdminClient()) {
			const user = this.userFacade.getUser();
			if (leaderStatus.leaderStatus && user && user.accountType !== AccountType.EXTERNAL) this.keyRotationFacade.processPendingKeyRotationsAndUpdates(user);
else this.keyRotationFacade.reset();
		}
	}
	onCounterChanged(counter) {
		this.eventController.onCountersUpdateReceived(counter);
	}
	async entityEventsReceived(data) {
		const groupKeyUpdates = [];
		const user = this.userFacade.getUser();
		if (user == null) return;
		for (const update of data) if (update.operation === OperationType.UPDATE && isSameTypeRefByAttr(UserTypeRef, update.application, update.type) && isSameId(user._id, update.instanceId)) await this.userFacade.updateUser(await this.entityClient.load(UserTypeRef, user._id));
else if ((update.operation === OperationType.CREATE || update.operation === OperationType.UPDATE) && isSameTypeRefByAttr(UserGroupKeyDistributionTypeRef, update.application, update.type) && isSameId(user.userGroup.group, update.instanceId)) await (await this.cacheManagementFacade()).tryUpdatingUserGroupKey();
else if (update.operation === OperationType.CREATE && isSameTypeRefByAttr(GroupKeyUpdateTypeRef, update.application, update.type)) groupKeyUpdates.push([update.instanceListId, update.instanceId]);
		await this.keyRotationFacade.updateGroupMemberships(groupKeyUpdates);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/WorkerFacade.ts
var WorkerFacade = class {
	async generateSsePushIdentifer() {
		return keyToBase64(aes256RandomKey());
	}
	async getLog() {
		const global = self;
		const logger = global.logger;
		if (logger) return logger.getEntries();
else return [];
	}
	async urlify(html) {
		const { urlify } = await import("./Urlifier-DVxN4Cpf.js");
		return urlify(html);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/Argon2idFacade.ts
assertWorkerOrNode();
var WASMArgon2idFacade = class {
	argon2 = new LazyLoaded(async () => {
		return await loadWasm();
	});
	async generateKeyFromPassphrase(passphrase, salt) {
		return generateKeyFromPassphrase(await this.argon2.getAsync(), passphrase, salt);
	}
};
var NativeArgon2idFacade = class {
	constructor(nativeCryptoFacade) {
		this.nativeCryptoFacade = nativeCryptoFacade;
	}
	async generateKeyFromPassphrase(passphrase, salt) {
		const hash = await this.nativeCryptoFacade.argon2idGeneratePassphraseKey(passphrase, salt);
		return uint8ArrayToBitArray(hash);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/KyberFacade.ts
assertWorkerOrNode();
var WASMKyberFacade = class {
	constructor(testWASM) {
		this.testWASM = testWASM;
	}
	liboqs = new LazyLoaded(async () => {
		if (this.testWASM) return this.testWASM;
		return await loadWasm$1();
	});
	async generateKeypair() {
		return generateKeyPair(await this.liboqs.getAsync(), random);
	}
	async encapsulate(publicKey) {
		return encapsulate(await this.liboqs.getAsync(), publicKey, random);
	}
	async decapsulate(privateKey, ciphertext) {
		return decapsulate(await this.liboqs.getAsync(), privateKey, ciphertext);
	}
};
var NativeKyberFacade = class {
	constructor(nativeCryptoFacade) {
		this.nativeCryptoFacade = nativeCryptoFacade;
	}
	generateKeypair() {
		return this.nativeCryptoFacade.generateKyberKeypair(random.generateRandomData(KYBER_RAND_AMOUNT_OF_ENTROPY));
	}
	encapsulate(publicKey) {
		return this.nativeCryptoFacade.kyberEncapsulate(publicKey, random.generateRandomData(KYBER_RAND_AMOUNT_OF_ENTROPY));
	}
	decapsulate(privateKey, ciphertext) {
		return this.nativeCryptoFacade.kyberDecapsulate(privateKey, ciphertext);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/PQMessage.ts
function decodePQMessage(encoded) {
	const pqMessageParts = bytesToByteArrays(encoded, 4);
	return {
		senderIdentityPubKey: pqMessageParts[0],
		ephemeralPubKey: pqMessageParts[1],
		encapsulation: {
			kyberCipherText: pqMessageParts[2],
			kekEncBucketKey: pqMessageParts[3]
		}
	};
}
function encodePQMessage({ senderIdentityPubKey, ephemeralPubKey, encapsulation }) {
	return byteArraysToBytes([
		senderIdentityPubKey,
		ephemeralPubKey,
		encapsulation.kyberCipherText,
		encapsulation.kekEncBucketKey
	]);
}

//#endregion
//#region ../src/common/api/worker/facades/PQFacade.ts
var PQFacade = class {
	constructor(kyberFacade) {
		this.kyberFacade = kyberFacade;
	}
	async generateKeyPairs() {
		return {
			keyPairType: KeyPairType.TUTA_CRYPT,
			eccKeyPair: generateEccKeyPair(),
			kyberKeyPair: await this.kyberFacade.generateKeypair()
		};
	}
	async encapsulateAndEncode(senderIdentityKeyPair, ephemeralKeyPair, recipientPublicKeys, bucketKey) {
		const encapsulated = await this.encapsulate(senderIdentityKeyPair, ephemeralKeyPair, recipientPublicKeys, bucketKey);
		return encodePQMessage(encapsulated);
	}
	/**
	* @VisibleForTesting
	*/
	async encapsulate(senderIdentityKeyPair, ephemeralKeyPair, recipientPublicKeys, bucketKey) {
		const eccSharedSecret = eccEncapsulate(senderIdentityKeyPair.privateKey, ephemeralKeyPair.privateKey, recipientPublicKeys.eccPublicKey);
		const kyberEncapsulation = await this.kyberFacade.encapsulate(recipientPublicKeys.kyberPublicKey);
		const kyberCipherText = kyberEncapsulation.ciphertext;
		const kek = this.derivePQKEK(senderIdentityKeyPair.publicKey, ephemeralKeyPair.publicKey, recipientPublicKeys, kyberCipherText, kyberEncapsulation.sharedSecret, eccSharedSecret, CryptoProtocolVersion.TUTA_CRYPT);
		const kekEncBucketKey = aesEncrypt(kek, bucketKey);
		return {
			senderIdentityPubKey: senderIdentityKeyPair.publicKey,
			ephemeralPubKey: ephemeralKeyPair.publicKey,
			encapsulation: {
				kyberCipherText,
				kekEncBucketKey
			}
		};
	}
	async decapsulateEncoded(encodedPQMessage, recipientKeys) {
		const decoded = decodePQMessage(encodedPQMessage);
		return {
			decryptedSymKeyBytes: await this.decapsulate(decoded, recipientKeys),
			senderIdentityPubKey: decoded.senderIdentityPubKey
		};
	}
	/**
	* @VisibleForTesting
	*/
	async decapsulate(message, recipientKeys) {
		const kyberCipherText = message.encapsulation.kyberCipherText;
		const eccSharedSecret = eccDecapsulate(message.senderIdentityPubKey, message.ephemeralPubKey, recipientKeys.eccKeyPair.privateKey);
		const kyberSharedSecret = await this.kyberFacade.decapsulate(recipientKeys.kyberKeyPair.privateKey, kyberCipherText);
		const kek = this.derivePQKEK(message.senderIdentityPubKey, message.ephemeralPubKey, pqKeyPairsToPublicKeys(recipientKeys), kyberCipherText, kyberSharedSecret, eccSharedSecret, CryptoProtocolVersion.TUTA_CRYPT);
		return authenticatedAesDecrypt(kek, message.encapsulation.kekEncBucketKey);
	}
	derivePQKEK(senderIdentityPublicKey, ephemeralPublicKey, recipientPublicKeys, kyberCipherText, kyberSharedSecret, eccSharedSecret, cryptoProtocolVersion) {
		const context = concat(senderIdentityPublicKey, ephemeralPublicKey, recipientPublicKeys.eccPublicKey, kyberPublicKeyToBytes(recipientPublicKeys.kyberPublicKey), kyberCipherText, new Uint8Array([Number(cryptoProtocolVersion)]));
		const inputKeyMaterial = concat(eccSharedSecret.ephemeralSharedSecret, eccSharedSecret.authSharedSecret, kyberSharedSecret);
		const kekBytes = hkdf(context, inputKeyMaterial, stringToUtf8Uint8Array("kek"), KEY_LENGTH_BYTES_AES_256);
		return uint8ArrayToKey(kekBytes);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/KeyLoaderFacade.ts
var KeyLoaderFacade = class {
	constructor(keyCache, userFacade, entityClient, cacheManagementFacade) {
		this.keyCache = keyCache;
		this.userFacade = userFacade;
		this.entityClient = entityClient;
		this.cacheManagementFacade = cacheManagementFacade;
	}
	/**
	* Load the symmetric group key for the groupId with the provided requestedVersion.
	* @param groupId the id of the group
	* @param requestedVersion the requestedVersion of the key to be loaded
	* @param currentGroupKey needs to be set if the user is not a member of the group (e.g. an admin)
	*/
	async loadSymGroupKey(groupId, requestedVersion, currentGroupKey) {
		if (currentGroupKey != null && currentGroupKey.version < requestedVersion) throw new Error(`Provided current group key is too old (${currentGroupKey.version}) to load the requested version ${requestedVersion} for group ${groupId}`);
		const groupKey = currentGroupKey ?? await this.getCurrentSymGroupKey(groupId);
		if (groupKey.version === requestedVersion) return groupKey.object;
else if (groupKey.version < requestedVersion) {
			await (await this.cacheManagementFacade()).refreshKeyCache(groupId);
			const refreshedGroupKey = await this.getCurrentSymGroupKey(groupId);
			return this.loadSymGroupKey(groupId, requestedVersion, refreshedGroupKey);
		} else {
			const group = await this.entityClient.load(GroupTypeRef, groupId);
			const { symmetricGroupKey } = await this.findFormerGroupKey(group, groupKey, requestedVersion);
			return symmetricGroupKey;
		}
	}
	async getCurrentSymGroupKey(groupId) {
		if (isSameId(groupId, this.userFacade.getUserGroupId())) return this.getCurrentSymUserGroupKey();
		return this.keyCache.getCurrentGroupKey(groupId, () => this.loadAndDecryptCurrentSymGroupKey(groupId));
	}
	async loadSymUserGroupKey(requestedVersion) {
		let currentUserGroupKey = this.getCurrentSymUserGroupKey();
		if (currentUserGroupKey.version < requestedVersion) {
			await (await this.cacheManagementFacade()).refreshKeyCache(this.userFacade.getUserGroupId());
			currentUserGroupKey = this.getCurrentSymUserGroupKey();
		}
		return this.loadSymGroupKey(this.userFacade.getUserGroupId(), requestedVersion, currentUserGroupKey);
	}
	getCurrentSymUserGroupKey() {
		return this.userFacade.getCurrentUserGroupKey();
	}
	async loadKeypair(keyPairGroupId, requestedVersion) {
		let group = await this.entityClient.load(GroupTypeRef, keyPairGroupId);
		let currentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId);
		if (requestedVersion > currentGroupKey.version) {
			group = (await (await this.cacheManagementFacade()).refreshKeyCache(keyPairGroupId)).group;
			currentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId);
		}
		return await this.loadKeyPairImpl(group, requestedVersion, currentGroupKey);
	}
	async loadCurrentKeyPair(groupId) {
		let group = await this.entityClient.load(GroupTypeRef, groupId);
		let currentGroupKey = await this.getCurrentSymGroupKey(groupId);
		if (Number(group.groupKeyVersion) !== currentGroupKey.version) {
			group = (await (await this.cacheManagementFacade()).refreshKeyCache(groupId)).group;
			currentGroupKey = await this.getCurrentSymGroupKey(groupId);
			if (Number(group.groupKeyVersion) !== currentGroupKey.version) throw new Error(`inconsistent key version state in cache and key cache for group ${groupId}`);
		}
		return {
			object: this.validateAndDecryptKeyPair(group.currentKeys, groupId, currentGroupKey.object),
			version: Number(group.groupKeyVersion)
		};
	}
	async loadKeyPairImpl(group, requestedVersion, currentGroupKey) {
		const keyPairGroupId = group._id;
		let keyPair;
		let symGroupKey;
		if (requestedVersion > currentGroupKey.version) throw new Error(`Not possible to get newer key version than is cached for group ${keyPairGroupId}`);
else if (requestedVersion === currentGroupKey.version) {
			symGroupKey = currentGroupKey.object;
			if (Number(group.groupKeyVersion) === currentGroupKey.version) keyPair = group.currentKeys;
else {
				const formerKeysList = assertNotNull(group.formerGroupKeys).list;
				const formerGroupKey = await this.entityClient.load(GroupKeyTypeRef, [formerKeysList, stringToCustomId(String(currentGroupKey.version))]);
				keyPair = formerGroupKey.keyPair;
			}
		} else {
			const { symmetricGroupKey, groupKeyInstance } = await this.findFormerGroupKey(group, currentGroupKey, requestedVersion);
			keyPair = groupKeyInstance.keyPair;
			symGroupKey = symmetricGroupKey;
		}
		return this.validateAndDecryptKeyPair(keyPair, keyPairGroupId, symGroupKey);
	}
	/**
	*
	* @param groupId MUST NOT be the user group id!
	* @private
	*/
	async loadAndDecryptCurrentSymGroupKey(groupId) {
		if (isSameId(groupId, this.userFacade.getUserGroupId())) throw new ProgrammingError("Must not add the user group to the regular group key cache");
		const groupMembership = this.userFacade.getMembership(groupId);
		const requiredUserGroupKey = await this.loadSymUserGroupKey(Number(groupMembership.symKeyVersion));
		return {
			version: Number(groupMembership.groupKeyVersion),
			object: decryptKey(requiredUserGroupKey, groupMembership.symEncGKey)
		};
	}
	async findFormerGroupKey(group, currentGroupKey, targetKeyVersion) {
		const formerKeysList = assertNotNull(group.formerGroupKeys).list;
		const startId = stringToCustomId(String(currentGroupKey.version));
		const amountOfKeysIncludingTarget = currentGroupKey.version - targetKeyVersion;
		const formerKeys = await this.entityClient.loadRange(GroupKeyTypeRef, formerKeysList, startId, amountOfKeysIncludingTarget, true);
		let lastVersion = currentGroupKey.version;
		let lastGroupKey = currentGroupKey.object;
		let lastGroupKeyInstance = null;
		for (const formerKey of formerKeys) {
			const version = this.decodeGroupKeyVersion(getElementId(formerKey));
			if (version + 1 > lastVersion) continue;
else if (version + 1 === lastVersion) {
				lastGroupKey = decryptKey(lastGroupKey, formerKey.ownerEncGKey);
				lastVersion = version;
				lastGroupKeyInstance = formerKey;
				if (lastVersion <= targetKeyVersion) break;
			} else throw new Error(`unexpected version ${version}; expected ${lastVersion}`);
		}
		if (lastVersion !== targetKeyVersion || !lastGroupKeyInstance) throw new Error(`could not get version (last version is ${lastVersion} of ${formerKeys.length} key(s) loaded from list ${formerKeysList})`);
		return {
			symmetricGroupKey: lastGroupKey,
			groupKeyInstance: lastGroupKeyInstance
		};
	}
	decodeGroupKeyVersion(id) {
		return Number(customIdToString(id));
	}
	validateAndDecryptKeyPair(keyPair, groupId, groupKey) {
		if (keyPair == null) throw new NotFoundError(`no key pair on group ${groupId}`);
		return decryptKeyPair(groupKey, keyPair);
	}
};

//#endregion
//#region ../src/common/api/worker/facades/KeyRotationFacade.ts
assertWorkerOrNode();
var KeyRotationFacade = class {
	/**
	* @VisibleForTesting
	*/
	pendingKeyRotations;
	facadeInitializedDeferredObject;
	pendingGroupKeyUpdateIds;
	constructor(entityClient, keyLoaderFacade, pqFacade, serviceExecutor, cryptoWrapper, recoverCodeFacade, userFacade, cryptoFacade, shareFacade, groupManagementFacade, asymmetricCryptoFacade) {
		this.entityClient = entityClient;
		this.keyLoaderFacade = keyLoaderFacade;
		this.pqFacade = pqFacade;
		this.serviceExecutor = serviceExecutor;
		this.cryptoWrapper = cryptoWrapper;
		this.recoverCodeFacade = recoverCodeFacade;
		this.userFacade = userFacade;
		this.cryptoFacade = cryptoFacade;
		this.shareFacade = shareFacade;
		this.groupManagementFacade = groupManagementFacade;
		this.asymmetricCryptoFacade = asymmetricCryptoFacade;
		this.pendingKeyRotations = {
			pwKey: null,
			adminOrUserGroupKeyRotation: null,
			teamOrCustomerGroupKeyRotations: [],
			userAreaGroupsKeyRotations: []
		};
		this.facadeInitializedDeferredObject = defer();
		this.pendingGroupKeyUpdateIds = [];
	}
	/**
	* Initialize the facade with the data it needs to perform rotations later.
	* Needs to be called during login when the password key is still available.
	* @param pwKey the user's passphrase key. May or may not be kept in memory, depending on whether a UserGroup key rotation is scheduled.
	* @param modernKdfType true if argon2id. no admin or user key rotation should be executed if false.
	*/
	async initialize(pwKey, modernKdfType) {
		const result = await this.serviceExecutor.get(GroupKeyRotationInfoService, null);
		if (result.userOrAdminGroupKeyRotationScheduled && modernKdfType) this.pendingKeyRotations.pwKey = pwKey;
		this.pendingGroupKeyUpdateIds = result.groupKeyUpdates;
		this.facadeInitializedDeferredObject.resolve();
	}
	/**
	* Processes pending key rotations and performs follow-up tasks such as updating memberships for groups rotated by another user.
	* @param user
	*/
	async processPendingKeyRotationsAndUpdates(user) {
		try {
			try {
				await this.loadPendingKeyRotations(user);
				await this.processPendingKeyRotation(user);
			} finally {
				await this.updateGroupMemberships(this.pendingGroupKeyUpdateIds);
			}
		} catch (e) {
			if (e instanceof LockedError) console.log("error when processing key rotation or group key update", e);
else throw e;
		}
	}
	/**
	* Queries the server for pending key rotations for a given user and saves them and optionally the given password key (in case an admin or user group needs to be rotated).
	*
	* Note that this function currently makes 2 server requests to load the key rotation list and check if a key rotation is needed.
	* This routine should be optimized in the future by saving a flag on the user to determine whether a key rotation is required or not.
	* @VisibleForTesting
	*/
	async loadPendingKeyRotations(user) {
		const userGroupRoot = await this.entityClient.load(UserGroupRootTypeRef, user.userGroup.group);
		if (userGroupRoot.keyRotations != null) {
			const pendingKeyRotations = await this.entityClient.loadAll(KeyRotationTypeRef, userGroupRoot.keyRotations.list);
			const keyRotationsByType = groupBy(pendingKeyRotations, (keyRotation) => keyRotation.groupKeyRotationType);
			let adminOrUserGroupKeyRotationArray = [
				keyRotationsByType.get(GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount),
				keyRotationsByType.get(GroupKeyRotationType.AdminGroupKeyRotationMultipleUserAccount),
				keyRotationsByType.get(GroupKeyRotationType.AdminGroupKeyRotationMultipleAdminAccount),
				keyRotationsByType.get(GroupKeyRotationType.User)
			].flat().filter(isNotNull);
			let customerGroupKeyRotationArray = keyRotationsByType.get(GroupKeyRotationType.Customer) || [];
			const adminOrUserGroupKeyRotation = adminOrUserGroupKeyRotationArray[0];
			this.pendingKeyRotations = {
				pwKey: this.pendingKeyRotations.pwKey,
				adminOrUserGroupKeyRotation: adminOrUserGroupKeyRotation ? adminOrUserGroupKeyRotation : null,
				teamOrCustomerGroupKeyRotations: customerGroupKeyRotationArray.concat(keyRotationsByType.get(GroupKeyRotationType.Team) || []),
				userAreaGroupsKeyRotations: keyRotationsByType.get(GroupKeyRotationType.UserArea) || []
			};
		}
	}
	/**
	* Processes the internal list of @PendingKeyRotation. Key rotations and (if existent) password keys are deleted after processing.
	* @VisibleForTesting
	*/
	async processPendingKeyRotation(user) {
		await this.facadeInitializedDeferredObject.promise;
		try {
			if (this.pendingKeyRotations.adminOrUserGroupKeyRotation && this.pendingKeyRotations.pwKey) {
				const groupKeyRotationType = assertEnumValue(GroupKeyRotationType, this.pendingKeyRotations.adminOrUserGroupKeyRotation.groupKeyRotationType);
				switch (groupKeyRotationType) {
					case GroupKeyRotationType.AdminGroupKeyRotationMultipleAdminAccount:
						console.log("Rotating the admin group with multiple members is not yet implemented");
						break;
					case GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount:
					case GroupKeyRotationType.AdminGroupKeyRotationMultipleUserAccount:
						await this.rotateAdminGroupKeys(user, this.pendingKeyRotations.pwKey, this.pendingKeyRotations.adminOrUserGroupKeyRotation);
						break;
					case GroupKeyRotationType.User:
						await this.rotateUserGroupKey(user, this.pendingKeyRotations.pwKey, this.pendingKeyRotations.adminOrUserGroupKeyRotation);
						break;
				}
				this.pendingKeyRotations.adminOrUserGroupKeyRotation = null;
			}
		} finally {
			this.pendingKeyRotations.pwKey = null;
		}
		const serviceData = createGroupKeyRotationPostIn({ groupKeyUpdates: [] });
		if (!isEmpty(this.pendingKeyRotations.teamOrCustomerGroupKeyRotations)) {
			const groupKeyRotationData = await this.rotateCustomerOrTeamGroupKeys(user);
			if (groupKeyRotationData != null) serviceData.groupKeyUpdates = groupKeyRotationData;
			this.pendingKeyRotations.teamOrCustomerGroupKeyRotations = [];
		}
		let invitationData = [];
		if (!isEmpty(this.pendingKeyRotations.userAreaGroupsKeyRotations)) {
			const { groupKeyRotationData, preparedReInvites } = await this.rotateUserAreaGroupKeys(user);
			invitationData = preparedReInvites;
			if (groupKeyRotationData != null) serviceData.groupKeyUpdates = serviceData.groupKeyUpdates.concat(groupKeyRotationData);
			this.pendingKeyRotations.userAreaGroupsKeyRotations = [];
		}
		if (serviceData.groupKeyUpdates.length <= 0) return;
		await this.serviceExecutor.post(GroupKeyRotationService, serviceData);
		if (!isEmpty(invitationData)) {
			const shareFacade = await this.shareFacade();
			await pMap(invitationData, (preparedInvite) => shareFacade.sendGroupInvitationRequest(preparedInvite));
		}
	}
	/**
	* @VisibleForTesting
	*/
	async rotateAdminGroupKeys(user, passphraseKey, keyRotation) {
		if (hasNonQuantumSafeKeys(passphraseKey)) {
			console.log("Not allowed to rotate admin group keys with a bcrypt password key");
			return;
		}
		const currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey();
		const adminGroupMembership = getFirstOrThrow(getUserGroupMemberships(user, GroupType.Admin));
		const currentAdminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupMembership.group);
		const adminKeyRotationData = await this.prepareKeyRotationForAdminGroup(keyRotation, user, currentUserGroupKey, currentAdminGroupKey, passphraseKey);
		return this.serviceExecutor.post(AdminGroupKeyRotationService, adminKeyRotationData);
	}
	async rotateUserAreaGroupKeys(user) {
		const currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey();
		if (hasNonQuantumSafeKeys(currentUserGroupKey.object)) {
			console.log("Keys cannot be rotated as the encrypting keys are not pq secure");
			return {
				groupKeyRotationData: [],
				preparedReInvites: []
			};
		}
		const groupKeyUpdates = new Array();
		let preparedReInvites = [];
		for (const keyRotation of this.pendingKeyRotations.userAreaGroupsKeyRotations) {
			const { groupKeyRotationData, preparedReInvitations } = await this.prepareKeyRotationForAreaGroup(keyRotation, currentUserGroupKey, user);
			groupKeyUpdates.push(groupKeyRotationData);
			preparedReInvites = preparedReInvites.concat(preparedReInvitations);
		}
		return {
			groupKeyRotationData: groupKeyUpdates,
			preparedReInvites
		};
	}
	async rotateCustomerOrTeamGroupKeys(user) {
		const adminGroupMembership = user.memberships.find((m) => m.groupType === GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount);
		if (adminGroupMembership == null) {
			console.log("Only admin user can rotate the group");
			return;
		}
		const currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey();
		const currentAdminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupMembership.group);
		if (hasNonQuantumSafeKeys(currentUserGroupKey.object, currentAdminGroupKey.object)) {
			console.log("Keys cannot be rotated as the encrypting keys are not pq secure");
			return;
		}
		const groupKeyUpdates = new Array();
		for (const keyRotation of this.pendingKeyRotations.teamOrCustomerGroupKeyRotations) {
			const groupKeyRotationData = await this.prepareKeyRotationForCustomerOrTeamGroup(keyRotation, currentUserGroupKey, currentAdminGroupKey, user);
			groupKeyUpdates.push(groupKeyRotationData);
		}
		return groupKeyUpdates;
	}
	async prepareKeyRotationForAdminGroup(keyRotation, user, currentUserGroupKey, currentAdminGroupKey, passphraseKey) {
		const adminGroupId = this.getTargetGroupId(keyRotation);
		const userGroupMembership = user.userGroup;
		const userGroupId = userGroupMembership.group;
		console.log(`KeyRotationFacade: rotate key for group: ${adminGroupId}, groupKeyRotationType: ${keyRotation.groupKeyRotationType}`);
		const adminGroup = await this.entityClient.load(GroupTypeRef, adminGroupId);
		const userGroup = await this.entityClient.load(GroupTypeRef, userGroupId);
		const newAdminGroupKeys = await this.generateGroupKeys(adminGroup);
		const adminKeyPair = assertNotNull(newAdminGroupKeys.encryptedKeyPair);
		const pubEccKey = assertNotNull(adminKeyPair.pubEccKey);
		const pubKyberKey = assertNotNull(adminKeyPair.pubKyberKey);
		const adminGroupKeyAuthenticationDataList = await this.generateEncryptedKeyHashes(pubEccKey, pubKyberKey, newAdminGroupKeys.symGroupKey.version, adminGroupId, assertNotNull(user.customer), userGroupId);
		const newUserGroupKeys = await this.generateGroupKeys(userGroup);
		const encryptedAdminKeys = await this.encryptGroupKeys(adminGroup, currentAdminGroupKey, newAdminGroupKeys, newAdminGroupKeys.symGroupKey);
		const encryptedUserKeys = await this.encryptUserGroupKey(userGroup, currentUserGroupKey, newUserGroupKeys, passphraseKey, newAdminGroupKeys, user);
		const membershipEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newUserGroupKeys.symGroupKey, newAdminGroupKeys.symGroupKey.object);
		const adminGroupKeyData = createGroupKeyRotationData({
			adminGroupEncGroupKey: assertNotNull(encryptedAdminKeys.adminGroupKeyEncNewGroupKey).key,
			adminGroupKeyVersion: String(assertNotNull(encryptedAdminKeys.adminGroupKeyEncNewGroupKey).encryptingKeyVersion),
			groupEncPreviousGroupKey: encryptedAdminKeys.newGroupKeyEncCurrentGroupKey.key,
			groupKeyVersion: String(newAdminGroupKeys.symGroupKey.version),
			group: adminGroup._id,
			keyPair: makeKeyPair(encryptedAdminKeys.keyPair),
			groupKeyUpdatesForMembers: [],
			groupMembershipUpdateData: [createGroupMembershipUpdateData({
				userId: user._id,
				userEncGroupKey: membershipEncNewGroupKey.key,
				userKeyVersion: String(membershipEncNewGroupKey.encryptingKeyVersion)
			})]
		});
		const userGroupKeyData = createUserGroupKeyRotationData({
			recoverCodeData: encryptedUserKeys.recoverCodeData,
			distributionKeyEncUserGroupKey: encryptedUserKeys.distributionKeyEncNewUserGroupKey,
			authVerifier: encryptedUserKeys.authVerifier,
			group: userGroup._id,
			userGroupEncPreviousGroupKey: encryptedUserKeys.newUserGroupKeyEncCurrentGroupKey.key,
			userGroupKeyVersion: String(newUserGroupKeys.symGroupKey.version),
			keyPair: encryptedUserKeys.keyPair,
			adminGroupEncUserGroupKey: encryptedUserKeys.newAdminGroupKeyEncNewUserGroupKey.key,
			adminGroupKeyVersion: String(encryptedUserKeys.newAdminGroupKeyEncNewUserGroupKey.encryptingKeyVersion),
			passphraseEncUserGroupKey: encryptedUserKeys.passphraseKeyEncNewUserGroupKey.key,
			pubAdminGroupEncUserGroupKey: null
		});
		return createAdminGroupKeyRotationPostIn({
			adminGroupKeyData,
			userGroupKeyData,
			adminGroupKeyAuthenticationDataList
		});
	}
	async generateEncryptedKeyHashes(pubEccKey, pubKyberKey, adminGroupKeyVersion, adminGroupId, customerId, groupToExclude) {
		const keyHash = this.generateKeyHash(adminGroupKeyVersion, adminGroupId, pubEccKey, pubKyberKey);
		const keyHashes = [];
		const customer = await this.entityClient.load(CustomerTypeRef, customerId);
		const userGroupInfos = await this.entityClient.loadAll(GroupInfoTypeRef, customer.userGroups);
		for (const userGroupInfo of userGroupInfos) {
			if (isSameId(userGroupInfo.group, groupToExclude)) continue;
			let gmf = await this.groupManagementFacade();
			const userGroupKey = await gmf.getCurrentGroupKeyViaAdminEncGKey(userGroupInfo.group);
			const authKey = this.deriveRotationHashKey(userGroupInfo.group, userGroupKey);
			const encryptedKeyHash = this.cryptoWrapper.aesEncrypt(authKey, keyHash);
			const publicKeyHash = createAdminGroupKeyAuthenticationData({
				userGroup: userGroupInfo.group,
				authKeyEncAdminRotationHash: encryptedKeyHash,
				version: String(adminGroupKeyVersion)
			});
			keyHashes.push(publicKeyHash);
		}
		return keyHashes;
	}
	deriveRotationHashKey(userGroupId, userGroupKey) {
		return this.cryptoWrapper.deriveKeyWithHkdf({
			salt: userGroupId,
			key: userGroupKey.object,
			context: "adminGroupKeyRotationHash"
		});
	}
	generateKeyHash(adminGroupKeyVersion, adminGroupId, pubEccKey, pubKyberKey) {
		const versionByte = Uint8Array.from([0]);
		const adminKeyVersion = Uint8Array.from([adminGroupKeyVersion]);
		const identifierType = Uint8Array.from([Number(PublicKeyIdentifierType.GROUP_ID)]);
		const identifier = customIdToUint8array(adminGroupId);
		const hashData = concat(versionByte, pubEccKey, pubKyberKey, adminKeyVersion, identifier, identifierType);
		return this.cryptoWrapper.sha256Hash(hashData);
	}
	async prepareKeyRotationForAreaGroup(keyRotation, currentUserGroupKey, user) {
		const targetGroupId = this.getTargetGroupId(keyRotation);
		console.log(`KeyRotationFacade: rotate key for group: ${targetGroupId}, groupKeyRotationType: ${keyRotation.groupKeyRotationType}`);
		const targetGroup = await this.entityClient.load(GroupTypeRef, targetGroupId);
		const currentGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(targetGroupId);
		const newGroupKeys = await this.generateGroupKeys(targetGroup);
		const groupEncPreviousGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newGroupKeys.symGroupKey, currentGroupKey.object);
		const membershipSymEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(currentUserGroupKey, newGroupKeys.symGroupKey.object);
		const preparedReInvitations = await this.handlePendingInvitations(targetGroup, newGroupKeys.symGroupKey);
		const groupKeyUpdatesForMembers = await this.createGroupKeyUpdatesForMembers(targetGroup, newGroupKeys.symGroupKey);
		const groupKeyRotationData = createGroupKeyRotationData({
			adminGroupEncGroupKey: null,
			adminGroupKeyVersion: null,
			group: targetGroupId,
			groupKeyVersion: String(newGroupKeys.symGroupKey.version),
			groupEncPreviousGroupKey: groupEncPreviousGroupKey.key,
			keyPair: makeKeyPair(newGroupKeys.encryptedKeyPair),
			groupKeyUpdatesForMembers,
			groupMembershipUpdateData: [createGroupMembershipUpdateData({
				userId: user._id,
				userEncGroupKey: membershipSymEncNewGroupKey.key,
				userKeyVersion: String(currentUserGroupKey.version)
			})]
		});
		return {
			groupKeyRotationData,
			preparedReInvitations
		};
	}
	async prepareKeyRotationForCustomerOrTeamGroup(keyRotation, currentUserGroupKey, currentAdminGroupKey, user) {
		const targetGroupId = this.getTargetGroupId(keyRotation);
		console.log(`KeyRotationFacade: rotate key for group: ${targetGroupId}, groupKeyRotationType: ${keyRotation.groupKeyRotationType}`);
		const targetGroup = await this.entityClient.load(GroupTypeRef, targetGroupId);
		const members = await this.entityClient.loadAll(GroupMemberTypeRef, targetGroup.members);
		const ownMember = members.find((member) => member.user == user._id);
		const otherMembers = members.filter((member) => member.user != user._id);
		let currentGroupKey = await this.getCurrentGroupKey(targetGroupId, targetGroup);
		const newGroupKeys = await this.generateGroupKeys(targetGroup);
		const encryptedGroupKeys = await this.encryptGroupKeys(targetGroup, currentGroupKey, newGroupKeys, currentAdminGroupKey);
		const groupMembershipUpdateData = new Array();
		if (ownMember) {
			const membershipSymEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(currentUserGroupKey, newGroupKeys.symGroupKey.object);
			groupMembershipUpdateData.push(createGroupMembershipUpdateData({
				userId: user._id,
				userEncGroupKey: membershipSymEncNewGroupKey.key,
				userKeyVersion: String(currentUserGroupKey.version)
			}));
		}
		for (const member of otherMembers) {
			const userEncNewGroupKey = await this.encryptGroupKeyForOtherUsers(member.user, newGroupKeys.symGroupKey);
			let groupMembershipUpdate = createGroupMembershipUpdateData({
				userId: member.user,
				userEncGroupKey: userEncNewGroupKey.key,
				userKeyVersion: String(userEncNewGroupKey.encryptingKeyVersion)
			});
			groupMembershipUpdateData.push(groupMembershipUpdate);
		}
		return createGroupKeyRotationData({
			adminGroupEncGroupKey: encryptedGroupKeys.adminGroupKeyEncNewGroupKey ? encryptedGroupKeys.adminGroupKeyEncNewGroupKey.key : null,
			adminGroupKeyVersion: encryptedGroupKeys.adminGroupKeyEncNewGroupKey ? String(encryptedGroupKeys.adminGroupKeyEncNewGroupKey.encryptingKeyVersion) : null,
			group: targetGroupId,
			groupKeyVersion: String(newGroupKeys.symGroupKey.version),
			groupEncPreviousGroupKey: encryptedGroupKeys.newGroupKeyEncCurrentGroupKey.key,
			keyPair: makeKeyPair(encryptedGroupKeys.keyPair),
			groupKeyUpdatesForMembers: [],
			groupMembershipUpdateData
		});
	}
	async getCurrentGroupKey(targetGroupId, targetGroup) {
		try {
			return await this.keyLoaderFacade.getCurrentSymGroupKey(targetGroupId);
		} catch (e) {
			const groupManagementFacade = await this.groupManagementFacade();
			const currentKey = await groupManagementFacade.getGroupKeyViaAdminEncGKey(targetGroupId, Number(targetGroup.groupKeyVersion));
			return {
				object: currentKey,
				version: Number(targetGroup.groupKeyVersion)
			};
		}
	}
	async encryptUserGroupKey(userGroup, currentUserGroupKey, newUserGroupKeys, passphraseKey, newAdminGroupKeys, user) {
		const { membershipSymEncNewGroupKey, distributionKeyEncNewUserGroupKey, authVerifier } = this.encryptUserGroupKeyForUser(passphraseKey, newUserGroupKeys, userGroup, currentUserGroupKey);
		const encryptedUserKeys = await this.encryptGroupKeys(userGroup, currentUserGroupKey, newUserGroupKeys, newAdminGroupKeys.symGroupKey);
		const recoverCodeData = await this.reencryptRecoverCodeIfExists(user, passphraseKey, newUserGroupKeys);
		return {
			newUserGroupKeyEncCurrentGroupKey: encryptedUserKeys.newGroupKeyEncCurrentGroupKey,
			newAdminGroupKeyEncNewUserGroupKey: assertNotNull(encryptedUserKeys.adminGroupKeyEncNewGroupKey),
			keyPair: assertNotNull(makeKeyPair(encryptedUserKeys.keyPair)),
			passphraseKeyEncNewUserGroupKey: membershipSymEncNewGroupKey,
			recoverCodeData,
			distributionKeyEncNewUserGroupKey,
			authVerifier
		};
	}
	async reencryptRecoverCodeIfExists(user, passphraseKey, newUserGroupKeys) {
		let recoverCodeData = null;
		if (user.auth?.recoverCode != null) {
			const recoverCodeFacade = await this.recoverCodeFacade();
			const recoverCode = await recoverCodeFacade.getRawRecoverCode(passphraseKey);
			const recoverData = recoverCodeFacade.encryptRecoveryCode(recoverCode, newUserGroupKeys.symGroupKey);
			recoverCodeData = createRecoverCodeData({
				recoveryCodeVerifier: recoverData.recoveryCodeVerifier,
				userEncRecoveryCode: recoverData.userEncRecoverCode,
				userKeyVersion: String(recoverData.userKeyVersion),
				recoveryCodeEncUserGroupKey: recoverData.recoverCodeEncUserGroupKey
			});
		}
		return recoverCodeData;
	}
	encryptUserGroupKeyForUser(passphraseKey, newUserGroupKeys, userGroup, currentGroupKey) {
		const versionedPassphraseKey = {
			object: passphraseKey,
			version: 0
		};
		const membershipSymEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(versionedPassphraseKey, newUserGroupKeys.symGroupKey.object);
		const userGroupKeyDistributionKey = this.userFacade.deriveUserGroupKeyDistributionKey(userGroup._id, passphraseKey);
		const distributionKeyEncNewUserGroupKey = this.cryptoWrapper.encryptKey(userGroupKeyDistributionKey, newUserGroupKeys.symGroupKey.object);
		const authVerifier = createAuthVerifier(passphraseKey);
		const newGroupKeyEncCurrentGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newUserGroupKeys.symGroupKey, currentGroupKey.object);
		return {
			membershipSymEncNewGroupKey,
			distributionKeyEncNewUserGroupKey,
			authVerifier,
			newGroupKeyEncCurrentGroupKey
		};
	}
	async handlePendingInvitations(targetGroup, newTargetGroupKey) {
		const preparedReInvitations = [];
		const targetGroupInfo = await this.entityClient.load(GroupInfoTypeRef, targetGroup.groupInfo);
		const pendingInvitations = await this.entityClient.loadAll(SentGroupInvitationTypeRef, targetGroup.invitations);
		const sentInvitationsByCapability = groupBy(pendingInvitations, (invitation) => invitation.capability);
		const shareFacade = await this.shareFacade();
		for (const [capability, sentInvitations] of sentInvitationsByCapability) {
			const inviteeMailAddresses = sentInvitations.map((invite) => invite.inviteeMailAddress);
			const prepareGroupReInvites = async (mailAddresses) => {
				const preparedInvitation = await shareFacade.prepareGroupInvitation(newTargetGroupKey, targetGroupInfo, mailAddresses, downcast(capability));
				preparedReInvitations.push(preparedInvitation);
			};
			try {
				await prepareGroupReInvites(inviteeMailAddresses);
			} catch (e) {
				if (e instanceof RecipientsNotFoundError) {
					const notFoundRecipients = e.message.split("\n");
					const reducedInviteeAddresses = inviteeMailAddresses.filter((address) => !notFoundRecipients.includes(address));
					if (reducedInviteeAddresses.length) await prepareGroupReInvites(reducedInviteeAddresses);
				} else throw e;
			}
		}
		return preparedReInvitations;
	}
	async createGroupKeyUpdatesForMembers(group, newGroupKey) {
		const members = await this.entityClient.loadAll(GroupMemberTypeRef, group.members);
		const otherMembers = members.filter((member) => member.user != this.userFacade.getUser()?._id);
		return await this.tryCreatingGroupKeyUpdatesForMembers(group._id, otherMembers, newGroupKey);
	}
	async tryCreatingGroupKeyUpdatesForMembers(groupId, otherMembers, newGroupKey) {
		const groupKeyUpdates = new Array();
		const groupedMembers = groupBy(otherMembers, (member) => listIdPart(member.userGroupInfo));
		const membersToRemove = new Array();
		for (const [listId, members] of groupedMembers) {
			const userGroupInfos = await this.entityClient.loadMultiple(GroupInfoTypeRef, listId, members.map((member) => elementIdPart(member.userGroupInfo)));
			for (const member of members) {
				const userGroupInfoForMember = userGroupInfos.find((ugi) => isSameId(ugi._id, member.userGroupInfo));
				const memberMailAddress = assertNotNull(userGroupInfoForMember?.mailAddress);
				const bucketKey = this.cryptoWrapper.aes256RandomKey();
				const sessionKey = this.cryptoWrapper.aes256RandomKey();
				const notFoundRecipients = [];
				const recipientKeyData = await this.cryptoFacade.encryptBucketKeyForInternalRecipient(this.userFacade.getUserGroupId(), bucketKey, memberMailAddress, notFoundRecipients);
				if (recipientKeyData != null && isSameTypeRef(recipientKeyData._type, InternalRecipientKeyDataTypeRef)) {
					const keyData = recipientKeyData;
					const pubEncKeyData = createPubEncKeyData({
						recipientIdentifier: keyData.mailAddress,
						recipientIdentifierType: PublicKeyIdentifierType.MAIL_ADDRESS,
						pubEncSymKey: keyData.pubEncBucketKey,
						recipientKeyVersion: keyData.recipientKeyVersion,
						senderKeyVersion: keyData.senderKeyVersion,
						protocolVersion: keyData.protocolVersion
					});
					const groupKeyUpdateData = createGroupKeyUpdateData({
						sessionKeyEncGroupKey: this.cryptoWrapper.encryptBytes(sessionKey, bitArrayToUint8Array(newGroupKey.object)),
						sessionKeyEncGroupKeyVersion: String(newGroupKey.version),
						bucketKeyEncSessionKey: this.cryptoWrapper.encryptKey(bucketKey, sessionKey),
						pubEncBucketKeyData: pubEncKeyData
					});
					groupKeyUpdates.push(groupKeyUpdateData);
				} else membersToRemove.push(member);
			}
		}
		const groupManagementFacade = await this.groupManagementFacade();
		if (membersToRemove.length !== 0) {
			for (const member of membersToRemove) await groupManagementFacade.removeUserFromGroup(member.user, groupId);
			const reducedMembers = otherMembers.filter((member) => !membersToRemove.includes(member));
			return this.tryCreatingGroupKeyUpdatesForMembers(groupId, reducedMembers, newGroupKey);
		} else return groupKeyUpdates;
	}
	/**
	* Get the ID of the group we want to rotate the keys for.
	*/
	getTargetGroupId(keyRotation) {
		return elementIdPart(keyRotation._id);
	}
	async encryptGroupKeys(group, currentGroupKey, newKeys, adminGroupKeys) {
		const newGroupKeyEncCurrentGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newKeys.symGroupKey, currentGroupKey.object);
		const adminGroupKeyEncNewGroupKey = (await this.groupManagementFacade()).hasAdminEncGKey(group) ? this.cryptoWrapper.encryptKeyWithVersionedKey(adminGroupKeys, newKeys.symGroupKey.object) : null;
		return {
			newGroupKeyEncCurrentGroupKey,
			keyPair: newKeys.encryptedKeyPair,
			adminGroupKeyEncNewGroupKey
		};
	}
	async encryptGroupKeyForOtherUsers(userId, newGroupKey) {
		const groupManagementFacade = await this.groupManagementFacade();
		const user = await this.entityClient.load(UserTypeRef, userId);
		const userGroupKey = await groupManagementFacade.getGroupKeyViaAdminEncGKey(user.userGroup.group, Number(user.userGroup.groupKeyVersion));
		const encrypteNewGroupKey = this.cryptoWrapper.encryptKey(userGroupKey, newGroupKey.object);
		return {
			key: encrypteNewGroupKey,
			encryptingKeyVersion: Number(user.userGroup.groupKeyVersion)
		};
	}
	async generateGroupKeys(group) {
		const symGroupKeyBytes = this.cryptoWrapper.aes256RandomKey();
		const keyPair = await this.createNewKeyPairValue(group, symGroupKeyBytes);
		return {
			symGroupKey: {
				object: symGroupKeyBytes,
				version: Number(group.groupKeyVersion) + 1
			},
			encryptedKeyPair: keyPair
		};
	}
	/**
	* Not all groups have key pairs, but if they do we need to rotate them as well.
	*/
	async createNewKeyPairValue(groupToRotate, newSymmetricGroupKey) {
		if (groupToRotate.currentKeys) {
			const newPqPairs = await this.pqFacade.generateKeyPairs();
			return {
				pubRsaKey: null,
				symEncPrivRsaKey: null,
				pubEccKey: newPqPairs.eccKeyPair.publicKey,
				symEncPrivEccKey: this.cryptoWrapper.encryptEccKey(newSymmetricGroupKey, newPqPairs.eccKeyPair.privateKey),
				pubKyberKey: this.cryptoWrapper.kyberPublicKeyToBytes(newPqPairs.kyberKeyPair.publicKey),
				symEncPrivKyberKey: this.cryptoWrapper.encryptKyberKey(newSymmetricGroupKey, newPqPairs.kyberKeyPair.privateKey)
			};
		} else return null;
	}
	/**
	* @VisibleForTesting
	* @private
	*/
	setPendingKeyRotations(pendingKeyRotations) {
		this.pendingKeyRotations = pendingKeyRotations;
		this.facadeInitializedDeferredObject.resolve();
	}
	async reset() {
		await this.facadeInitializedDeferredObject.promise;
		this.pendingKeyRotations = {
			pwKey: null,
			adminOrUserGroupKeyRotation: null,
			teamOrCustomerGroupKeyRotations: [],
			userAreaGroupsKeyRotations: []
		};
	}
	/**
	*
	* @param groupKeyUpdateIds MUST be in the same list
	*/
	async updateGroupMemberships(groupKeyUpdateIds) {
		if (groupKeyUpdateIds.length < 1) return;
		console.log("handling group key update for groups: ", groupKeyUpdateIds);
		const groupKeyUpdateInstances = await this.entityClient.loadMultiple(GroupKeyUpdateTypeRef, listIdPart(groupKeyUpdateIds[0]), groupKeyUpdateIds.map((id) => elementIdPart(id)));
		const groupKeyUpdates = groupKeyUpdateInstances.map((update) => this.prepareGroupMembershipUpdate(update));
		const membershipPutIn = createMembershipPutIn({ groupKeyUpdates });
		return this.serviceExecutor.put(MembershipService, membershipPutIn);
	}
	prepareGroupMembershipUpdate(groupKeyUpdate) {
		const userGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey();
		const symEncGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(userGroupKey, uint8ArrayToKey(groupKeyUpdate.groupKey));
		return createGroupMembershipKeyData({
			group: elementIdPart(groupKeyUpdate._id),
			symEncGKey: symEncGroupKey.key,
			groupKeyVersion: groupKeyUpdate.groupKeyVersion,
			symKeyVersion: String(userGroupKey.version)
		});
	}
	/**
	* This function is responsible for upgrading the encryption keys of any user according to a GroupKeyRotation object
	* Before rotating the keys the user will check that the admin hash created by the admin and encrypted with this user
	* group key matches the hash generated by the user for this rotation.
	*
	* @param user
	* @param pwKey
	* @param userGroupKeyRotation
	* @private
	*/
	async rotateUserGroupKey(user, pwKey, userGroupKeyRotation) {
		const userGroupMembership = user.userGroup;
		const userGroupId = userGroupMembership.group;
		const currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey();
		console.log(`KeyRotationFacade: rotate key for group: ${userGroupId}, groupKeyRotationType: ${userGroupKeyRotation.groupKeyRotationType}`);
		if (userGroupKeyRotation.adminGroupKeyAuthenticationData == null) throw new Error("The hash encrypted by admin is not present in the user group key rotation !");
		const { version: adminGroupKeyVersion, authKeyEncAdminRotationHash } = userGroupKeyRotation.adminGroupKeyAuthenticationData;
		const authKey = this.deriveRotationHashKey(userGroupId, currentUserGroupKey);
		const decryptedAdminHash = this.cryptoWrapper.aesDecrypt(authKey, authKeyEncAdminRotationHash, true);
		const userGroup = await this.entityClient.load(GroupTypeRef, userGroupId);
		const adminGroupId = assertNotNull(userGroup.admin);
		const adminPublicKeyGetIn = createPublicKeyGetIn({
			identifier: adminGroupId,
			identifierType: PublicKeyIdentifierType.GROUP_ID,
			version: null
		});
		const adminPublicKeyGetOut = await this.serviceExecutor.get(PublicKeyService, adminPublicKeyGetIn);
		const { pubEccKey, pubKyberKey } = adminPublicKeyGetOut;
		if (pubEccKey == null) throw new Error("tried to generate a keyhash when rotating but received an empty public ecc key!");
		if (pubKyberKey == null) throw new Error("tried to generate a keyhash when rotating but received an empty public kyber key!");
		const clientGeneratedKeyHash = this.generateKeyHash(Number(adminGroupKeyVersion), adminGroupId, pubEccKey, pubKyberKey);
		if (!arrayEquals(decryptedAdminHash, clientGeneratedKeyHash)) throw new Error("mismatch between client generated hash and encrypted admin hash, aborting rotation");
		const newUserGroupKeys = await this.generateGroupKeys(userGroup);
		const { membershipSymEncNewGroupKey, distributionKeyEncNewUserGroupKey, authVerifier, newGroupKeyEncCurrentGroupKey } = this.encryptUserGroupKeyForUser(pwKey, newUserGroupKeys, userGroup, currentUserGroupKey);
		const recoverCodeData = await this.reencryptRecoverCodeIfExists(user, pwKey, newUserGroupKeys);
		const pubAdminGroupEncUserGroupKey = await this.encryptUserGroupKeyForAdmin(newUserGroupKeys, adminPublicKeyGetOut, adminGroupId);
		const userGroupKeyData = createUserGroupKeyRotationData({
			userGroupKeyVersion: String(newUserGroupKeys.symGroupKey.version),
			userGroupEncPreviousGroupKey: newGroupKeyEncCurrentGroupKey.key,
			passphraseEncUserGroupKey: membershipSymEncNewGroupKey.key,
			group: userGroupId,
			distributionKeyEncUserGroupKey: distributionKeyEncNewUserGroupKey,
			keyPair: assertNotNull(makeKeyPair(newUserGroupKeys.encryptedKeyPair)),
			authVerifier,
			adminGroupKeyVersion: pubAdminGroupEncUserGroupKey.recipientKeyVersion,
			pubAdminGroupEncUserGroupKey,
			adminGroupEncUserGroupKey: null,
			recoverCodeData
		});
		await this.serviceExecutor.post(UserGroupKeyRotationService, createUserGroupKeyRotationPostIn({ userGroupKeyData }));
	}
	async encryptUserGroupKeyForAdmin(newUserGroupKeys, publicKeyGetOut, adminGroupId) {
		const adminPubKeys = {
			version: Number(publicKeyGetOut.pubKeyVersion),
			object: {
				pubEccKey: publicKeyGetOut.pubEccKey,
				pubKyberKey: publicKeyGetOut.pubKyberKey,
				pubRsaKey: null
			}
		};
		const pqKeyPair = this.cryptoWrapper.decryptKeyPair(newUserGroupKeys.symGroupKey.object, assertNotNull(newUserGroupKeys.encryptedKeyPair));
		const pubEncSymKey = await this.asymmetricCryptoFacade.tutaCryptEncryptSymKey(newUserGroupKeys.symGroupKey.object, adminPubKeys, {
			version: newUserGroupKeys.symGroupKey.version,
			object: pqKeyPair.eccKeyPair
		});
		return createPubEncKeyData({
			recipientIdentifier: adminGroupId,
			recipientIdentifierType: PublicKeyIdentifierType.GROUP_ID,
			pubEncSymKey: pubEncSymKey.pubEncSymKeyBytes,
			protocolVersion: pubEncSymKey.cryptoProtocolVersion,
			senderKeyVersion: pubEncSymKey.senderKeyVersion != null ? pubEncSymKey.senderKeyVersion.toString() : null,
			recipientKeyVersion: pubEncSymKey.recipientKeyVersion.toString()
		});
	}
};
/**
* We require AES keys to be 256-bit long to be quantum-safe because of Grover's algorithm.
*/
function isQuantumSafe(key) {
	return getKeyLengthBytes(key) === KEY_LENGTH_BYTES_AES_256;
}
function hasNonQuantumSafeKeys(...keys) {
	return keys.some((key) => !isQuantumSafe(key));
}
function makeKeyPair(keyPair) {
	return keyPair != null ? createKeyPair(keyPair) : null;
}

//#endregion
//#region ../src/common/api/worker/facades/KeyCache.ts
var KeyCache = class {
	currentGroupKeys = new Map();
	currentUserGroupKey = null;
	userGroupKeyDistributionKey = null;
	setCurrentUserGroupKey(newUserGroupKey) {
		if (this.currentUserGroupKey != null && this.currentUserGroupKey.version > newUserGroupKey.version) {
			console.log("Tried to set an outdated user group key");
			return;
		}
		this.currentUserGroupKey = newUserGroupKey;
	}
	getCurrentUserGroupKey() {
		return this.currentUserGroupKey;
	}
	setUserGroupKeyDistributionKey(userGroupKeyDistributionKey) {
		this.userGroupKeyDistributionKey = userGroupKeyDistributionKey;
	}
	getUserGroupKeyDistributionKey() {
		return this.userGroupKeyDistributionKey;
	}
	/**
	*
	* @param groupId MUST NOT be the user group id
	* @param keyLoader a function to load and decrypt the group key if it is not cached
	*/
	getCurrentGroupKey(groupId, keyLoader) {
		return getFromMap(this.currentGroupKeys, groupId, async () => {
			return keyLoader();
		});
	}
	reset() {
		this.currentGroupKeys = new Map();
		this.currentUserGroupKey = null;
		this.userGroupKeyDistributionKey = null;
	}
	/**
	* Clears keys from the cache which are outdated or where we do no longer hava a membership.
	* An outdated user membership is ignored and should be processed by the UserGroupKeyDistribution update.
	* @param user updated user with up-to-date memberships
	*/
	async removeOutdatedGroupKeys(user) {
		const currentUserGroupKeyVersion = neverNull(this.getCurrentUserGroupKey()).version;
		const receivedUserGroupKeyVersion = Number(user.userGroup.groupKeyVersion);
		if (receivedUserGroupKeyVersion > currentUserGroupKeyVersion) console.log(`Received user update with new user group key version: ${currentUserGroupKeyVersion} -> ${receivedUserGroupKeyVersion}`);
		const newCurrentGroupKeyCache = new Map();
		for (const membership of user.memberships) {
			const cachedGroupKey = this.currentGroupKeys.get(membership.group);
			if (cachedGroupKey != null && Number(membership.groupKeyVersion) === (await cachedGroupKey).version) await getFromMap(newCurrentGroupKeyCache, membership.group, () => cachedGroupKey);
		}
		this.currentGroupKeys = newCurrentGroupKeyCache;
	}
};

//#endregion
//#region ../src/common/api/worker/DateProvider.ts
var LocalTimeDateProvider = class {
	getStartOfDayShiftedBy(shiftByDays) {
		return getStartOfDay(getDayShifted(new Date(), shiftByDays));
	}
};

//#endregion
//#region ../src/mail-app/workerUtils/worker/WorkerLocator.ts
assertWorkerOrNode();
const locator = {};
async function initLocator(worker, browserData) {
	locator._worker = worker;
	locator._browserData = browserData;
	locator.keyCache = new KeyCache();
	locator.cryptoWrapper = new CryptoWrapper();
	locator.user = new UserFacade(locator.keyCache, locator.cryptoWrapper);
	locator.workerFacade = new WorkerFacade();
	const dateProvider = new NoZoneDateProvider();
	const mainInterface = worker.getMainInterface();
	const suspensionHandler = new SuspensionHandler(mainInterface.infoMessageHandler, self);
	locator.instanceMapper = new InstanceMapper();
	locator.rsa = await createRsaImplementation(worker);
	const domainConfig = new DomainConfigProvider().getCurrentDomainConfig();
	locator.restClient = new RestClient(suspensionHandler, domainConfig);
	locator.serviceExecutor = new ServiceExecutor(locator.restClient, locator.user, locator.instanceMapper, () => locator.crypto);
	locator.entropyFacade = new EntropyFacade(locator.user, locator.serviceExecutor, random, () => locator.keyLoader);
	locator.blobAccessToken = new BlobAccessTokenFacade(locator.serviceExecutor, locator.user, dateProvider);
	const entityRestClient = new EntityRestClient(locator.user, locator.restClient, () => locator.crypto, locator.instanceMapper, locator.blobAccessToken);
	locator.native = worker;
	locator.booking = lazyMemoized(async () => {
		const { BookingFacade } = await import("./BookingFacade-Bji9YNVq.js");
		return new BookingFacade(locator.serviceExecutor);
	});
	let offlineStorageProvider;
	if (isOfflineStorageAvailable() && !isAdminClient()) {
		locator.sqlCipherFacade = new SqlCipherFacadeSendDispatcher(locator.native);
		offlineStorageProvider = async () => {
			return new OfflineStorage(locator.sqlCipherFacade, new InterWindowEventFacadeSendDispatcher(worker), dateProvider, new OfflineStorageMigrator(OFFLINE_STORAGE_MIGRATIONS, modelInfos), new MailOfflineCleaner());
		};
	} else offlineStorageProvider = async () => null;
	locator.pdfWriter = async () => {
		const { PdfWriter } = await import("./PdfWriter-B447hHjP.js");
		return new PdfWriter(new TextEncoder(), undefined);
	};
	const maybeUninitializedStorage = new LateInitializedCacheStorageImpl(async (error) => {
		await worker.sendError(error);
	}, offlineStorageProvider);
	locator.cacheStorage = maybeUninitializedStorage;
	const fileApp = new NativeFileApp(new FileFacadeSendDispatcher(worker), new ExportFacadeSendDispatcher(worker));
	let cache = null;
	if (!isAdminClient()) cache = new DefaultEntityRestCache(entityRestClient, maybeUninitializedStorage);
	locator.cache = cache ?? entityRestClient;
	locator.cachingEntityClient = new EntityClient(locator.cache);
	const nonCachingEntityClient = new EntityClient(entityRestClient);
	locator.cacheManagement = lazyMemoized(async () => {
		const { CacheManagementFacade } = await import("./CacheManagementFacade-PpLmAIBj.js");
		return new CacheManagementFacade(locator.user, locator.cachingEntityClient, assertNotNull(cache));
	});
	/** Slightly annoying two-stage init: first import bulk loader, then we can have a factory for it. */
	const prepareBulkLoaderFactory = async () => {
		const { BulkMailLoader } = await import("./BulkMailLoader-Qz8tD3oz.js");
		return () => {
			if (isOfflineStorageAvailable()) return new BulkMailLoader(locator.cachingEntityClient, locator.cachingEntityClient, null);
else {
				const cacheStorage = new EphemeralCacheStorage();
				return new BulkMailLoader(new EntityClient(new DefaultEntityRestCache(entityRestClient, cacheStorage)), new EntityClient(entityRestClient), cacheStorage);
			}
		};
	};
	locator.bulkMailLoader = async () => {
		const factory = await prepareBulkLoaderFactory();
		return factory();
	};
	locator.indexer = lazyMemoized(async () => {
		const { Indexer } = await import("./Indexer-CEUenHus.js");
		const { MailIndexer } = await import("./MailIndexer-BK7d08jg.js");
		const mailFacade = await locator.mail();
		const bulkLoaderFactory = await prepareBulkLoaderFactory();
		return new Indexer(entityRestClient, mainInterface.infoMessageHandler, browserData, locator.cache, (core, db) => {
			const dateProvider$1 = new LocalTimeDateProvider();
			return new MailIndexer(core, db, mainInterface.infoMessageHandler, bulkLoaderFactory, locator.cachingEntityClient, dateProvider$1, mailFacade);
		});
	});
	if (isIOSApp() || isAndroidApp()) locator.kyberFacade = new NativeKyberFacade(new NativeCryptoFacadeSendDispatcher(worker));
else locator.kyberFacade = new WASMKyberFacade();
	locator.pqFacade = new PQFacade(locator.kyberFacade);
	locator.keyLoader = new KeyLoaderFacade(locator.keyCache, locator.user, locator.cachingEntityClient, locator.cacheManagement);
	locator.asymmetricCrypto = new AsymmetricCryptoFacade(locator.rsa, locator.pqFacade, locator.keyLoader, locator.cryptoWrapper, locator.serviceExecutor);
	locator.crypto = new CryptoFacade(locator.user, locator.cachingEntityClient, locator.restClient, locator.serviceExecutor, locator.instanceMapper, new OwnerEncSessionKeysUpdateQueue(locator.user, locator.serviceExecutor), cache, locator.keyLoader, locator.asymmetricCrypto);
	locator.recoverCode = lazyMemoized(async () => {
		const { RecoverCodeFacade } = await import("./RecoverCodeFacade-ks5kTH3_.js");
		return new RecoverCodeFacade(locator.user, locator.cachingEntityClient, locator.login, locator.keyLoader);
	});
	locator.share = lazyMemoized(async () => {
		const { ShareFacade } = await import("./ShareFacade-DCXzEkdE.js");
		return new ShareFacade(locator.user, locator.crypto, locator.serviceExecutor, locator.cachingEntityClient, locator.keyLoader);
	});
	locator.counters = lazyMemoized(async () => {
		const { CounterFacade } = await import("./CounterFacade-CCBCCCwe.js");
		return new CounterFacade(locator.serviceExecutor);
	});
	locator.groupManagement = lazyMemoized(async () => {
		const { GroupManagementFacade } = await import("./GroupManagementFacade-EZYCzqZy.js");
		return new GroupManagementFacade(locator.user, await locator.counters(), locator.cachingEntityClient, locator.serviceExecutor, locator.pqFacade, locator.keyLoader, await locator.cacheManagement(), locator.asymmetricCrypto, locator.cryptoWrapper);
	});
	locator.keyRotation = new KeyRotationFacade(locator.cachingEntityClient, locator.keyLoader, locator.pqFacade, locator.serviceExecutor, locator.cryptoWrapper, locator.recoverCode, locator.user, locator.crypto, locator.share, locator.groupManagement, locator.asymmetricCrypto);
	const loginListener = {
		onFullLoginSuccess(sessionType, cacheInfo, credentials) {
			if (!isTest() && sessionType !== SessionType.Temporary && !isAdminClient()) {
				console.log("initIndexer after log in");
				initIndexer(worker, cacheInfo, locator.keyLoader);
			}
			return mainInterface.loginListener.onFullLoginSuccess(sessionType, cacheInfo, credentials);
		},
		onLoginFailure(reason) {
			return mainInterface.loginListener.onLoginFailure(reason);
		},
		onSecondFactorChallenge(sessionId, challenges, mailAddress) {
			return mainInterface.loginListener.onSecondFactorChallenge(sessionId, challenges, mailAddress);
		}
	};
	let argon2idFacade;
	if (!isBrowser()) argon2idFacade = new NativeArgon2idFacade(new NativeCryptoFacadeSendDispatcher(worker));
else argon2idFacade = new WASMArgon2idFacade();
	locator.deviceEncryptionFacade = new DeviceEncryptionFacade();
	const { DatabaseKeyFactory } = await import("./DatabaseKeyFactory-DqvWWT84.js");
	locator.login = new LoginFacade(
		locator.restClient,
		/**
		* we don't want to try to use the cache in the login facade, because it may not be available (when no user is logged in)
		*/
		new EntityClient(locator.cache),
		loginListener,
		locator.instanceMapper,
		locator.crypto,
		locator.keyRotation,
		maybeUninitializedStorage,
		locator.serviceExecutor,
		locator.user,
		locator.blobAccessToken,
		locator.entropyFacade,
		new DatabaseKeyFactory(locator.deviceEncryptionFacade),
		argon2idFacade,
		nonCachingEntityClient,
		async (error) => {
			await worker.sendError(error);
		},
		locator.cacheManagement
);
	locator.search = lazyMemoized(async () => {
		const { SearchFacade } = await import("./SearchFacade-CEqIHl00.js");
		const indexer = await locator.indexer();
		const suggestionFacades = [indexer._contact.suggestionFacade];
		return new SearchFacade(locator.user, indexer.db, indexer._mail, suggestionFacades, browserData, locator.cachingEntityClient);
	});
	locator.userManagement = lazyMemoized(async () => {
		const { UserManagementFacade } = await import("./UserManagementFacade-DmePLV2w.js");
		return new UserManagementFacade(locator.user, await locator.groupManagement(), await locator.counters(), locator.cachingEntityClient, locator.serviceExecutor, mainInterface.operationProgressTracker, locator.login, locator.pqFacade, locator.keyLoader, await locator.recoverCode());
	});
	locator.customer = lazyMemoized(async () => {
		const { CustomerFacade } = await import("./CustomerFacade-CO1Vc4dd.js");
		return new CustomerFacade(locator.user, await locator.groupManagement(), await locator.userManagement(), await locator.counters(), locator.rsa, locator.cachingEntityClient, locator.serviceExecutor, await locator.booking(), locator.crypto, mainInterface.operationProgressTracker, locator.pdfWriter, locator.pqFacade, locator.keyLoader, await locator.recoverCode(), locator.asymmetricCrypto);
	});
	const aesApp = new AesApp(new NativeCryptoFacadeSendDispatcher(worker), random);
	locator.blob = lazyMemoized(async () => {
		const { BlobFacade } = await import("./BlobFacade-BE_idPec.js");
		return new BlobFacade(locator.restClient, suspensionHandler, fileApp, aesApp, locator.instanceMapper, locator.crypto, locator.blobAccessToken);
	});
	locator.mail = lazyMemoized(async () => {
		const { MailFacade } = await import("./MailFacade-CHBUUM9Q.js");
		return new MailFacade(locator.user, locator.cachingEntityClient, locator.crypto, locator.serviceExecutor, await locator.blob(), fileApp, locator.login, locator.keyLoader);
	});
	const nativePushFacade = new NativePushFacadeSendDispatcher(worker);
	locator.calendar = lazyMemoized(async () => {
		const { CalendarFacade } = await import("./CalendarFacade-C0cFsjqT.js");
		return new CalendarFacade(locator.user, await locator.groupManagement(), assertNotNull(cache), nonCachingEntityClient, nativePushFacade, mainInterface.operationProgressTracker, locator.instanceMapper, locator.serviceExecutor, locator.crypto, mainInterface.infoMessageHandler);
	});
	locator.mailAddress = lazyMemoized(async () => {
		const { MailAddressFacade } = await import("./MailAddressFacade-DFVBEXif.js");
		return new MailAddressFacade(locator.user, await locator.groupManagement(), locator.serviceExecutor, nonCachingEntityClient);
	});
	const scheduler = new SchedulerImpl(dateProvider, self, self);
	locator.configFacade = lazyMemoized(async () => {
		const { ConfigurationDatabase } = await import("./ConfigurationDatabase-DwrSB0ro.js");
		return new ConfigurationDatabase(locator.keyLoader, locator.user);
	});
	const eventBusCoordinator = new EventBusEventCoordinator(mainInterface.wsConnectivityListener, locator.mail, locator.user, locator.cachingEntityClient, mainInterface.eventController, locator.configFacade, locator.keyRotation, locator.cacheManagement, async (error) => {
		await worker.sendError(error);
	}, async (queuedBatch) => {
		const indexer = await locator.indexer();
		indexer.addBatchesToQueue(queuedBatch);
		indexer.startProcessing();
	});
	locator.eventBusClient = new EventBusClient(eventBusCoordinator, cache ?? new AdminClientDummyEntityRestCache(), locator.user, locator.cachingEntityClient, locator.instanceMapper, (path) => new WebSocket(getWebsocketBaseUrl(domainConfig) + path), new SleepDetector(scheduler, dateProvider), mainInterface.progressTracker);
	locator.login.init(locator.eventBusClient);
	locator.Const = Const;
	locator.giftCards = lazyMemoized(async () => {
		const { GiftCardFacade } = await import("./GiftCardFacade-D7h0WbTw.js");
		return new GiftCardFacade(locator.user, await locator.customer(), locator.serviceExecutor, locator.crypto, locator.keyLoader);
	});
	locator.contactFacade = lazyMemoized(async () => {
		const { ContactFacade } = await import("./ContactFacade-D-ZsVNpJ.js");
		return new ContactFacade(new EntityClient(locator.cache));
	});
	locator.mailExportFacade = lazyMemoized(async () => {
		const { MailExportFacade } = await import("./MailExportFacade-Cfo0xrmc.js");
		const { MailExportTokenFacade } = await import("./MailExportTokenFacade-EMFqxQkd.js");
		const mailExportTokenFacade = new MailExportTokenFacade(locator.serviceExecutor);
		return new MailExportFacade(mailExportTokenFacade, await locator.bulkMailLoader(), await locator.blob(), locator.crypto, locator.blobAccessToken);
	});
}
const RETRY_TIMOUT_AFTER_INIT_INDEXER_ERROR_MS = 3e4;
async function initIndexer(worker, cacheInfo, keyLoaderFacade) {
	const indexer = await locator.indexer();
	try {
		await indexer.init({
			user: assertNotNull(locator.user.getUser()),
			cacheInfo,
			keyLoaderFacade
		});
	} catch (e) {
		if (e instanceof ServiceUnavailableError) {
			console.log("Retry init indexer in 30 seconds after ServiceUnavailableError");
			await delay(RETRY_TIMOUT_AFTER_INIT_INDEXER_ERROR_MS);
			console.log("_initIndexer after ServiceUnavailableError");
			return initIndexer(worker, cacheInfo, keyLoaderFacade);
		} else if (e instanceof ConnectionError) {
			console.log("Retry init indexer in 30 seconds after ConnectionError");
			await delay(RETRY_TIMOUT_AFTER_INIT_INDEXER_ERROR_MS);
			console.log("_initIndexer after ConnectionError");
			return initIndexer(worker, cacheInfo, keyLoaderFacade);
		} else {
			worker.sendError(e);
			return;
		}
	}
	if (cacheInfo.isPersistent && cacheInfo.isNewOfflineDb) indexer.enableMailIndexing();
}
async function resetLocator() {
	await locator.login.resetSession();
	await initLocator(locator._worker, locator._browserData);
}
if (typeof self !== "undefined") self.locator = locator;

//#endregion
export { AesApp, AsymmetricCryptoFacade, BlobAccessTokenFacade, CHECK_INTERVAL, CryptoFacade, EphemeralCacheStorage, EventBusEventCoordinator, InstanceMapper, KeyCache, KeyLoaderFacade, KeyRotationFacade, LateInitializedCacheStorageImpl, LocalTimeDateProvider, OwnerEncSessionKeysUpdateQueue, PQFacade, SLEEP_INTERVAL, ServiceExecutor, SleepDetector, SuspensionHandler, UserFacade, WASMKyberFacade, convertToVersionedPublicKeys, decodePQMessage, decryptValue, encodePQMessage, encryptValue, initLocator, locator, resetLocator };
//# sourceMappingURL=WorkerLocator-vHg_-eJs.js.map