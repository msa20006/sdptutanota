{"version":3,"file":"RecipientsSearchModel-CWgbkZTK.js","names":["recipientsModel: RecipientsModel","contactModel: ContactModel","suggestionsProvider: ContactSuggestionProvider","entityClient: EntityClient","value: string","value","contactList: ContactListInfo","filter: RecipientSearchResultFilter | null","query: string","suggestedRecipients: Array<Recipient>","address: string","text: string"],"sources":["../../src/common/misc/RecipientsSearchModel.ts"],"sourcesContent":["import { PartialRecipient, Recipient } from \"../api/common/recipients/Recipient.js\"\nimport { RecipientsModel, ResolveMode } from \"../api/main/RecipientsModel.js\"\nimport { ContactListInfo, ContactModel } from \"../contactsFunctionality/ContactModel.js\"\nimport { isMailAddress } from \"./FormatValidator.js\"\nimport { ofClass } from \"@tutao/tutanota-utils\"\nimport { DbError } from \"../api/common/error/DbError.js\"\nimport { locator } from \"../api/main/CommonLocator.js\"\nimport { ContactListEntryTypeRef, ContactTypeRef } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { LoginIncompleteError } from \"../api/common/error/LoginIncompleteError.js\"\nimport { findRecipientWithAddress } from \"../api/common/utils/CommonCalendarUtils.js\"\nimport { EntityClient } from \"../api/common/EntityClient.js\"\nimport { ContactSuggestion } from \"../native/common/generatedipc/ContactSuggestion.js\"\n\nconst MaxNativeSuggestions = 10\n\nexport type RecipientSearchResultItem =\n\t| { type: \"recipient\"; value: Recipient }\n\t| {\n\t\t\ttype: \"contactlist\"\n\t\t\tvalue: ContactListInfo\n\t  }\nexport type RecipientSearchResultFilter = (item: RecipientSearchResultItem) => boolean\n\nexport interface ContactSuggestionProvider {\n\tgetContactSuggestions(query: string): Promise<readonly ContactSuggestion[]>\n}\n\nexport class RecipientsSearchModel {\n\tprivate searchResults: Array<RecipientSearchResultItem> = []\n\tprivate loading: Promise<void> | null = null\n\n\tprivate currentQuery = \"\"\n\tprivate previousQuery = \"\"\n\tprivate filter: RecipientSearchResultFilter | null = null\n\n\tconstructor(\n\t\tprivate readonly recipientsModel: RecipientsModel,\n\t\tprivate readonly contactModel: ContactModel,\n\t\tprivate readonly suggestionsProvider: ContactSuggestionProvider,\n\t\tprivate readonly entityClient: EntityClient,\n\t) {}\n\n\tresults(): ReadonlyArray<RecipientSearchResultItem> {\n\t\treturn this.searchResults\n\t}\n\n\tisLoading(): boolean {\n\t\treturn this.loading != null\n\t}\n\n\tclear() {\n\t\tthis.searchResults = []\n\t\tthis.loading = null\n\t\tthis.currentQuery = \"\"\n\t\tthis.previousQuery = \"\"\n\t}\n\n\tasync search(value: string): Promise<void> {\n\t\tconst query = value.trim()\n\n\t\tthis.currentQuery = query\n\n\t\tif (this.loading != null) {\n\t\t\t// fall through and await below\n\t\t} else if (query.length > 0 && !(this.previousQuery.length > 0 && query.indexOf(this.previousQuery) === 0 && this.searchResults.length === 0)) {\n\t\t\tconst [newContactListSuggestions, newContactSuggestions] = await Promise.all([\n\t\t\t\tthis.findContactLists(query.toLowerCase()),\n\t\t\t\tthis.findContacts(query.toLowerCase()),\n\t\t\t])\n\t\t\tif (query === this.currentQuery) {\n\t\t\t\tthis.searchResults = [\n\t\t\t\t\t...newContactListSuggestions.map(\n\t\t\t\t\t\t(value) =>\n\t\t\t\t\t\t\t({\n\t\t\t\t\t\t\t\ttype: \"contactlist\",\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t} satisfies RecipientSearchResultItem),\n\t\t\t\t\t),\n\t\t\t\t\t...newContactSuggestions.map(\n\t\t\t\t\t\t(value) =>\n\t\t\t\t\t\t\t({\n\t\t\t\t\t\t\t\ttype: \"recipient\",\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t} satisfies RecipientSearchResultItem),\n\t\t\t\t\t),\n\t\t\t\t].filter(this.filter ?? ((_) => true))\n\t\t\t\tthis.previousQuery = query\n\t\t\t}\n\t\t\tthis.loading = null\n\t\t} else if (query.length === 0 && query !== this.previousQuery) {\n\t\t\tthis.searchResults = []\n\t\t\tthis.previousQuery = query\n\t\t}\n\n\t\tawait this.loading\n\t}\n\n\tasync resolveContactList(contactList: ContactListInfo): Promise<Array<Recipient>> {\n\t\tconst entries = await this.entityClient.loadAll(ContactListEntryTypeRef, contactList.groupRoot.entries)\n\t\treturn entries.map((entry) => {\n\t\t\t// it's okay to be lazy sometimes\n\t\t\t// all the places anyway resolve the recipients when they need to\n\t\t\treturn this.recipientsModel.resolve({ address: entry.emailAddress }, ResolveMode.Lazy)\n\t\t})\n\t}\n\n\tsetFilter(filter: RecipientSearchResultFilter | null) {\n\t\tthis.filter = filter\n\t}\n\n\tprivate async findContacts(query: string): Promise<Array<Recipient>> {\n\t\tif (isMailAddress(query, false)) {\n\t\t\treturn []\n\t\t}\n\n\t\t// ensure match word order for email addresses mainly\n\t\tconst contacts = await this.contactModel\n\t\t\t.searchForContacts(`\"${query}\"`, \"recipient\", 10)\n\t\t\t.catch(\n\t\t\t\tofClass(DbError, async () => {\n\t\t\t\t\tconst listId = await this.contactModel.getContactListId()\n\t\t\t\t\tif (listId) {\n\t\t\t\t\t\treturn locator.entityClient.loadAll(ContactTypeRef, listId)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn []\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(ofClass(LoginIncompleteError, () => []))\n\n\t\tlet suggestedRecipients: Array<Recipient> = []\n\t\tfor (const contact of contacts) {\n\t\t\tconst name = `${contact.firstName} ${contact.lastName}`.trim()\n\n\t\t\tconst filter =\n\t\t\t\tname.toLowerCase().indexOf(query) !== -1\n\t\t\t\t\t? (address: string) => isMailAddress(address.trim(), false)\n\t\t\t\t\t: (address: string) => isMailAddress(address.trim(), false) && address.toLowerCase().indexOf(query) !== -1\n\n\t\t\tconst recipientsOfContact = contact.mailAddresses\n\t\t\t\t.map(({ address }) => address)\n\t\t\t\t.filter(filter)\n\t\t\t\t.map((address) => this.recipientsModel.resolve({ name, address, contact }, ResolveMode.Lazy))\n\n\t\t\tsuggestedRecipients = suggestedRecipients.concat(recipientsOfContact)\n\t\t}\n\n\t\tconst additionalSuggestions = await this.findAdditionalSuggestions(query)\n\n\t\tconst contactSuggestions = additionalSuggestions\n\t\t\t.filter((contact) => isMailAddress(contact.address, false) && !findRecipientWithAddress(suggestedRecipients, contact.address))\n\t\t\t.slice(0, MaxNativeSuggestions)\n\t\t\t.map((recipient) => this.recipientsModel.resolve(recipient, ResolveMode.Lazy))\n\n\t\tsuggestedRecipients.push(...contactSuggestions)\n\n\t\treturn suggestedRecipients.sort((suggestion1, suggestion2) => suggestion1.name.localeCompare(suggestion2.name))\n\t}\n\n\tprivate async findAdditionalSuggestions(text: string): Promise<Array<PartialRecipient>> {\n\t\tif (!this.suggestionsProvider) {\n\t\t\treturn []\n\t\t}\n\t\tconst recipients = await this.suggestionsProvider.getContactSuggestions(text)\n\t\treturn recipients.map(({ name, mailAddress }) => ({ name, address: mailAddress }))\n\t}\n\n\tprivate async findContactLists(text: string): Promise<ContactListInfo[]> {\n\t\treturn this.contactModel.searchForContactLists(text)\n\t}\n}\n"],"mappings":"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"}