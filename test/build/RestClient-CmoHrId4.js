
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, typedEntries, uint8ArrayToArrayBuffer } from "./dist-CJHwsXKY.js";
import { assertWorkerOrNode, getApiBaseUrl, isAdminClient, isAndroidApp, isWebClient, isWorker } from "./Env-D5xGlXfw.js";
import { REQUEST_SIZE_LIMIT_DEFAULT, REQUEST_SIZE_LIMIT_MAP } from "./TutanotaConstants-3bwAESYA.js";
import { ConnectionError, PayloadTooLargeError, ServiceUnavailableError, TooManyRequestsError, handleRestError } from "./RestError-D17JEBMr.js";
import { SuspensionError } from "./SuspensionError-okvIjE4H.js";
import { HttpMethod, MediaType } from "./EntityFunctions-l6CncM5C.js";

//#region ../src/common/api/worker/rest/RestClient.ts
assertWorkerOrNode();
const TAG = "[RestClient]";
let SuspensionBehavior = function(SuspensionBehavior$1) {
	SuspensionBehavior$1[SuspensionBehavior$1["Suspend"] = 0] = "Suspend";
	SuspensionBehavior$1[SuspensionBehavior$1["Throw"] = 1] = "Throw";
	return SuspensionBehavior$1;
}({});
var RestClient = class {
	id;
	serverTimeOffsetMs = null;
	constructor(suspensionHandler, domainConfig) {
		this.suspensionHandler = suspensionHandler;
		this.domainConfig = domainConfig;
		this.id = 0;
	}
	request(path, method, options = {}) {
		const debug = typeof self !== "undefined" && self.debug;
		const verbose = isWorker() && debug;
		this.checkRequestSizeLimit(path, method, options.body ?? null);
		if (this.suspensionHandler.isSuspended()) return this.suspensionHandler.deferRequest(() => this.request(path, method, options));
else return new Promise((resolve, reject) => {
			this.id++;
			const queryParams = options.queryParams ?? {};
			if (method === HttpMethod.GET && typeof options.body === "string") queryParams["_body"] = options.body;
			if (options.noCORS) queryParams["cv"] = env.versionNumber;
			const origin = options.baseUrl ?? getApiBaseUrl(this.domainConfig);
			const resourceURL = new URL(origin);
			resourceURL.pathname = path;
			const url = addParamsToUrl(resourceURL, queryParams);
			const xhr = new XMLHttpRequest();
			xhr.open(method, url.toString());
			this.setHeaders(xhr, options);
			xhr.responseType = options.responseType === MediaType.Json || options.responseType === MediaType.Text ? "text" : "arraybuffer";
			const abortAfterTimeout = () => {
				const res = {
					timeoutId: 0,
					abortFunction: () => {
						if (this.usingTimeoutAbort()) {
							console.log(TAG, `${this.id}: ${String(new Date())} aborting ` + String(res.timeoutId));
							xhr.abort();
						}
					}
				};
				return res;
			};
			const t = abortAfterTimeout();
			let timeout = setTimeout(t.abortFunction, env.timeout);
			t.timeoutId = timeout;
			if (verbose) console.log(TAG, `${this.id}: set initial timeout ${String(timeout)} of ${env.timeout}`);
			xhr.onload = () => {
				if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} finished request. Clearing Timeout ${String(timeout)}.`);
				clearTimeout(timeout);
				this.saveServerTimeOffsetFromRequest(xhr);
				if (xhr.status === 200 || method === HttpMethod.POST && xhr.status === 201) if (options.responseType === MediaType.Json || options.responseType === MediaType.Text) resolve(xhr.response);
else if (options.responseType === MediaType.Binary) resolve(new Uint8Array(xhr.response));
else resolve(null);
else {
					const suspensionTime = xhr.getResponseHeader("Retry-After") || xhr.getResponseHeader("Suspension-Time");
					if (isSuspensionResponse(xhr.status, suspensionTime) && options.suspensionBehavior === SuspensionBehavior.Throw) reject(new SuspensionError(`blocked for ${suspensionTime}, not suspending (${xhr.status})`, suspensionTime && (parseInt(suspensionTime) * 1e3).toString()));
else if (isSuspensionResponse(xhr.status, suspensionTime)) {
						this.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), resourceURL);
						resolve(this.suspensionHandler.deferRequest(() => this.request(path, method, options)));
					} else {
						logFailedRequest(method, url, xhr, options);
						reject(handleRestError(xhr.status, `| ${method} ${path}`, xhr.getResponseHeader("Error-Id"), xhr.getResponseHeader("Precondition")));
					}
				}
			};
			xhr.onerror = function() {
				clearTimeout(timeout);
				logFailedRequest(method, url, xhr, options);
				reject(handleRestError(xhr.status, ` | ${method} ${path}`, xhr.getResponseHeader("Error-Id"), xhr.getResponseHeader("Precondition")));
			};
			if (!options.noCORS) {
				xhr.upload.onprogress = (pe) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload progress. Clearing Timeout ${String(timeout)}`, pe);
					clearTimeout(timeout);
					const t$1 = abortAfterTimeout();
					timeout = setTimeout(t$1.abortFunction, env.timeout);
					t$1.timeoutId = timeout;
					if (verbose) console.log(TAG, `${this.id}: set new timeout ${String(timeout)} of ${env.timeout}`);
					if (options.progressListener != null && pe.lengthComputable) options.progressListener.upload(1 / pe.total * pe.loaded);
				};
				xhr.upload.ontimeout = (e) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload timeout. calling error handler.`, e);
					xhr.onerror?.(e);
				};
				xhr.upload.onerror = (e) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload error. calling error handler.`, e);
					xhr.onerror?.(e);
				};
				xhr.upload.onabort = (e) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload aborted. calling error handler.`, e);
					xhr.onerror?.(e);
				};
			}
			xhr.onprogress = (pe) => {
				if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} download progress. Clearing Timeout ${String(timeout)}`, pe);
				clearTimeout(timeout);
				let t$1 = abortAfterTimeout();
				timeout = setTimeout(t$1.abortFunction, env.timeout);
				t$1.timeoutId = timeout;
				if (verbose) console.log(TAG, `${this.id}: set new timeout ${String(timeout)} of ${env.timeout}`);
				if (options.progressListener != null && pe.lengthComputable) options.progressListener.download(1 / pe.total * pe.loaded);
			};
			xhr.onabort = () => {
				clearTimeout(timeout);
				reject(new ConnectionError(`Reached timeout of ${env.timeout}ms ${xhr.statusText} | ${method} ${path}`));
			};
			if (options.body instanceof Uint8Array) xhr.send(uint8ArrayToArrayBuffer(options.body));
else xhr.send(options.body);
		});
	}
	/** We only need to track timeout directly here on some platforms. Other platforms do it inside their network driver. */
	usingTimeoutAbort() {
		return isWebClient() || isAndroidApp();
	}
	saveServerTimeOffsetFromRequest(xhr) {
		const serverTimestamp = xhr.getResponseHeader("Date");
		if (serverTimestamp != null) {
			const serverTime = new Date(serverTimestamp).getTime();
			if (!isNaN(serverTime)) {
				const now = Date.now();
				this.serverTimeOffsetMs = serverTime - now;
			}
		}
	}
	/**
	* Get the time on the server based on the client time + the server time offset
	* The server time offset is calculated based on the date field in the header returned from REST requests.
	* will throw an error if offline or no rest requests have been made yet
	*/
	getServerTimestampMs() {
		const timeOffset = assertNotNull(this.serverTimeOffsetMs, "You can't get server time if no rest requests were made");
		return Date.now() + timeOffset;
	}
	/**
	* Checks if the request body is too large.
	* Ignores the method because GET requests etc. should not exceed the limits neither.
	* This is done to avoid making the request, because the server will return a PayloadTooLargeError anyway.
	* */
	checkRequestSizeLimit(path, method, body) {
		if (isAdminClient()) return;
		const limit = REQUEST_SIZE_LIMIT_MAP.get(path) ?? REQUEST_SIZE_LIMIT_DEFAULT;
		if (body && body.length > limit) throw new PayloadTooLargeError(`request body is too large. Path: ${path}, Method: ${method}, Body length: ${body.length}`);
	}
	setHeaders(xhr, options) {
		if (options.headers == null) options.headers = {};
		const { headers, body, responseType } = options;
		if (!options.noCORS) {
			headers["cv"] = env.versionNumber;
			if (body instanceof Uint8Array) headers["Content-Type"] = MediaType.Binary;
else if (typeof body === "string") headers["Content-Type"] = MediaType.Json;
		}
		if (responseType) headers["Accept"] = responseType;
		for (const i in headers) xhr.setRequestHeader(i, headers[i]);
	}
};
function addParamsToUrl(url, urlParams) {
	if (urlParams) {
		for (const [key, value] of typedEntries(urlParams)) if (value !== undefined) url.searchParams.set(key, value);
	}
	return url;
}
function isSuspensionResponse(statusCode, suspensionTimeNumberString) {
	return Number(suspensionTimeNumberString) > 0 && (statusCode === TooManyRequestsError.CODE || statusCode === ServiceUnavailableError.CODE);
}
function logFailedRequest(method, url, xhr, options) {
	const args = [
		TAG,
		"failed request",
		method,
		url.toString(),
		xhr.status,
		xhr.statusText
	];
	if (options.headers != null) args.push(Object.keys(options.headers));
	if (options.body != null) {
		const logBody = "string" === typeof options.body ? `[${options.body.length} characters]` : `[${options.body.length} bytes]`;
		args.push(logBody);
	} else args.push("no body");
	console.log(...args);
}

//#endregion
export { RestClient, SuspensionBehavior, addParamsToUrl, isSuspensionResponse };
//# sourceMappingURL=RestClient-CmoHrId4.js.map