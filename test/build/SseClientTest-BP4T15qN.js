
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { assertNotNull, defer, getFirstOrThrow } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import { reverse } from "./TutanotaConstants-3bwAESYA.js";
import { NotAuthenticatedError, NotAuthorizedError } from "./RestError-D17JEBMr.js";
import "./CryptoError-PqdvQky4.js";
import "./CancelledError-FjP5S_cR.js";
import "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import "./TypeModels-BktRFNDN.js";
import "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./dist-DcZ1Y4qd.js";
import "./IndexTables-C5S9WDY9.js";
import "./IndexUtils-K27esrGs.js";
import { makeTaggedLogger } from "./DesktopLog-yAgEoQsh.js";
import "./IndexerCore-CrLYpsA5.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { verify } from "./dist-BY49f75m.js";
import { SchedulerMock } from "./TestUtils-f_4UhLVE.js";

//#region ../src/common/desktop/sse/SseClient.ts
const log = makeTaggedLogger("[SSE]");
let ConnectionState = function(ConnectionState$1) {
	/** Not connecting or trying to connect. */
	ConnectionState$1[ConnectionState$1["disconnected"] = 0] = "disconnected";
	/** Will try to reconnect after timeout. */
	ConnectionState$1[ConnectionState$1["delayedReconnect"] = 1] = "delayedReconnect";
	/** Started the connection. */
	ConnectionState$1[ConnectionState$1["connecting"] = 2] = "connecting";
	/** Received the response, connection is usable. */
	ConnectionState$1[ConnectionState$1["connected"] = 3] = "connected";
	return ConnectionState$1;
}({});
var SseClient = class {
	listener = null;
	_state = { state: ConnectionState.disconnected };
	readTimeoutSec = null;
	heartBeatListenerHandle = undefined;
	set state(newState) {
		const stateName = reverse(ConnectionState)[newState.state];
		log.debug("state:", stateName);
		this._state = newState;
	}
	get state() {
		return this._state;
	}
	constructor(net, delay, scheduler) {
		this.net = net;
		this.delay = delay;
		this.scheduler = scheduler;
	}
	async connect(options) {
		log.debug("connect");
		switch (this.state.state) {
			case ConnectionState.delayedReconnect:
				this.scheduler.unscheduleTimeout(this.state.timeout);
				break;
			case ConnectionState.connecting:
			case ConnectionState.connected:
				await this.disconnect();
				break;
			case ConnectionState.disconnected: break;
		}
		this.doConnect(options);
	}
	doConnect(options) {
		let attempt;
		switch (this.state.state) {
			case ConnectionState.disconnected:
				attempt = 1;
				break;
			case ConnectionState.delayedReconnect:
				attempt = this.state.attempt;
				break;
			case ConnectionState.connecting:
			case ConnectionState.connected: throw new ProgrammingError("Invalid state: already connecting");
		}
		const { url, headers } = options;
		const connection = this.net.request(url, {
			headers: {
				"Content-Type": "application/json",
				Connection: "Keep-Alive",
				"Keep-Alive": "header",
				Accept: "text/event-stream",
				...headers
			},
			method: "GET"
		});
		connection.on("socket", (s) => {
			s.on("lookup", () => log.debug("lookup"));
		}).on("response", async (res) => {
			log.debug("established SSE connection with code", res.statusCode);
			this.state = {
				state: ConnectionState.connected,
				connection,
				options,
				receivedHeartbeat: false
			};
			this.resetHeartbeatListener();
			if (res.statusCode === 403 || res.statusCode === 401) {
				await this.listener?.onNotAuthenticated();
				await this.disconnect();
				return;
			}
			res.setEncoding("utf8");
			let resData = "";
			res.on("data", (d) => {
				resData += d;
				const lines = resData.split("\n");
				resData = lines.pop() ?? "";
				for (const l of lines) {
					const trimmedLine = l.trim();
					if (trimmedLine === "") {
						log.debug("heartbeat");
						this.onHeartbeat();
					} else this.listener?.onNewMessage(trimmedLine);
				}
			}).on("close", () => {
				log.debug("response closed");
				if (this.state.state != ConnectionState.disconnected) this.delayedReconnect();
			}).on("error", (e) => {
				log.error("response error:", e);
				if (this.state.state != ConnectionState.disconnected) this.delayedReconnect();
			});
		}).on("information", () => log.debug("information")).on("connect", () => log.debug("connect:")).on("error", (e) => {
			log.error("error:", e.message);
			if (this.state.state === ConnectionState.connecting) this.exponentialBackoffReconnect();
		}).end();
		this.state = {
			state: ConnectionState.connecting,
			connection,
			attempt,
			options
		};
	}
	async disconnect() {
		const state = this.state;
		switch (state.state) {
			case ConnectionState.delayedReconnect:
				this.scheduler.unscheduleTimeout(state.timeout);
				this.state = { state: ConnectionState.disconnected };
				break;
			case ConnectionState.connected:
			case ConnectionState.connecting: return new Promise((resolve) => {
				state.connection.once("close", () => {
					this.state = { state: ConnectionState.disconnected };
					resolve();
				});
				state.connection.destroy();
			});
		}
	}
	setEventListener(listener) {
		this.listener = listener;
	}
	setReadTimeout(timeoutSeconds) {
		this.readTimeoutSec = timeoutSeconds;
		this.resetHeartbeatListener();
		this.onHeartbeat();
	}
	exponentialBackoffReconnect() {
		if (this.state.state != ConnectionState.connecting) throw new ProgrammingError("Invalid state: not connecting");
		log.debug("Scheduling exponential reconnect");
		const timeout = this.scheduler.scheduleAfter(() => this.retryConnect(), this.delay.reconnectDelay(this.state.attempt));
		this.state = {
			state: ConnectionState.delayedReconnect,
			attempt: this.state.attempt + 1,
			options: this.state.options,
			timeout
		};
	}
	delayedReconnect() {
		if (this.state.state != ConnectionState.connected) throw new ProgrammingError("Invalid state: not connected");
		log.debug("Scheduling delayed reconnect");
		const timeout = this.scheduler.scheduleAfter(() => this.retryConnect(), this.delay.initialConnectionDelay());
		this.state = {
			state: ConnectionState.delayedReconnect,
			attempt: 0,
			options: this.state.options,
			timeout
		};
	}
	async retryConnect() {
		if (this.state.state !== ConnectionState.delayedReconnect) throw new ProgrammingError("Invalid state: not in delayed reconnect");
		this.doConnect(this.state.options);
	}
	onHeartbeat() {
		if (this.state.state === ConnectionState.connected) this.state = {
			...this.state,
			receivedHeartbeat: true
		};
	}
	resetHeartbeatListener() {
		if (this.heartBeatListenerHandle != null) this.scheduler.unschedulePeriodic(this.heartBeatListenerHandle);
		this.heartBeatListenerHandle = this.scheduler.schedulePeriodic(async () => {
			const state = this.state;
			if (state.state === ConnectionState.connected) if (state.receivedHeartbeat) this.state = {
				...state,
				receivedHeartbeat: false
			};
else {
				await this.disconnect();
				this.doConnect(state.options);
			}
		}, Math.floor(this.readTimeoutSec * 1.2 * 1e3));
	}
};

//#endregion
//#region tests/desktop/sse/SseClientTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
dist_default.spec("SseClient", function() {
	const defaultOptions = Object.freeze({
		url: new URL("http://example.com"),
		headers: { header: "headerValue" }
	});
	let sseClient;
	let net;
	let delay;
	let scheduler;
	let listener;
	dist_default.beforeEach(() => {
		net = new NetStub();
		delay = (0, import_testdouble.object)();
		listener = (0, import_testdouble.object)();
		scheduler = new SchedulerMock();
		sseClient = new SseClient(net, delay, scheduler);
		sseClient.setEventListener(listener);
	});
	dist_default.test("connect passes options to net correctly", async () => {
		await sseClient.connect(defaultOptions);
		const request = await net.waitForRequest();
		dist_default(request.url).deepEquals(defaultOptions.url);
		dist_default(request.opts).deepEquals({
			headers: {
				"Content-Type": "application/json",
				Connection: "Keep-Alive",
				"Keep-Alive": "header",
				Accept: "text/event-stream",
				header: "headerValue"
			},
			method: "GET"
		});
	});
	dist_default.spec("messages", () => {
		dist_default.test("heartbeat does not trigger listener", async () => {
			const response = new ResponseStub();
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			response.sendData("\n\n");
			verify(listener.onNewMessage(import_testdouble.matchers.anything()), { times: 0 });
		});
		dist_default.test("data message triggers listener", async () => {
			const response = new ResponseStub();
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			response.sendData("data: test\n");
			verify(listener.onNewMessage("data: test"));
		});
		dist_default.test("multiple data chunks trigger listener", async () => {
			const response = new ResponseStub();
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			response.sendData("data: test1\n");
			response.sendData("data: test2\n");
			verify(listener.onNewMessage("data: test1"));
			verify(listener.onNewMessage("data: test2"));
		});
		dist_default.test("on notAuthenticated it notifies listener", async () => {
			const response = new ResponseStub();
			response.statusCode = NotAuthenticatedError.CODE;
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			verify(listener.onNotAuthenticated());
		});
		dist_default.test("on notAuthorized it notifies listener", async () => {
			const response = new ResponseStub();
			response.statusCode = NotAuthorizedError.CODE;
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			verify(listener.onNotAuthenticated());
		});
	});
	dist_default.spec("reconnect", () => {
		dist_default.test("reconnects if response is closed", async () => {
			const response = new ResponseStub();
			(0, import_testdouble.when)(delay.initialConnectionDelay()).thenReturn(10);
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			net.prepareForAnotherRequest();
			response.close();
			dist_default(net.requests.length).equals(1)("Only one request is done so far, the other one is delayed");
			scheduler.getThunkAfter(10)();
			await net.waitForRequest();
		});
		dist_default.test("reconnects if response errors out", async () => {
			const response = new ResponseStub();
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			(0, import_testdouble.when)(delay.initialConnectionDelay()).thenReturn(10);
			net.prepareForAnotherRequest();
			response.sendError(new Error("test"));
			dist_default(net.requests.length).equals(1)("Only one request is done so far, the other one is delayed");
			scheduler.getThunkAfter(10)();
			await net.waitForRequest();
		});
	});
	dist_default.spec("failing to connect", () => {
		dist_default.test("on failing to connect the first time it reschedules with attempts=1", async () => {
			(0, import_testdouble.when)(delay.reconnectDelay(1)).thenReturn(1);
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			net.prepareForAnotherRequest();
			await request.sendError(new Error("error1"));
			scheduler.getThunkAfter(1)();
			await net.waitForRequest();
		});
		dist_default.test("on failing to connect the second time it reschedules with attempts=2", async () => {
			(0, import_testdouble.when)(delay.reconnectDelay(1)).thenReturn(1);
			(0, import_testdouble.when)(delay.reconnectDelay(2)).thenReturn(2);
			await sseClient.connect(defaultOptions);
			const request1 = await net.waitForRequest();
			net.prepareForAnotherRequest();
			await request1.sendError(new Error("error1"));
			scheduler.getThunkAfter(1)();
			const request2 = await net.waitForRequest();
			net.prepareForAnotherRequest();
			await request2.sendError(new Error("error2"));
			scheduler.getThunkAfter(2)();
			await net.waitForRequest();
		});
	});
	dist_default.spec("heartbeat", () => {
		dist_default.test("when heartbeat is received before the heartbeat interval the connection is kept open", async () => {
			sseClient.setReadTimeout(15);
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			const response = new ResponseStub();
			await request.sendResponse(response);
			response.sendData("\n\n");
			await getFirstOrThrow(scheduler.getAllPeriodThunks())();
			dist_default(request.state).equals("created");
		});
		dist_default.test("when heartbeat is not received before the heartbeat interval the connection is closed and another one open", async () => {
			sseClient.setReadTimeout(15);
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			const response = new ResponseStub();
			await request.sendResponse(response);
			net.prepareForAnotherRequest();
			await getFirstOrThrow(scheduler.getAllPeriodThunks())();
			dist_default(request.state).equals("destroyed");
			await net.waitForRequest();
		});
		dist_default.test("heartbeat is rescheduled when setReadTimeout is called", async () => {
			sseClient.setReadTimeout(15);
			sseClient.setReadTimeout(25);
			dist_default(scheduler.cancelledPeriodic.size).equals(1)("one periodic timeout canceled");
			dist_default(scheduler.getAllPeriodThunks().length).equals(2)("rescheduled heartbeat thunk");
		});
	});
	dist_default.spec("external state switching", () => {
		dist_default.test("should connect eventually connect if connect() is called while disconnecting", async () => {
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			request.doNotClose();
			sseClient.disconnect();
			await request.waitForDestroy();
			request.eventListeners.get("close")?.();
			net.prepareForAnotherRequest();
			await sseClient.connect(defaultOptions);
			await net.waitForRequest();
		});
		dist_default.test("should cancel timeouts if disconnect is called while waiting to reconnect", async () => {
			await sseClient.connect(defaultOptions);
			const request = await net.waitForRequest();
			await request.sendError(new Error("test"));
			await sseClient.disconnect();
			dist_default(scheduler.cancelledAt.size).equals(1);
		});
		dist_default.test("should disconnect and use new options if connect() is called while connected", async () => {
			await sseClient.connect(defaultOptions);
			const response = new ResponseStub();
			const request = await net.waitForRequest();
			await request.sendResponse(response);
			net.prepareForAnotherRequest();
			const newOptions = Object.freeze({
				url: new URL("https://another.com"),
				headers: { anotherHeader: "anotherValue" }
			});
			await sseClient.connect(newOptions);
			dist_default(request.state).equals("destroyed");
			const newRequest = await net.waitForRequest();
			dist_default(newRequest.url).deepEquals(newOptions.url);
			dist_default(newRequest.opts).deepEquals({
				headers: {
					"Content-Type": "application/json",
					Connection: "Keep-Alive",
					"Keep-Alive": "header",
					Accept: "text/event-stream",
					anotherHeader: "anotherValue"
				},
				method: "GET"
			});
		});
	});
});
var NetStub = class {
	requestDefer = defer();
	requests = [];
	request(url, opts) {
		const requestMock = new RequestStub(url, opts);
		this.requests.push(requestMock);
		this.requestDefer.resolve(requestMock);
		return requestMock;
	}
	waitForRequest() {
		return this.requestDefer.promise;
	}
	prepareForAnotherRequest() {
		this.requestDefer = defer();
	}
};
var RequestStub = class {
	state = "created";
	eventListeners = new Map();
	destroyedDefer = defer();
	preventClose = false;
	constructor(url, opts) {
		this.url = url;
		this.opts = opts;
	}
	on(event, listener) {
		this.eventListeners.set(event, listener);
		return this;
	}
	once(event, listener) {
		this.eventListeners.set(event, listener);
		return this;
	}
	async sendResponse(response) {
		await assertNotNull(this.eventListeners.get("response"))(response);
	}
	async sendError(error) {
		await this.eventListeners.get("error")(error);
	}
	waitForDestroy() {
		return this.destroyedDefer.promise;
	}
	destroy() {
		this.state = "destroyed";
		if (!this.preventClose) this.eventListeners.get("close")?.();
		this.destroyedDefer.resolve();
		return this;
	}
	end() {
		return this;
	}
	doNotClose() {
		this.preventClose = true;
	}
};
var ResponseStub = class {
	statusCode = 200;
	eventListeners = new Map();
	on(event, listener) {
		this.eventListeners.set(event, listener);
		return this;
	}
	setEncoding() {
		return this;
	}
	sendData(data) {
		assertNotNull(this.eventListeners.get("data"))(data);
	}
	close() {
		this.eventListeners.get("close")?.();
	}
	sendError(e) {
		this.eventListeners.get("error")?.();
	}
};

//#endregion
//# sourceMappingURL=SseClientTest-BP4T15qN.js.map