{"version":3,"file":"MailFacade-Dv71IuiQ.js","names":["userFacade: UserFacade","entityClient: EntityClient","crypto: CryptoFacade","serviceExecutor: IServiceExecutor","blobFacade: BlobFacade","fileApp: NativeFileApp","loginFacade: LoginFacade","keyLoaderFacade: KeyLoaderFacade","name: string","parent: IdTuple | null","ownerGroupId: Id","folder: MailFolder","newName: string","newParent: IdTuple | null","mails: IdTuple[]","sourceFolder: IdTuple","targetFolder: IdTuple","mail: Mail","reportType: MailReportType","mailSessionKey: Aes128Key","folder: IdTuple","providedFiles: Attachments | null","existingFileIds: IdTuple[]","removedAttachmentIds: IdTuple[]","existingFileIds: ReadonlyArray<IdTuple>","senderMailGroupId: Id","mailGroupKey: VersionedKey","referenceTokens: Array<BlobReferenceTokenWrapper>","referenceTokens: BlobReferenceTokenWrapper[]","fileSessionKey: AesKey","providedFile: DataFile | FileReference","draft: Mail","recipients: Array<Recipient>","language: string","ownerEncSessionKeyProvider: OwnerEncSessionKeyProvider","links: Array<{\n\t\t\thref: string\n\t\t\tinnerHTML: string\n\t\t}>","id: IdTuple","groupId: Id","unreadMails: number","type: ReportedMailFieldType","value: string","bucketKey: AesKey","sendDraftData: SendDraftData","notFoundRecipients: string[]","contact: Contact | null","recipientMailAddress: string","externalUserKdfType: KdfType","externalUserPwKey: AesKey","verifier: Uint8Array","externalUserReference: ExternalUserReference","mailAddress: string","data: EntityUpdate[]","markers: ReportedMailFieldMarker[]","cleanedMailAddress: string","user: User","folderId: IdTuple","mailId: IdTuple","recipient: string","headers: string[]","ownerEncSessionKeyProvider: OwnerEncSessionKeyProvider | undefined","instanceElementId: Id","instanceSessionKey","mailGroupId: Id","labelData: { name: string; color: string }","label: MailFolder","color: string","mails: readonly Mail[]","addedLabels: readonly MailFolder[]","removedLabels: readonly MailFolder[]","link: string","recipient: PartialRecipient","attachments: Attachments"],"sources":["../../src/common/api/worker/facades/lazy/MailFacade.ts"],"sourcesContent":["import type { CryptoFacade } from \"../../crypto/CryptoFacade.js\"\nimport {\n\tApplyLabelService,\n\tDraftService,\n\tExternalUserService,\n\tListUnsubscribeService,\n\tMailFolderService,\n\tMailService,\n\tManageLabelService,\n\tMoveMailService,\n\tReportMailService,\n\tSendDraftService,\n} from \"../../../entities/tutanota/Services.js\"\nimport {\n\tArchiveDataType,\n\tConversationType,\n\tCounterType,\n\tCryptoProtocolVersion,\n\tDEFAULT_KDF_TYPE,\n\tEncryptionAuthStatus,\n\tGroupType,\n\tKdfType,\n\tMailAuthenticationStatus,\n\tMailMethod,\n\tMailReportType,\n\tOperationType,\n\tPhishingMarkerStatus,\n\tPublicKeyIdentifierType,\n\tReportedMailFieldType,\n\tSYSTEM_GROUP_MAIL_ADDRESS,\n} from \"../../../common/TutanotaConstants.js\"\nimport {\n\tContact,\n\tcreateApplyLabelServicePostIn,\n\tcreateAttachmentKeyData,\n\tcreateCreateExternalUserGroupData,\n\tcreateCreateMailFolderData,\n\tcreateDeleteMailData,\n\tcreateDeleteMailFolderData,\n\tcreateDraftAttachment,\n\tcreateDraftCreateData,\n\tcreateDraftData,\n\tcreateDraftRecipient,\n\tcreateDraftUpdateData,\n\tcreateEncryptedMailAddress,\n\tcreateExternalUserData,\n\tcreateListUnsubscribeData,\n\tcreateManageLabelServiceDeleteIn,\n\tcreateManageLabelServiceLabelData,\n\tcreateManageLabelServicePostIn,\n\tcreateMoveMailData,\n\tcreateNewDraftAttachment,\n\tcreateReportMailPostData,\n\tcreateSecureExternalRecipientKeyData,\n\tcreateSendDraftData,\n\tcreateUpdateMailFolderData,\n\tDraftAttachment,\n\tDraftRecipient,\n\tEncryptedMailAddress,\n\tFile as TutanotaFile,\n\tFileTypeRef,\n\tInternalRecipientKeyData,\n\tInternalRecipientKeyDataTypeRef,\n\tMail,\n\tMailDetails,\n\tMailDetailsBlobTypeRef,\n\tMailDetailsDraftTypeRef,\n\tMailFolder,\n\tMailTypeRef,\n\tReportedMailFieldMarker,\n\tSendDraftData,\n\tSymEncInternalRecipientKeyData,\n\tSymEncInternalRecipientKeyDataTypeRef,\n\tTutanotaPropertiesTypeRef,\n} from \"../../../entities/tutanota/TypeRefs.js\"\nimport { RecipientsNotFoundError } from \"../../../common/error/RecipientsNotFoundError.js\"\nimport { NotFoundError } from \"../../../common/error/RestError.js\"\nimport type { EntityUpdate, ExternalUserReference, PublicKeyGetOut, User } from \"../../../entities/sys/TypeRefs.js\"\nimport {\n\tBlobReferenceTokenWrapper,\n\tcreatePublicKeyGetIn,\n\tExternalUserReferenceTypeRef,\n\tGroupInfoTypeRef,\n\tGroupRootTypeRef,\n\tGroupTypeRef,\n\tUserTypeRef,\n} from \"../../../entities/sys/TypeRefs.js\"\nimport {\n\taddressDomain,\n\tassertNotNull,\n\tbyteLength,\n\tcontains,\n\tdefer,\n\tfreshVersioned,\n\tisEmpty,\n\tisNotNull,\n\tisSameTypeRef,\n\tisSameTypeRefByAttr,\n\tnoOp,\n\tofClass,\n\tpromiseFilter,\n\tpromiseMap,\n} from \"@tutao/tutanota-utils\"\nimport { BlobFacade } from \"./BlobFacade.js\"\nimport { assertWorkerOrNode, isApp, isDesktop } from \"../../../common/Env.js\"\nimport { EntityClient } from \"../../../common/EntityClient.js\"\nimport { getEnabledMailAddressesForGroupInfo, getUserGroupMemberships } from \"../../../common/utils/GroupUtils.js\"\nimport { containsId, elementIdPart, getElementId, getLetId, isSameId, listIdPart, stringToCustomId } from \"../../../common/utils/EntityUtils.js\"\nimport { htmlToText } from \"../../search/IndexUtils.js\"\nimport { MailBodyTooLargeError } from \"../../../common/error/MailBodyTooLargeError.js\"\nimport { UNCOMPRESSED_MAX_SIZE } from \"../../Compression.js\"\nimport {\n\tAes128Key,\n\taes256RandomKey,\n\tAesKey,\n\tbitArrayToUint8Array,\n\tcreateAuthVerifier,\n\tdecryptKey,\n\tencryptKey,\n\tgenerateRandomSalt,\n\tkeyToUint8Array,\n\tmurmurHash,\n\trandom,\n\tsha256Hash,\n} from \"@tutao/tutanota-crypto\"\nimport { DataFile } from \"../../../common/DataFile.js\"\nimport { FileReference, isDataFile, isFileReference } from \"../../../common/utils/FileUtils.js\"\nimport { CounterService } from \"../../../entities/monitor/Services.js\"\nimport { PublicKeyService } from \"../../../entities/sys/Services.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { createWriteCounterData } from \"../../../entities/monitor/TypeRefs.js\"\nimport { UserFacade } from \"../UserFacade.js\"\nimport { PartialRecipient, Recipient, RecipientList, RecipientType } from \"../../../common/recipients/Recipient.js\"\nimport { NativeFileApp } from \"../../../../native/common/FileApp.js\"\nimport { LoginFacade } from \"../LoginFacade.js\"\nimport { ProgrammingError } from \"../../../common/error/ProgrammingError.js\"\nimport { OwnerEncSessionKeyProvider } from \"../../rest/EntityRestClient.js\"\nimport { resolveTypeReference } from \"../../../common/EntityFunctions.js\"\nimport { KeyLoaderFacade } from \"../KeyLoaderFacade.js\"\nimport { encryptBytes, encryptKeyWithVersionedKey, encryptString, VersionedEncryptedKey, VersionedKey } from \"../../crypto/CryptoWrapper.js\"\n\nassertWorkerOrNode()\ntype Attachments = ReadonlyArray<TutanotaFile | DataFile | FileReference>\n\ninterface CreateDraftParams {\n\tsubject: string\n\tbodyText: string\n\tsenderMailAddress: string\n\tsenderName: string\n\ttoRecipients: RecipientList\n\tccRecipients: RecipientList\n\tbccRecipients: RecipientList\n\tconversationType: ConversationType\n\tpreviousMessageId: Id | null\n\tattachments: Attachments | null\n\tconfidential: boolean\n\treplyTos: RecipientList\n\tmethod: MailMethod\n}\n\ninterface UpdateDraftParams {\n\tsubject: string\n\tbody: string\n\tsenderMailAddress: string\n\tsenderName: string\n\ttoRecipients: RecipientList\n\tccRecipients: RecipientList\n\tbccRecipients: RecipientList\n\tattachments: Attachments | null\n\tconfidential: boolean\n\tdraft: Mail\n}\n\nexport class MailFacade {\n\tprivate phishingMarkers: Set<string> = new Set()\n\tprivate deferredDraftId: IdTuple | null = null // the mail id of the draft that we are waiting for to be updated via websocket\n\tprivate deferredDraftUpdate: Record<string, any> | null = null // this deferred promise is resolved as soon as the update of the draft is received\n\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly crypto: CryptoFacade,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly blobFacade: BlobFacade,\n\t\tprivate readonly fileApp: NativeFileApp,\n\t\tprivate readonly loginFacade: LoginFacade,\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t) {}\n\n\tasync createMailFolder(name: string, parent: IdTuple | null, ownerGroupId: Id): Promise<void> {\n\t\tconst mailGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(ownerGroupId)\n\n\t\tconst sk = aes256RandomKey()\n\t\tconst ownerEncSessionKey = encryptKeyWithVersionedKey(mailGroupKey, sk)\n\t\tconst newFolder = createCreateMailFolderData({\n\t\t\tfolderName: name,\n\t\t\tparentFolder: parent,\n\t\t\townerEncSessionKey: ownerEncSessionKey.key,\n\t\t\townerGroup: ownerGroupId,\n\t\t\townerKeyVersion: ownerEncSessionKey.encryptingKeyVersion.toString(),\n\t\t})\n\t\tawait this.serviceExecutor.post(MailFolderService, newFolder, { sessionKey: sk })\n\t}\n\n\t/**\n\t * Updates a mail folder's name, if needed\n\t * @param newName - if this is the same as the folder's current name, nothing is done\n\t */\n\tasync updateMailFolderName(folder: MailFolder, newName: string): Promise<void> {\n\t\tif (newName !== folder.name) {\n\t\t\tfolder.name = newName\n\t\t\tawait this.entityClient.update(folder)\n\t\t}\n\t}\n\n\t/**\n\t * Updates a mail folder's parent, if needed\n\t * @param newParent - if this is the same as the folder's current parent, nothing is done\n\t */\n\tasync updateMailFolderParent(folder: MailFolder, newParent: IdTuple | null): Promise<void> {\n\t\tif (\n\t\t\t(folder.parentFolder != null && newParent != null && !isSameId(folder.parentFolder, newParent)) ||\n\t\t\t(folder.parentFolder == null && newParent != null) ||\n\t\t\t(folder.parentFolder != null && newParent == null)\n\t\t) {\n\t\t\tconst updateFolder = createUpdateMailFolderData({\n\t\t\t\tfolder: folder._id,\n\t\t\t\tnewParent: newParent,\n\t\t\t})\n\t\t\tawait this.serviceExecutor.put(MailFolderService, updateFolder)\n\t\t}\n\t}\n\n\t/**\n\t * Creates a draft mail.\n\t * @param bodyText The bodyText of the mail formatted as HTML.\n\t * @param previousMessageId The id of the message that this mail is a reply or forward to. Null if this is a new mail.\n\t * @param attachments The files that shall be attached to this mail or null if no files shall be attached. TutanotaFiles are already exising on the server, DataFiles are files from the local file system. Attention: the DataFile class information is lost\n\t * @param confidential True if the mail shall be sent end-to-end encrypted, false otherwise.\n\t */\n\tasync createDraft({\n\t\tsubject,\n\t\tbodyText,\n\t\tsenderMailAddress,\n\t\tsenderName,\n\t\ttoRecipients,\n\t\tccRecipients,\n\t\tbccRecipients,\n\t\tconversationType,\n\t\tpreviousMessageId,\n\t\tattachments,\n\t\tconfidential,\n\t\treplyTos,\n\t\tmethod,\n\t}: CreateDraftParams): Promise<Mail> {\n\t\tif (byteLength(bodyText) > UNCOMPRESSED_MAX_SIZE) {\n\t\t\tthrow new MailBodyTooLargeError(`Can't update draft, mail body too large (${byteLength(bodyText)})`)\n\t\t}\n\n\t\tconst senderMailGroupId = await this._getMailGroupIdForMailAddress(this.userFacade.getLoggedInUser(), senderMailAddress)\n\t\tconst mailGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(senderMailGroupId)\n\n\t\tconst sk = aes256RandomKey()\n\t\tconst ownerEncSessionKey = encryptKeyWithVersionedKey(mailGroupKey, sk)\n\t\tconst service = createDraftCreateData({\n\t\t\tpreviousMessageId: previousMessageId,\n\t\t\tconversationType: conversationType,\n\t\t\townerEncSessionKey: ownerEncSessionKey.key,\n\t\t\tdraftData: createDraftData({\n\t\t\t\tsubject,\n\t\t\t\tcompressedBodyText: bodyText,\n\t\t\t\tsenderMailAddress,\n\t\t\t\tsenderName,\n\t\t\t\tconfidential,\n\t\t\t\tmethod,\n\t\t\t\ttoRecipients: toRecipients.map(recipientToDraftRecipient),\n\t\t\t\tccRecipients: ccRecipients.map(recipientToDraftRecipient),\n\t\t\t\tbccRecipients: bccRecipients.map(recipientToDraftRecipient),\n\t\t\t\treplyTos: replyTos.map(recipientToEncryptedMailAddress),\n\t\t\t\taddedAttachments: await this._createAddedAttachments(attachments, [], senderMailGroupId, mailGroupKey),\n\t\t\t\tbodyText: \"\",\n\t\t\t\tremovedAttachments: [],\n\t\t\t}),\n\t\t\townerKeyVersion: ownerEncSessionKey.encryptingKeyVersion.toString(),\n\t\t})\n\t\tconst createDraftReturn = await this.serviceExecutor.post(DraftService, service, { sessionKey: sk })\n\t\treturn this.entityClient.load(MailTypeRef, createDraftReturn.draft)\n\t}\n\n\t/**\n\t * Updates a draft mail.\n\t * @param subject The subject of the mail.\n\t * @param body The body text of the mail.\n\t * @param senderMailAddress The senders mail address.\n\t * @param senderName The name of the sender that is sent together with the mail address of the sender.\n\t * @param toRecipients The recipients the mail shall be sent to.\n\t * @param ccRecipients The recipients the mail shall be sent to in cc.\n\t * @param bccRecipients The recipients the mail shall be sent to in bcc.\n\t * @param attachments The files that shall be attached to this mail or null if the current attachments shall not be changed.\n\t * @param confidential True if the mail shall be sent end-to-end encrypted, false otherwise.\n\t * @param draft The draft to update.\n\t * @return The updated draft. Rejected with TooManyRequestsError if the number allowed mails was exceeded, AccessBlockedError if the customer is not allowed to send emails currently because he is marked for approval.\n\t */\n\tasync updateDraft({\n\t\tsubject,\n\t\tbody,\n\t\tsenderMailAddress,\n\t\tsenderName,\n\t\ttoRecipients,\n\t\tccRecipients,\n\t\tbccRecipients,\n\t\tattachments,\n\t\tconfidential,\n\t\tdraft,\n\t}: UpdateDraftParams): Promise<Mail> {\n\t\tif (byteLength(body) > UNCOMPRESSED_MAX_SIZE) {\n\t\t\tthrow new MailBodyTooLargeError(`Can't update draft, mail body too large (${byteLength(body)})`)\n\t\t}\n\n\t\tconst senderMailGroupId = await this._getMailGroupIdForMailAddress(this.userFacade.getLoggedInUser(), senderMailAddress)\n\n\t\tconst mailGroupKeyVersion = Number(draft._ownerKeyVersion ?? 0)\n\t\tconst mailGroupKey = {\n\t\t\tversion: mailGroupKeyVersion,\n\t\t\tobject: await this.keyLoaderFacade.loadSymGroupKey(senderMailGroupId, mailGroupKeyVersion),\n\t\t}\n\t\tconst currentAttachments = await this.getAttachmentIds(draft)\n\t\tconst replyTos = await this.getReplyTos(draft)\n\n\t\tconst sk = decryptKey(mailGroupKey.object, assertNotNull(draft._ownerEncSessionKey))\n\t\tconst service = createDraftUpdateData({\n\t\t\tdraft: draft._id,\n\t\t\tdraftData: createDraftData({\n\t\t\t\tsubject: subject,\n\t\t\t\tcompressedBodyText: body,\n\t\t\t\tsenderMailAddress: senderMailAddress,\n\t\t\t\tsenderName: senderName,\n\t\t\t\tconfidential: confidential,\n\t\t\t\tmethod: draft.method,\n\t\t\t\ttoRecipients: toRecipients.map(recipientToDraftRecipient),\n\t\t\t\tccRecipients: ccRecipients.map(recipientToDraftRecipient),\n\t\t\t\tbccRecipients: bccRecipients.map(recipientToDraftRecipient),\n\t\t\t\treplyTos: replyTos,\n\t\t\t\tremovedAttachments: this._getRemovedAttachments(attachments, currentAttachments),\n\t\t\t\taddedAttachments: await this._createAddedAttachments(attachments, currentAttachments, senderMailGroupId, mailGroupKey),\n\t\t\t\tbodyText: \"\",\n\t\t\t}),\n\t\t})\n\t\tthis.deferredDraftId = draft._id\n\t\t// we have to wait for the updated mail because sendMail() might be called right after this update\n\t\tthis.deferredDraftUpdate = defer()\n\t\t// use a local reference here because this._deferredDraftUpdate is set to null when the event is received async\n\t\tconst deferredUpdatePromiseWrapper = this.deferredDraftUpdate\n\t\tawait this.serviceExecutor.put(DraftService, service, { sessionKey: sk })\n\t\treturn deferredUpdatePromiseWrapper.promise\n\t}\n\n\tasync moveMails(mails: IdTuple[], sourceFolder: IdTuple, targetFolder: IdTuple): Promise<void> {\n\t\tawait this.serviceExecutor.post(MoveMailService, createMoveMailData({ mails, sourceFolder, targetFolder }))\n\t}\n\n\tasync reportMail(mail: Mail, reportType: MailReportType): Promise<void> {\n\t\tconst mailSessionKey: Aes128Key = assertNotNull(await this.crypto.resolveSessionKeyForInstance(mail))\n\t\tconst postData = createReportMailPostData({\n\t\t\tmailId: mail._id,\n\t\t\tmailSessionKey: bitArrayToUint8Array(mailSessionKey),\n\t\t\treportType,\n\t\t})\n\t\tawait this.serviceExecutor.post(ReportMailService, postData)\n\t}\n\n\tasync deleteMails(mails: IdTuple[], folder: IdTuple): Promise<void> {\n\t\tconst deleteMailData = createDeleteMailData({\n\t\t\tmails,\n\t\t\tfolder,\n\t\t})\n\t\tawait this.serviceExecutor.delete(MailService, deleteMailData)\n\t}\n\n\t/**\n\t * Returns all ids of the files that have been removed, i.e. that are contained in the existingFileIds but not in the provided files\n\t */\n\t_getRemovedAttachments(providedFiles: Attachments | null, existingFileIds: IdTuple[]): IdTuple[] {\n\t\tconst removedAttachmentIds: IdTuple[] = []\n\n\t\tif (providedFiles != null) {\n\t\t\tconst attachments = providedFiles\n\t\t\t// check which attachments have been removed\n\t\t\tfor (const fileId of existingFileIds) {\n\t\t\t\tif (\n\t\t\t\t\t!attachments.some(\n\t\t\t\t\t\t(attachment) => attachment._type !== \"DataFile\" && attachment._type !== \"FileReference\" && isSameId(getLetId(attachment), fileId),\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tremovedAttachmentIds.push(fileId)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn removedAttachmentIds\n\t}\n\n\t/**\n\t * Uploads the given data files or sets the file if it is already existing files (e.g. forwarded files) and returns all DraftAttachments\n\t */\n\tasync _createAddedAttachments(\n\t\tprovidedFiles: Attachments | null,\n\t\texistingFileIds: ReadonlyArray<IdTuple>,\n\t\tsenderMailGroupId: Id,\n\t\tmailGroupKey: VersionedKey,\n\t): Promise<DraftAttachment[]> {\n\t\tif (providedFiles == null || providedFiles.length === 0) return []\n\n\t\t// Verify mime types are correct before uploading\n\t\tvalidateMimeTypesForAttachments(providedFiles)\n\n\t\treturn promiseMap(providedFiles, async (providedFile) => {\n\t\t\t// check if this is a new attachment or an existing one\n\t\t\tif (isDataFile(providedFile)) {\n\t\t\t\t// user added attachment\n\t\t\t\tconst fileSessionKey = aes256RandomKey()\n\t\t\t\tlet referenceTokens: Array<BlobReferenceTokenWrapper>\n\t\t\t\tif (isApp() || isDesktop()) {\n\t\t\t\t\tconst { location } = await this.fileApp.writeDataFile(providedFile)\n\t\t\t\t\treferenceTokens = await this.blobFacade.encryptAndUploadNative(ArchiveDataType.Attachments, location, senderMailGroupId, fileSessionKey)\n\t\t\t\t\tawait this.fileApp.deleteFile(location)\n\t\t\t\t} else {\n\t\t\t\t\treferenceTokens = await this.blobFacade.encryptAndUpload(ArchiveDataType.Attachments, providedFile.data, senderMailGroupId, fileSessionKey)\n\t\t\t\t}\n\t\t\t\treturn this.createAndEncryptDraftAttachment(referenceTokens, fileSessionKey, providedFile, mailGroupKey)\n\t\t\t} else if (isFileReference(providedFile)) {\n\t\t\t\tconst fileSessionKey = aes256RandomKey()\n\t\t\t\tconst referenceTokens = await this.blobFacade.encryptAndUploadNative(\n\t\t\t\t\tArchiveDataType.Attachments,\n\t\t\t\t\tprovidedFile.location,\n\t\t\t\t\tsenderMailGroupId,\n\t\t\t\t\tfileSessionKey,\n\t\t\t\t)\n\t\t\t\treturn this.createAndEncryptDraftAttachment(referenceTokens, fileSessionKey, providedFile, mailGroupKey)\n\t\t\t} else if (!containsId(existingFileIds, getLetId(providedFile))) {\n\t\t\t\t// forwarded attachment which was not in the draft before\n\t\t\t\treturn this.crypto.resolveSessionKeyForInstance(providedFile).then((fileSessionKey) => {\n\t\t\t\t\tconst sessionKey = assertNotNull(fileSessionKey, \"filesessionkey was not resolved\")\n\t\t\t\t\tconst ownerEncFileSessionKey = encryptKeyWithVersionedKey(mailGroupKey, sessionKey)\n\t\t\t\t\tconst attachment = createDraftAttachment({\n\t\t\t\t\t\texistingFile: getLetId(providedFile),\n\t\t\t\t\t\townerEncFileSessionKey: ownerEncFileSessionKey.key,\n\t\t\t\t\t\tnewFile: null,\n\t\t\t\t\t\townerKeyVersion: ownerEncFileSessionKey.encryptingKeyVersion.toString(),\n\t\t\t\t\t})\n\t\t\t\t\treturn attachment\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn null\n\t\t\t}\n\t\t}) // disable concurrent file upload to avoid timeout because of missing progress events on Firefox.\n\t\t\t.then((attachments) => attachments.filter(isNotNull))\n\t\t\t.then((it) => {\n\t\t\t\t// only delete the temporary files after all attachments have been uploaded\n\t\t\t\tif (isApp()) {\n\t\t\t\t\tthis.fileApp.clearFileData().catch((e) => console.warn(\"Failed to clear files\", e))\n\t\t\t\t}\n\n\t\t\t\treturn it\n\t\t\t})\n\t}\n\n\tprivate createAndEncryptDraftAttachment(\n\t\treferenceTokens: BlobReferenceTokenWrapper[],\n\t\tfileSessionKey: AesKey,\n\t\tprovidedFile: DataFile | FileReference,\n\t\tmailGroupKey: VersionedKey,\n\t): DraftAttachment {\n\t\tconst ownerEncFileSessionKey = encryptKeyWithVersionedKey(mailGroupKey, fileSessionKey)\n\t\treturn createDraftAttachment({\n\t\t\tnewFile: createNewDraftAttachment({\n\t\t\t\tencFileName: encryptString(fileSessionKey, providedFile.name),\n\t\t\t\tencMimeType: encryptString(fileSessionKey, providedFile.mimeType),\n\t\t\t\treferenceTokens: referenceTokens,\n\t\t\t\tencCid: providedFile.cid == null ? null : encryptString(fileSessionKey, providedFile.cid),\n\t\t\t}),\n\t\t\townerEncFileSessionKey: ownerEncFileSessionKey.key,\n\t\t\townerKeyVersion: ownerEncFileSessionKey.encryptingKeyVersion.toString(),\n\t\t\texistingFile: null,\n\t\t})\n\t}\n\n\tasync sendDraft(draft: Mail, recipients: Array<Recipient>, language: string): Promise<void> {\n\t\tconst senderMailGroupId = await this._getMailGroupIdForMailAddress(this.userFacade.getLoggedInUser(), draft.sender.address)\n\t\tconst bucketKey = aes256RandomKey()\n\t\tconst sendDraftData = createSendDraftData({\n\t\t\tlanguage: language,\n\t\t\tmail: draft._id,\n\t\t\tmailSessionKey: null,\n\t\t\tattachmentKeyData: [],\n\t\t\tcalendarMethod: false,\n\t\t\tinternalRecipientKeyData: [],\n\t\t\tplaintext: false,\n\t\t\tbucketEncMailSessionKey: null,\n\t\t\tsenderNameUnencrypted: null,\n\t\t\tsecureExternalRecipientKeyData: [],\n\t\t\tsymEncInternalRecipientKeyData: [],\n\t\t\tsessionEncEncryptionAuthStatus: null,\n\t\t})\n\n\t\tconst attachments = await this.getAttachmentIds(draft)\n\t\tfor (const fileId of attachments) {\n\t\t\tconst file = await this.entityClient.load(FileTypeRef, fileId)\n\t\t\tconst fileSessionKey = assertNotNull(await this.crypto.resolveSessionKeyForInstance(file), \"fileSessionKey was null\")\n\t\t\tconst data = createAttachmentKeyData({\n\t\t\t\tfile: fileId,\n\t\t\t\tfileSessionKey: null,\n\t\t\t\tbucketEncFileSessionKey: null,\n\t\t\t})\n\n\t\t\tif (draft.confidential) {\n\t\t\t\tdata.bucketEncFileSessionKey = encryptKey(bucketKey, fileSessionKey)\n\t\t\t} else {\n\t\t\t\tdata.fileSessionKey = keyToUint8Array(fileSessionKey)\n\t\t\t}\n\n\t\t\tsendDraftData.attachmentKeyData.push(data)\n\t\t}\n\n\t\tawait Promise.all([\n\t\t\tthis.entityClient.loadRoot(TutanotaPropertiesTypeRef, this.userFacade.getUserGroupId()).then((tutanotaProperties) => {\n\t\t\t\tsendDraftData.plaintext = tutanotaProperties.sendPlaintextOnly\n\t\t\t}),\n\t\t\tthis.crypto.resolveSessionKeyForInstance(draft).then(async (mailSessionkey) => {\n\t\t\t\tconst sk = assertNotNull(mailSessionkey, \"mailSessionKey was null\")\n\t\t\t\tsendDraftData.calendarMethod = draft.method !== MailMethod.NONE\n\n\t\t\t\tif (draft.confidential) {\n\t\t\t\t\tsendDraftData.bucketEncMailSessionKey = encryptKey(bucketKey, sk)\n\t\t\t\t\tconst hasExternalSecureRecipient = recipients.some((r) => r.type === RecipientType.EXTERNAL && !!this.getContactPassword(r.contact)?.trim())\n\n\t\t\t\t\tif (hasExternalSecureRecipient) {\n\t\t\t\t\t\tsendDraftData.senderNameUnencrypted = draft.sender.name // needed for notification mail\n\t\t\t\t\t}\n\n\t\t\t\t\tawait this.addRecipientKeyData(bucketKey, sendDraftData, recipients, senderMailGroupId)\n\t\t\t\t\tif (this.isTutaCryptMail(sendDraftData)) {\n\t\t\t\t\t\tsendDraftData.sessionEncEncryptionAuthStatus = encryptString(sk, EncryptionAuthStatus.TUTACRYPT_SENDER)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsendDraftData.mailSessionKey = bitArrayToUint8Array(sk)\n\t\t\t\t}\n\t\t\t}),\n\t\t])\n\t\tawait this.serviceExecutor.post(SendDraftService, sendDraftData)\n\t}\n\n\tasync getAttachmentIds(draft: Mail): Promise<IdTuple[]> {\n\t\treturn draft.attachments\n\t}\n\n\tasync getReplyTos(draft: Mail): Promise<EncryptedMailAddress[]> {\n\t\tconst ownerEncSessionKeyProvider: OwnerEncSessionKeyProvider = this.keyProviderFromInstance(draft)\n\t\tconst mailDetailsDraftId = assertNotNull(draft.mailDetailsDraft, \"draft without mailDetailsDraft\")\n\t\tconst mailDetails = await this.entityClient.loadMultiple(\n\t\t\tMailDetailsDraftTypeRef,\n\t\t\tlistIdPart(mailDetailsDraftId),\n\t\t\t[elementIdPart(mailDetailsDraftId)],\n\t\t\townerEncSessionKeyProvider,\n\t\t)\n\t\tif (mailDetails.length === 0) {\n\t\t\tthrow new NotFoundError(`MailDetailsDraft ${draft.mailDetailsDraft}`)\n\t\t}\n\t\treturn mailDetails[0].details.replyTos\n\t}\n\n\tasync checkMailForPhishing(\n\t\tmail: Mail,\n\t\tlinks: Array<{\n\t\t\thref: string\n\t\t\tinnerHTML: string\n\t\t}>,\n\t): Promise<boolean> {\n\t\tlet score = 0\n\t\tconst senderAddress = mail.sender.address\n\n\t\tlet senderAuthenticated\n\t\tif (mail.authStatus !== null) {\n\t\t\tsenderAuthenticated = mail.authStatus === MailAuthenticationStatus.AUTHENTICATED\n\t\t} else {\n\t\t\tconst mailDetails = await this.loadMailDetailsBlob(mail)\n\t\t\tsenderAuthenticated = mailDetails.authStatus === MailAuthenticationStatus.AUTHENTICATED\n\t\t}\n\n\t\tif (senderAuthenticated) {\n\t\t\tif (this._checkFieldForPhishing(ReportedMailFieldType.FROM_ADDRESS, senderAddress)) {\n\t\t\t\tscore += 6\n\t\t\t} else {\n\t\t\t\tconst senderDomain = addressDomain(senderAddress)\n\n\t\t\t\tif (this._checkFieldForPhishing(ReportedMailFieldType.FROM_DOMAIN, senderDomain)) {\n\t\t\t\t\tscore += 6\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._checkFieldForPhishing(ReportedMailFieldType.FROM_ADDRESS_NON_AUTH, senderAddress)) {\n\t\t\t\tscore += 6\n\t\t\t} else {\n\t\t\t\tconst senderDomain = addressDomain(senderAddress)\n\n\t\t\t\tif (this._checkFieldForPhishing(ReportedMailFieldType.FROM_DOMAIN_NON_AUTH, senderDomain)) {\n\t\t\t\t\tscore += 6\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// We check that subject exists because when there's an encryption error it will be missing\n\t\tif (mail.subject && this._checkFieldForPhishing(ReportedMailFieldType.SUBJECT, mail.subject)) {\n\t\t\tscore += 3\n\t\t}\n\n\t\tfor (const link of links) {\n\t\t\tif (this._checkFieldForPhishing(ReportedMailFieldType.LINK, link.href)) {\n\t\t\t\tscore += 6\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tconst domain = getUrlDomain(link.href)\n\n\t\t\t\tif (domain && this._checkFieldForPhishing(ReportedMailFieldType.LINK_DOMAIN, domain)) {\n\t\t\t\t\tscore += 6\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst hasSuspiciousLink = links.some(({ href, innerHTML }) => {\n\t\t\tconst innerText = htmlToText(innerHTML)\n\t\t\tconst textUrl = parseUrl(innerText)\n\t\t\tconst hrefUrl = parseUrl(href)\n\t\t\treturn textUrl && hrefUrl && textUrl.hostname !== hrefUrl.hostname\n\t\t})\n\n\t\tif (hasSuspiciousLink) {\n\t\t\tscore += 6\n\t\t}\n\n\t\treturn Promise.resolve(7 < score)\n\t}\n\n\tasync deleteFolder(id: IdTuple): Promise<void> {\n\t\tconst deleteMailFolderData = createDeleteMailFolderData({\n\t\t\tfolders: [id],\n\t\t})\n\t\t// TODO make DeleteMailFolderData unencrypted in next model version\n\t\tawait this.serviceExecutor.delete(MailFolderService, deleteMailFolderData, { sessionKey: \"dummy\" as any })\n\t}\n\n\tasync fixupCounterForFolder(groupId: Id, folder: MailFolder, unreadMails: number): Promise<void> {\n\t\tconst counterId = folder.isMailSet ? getElementId(folder) : folder.mails\n\t\tconst data = createWriteCounterData({\n\t\t\tcounterType: CounterType.UnreadMails,\n\t\t\trow: groupId,\n\t\t\tcolumn: counterId,\n\t\t\tvalue: String(unreadMails),\n\t\t})\n\t\tawait this.serviceExecutor.post(CounterService, data)\n\t}\n\n\t_checkFieldForPhishing(type: ReportedMailFieldType, value: string): boolean {\n\t\tconst hash = phishingMarkerValue(type, value)\n\t\treturn this.phishingMarkers.has(hash)\n\t}\n\n\tprivate async addRecipientKeyData(bucketKey: AesKey, sendDraftData: SendDraftData, recipients: Array<Recipient>, senderMailGroupId: Id): Promise<void> {\n\t\tconst notFoundRecipients: string[] = []\n\n\t\tfor (const recipient of recipients) {\n\t\t\tif (recipient.address === SYSTEM_GROUP_MAIL_ADDRESS || !recipient) {\n\t\t\t\tnotFoundRecipients.push(recipient.address)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// copy password information if this is an external contact\n\t\t\t// otherwise load the key information from the server\n\t\t\tconst isSharedMailboxSender = !isSameId(this.userFacade.getGroupId(GroupType.Mail), senderMailGroupId)\n\n\t\t\tif (recipient.type === RecipientType.EXTERNAL) {\n\t\t\t\tconst passphrase = this.getContactPassword(recipient.contact)\n\t\t\t\tif (passphrase == null || isSharedMailboxSender) {\n\t\t\t\t\t// no password given and prevent sending to secure externals from shared group\n\t\t\t\t\tnotFoundRecipients.push(recipient.address)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst salt = generateRandomSalt()\n\t\t\t\tconst kdfType = DEFAULT_KDF_TYPE\n\t\t\t\tconst passwordKey = await this.loginFacade.deriveUserPassphraseKey({ kdfType, passphrase, salt })\n\t\t\t\tconst passwordVerifier = createAuthVerifier(passwordKey)\n\t\t\t\tconst externalGroupKeys = await this.getExternalGroupKeys(recipient.address, kdfType, passwordKey, passwordVerifier)\n\t\t\t\tconst ownerEncBucketKey = encryptKeyWithVersionedKey(externalGroupKeys.currentExternalMailGroupKey, bucketKey)\n\t\t\t\tconst data = createSecureExternalRecipientKeyData({\n\t\t\t\t\tmailAddress: recipient.address,\n\t\t\t\t\tkdfVersion: kdfType,\n\t\t\t\t\townerEncBucketKey: ownerEncBucketKey.key,\n\t\t\t\t\townerKeyVersion: ownerEncBucketKey.encryptingKeyVersion.toString(),\n\t\t\t\t\tpasswordVerifier: passwordVerifier,\n\t\t\t\t\tsalt: salt,\n\t\t\t\t\tsaltHash: sha256Hash(salt),\n\t\t\t\t\tpwEncCommunicationKey: encryptKey(passwordKey, externalGroupKeys.currentExternalUserGroupKey.object),\n\t\t\t\t\tuserGroupKeyVersion: String(externalGroupKeys.currentExternalUserGroupKey.version),\n\t\t\t\t})\n\t\t\t\tsendDraftData.secureExternalRecipientKeyData.push(data)\n\t\t\t} else {\n\t\t\t\tconst keyData = await this.crypto.encryptBucketKeyForInternalRecipient(\n\t\t\t\t\tisSharedMailboxSender ? senderMailGroupId : this.userFacade.getLoggedInUser().userGroup.group,\n\t\t\t\t\tbucketKey,\n\t\t\t\t\trecipient.address,\n\t\t\t\t\tnotFoundRecipients,\n\t\t\t\t)\n\t\t\t\tif (keyData == null) {\n\t\t\t\t\t// cannot add recipient because of notFoundError\n\t\t\t\t\t// we do not throw here because we want to collect all not found recipients first\n\t\t\t\t} else if (isSameTypeRef(keyData._type, SymEncInternalRecipientKeyDataTypeRef)) {\n\t\t\t\t\tsendDraftData.symEncInternalRecipientKeyData.push(keyData as SymEncInternalRecipientKeyData)\n\t\t\t\t} else if (isSameTypeRef(keyData._type, InternalRecipientKeyDataTypeRef)) {\n\t\t\t\t\tsendDraftData.internalRecipientKeyData.push(keyData as InternalRecipientKeyData)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (notFoundRecipients.length > 0) {\n\t\t\tthrow new RecipientsNotFoundError(notFoundRecipients.join(\"\\n\"))\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given send draft data contains only encrypt keys that have been encrypted with TutaCrypt protocol.\n\t * @VisibleForTesting\n\t * @param sendDraftData The send drafta for the mail that should be sent\n\t */\n\tisTutaCryptMail(sendDraftData: SendDraftData) {\n\t\t// if an secure external recipient is involved in the conversation we do not use asymmetric encryption\n\t\tif (sendDraftData.symEncInternalRecipientKeyData.length > 0 || sendDraftData.secureExternalRecipientKeyData.length) {\n\t\t\treturn false\n\t\t}\n\t\tif (isEmpty(sendDraftData.internalRecipientKeyData)) {\n\t\t\treturn false\n\t\t}\n\t\treturn sendDraftData.internalRecipientKeyData.every((recipientData) => recipientData.protocolVersion === CryptoProtocolVersion.TUTA_CRYPT)\n\t}\n\n\tprivate getContactPassword(contact: Contact | null): string | null {\n\t\treturn contact?.presharedPassword ?? null\n\t}\n\n\t/**\n\t * Checks that an external user instance with a mail box exists for the given recipient. If it does not exist, it is created.\n\t * Returns the user group key and the user mail group key of the external recipient.\n\t * @param recipientMailAddress\n\t * @param externalUserKdfType the kdf type used to derive externalUserPwKey\n\t * @param externalUserPwKey The external user's password key.\n\t * @param verifier The external user's verifier, base64 encoded.\n\t * @return Resolves to the external user's group key and the external user's mail group key, rejected if an error occurred\n\t */\n\tprivate async getExternalGroupKeys(\n\t\trecipientMailAddress: string,\n\t\texternalUserKdfType: KdfType,\n\t\texternalUserPwKey: AesKey,\n\t\tverifier: Uint8Array,\n\t): Promise<{ currentExternalUserGroupKey: VersionedKey; currentExternalMailGroupKey: VersionedKey }> {\n\t\tconst groupRoot = await this.entityClient.loadRoot(GroupRootTypeRef, this.userFacade.getUserGroupId())\n\t\tconst cleanedMailAddress = recipientMailAddress.trim().toLocaleLowerCase()\n\t\tconst mailAddressId = stringToCustomId(cleanedMailAddress)\n\n\t\tlet externalUserReference: ExternalUserReference\n\t\ttry {\n\t\t\texternalUserReference = await this.entityClient.load(ExternalUserReferenceTypeRef, [groupRoot.externalUserReferences, mailAddressId])\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\treturn this.createExternalUser(cleanedMailAddress, externalUserKdfType, externalUserPwKey, verifier)\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\n\t\tconst externalUser = await this.entityClient.load(UserTypeRef, externalUserReference.user)\n\t\tconst externalUserGroupId = externalUserReference.userGroup\n\t\tconst externalMailGroupId = assertNotNull(\n\t\t\texternalUser.memberships.find((m) => m.groupType === GroupType.Mail),\n\t\t\t\"no mail group membership on external user\",\n\t\t).group\n\n\t\tconst externalMailGroup = await this.entityClient.load(GroupTypeRef, externalMailGroupId)\n\t\tconst externalUserGroup = await this.entityClient.load(GroupTypeRef, externalUserGroupId)\n\t\tconst requiredInternalUserGroupKeyVersion = Number(externalUserGroup.adminGroupKeyVersion ?? 0)\n\t\tconst requiredExternalUserGroupKeyVersion = Number(externalMailGroup.adminGroupKeyVersion ?? 0)\n\t\tconst internalUserEncExternalUserKey = assertNotNull(externalUserGroup.adminGroupEncGKey, \"no adminGroupEncGKey on external user group\")\n\t\tconst externalUserEncExternalMailKey = assertNotNull(externalMailGroup.adminGroupEncGKey, \"no adminGroupEncGKey on external mail group\")\n\t\tconst requiredInternalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(this.userFacade.getUserGroupId(), requiredInternalUserGroupKeyVersion)\n\t\tconst currentExternalUserGroupKey = {\n\t\t\tobject: decryptKey(requiredInternalUserGroupKey, internalUserEncExternalUserKey),\n\t\t\tversion: Number(externalUserGroup.groupKeyVersion),\n\t\t}\n\t\tconst requiredExternalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(\n\t\t\texternalUserGroupId,\n\t\t\trequiredExternalUserGroupKeyVersion,\n\t\t\tcurrentExternalUserGroupKey,\n\t\t)\n\t\tconst currentExternalMailGroupKey = {\n\t\t\tobject: decryptKey(requiredExternalUserGroupKey, externalUserEncExternalMailKey),\n\t\t\tversion: Number(externalMailGroup.groupKeyVersion),\n\t\t}\n\t\treturn {\n\t\t\tcurrentExternalUserGroupKey,\n\t\t\tcurrentExternalMailGroupKey,\n\t\t}\n\t}\n\n\tgetRecipientKeyData(mailAddress: string): Promise<PublicKeyGetOut | null> {\n\t\treturn this.serviceExecutor\n\t\t\t.get(\n\t\t\t\tPublicKeyService,\n\t\t\t\tcreatePublicKeyGetIn({\n\t\t\t\t\tidentifierType: PublicKeyIdentifierType.MAIL_ADDRESS,\n\t\t\t\t\tidentifier: mailAddress,\n\t\t\t\t\tversion: null, // get the current version for encryption\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(ofClass(NotFoundError, () => null))\n\t}\n\n\tentityEventsReceived(data: EntityUpdate[]): Promise<void> {\n\t\treturn promiseMap(data, (update) => {\n\t\t\tif (\n\t\t\t\tthis.deferredDraftUpdate != null &&\n\t\t\t\tthis.deferredDraftId != null &&\n\t\t\t\tupdate.operation === OperationType.UPDATE &&\n\t\t\t\tisSameTypeRefByAttr(MailTypeRef, update.application, update.type) &&\n\t\t\t\tisSameId(this.deferredDraftId, [update.instanceListId, update.instanceId])\n\t\t\t) {\n\t\t\t\treturn this.entityClient\n\t\t\t\t\t.load(MailTypeRef, this.deferredDraftId)\n\t\t\t\t\t.then((mail) => {\n\t\t\t\t\t\tconst deferredPromiseWrapper = assertNotNull(this.deferredDraftUpdate, \"deferredDraftUpdate went away?\")\n\t\t\t\t\t\tthis.deferredDraftUpdate = null\n\t\t\t\t\t\tdeferredPromiseWrapper.resolve(mail)\n\t\t\t\t\t})\n\t\t\t\t\t.catch(\n\t\t\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\t\t\tconsole.log(`Could not find updated mail ${JSON.stringify([update.instanceListId, update.instanceId])}`)\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t}\n\t\t}).then(noOp)\n\t}\n\n\t/**\n\t * @param markers only phishing (not spam) markers will be sent as event bus updates\n\t */\n\tphishingMarkersUpdateReceived(markers: ReportedMailFieldMarker[]) {\n\t\tfor (const marker of markers) {\n\t\t\tif (marker.status === PhishingMarkerStatus.INACTIVE) {\n\t\t\t\tthis.phishingMarkers.delete(marker.marker)\n\t\t\t} else {\n\t\t\t\tthis.phishingMarkers.add(marker.marker)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async createExternalUser(cleanedMailAddress: string, externalUserKdfType: KdfType, externalUserPwKey: AesKey, verifier: Uint8Array) {\n\t\tconst internalUserGroupKey = this.userFacade.getCurrentUserGroupKey()\n\t\tconst internalMailGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(this.userFacade.getGroupId(GroupType.Mail))\n\n\t\tconst currentExternalUserGroupKey = freshVersioned(aes256RandomKey())\n\t\tconst currentExternalMailGroupKey = freshVersioned(aes256RandomKey())\n\t\tconst externalUserGroupInfoSessionKey = aes256RandomKey()\n\t\tconst externalMailGroupInfoSessionKey = aes256RandomKey()\n\t\tconst tutanotaPropertiesSessionKey = aes256RandomKey()\n\t\tconst mailboxSessionKey = aes256RandomKey()\n\t\tconst externalUserEncEntropy = encryptBytes(currentExternalUserGroupKey.object, random.generateRandomData(32))\n\n\t\tconst internalUserEncGroupKey = encryptKeyWithVersionedKey(internalUserGroupKey, currentExternalUserGroupKey.object)\n\t\tconst userGroupData = createCreateExternalUserGroupData({\n\t\t\tmailAddress: cleanedMailAddress,\n\t\t\texternalPwEncUserGroupKey: encryptKey(externalUserPwKey, currentExternalUserGroupKey.object),\n\t\t\tinternalUserEncUserGroupKey: internalUserEncGroupKey.key,\n\t\t\tinternalUserGroupKeyVersion: internalUserEncGroupKey.encryptingKeyVersion.toString(),\n\t\t})\n\n\t\tconst externalUserEncUserGroupInfoSessionKey = encryptKeyWithVersionedKey(currentExternalUserGroupKey, externalUserGroupInfoSessionKey)\n\t\tconst externalUserEncMailGroupKey = encryptKeyWithVersionedKey(currentExternalUserGroupKey, currentExternalMailGroupKey.object)\n\t\tconst externalUserEncTutanotaPropertiesSessionKey = encryptKeyWithVersionedKey(currentExternalUserGroupKey, tutanotaPropertiesSessionKey)\n\n\t\tconst externalMailEncMailGroupInfoSessionKey = encryptKeyWithVersionedKey(currentExternalMailGroupKey, externalMailGroupInfoSessionKey)\n\t\tconst externalMailEncMailBoxSessionKey = encryptKeyWithVersionedKey(currentExternalMailGroupKey, mailboxSessionKey)\n\n\t\tconst internalMailEncUserGroupInfoSessionKey = encryptKeyWithVersionedKey(internalMailGroupKey, externalUserGroupInfoSessionKey)\n\t\tconst internalMailEncMailGroupInfoSessionKey = encryptKeyWithVersionedKey(internalMailGroupKey, externalMailGroupInfoSessionKey)\n\n\t\tconst externalUserData = createExternalUserData({\n\t\t\tverifier,\n\t\t\tuserGroupData,\n\t\t\tkdfVersion: externalUserKdfType,\n\n\t\t\texternalUserEncEntropy,\n\t\t\texternalUserEncUserGroupInfoSessionKey: externalUserEncUserGroupInfoSessionKey.key,\n\t\t\texternalUserEncMailGroupKey: externalUserEncMailGroupKey.key,\n\t\t\texternalUserEncTutanotaPropertiesSessionKey: externalUserEncTutanotaPropertiesSessionKey.key,\n\n\t\t\texternalMailEncMailGroupInfoSessionKey: externalMailEncMailGroupInfoSessionKey.key,\n\t\t\texternalMailEncMailBoxSessionKey: externalMailEncMailBoxSessionKey.key,\n\n\t\t\tinternalMailEncUserGroupInfoSessionKey: internalMailEncUserGroupInfoSessionKey.key,\n\t\t\tinternalMailEncMailGroupInfoSessionKey: internalMailEncMailGroupInfoSessionKey.key,\n\t\t\tinternalMailGroupKeyVersion: internalMailGroupKey.version.toString(),\n\t\t})\n\t\tawait this.serviceExecutor.post(ExternalUserService, externalUserData)\n\t\treturn {\n\t\t\tcurrentExternalUserGroupKey,\n\t\t\tcurrentExternalMailGroupKey,\n\t\t}\n\t}\n\n\t_getMailGroupIdForMailAddress(user: User, mailAddress: string): Promise<Id> {\n\t\treturn promiseFilter(getUserGroupMemberships(user, GroupType.Mail), (groupMembership) => {\n\t\t\treturn this.entityClient.load(GroupTypeRef, groupMembership.group).then((mailGroup) => {\n\t\t\t\tif (mailGroup.user == null) {\n\t\t\t\t\treturn this.entityClient.load(GroupInfoTypeRef, groupMembership.groupInfo).then((mailGroupInfo) => {\n\t\t\t\t\t\treturn contains(getEnabledMailAddressesForGroupInfo(mailGroupInfo), mailAddress)\n\t\t\t\t\t})\n\t\t\t\t} else if (isSameId(mailGroup.user, user._id)) {\n\t\t\t\t\treturn this.entityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo).then((userGroupInfo) => {\n\t\t\t\t\t\treturn contains(getEnabledMailAddressesForGroupInfo(userGroupInfo), mailAddress)\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\t// not supported\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t})\n\t\t}).then((filteredMemberships) => {\n\t\t\tif (filteredMemberships.length === 1) {\n\t\t\t\treturn filteredMemberships[0].group\n\t\t\t} else {\n\t\t\t\tthrow new NotFoundError(\"group for mail address not found \" + mailAddress)\n\t\t\t}\n\t\t})\n\t}\n\n\tasync clearFolder(folderId: IdTuple) {\n\t\tconst deleteMailData = createDeleteMailData({\n\t\t\tfolder: folderId,\n\t\t\tmails: [],\n\t\t})\n\t\tawait this.serviceExecutor.delete(MailService, deleteMailData)\n\t}\n\n\tasync unsubscribe(mailId: IdTuple, recipient: string, headers: string[]) {\n\t\tconst postData = createListUnsubscribeData({\n\t\t\tmail: mailId,\n\t\t\trecipient,\n\t\t\theaders: headers.join(\"\\n\"),\n\t\t})\n\t\tawait this.serviceExecutor.post(ListUnsubscribeService, postData)\n\t}\n\n\tasync loadAttachments(mail: Mail): Promise<TutanotaFile[]> {\n\t\tif (mail.attachments.length === 0) {\n\t\t\treturn []\n\t\t}\n\t\tconst attachmentsListId = listIdPart(mail.attachments[0])\n\t\tconst attachmentElementIds = mail.attachments.map(elementIdPart)\n\n\t\tconst bucketKey = mail.bucketKey\n\t\tlet ownerEncSessionKeyProvider: OwnerEncSessionKeyProvider | undefined\n\t\tif (bucketKey) {\n\t\t\tconst typeModel = await resolveTypeReference(FileTypeRef)\n\t\t\tconst resolvedSessionKeys = await this.crypto.resolveWithBucketKey(assertNotNull(mail.bucketKey), mail, typeModel)\n\t\t\townerEncSessionKeyProvider = async (instanceElementId: Id): Promise<VersionedEncryptedKey> => {\n\t\t\t\tconst instanceSessionKey = assertNotNull(\n\t\t\t\t\tresolvedSessionKeys.instanceSessionKeys.find((instanceSessionKey) => instanceElementId === instanceSessionKey.instanceId),\n\t\t\t\t)\n\t\t\t\treturn {\n\t\t\t\t\tkey: instanceSessionKey.symEncSessionKey,\n\t\t\t\t\tencryptingKeyVersion: Number(instanceSessionKey.symKeyVersion),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn await this.entityClient.loadMultiple(FileTypeRef, attachmentsListId, attachmentElementIds, ownerEncSessionKeyProvider)\n\t}\n\n\t/**\n\t * @param mail in case it is a mailDetailsBlob\n\t */\n\tasync loadMailDetailsBlob(mail: Mail): Promise<MailDetails> {\n\t\t// if isDraft\n\t\tif (mail.mailDetailsDraft != null) {\n\t\t\tthrow new ProgrammingError(\"not supported, must be mail details blob\")\n\t\t} else {\n\t\t\tconst mailDetailsBlobId = assertNotNull(mail.mailDetails)\n\n\t\t\tconst mailDetailsBlobs = await this.entityClient.loadMultiple(\n\t\t\t\tMailDetailsBlobTypeRef,\n\t\t\t\tlistIdPart(mailDetailsBlobId),\n\t\t\t\t[elementIdPart(mailDetailsBlobId)],\n\t\t\t\tthis.keyProviderFromInstance(mail),\n\t\t\t)\n\t\t\tif (mailDetailsBlobs.length === 0) {\n\t\t\t\tthrow new NotFoundError(`MailDetailsBlob ${mailDetailsBlobId}`)\n\t\t\t}\n\t\t\treturn mailDetailsBlobs[0].details\n\t\t}\n\t}\n\n\tprivate keyProviderFromInstance(mail: Mail) {\n\t\treturn async () => ({\n\t\t\tkey: assertNotNull(mail._ownerEncSessionKey),\n\t\t\tencryptingKeyVersion: Number(mail._ownerKeyVersion),\n\t\t})\n\t}\n\n\t/**\n\t * @param mail in case it is a mailDetailsDraft\n\t */\n\tasync loadMailDetailsDraft(mail: Mail): Promise<MailDetails> {\n\t\t// if not isDraft\n\t\tif (mail.mailDetailsDraft == null) {\n\t\t\tthrow new ProgrammingError(\"not supported, must be mail details draft\")\n\t\t} else {\n\t\t\tconst detailsDraftId = assertNotNull(mail.mailDetailsDraft)\n\n\t\t\tconst mailDetailsDrafts = await this.entityClient.loadMultiple(\n\t\t\t\tMailDetailsDraftTypeRef,\n\t\t\t\tlistIdPart(detailsDraftId),\n\t\t\t\t[elementIdPart(detailsDraftId)],\n\t\t\t\tthis.keyProviderFromInstance(mail),\n\t\t\t)\n\t\t\tif (mailDetailsDrafts.length === 0) {\n\t\t\t\tthrow new NotFoundError(`MailDetailsDraft ${detailsDraftId}`)\n\t\t\t}\n\t\t\treturn mailDetailsDrafts[0].details\n\t\t}\n\t}\n\n\t/**\n\t * Create a label (aka MailSet aka {@link MailFolder} of kind {@link MailSetKind.LABEL}) for the group {@param mailGroupId}.\n\t */\n\tasync createLabel(mailGroupId: Id, labelData: { name: string; color: string }) {\n\t\tconst mailGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(mailGroupId)\n\t\tconst sk = aes256RandomKey()\n\t\tconst ownerEncSessionKey = encryptKeyWithVersionedKey(mailGroupKey, sk)\n\n\t\tawait this.serviceExecutor.post(\n\t\t\tManageLabelService,\n\t\t\tcreateManageLabelServicePostIn({\n\t\t\t\townerGroup: mailGroupId,\n\t\t\t\townerEncSessionKey: ownerEncSessionKey.key,\n\t\t\t\townerKeyVersion: String(ownerEncSessionKey.encryptingKeyVersion),\n\t\t\t\tdata: createManageLabelServiceLabelData({\n\t\t\t\t\tname: labelData.name,\n\t\t\t\t\tcolor: labelData.color,\n\t\t\t\t}),\n\t\t\t}),\n\t\t\t{\n\t\t\t\tsessionKey: sk,\n\t\t\t},\n\t\t)\n\t}\n\n\t/*\n\t * Update a label, if needed\n\t * @param label existing label\n\t * @param name possible new name for label\n\t * @param color possible new color for label\n\t */\n\tasync updateLabel(label: MailFolder, name: string, color: string) {\n\t\tif (name !== label.name || color != label.color) {\n\t\t\tlabel.name = name\n\t\t\tlabel.color = color\n\t\t\tawait this.entityClient.update(label)\n\t\t}\n\t}\n\n\tasync deleteLabel(label: MailFolder) {\n\t\tawait this.serviceExecutor.delete(\n\t\t\tManageLabelService,\n\t\t\tcreateManageLabelServiceDeleteIn({\n\t\t\t\tlabel: label._id,\n\t\t\t}),\n\t\t)\n\t}\n\n\tasync applyLabels(mails: readonly Mail[], addedLabels: readonly MailFolder[], removedLabels: readonly MailFolder[]) {\n\t\tconst postIn = createApplyLabelServicePostIn({\n\t\t\tmails: mails.map((mail) => mail._id),\n\t\t\taddedLabels: addedLabels.map((label) => label._id),\n\t\t\tremovedLabels: removedLabels.map((label) => label._id),\n\t\t})\n\t\tawait this.serviceExecutor.post(ApplyLabelService, postIn)\n\t}\n}\n\nexport function phishingMarkerValue(type: ReportedMailFieldType, value: string): string {\n\treturn type + murmurHash(value.replace(/\\s/g, \"\"))\n}\n\nfunction parseUrl(link: string): URL | null {\n\ttry {\n\t\treturn new URL(link)\n\t} catch (e) {\n\t\treturn null\n\t}\n}\n\nfunction getUrlDomain(link: string): string | null {\n\tconst url = parseUrl(link)\n\treturn url && url.hostname\n}\n\nfunction recipientToDraftRecipient(recipient: PartialRecipient): DraftRecipient {\n\treturn createDraftRecipient({\n\t\tname: recipient.name ?? \"\",\n\t\tmailAddress: recipient.address,\n\t})\n}\n\nfunction recipientToEncryptedMailAddress(recipient: PartialRecipient): EncryptedMailAddress {\n\treturn createEncryptedMailAddress({\n\t\tname: recipient.name ?? \"\",\n\t\taddress: recipient.address,\n\t})\n}\n\n/**\n * Verify all attachments contain correctly formatted MIME types. This ensures that they can be sent.\n *\n * Note that this does not verify that the mime type actually corresponds to a known MIME type.\n * @param attachments\n * @throws {ProgrammingError} if a MIME type is somehow not correctly formatted for at least one attachment\n */\nexport function validateMimeTypesForAttachments(attachments: Attachments) {\n\tconst regex = /^\\w+\\/[\\w.+-]+?(;\\s*[\\w.+-]+=([\\w.+-]+|\"[\\w\\s,.+-]+\"))*$/g\n\tfor (const attachment of attachments) {\n\t\tif (isDataFile(attachment) || isFileReference(attachment)) {\n\t\t\tif (!attachment.mimeType.match(regex)) {\n\t\t\t\tthrow new ProgrammingError(`${attachment.mimeType} is not a correctly formatted mimetype (${attachment.name})`)\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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"}