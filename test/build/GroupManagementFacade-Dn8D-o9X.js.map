{"version":3,"file":"GroupManagementFacade-Dn8D-o9X.js","names":["userFacade: UserFacade","counters: CounterFacade","entityClient: EntityClient","serviceExecutor: IServiceExecutor","pqFacade: PQFacade","keyLoaderFacade: KeyLoaderFacade","cacheManagementFacade: CacheManagementFacade","asymmetricCryptoFacade: AsymmetricCryptoFacade","cryptoWrapper: CryptoWrapper","group: Group","name: string","mailAddress: string","adminGroupKey: VersionedKey | null","groupRoot: ContactListGroupRoot","keyPair: PQKeyPairs","groupKey: AesKey","groupInfoSessionKey: AesKey","adminGroupId: Id | null","adminGroupKey: VersionedKey","ownerGroupKey: VersionedKey","user: User","groupId: Id","userId: Id","restore: boolean","version: number","viaUser: Id","requiredAdminKeyVersion: number","globalAdminGroupKey: VersionedKey","localAdminGroupKey: AesKey","userGroup: Group","adminGroupId: Id","administratedGroups: Array<AdministratedGroup>"],"sources":["../../src/common/api/worker/facades/lazy/GroupManagementFacade.ts"],"sourcesContent":["import { CounterType, GroupType, PublicKeyIdentifierType } from \"../../../common/TutanotaConstants.js\"\nimport type { ContactListGroupRoot, InternalGroupData, UserAreaGroupData } from \"../../../entities/tutanota/TypeRefs.js\"\nimport {\n\tcreateCreateMailGroupData,\n\tcreateDeleteGroupData,\n\tcreateInternalGroupData,\n\tcreateUserAreaGroupData,\n\tcreateUserAreaGroupDeleteData,\n\tcreateUserAreaGroupPostData,\n} from \"../../../entities/tutanota/TypeRefs.js\"\nimport { assertNotNull, freshVersioned, getFirstOrThrow, isNotEmpty, neverNull } from \"@tutao/tutanota-utils\"\nimport {\n\tAdministratedGroup,\n\tAdministratedGroupTypeRef,\n\tcreateLocalAdminGroupReplacementData,\n\tcreateLocalAdminRemovalPostIn,\n\tcreateMembershipAddData,\n\tcreateMembershipRemoveData,\n\tCustomerTypeRef,\n\tGroup,\n\tGroupInfoTypeRef,\n\tGroupTypeRef,\n\tLocalAdminGroupReplacementData,\n\tUser,\n\tUserTypeRef,\n} from \"../../../entities/sys/TypeRefs.js\"\nimport { CounterFacade } from \"./CounterFacade.js\"\nimport { EntityClient } from \"../../../common/EntityClient.js\"\nimport { assertWorkerOrNode } from \"../../../common/Env.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { CalendarService, ContactListGroupService, MailGroupService, TemplateGroupService } from \"../../../entities/tutanota/Services.js\"\nimport { LocalAdminRemovalService, MembershipService } from \"../../../entities/sys/Services.js\"\nimport { UserFacade } from \"../UserFacade.js\"\nimport { ProgrammingError } from \"../../../common/error/ProgrammingError.js\"\nimport { PQFacade } from \"../PQFacade.js\"\nimport { KeyLoaderFacade } from \"../KeyLoaderFacade.js\"\nimport { CacheManagementFacade } from \"./CacheManagementFacade.js\"\nimport { CryptoWrapper, encryptKeyWithVersionedKey, encryptString, VersionedKey } from \"../../crypto/CryptoWrapper.js\"\nimport { AsymmetricCryptoFacade } from \"../../crypto/AsymmetricCryptoFacade.js\"\nimport { AesKey, PQKeyPairs } from \"@tutao/tutanota-crypto\"\nimport { isGlobalAdmin } from \"../../../common/utils/UserUtils.js\"\n\nassertWorkerOrNode()\n\nexport class GroupManagementFacade {\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly counters: CounterFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly pqFacade: PQFacade,\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t\tprivate readonly cacheManagementFacade: CacheManagementFacade,\n\t\tprivate readonly asymmetricCryptoFacade: AsymmetricCryptoFacade,\n\t\tprivate readonly cryptoWrapper: CryptoWrapper,\n\t) {}\n\n\tasync readUsedSharedMailGroupStorage(group: Group): Promise<number> {\n\t\treturn this.counters.readCounterValue(CounterType.UserStorageLegacy, neverNull(group.customer), group._id)\n\t}\n\n\tasync createMailGroup(name: string, mailAddress: string): Promise<void> {\n\t\tconst adminGroupIds = this.userFacade.getGroupIds(GroupType.Admin)\n\t\tconst adminGroupId = getFirstOrThrow(adminGroupIds)\n\n\t\tlet adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId)\n\t\tlet customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(this.userFacade.getGroupId(GroupType.Customer))\n\t\tlet mailGroupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey())\n\n\t\tlet mailGroupInfoSessionKey = this.cryptoWrapper.aes256RandomKey()\n\t\tlet mailboxSessionKey = this.cryptoWrapper.aes256RandomKey()\n\t\tconst keyPair = await this.pqFacade.generateKeyPairs()\n\t\tconst mailGroupData = this.generateInternalGroupData(\n\t\t\tkeyPair,\n\t\t\tmailGroupKey.object,\n\t\t\tmailGroupInfoSessionKey,\n\t\t\tadminGroupId,\n\t\t\tadminGroupKey,\n\t\t\tcustomerGroupKey,\n\t\t)\n\n\t\tconst mailEncMailboxSessionKey = encryptKeyWithVersionedKey(mailGroupKey, mailboxSessionKey)\n\n\t\tconst data = createCreateMailGroupData({\n\t\t\tmailAddress,\n\t\t\tencryptedName: encryptString(mailGroupInfoSessionKey, name),\n\t\t\tmailEncMailboxSessionKey: mailEncMailboxSessionKey.key,\n\t\t\tgroupData: mailGroupData,\n\t\t})\n\t\tawait this.serviceExecutor.post(MailGroupService, data)\n\t}\n\n\t/**\n\t * Generates keys for the new group and prepares the group data object to create the group.\n\t *\n\t * @param name Name of the group\n\t */\n\tasync generateUserAreaGroupData(name: string): Promise<UserAreaGroupData> {\n\t\t// adminGroup Is not set when generating new customer, then the admin group will be the admin of the customer\n\t\t// adminGroupKey Is not set when generating calendar as normal user\n\t\tconst userGroup = await this.entityClient.load(GroupTypeRef, this.userFacade.getUserGroupId())\n\t\tconst adminGroupId = neverNull(userGroup.admin) // user group has always admin group\n\n\t\tlet adminGroupKey: VersionedKey | null = null\n\n\t\tif (this.userFacade.getAllGroupIds().indexOf(adminGroupId) !== -1) {\n\t\t\t// getGroupKey throws an error if user is not member of that group - so check first\n\t\t\tadminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId)\n\t\t}\n\n\t\tconst customerGroupId = this.userFacade.getGroupId(GroupType.Customer)\n\t\tconst customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(customerGroupId)\n\t\tconst userGroupKey = this.userFacade.getCurrentUserGroupKey()\n\t\tconst groupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey())\n\n\t\tconst groupRootSessionKey = this.cryptoWrapper.aes256RandomKey()\n\t\tconst groupInfoSessionKey = this.cryptoWrapper.aes256RandomKey()\n\n\t\tconst userEncGroupKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object)\n\t\tconst adminEncGroupKey = adminGroupKey ? encryptKeyWithVersionedKey(adminGroupKey, groupKey.object) : null\n\t\tconst customerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(customerGroupKey, groupInfoSessionKey)\n\t\tconst groupEncGroupRootSessionKey = encryptKeyWithVersionedKey(groupKey, groupRootSessionKey)\n\n\t\treturn createUserAreaGroupData({\n\t\t\tgroupEncGroupRootSessionKey: groupEncGroupRootSessionKey.key,\n\t\t\tcustomerEncGroupInfoSessionKey: customerEncGroupInfoSessionKey.key,\n\t\t\tuserEncGroupKey: userEncGroupKey.key,\n\t\t\tgroupInfoEncName: encryptString(groupInfoSessionKey, name),\n\t\t\tadminEncGroupKey: adminEncGroupKey?.key ?? null,\n\t\t\tadminGroup: adminGroupId,\n\t\t\tcustomerKeyVersion: customerEncGroupInfoSessionKey.encryptingKeyVersion.toString(),\n\t\t\tuserKeyVersion: userGroupKey.version.toString(),\n\t\t\tadminKeyVersion: adminEncGroupKey?.encryptingKeyVersion.toString() ?? null,\n\t\t})\n\t}\n\n\tasync createCalendar(name: string): Promise<{ user: User; group: Group }> {\n\t\tconst groupData = await this.generateUserAreaGroupData(name)\n\t\tconst postData = createUserAreaGroupPostData({\n\t\t\tgroupData,\n\t\t})\n\t\tconst postGroupData = await this.serviceExecutor.post(CalendarService, postData, { sessionKey: this.cryptoWrapper.aes256RandomKey() }) // we expect a session key to be defined as the entity is marked encrypted\n\t\tconst group = await this.entityClient.load(GroupTypeRef, postGroupData.group)\n\t\tconst user = await this.cacheManagementFacade.reloadUser()\n\n\t\treturn { user, group }\n\t}\n\n\tasync createTemplateGroup(name: string): Promise<Id> {\n\t\tconst groupData = await this.generateUserAreaGroupData(name)\n\t\tconst serviceData = createUserAreaGroupPostData({\n\t\t\tgroupData,\n\t\t})\n\n\t\tconst postGroupData = await this.serviceExecutor.post(TemplateGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() }) // we expect a session key to be defined as the entity is marked encrypted\n\n\t\tawait this.cacheManagementFacade.reloadUser()\n\n\t\treturn postGroupData.group\n\t}\n\n\tasync createContactListGroup(name: string): Promise<Group> {\n\t\tconst groupData = await this.generateUserAreaGroupData(name)\n\t\tconst serviceData = createUserAreaGroupPostData({\n\t\t\tgroupData,\n\t\t})\n\t\tconst postGroupData = await this.serviceExecutor.post(ContactListGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() }) // we expect a session key to be defined as the entity is marked encrypted\n\t\tconst group = await this.entityClient.load(GroupTypeRef, postGroupData.group)\n\t\tawait this.cacheManagementFacade.reloadUser()\n\n\t\treturn group\n\t}\n\n\tasync deleteContactListGroup(groupRoot: ContactListGroupRoot) {\n\t\tconst serviceData = createUserAreaGroupDeleteData({\n\t\t\tgroup: groupRoot._id,\n\t\t})\n\t\tawait this.serviceExecutor.delete(ContactListGroupService, serviceData)\n\t}\n\n\t/**\n\t * Assemble the data transfer type to create a new internal group on the server.\n\t * The group key version is not needed because it is always zero.\n\t */\n\tgenerateInternalGroupData(\n\t\tkeyPair: PQKeyPairs,\n\t\tgroupKey: AesKey,\n\t\tgroupInfoSessionKey: AesKey,\n\t\tadminGroupId: Id | null,\n\t\tadminGroupKey: VersionedKey,\n\t\townerGroupKey: VersionedKey,\n\t): InternalGroupData {\n\t\tconst adminEncGroupKey = encryptKeyWithVersionedKey(adminGroupKey, groupKey)\n\t\tconst ownerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(ownerGroupKey, groupInfoSessionKey)\n\n\t\treturn createInternalGroupData({\n\t\t\tpubRsaKey: null,\n\t\t\tgroupEncPrivRsaKey: null,\n\t\t\tpubEccKey: keyPair.eccKeyPair.publicKey,\n\t\t\tgroupEncPrivEccKey: this.cryptoWrapper.encryptEccKey(groupKey, keyPair.eccKeyPair.privateKey),\n\t\t\tpubKyberKey: this.cryptoWrapper.kyberPublicKeyToBytes(keyPair.kyberKeyPair.publicKey),\n\t\t\tgroupEncPrivKyberKey: this.cryptoWrapper.encryptKyberKey(groupKey, keyPair.kyberKeyPair.privateKey),\n\t\t\tadminGroup: adminGroupId,\n\t\t\tadminEncGroupKey: adminEncGroupKey.key,\n\t\t\townerEncGroupInfoSessionKey: ownerEncGroupInfoSessionKey.key,\n\t\t\tadminKeyVersion: adminEncGroupKey.encryptingKeyVersion.toString(),\n\t\t\townerKeyVersion: ownerEncGroupInfoSessionKey.encryptingKeyVersion.toString(),\n\t\t})\n\t}\n\n\tasync addUserToGroup(user: User, groupId: Id): Promise<void> {\n\t\tconst userGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(user.userGroup.group)\n\t\tconst groupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId)\n\t\tconst symEncGKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object)\n\t\tconst data = createMembershipAddData({\n\t\t\tuser: user._id,\n\t\t\tgroup: groupId,\n\t\t\tsymEncGKey: symEncGKey.key,\n\t\t\tgroupKeyVersion: String(groupKey.version),\n\t\t\tsymKeyVersion: symEncGKey.encryptingKeyVersion.toString(),\n\t\t})\n\t\tawait this.serviceExecutor.post(MembershipService, data)\n\t}\n\n\tasync removeUserFromGroup(userId: Id, groupId: Id): Promise<void> {\n\t\tconst data = createMembershipRemoveData({\n\t\t\tuser: userId,\n\t\t\tgroup: groupId,\n\t\t})\n\t\tawait this.serviceExecutor.delete(MembershipService, data)\n\t}\n\n\tasync deactivateGroup(group: Group, restore: boolean): Promise<void> {\n\t\tconst data = createDeleteGroupData({\n\t\t\tgroup: group._id,\n\t\t\trestore,\n\t\t})\n\n\t\tif (group.type === GroupType.Mail) {\n\t\t\tawait this.serviceExecutor.delete(MailGroupService, data)\n\t\t} else {\n\t\t\tthrow new Error(\"invalid group type for deactivation\")\n\t\t}\n\t}\n\n\tasync getGroupKeyViaUser(groupId: Id, version: number, viaUser: Id): Promise<AesKey> {\n\t\tconst currentGroupKey = await this.getCurrentGroupKeyViaUser(groupId, viaUser)\n\t\treturn this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey)\n\t}\n\n\t/**\n\t * Get a group key for any group we are admin and know some member of.\n\t *\n\t * Unlike {@link getCurrentGroupKeyViaAdminEncGKey} this should work for any group because we will actually go a \"long\" route of decrypting userGroupKey of the\n\t * member and decrypting group key with that.\n\t */\n\tasync getCurrentGroupKeyViaUser(groupId: Id, viaUser: Id): Promise<VersionedKey> {\n\t\tconst user = await this.entityClient.load(UserTypeRef, viaUser)\n\t\tconst membership = user.memberships.find((m) => m.group === groupId)\n\t\tif (membership == null) {\n\t\t\tthrow new Error(`User doesn't have this group membership! User: ${viaUser} groupId: ${groupId}`)\n\t\t}\n\t\tconst requiredUserGroupKeyVersion = membership.symKeyVersion\n\t\tconst requiredUserGroupKey = await this.getGroupKeyViaAdminEncGKey(user.userGroup.group, Number(requiredUserGroupKeyVersion))\n\n\t\tconst key = this.cryptoWrapper.decryptKey(requiredUserGroupKey, membership.symEncGKey)\n\t\tconst version = Number(membership.groupKeyVersion)\n\n\t\treturn { object: key, version }\n\t}\n\n\tasync getGroupKeyViaAdminEncGKey(groupId: Id, version: number): Promise<AesKey> {\n\t\tif (this.userFacade.hasGroup(groupId)) {\n\t\t\t// e.g. I am a global admin and want to add another user to the global admin group\n\t\t\treturn this.keyLoaderFacade.loadSymGroupKey(groupId, version)\n\t\t} else {\n\t\t\tconst currentGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId)\n\t\t\treturn this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey)\n\t\t}\n\t}\n\n\t/**\n\t * @returns true if the group currently has an adminEncGKey. This may be an asymmetrically encrypted one.\n\t */\n\thasAdminEncGKey(group: Group) {\n\t\treturn (group.adminGroupEncGKey != null && group.adminGroupEncGKey.length !== 0) || group.pubAdminGroupEncGKey != null\n\t}\n\n\t/**\n\t * Get a group key for certain group types.\n\t *\n\t * Some groups (e.g. user groups or shared mailboxes) have adminGroupEncGKey set on creation. For those groups we can fairly easily get a group key without\n\t * decrypting userGroupKey of some member of that group.\n\t */\n\tasync getCurrentGroupKeyViaAdminEncGKey(groupId: Id): Promise<VersionedKey> {\n\t\tif (this.userFacade.hasGroup(groupId)) {\n\t\t\t// e.g. I am a global admin and want to add another user to the global admin group\n\t\t\t// or I am an admin and I am a member of the target group (eg: shared mailboxes)\n\t\t\treturn this.keyLoaderFacade.getCurrentSymGroupKey(groupId)\n\t\t} else {\n\t\t\tconst group = await this.cacheManagementFacade.reloadGroup(groupId)\n\t\t\tif (!this.hasAdminEncGKey(group)) {\n\t\t\t\tthrow new ProgrammingError(\"Group doesn't have adminGroupEncGKey, you can't get group key this way\")\n\t\t\t}\n\t\t\tif (!(group.admin && this.userFacade.hasGroup(group.admin))) {\n\t\t\t\tthrow new Error(`The user is not a member of the admin group ${group.admin} when trying to get the group key for group ${groupId}`)\n\t\t\t}\n\n\t\t\t// e.g. I am a member of the group that administrates group G and want to add a new member to G\n\t\t\tconst requiredAdminKeyVersion = Number(group.adminGroupKeyVersion ?? 0)\n\t\t\tif (group.adminGroupEncGKey != null) {\n\t\t\t\treturn await this.decryptViaSymmetricAdminGKey(group, requiredAdminKeyVersion)\n\t\t\t} else {\n\t\t\t\treturn await this.decryptViaAsymmetricAdminGKey(group, requiredAdminKeyVersion)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async decryptViaSymmetricAdminGKey(group: Group, requiredAdminKeyVersion: number): Promise<VersionedKey> {\n\t\tconst requiredAdminGroupKey = await this.keyLoaderFacade.loadSymGroupKey(assertNotNull(group.admin), requiredAdminKeyVersion)\n\t\tconst decryptedKey = this.cryptoWrapper.decryptKey(requiredAdminGroupKey, assertNotNull(group.adminGroupEncGKey))\n\t\treturn { object: decryptedKey, version: Number(group.groupKeyVersion) }\n\t}\n\n\tprivate async decryptViaAsymmetricAdminGKey(group: Group, requiredAdminKeyVersion: number): Promise<VersionedKey> {\n\t\tconst requiredAdminGroupKeyPair = await this.keyLoaderFacade.loadKeypair(assertNotNull(group.admin), requiredAdminKeyVersion)\n\t\tconst pubEncKeyData = assertNotNull(group.pubAdminGroupEncGKey)\n\t\tconst decryptedKey = await this.asymmetricCryptoFacade.decryptSymKeyWithKeyPairAndAuthenticate(requiredAdminGroupKeyPair, pubEncKeyData, {\n\t\t\tidentifier: group._id,\n\t\t\tidentifierType: PublicKeyIdentifierType.GROUP_ID,\n\t\t})\n\t\treturn { object: decryptedKey.decryptedAesKey, version: Number(group.groupKeyVersion) }\n\t}\n\n\t/**\n\t * Context: removal of local admins\n\t * Problem: local admins encrypted the user group key of their users with their admin group key but global admin can't\n\t * decrypt these with their admin group key.\n\t * We want the global admin to still be able to decrypt user data.\n\t *\n\t * This function will decrypt the user group key with the local admin group key and then encrypt it with the global admin group key\n\t * Please note that this function is free of side effects, it only returns a new reference of the newly modified group.\n\t *\n\t * @param globalAdminGroupKey the key of the global admin that will encrypt the user group key\n\t * @param localAdminGroupKey the key of the local admin that was used to encrypt the user group key and will be used to decrypt the user group key\n\t * @param userGroup the user group that needs its adminEncGroupKey to be replaced\n\t */\n\tasync replaceLocalAdminEncGroupKeyWithGlobalAdminEncGroupKey(\n\t\tglobalAdminGroupKey: VersionedKey,\n\t\tlocalAdminGroupKey: AesKey,\n\t\tuserGroup: Group,\n\t): Promise<LocalAdminGroupReplacementData> {\n\t\tconst localAdminEncUserGroupKey = assertNotNull(userGroup.adminGroupEncGKey)\n\t\tconst decryptedUserGroupKey = this.cryptoWrapper.decryptKey(localAdminGroupKey, localAdminEncUserGroupKey)\n\n\t\tconst globalAdminEncUserGroupKey = this.cryptoWrapper.encryptKey(globalAdminGroupKey.object, decryptedUserGroupKey)\n\n\t\tconst groupUpdate = createLocalAdminGroupReplacementData({\n\t\t\tadminGroupKeyVersion: String(globalAdminGroupKey.version),\n\t\t\tadminGroupEncGKey: globalAdminEncUserGroupKey,\n\t\t\tgroupId: userGroup._id,\n\t\t\tgroupKeyVersion: userGroup.groupKeyVersion,\n\t\t})\n\t\treturn groupUpdate\n\t}\n\n\t/**\n\t * Since local admins won't be supported anymore and will be removed we need to let the\n\t * global admin access the locally administrated group data.\n\t * As its name suggest this function migrate the users administrated by the local admins\n\t * to the global admin of the customer so that the global admin can have direct\n\t * encryption and decryption of its users group keys.\n\t */\n\tasync migrateLocalAdminsToGlobalAdmins() {\n\t\tconst user = this.userFacade.getLoggedInUser()\n\t\tif (!isGlobalAdmin(user)) {\n\t\t\treturn\n\t\t}\n\n\t\tconst customer = await this.entityClient.load(CustomerTypeRef, assertNotNull(user.customer))\n\t\tconst teamGroupInfos = await this.entityClient.loadAll(GroupInfoTypeRef, customer.teamGroups)\n\t\tconst localAdminGroupInfos = teamGroupInfos.filter((group) => group.groupType === GroupType.LocalAdmin)\n\t\tconst adminGroupId: Id = customer.adminGroup\n\t\tconst adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId)\n\t\tconst postIn = createLocalAdminRemovalPostIn({ groupUpdates: [] })\n\n\t\tfor (let localAdminGroupInfo of localAdminGroupInfos) {\n\t\t\tconst localAdminGroup = await this.entityClient.load(GroupTypeRef, localAdminGroupInfo.group)\n\t\t\tconst administratedGroupsListId = localAdminGroup.administratedGroups?.items\n\t\t\tif (administratedGroupsListId == null) return null\n\t\t\tconst administratedGroups: Array<AdministratedGroup> = await this.entityClient.loadAll(AdministratedGroupTypeRef, administratedGroupsListId)\n\n\t\t\t// we assume local admins never had their key rotation done and so their sym key version (requestedVersion) is stuck to 0 by default\n\t\t\tconst thisLocalAdminGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(localAdminGroup._id)\n\t\t\tfor (let ag of administratedGroups) {\n\t\t\t\tconst thisRelatedGroupInfo = await this.entityClient.load(GroupInfoTypeRef, ag.groupInfo)\n\t\t\t\tconst thisRelatedGroup = await this.entityClient.load(GroupTypeRef, thisRelatedGroupInfo.group)\n\n\t\t\t\tconst groupUpdate = await this.replaceLocalAdminEncGroupKeyWithGlobalAdminEncGroupKey(\n\t\t\t\t\tadminGroupKey,\n\t\t\t\t\tthisLocalAdminGroupKey.object,\n\t\t\t\t\tthisRelatedGroup,\n\t\t\t\t)\n\t\t\t\tpostIn.groupUpdates.push(groupUpdate)\n\t\t\t}\n\t\t}\n\t\tif (isNotEmpty(postIn.groupUpdates)) {\n\t\t\tawait this.serviceExecutor.post(LocalAdminRemovalService, postIn)\n\t\t}\n\t}\n}\n"],"mappings":"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"}