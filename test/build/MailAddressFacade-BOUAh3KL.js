
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, findAndRemove, getFirstOrThrow, ofClass } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertWorkerOrNode } from "./Env-D5xGlXfw.js";
import { PreconditionFailedError } from "./RestError-D17JEBMr.js";
import { MailboxGroupRootTypeRef, MailboxPropertiesTypeRef, createMailAddressProperties, createMailboxProperties } from "./TypeRefs-CR3TLWn0.js";
import { GroupInfoTypeRef, GroupTypeRef, UserTypeRef, createDomainMailAddressAvailabilityData, createMailAddressAliasGetIn, createMailAddressAliasServiceData, createMailAddressAliasServiceDataDelete, createMultipleMailAddressAvailabilityData, createStringWrapper } from "./TypeRefs-BP1jvX9p.js";
import { DomainMailAddressAvailabilityService, MailAddressAliasService, MultipleMailAddressAvailabilityService } from "./Services-CZFE0084.js";
import { getEnabledMailAddressesForGroupInfo } from "./GroupUtils-0ZkLIAeC.js";

//#region ../src/common/api/worker/facades/lazy/MailAddressFacade.ts
assertWorkerOrNode();
var MailAddressFacade = class {
	constructor(userFacade, groupManagement, serviceExecutor, nonCachingEntityClient) {
		this.userFacade = userFacade;
		this.groupManagement = groupManagement;
		this.serviceExecutor = serviceExecutor;
		this.nonCachingEntityClient = nonCachingEntityClient;
	}
	/**
	* For legacy accounts the given userGroupId is ignored since the alias counters are for the customer
	*/
	getAliasCounters(userGroupId) {
		const data = createMailAddressAliasGetIn({ targetGroup: userGroupId });
		return this.serviceExecutor.get(MailAddressAliasService, data);
	}
	isMailAddressAvailable(mailAddress) {
		if (this.userFacade.isFullyLoggedIn()) {
			const data = createDomainMailAddressAvailabilityData({ mailAddress });
			return this.serviceExecutor.get(DomainMailAddressAvailabilityService, data).then((result) => result.available);
		} else return this.areMailAddressesAvailable([mailAddress]).then((result) => getFirstOrThrow(result).available);
	}
	async areMailAddressesAvailable(mailAddresses) {
		const data = createMultipleMailAddressAvailabilityData({ mailAddresses: mailAddresses.map((mailAddress) => createStringWrapper({ value: mailAddress })) });
		const result = await this.serviceExecutor.get(MultipleMailAddressAvailabilityService, data);
		return result.availabilities;
	}
	/**
	* Add an {@param alias} to {@param targetGroupId}.
	* {@param targetGroupId} is *not* a Mail group, it is currently only a user group.
	*
	* Can only be done by an admin.
	*/
	async addMailAlias(targetGroupId, alias) {
		const data = createMailAddressAliasServiceData({
			group: targetGroupId,
			mailAddress: alias
		});
		await this.serviceExecutor.post(MailAddressAliasService, data);
	}
	/**
	* Enable/disable an {@param alias} on {@param targetGroupId}.
	* {@param targetGroupId} is *not* a Mail group, it is currently only a user group.
	*
	* {@param restore} means whether the alias will be enabled or disabled.
	*
	* Can only be done by an admin.
	*/
	async setMailAliasStatus(targetGroupId, alias, restore) {
		const deleteData = createMailAddressAliasServiceDataDelete({
			mailAddress: alias,
			restore,
			group: targetGroupId
		});
		await this.serviceExecutor.delete(MailAddressAliasService, deleteData);
	}
	/**
	* Get mailAddress to senderName mappings for mail group that the specified user is a member of.
	* if no user is given, the operation is attempted as an admin of the given group.
	* */
	async getSenderNames(mailGroupId, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		return this.collectSenderNames(mailboxProperties);
	}
	/**
	* Set mailAddress to senderName mapping for mail group that the specified user is a member of.
	* if no user is specified, the operation will be attempted as an admin of the given group.
	* */
	async setSenderName(mailGroupId, mailAddress, senderName, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		let mailAddressProperty = mailboxProperties.mailAddressProperties.find((p) => p.mailAddress === mailAddress);
		if (mailAddressProperty == null) {
			mailAddressProperty = createMailAddressProperties({
				mailAddress,
				senderName: ""
			});
			mailboxProperties.mailAddressProperties.push(mailAddressProperty);
		}
		mailAddressProperty.senderName = senderName;
		const updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser);
		return this.collectSenderNames(updatedProperties);
	}
	/**
	* remove the sender name of the given mail address.
	* If no user is given, the operation will be attempted as an admin of the group.
	*/
	async removeSenderName(mailGroupId, mailAddress, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		findAndRemove(mailboxProperties.mailAddressProperties, (p) => p.mailAddress === mailAddress);
		const updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser);
		return this.collectSenderNames(updatedProperties);
	}
	async getOrCreateMailboxProperties(mailGroupId, viaUser) {
		const mailboxGroupRoot = await this.nonCachingEntityClient.load(MailboxGroupRootTypeRef, mailGroupId);
		if (mailboxGroupRoot.mailboxProperties == null) {
			const currentGroupKey = viaUser ? await this.groupManagement.getCurrentGroupKeyViaUser(mailGroupId, viaUser) : await this.groupManagement.getCurrentGroupKeyViaAdminEncGKey(mailGroupId);
			mailboxGroupRoot.mailboxProperties = await this.createMailboxProperties(mailboxGroupRoot, currentGroupKey);
		}
		const groupKeyProvider = async (version) => viaUser ? await this.groupManagement.getGroupKeyViaUser(mailGroupId, version, viaUser) : await this.groupManagement.getGroupKeyViaAdminEncGKey(mailGroupId, version);
		const mailboxProperties = await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxGroupRoot.mailboxProperties, { ownerKeyProvider: groupKeyProvider });
		return mailboxProperties.mailAddressProperties.length === 0 ? this.mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) : mailboxProperties;
	}
	/**
	* set the legacy sender name (groupInfo.name) of the group on all assigned mail addresses.
	* if no user is given, the operation will be attempted as an admin of the group of the given mailboxProperties.
	* */
	async mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) {
		const groupInfo = viaUser ? await this.loadUserGroupInfo(viaUser) : await this.loadMailGroupInfo(mailboxProperties._ownerGroup);
		const legacySenderName = groupInfo.name;
		const mailAddresses = getEnabledMailAddressesForGroupInfo(groupInfo);
		for (const mailAddress of mailAddresses) mailboxProperties.mailAddressProperties.push(createMailAddressProperties({
			mailAddress,
			senderName: legacySenderName
		}));
		return this.updateMailboxProperties(mailboxProperties, viaUser);
	}
	async loadUserGroupInfo(userId) {
		const user = await this.nonCachingEntityClient.load(UserTypeRef, userId);
		return await this.nonCachingEntityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo);
	}
	async loadMailGroupInfo(groupId) {
		const group = await this.nonCachingEntityClient.load(GroupTypeRef, groupId);
		return await this.nonCachingEntityClient.load(GroupInfoTypeRef, group.groupInfo);
	}
	async createMailboxProperties(mailboxGroupRoot, groupKey) {
		const _ownerGroup = mailboxGroupRoot._ownerGroup;
		const mailboxProperties = createMailboxProperties({
			..._ownerGroup != null ? { _ownerGroup } : null,
			reportMovedMails: "",
			mailAddressProperties: []
		});
		return this.nonCachingEntityClient.setup(null, mailboxProperties, undefined, { ownerKey: groupKey }).catch(ofClass(PreconditionFailedError, (e) => {
			if (e.data && e.data.startsWith("exists:")) {
				const existingId = e.data.substring("exists:".length);
				console.log("mailboxProperties already exists", existingId);
				return existingId;
			} else throw new ProgrammingError(`Could not create mailboxProperties, precondition: ${e.data}`);
		}));
	}
	async updateMailboxProperties(mailboxProperties, viaUser) {
		const groupKeyProvider = async (version) => viaUser ? await this.groupManagement.getGroupKeyViaUser(assertNotNull(mailboxProperties._ownerGroup), version, viaUser) : await this.groupManagement.getGroupKeyViaAdminEncGKey(assertNotNull(mailboxProperties._ownerGroup), version);
		await this.nonCachingEntityClient.update(mailboxProperties, { ownerKeyProvider: groupKeyProvider });
		return await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxProperties._id, { ownerKeyProvider: groupKeyProvider });
	}
	async collectSenderNames(mailboxProperties) {
		const result = new Map();
		for (const data of mailboxProperties.mailAddressProperties) result.set(data.mailAddress, data.senderName);
		return result;
	}
};

//#endregion
export { MailAddressFacade };
//# sourceMappingURL=MailAddressFacade-BOUAh3KL.js.map