
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`

//#region ../libs/linkify.js
const encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
const encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
/**
* @template A
* @template B
* @param {A} target
* @param {B} properties
* @return {A & B}
*/
const assign = (target, properties) => {
	for (const key in properties) target[key] = properties[key];
	return target;
};
/**
* Finite State Machine generation utilities
*/
/**
* @template T
* @typedef {{ [group: string]: T[] }} Collections
*/
/**
* @typedef {{ [group: string]: true }} Flags
*/
const numeric = "numeric";
const ascii = "ascii";
const alpha = "alpha";
const asciinumeric = "asciinumeric";
const alphanumeric = "alphanumeric";
const domain = "domain";
const emoji = "emoji";
const scheme = "scheme";
const slashscheme = "slashscheme";
const whitespace = "whitespace";
/**
* @template T
* @param {string} name
* @param {Collections<T>} groups to register in
* @returns {T[]} Current list of tokens in the given collection
*/
function registerGroup(name, groups) {
	if (!(name in groups)) groups[name] = [];
	return groups[name];
}
/**
* @template T
* @param {T} t token to add
* @param {Collections<T>} groups
* @param {Flags} flags
*/
function addToGroups(t, flags, groups) {
	if (flags[numeric]) {
		flags[asciinumeric] = true;
		flags[alphanumeric] = true;
	}
	if (flags[ascii]) {
		flags[asciinumeric] = true;
		flags[alpha] = true;
	}
	if (flags[asciinumeric]) flags[alphanumeric] = true;
	if (flags[alpha]) flags[alphanumeric] = true;
	if (flags[alphanumeric]) flags[domain] = true;
	if (flags[emoji]) flags[domain] = true;
	for (const k in flags) {
		const group = registerGroup(k, groups);
		if (group.indexOf(t) < 0) group.push(t);
	}
}
/**
* @template T
* @param {T} t token to check
* @param {Collections<T>} groups
* @returns {Flags} group flags that contain this token
*/
function flagsForToken(t, groups) {
	const result = {};
	for (const c in groups) if (groups[c].indexOf(t) >= 0) result[c] = true;
	return result;
}
/**
* @template T
* @typedef {null | T } Transition
*/
/**
* Define a basic state machine state. j is the list of character transitions,
* jr is the list of regex-match transitions, jd is the default state to
* transition to t is the accepting token type, if any. If this is the terminal
* state, then it does not emit a token.
*
* The template type T represents the type of the token this state accepts. This
* should be a string (such as of the token exports in `text.js`) or a
* MultiToken subclass (from `multi.js`)
*
* @template T
* @param {T} [token] Token that this state emits
*/
function State(token) {
	if (token === void 0) token = null;
	/** @type {{ [input: string]: State<T> }} j */
	this.j = {};
	/** @type {[RegExp, State<T>][]} jr */
	this.jr = [];
	/** @type {?State<T>} jd */
	this.jd = null;
	/** @type {?T} t */
	this.t = token;
}
/**
* Scanner token groups
* @type Collections<string>
*/
State.groups = {};
State.prototype = {
	accepts() {
		return !!this.t;
	},
	go(input) {
		const state = this;
		const nextState = state.j[input];
		if (nextState) return nextState;
		for (let i = 0; i < state.jr.length; i++) {
			const regex = state.jr[i][0];
			const nextState$1 = state.jr[i][1];
			if (nextState$1 && regex.test(input)) return nextState$1;
		}
		return state.jd;
	},
	has(input, exactOnly) {
		if (exactOnly === void 0) exactOnly = false;
		return exactOnly ? input in this.j : !!this.go(input);
	},
	ta(inputs, next, flags, groups) {
		for (let i = 0; i < inputs.length; i++) this.tt(inputs[i], next, flags, groups);
	},
	tr(regexp, next, flags, groups) {
		groups = groups || State.groups;
		let nextState;
		if (next && next.j) nextState = next;
else {
			nextState = new State(next);
			if (flags && groups) addToGroups(next, flags, groups);
		}
		this.jr.push([regexp, nextState]);
		return nextState;
	},
	ts(input, next, flags, groups) {
		let state = this;
		const len = input.length;
		if (!len) return state;
		for (let i = 0; i < len - 1; i++) state = state.tt(input[i]);
		return state.tt(input[len - 1], next, flags, groups);
	},
	tt(input, next, flags, groups) {
		groups = groups || State.groups;
		const state = this;
		if (next && next.j) {
			state.j[input] = next;
			return next;
		}
		const t = next;
		let nextState, templateState = state.go(input);
		if (templateState) {
			nextState = new State();
			assign(nextState.j, templateState.j);
			nextState.jr.push.apply(nextState.jr, templateState.jr);
			nextState.jd = templateState.jd;
			nextState.t = templateState.t;
		} else nextState = new State();
		if (t) {
			if (groups) {
				if (nextState.t && typeof nextState.t === "string") {
					const allFlags = assign(flagsForToken(nextState.t, groups), flags);
					addToGroups(t, allFlags, groups);
				} else if (flags) addToGroups(t, flags, groups);
			}
			nextState.t = t;
		}
		state.j[input] = nextState;
		return nextState;
	}
};
/**
* @template T
* @param {State<T>} state
* @param {string | string[]} input
* @param {Flags} [flags]
* @param {Collections<T>} [groups]
*/
const ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
/**
* @template T
* @param {State<T>} state
* @param {RegExp} regexp
* @param {T | State<T>} [next]
* @param {Flags} [flags]
* @param {Collections<T>} [groups]
*/
const tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
/**
* @template T
* @param {State<T>} state
* @param {string | string[]} input
* @param {T | State<T>} [next]
* @param {Flags} [flags]
* @param {Collections<T>} [groups]
*/
const ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
/**
* @template T
* @param {State<T>} state
* @param {string} input
* @param {T | State<T>} [next]
* @param {Collections<T>} [groups]
* @param {Flags} [flags]
*/
const tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
/******************************************************************************
Text Tokens
Identifiers for token outputs from the regexp scanner
******************************************************************************/
const WORD = "WORD";
const UWORD = "UWORD";
const LOCALHOST = "LOCALHOST";
const TLD = "TLD";
const UTLD = "UTLD";
const SCHEME = "SCHEME";
const SLASH_SCHEME = "SLASH_SCHEME";
const NUM = "NUM";
const WS = "WS";
const NL$1 = "NL";
const OPENBRACE = "OPENBRACE";
const CLOSEBRACE = "CLOSEBRACE";
const OPENBRACKET = "OPENBRACKET";
const CLOSEBRACKET = "CLOSEBRACKET";
const OPENPAREN = "OPENPAREN";
const CLOSEPAREN = "CLOSEPAREN";
const OPENANGLEBRACKET = "OPENANGLEBRACKET";
const CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
const FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
const FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
const LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
const RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
const LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
const RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
const FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
const FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
const AMPERSAND = "AMPERSAND";
const APOSTROPHE = "APOSTROPHE";
const ASTERISK = "ASTERISK";
const AT = "AT";
const BACKSLASH = "BACKSLASH";
const BACKTICK = "BACKTICK";
const CARET = "CARET";
const COLON = "COLON";
const COMMA = "COMMA";
const DOLLAR = "DOLLAR";
const DOT = "DOT";
const EQUALS = "EQUALS";
const EXCLAMATION = "EXCLAMATION";
const HYPHEN = "HYPHEN";
const PERCENT = "PERCENT";
const PIPE = "PIPE";
const PLUS = "PLUS";
const POUND = "POUND";
const QUERY = "QUERY";
const QUOTE = "QUOTE";
const SEMI = "SEMI";
const SLASH = "SLASH";
const TILDE = "TILDE";
const UNDERSCORE = "UNDERSCORE";
const EMOJI$1 = "EMOJI";
const SYM = "SYM";
var tk = /*#__PURE__*/ Object.freeze({
	__proto__: null,
	WORD,
	UWORD,
	LOCALHOST,
	TLD,
	UTLD,
	SCHEME,
	SLASH_SCHEME,
	NUM,
	WS,
	NL: NL$1,
	OPENBRACE,
	CLOSEBRACE,
	OPENBRACKET,
	CLOSEBRACKET,
	OPENPAREN,
	CLOSEPAREN,
	OPENANGLEBRACKET,
	CLOSEANGLEBRACKET,
	FULLWIDTHLEFTPAREN,
	FULLWIDTHRIGHTPAREN,
	LEFTCORNERBRACKET,
	RIGHTCORNERBRACKET,
	LEFTWHITECORNERBRACKET,
	RIGHTWHITECORNERBRACKET,
	FULLWIDTHLESSTHAN,
	FULLWIDTHGREATERTHAN,
	AMPERSAND,
	APOSTROPHE,
	ASTERISK,
	AT,
	BACKSLASH,
	BACKTICK,
	CARET,
	COLON,
	COMMA,
	DOLLAR,
	DOT,
	EQUALS,
	EXCLAMATION,
	HYPHEN,
	PERCENT,
	PIPE,
	PLUS,
	POUND,
	QUERY,
	QUOTE,
	SEMI,
	SLASH,
	TILDE,
	UNDERSCORE,
	EMOJI: EMOJI$1,
	SYM
});
const ASCII_LETTER = /[a-z]/;
const LETTER = /\p{L}/u;
const EMOJI = /\p{Emoji}/u;
const DIGIT = /\d/;
const SPACE = /\s/;
/**
The scanner provides an interface that takes a string of text as input, and
outputs an array of tokens instances that can be used for easy URL parsing.
*/
const NL = "\n";
const EMOJI_VARIATION = "️";
const EMOJI_JOINER = "‍";
let tlds = null, utlds = null;
/**
* Scanner output token:
* - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')
* - `v` is the value of the token (e.g., '123', '❤️', 'com')
* - `s` is the start index of the token in the original string
* - `e` is the end index of the token in the original string
* @typedef {{t: string, v: string, s: number, e: number}} Token
*/
/**
* @template T
* @typedef {{ [collection: string]: T[] }} Collections
*/
/**
* Initialize the scanner character-based state machine for the given start
* state
* @param {[string, boolean][]} customSchemes List of custom schemes, where each
* item is a length-2 tuple with the first element set to the string scheme, and
* the second element set to `true` if the `://` after the scheme is optional
*/
function init$2(customSchemes) {
	if (customSchemes === void 0) customSchemes = [];
	/** @type Collections<string> */
	const groups = {};
	State.groups = groups;
	/** @type State<string> */
	const Start = new State();
	if (tlds == null) tlds = decodeTlds(encodedTlds);
	if (utlds == null) utlds = decodeTlds(encodedUtlds);
	tt(Start, "'", APOSTROPHE);
	tt(Start, "{", OPENBRACE);
	tt(Start, "}", CLOSEBRACE);
	tt(Start, "[", OPENBRACKET);
	tt(Start, "]", CLOSEBRACKET);
	tt(Start, "(", OPENPAREN);
	tt(Start, ")", CLOSEPAREN);
	tt(Start, "<", OPENANGLEBRACKET);
	tt(Start, ">", CLOSEANGLEBRACKET);
	tt(Start, "（", FULLWIDTHLEFTPAREN);
	tt(Start, "）", FULLWIDTHRIGHTPAREN);
	tt(Start, "「", LEFTCORNERBRACKET);
	tt(Start, "」", RIGHTCORNERBRACKET);
	tt(Start, "『", LEFTWHITECORNERBRACKET);
	tt(Start, "』", RIGHTWHITECORNERBRACKET);
	tt(Start, "＜", FULLWIDTHLESSTHAN);
	tt(Start, "＞", FULLWIDTHGREATERTHAN);
	tt(Start, "&", AMPERSAND);
	tt(Start, "*", ASTERISK);
	tt(Start, "@", AT);
	tt(Start, "`", BACKTICK);
	tt(Start, "^", CARET);
	tt(Start, ":", COLON);
	tt(Start, ",", COMMA);
	tt(Start, "$", DOLLAR);
	tt(Start, ".", DOT);
	tt(Start, "=", EQUALS);
	tt(Start, "!", EXCLAMATION);
	tt(Start, "-", HYPHEN);
	tt(Start, "%", PERCENT);
	tt(Start, "|", PIPE);
	tt(Start, "+", PLUS);
	tt(Start, "#", POUND);
	tt(Start, "?", QUERY);
	tt(Start, "\"", QUOTE);
	tt(Start, "/", SLASH);
	tt(Start, ";", SEMI);
	tt(Start, "~", TILDE);
	tt(Start, "_", UNDERSCORE);
	tt(Start, "\\", BACKSLASH);
	const Num = tr(Start, DIGIT, NUM, { [numeric]: true });
	tr(Num, DIGIT, Num);
	const Word = tr(Start, ASCII_LETTER, WORD, { [ascii]: true });
	tr(Word, ASCII_LETTER, Word);
	const UWord = tr(Start, LETTER, UWORD, { [alpha]: true });
	tr(UWord, ASCII_LETTER);
	tr(UWord, LETTER, UWord);
	const Ws = tr(Start, SPACE, WS, { [whitespace]: true });
	tt(Start, NL, NL$1, { [whitespace]: true });
	tt(Ws, NL);
	tr(Ws, SPACE, Ws);
	const Emoji = tr(Start, EMOJI, EMOJI$1, { [emoji]: true });
	tr(Emoji, EMOJI, Emoji);
	tt(Emoji, EMOJI_VARIATION, Emoji);
	const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
	tr(EmojiJoiner, EMOJI, Emoji);
	const wordjr = [[ASCII_LETTER, Word]];
	const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
	for (let i = 0; i < tlds.length; i++) fastts(Start, tlds[i], TLD, WORD, wordjr);
	for (let i = 0; i < utlds.length; i++) fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
	addToGroups(TLD, {
		tld: true,
		ascii: true
	}, groups);
	addToGroups(UTLD, {
		utld: true,
		alpha: true
	}, groups);
	fastts(Start, "file", SCHEME, WORD, wordjr);
	fastts(Start, "mailto", SCHEME, WORD, wordjr);
	fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
	fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
	fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
	fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
	addToGroups(SCHEME, {
		scheme: true,
		ascii: true
	}, groups);
	addToGroups(SLASH_SCHEME, {
		slashscheme: true,
		ascii: true
	}, groups);
	customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
	for (let i = 0; i < customSchemes.length; i++) {
		const sch = customSchemes[i][0];
		const optionalSlashSlash = customSchemes[i][1];
		const flags = optionalSlashSlash ? { [scheme]: true } : { [slashscheme]: true };
		if (sch.indexOf("-") >= 0) flags[domain] = true;
else if (!ASCII_LETTER.test(sch)) flags[numeric] = true;
else if (DIGIT.test(sch)) flags[asciinumeric] = true;
else flags[ascii] = true;
		ts(Start, sch, sch, flags);
	}
	ts(Start, "localhost", LOCALHOST, { ascii: true });
	Start.jd = new State(SYM);
	return {
		start: Start,
		tokens: assign({ groups }, tk)
	};
}
/**
Given a string, returns an array of TOKEN instances representing the
composition of that string.

@method run
@param {State<string>} start scanner starting state
@param {string} str input string to scan
@return {Token[]} list of tokens, each with a type and value
*/
function run$1(start, str) {
	const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
	const charCount = iterable.length;
	const tokens = [];
	let cursor = 0;
	let charCursor = 0;
	while (charCursor < charCount) {
		let state = start;
		let nextState = null;
		let tokenLength = 0;
		let latestAccepting = null;
		let sinceAccepts = -1;
		let charsSinceAccepts = -1;
		while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
			state = nextState;
			if (state.accepts()) {
				sinceAccepts = 0;
				charsSinceAccepts = 0;
				latestAccepting = state;
			} else if (sinceAccepts >= 0) {
				sinceAccepts += iterable[charCursor].length;
				charsSinceAccepts++;
			}
			tokenLength += iterable[charCursor].length;
			cursor += iterable[charCursor].length;
			charCursor++;
		}
		cursor -= sinceAccepts;
		charCursor -= charsSinceAccepts;
		tokenLength -= sinceAccepts;
		tokens.push({
			t: latestAccepting.t,
			v: str.slice(cursor - tokenLength, cursor),
			s: cursor - tokenLength,
			e: cursor
		});
	}
	return tokens;
}
/**
* Convert a String to an Array of characters, taking into account that some
* characters like emojis take up two string indexes.
*
* Adapted from core-js (MIT license)
* https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
*
* @function stringToArray
* @param {string} str
* @returns {string[]}
*/
function stringToArray(str) {
	const result = [];
	const len = str.length;
	let index = 0;
	while (index < len) {
		let first = str.charCodeAt(index);
		let second;
		let char = first < 55296 || first > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
		result.push(char);
		index += char.length;
	}
	return result;
}
/**
* Fast version of ts function for when transition defaults are well known
* @param {State<string>} state
* @param {string} input
* @param {string} t
* @param {string} defaultt
* @param {[RegExp, State<string>][]} jr
* @returns {State<string>}
*/
function fastts(state, input, t, defaultt, jr) {
	let next;
	const len = input.length;
	for (let i = 0; i < len - 1; i++) {
		const char = input[i];
		if (state.j[char]) next = state.j[char];
else {
			next = new State(defaultt);
			next.jr = jr.slice();
			state.j[char] = next;
		}
		state = next;
	}
	next = new State(t);
	next.jr = jr.slice();
	state.j[input[len - 1]] = next;
	return next;
}
/**
* Converts a string of Top-Level Domain names encoded in update-tlds.js back
* into a list of strings.
* @param {str} encoded encoded TLDs string
* @returns {str[]} original TLDs list
*/
function decodeTlds(encoded) {
	const words = [];
	const stack = [];
	let i = 0;
	let digits = "0123456789";
	while (i < encoded.length) {
		let popDigitCount = 0;
		while (digits.indexOf(encoded[i + popDigitCount]) >= 0) popDigitCount++;
		if (popDigitCount > 0) {
			words.push(stack.join(""));
			for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) stack.pop();
			i += popDigitCount;
		} else {
			stack.push(encoded[i]);
			i++;
		}
	}
	return words;
}
/**
* An object where each key is a valid DOM Event Name such as `click` or `focus`
* and each value is an event handler function.
*
* https://developer.mozilla.org/en-US/docs/Web/API/Element#events
* @typedef {?{ [event: string]: Function }} EventListeners
*/
/**
* All formatted properties required to render a link, including `tagName`,
* `attributes`, `content` and `eventListeners`.
* @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,
* eventListeners: EventListeners }} IntermediateRepresentation
*/
/**
* Specify either an object described by the template type `O` or a function.
*
* The function takes a string value (usually the link's href attribute), the
* link type (`'url'`, `'hashtag`', etc.) and an internal token representation
* of the link. It should return an object of the template type `O`
* @template O
* @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj
*/
/**
* Specify either a function described by template type `F` or an object.
*
* Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each
* value should be a function with template type `F` that is called when the
* corresponding link type is encountered.
* @template F
* @typedef {F | { [type: string]: F}} OptFn
*/
/**
* Specify either a value with template type `V`, a function that returns `V` or
* an object where each value resolves to `V`.
*
* The function takes a string value (usually the link's href attribute), the
* link type (`'url'`, `'hashtag`', etc.) and an internal token representation
* of the link. It should return an object of the template type `V`
*
* For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).
* Each value should either have type `V` or a function that returns V. This
* function similarly takes a string value and a token.
*
* Example valid types for `Opt<string>`:
*
* ```js
* 'hello'
* (value, type, token) => 'world'
* { url: 'hello', email: (value, token) => 'world'}
* ```
* @template V
* @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt
*/
/**
* See available options: https://linkify.js.org/docs/options.html
* @typedef {{
* 	defaultProtocol?: string,
*  events?: OptObj<EventListeners>,
* 	format?: Opt<string>,
* 	formatHref?: Opt<string>,
* 	nl2br?: boolean,
* 	tagName?: Opt<any>,
* 	target?: Opt<string>,
* 	rel?: Opt<string>,
* 	validate?: Opt<boolean>,
* 	truncate?: Opt<number>,
* 	className?: Opt<string>,
* 	attributes?: OptObj<({ [attr: string]: any })>,
*  ignoreTags?: string[],
* 	render?: OptFn<((ir: IntermediateRepresentation) => any)>
* }} Opts
*/
/**
* @type Required<Opts>
*/
const defaults = {
	defaultProtocol: "http",
	events: null,
	format: noop,
	formatHref: noop,
	nl2br: false,
	tagName: "a",
	target: null,
	rel: null,
	validate: true,
	truncate: Infinity,
	className: null,
	attributes: null,
	ignoreTags: [],
	render: null
};
/**
* Utility class for linkify interfaces to apply specified
* {@link Opts formatting and rendering options}.
*
* @param {Opts | Options} [opts] Option value overrides.
* @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For
*   internal use) default render function that determines how to generate an
*   HTML element based on a link token's derived tagName, attributes and HTML.
*   Similar to render option
*/
function Options(opts, defaultRender$1) {
	if (defaultRender$1 === void 0) defaultRender$1 = null;
	let o = assign({}, defaults);
	if (opts) o = assign(o, opts instanceof Options ? opts.o : opts);
	const ignoredTags = o.ignoreTags;
	const uppercaseIgnoredTags = [];
	for (let i = 0; i < ignoredTags.length; i++) uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
	/** @protected */
	this.o = o;
	if (defaultRender$1) this.defaultRender = defaultRender$1;
	this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
	o: defaults,
	ignoreTags: [],
	defaultRender(ir) {
		return ir;
	},
	check(token) {
		return this.get("validate", token.toString(), token);
	},
	get(key, operator, token) {
		const isCallable = operator != null;
		let option = this.o[key];
		if (!option) return option;
		if (typeof option === "object") {
			option = token.t in option ? option[token.t] : defaults[key];
			if (typeof option === "function" && isCallable) option = option(operator, token);
		} else if (typeof option === "function" && isCallable) option = option(operator, token.t, token);
		return option;
	},
	getObj(key, operator, token) {
		let obj = this.o[key];
		if (typeof obj === "function" && operator != null) obj = obj(operator, token.t, token);
		return obj;
	},
	render(token) {
		const ir = token.render(this);
		const renderFn = this.get("render", null, token) || this.defaultRender;
		return renderFn(ir, token.t, token);
	}
};
function noop(val) {
	return val;
}
/******************************************************************************
Multi-Tokens
Tokens composed of arrays of TextTokens
******************************************************************************/
/**
* @param {string} value
* @param {Token[]} tokens
*/
function MultiToken(value, tokens) {
	this.t = "token";
	this.v = value;
	this.tk = tokens;
}
/**
* Abstract class used for manufacturing tokens of text tokens. That is rather
* than the value for a token being a small string of text, it's value an array
* of text tokens.
*
* Used for grouping together URLs, emails, hashtags, and other potential
* creations.
* @class MultiToken
* @property {string} t
* @property {string} v
* @property {Token[]} tk
* @abstract
*/
MultiToken.prototype = {
	isLink: false,
	toString() {
		return this.v;
	},
	toHref(scheme$1) {
		return this.toString();
	},
	toFormattedString(options) {
		const val = this.toString();
		const truncate = options.get("truncate", val, this);
		const formatted = options.get("format", val, this);
		return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
	},
	toFormattedHref(options) {
		return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
	},
	startIndex() {
		return this.tk[0].s;
	},
	endIndex() {
		return this.tk[this.tk.length - 1].e;
	},
	toObject(protocol) {
		if (protocol === void 0) protocol = defaults.defaultProtocol;
		return {
			type: this.t,
			value: this.toString(),
			isLink: this.isLink,
			href: this.toHref(protocol),
			start: this.startIndex(),
			end: this.endIndex()
		};
	},
	toFormattedObject(options) {
		return {
			type: this.t,
			value: this.toFormattedString(options),
			isLink: this.isLink,
			href: this.toFormattedHref(options),
			start: this.startIndex(),
			end: this.endIndex()
		};
	},
	validate(options) {
		return options.get("validate", this.toString(), this);
	},
	render(options) {
		const token = this;
		const href = this.toHref(options.get("defaultProtocol"));
		const formattedHref = options.get("formatHref", href, this);
		const tagName = options.get("tagName", href, token);
		const content = this.toFormattedString(options);
		const attributes = {};
		const className = options.get("className", href, token);
		const target = options.get("target", href, token);
		const rel = options.get("rel", href, token);
		const attrs = options.getObj("attributes", href, token);
		const eventListeners = options.getObj("events", href, token);
		attributes.href = formattedHref;
		if (className) attributes.class = className;
		if (target) attributes.target = target;
		if (rel) attributes.rel = rel;
		if (attrs) assign(attributes, attrs);
		return {
			tagName,
			attributes,
			content,
			eventListeners
		};
	}
};
/**
* Create a new token that can be emitted by the parser state machine
* @param {string} type readable type of the token
* @param {object} props properties to assign or override, including isLink = true or false
* @returns {new (value: string, tokens: Token[]) => MultiToken} new token class
*/
function createTokenClass(type, props) {
	class Token extends MultiToken {
		constructor(value, tokens) {
			super(value, tokens);
			this.t = type;
		}
	}
	for (const p in props) Token.prototype[p] = props[p];
	Token.t = type;
	return Token;
}
/**
Represents a list of tokens making up a valid email address
*/
const Email = createTokenClass("email", {
	isLink: true,
	toHref() {
		return "mailto:" + this.toString();
	}
});
/**
Represents some plain text
*/
const Text = createTokenClass("text");
/**
Multi-linebreak token - represents a line break
@class Nl
*/
const Nl = createTokenClass("nl");
/**
Represents a list of text tokens making up a valid URL
@class Url
*/
const Url = createTokenClass("url", {
	isLink: true,
	toHref(scheme$1) {
		if (scheme$1 === void 0) scheme$1 = defaults.defaultProtocol;
		return this.hasProtocol() ? this.v : `${scheme$1}://${this.v}`;
	},
	hasProtocol() {
		const tokens = this.tk;
		return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
	}
});
/**
Not exactly parser, more like the second-stage scanner (although we can
theoretically hotswap the code here with a real parser in the future... but
for a little URL-finding utility abstract syntax trees may be a little
overkill).

URL format: http://en.wikipedia.org/wiki/URI_scheme
Email format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in
reference)

@module linkify
@submodule parser
@main run
*/
const makeState = (arg) => new State(arg);
/**
* Generate the parser multi token-based state machine
* @param {{ groups: Collections<string> }} tokens
*/
function init$1(_ref) {
	let { groups } = _ref;
	const qsAccepting = groups.domain.concat([
		AMPERSAND,
		ASTERISK,
		AT,
		BACKSLASH,
		BACKTICK,
		CARET,
		DOLLAR,
		EQUALS,
		HYPHEN,
		NUM,
		PERCENT,
		PIPE,
		PLUS,
		POUND,
		SLASH,
		SYM,
		TILDE,
		UNDERSCORE
	]);
	const qsNonAccepting = [
		APOSTROPHE,
		COLON,
		COMMA,
		DOT,
		EXCLAMATION,
		QUERY,
		QUOTE,
		SEMI,
		OPENANGLEBRACKET,
		CLOSEANGLEBRACKET,
		OPENBRACE,
		CLOSEBRACE,
		CLOSEBRACKET,
		OPENBRACKET,
		OPENPAREN,
		CLOSEPAREN,
		FULLWIDTHLEFTPAREN,
		FULLWIDTHRIGHTPAREN,
		LEFTCORNERBRACKET,
		RIGHTCORNERBRACKET,
		LEFTWHITECORNERBRACKET,
		RIGHTWHITECORNERBRACKET,
		FULLWIDTHLESSTHAN,
		FULLWIDTHGREATERTHAN
	];
	const localpartAccepting = [
		AMPERSAND,
		APOSTROPHE,
		ASTERISK,
		BACKSLASH,
		BACKTICK,
		CARET,
		DOLLAR,
		EQUALS,
		HYPHEN,
		OPENBRACE,
		CLOSEBRACE,
		PERCENT,
		PIPE,
		PLUS,
		POUND,
		QUERY,
		SLASH,
		SYM,
		TILDE,
		UNDERSCORE
	];
	/**
	* @type State<Token>
	*/
	const Start = makeState();
	const Localpart = tt(Start, TILDE);
	ta(Localpart, localpartAccepting, Localpart);
	ta(Localpart, groups.domain, Localpart);
	const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
	ta(Start, groups.domain, Domain);
	ta(Start, groups.scheme, Scheme);
	ta(Start, groups.slashscheme, SlashScheme);
	ta(Domain, localpartAccepting, Localpart);
	ta(Domain, groups.domain, Domain);
	const LocalpartAt = tt(Domain, AT);
	tt(Localpart, AT, LocalpartAt);
	tt(Scheme, AT, LocalpartAt);
	tt(SlashScheme, AT, LocalpartAt);
	const LocalpartDot = tt(Localpart, DOT);
	ta(LocalpartDot, localpartAccepting, Localpart);
	ta(LocalpartDot, groups.domain, Localpart);
	const EmailDomain = makeState();
	ta(LocalpartAt, groups.domain, EmailDomain);
	ta(EmailDomain, groups.domain, EmailDomain);
	const EmailDomainDot = tt(EmailDomain, DOT);
	ta(EmailDomainDot, groups.domain, EmailDomain);
	const Email$1 = makeState(Email);
	ta(EmailDomainDot, groups.tld, Email$1);
	ta(EmailDomainDot, groups.utld, Email$1);
	tt(LocalpartAt, LOCALHOST, Email$1);
	const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
	ta(EmailDomainHyphen, groups.domain, EmailDomain);
	ta(Email$1, groups.domain, EmailDomain);
	tt(Email$1, DOT, EmailDomainDot);
	tt(Email$1, HYPHEN, EmailDomainHyphen);
	const EmailColon = tt(Email$1, COLON);
	ta(EmailColon, groups.numeric, Email);
	const DomainHyphen = tt(Domain, HYPHEN);
	const DomainDot = tt(Domain, DOT);
	ta(DomainHyphen, groups.domain, Domain);
	ta(DomainDot, localpartAccepting, Localpart);
	ta(DomainDot, groups.domain, Domain);
	const DomainDotTld = makeState(Url);
	ta(DomainDot, groups.tld, DomainDotTld);
	ta(DomainDot, groups.utld, DomainDotTld);
	ta(DomainDotTld, groups.domain, Domain);
	ta(DomainDotTld, localpartAccepting, Localpart);
	tt(DomainDotTld, DOT, DomainDot);
	tt(DomainDotTld, HYPHEN, DomainHyphen);
	tt(DomainDotTld, AT, LocalpartAt);
	const DomainDotTldColon = tt(DomainDotTld, COLON);
	const DomainDotTldColonPort = makeState(Url);
	ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
	const Url$1 = makeState(Url);
	const UrlNonaccept = makeState();
	ta(Url$1, qsAccepting, Url$1);
	ta(Url$1, qsNonAccepting, UrlNonaccept);
	ta(UrlNonaccept, qsAccepting, Url$1);
	ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
	tt(DomainDotTld, SLASH, Url$1);
	tt(DomainDotTldColonPort, SLASH, Url$1);
	const SchemeColon = tt(Scheme, COLON);
	const SlashSchemeColon = tt(SlashScheme, COLON);
	const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
	const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
	ta(Scheme, groups.domain, Domain);
	tt(Scheme, DOT, DomainDot);
	tt(Scheme, HYPHEN, DomainHyphen);
	ta(SlashScheme, groups.domain, Domain);
	tt(SlashScheme, DOT, DomainDot);
	tt(SlashScheme, HYPHEN, DomainHyphen);
	ta(SchemeColon, groups.domain, Url$1);
	tt(SchemeColon, SLASH, Url$1);
	ta(UriPrefix, groups.domain, Url$1);
	ta(UriPrefix, qsAccepting, Url$1);
	tt(UriPrefix, SLASH, Url$1);
	const bracketPairs = [
		[OPENBRACE, CLOSEBRACE],
		[OPENBRACKET, CLOSEBRACKET],
		[OPENPAREN, CLOSEPAREN],
		[OPENANGLEBRACKET, CLOSEANGLEBRACKET],
		[FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
		[LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
		[LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
		[FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
	];
	for (let i = 0; i < bracketPairs.length; i++) {
		const [OPEN, CLOSE] = bracketPairs[i];
		const UrlOpen = tt(Url$1, OPEN);
		tt(UrlNonaccept, OPEN, UrlOpen);
		tt(UrlOpen, CLOSE, Url$1);
		const UrlOpenQ = makeState(Url);
		ta(UrlOpen, qsAccepting, UrlOpenQ);
		const UrlOpenSyms = makeState();
		ta(UrlOpen, qsNonAccepting);
		ta(UrlOpenQ, qsAccepting, UrlOpenQ);
		ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
		ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
		ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
		tt(UrlOpenQ, CLOSE, Url$1);
		tt(UrlOpenSyms, CLOSE, Url$1);
	}
	tt(Start, LOCALHOST, DomainDotTld);
	tt(Start, NL$1, Nl);
	return {
		start: Start,
		tokens: tk
	};
}
/**
* Run the parser state machine on a list of scanned string-based tokens to
* create a list of multi tokens, each of which represents a URL, email address,
* plain text, etc.
*
* @param {State<MultiToken>} start parser start state
* @param {string} input the original input used to generate the given tokens
* @param {Token[]} tokens list of scanned tokens
* @returns {MultiToken[]}
*/
function run(start, input, tokens) {
	let len = tokens.length;
	let cursor = 0;
	let multis = [];
	let textTokens = [];
	while (cursor < len) {
		let state = start;
		let secondState = null;
		let nextState = null;
		let multiLength = 0;
		let latestAccepting = null;
		let sinceAccepts = -1;
		while (cursor < len && !(secondState = state.go(tokens[cursor].t))) textTokens.push(tokens[cursor++]);
		while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
			secondState = null;
			state = nextState;
			if (state.accepts()) {
				sinceAccepts = 0;
				latestAccepting = state;
			} else if (sinceAccepts >= 0) sinceAccepts++;
			cursor++;
			multiLength++;
		}
		if (sinceAccepts < 0) {
			cursor -= multiLength;
			if (cursor < len) {
				textTokens.push(tokens[cursor]);
				cursor++;
			}
		} else {
			if (textTokens.length > 0) {
				multis.push(initMultiToken(Text, input, textTokens));
				textTokens = [];
			}
			cursor -= sinceAccepts;
			multiLength -= sinceAccepts;
			const Multi = latestAccepting.t;
			const subtokens = tokens.slice(cursor - multiLength, cursor);
			multis.push(initMultiToken(Multi, input, subtokens));
		}
	}
	if (textTokens.length > 0) multis.push(initMultiToken(Text, input, textTokens));
	return multis;
}
/**
* Utility function for instantiating a new multitoken with all the relevant
* fields during parsing.
* @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate
* @param {string} input original input string
* @param {Token[]} tokens consecutive tokens scanned from input string
* @returns {MultiToken}
*/
function initMultiToken(Multi, input, tokens) {
	const startIdx = tokens[0].s;
	const endIdx = tokens[tokens.length - 1].e;
	const value = input.slice(startIdx, endIdx);
	return new Multi(value, tokens);
}
const INIT = {
	scanner: null,
	parser: null,
	tokenQueue: [],
	pluginQueue: [],
	customSchemes: [],
	initialized: false
};
/**
* Initialize the linkify state machine. Called automatically the first time
* linkify is called on a string, but may be called manually as well.
*/
function init() {
	INIT.scanner = init$2(INIT.customSchemes);
	for (let i = 0; i < INIT.tokenQueue.length; i++) INIT.tokenQueue[i][1]({ scanner: INIT.scanner });
	INIT.parser = init$1(INIT.scanner.tokens);
	for (let i = 0; i < INIT.pluginQueue.length; i++) INIT.pluginQueue[i][1]({
		scanner: INIT.scanner,
		parser: INIT.parser
	});
	INIT.initialized = true;
}
/**
* Parse a string into tokens that represent linkable and non-linkable sub-components
* @param {string} str
* @return {MultiToken[]} tokens
*/
function tokenize$1(str) {
	if (!INIT.initialized) init();
	return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}

//#endregion
//#region ../libs/linkify-html.js
/**
* generated from https://raw.githubusercontent.com/w3c/html/26b5126f96f736f796b9e29718138919dd513744/entities.json
* do not edit
*/
var HTML5NamedCharRefs = {
	amp: "&",
	gt: ">",
	lt: "<",
	nbsp: "\xA0",
	quot: "\""
};
var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
var CHARCODE = /^#([0-9]+)$/;
var NAMED = /^([A-Za-z0-9]+)$/;
var EntityParser = function() {
	function EntityParser$1(named) {
		this.named = named;
	}
	EntityParser$1.prototype.parse = function(entity) {
		if (!entity) return;
		var matches = entity.match(HEXCHARCODE);
		if (matches) return String.fromCharCode(parseInt(matches[1], 16));
		matches = entity.match(CHARCODE);
		if (matches) return String.fromCharCode(parseInt(matches[1], 10));
		matches = entity.match(NAMED);
		if (matches) return this.named[matches[1]] || "&" + matches[1] + ";";
	};
	return EntityParser$1;
}();
var WSP = /[\t\n\f ]/;
var ALPHA = /[A-Za-z]/;
var CRLF = /\r\n?/g;
function isSpace(char) {
	return WSP.test(char);
}
function isAlpha(char) {
	return ALPHA.test(char);
}
function preprocessInput(input) {
	return input.replace(CRLF, "\n");
}
var EventedTokenizer = function() {
	function EventedTokenizer$1(delegate, entityParser, mode) {
		if (mode === void 0) mode = "precompile";
		this.delegate = delegate;
		this.entityParser = entityParser;
		this.mode = mode;
		this.state = "beforeData";
		this.line = -1;
		this.column = -1;
		this.input = "";
		this.index = -1;
		this.tagNameBuffer = "";
		this.states = {
			beforeData: function() {
				var char = this.peek();
				if (char === "<" && !this.isIgnoredEndTag()) {
					this.transitionTo(
						"tagOpen"
						/* tagOpen */
);
					this.markTagStart();
					this.consume();
				} else {
					if (this.mode === "precompile" && char === "\n") {
						var tag = this.tagNameBuffer.toLowerCase();
						if (tag === "pre" || tag === "textarea") this.consume();
					}
					this.transitionTo(
						"data"
						/* data */
);
					this.delegate.beginData();
				}
			},
			data: function() {
				var char = this.peek();
				var tag = this.tagNameBuffer;
				if (char === "<" && !this.isIgnoredEndTag()) {
					this.delegate.finishData();
					this.transitionTo(
						"tagOpen"
						/* tagOpen */
);
					this.markTagStart();
					this.consume();
				} else if (char === "&" && tag !== "script" && tag !== "style") {
					this.consume();
					this.delegate.appendToData(this.consumeCharRef() || "&");
				} else {
					this.consume();
					this.delegate.appendToData(char);
				}
			},
			tagOpen: function() {
				var char = this.consume();
				if (char === "!") this.transitionTo(
					"markupDeclarationOpen"
					/* markupDeclarationOpen */
);
else if (char === "/") this.transitionTo(
					"endTagOpen"
					/* endTagOpen */
);
else if (char === "@" || char === ":" || isAlpha(char)) {
					this.transitionTo(
						"tagName"
						/* tagName */
);
					this.tagNameBuffer = "";
					this.delegate.beginStartTag();
					this.appendToTagName(char);
				}
			},
			markupDeclarationOpen: function() {
				var char = this.consume();
				if (char === "-" && this.peek() === "-") {
					this.consume();
					this.transitionTo(
						"commentStart"
						/* commentStart */
);
					this.delegate.beginComment();
				} else {
					var maybeDoctype = char.toUpperCase() + this.input.substring(this.index, this.index + 6).toUpperCase();
					if (maybeDoctype === "DOCTYPE") {
						this.consume();
						this.consume();
						this.consume();
						this.consume();
						this.consume();
						this.consume();
						this.transitionTo(
							"doctype"
							/* doctype */
);
						if (this.delegate.beginDoctype) this.delegate.beginDoctype();
					}
				}
			},
			doctype: function() {
				var char = this.consume();
				if (isSpace(char)) this.transitionTo(
					"beforeDoctypeName"
					/* beforeDoctypeName */
);
			},
			beforeDoctypeName: function() {
				var char = this.consume();
				if (isSpace(char)) return;
else {
					this.transitionTo(
						"doctypeName"
						/* doctypeName */
);
					if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());
				}
			},
			doctypeName: function() {
				var char = this.consume();
				if (isSpace(char)) this.transitionTo(
					"afterDoctypeName"
					/* afterDoctypeName */
);
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());
			},
			afterDoctypeName: function() {
				var char = this.consume();
				if (isSpace(char)) return;
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else {
					var nextSixChars = char.toUpperCase() + this.input.substring(this.index, this.index + 5).toUpperCase();
					var isPublic = nextSixChars.toUpperCase() === "PUBLIC";
					var isSystem = nextSixChars.toUpperCase() === "SYSTEM";
					if (isPublic || isSystem) {
						this.consume();
						this.consume();
						this.consume();
						this.consume();
						this.consume();
						this.consume();
					}
					if (isPublic) this.transitionTo(
						"afterDoctypePublicKeyword"
						/* afterDoctypePublicKeyword */
);
else if (isSystem) this.transitionTo(
						"afterDoctypeSystemKeyword"
						/* afterDoctypeSystemKeyword */
);
				}
			},
			afterDoctypePublicKeyword: function() {
				var char = this.peek();
				if (isSpace(char)) {
					this.transitionTo(
						"beforeDoctypePublicIdentifier"
						/* beforeDoctypePublicIdentifier */
);
					this.consume();
				} else if (char === "\"") {
					this.transitionTo(
						"doctypePublicIdentifierDoubleQuoted"
						/* doctypePublicIdentifierDoubleQuoted */
);
					this.consume();
				} else if (char === "'") {
					this.transitionTo(
						"doctypePublicIdentifierSingleQuoted"
						/* doctypePublicIdentifierSingleQuoted */
);
					this.consume();
				} else if (char === ">") {
					this.consume();
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				}
			},
			doctypePublicIdentifierDoubleQuoted: function() {
				var char = this.consume();
				if (char === "\"") this.transitionTo(
					"afterDoctypePublicIdentifier"
					/* afterDoctypePublicIdentifier */
);
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);
			},
			doctypePublicIdentifierSingleQuoted: function() {
				var char = this.consume();
				if (char === "'") this.transitionTo(
					"afterDoctypePublicIdentifier"
					/* afterDoctypePublicIdentifier */
);
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);
			},
			afterDoctypePublicIdentifier: function() {
				var char = this.consume();
				if (isSpace(char)) this.transitionTo(
					"betweenDoctypePublicAndSystemIdentifiers"
					/* betweenDoctypePublicAndSystemIdentifiers */
);
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (char === "\"") this.transitionTo(
					"doctypeSystemIdentifierDoubleQuoted"
					/* doctypeSystemIdentifierDoubleQuoted */
);
else if (char === "'") this.transitionTo(
					"doctypeSystemIdentifierSingleQuoted"
					/* doctypeSystemIdentifierSingleQuoted */
);
			},
			betweenDoctypePublicAndSystemIdentifiers: function() {
				var char = this.consume();
				if (isSpace(char)) return;
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (char === "\"") this.transitionTo(
					"doctypeSystemIdentifierDoubleQuoted"
					/* doctypeSystemIdentifierDoubleQuoted */
);
else if (char === "'") this.transitionTo(
					"doctypeSystemIdentifierSingleQuoted"
					/* doctypeSystemIdentifierSingleQuoted */
);
			},
			doctypeSystemIdentifierDoubleQuoted: function() {
				var char = this.consume();
				if (char === "\"") this.transitionTo(
					"afterDoctypeSystemIdentifier"
					/* afterDoctypeSystemIdentifier */
);
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);
			},
			doctypeSystemIdentifierSingleQuoted: function() {
				var char = this.consume();
				if (char === "'") this.transitionTo(
					"afterDoctypeSystemIdentifier"
					/* afterDoctypeSystemIdentifier */
);
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);
			},
			afterDoctypeSystemIdentifier: function() {
				var char = this.consume();
				if (isSpace(char)) return;
else if (char === ">") {
					if (this.delegate.endDoctype) this.delegate.endDoctype();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				}
			},
			commentStart: function() {
				var char = this.consume();
				if (char === "-") this.transitionTo(
					"commentStartDash"
					/* commentStartDash */
);
else if (char === ">") {
					this.delegate.finishComment();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else {
					this.delegate.appendToCommentData(char);
					this.transitionTo(
						"comment"
						/* comment */
);
				}
			},
			commentStartDash: function() {
				var char = this.consume();
				if (char === "-") this.transitionTo(
					"commentEnd"
					/* commentEnd */
);
else if (char === ">") {
					this.delegate.finishComment();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else {
					this.delegate.appendToCommentData("-");
					this.transitionTo(
						"comment"
						/* comment */
);
				}
			},
			comment: function() {
				var char = this.consume();
				if (char === "-") this.transitionTo(
					"commentEndDash"
					/* commentEndDash */
);
else this.delegate.appendToCommentData(char);
			},
			commentEndDash: function() {
				var char = this.consume();
				if (char === "-") this.transitionTo(
					"commentEnd"
					/* commentEnd */
);
else {
					this.delegate.appendToCommentData("-" + char);
					this.transitionTo(
						"comment"
						/* comment */
);
				}
			},
			commentEnd: function() {
				var char = this.consume();
				if (char === ">") {
					this.delegate.finishComment();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else {
					this.delegate.appendToCommentData("--" + char);
					this.transitionTo(
						"comment"
						/* comment */
);
				}
			},
			tagName: function() {
				var char = this.consume();
				if (isSpace(char)) this.transitionTo(
					"beforeAttributeName"
					/* beforeAttributeName */
);
else if (char === "/") this.transitionTo(
					"selfClosingStartTag"
					/* selfClosingStartTag */
);
else if (char === ">") {
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else this.appendToTagName(char);
			},
			endTagName: function() {
				var char = this.consume();
				if (isSpace(char)) {
					this.transitionTo(
						"beforeAttributeName"
						/* beforeAttributeName */
);
					this.tagNameBuffer = "";
				} else if (char === "/") {
					this.transitionTo(
						"selfClosingStartTag"
						/* selfClosingStartTag */
);
					this.tagNameBuffer = "";
				} else if (char === ">") {
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
					this.tagNameBuffer = "";
				} else this.appendToTagName(char);
			},
			beforeAttributeName: function() {
				var char = this.peek();
				if (isSpace(char)) {
					this.consume();
					return;
				} else if (char === "/") {
					this.transitionTo(
						"selfClosingStartTag"
						/* selfClosingStartTag */
);
					this.consume();
				} else if (char === ">") {
					this.consume();
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (char === "=") {
					this.delegate.reportSyntaxError("attribute name cannot start with equals sign");
					this.transitionTo(
						"attributeName"
						/* attributeName */
);
					this.delegate.beginAttribute();
					this.consume();
					this.delegate.appendToAttributeName(char);
				} else {
					this.transitionTo(
						"attributeName"
						/* attributeName */
);
					this.delegate.beginAttribute();
				}
			},
			attributeName: function() {
				var char = this.peek();
				if (isSpace(char)) {
					this.transitionTo(
						"afterAttributeName"
						/* afterAttributeName */
);
					this.consume();
				} else if (char === "/") {
					this.delegate.beginAttributeValue(false);
					this.delegate.finishAttributeValue();
					this.consume();
					this.transitionTo(
						"selfClosingStartTag"
						/* selfClosingStartTag */
);
				} else if (char === "=") {
					this.transitionTo(
						"beforeAttributeValue"
						/* beforeAttributeValue */
);
					this.consume();
				} else if (char === ">") {
					this.delegate.beginAttributeValue(false);
					this.delegate.finishAttributeValue();
					this.consume();
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else if (char === "\"" || char === "'" || char === "<") {
					this.delegate.reportSyntaxError(char + " is not a valid character within attribute names");
					this.consume();
					this.delegate.appendToAttributeName(char);
				} else {
					this.consume();
					this.delegate.appendToAttributeName(char);
				}
			},
			afterAttributeName: function() {
				var char = this.peek();
				if (isSpace(char)) {
					this.consume();
					return;
				} else if (char === "/") {
					this.delegate.beginAttributeValue(false);
					this.delegate.finishAttributeValue();
					this.consume();
					this.transitionTo(
						"selfClosingStartTag"
						/* selfClosingStartTag */
);
				} else if (char === "=") {
					this.consume();
					this.transitionTo(
						"beforeAttributeValue"
						/* beforeAttributeValue */
);
				} else if (char === ">") {
					this.delegate.beginAttributeValue(false);
					this.delegate.finishAttributeValue();
					this.consume();
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else {
					this.delegate.beginAttributeValue(false);
					this.delegate.finishAttributeValue();
					this.transitionTo(
						"attributeName"
						/* attributeName */
);
					this.delegate.beginAttribute();
					this.consume();
					this.delegate.appendToAttributeName(char);
				}
			},
			beforeAttributeValue: function() {
				var char = this.peek();
				if (isSpace(char)) this.consume();
else if (char === "\"") {
					this.transitionTo(
						"attributeValueDoubleQuoted"
						/* attributeValueDoubleQuoted */
);
					this.delegate.beginAttributeValue(true);
					this.consume();
				} else if (char === "'") {
					this.transitionTo(
						"attributeValueSingleQuoted"
						/* attributeValueSingleQuoted */
);
					this.delegate.beginAttributeValue(true);
					this.consume();
				} else if (char === ">") {
					this.delegate.beginAttributeValue(false);
					this.delegate.finishAttributeValue();
					this.consume();
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else {
					this.transitionTo(
						"attributeValueUnquoted"
						/* attributeValueUnquoted */
);
					this.delegate.beginAttributeValue(false);
					this.consume();
					this.delegate.appendToAttributeValue(char);
				}
			},
			attributeValueDoubleQuoted: function() {
				var char = this.consume();
				if (char === "\"") {
					this.delegate.finishAttributeValue();
					this.transitionTo(
						"afterAttributeValueQuoted"
						/* afterAttributeValueQuoted */
);
				} else if (char === "&") this.delegate.appendToAttributeValue(this.consumeCharRef() || "&");
else this.delegate.appendToAttributeValue(char);
			},
			attributeValueSingleQuoted: function() {
				var char = this.consume();
				if (char === "'") {
					this.delegate.finishAttributeValue();
					this.transitionTo(
						"afterAttributeValueQuoted"
						/* afterAttributeValueQuoted */
);
				} else if (char === "&") this.delegate.appendToAttributeValue(this.consumeCharRef() || "&");
else this.delegate.appendToAttributeValue(char);
			},
			attributeValueUnquoted: function() {
				var char = this.peek();
				if (isSpace(char)) {
					this.delegate.finishAttributeValue();
					this.consume();
					this.transitionTo(
						"beforeAttributeName"
						/* beforeAttributeName */
);
				} else if (char === "/") {
					this.delegate.finishAttributeValue();
					this.consume();
					this.transitionTo(
						"selfClosingStartTag"
						/* selfClosingStartTag */
);
				} else if (char === "&") {
					this.consume();
					this.delegate.appendToAttributeValue(this.consumeCharRef() || "&");
				} else if (char === ">") {
					this.delegate.finishAttributeValue();
					this.consume();
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else {
					this.consume();
					this.delegate.appendToAttributeValue(char);
				}
			},
			afterAttributeValueQuoted: function() {
				var char = this.peek();
				if (isSpace(char)) {
					this.consume();
					this.transitionTo(
						"beforeAttributeName"
						/* beforeAttributeName */
);
				} else if (char === "/") {
					this.consume();
					this.transitionTo(
						"selfClosingStartTag"
						/* selfClosingStartTag */
);
				} else if (char === ">") {
					this.consume();
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else this.transitionTo(
					"beforeAttributeName"
					/* beforeAttributeName */
);
			},
			selfClosingStartTag: function() {
				var char = this.peek();
				if (char === ">") {
					this.consume();
					this.delegate.markTagAsSelfClosing();
					this.delegate.finishTag();
					this.transitionTo(
						"beforeData"
						/* beforeData */
);
				} else this.transitionTo(
					"beforeAttributeName"
					/* beforeAttributeName */
);
			},
			endTagOpen: function() {
				var char = this.consume();
				if (char === "@" || char === ":" || isAlpha(char)) {
					this.transitionTo(
						"endTagName"
						/* endTagName */
);
					this.tagNameBuffer = "";
					this.delegate.beginEndTag();
					this.appendToTagName(char);
				}
			}
		};
		this.reset();
	}
	EventedTokenizer$1.prototype.reset = function() {
		this.transitionTo(
			"beforeData"
			/* beforeData */
);
		this.input = "";
		this.tagNameBuffer = "";
		this.index = 0;
		this.line = 1;
		this.column = 0;
		this.delegate.reset();
	};
	EventedTokenizer$1.prototype.transitionTo = function(state) {
		this.state = state;
	};
	EventedTokenizer$1.prototype.tokenize = function(input) {
		this.reset();
		this.tokenizePart(input);
		this.tokenizeEOF();
	};
	EventedTokenizer$1.prototype.tokenizePart = function(input) {
		this.input += preprocessInput(input);
		while (this.index < this.input.length) {
			var handler = this.states[this.state];
			if (handler !== undefined) handler.call(this);
else throw new Error("unhandled state " + this.state);
		}
	};
	EventedTokenizer$1.prototype.tokenizeEOF = function() {
		this.flushData();
	};
	EventedTokenizer$1.prototype.flushData = function() {
		if (this.state === "data") {
			this.delegate.finishData();
			this.transitionTo(
				"beforeData"
				/* beforeData */
);
		}
	};
	EventedTokenizer$1.prototype.peek = function() {
		return this.input.charAt(this.index);
	};
	EventedTokenizer$1.prototype.consume = function() {
		var char = this.peek();
		this.index++;
		if (char === "\n") {
			this.line++;
			this.column = 0;
		} else this.column++;
		return char;
	};
	EventedTokenizer$1.prototype.consumeCharRef = function() {
		var endIndex = this.input.indexOf(";", this.index);
		if (endIndex === -1) return;
		var entity = this.input.slice(this.index, endIndex);
		var chars = this.entityParser.parse(entity);
		if (chars) {
			var count = entity.length;
			while (count) {
				this.consume();
				count--;
			}
			this.consume();
			return chars;
		}
	};
	EventedTokenizer$1.prototype.markTagStart = function() {
		this.delegate.tagOpen();
	};
	EventedTokenizer$1.prototype.appendToTagName = function(char) {
		this.tagNameBuffer += char;
		this.delegate.appendToTagName(char);
	};
	EventedTokenizer$1.prototype.isIgnoredEndTag = function() {
		var tag = this.tagNameBuffer;
		return tag === "title" && this.input.substring(this.index, this.index + 8) !== "</title>" || tag === "style" && this.input.substring(this.index, this.index + 8) !== "</style>" || tag === "script" && this.input.substring(this.index, this.index + 9) !== "</script>";
	};
	return EventedTokenizer$1;
}();
var Tokenizer = function() {
	function Tokenizer$1(entityParser, options) {
		if (options === void 0) options = {};
		this.options = options;
		this.token = null;
		this.startLine = 1;
		this.startColumn = 0;
		this.tokens = [];
		this.tokenizer = new EventedTokenizer(this, entityParser, options.mode);
		this._currentAttribute = undefined;
	}
	Tokenizer$1.prototype.tokenize = function(input) {
		this.tokens = [];
		this.tokenizer.tokenize(input);
		return this.tokens;
	};
	Tokenizer$1.prototype.tokenizePart = function(input) {
		this.tokens = [];
		this.tokenizer.tokenizePart(input);
		return this.tokens;
	};
	Tokenizer$1.prototype.tokenizeEOF = function() {
		this.tokens = [];
		this.tokenizer.tokenizeEOF();
		return this.tokens[0];
	};
	Tokenizer$1.prototype.reset = function() {
		this.token = null;
		this.startLine = 1;
		this.startColumn = 0;
	};
	Tokenizer$1.prototype.current = function() {
		var token = this.token;
		if (token === null) throw new Error("token was unexpectedly null");
		if (arguments.length === 0) return token;
		for (var i = 0; i < arguments.length; i++) if (token.type === arguments[i]) return token;
		throw new Error("token type was unexpectedly " + token.type);
	};
	Tokenizer$1.prototype.push = function(token) {
		this.token = token;
		this.tokens.push(token);
	};
	Tokenizer$1.prototype.currentAttribute = function() {
		return this._currentAttribute;
	};
	Tokenizer$1.prototype.addLocInfo = function() {
		if (this.options.loc) this.current().loc = {
			start: {
				line: this.startLine,
				column: this.startColumn
			},
			end: {
				line: this.tokenizer.line,
				column: this.tokenizer.column
			}
		};
		this.startLine = this.tokenizer.line;
		this.startColumn = this.tokenizer.column;
	};
	Tokenizer$1.prototype.beginDoctype = function() {
		this.push({
			type: "Doctype",
			name: ""
		});
	};
	Tokenizer$1.prototype.appendToDoctypeName = function(char) {
		this.current(
			"Doctype"
			/* Doctype */
).name += char;
	};
	Tokenizer$1.prototype.appendToDoctypePublicIdentifier = function(char) {
		var doctype = this.current(
			"Doctype"
			/* Doctype */
);
		if (doctype.publicIdentifier === undefined) doctype.publicIdentifier = char;
else doctype.publicIdentifier += char;
	};
	Tokenizer$1.prototype.appendToDoctypeSystemIdentifier = function(char) {
		var doctype = this.current(
			"Doctype"
			/* Doctype */
);
		if (doctype.systemIdentifier === undefined) doctype.systemIdentifier = char;
else doctype.systemIdentifier += char;
	};
	Tokenizer$1.prototype.endDoctype = function() {
		this.addLocInfo();
	};
	Tokenizer$1.prototype.beginData = function() {
		this.push({
			type: "Chars",
			chars: ""
		});
	};
	Tokenizer$1.prototype.appendToData = function(char) {
		this.current(
			"Chars"
			/* Chars */
).chars += char;
	};
	Tokenizer$1.prototype.finishData = function() {
		this.addLocInfo();
	};
	Tokenizer$1.prototype.beginComment = function() {
		this.push({
			type: "Comment",
			chars: ""
		});
	};
	Tokenizer$1.prototype.appendToCommentData = function(char) {
		this.current(
			"Comment"
			/* Comment */
).chars += char;
	};
	Tokenizer$1.prototype.finishComment = function() {
		this.addLocInfo();
	};
	Tokenizer$1.prototype.tagOpen = function() {};
	Tokenizer$1.prototype.beginStartTag = function() {
		this.push({
			type: "StartTag",
			tagName: "",
			attributes: [],
			selfClosing: false
		});
	};
	Tokenizer$1.prototype.beginEndTag = function() {
		this.push({
			type: "EndTag",
			tagName: ""
		});
	};
	Tokenizer$1.prototype.finishTag = function() {
		this.addLocInfo();
	};
	Tokenizer$1.prototype.markTagAsSelfClosing = function() {
		this.current(
			"StartTag"
			/* StartTag */
).selfClosing = true;
	};
	Tokenizer$1.prototype.appendToTagName = function(char) {
		this.current(
			"StartTag",
			"EndTag"
			/* EndTag */
).tagName += char;
	};
	Tokenizer$1.prototype.beginAttribute = function() {
		this._currentAttribute = [
			"",
			"",
			false
		];
	};
	Tokenizer$1.prototype.appendToAttributeName = function(char) {
		this.currentAttribute()[0] += char;
	};
	Tokenizer$1.prototype.beginAttributeValue = function(isQuoted) {
		this.currentAttribute()[2] = isQuoted;
	};
	Tokenizer$1.prototype.appendToAttributeValue = function(char) {
		this.currentAttribute()[1] += char;
	};
	Tokenizer$1.prototype.finishAttributeValue = function() {
		this.current(
			"StartTag"
			/* StartTag */
).attributes.push(this._currentAttribute);
	};
	Tokenizer$1.prototype.reportSyntaxError = function(message) {
		this.current().syntaxError = message;
	};
	return Tokenizer$1;
}();
function tokenize(input, options) {
	var tokenizer = new Tokenizer(new EntityParser(HTML5NamedCharRefs), options);
	return tokenizer.tokenize(input);
}
const LinkifyResult = "LinkifyResult";
const StartTag = "StartTag";
const EndTag = "EndTag";
const Chars = "Chars";
const Comment = "Comment";
const Doctype = "Doctype";
/**
* @param {string} str html string to link
* @param {import('linkifyjs').Opts} [opts] linkify options
* @returns {string} resulting string
*/
function linkifyHtml(str, opts) {
	if (opts === void 0) opts = {};
	const tokens = tokenize(str);
	const linkifiedTokens = [];
	const linkified = [];
	const options = new Options(opts, defaultRender);
	for (let i = 0; i < tokens.length; i++) {
		const token = tokens[i];
		if (token.type === StartTag) {
			linkifiedTokens.push(token);
			const tagName = token.tagName.toUpperCase();
			const isIgnored = tagName === "A" || options.ignoreTags.indexOf(tagName) >= 0;
			if (!isIgnored) continue;
			let preskipLen = linkifiedTokens.length;
			skipTagTokens(tagName, tokens, ++i, linkifiedTokens);
			i += linkifiedTokens.length - preskipLen - 1;
		} else if (token.type !== Chars) linkifiedTokens.push(token);
else {
			const linkifedChars = linkifyChars(token.chars, options);
			linkifiedTokens.push.apply(linkifiedTokens, linkifedChars);
		}
	}
	for (let i = 0; i < linkifiedTokens.length; i++) {
		const token = linkifiedTokens[i];
		switch (token.type) {
			case LinkifyResult:
				linkified.push(token.rendered);
				break;
			case StartTag: {
				let link = "<" + token.tagName;
				if (token.attributes.length > 0) link += " " + attributeArrayToStrings(token.attributes).join(" ");
				if (token.selfClosing) link += " /";
				link += ">";
				linkified.push(link);
				break;
			}
			case EndTag:
				linkified.push(`</${token.tagName}>`);
				break;
			case Chars:
				linkified.push(escapeText(token.chars));
				break;
			case Comment:
				linkified.push(`<!--${escapeText(token.chars)}-->`);
				break;
			case Doctype: {
				let doctype = `<!DOCTYPE ${token.name}`;
				if (token.publicIdentifier) doctype += ` PUBLIC "${token.publicIdentifier}"`;
				if (token.systemIdentifier) doctype += ` "${token.systemIdentifier}"`;
				doctype += ">";
				linkified.push(doctype);
				break;
			}
		}
	}
	return linkified.join("");
}
/**
`tokens` and `token` in this section referes to tokens returned by
`linkify.tokenize`. `linkified` will contain HTML Parser-style tokens
@param {string}
@param {import('linkifyjs').Options}
*/
function linkifyChars(str, options) {
	const tokens = tokenize$1(str);
	const result = [];
	for (let i = 0; i < tokens.length; i++) {
		const token = tokens[i];
		if (token.t === "nl" && options.get("nl2br")) result.push({
			type: StartTag,
			tagName: "br",
			attributes: [],
			selfClosing: true
		});
else if (!token.isLink || !options.check(token)) result.push({
			type: Chars,
			chars: token.toString()
		});
else result.push({
			type: LinkifyResult,
			rendered: options.render(token)
		});
	}
	return result;
}
/**
Returns a list of tokens skipped until the closing tag of tagName.

* `tagName` is the closing tag which will prompt us to stop skipping
* `tokens` is the array of tokens generated by HTML5Tokenizer which
* `i` is the index immediately after the opening tag to skip
* `skippedTokens` is an array which skipped tokens are being pushed into

Caveats

* Assumes that i is the first token after the given opening tagName
* The closing tag will be skipped, but nothing after it
* Will track whether there is a nested tag of the same type
*/
function skipTagTokens(tagName, tokens, i, skippedTokens) {
	let stackCount = 1;
	while (i < tokens.length && stackCount > 0) {
		let token = tokens[i];
		if (token.type === StartTag && token.tagName.toUpperCase() === tagName) stackCount++;
else if (token.type === EndTag && token.tagName.toUpperCase() === tagName) stackCount--;
		skippedTokens.push(token);
		i++;
	}
	return skippedTokens;
}
function defaultRender(_ref) {
	let { tagName, attributes, content } = _ref;
	return `<${tagName} ${attributesToString(attributes)}>${escapeText(content)}</${tagName}>`;
}
function escapeText(text) {
	return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function escapeAttr(attr) {
	return attr.replace(/"/g, "&quot;");
}
function attributesToString(attributes) {
	const result = [];
	for (const attr in attributes) {
		const val = attributes[attr] + "";
		result.push(`${attr}="${escapeAttr(val)}"`);
	}
	return result.join(" ");
}
function attributeArrayToStrings(attrs) {
	const attrStrs = [];
	for (let i = 0; i < attrs.length; i++) {
		const name = attrs[i][0];
		const value = attrs[i][1] + "";
		attrStrs.push(`${name}="${escapeAttr(value)}"`);
	}
	return attrStrs;
}

//#endregion
//#region ../src/common/api/worker/Urlifier.ts
function urlify(html) {
	return linkifyHtml(html, {
		defaultProtocol: "https",
		attributes: { rel: "noopener noreferrer" },
		target: "_blank"
	});
}

//#endregion
export { urlify };
//# sourceMappingURL=Urlifier-0Ec01nef.js.map