{"version":3,"file":"DesktopFileFacade-o-Coc2Lq.js","names":["win: ApplicationWindow","conf: DesktopConfig","dateProvider: DateProvider","fetch: FetchImpl","electron: ElectronExports","tfs: TempFs","fs: FsExports","filename: string","sourceUrl: string","fileName: string","headers: Record<string, string>","readable: stream.Readable","response: stream.Readable","encryptedFilePath: string","fileStream: WriteStream","file: string","fileUri: string","files: Array<string>","location: string","boundingRect: IpcClientRect","filter: ReadonlyArray<string> | null","opts: OpenDialogOptions","localFileUri: string","fileNameToUse: string","maxChunkSizeBytes: number","chunkPaths: string[]","targetUrl: string","method: HttpMethod","responseBody: Uint8Array","file: DataFile","directory: string","uriOrPath: FileUri","savePath: string","stream: FsModule.WriteStream","stream: stream.Readable","data: Buffer[]","headers: Headers","name: string","into: stream.Writable","body: ReadableStream<unknown>"],"sources":["../../src/common/desktop/files/DesktopFileFacade.ts"],"sourcesContent":["import { FileFacade } from \"../../native/common/generatedipc/FileFacade.js\"\nimport { DownloadTaskResponse } from \"../../native/common/generatedipc/DownloadTaskResponse.js\"\nimport { IpcClientRect } from \"../../native/common/generatedipc/IpcClientRect.js\"\nimport { ElectronExports, FsExports } from \"../ElectronExportTypes.js\"\nimport { UploadTaskResponse } from \"../../native/common/generatedipc/UploadTaskResponse.js\"\nimport { DataFile } from \"../../api/common/DataFile.js\"\nimport { FileUri } from \"../../native/common/FileApp.js\"\nimport path from \"node:path\"\nimport { ApplicationWindow } from \"../ApplicationWindow.js\"\nimport { sha256Hash } from \"@tutao/tutanota-crypto\"\nimport { assertNotNull, splitUint8ArrayInChunks, stringToUtf8Uint8Array, uint8ArrayToBase64, uint8ArrayToHex } from \"@tutao/tutanota-utils\"\nimport { looksExecutable, nonClobberingFilename } from \"../PathUtils.js\"\nimport url from \"node:url\"\nimport FsModule from \"node:fs\"\nimport { Buffer } from \"node:buffer\"\nimport { default as stream } from \"node:stream\"\nimport type { ReadableStream } from \"node:stream/web\"\nimport { FileOpenError } from \"../../api/common/error/FileOpenError.js\"\nimport { lang } from \"../../misc/LanguageViewModel.js\"\nimport { log } from \"../DesktopLog.js\"\nimport { WriteStream } from \"fs-extra\"\nimport { BuildConfigKey, DesktopConfigKey } from \"../config/ConfigKeys.js\"\nimport { CancelledError } from \"../../api/common/error/CancelledError.js\"\nimport { DesktopConfig } from \"../config/DesktopConfig.js\"\nimport { DateProvider } from \"../../api/common/DateProvider.js\"\nimport { TempFs } from \"./TempFs.js\"\nimport { HttpMethod } from \"../../api/common/EntityFunctions\"\nimport { FetchImpl } from \"../net/NetAgent\"\nimport { OpenDialogOptions } from \"electron\"\n\nconst TAG = \"[DesktopFileFacade]\"\n\nexport class DesktopFileFacade implements FileFacade {\n\t/** We don't want to spam opening file manager all the time so we throttle it. This field is set to the last time we opened it. */\n\tprivate lastOpenedFileManagerAt: number | null\n\n\tconstructor(\n\t\tprivate readonly win: ApplicationWindow,\n\t\tprivate readonly conf: DesktopConfig,\n\t\tprivate readonly dateProvider: DateProvider,\n\t\tprivate readonly fetch: FetchImpl,\n\t\tprivate readonly electron: ElectronExports,\n\t\tprivate readonly tfs: TempFs,\n\t\tprivate readonly fs: FsExports,\n\t) {\n\t\tthis.lastOpenedFileManagerAt = null\n\t}\n\n\tclearFileData(): Promise<void> {\n\t\tthis.tfs.clear()\n\t\treturn Promise.resolve()\n\t}\n\n\tasync deleteFile(filename: string): Promise<void> {\n\t\treturn await this.fs.promises.unlink(filename)\n\t}\n\n\tasync download(sourceUrl: string, fileName: string, headers: Record<string, string>): Promise<DownloadTaskResponse> {\n\t\tconst { status, headers: headersIncoming, body } = await this.fetch(sourceUrl, { method: \"GET\", headers })\n\t\tlet encryptedFilePath\n\t\tif (status == 200 && body != null) {\n\t\t\tconst downloadDirectory = await this.tfs.ensureEncryptedDir()\n\t\t\tencryptedFilePath = path.join(downloadDirectory, fileName)\n\t\t\tconst readable: stream.Readable = bodyToReadable(body)\n\t\t\tawait this.pipeIntoFile(readable, encryptedFilePath)\n\t\t} else {\n\t\t\tencryptedFilePath = null\n\t\t}\n\n\t\tconst result = {\n\t\t\tstatusCode: status,\n\t\t\tencryptedFileUri: encryptedFilePath,\n\t\t\terrorId: getHttpHeader(headersIncoming, \"error-id\"),\n\t\t\tprecondition: getHttpHeader(headersIncoming, \"precondition\"),\n\t\t\tsuspensionTime: getHttpHeader(headersIncoming, \"suspension-time\") ?? getHttpHeader(headersIncoming, \"retry-after\"),\n\t\t}\n\n\t\tlog.info(TAG, \"Download finished\", result.statusCode, result.suspensionTime)\n\t\treturn result\n\t}\n\n\tprivate async pipeIntoFile(response: stream.Readable, encryptedFilePath: string) {\n\t\tconst fileStream: WriteStream = this.fs.createWriteStream(encryptedFilePath, { emitClose: true })\n\t\ttry {\n\t\t\tawait pipeStream(response, fileStream)\n\t\t\tawait closeFileStream(fileStream)\n\t\t} catch (e) {\n\t\t\t// Close first, delete second\n\t\t\t// Also yes, we do need to close it manually:\n\t\t\t// > One important caveat is that if the Readable stream emits an error during processing, the Writable destination is not closed automatically.\n\t\t\t// > If an error occurs, it will be necessary to manually close each stream in order to prevent memory leaks.\n\t\t\t// see https://nodejs.org/api/stream.html#readablepipedestination-options\n\t\t\tawait closeFileStream(fileStream)\n\t\t\tawait this.fs.promises.unlink(encryptedFilePath)\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tasync getMimeType(file: string): Promise<string> {\n\t\treturn await getMimeTypeForFile(file)\n\t}\n\n\tasync getName(file: string): Promise<string> {\n\t\treturn path.basename(file)\n\t}\n\n\tasync getSize(fileUri: string): Promise<number> {\n\t\tconst stats = await this.fs.promises.stat(fileUri)\n\t\treturn stats.size\n\t}\n\n\tasync hashFile(fileUri: string): Promise<string> {\n\t\tconst data = await this.fs.promises.readFile(fileUri)\n\t\tconst checksum = sha256Hash(data).slice(0, 6)\n\t\treturn uint8ArrayToBase64(checksum)\n\t}\n\n\tasync joinFiles(filename: string, files: Array<string>): Promise<string> {\n\t\tconst downloadDirectory = await this.tfs.ensureUnencrytpedDir()\n\n\t\tconst filesInDirectory = await this.fs.promises.readdir(downloadDirectory)\n\t\tconst newFilename = nonClobberingFilename(filesInDirectory, filename)\n\t\tconst fileUri = path.join(downloadDirectory, newFilename)\n\t\tconst outStream = this.fs.createWriteStream(fileUri, { autoClose: false })\n\n\t\tfor (const infile of files) {\n\t\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\t\tconst readStream = this.fs.createReadStream(infile)\n\t\t\t\treadStream.on(\"end\", resolve)\n\t\t\t\treadStream.on(\"error\", reject)\n\t\t\t\treadStream.pipe(outStream, { end: false })\n\t\t\t})\n\t\t}\n\t\tawait closeFileStream(outStream)\n\t\treturn fileUri\n\t}\n\n\topen(location: string /* , mimeType: string omitted */): Promise<void> {\n\t\tconst tryOpen = () =>\n\t\t\tthis.electron.shell\n\t\t\t\t.openPath(location) // may resolve with \"\" or an error message\n\t\t\t\t.catch(() => \"failed to open path.\")\n\t\t\t\t.then((errMsg) => (errMsg === \"\" ? Promise.resolve() : Promise.reject(new FileOpenError(\"Could not open \" + location + \", \" + errMsg))))\n\n\t\t// only windows will happily execute a just downloaded program\n\t\tif (process.platform === \"win32\" && looksExecutable(location)) {\n\t\t\treturn this.electron.dialog\n\t\t\t\t.showMessageBox({\n\t\t\t\t\ttype: \"warning\",\n\t\t\t\t\tbuttons: [lang.get(\"yes_label\"), lang.get(\"no_label\")],\n\t\t\t\t\ttitle: lang.get(\"executableOpen_label\"),\n\t\t\t\t\tmessage: lang.get(\"executableOpen_msg\"),\n\t\t\t\t\tdefaultId: 1, // default button\n\t\t\t\t})\n\t\t\t\t.then(({ response }) => {\n\t\t\t\t\tif (response === 0) {\n\t\t\t\t\t\treturn tryOpen()\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Promise.resolve()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t} else {\n\t\t\treturn tryOpen()\n\t\t}\n\t}\n\n\tasync openFileChooser(boundingRect: IpcClientRect, filter: ReadonlyArray<string> | null): Promise<Array<string>> {\n\t\tconst opts: OpenDialogOptions = { properties: [\"openFile\", \"multiSelections\"] }\n\t\tif (filter != null) {\n\t\t\topts.filters = [{ name: \"Filter\", extensions: filter.slice() }]\n\t\t}\n\t\tconst { filePaths } = await this.electron.dialog.showOpenDialog(this.win._browserWindow, opts)\n\t\treturn filePaths\n\t}\n\n\topenFolderChooser(): Promise<string | null> {\n\t\t// open folder dialog\n\t\treturn this.electron.dialog\n\t\t\t.showOpenDialog(this.win._browserWindow, {\n\t\t\t\tproperties: [\"openDirectory\"],\n\t\t\t})\n\t\t\t.then(({ filePaths }) => filePaths[0] ?? null)\n\t}\n\n\tasync putFileIntoDownloadsFolder(localFileUri: string, fileNameToUse: string): Promise<string> {\n\t\tconst savePath = await this.pickSavePath(fileNameToUse)\n\t\tawait this.fs.promises.mkdir(path.dirname(savePath), {\n\t\t\trecursive: true,\n\t\t})\n\t\tawait this.fs.promises.copyFile(localFileUri, savePath)\n\t\tawait this.showInFileExplorer(savePath)\n\t\treturn savePath\n\t}\n\n\tasync splitFile(fileUri: string, maxChunkSizeBytes: number): Promise<Array<string>> {\n\t\tconst tempDir = await this.tfs.ensureUnencrytpedDir()\n\t\tconst fullBytes = await this.fs.promises.readFile(fileUri)\n\t\tconst chunks = splitUint8ArrayInChunks(maxChunkSizeBytes, fullBytes)\n\t\t// this could just be randomized, we don't seem to care about the blob file names\n\t\tconst filenameHash = uint8ArrayToHex(sha256Hash(stringToUtf8Uint8Array(fileUri)))\n\t\tconst chunkPaths: string[] = []\n\n\t\tfor (let i = 0; i < chunks.length; i++) {\n\t\t\tconst chunk = chunks[i]\n\t\t\tconst fileName = `${filenameHash}.${i}.blob`\n\t\t\tconst chunkPath = path.join(tempDir, fileName)\n\t\t\tawait this.fs.promises.writeFile(chunkPath, chunk)\n\t\t\tchunkPaths.push(chunkPath)\n\t\t}\n\n\t\treturn chunkPaths\n\t}\n\n\tasync upload(fileUri: string, targetUrl: string, method: HttpMethod, headers: Record<string, string>): Promise<UploadTaskResponse> {\n\t\tconst fileStream = this.fs.createReadStream(fileUri)\n\t\tconst stat = await this.fs.promises.stat(fileUri)\n\t\theaders[\"Content-Length\"] = `${stat.size}`\n\t\tconst response = await this.fetch(targetUrl, { method, headers, body: fileStream })\n\n\t\tlet responseBody: Uint8Array\n\t\tif ((response.status == 200 || response.status == 201) && response.body != null) {\n\t\t\tconst readable: stream.Readable = bodyToReadable(response.body)\n\t\t\tresponseBody = await readStreamToBuffer(readable)\n\t\t} else {\n\t\t\t// this is questionable, should probably change the type\n\t\t\tresponseBody = new Uint8Array([])\n\t\t}\n\t\treturn {\n\t\t\tstatusCode: assertNotNull(response.status),\n\t\t\terrorId: getHttpHeader(response.headers, \"error-id\"),\n\t\t\tprecondition: getHttpHeader(response.headers, \"precondition\"),\n\t\t\tsuspensionTime: getHttpHeader(response.headers, \"suspension-time\") ?? getHttpHeader(response.headers, \"retry-after\"),\n\t\t\tresponseBody,\n\t\t}\n\t}\n\n\t// this is only used to write decrypted data into our tmp\n\tasync writeDataFile(file: DataFile): Promise<string> {\n\t\treturn await this.tfs.writeToDisk(file.data, \"decrypted\")\n\t}\n\n\tasync writeDataFileToDirectory(file: DataFile, directory: string): Promise<string> {\n\t\tconst filePath = path.join(directory, file.name)\n\t\tawait this.fs.promises.writeFile(filePath, file.data)\n\t\treturn filePath\n\t}\n\n\t// this is used to read unencrypted data from arbitrary locations\n\tasync readDataFile(uriOrPath: FileUri): Promise<DataFile | null> {\n\t\ttry {\n\t\t\turiOrPath = url.fileURLToPath(uriOrPath)\n\t\t} catch (e) {\n\t\t\t// the thing already was a path, or at least not an URI\n\t\t}\n\t\tconst name = path.basename(uriOrPath)\n\t\ttry {\n\t\t\tconst [data, mimeType] = await Promise.all([this.fs.promises.readFile(uriOrPath), this.getMimeType(uriOrPath)])\n\t\t\tif (data == null) return null\n\t\t\treturn {\n\t\t\t\t_type: \"DataFile\",\n\t\t\t\tdata,\n\t\t\t\tname,\n\t\t\t\tmimeType,\n\t\t\t\tsize: data.length,\n\t\t\t\tid: undefined,\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/** select a non-colliding name in the configured downloadPath, preferably with the given file name\n\t * public for testing */\n\tasync pickSavePath(filename: string): Promise<string> {\n\t\tconst defaultDownloadPath = await this.conf.getVar(DesktopConfigKey.defaultDownloadPath)\n\n\t\tif (defaultDownloadPath != null) {\n\t\t\tconst fileName = path.basename(filename)\n\t\t\treturn path.join(defaultDownloadPath, nonClobberingFilename(await this.fs.promises.readdir(defaultDownloadPath), fileName))\n\t\t} else {\n\t\t\tconst { canceled, filePath } = await this.electron.dialog.showSaveDialog({\n\t\t\t\tdefaultPath: path.join(this.electron.app.getPath(\"downloads\"), filename),\n\t\t\t})\n\n\t\t\tif (canceled) {\n\t\t\t\tthrow new CancelledError(\"Path selection cancelled\")\n\t\t\t} else {\n\t\t\t\treturn assertNotNull(filePath)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** public for testing */\n\tasync showInFileExplorer(savePath: string): Promise<void> {\n\t\t// See doc for _lastOpenedFileManagerAt on why we do this throttling.\n\t\tconst lastOpenedFileManagerAt = this.lastOpenedFileManagerAt\n\t\tconst fileManagerTimeout = await this.conf.getConst(BuildConfigKey.fileManagerTimeout)\n\n\t\tif (lastOpenedFileManagerAt == null || this.dateProvider.now() - lastOpenedFileManagerAt > fileManagerTimeout) {\n\t\t\tthis.lastOpenedFileManagerAt = this.dateProvider.now()\n\t\t\tawait this.electron.shell.openPath(path.dirname(savePath))\n\t\t}\n\t}\n}\n\nexport async function getMimeTypeForFile(file: string): Promise<string> {\n\tconst ext = path.extname(file).slice(1)\n\tconst { mimes } = await import(\"../flat-mimes.js\")\n\tconst candidates = mimes[ext]\n\t// sometimes there are multiple options, but we'll take the first and reorder if issues arise.\n\treturn candidates != null ? candidates[0] : \"application/octet-stream\"\n}\n\nfunction closeFileStream(stream: FsModule.WriteStream): Promise<void> {\n\treturn new Promise((resolve) => {\n\t\tstream.on(\"close\", resolve)\n\t\tstream.close()\n\t})\n}\n\nexport async function readStreamToBuffer(stream: stream.Readable): Promise<Uint8Array> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst data: Buffer[] = []\n\n\t\tstream.on(\"data\", (chunk) => {\n\t\t\tdata.push(chunk as Buffer)\n\t\t})\n\n\t\tstream.on(\"end\", () => {\n\t\t\tresolve(Buffer.concat(data))\n\t\t})\n\n\t\tstream.on(\"error\", (err) => {\n\t\t\treject(err)\n\t\t})\n\t})\n}\n\nfunction getHttpHeader(headers: Headers, name: string): string | null {\n\t// All headers are in lowercase. Lowercase them just to be sure\n\treturn headers.get(name.toLowerCase())\n}\n\nfunction pipeStream(stream: stream.Readable, into: stream.Writable): Promise<void> {\n\treturn new Promise((resolve, reject) => {\n\t\tstream.on(\"error\", reject)\n\t\tstream.pipe(into)\n\t\tinto.on(\"finish\", resolve)\n\t\tinto.on(\"error\", reject)\n\t})\n}\n\nfunction bodyToReadable(body: ReadableStream<unknown>): stream.Readable {\n\t// https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/65542\n\treturn stream.Readable.fromWeb(body)\n}\n"],"mappings":"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"}