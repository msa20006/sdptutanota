{"version":3,"file":"MailAddressTableModel-DGB9dbCy.js","names":["entityClient: EntityClient","serviceExecutor: IServiceExecutor","mailAddressFacade: MailAddressFacade","logins: LoginController","eventController: EventController","userGroupInfo: GroupInfo","nameChanger: MailAddressNameChanger","redraw: () => unknown","address: string","senderName: string","alias: string","restore: boolean","updates: ReadonlyArray<EntityUpdateData>"],"sources":["../../src/common/settings/mailaddress/MailAddressTableModel.ts"],"sourcesContent":["import { EntityClient } from \"../../api/common/EntityClient.js\"\nimport { MailboxPropertiesTypeRef } from \"../../api/entities/tutanota/TypeRefs.js\"\nimport { MailAddressFacade } from \"../../api/worker/facades/lazy/MailAddressFacade.js\"\nimport { LoginController } from \"../../api/main/LoginController.js\"\nimport { EventController } from \"../../api/main/EventController.js\"\nimport { OperationType } from \"../../api/common/TutanotaConstants.js\"\nimport { EmailDomainData, getAvailableDomains } from \"./MailAddressesUtils.js\"\nimport { GroupInfo, GroupInfoTypeRef, MailAddressAliasServiceReturn } from \"../../api/entities/sys/TypeRefs.js\"\nimport { assertNotNull, lazyMemoized } from \"@tutao/tutanota-utils\"\nimport { LimitReachedError } from \"../../api/common/error/RestError.js\"\nimport { UserError } from \"../../api/main/UserError.js\"\nimport { UpgradeRequiredError } from \"../../api/main/UpgradeRequiredError.js\"\nimport { IServiceExecutor } from \"../../api/common/ServiceRequest.js\"\nimport { getAvailableMatchingPlans } from \"../../subscription/SubscriptionUtils.js\"\nimport { EntityUpdateData, isUpdateFor, isUpdateForTypeRef } from \"../../api/common/utils/EntityUpdateUtils.js\"\nimport { isTutaMailAddress } from \"../../mailFunctionality/SharedMailUtils.js\"\n\nexport enum AddressStatus {\n\tPrimary,\n\tAlias,\n\tDisabledAlias,\n\tCustom,\n}\n\nexport interface AddressInfo {\n\tname: string\n\taddress: string\n\tstatus: AddressStatus\n}\n\nexport type AddressToName = Map<string, string>\n\n/** A strategy to change mail address to sender name mapping. */\nexport interface MailAddressNameChanger {\n\tgetSenderNames(): Promise<AddressToName>\n\n\tsetSenderName(address: string, name: string): Promise<AddressToName>\n\n\tremoveSenderName(address: string): Promise<AddressToName>\n}\n\n/** Model for showing the list of mail addresses and optionally adding more, enabling/disabling/setting names for them. */\nexport class MailAddressTableModel {\n\tprivate nameMappings: AddressToName | null = null\n\tprivate onLegacyPlan: boolean = false\n\taliasCount: MailAddressAliasServiceReturn | null = null\n\n\tinit: () => Promise<void> = lazyMemoized(async () => {\n\t\tthis.eventController.addEntityListener(this.entityEventsReceived)\n\n\t\t// important: \"not on legacy plan\" is true for free plans\n\t\tconst userController = this.logins.getUserController()\n\t\tthis.onLegacyPlan = userController.isLegacyPlan(await userController.getPlanType())\n\n\t\tawait this.loadNames()\n\t\tthis.redraw()\n\t\tawait this.loadAliasCount()\n\t\tthis.redraw()\n\t})\n\n\tconstructor(\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly mailAddressFacade: MailAddressFacade,\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate userGroupInfo: GroupInfo,\n\t\tprivate readonly nameChanger: MailAddressNameChanger,\n\t\tprivate readonly redraw: () => unknown,\n\t) {}\n\n\tdispose() {\n\t\tthis.eventController.removeEntityListener(this.entityEventsReceived)\n\t}\n\n\tuserCanModifyAliases(): boolean {\n\t\treturn this.logins.getUserController().isGlobalAdmin()\n\t}\n\n\taliasLimitIncludesCustomDomains(): boolean {\n\t\treturn this.onLegacyPlan\n\t}\n\n\taddresses(): AddressInfo[] {\n\t\tconst { nameMappings } = this\n\t\tif (nameMappings == null) {\n\t\t\treturn []\n\t\t}\n\n\t\tconst primaryAddress = assertNotNull(this.userGroupInfo.mailAddress)\n\t\tconst primaryAddressInfo = {\n\t\t\tname: nameMappings.get(primaryAddress) ?? \"\",\n\t\t\taddress: primaryAddress,\n\t\t\tstatus: AddressStatus.Primary,\n\t\t}\n\n\t\tconst aliasesInfo = this.userGroupInfo.mailAddressAliases\n\t\t\t.slice()\n\t\t\t.sort((a, b) => (a.mailAddress > b.mailAddress ? 1 : -1))\n\t\t\t.map(({ mailAddress, enabled }) => {\n\t\t\t\tconst status =\n\t\t\t\t\t// O(aliases * TUTA_MAIL_ADDRESS_DOMAINS)\n\t\t\t\t\tisTutaMailAddress(mailAddress) ? (enabled ? AddressStatus.Alias : AddressStatus.DisabledAlias) : AddressStatus.Custom\n\n\t\t\t\treturn {\n\t\t\t\t\tname: nameMappings.get(mailAddress) ?? \"\",\n\t\t\t\t\taddress: mailAddress,\n\t\t\t\t\tstatus,\n\t\t\t\t}\n\t\t\t})\n\t\treturn [primaryAddressInfo, ...aliasesInfo]\n\t}\n\n\tasync setAliasName(address: string, senderName: string) {\n\t\tthis.nameMappings = await this.nameChanger.setSenderName(address, senderName)\n\t\tthis.redraw()\n\t}\n\n\t/**\n\t * Add an alias.\n\t * @throws if an error occurred, such as a LimitReachedError if too many aliases were added\n\t */\n\tasync addAlias(alias: string, senderName: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this.mailAddressFacade.addMailAlias(this.userGroupInfo.group, alias)\n\t\t\tawait this.setAliasName(alias, senderName)\n\t\t} catch (e) {\n\t\t\tif (e instanceof LimitReachedError) {\n\t\t\t\tawait this.handleTooManyAliases()\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tgetAvailableDomains(): Promise<EmailDomainData[]> {\n\t\treturn getAvailableDomains(this.logins)\n\t}\n\n\tasync setAliasStatus(address: string, restore: boolean): Promise<void> {\n\t\tawait this.mailAddressFacade.setMailAliasStatus(this.userGroupInfo.group, address, restore)\n\t\tthis.redraw()\n\t\tthis.nameMappings = await this.nameChanger.removeSenderName(address)\n\t\tthis.redraw()\n\t}\n\n\tdefaultSenderName(): string {\n\t\treturn this.userGroupInfo.name\n\t}\n\n\tprivate entityEventsReceived = async (updates: ReadonlyArray<EntityUpdateData>) => {\n\t\tfor (const update of updates) {\n\t\t\tif (isUpdateForTypeRef(MailboxPropertiesTypeRef, update) && update.operation === OperationType.UPDATE) {\n\t\t\t\tawait this.loadNames()\n\t\t\t} else if (isUpdateFor(this.userGroupInfo, update) && update.operation === OperationType.UPDATE) {\n\t\t\t\tthis.userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, this.userGroupInfo._id)\n\t\t\t\tawait this.loadAliasCount()\n\t\t\t}\n\t\t}\n\t\tthis.redraw()\n\t}\n\n\tprivate async loadNames() {\n\t\tthis.nameMappings = await this.nameChanger.getSenderNames()\n\t}\n\n\tprivate async loadAliasCount() {\n\t\tthis.aliasCount = await this.mailAddressFacade.getAliasCounters(this.userGroupInfo.group)\n\t}\n\n\t/**\n\t * Chooses the correct error to throw.\n\t * @throws UpgradeRequiredError if the customer can upgrade to a plan with more aliases\n\t * @throws UserError if the customer cannot add more aliases\n\t */\n\tpublic async handleTooManyAliases(): Promise<void> {\n\t\t// Determine if there is an available plan we can switch to that would let the user add an alias.\n\t\t// If so, show an upgrade dialog. Otherwise, inform the user that they reached the maximum number of aliases.\n\t\tconst plansWithMoreAliases = await getAvailableMatchingPlans(\n\t\t\tthis.serviceExecutor,\n\t\t\t(config) => Number(config.nbrOfAliases) > this.userGroupInfo.mailAddressAliases.length,\n\t\t)\n\t\tif (plansWithMoreAliases.length > 0) {\n\t\t\tthrow new UpgradeRequiredError(\"moreAliasesRequired_msg\", plansWithMoreAliases)\n\t\t} else {\n\t\t\tthrow new UserError(\"adminMaxNbrOfAliasesReached_msg\")\n\t\t}\n\t}\n}\n"],"mappings":"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"}