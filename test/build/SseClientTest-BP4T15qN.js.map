{"version":3,"file":"SseClientTest-BP4T15qN.js","names":["newState: State","net: DesktopNetworkClient","delay: SseDelay","scheduler: Scheduler","options: SseConnectOptions","attempt: number","listener: SseEventHandler","timeoutSeconds: number","defaultOptions: SseConnectOptions","sseClient: SseClient","net: NetStub","delay: SseDelay","scheduler: SchedulerMock","listener: SseEventHandler","url: URL","opts: ClientRequestOptions","response: ResponseStub","error: Error","data: string","e: Error"],"sources":["../../src/common/desktop/sse/SseClient.ts","../tests/desktop/sse/SseClientTest.ts"],"sourcesContent":["import http from \"node:http\"\nimport type { DesktopNetworkClient } from \"../net/DesktopNetworkClient\"\nimport { makeTaggedLogger } from \"../DesktopLog\"\nimport { Scheduler } from \"../../api/common/utils/Scheduler.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\nimport { reverse } from \"../../api/common/TutanotaConstants.js\"\n\nconst log = makeTaggedLogger(\"[SSE]\")\n\n/**\n * Provides computed delays for SSE (in ms)\n */\nexport interface SseDelay {\n\treconnectDelay(attempt: number): number\n\n\tinitialConnectionDelay(): number\n}\n\nexport interface SseEventHandler {\n\tonNewMessage: (message: string) => unknown\n\tonNotAuthenticated: () => unknown\n}\n\nexport interface SseConnectOptions {\n\turl: URL\n\theaders: Record<string, string | undefined>\n}\n\nexport enum ConnectionState {\n\t/** Not connecting or trying to connect. */\n\tdisconnected,\n\t/** Will try to reconnect after timeout. */\n\tdelayedReconnect,\n\t/** Started the connection. */\n\tconnecting,\n\t/** Received the response, connection is usable. */\n\tconnected,\n}\n\n/**\n *   +--------------+                              +-------------+\n *   | Disconnected |                              |  Connecting |\n *   +-------^------+ ----------connect-------->   +----+--------+\n *           |                                  | ^     |\n *           |        +-----------error---------+ |     |\n *           |        |                           |     response\n *       disconnect   |                           |     |\n *           |        v ----------timeout---------+     v\n * +---------+---------+                           +--------------+\n * | DelayedConnecting |<---------close------------+   Connected  |\n * +-------------------+          error            +--------------+\n */\ntype State =\n\t| { state: ConnectionState.disconnected }\n\t| { state: ConnectionState.connecting; options: SseConnectOptions; attempt: number; connection: http.ClientRequest }\n\t| { state: ConnectionState.delayedReconnect; options: SseConnectOptions; attempt: number; timeout: NodeJS.Timeout }\n\t| { state: ConnectionState.connected; options: SseConnectOptions; connection: http.ClientRequest; receivedHeartbeat: boolean }\n\n/**\n * Generic Server Sent Events client.\n * Does automatically reconnect.\n */\nexport class SseClient {\n\tprivate listener: SseEventHandler | null = null\n\tprivate _state: State = { state: ConnectionState.disconnected }\n\tprivate readTimeoutSec: number | null = null\n\tprivate heartBeatListenerHandle: NodeJS.Timeout | undefined = undefined\n\n\tprivate set state(newState: State) {\n\t\tconst stateName = reverse(ConnectionState)[newState.state]\n\t\tlog.debug(\"state:\", stateName)\n\t\tthis._state = newState\n\t}\n\n\tprivate get state(): State {\n\t\treturn this._state\n\t}\n\n\tconstructor(private readonly net: DesktopNetworkClient, private readonly delay: SseDelay, private readonly scheduler: Scheduler) {}\n\n\tasync connect(options: SseConnectOptions) {\n\t\tlog.debug(\"connect\")\n\t\tswitch (this.state.state) {\n\t\t\tcase ConnectionState.delayedReconnect:\n\t\t\t\tthis.scheduler.unscheduleTimeout(this.state.timeout)\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.connecting:\n\t\t\tcase ConnectionState.connected:\n\t\t\t\tawait this.disconnect()\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.disconnected:\n\t\t\t\tbreak\n\t\t\t// go on with connection\n\t\t}\n\t\tthis.doConnect(options)\n\t}\n\n\tprivate doConnect(options: SseConnectOptions) {\n\t\tlet attempt: number\n\t\tswitch (this.state.state) {\n\t\t\tcase ConnectionState.disconnected:\n\t\t\t\tattempt = 1\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.delayedReconnect:\n\t\t\t\tattempt = this.state.attempt\n\t\t\t\t// go on with connection\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.connecting:\n\t\t\tcase ConnectionState.connected:\n\t\t\t\tthrow new ProgrammingError(\"Invalid state: already connecting\")\n\t\t}\n\n\t\tconst { url, headers } = options\n\n\t\tconst connection = this.net.request(url, {\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\tConnection: \"Keep-Alive\",\n\t\t\t\t\"Keep-Alive\": \"header\",\n\t\t\t\tAccept: \"text/event-stream\",\n\t\t\t\t...headers,\n\t\t\t},\n\t\t\tmethod: \"GET\",\n\t\t})\n\t\tconnection\n\t\t\t.on(\"socket\", (s) => {\n\t\t\t\t// We add this listener purely as a workaround for some problem with net module.\n\t\t\t\t// The problem is that sometimes request gets stuck after handshake - does not process unless some event\n\t\t\t\t// handler is called (and it works more reliably with console.log()).\n\t\t\t\t// This makes the request magically unstuck, probably console.log does some I/O and/or socket things.\n\t\t\t\ts.on(\"lookup\", () => log.debug(\"lookup\"))\n\t\t\t})\n\t\t\t.on(\"response\", async (res) => {\n\t\t\t\tlog.debug(\"established SSE connection with code\", res.statusCode)\n\t\t\t\tthis.state = { state: ConnectionState.connected, connection, options, receivedHeartbeat: false }\n\t\t\t\tthis.resetHeartbeatListener()\n\n\t\t\t\tif (res.statusCode === 403 || res.statusCode === 401) {\n\t\t\t\t\tawait this.listener?.onNotAuthenticated()\n\t\t\t\t\tawait this.disconnect()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tres.setEncoding(\"utf8\")\n\t\t\t\tlet resData = \"\"\n\t\t\t\tres.on(\"data\", (d) => {\n\t\t\t\t\t// add new data to the buffer\n\t\t\t\t\tresData += d\n\t\t\t\t\tconst lines = resData.split(\"\\n\")\n\t\t\t\t\tresData = lines.pop() ?? \"\" // put the last line back into the buffer\n\n\t\t\t\t\tfor (const l of lines) {\n\t\t\t\t\t\tconst trimmedLine = l.trim()\n\t\t\t\t\t\tif (trimmedLine === \"\") {\n\t\t\t\t\t\t\tlog.debug(\"heartbeat\")\n\t\t\t\t\t\t\tthis.onHeartbeat()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.listener?.onNewMessage(trimmedLine)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t\t.on(\"close\", () => {\n\t\t\t\t\t\tlog.debug(\"response closed\")\n\t\t\t\t\t\t// This event is fired also when we close the connection manually. In this case we do not want to reconnect.\n\t\t\t\t\t\tif (this.state.state != ConnectionState.disconnected) this.delayedReconnect()\n\t\t\t\t\t})\n\t\t\t\t\t.on(\"error\", (e) => {\n\t\t\t\t\t\tlog.error(\"response error:\", e)\n\t\t\t\t\t\t// This event is fired also when we close the connection manually. In this case we do not want to reconnect.\n\t\t\t\t\t\tif (this.state.state != ConnectionState.disconnected) this.delayedReconnect()\n\t\t\t\t\t})\n\t\t\t})\n\t\t\t.on(\"information\", () => log.debug(\"information\"))\n\t\t\t.on(\"connect\", () => log.debug(\"connect:\"))\n\t\t\t.on(\"error\", (e) => {\n\t\t\t\tlog.error(\"error:\", e.message)\n\t\t\t\tif (this.state.state === ConnectionState.connecting) {\n\t\t\t\t\tthis.exponentialBackoffReconnect()\n\t\t\t\t}\n\t\t\t})\n\t\t\t.end()\n\t\tthis.state = { state: ConnectionState.connecting, connection, attempt, options }\n\t}\n\n\tasync disconnect() {\n\t\tconst state = this.state\n\t\tswitch (state.state) {\n\t\t\tcase ConnectionState.delayedReconnect:\n\t\t\t\tthis.scheduler.unscheduleTimeout(state.timeout)\n\t\t\t\tthis.state = { state: ConnectionState.disconnected }\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.connected:\n\t\t\tcase ConnectionState.connecting:\n\t\t\t\treturn new Promise<void>((resolve) => {\n\t\t\t\t\tstate.connection.once(\"close\", () => {\n\t\t\t\t\t\tthis.state = { state: ConnectionState.disconnected }\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t})\n\t\t\t\t\tstate.connection.destroy()\n\t\t\t\t})\n\t\t}\n\t}\n\n\tsetEventListener(listener: SseEventHandler) {\n\t\tthis.listener = listener\n\t}\n\n\tsetReadTimeout(timeoutSeconds: number) {\n\t\tthis.readTimeoutSec = timeoutSeconds\n\t\tthis.resetHeartbeatListener()\n\t\tthis.onHeartbeat()\n\t}\n\n\tprivate exponentialBackoffReconnect() {\n\t\tif (this.state.state != ConnectionState.connecting) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: not connecting\")\n\t\t}\n\t\tlog.debug(\"Scheduling exponential reconnect\")\n\t\tconst timeout = this.scheduler.scheduleAfter(() => this.retryConnect(), this.delay.reconnectDelay(this.state.attempt))\n\t\tthis.state = { state: ConnectionState.delayedReconnect, attempt: this.state.attempt + 1, options: this.state.options, timeout }\n\t}\n\n\tprivate delayedReconnect() {\n\t\tif (this.state.state != ConnectionState.connected) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: not connected\")\n\t\t}\n\t\tlog.debug(\"Scheduling delayed reconnect\")\n\t\tconst timeout = this.scheduler.scheduleAfter(() => this.retryConnect(), this.delay.initialConnectionDelay())\n\t\tthis.state = { state: ConnectionState.delayedReconnect, attempt: 0, options: this.state.options, timeout }\n\t}\n\n\tprivate async retryConnect() {\n\t\tif (this.state.state !== ConnectionState.delayedReconnect) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: not in delayed reconnect\")\n\t\t}\n\t\tthis.doConnect(this.state.options)\n\t}\n\n\tprivate onHeartbeat() {\n\t\tif (this.state.state === ConnectionState.connected) {\n\t\t\tthis.state = { ...this.state, receivedHeartbeat: true }\n\t\t}\n\t}\n\n\tprivate resetHeartbeatListener() {\n\t\t// It will check if the heartbeat was received periodically.\n\t\t// Theoretically we need to reset this every time we connect but\n\t\t// the server will send us the timeout right after the connection anyway.\n\t\tif (this.heartBeatListenerHandle != null) this.scheduler.unschedulePeriodic(this.heartBeatListenerHandle)\n\t\tthis.heartBeatListenerHandle = this.scheduler.schedulePeriodic(async () => {\n\t\t\tconst state = this.state\n\t\t\tif (state.state === ConnectionState.connected) {\n\t\t\t\tif (state.receivedHeartbeat) {\n\t\t\t\t\tthis.state = { ...state, receivedHeartbeat: false }\n\t\t\t\t} else {\n\t\t\t\t\tawait this.disconnect()\n\t\t\t\t\tthis.doConnect(state.options)\n\t\t\t\t}\n\t\t\t}\n\t\t}, Math.floor(this.readTimeoutSec! * 1.2 * 1000))\n\t}\n}\n","import o from \"@tutao/otest\"\nimport { SseClient, SseConnectOptions, SseDelay, SseEventHandler } from \"../../../../src/common/desktop/sse/SseClient.js\"\nimport { ClientRequestOptions, DesktopNetworkClient } from \"../../../../src/common/desktop/net/DesktopNetworkClient.js\"\nimport { matchers, object, when } from \"testdouble\"\nimport http from \"node:http\"\nimport { verify } from \"@tutao/tutanota-test-utils\"\nimport { assertNotNull, defer, getFirstOrThrow } from \"@tutao/tutanota-utils\"\nimport { SchedulerMock } from \"../../TestUtils.js\"\nimport { NotAuthenticatedError, NotAuthorizedError } from \"../../../../src/common/api/common/error/RestError.js\"\n\no.spec(\"SseClient\", function () {\n\tconst defaultOptions: SseConnectOptions = Object.freeze({ url: new URL(\"http://example.com\"), headers: { header: \"headerValue\" } })\n\n\tlet sseClient: SseClient\n\tlet net: NetStub\n\tlet delay: SseDelay\n\tlet scheduler: SchedulerMock\n\tlet listener: SseEventHandler\n\n\to.beforeEach(() => {\n\t\tnet = new NetStub()\n\t\tdelay = object()\n\t\tlistener = object()\n\t\tscheduler = new SchedulerMock()\n\n\t\tsseClient = new SseClient(net as unknown as DesktopNetworkClient, delay, scheduler)\n\n\t\tsseClient.setEventListener(listener)\n\t})\n\n\to.test(\"connect passes options to net correctly\", async () => {\n\t\tawait sseClient.connect(defaultOptions)\n\t\tconst request = await net.waitForRequest()\n\t\to(request.url).deepEquals(defaultOptions.url)\n\t\to(request.opts).deepEquals({\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\tConnection: \"Keep-Alive\",\n\t\t\t\t\"Keep-Alive\": \"header\",\n\t\t\t\tAccept: \"text/event-stream\",\n\t\t\t\theader: \"headerValue\",\n\t\t\t},\n\t\t\tmethod: \"GET\",\n\t\t})\n\t})\n\n\to.spec(\"messages\", () => {\n\t\to.test(\"heartbeat does not trigger listener\", async () => {\n\t\t\tconst response = new ResponseStub()\n\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\t\t\tresponse.sendData(\"\\n\\n\")\n\n\t\t\tverify(listener.onNewMessage(matchers.anything()), { times: 0 })\n\t\t})\n\n\t\to.test(\"data message triggers listener\", async () => {\n\t\t\tconst response = new ResponseStub()\n\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\t\t\tresponse.sendData(\"data: test\\n\")\n\n\t\t\tverify(listener.onNewMessage(\"data: test\"))\n\t\t})\n\n\t\to.test(\"multiple data chunks trigger listener\", async () => {\n\t\t\tconst response = new ResponseStub()\n\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\t\t\tresponse.sendData(\"data: test1\\n\")\n\t\t\tresponse.sendData(\"data: test2\\n\")\n\n\t\t\tverify(listener.onNewMessage(\"data: test1\"))\n\t\t\tverify(listener.onNewMessage(\"data: test2\"))\n\t\t})\n\n\t\to.test(\"on notAuthenticated it notifies listener\", async () => {\n\t\t\tconst response = new ResponseStub()\n\t\t\tresponse.statusCode = NotAuthenticatedError.CODE\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\t\t\tverify(listener.onNotAuthenticated())\n\t\t})\n\n\t\to.test(\"on notAuthorized it notifies listener\", async () => {\n\t\t\tconst response = new ResponseStub()\n\t\t\tresponse.statusCode = NotAuthorizedError.CODE\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\t\t\tverify(listener.onNotAuthenticated())\n\t\t})\n\t})\n\n\to.spec(\"reconnect\", () => {\n\t\to.test(\"reconnects if response is closed\", async () => {\n\t\t\tconst response = new ResponseStub()\n\t\t\twhen(delay.initialConnectionDelay()).thenReturn(10)\n\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\n\t\t\tnet.prepareForAnotherRequest()\n\t\t\tresponse.close()\n\t\t\to(net.requests.length).equals(1)(\"Only one request is done so far, the other one is delayed\")\n\t\t\tscheduler.getThunkAfter(10)()\n\n\t\t\tawait net.waitForRequest()\n\t\t})\n\n\t\to.test(\"reconnects if response errors out\", async () => {\n\t\t\tconst response = new ResponseStub()\n\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\t\t\twhen(delay.initialConnectionDelay()).thenReturn(10)\n\n\t\t\tnet.prepareForAnotherRequest()\n\t\t\tresponse.sendError(new Error(\"test\"))\n\t\t\to(net.requests.length).equals(1)(\"Only one request is done so far, the other one is delayed\")\n\t\t\tscheduler.getThunkAfter(10)()\n\n\t\t\tawait net.waitForRequest()\n\t\t})\n\t})\n\n\to.spec(\"failing to connect\", () => {\n\t\to.test(\"on failing to connect the first time it reschedules with attempts=1\", async () => {\n\t\t\twhen(delay.reconnectDelay(1)).thenReturn(1)\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tnet.prepareForAnotherRequest()\n\t\t\tawait request.sendError(new Error(\"error1\"))\n\t\t\tscheduler.getThunkAfter(1)()\n\t\t\tawait net.waitForRequest()\n\t\t})\n\n\t\to.test(\"on failing to connect the second time it reschedules with attempts=2\", async () => {\n\t\t\twhen(delay.reconnectDelay(1)).thenReturn(1)\n\t\t\twhen(delay.reconnectDelay(2)).thenReturn(2)\n\t\t\tawait sseClient.connect(defaultOptions)\n\n\t\t\tconst request1 = await net.waitForRequest()\n\t\t\tnet.prepareForAnotherRequest()\n\t\t\tawait request1.sendError(new Error(\"error1\"))\n\t\t\tscheduler.getThunkAfter(1)()\n\n\t\t\tconst request2 = await net.waitForRequest()\n\t\t\tnet.prepareForAnotherRequest()\n\t\t\tawait request2.sendError(new Error(\"error2\"))\n\t\t\tscheduler.getThunkAfter(2)()\n\t\t\tawait net.waitForRequest()\n\t\t})\n\t})\n\n\to.spec(\"heartbeat\", () => {\n\t\to.test(\"when heartbeat is received before the heartbeat interval the connection is kept open\", async () => {\n\t\t\tsseClient.setReadTimeout(15)\n\n\t\t\tawait sseClient.connect(defaultOptions)\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tconst response = new ResponseStub()\n\t\t\tawait request.sendResponse(response)\n\t\t\tresponse.sendData(\"\\n\\n\")\n\t\t\tawait getFirstOrThrow(scheduler.getAllPeriodThunks())()\n\t\t\to(request.state).equals(\"created\")\n\t\t})\n\n\t\to.test(\"when heartbeat is not received before the heartbeat interval the connection is closed and another one open\", async () => {\n\t\t\tsseClient.setReadTimeout(15)\n\n\t\t\tawait sseClient.connect(defaultOptions)\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tconst response = new ResponseStub()\n\t\t\tawait request.sendResponse(response)\n\n\t\t\tnet.prepareForAnotherRequest()\n\n\t\t\tawait getFirstOrThrow(scheduler.getAllPeriodThunks())()\n\t\t\to(request.state).equals(\"destroyed\")\n\t\t\tawait net.waitForRequest()\n\t\t})\n\n\t\to.test(\"heartbeat is rescheduled when setReadTimeout is called\", async () => {\n\t\t\tsseClient.setReadTimeout(15)\n\t\t\tsseClient.setReadTimeout(25)\n\t\t\to(scheduler.cancelledPeriodic.size).equals(1)(\"one periodic timeout canceled\")\n\t\t\to(scheduler.getAllPeriodThunks().length).equals(2)(\"rescheduled heartbeat thunk\")\n\t\t})\n\t})\n\n\to.spec(\"external state switching\", () => {\n\t\to.test(\"should connect eventually connect if connect() is called while disconnecting\", async () => {\n\t\t\tawait sseClient.connect(defaultOptions)\n\t\t\tconst request = await net.waitForRequest()\n\t\t\t// Call disconnect, it will call destroy on the request but we will not close the connection right away\n\t\t\trequest.doNotClose()\n\t\t\t// do not wait for it\n\t\t\tsseClient.disconnect()\n\t\t\tawait request.waitForDestroy()\n\t\t\t// to actually finish close and allow another request\n\t\t\trequest.eventListeners.get(\"close\")?.()\n\n\t\t\tnet.prepareForAnotherRequest()\n\t\t\tawait sseClient.connect(defaultOptions)\n\t\t\tawait net.waitForRequest()\n\t\t})\n\n\t\to.test(\"should cancel timeouts if disconnect is called while waiting to reconnect\", async () => {\n\t\t\tawait sseClient.connect(defaultOptions)\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendError(new Error(\"test\"))\n\n\t\t\tawait sseClient.disconnect()\n\t\t\to(scheduler.cancelledAt.size).equals(1)\n\t\t})\n\n\t\to.test(\"should disconnect and use new options if connect() is called while connected\", async () => {\n\t\t\tawait sseClient.connect(defaultOptions)\n\t\t\tconst response = new ResponseStub()\n\t\t\tconst request = await net.waitForRequest()\n\t\t\tawait request.sendResponse(response)\n\n\t\t\tnet.prepareForAnotherRequest()\n\n\t\t\tconst newOptions = Object.freeze({ url: new URL(\"https://another.com\"), headers: { anotherHeader: \"anotherValue\" } })\n\t\t\tawait sseClient.connect(newOptions)\n\t\t\to(request.state).equals(\"destroyed\")\n\t\t\tconst newRequest = await net.waitForRequest()\n\t\t\to(newRequest.url).deepEquals(newOptions.url)\n\t\t\to(newRequest.opts).deepEquals({\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\tConnection: \"Keep-Alive\",\n\t\t\t\t\t\"Keep-Alive\": \"header\",\n\t\t\t\t\tAccept: \"text/event-stream\",\n\t\t\t\t\tanotherHeader: \"anotherValue\",\n\t\t\t\t},\n\t\t\t\tmethod: \"GET\",\n\t\t\t})\n\t\t})\n\t})\n})\n\nclass NetStub implements Partial<DesktopNetworkClient> {\n\tprivate requestDefer = defer<RequestStub>()\n\trequests: RequestStub[] = []\n\n\trequest(url: URL, opts: ClientRequestOptions): http.ClientRequest {\n\t\tconst requestMock = new RequestStub(url, opts)\n\t\tthis.requests.push(requestMock)\n\t\tthis.requestDefer.resolve(requestMock)\n\t\treturn requestMock as unknown as http.ClientRequest\n\t}\n\n\twaitForRequest(): Promise<RequestStub> {\n\t\treturn this.requestDefer.promise\n\t}\n\n\tprepareForAnotherRequest() {\n\t\tthis.requestDefer = defer()\n\t}\n}\n\nclass RequestStub implements Partial<http.ClientRequest> {\n\tstate: \"created\" | \"destroyed\" = \"created\"\n\teventListeners = new Map<string, (...args: any[]) => unknown>()\n\tdestroyedDefer = defer<void>()\n\tpreventClose = false\n\n\tconstructor(readonly url: URL, readonly opts: ClientRequestOptions) {}\n\n\ton(event, listener) {\n\t\tthis.eventListeners.set(event, listener)\n\t\treturn this as unknown as http.ClientRequest\n\t}\n\n\tonce(event, listener) {\n\t\tthis.eventListeners.set(event, listener)\n\t\treturn this as unknown as http.ClientRequest\n\t}\n\n\tasync sendResponse(response: ResponseStub) {\n\t\tawait assertNotNull(this.eventListeners.get(\"response\"))(response)\n\t}\n\n\tasync sendError(error: Error) {\n\t\tawait this.eventListeners.get(\"error\")!(error)\n\t}\n\n\twaitForDestroy() {\n\t\treturn this.destroyedDefer.promise\n\t}\n\n\tdestroy() {\n\t\tthis.state = \"destroyed\"\n\t\tif (!this.preventClose) {\n\t\t\tthis.eventListeners.get(\"close\")?.()\n\t\t}\n\n\t\tthis.destroyedDefer.resolve()\n\t\treturn this as unknown as http.ClientRequest\n\t}\n\n\tend() {\n\t\treturn this as unknown as http.ClientRequest\n\t}\n\n\tdoNotClose() {\n\t\tthis.preventClose = true\n\t}\n}\n\nclass ResponseStub implements Partial<http.IncomingMessage> {\n\tstatusCode: number = 200\n\teventListeners = new Map<string, (...args: any[]) => unknown>()\n\n\ton(event, listener) {\n\t\tthis.eventListeners.set(event, listener)\n\t\treturn this as unknown as http.IncomingMessage\n\t}\n\n\tsetEncoding() {\n\t\treturn this as unknown as http.IncomingMessage\n\t}\n\n\tsendData(data: string) {\n\t\tassertNotNull(this.eventListeners.get(\"data\"))(data)\n\t}\n\n\tclose() {\n\t\tthis.eventListeners.get(\"close\")?.()\n\t}\n\n\tsendError(e: Error) {\n\t\tthis.eventListeners.get(\"error\")?.()\n\t}\n}\n"],"mappings":"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"}