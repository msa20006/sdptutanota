{"version":3,"file":"MailUtils-ChhZAFAd.js","names":["folder: MailFolder","system: FolderSystem","type: Omit<MailSetKind, MailSetKind.CUSTOM>","folderSystem: FolderSystem","headers: Header","mailDetails: MailDetails"],"sources":["../../src/mail-app/mail/model/MailUtils.ts"],"sourcesContent":["import { FolderSystem, IndentedFolder } from \"../../../common/api/common/mail/FolderSystem.js\"\nimport { Header, InboxRule, Mail, MailDetails, MailFolder, TutanotaProperties } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { assertNotNull, contains, first, isNotEmpty, neverNull } from \"@tutao/tutanota-utils\"\nimport { MailModel } from \"./MailModel.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel.js\"\nimport { UserController } from \"../../../common/api/main/UserController.js\"\nimport { getEnabledMailAddressesForGroupInfo } from \"../../../common/api/common/utils/GroupUtils.js\"\nimport { MailSetKind } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { getListId, isSameId } from \"../../../common/api/common/utils/EntityUtils\"\n\nexport type FolderInfo = { level: number; folder: MailFolder }\nexport const MAX_FOLDER_INDENT_LEVEL = 10\n\nexport function getFolderName(folder: MailFolder): string {\n\tswitch (folder.folderType) {\n\t\tcase \"0\":\n\t\t\treturn folder.name\n\n\t\tcase \"1\":\n\t\t\treturn lang.get(\"received_action\")\n\n\t\tcase \"2\":\n\t\t\treturn lang.get(\"sent_action\")\n\n\t\tcase \"3\":\n\t\t\treturn lang.get(\"trash_action\")\n\n\t\tcase \"4\":\n\t\t\treturn lang.get(\"archive_label\")\n\n\t\tcase \"5\":\n\t\t\treturn lang.get(\"spam_action\")\n\n\t\tcase \"6\":\n\t\t\treturn lang.get(\"draft_action\")\n\n\t\tdefault:\n\t\t\t// do not throw an error - new system folders may cause problems\n\t\t\t//throw new Error(\"illegal folder type: \" + this.folder.getFolderType())\n\t\t\treturn \"\"\n\t}\n}\n\nexport function getIndentedFolderNameForDropdown(folderInfo: FolderInfo) {\n\tconst indentLevel = Math.min(folderInfo.level, MAX_FOLDER_INDENT_LEVEL)\n\treturn \". \".repeat(indentLevel) + getFolderName(folderInfo.folder)\n}\n\nexport async function getMoveTargetFolderSystems(foldersModel: MailModel, mails: readonly Mail[]): Promise<Array<FolderInfo>> {\n\tconst firstMail = first(mails)\n\tif (firstMail == null) return []\n\n\tconst mailboxDetails = await foldersModel.getMailboxDetailsForMail(firstMail)\n\tif (mailboxDetails == null || mailboxDetails.mailbox.folders == null) {\n\t\treturn []\n\t}\n\n\tconst folders = await foldersModel.getMailboxFoldersForId(mailboxDetails.mailbox.folders._id)\n\tif (folders == null) {\n\t\treturn []\n\t}\n\tconst folderOfFirstMail = foldersModel.getMailFolderForMail(firstMail)\n\tif (folderOfFirstMail == null) {\n\t\treturn []\n\t}\n\n\tconst areMailsInDifferentFolders =\n\t\tmails.length > 1 &&\n\t\tmails.some((mail) => {\n\t\t\treturn !isSameId(folderOfFirstMail._id, assertNotNull(foldersModel.getMailFolderForMail(mail))._id)\n\t\t})\n\n\tif (areMailsInDifferentFolders) {\n\t\treturn folders.getIndentedList()\n\t} else {\n\t\treturn folders.getIndentedList().filter((f: IndentedFolder) => {\n\t\t\tif (f.folder.isMailSet && isNotEmpty(firstMail.sets)) {\n\t\t\t\treturn !isSameId(f.folder._id, folderOfFirstMail._id)\n\t\t\t} else {\n\t\t\t\treturn f.folder.mails !== getListId(firstMail)\n\t\t\t}\n\t\t})\n\t}\n}\n\n/**\n * Gets a system folder of the specified type and unwraps it.\n * Some system folders don't exist in some cases, e.g. spam or archive for external mailboxes!\n *\n * Use with caution.\n */\nexport function assertSystemFolderOfType(system: FolderSystem, type: Omit<MailSetKind, MailSetKind.CUSTOM>): MailFolder {\n\treturn assertNotNull(system.getSystemFolderByType(type), \"System folder of type does not exist!\")\n}\n\nexport function getPathToFolderString(folderSystem: FolderSystem, folder: MailFolder, omitLast = false) {\n\tconst folderPath = folderSystem.getPathToFolder(folder._id)\n\tif (omitLast) {\n\t\tfolderPath.pop()\n\t}\n\treturn folderPath.map(getFolderName).join(\" Â· \")\n}\n\nexport function getMailHeaders(headers: Header): string {\n\treturn headers.compressedHeaders ?? headers.headers ?? \"\"\n}\n\nexport async function loadMailHeaders(mailDetails: MailDetails): Promise<string | null> {\n\treturn mailDetails.headers != null ? getMailHeaders(mailDetails.headers) : null\n}\n\nexport function getExistingRuleForType(props: TutanotaProperties, cleanValue: string, type: string): InboxRule | null {\n\treturn props.inboxRules.find((rule) => type === rule.type && cleanValue === rule.value) ?? null\n}\n\n/**\n * @return {string} default mail address\n */\nexport function getDefaultSenderFromUser({ props, userGroupInfo }: UserController): string {\n\treturn props.defaultSender && contains(getEnabledMailAddressesForGroupInfo(userGroupInfo), props.defaultSender)\n\t\t? props.defaultSender\n\t\t: neverNull(userGroupInfo.mailAddress)\n}\n\nexport function allInSameMailbox(mails: readonly Mail[]): boolean {\n\tconst mailGroups = mails.map((m) => m._ownerGroup)\n\treturn mailGroups.every((mg) => mg === mailGroups[0])\n\t// returns true if mails is empty\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaO,SAAS,cAAcA,QAA4B;AACzD,SAAQ,OAAO,YAAf;AACC,OAAK,IACJ,QAAO,OAAO;AAEf,OAAK,IACJ,QAAO,KAAK,IAAI,kBAAkB;AAEnC,OAAK,IACJ,QAAO,KAAK,IAAI,cAAc;AAE/B,OAAK,IACJ,QAAO,KAAK,IAAI,eAAe;AAEhC,OAAK,IACJ,QAAO,KAAK,IAAI,gBAAgB;AAEjC,OAAK,IACJ,QAAO,KAAK,IAAI,cAAc;AAE/B,OAAK,IACJ,QAAO,KAAK,IAAI,eAAe;AAEhC,UAGC,QAAO;CACR;AACD;AAkDM,SAAS,yBAAyBC,QAAsBC,MAAyD;AACvH,QAAO,cAAc,OAAO,sBAAsB,KAAK,EAAE,wCAAwC;AACjG;AAEM,SAAS,sBAAsBC,cAA4BH,QAAoB,WAAW,OAAO;CACvG,MAAM,aAAa,aAAa,gBAAgB,OAAO,IAAI;AAC3D,KAAI,SACH,YAAW,KAAK;AAEjB,QAAO,WAAW,IAAI,cAAc,CAAC,KAAK,MAAM;AAChD;AAEM,SAAS,eAAeI,SAAyB;AACvD,QAAO,QAAQ,qBAAqB,QAAQ,WAAW;AACvD;AAEM,eAAe,gBAAgBC,aAAkD;AACvF,QAAO,YAAY,WAAW,OAAO,eAAe,YAAY,QAAQ,GAAG;AAC3E"}