{"version":3,"file":"ListModel-jYF3dysm.js","names":["config: ListModelConfig<ItemType, IdType>","acc: ReadonlySet<ItemType>","state: ListState<ItemType>","Stream","newStatePart: Partial<PrivateListState<ItemType>>","status: ListLoadingState","newItems: ReadonlyArray<ItemType>","filter: ListFilter<ItemType> | null","item: ItemType","clearSelectionOnMultiSelectStart?: boolean","finder: (item: ItemType) => boolean","shouldStop: () => boolean","foundItem: ItemType | undefined","clickedItemIndex: number","nearestSelectedIndex: number | null","itemsToAddToSelection: ItemType[]","multiselect: boolean","oldActiveItem: ItemType | null","lastItem: ItemType | null | undefined","itemId: IdType","state: PrivateListState<ItemType>","what: () => any","item1: ItemType","item2: ItemType","entity: ItemType","listModel: Pick<ListModel<ItemType, IdType>, \"areAllSelected\" | \"selectNone\" | \"selectAll\"> | null"],"sources":["../../src/common/misc/ListModel.ts"],"sourcesContent":["import { ListLoadingState, ListState } from \"../gui/base/List.js\"\nimport {\n\tassertNonNull,\n\tbinarySearch,\n\tdefer,\n\tfindBy,\n\tfindLast,\n\tfirst,\n\tgetFirstOrThrow,\n\tlast,\n\tlastThrow,\n\tmemoizedWithHiddenArgument,\n\tremove,\n\tsetAddAll,\n\tsetEquals,\n\tsetMap,\n\tsettledThen,\n} from \"@tutao/tutanota-utils\"\nimport Stream from \"mithril/stream\"\nimport stream from \"mithril/stream\"\nimport { ListFetchResult, PageSize } from \"../gui/base/ListUtils.js\"\nimport { isOfflineError } from \"../api/common/utils/ErrorUtils.js\"\nimport { ListAutoSelectBehavior } from \"./DeviceConfig.js\"\n\n/**\n * Specifies methods for retrieving items, fetching items, and comparing items for a ListModel.\n */\nexport interface ListModelConfig<ItemType, IdType> {\n\t/**\n\t * Get the given number of entities starting after the given id. May return more items than requested, e.g. if all items are available on first fetch.\n\t */\n\tfetch(lastFetchedItem: ItemType | null | undefined, count: number): Promise<ListFetchResult<ItemType>>\n\n\t/**\n\t * Compare the items\n\t * @return 0 if equal, less than 0 if less and greater than 0 if greater\n\t */\n\tsortCompare(item1: ItemType, item2: ItemType): number\n\n\t/**\n\t * @return the ID of the item\n\t */\n\tgetItemId(item: ItemType): IdType\n\n\t/**\n\t * @return true if the IDs are the same\n\t */\n\tisSameId(id1: IdType, id2: IdType): boolean\n\n\tautoSelectBehavior: () => ListAutoSelectBehavior\n}\n\nexport type ListFilter<ItemType> = (item: ItemType) => boolean\n\ntype PrivateListState<ItemType> = Omit<ListState<ItemType>, \"items\" | \"activeIndex\"> & {\n\tunfilteredItems: ItemType[]\n\tfilteredItems: ItemType[]\n\tactiveItem: ItemType | null\n}\n\n/** ListModel that does the state upkeep for the List, including loading state, loaded items, selection and filters*/\nexport class ListModel<ItemType, IdType> {\n\tconstructor(private readonly config: ListModelConfig<ItemType, IdType>) {}\n\n\tprivate loadState: \"created\" | \"initialized\" = \"created\"\n\tprivate loading: Promise<unknown> = Promise.resolve()\n\tprivate filter: ListFilter<ItemType> | null = null\n\tprivate rangeSelectionAnchorItem: ItemType | null = null\n\n\tget state(): ListState<ItemType> {\n\t\treturn this.stateStream()\n\t}\n\n\tprivate get rawState(): PrivateListState<ItemType> {\n\t\treturn this.rawStateStream()\n\t}\n\n\tprivate defaultRawStateStream: PrivateListState<ItemType> = {\n\t\tunfilteredItems: [],\n\t\tfilteredItems: [],\n\t\tinMultiselect: false,\n\t\tloadingStatus: ListLoadingState.Idle,\n\t\tloadingAll: false,\n\t\tselectedItems: new Set(),\n\t\tactiveItem: null,\n\t}\n\tprivate rawStateStream: Stream<PrivateListState<ItemType>> = stream(this.defaultRawStateStream)\n\n\treadonly stateStream: Stream<ListState<ItemType>> = this.rawStateStream.map((state) => {\n\t\tconst activeItem = state.activeItem\n\t\tconst foundIndex = activeItem ? binarySearch(state.filteredItems, activeItem, (l, r) => this.config.sortCompare(l, r)) : -1\n\t\tconst activeIndex = foundIndex < 0 ? null : foundIndex\n\t\treturn { ...state, items: state.filteredItems, activeIndex }\n\t})\n\n\treadonly differentItemsSelected: Stream<ReadonlySet<ItemType>> = Stream.scan(\n\t\t(acc: ReadonlySet<ItemType>, state: ListState<ItemType>) => {\n\t\t\tconst newSelectedIds = setMap(state.selectedItems, (item) => this.config.getItemId(item))\n\t\t\tconst oldSelectedIds = setMap(acc, (item) => this.config.getItemId(item))\n\t\t\tif (setEquals(oldSelectedIds, newSelectedIds)) {\n\t\t\t\t// Stream.scan type definitions does not take it into account\n\t\t\t\treturn Stream.SKIP as unknown as ReadonlySet<ItemType>\n\t\t\t} else {\n\t\t\t\treturn state.selectedItems\n\t\t\t}\n\t\t},\n\t\tnew Set(),\n\t\tthis.stateStream,\n\t)\n\n\tprivate updateState(newStatePart: Partial<PrivateListState<ItemType>>) {\n\t\tthis.rawStateStream({ ...this.rawState, ...newStatePart })\n\t}\n\n\tprivate waitUtilInit(): Promise<unknown> {\n\t\tconst deferred = defer()\n\t\tconst subscription = this.rawStateStream.map(() => {\n\t\t\tif (this.loadState === \"initialized\") {\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tsubscription.end(true)\n\t\t\t\t\tdeferred.resolve(undefined)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\treturn deferred.promise\n\t}\n\n\tasync loadInitial() {\n\t\tif (this.loadState !== \"created\") {\n\t\t\treturn\n\t\t}\n\t\tthis.loadState = \"initialized\"\n\t\tawait this.doLoad()\n\t}\n\n\tasync loadMore() {\n\t\tif (this.rawState.loadingStatus === ListLoadingState.Loading) {\n\t\t\treturn this.loading\n\t\t}\n\t\tif (this.loadState !== \"initialized\" || this.rawState.loadingStatus !== ListLoadingState.Idle) {\n\t\t\treturn\n\t\t}\n\t\tawait this.doLoad()\n\t}\n\n\tasync retryLoading() {\n\t\tif (this.loadState !== \"initialized\" || this.rawState.loadingStatus !== ListLoadingState.ConnectionLost) {\n\t\t\treturn\n\t\t}\n\t\tawait this.doLoad()\n\t}\n\n\tupdateLoadingStatus(status: ListLoadingState) {\n\t\tif (this.rawState.loadingStatus === status) return\n\n\t\tthis.updateState({ loadingStatus: status })\n\t}\n\n\tprivate async doLoad() {\n\t\tthis.updateLoadingStatus(ListLoadingState.Loading)\n\t\tthis.loading = Promise.resolve().then(async () => {\n\t\t\tconst lastFetchedItem = last(this.rawState.unfilteredItems)\n\t\t\ttry {\n\t\t\t\tconst { items: newItems, complete } = await this.config.fetch(lastFetchedItem, PageSize)\n\t\t\t\t// if the loading was cancelled in the meantime, don't insert anything so that it's not confusing\n\t\t\t\tif (this.state.loadingStatus === ListLoadingState.ConnectionLost) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst newUnfilteredItems = [...this.rawState.unfilteredItems, ...newItems]\n\t\t\t\tnewUnfilteredItems.sort(this.config.sortCompare)\n\n\t\t\t\tconst newFilteredItems = [...this.rawState.filteredItems, ...this.applyFilter(newItems)]\n\t\t\t\tnewFilteredItems.sort(this.config.sortCompare)\n\n\t\t\t\tconst loadingStatus = complete ? ListLoadingState.Done : ListLoadingState.Idle\n\t\t\t\tthis.updateState({ loadingStatus, unfilteredItems: newUnfilteredItems, filteredItems: newFilteredItems })\n\t\t\t} catch (e) {\n\t\t\t\tthis.updateLoadingStatus(ListLoadingState.ConnectionLost)\n\t\t\t\tif (!isOfflineError(e)) {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\treturn this.loading\n\t}\n\n\tprivate applyFilter(newItems: ReadonlyArray<ItemType>): Array<ItemType> {\n\t\treturn newItems.filter(this.filter ?? (() => true))\n\t}\n\n\tsetFilter(filter: ListFilter<ItemType> | null) {\n\t\tthis.filter = filter\n\t\tthis.reapplyFilter()\n\t}\n\n\treapplyFilter() {\n\t\tconst newFilteredItems = this.applyFilter(this.rawState.unfilteredItems)\n\n\t\tconst newSelectedItems = new Set(this.applyFilter([...this.state.selectedItems]))\n\n\t\tthis.updateState({ filteredItems: newFilteredItems, selectedItems: newSelectedItems })\n\t}\n\n\tonSingleSelection(item: ItemType): void {\n\t\tthis.updateState({ selectedItems: new Set([item]), inMultiselect: false, activeItem: item })\n\t\tthis.rangeSelectionAnchorItem = item\n\t}\n\n\t/** An item was added to the selection. If multiselect was not on, discard previous single selection and only added selected item to the selection. */\n\tonSingleExclusiveSelection(item: ItemType): void {\n\t\tif (!this.rawState.inMultiselect) {\n\t\t\tthis.updateState({ selectedItems: new Set([item]), inMultiselect: true, activeItem: item })\n\t\t\tthis.rangeSelectionAnchorItem = item\n\t\t} else {\n\t\t\tconst selectedItems = new Set(this.state.selectedItems)\n\t\t\tif (selectedItems.has(item)) {\n\t\t\t\tselectedItems.delete(item)\n\t\t\t} else {\n\t\t\t\tselectedItems.add(item)\n\t\t\t}\n\t\t\tif (selectedItems.size === 0) {\n\t\t\t\tthis.updateState({ selectedItems, inMultiselect: false, activeItem: null })\n\t\t\t\tthis.rangeSelectionAnchorItem = null\n\t\t\t} else {\n\t\t\t\tthis.updateState({ selectedItems, inMultiselect: true, activeItem: item })\n\t\t\t\tthis.rangeSelectionAnchorItem = item\n\t\t\t}\n\t\t}\n\t}\n\n\t/** An item was added to the selection. If multiselect was not on, add previous single selection and newly added selected item to the selection. */\n\tonSingleInclusiveSelection(item: ItemType, clearSelectionOnMultiSelectStart?: boolean): void {\n\t\t// If it isn't in MultiSelect, we discard all previous items\n\t\t// and start a new set of selected items in MultiSelect mode\n\t\t// we do it only if the user is on singleColumnMode, because\n\t\t// there are different expected behaviors there\n\t\tif (!this.state.inMultiselect && clearSelectionOnMultiSelectStart) {\n\t\t\tthis.selectNone()\n\t\t}\n\n\t\tconst selectedItems = new Set(this.state.selectedItems)\n\n\t\tif (this.state.inMultiselect && selectedItems.has(item)) {\n\t\t\tselectedItems.delete(item)\n\t\t} else {\n\t\t\tselectedItems.add(item)\n\t\t}\n\n\t\tif (selectedItems.size === 0) {\n\t\t\tthis.updateState({ selectedItems, inMultiselect: false, activeItem: null })\n\t\t\tthis.rangeSelectionAnchorItem = null\n\t\t} else {\n\t\t\tthis.updateState({ selectedItems, inMultiselect: true, activeItem: item })\n\t\t\tthis.rangeSelectionAnchorItem = item\n\t\t}\n\t}\n\n\tasync loadAndSelect(finder: (item: ItemType) => boolean, shouldStop: () => boolean): Promise<ItemType | null> {\n\t\tawait this.waitUtilInit()\n\t\tlet foundItem: ItemType | undefined = undefined\n\t\twhile (\n\t\t\t// if we did find the target mail, stop\n\t\t\t// make sure to call this before shouldStop or we might stop before trying to find an item\n\t\t\t// this can probably be optimized to be binary search in most (all?) cases\n\t\t\t!(foundItem = this.rawState.unfilteredItems.find(finder)) &&\n\t\t\t!shouldStop() &&\n\t\t\t// if we are done loading, stop\n\t\t\tthis.rawState.loadingStatus !== ListLoadingState.Done &&\n\t\t\t// if we are offline, stop\n\t\t\tthis.rawState.loadingStatus !== ListLoadingState.ConnectionLost\n\t\t) {\n\t\t\tawait this.loadMore()\n\t\t}\n\t\tif (foundItem) {\n\t\t\tthis.onSingleSelection(foundItem)\n\t\t}\n\t\treturn foundItem ?? null\n\t}\n\n\tselectRangeTowards(item: ItemType): void {\n\t\tconst selectedItems = new Set(this.state.selectedItems)\n\t\tif (selectedItems.size === 0) {\n\t\t\tselectedItems.add(item)\n\t\t} else {\n\t\t\t// we are trying to find the item that's closest to the clicked one\n\t\t\t// and after that we will select everything between the closest and the clicked one\n\n\t\t\tconst clickedItemIndex: number = this.state.items.indexOf(item)\n\t\t\tlet nearestSelectedIndex: number | null = null\n\n\t\t\t// find absolute min based on the distance (closest)\n\t\t\tfor (const selectedItem of selectedItems) {\n\t\t\t\tconst currentSelectedItemIndex = this.state.items.indexOf(selectedItem)\n\n\t\t\t\tif (nearestSelectedIndex == null || Math.abs(clickedItemIndex - currentSelectedItemIndex) < Math.abs(clickedItemIndex - nearestSelectedIndex)) {\n\t\t\t\t\tnearestSelectedIndex = currentSelectedItemIndex\n\t\t\t\t}\n\t\t\t}\n\t\t\tassertNonNull(nearestSelectedIndex)\n\n\t\t\tconst itemsToAddToSelection: ItemType[] = []\n\n\t\t\tif (nearestSelectedIndex < clickedItemIndex) {\n\t\t\t\tfor (let i = nearestSelectedIndex + 1; i <= clickedItemIndex; i++) {\n\t\t\t\t\titemsToAddToSelection.push(this.state.items[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = clickedItemIndex; i < nearestSelectedIndex; i++) {\n\t\t\t\t\titemsToAddToSelection.push(this.state.items[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetAddAll(selectedItems, itemsToAddToSelection)\n\t\t}\n\t\tthis.updateState({ selectedItems, inMultiselect: true, activeItem: item })\n\t\tthis.rangeSelectionAnchorItem = item\n\t}\n\n\tselectPrevious(multiselect: boolean) {\n\t\tconst oldActiveItem = this.rawState.activeItem\n\t\tconst newActiveItem = this.getPreviousItem(oldActiveItem)\n\n\t\tif (newActiveItem != null) {\n\t\t\tif (!multiselect) {\n\t\t\t\tthis.onSingleSelection(newActiveItem)\n\t\t\t} else {\n\t\t\t\tconst selectedItems = new Set(this.state.selectedItems)\n\t\t\t\tthis.rangeSelectionAnchorItem = this.rangeSelectionAnchorItem ?? first(this.state.items)\n\t\t\t\tif (!this.rangeSelectionAnchorItem) return\n\n\t\t\t\tconst previousActiveIndex = this.state.activeIndex ?? 0\n\t\t\t\tconst towardsAnchor = this.config.sortCompare(oldActiveItem ?? getFirstOrThrow(this.state.items), this.rangeSelectionAnchorItem) > 0\n\t\t\t\tif (towardsAnchor) {\n\t\t\t\t\t// remove\n\t\t\t\t\tselectedItems.delete(this.state.items[previousActiveIndex])\n\t\t\t\t} else {\n\t\t\t\t\t// add\n\t\t\t\t\tselectedItems.add(newActiveItem)\n\t\t\t\t}\n\n\t\t\t\tthis.updateState({ activeItem: newActiveItem, selectedItems, inMultiselect: true })\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getPreviousItem(oldActiveItem: ItemType | null) {\n\t\treturn oldActiveItem == null\n\t\t\t? first(this.state.items)\n\t\t\t: findLast(this.state.items, (item) => this.config.sortCompare(item, oldActiveItem) < 0) ?? first(this.state.items)\n\t}\n\n\tselectNext(multiselect: boolean) {\n\t\tconst oldActiveItem = this.rawState.activeItem\n\t\tconst lastItem = last(this.state.items)\n\t\tconst newActiveItem = this.getNextItem(oldActiveItem, lastItem)\n\n\t\tif (newActiveItem != null) {\n\t\t\tif (!multiselect) {\n\t\t\t\tthis.onSingleSelection(newActiveItem)\n\t\t\t} else {\n\t\t\t\tconst selectedItems = new Set(this.state.selectedItems)\n\t\t\t\tthis.rangeSelectionAnchorItem = this.rangeSelectionAnchorItem ?? first(this.state.items)\n\t\t\t\tif (!this.rangeSelectionAnchorItem) return\n\n\t\t\t\tconst previousActiveIndex = this.state.activeIndex ?? 0\n\t\t\t\tconst towardsAnchor = this.config.sortCompare(oldActiveItem ?? getFirstOrThrow(this.state.items), this.rangeSelectionAnchorItem) < 0\n\t\t\t\tif (towardsAnchor) {\n\t\t\t\t\tselectedItems.delete(this.state.items[previousActiveIndex])\n\t\t\t\t} else {\n\t\t\t\t\tselectedItems.add(newActiveItem)\n\t\t\t\t}\n\t\t\t\tthis.updateState({ selectedItems, inMultiselect: true, activeItem: newActiveItem })\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getNextItem(oldActiveItem: ItemType | null, lastItem: ItemType | null | undefined) {\n\t\treturn oldActiveItem == null\n\t\t\t? first(this.state.items)\n\t\t\t: lastItem && this.config.sortCompare(lastItem, oldActiveItem) <= 0\n\t\t\t? lastItem\n\t\t\t: this.state.items.find((item) => this.config.sortCompare(item, oldActiveItem) > 0) ?? first(this.state.items)\n\t}\n\n\tareAllSelected(): boolean {\n\t\treturn this.rawState.inMultiselect && this.state.selectedItems.size === this.state.items.length\n\t}\n\n\tselectAll() {\n\t\tthis.updateState({ selectedItems: new Set(this.state.items), activeItem: null, inMultiselect: true })\n\t\tthis.rangeSelectionAnchorItem = null\n\t}\n\n\tselectNone() {\n\t\tthis.rangeSelectionAnchorItem = null\n\t\tthis.updateState({ selectedItems: new Set<ItemType>(), inMultiselect: false })\n\t}\n\n\tisItemSelected(itemId: IdType): boolean {\n\t\treturn findBy(this.state.selectedItems, (item: ItemType) => this.config.isSameId(this.config.getItemId(item), itemId)) != null\n\t}\n\n\treadonly getSelectedAsArray: () => Array<ItemType> = memoizedWithHiddenArgument(\n\t\t() => this.state,\n\t\t(state: ListState<ItemType>) => [...state.selectedItems],\n\t)\n\n\treadonly isSelectionEmpty: () => boolean = memoizedWithHiddenArgument(\n\t\t() => this.state,\n\t\t(state: ListState<ItemType>) => state.selectedItems.size === 0,\n\t)\n\n\treadonly getUnfilteredAsArray: () => Array<ItemType> = memoizedWithHiddenArgument(\n\t\t() => this.rawState,\n\t\t(state: PrivateListState<ItemType>) => [...state.unfilteredItems],\n\t)\n\n\tenterMultiselect() {\n\t\t// avoid having the viewed item as a preselected one which might be confusing.\n\t\tthis.selectNone()\n\t\tthis.updateState({ inMultiselect: true })\n\t}\n\n\tsort() {\n\t\tconst filteredItems = this.rawState.filteredItems.slice().sort(this.config.sortCompare)\n\t\tconst unfilteredItems = this.rawState.filteredItems.slice().sort(this.config.sortCompare)\n\t\tthis.updateState({ filteredItems, unfilteredItems })\n\t}\n\n\tisLoadedCompletely(): boolean {\n\t\treturn this.rawState.loadingStatus === ListLoadingState.Done\n\t}\n\n\tcancelLoadAll() {\n\t\tif (this.state.loadingAll) {\n\t\t\tthis.updateState({ loadingAll: false })\n\t\t}\n\t}\n\n\tasync loadAll() {\n\t\tif (this.rawState.loadingAll) return\n\n\t\tthis.updateState({ loadingAll: true })\n\n\t\ttry {\n\t\t\twhile (this.rawState.loadingAll && !this.isLoadedCompletely()) {\n\t\t\t\tawait this.loadMore()\n\t\t\t\tthis.selectAll()\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.cancelLoadAll()\n\t\t}\n\t}\n\n\tisEmptyAndDone(): boolean {\n\t\treturn this.state.items.length === 0 && this.state.loadingStatus === ListLoadingState.Done\n\t}\n\n\tstopLoading() {\n\t\tif (this.state.loadingStatus === ListLoadingState.Loading) {\n\t\t\t// We can't really cancel ongoing requests, but we can prevent more requests from happening\n\t\t\tthis.updateState({ loadingStatus: ListLoadingState.ConnectionLost })\n\t\t}\n\t}\n\n\twaitLoad(what: () => any): Promise<any> {\n\t\treturn settledThen(this.loading, what)\n\t}\n\n\tinsertLoadedItem(item: ItemType) {\n\t\tif (this.rawState.unfilteredItems.some((unfilteredItem) => this.hasSameId(unfilteredItem, item))) {\n\t\t\treturn\n\t\t}\n\n\t\t// can we do something like binary search?\n\t\tconst unfilteredItems = this.rawState.unfilteredItems.concat(item).sort(this.config.sortCompare)\n\t\tconst filteredItems = this.rawState.filteredItems.concat(this.applyFilter([item])).sort(this.config.sortCompare)\n\t\tthis.updateState({ filteredItems, unfilteredItems })\n\t}\n\n\tupdateLoadedItem(item: ItemType) {\n\t\t// We cannot use binary search here because the sort order of items can change based on an entity update, and we need to find the position of the\n\t\t// old entity by id in order to remove it.\n\n\t\t// Since every item id is unique and there's no scenario where the same item appears twice but in different lists, we can safely sort just\n\t\t// by the item id, ignoring the list id\n\n\t\t// update unfiltered list: find the position, take out the old item and put the updated one\n\t\tconst positionToUpdateUnfiltered = this.rawState.unfilteredItems.findIndex((unfilteredItem) => this.hasSameId(unfilteredItem, item))\n\t\tconst unfilteredItems = this.rawState.unfilteredItems.slice()\n\t\tif (positionToUpdateUnfiltered >= 0) {\n\t\t\tunfilteredItems.splice(positionToUpdateUnfiltered, 1, item)\n\t\t\tunfilteredItems.sort(this.config.sortCompare)\n\t\t}\n\n\t\t// update filtered list & selected items\n\t\tconst positionToUpdateFiltered = this.rawState.filteredItems.findIndex((filteredItem) => this.hasSameId(filteredItem, item))\n\t\tconst filteredItems = this.rawState.filteredItems.slice()\n\t\tconst selectedItems = new Set(this.rawState.selectedItems)\n\t\tif (positionToUpdateFiltered >= 0) {\n\t\t\tconst [oldItem] = filteredItems.splice(positionToUpdateFiltered, 1, item)\n\t\t\tfilteredItems.sort(this.config.sortCompare)\n\t\t\tif (selectedItems.delete(oldItem)) {\n\t\t\t\tselectedItems.add(item)\n\t\t\t}\n\t\t}\n\n\t\t// keep active item up-to-date\n\t\tconst activeItemUpdated = this.rawState.activeItem != null && this.hasSameId(this.rawState.activeItem, item)\n\t\tconst newActiveItem = this.rawState.activeItem\n\n\t\tif (positionToUpdateUnfiltered !== -1 || positionToUpdateFiltered !== -1 || activeItemUpdated) {\n\t\t\tthis.updateState({ unfilteredItems, filteredItems, selectedItems, activeItem: newActiveItem })\n\t\t}\n\n\t\t// keep anchor up-to-date\n\t\tif (this.rangeSelectionAnchorItem != null && this.hasSameId(this.rangeSelectionAnchorItem, item)) {\n\t\t\tthis.rangeSelectionAnchorItem = item\n\t\t}\n\t}\n\n\tdeleteLoadedItem(itemId: IdType): Promise<void> {\n\t\treturn settledThen(this.loading, () => {\n\t\t\tconst item = this.rawState.filteredItems.find((e) => this.config.isSameId(this.config.getItemId(e), itemId))\n\n\t\t\tconst selectedItems = new Set(this.rawState.selectedItems)\n\n\t\t\tlet newActiveItem\n\n\t\t\tif (item) {\n\t\t\t\tconst wasRemoved = selectedItems.delete(item)\n\n\t\t\t\tif (this.rawState.filteredItems.length > 1) {\n\t\t\t\t\tconst desiredBehavior = this.config.autoSelectBehavior?.() ?? null\n\t\t\t\t\tif (wasRemoved) {\n\t\t\t\t\t\tif (desiredBehavior === ListAutoSelectBehavior.NONE || this.state.inMultiselect) {\n\t\t\t\t\t\t\tselectedItems.clear()\n\t\t\t\t\t\t} else if (desiredBehavior === ListAutoSelectBehavior.NEWER) {\n\t\t\t\t\t\t\tnewActiveItem = this.getPreviousItem(item)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewActiveItem = item === last(this.state.items) ? this.getPreviousItem(item) : this.getNextItem(item, null)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newActiveItem) {\n\t\t\t\t\t\tselectedItems.add(newActiveItem)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewActiveItem = this.rawState.activeItem\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst filteredItems = this.rawState.filteredItems.slice()\n\t\t\t\tremove(filteredItems, item)\n\t\t\t\tconst unfilteredItems = this.rawState.unfilteredItems.slice()\n\t\t\t\tremove(unfilteredItems, item)\n\t\t\t\tthis.updateState({ filteredItems, selectedItems, unfilteredItems, activeItem: newActiveItem })\n\t\t\t}\n\t\t})\n\t}\n\n\tgetLastItem(): ItemType | null {\n\t\tif (this.rawState.unfilteredItems.length > 0) {\n\t\t\treturn lastThrow(this.rawState.unfilteredItems)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tprivate hasSameId(item1: ItemType, item2: ItemType): boolean {\n\t\tconst id1 = this.config.getItemId(item1)\n\t\tconst id2 = this.config.getItemId(item2)\n\t\treturn this.config.isSameId(id1, id2)\n\t}\n\n\tcanInsertItem(entity: ItemType): boolean {\n\t\tif (this.state.loadingStatus === ListLoadingState.Done) {\n\t\t\treturn true\n\t\t}\n\n\t\t// new element is in the loaded range or newer than the first element\n\t\tconst lastElement = this.getLastItem()\n\t\treturn lastElement != null && this.config.sortCompare(entity, lastElement) < 0\n\t}\n}\n\nexport function selectionAttrsForList<ItemType, IdType>(listModel: Pick<ListModel<ItemType, IdType>, \"areAllSelected\" | \"selectNone\" | \"selectAll\"> | null) {\n\treturn {\n\t\tselected: listModel?.areAllSelected() ?? false,\n\t\tselectNone: () => listModel?.selectNone(),\n\t\tselectAll: () => listModel?.selectAll(),\n\t}\n}\n"],"mappings":"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"}