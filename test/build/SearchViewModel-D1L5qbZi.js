
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { LazyLoaded, TypeRef, YEAR_IN_MILLIS, assertNotNull, deepEqual, defer, downcast, getEndOfDay, getStartOfDay, incrementMonth, isSameDayOfDate, isSameTypeRef, neverNull, ofClass, stringToBase64 } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertMainOrNode } from "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import "./LanguageViewModel-BNC5ekpO.js";
import { isColorLight, px, size, theme } from "./HtmlUtils-C-ecR7U7.js";
import "./ClientDetector-D0v6Vqu6.js";
import { CLIENT_ONLY_CALENDARS, FULL_INDEXED_TIMESTAMP, MailSetKind, NOTHING_INDEXED_TIMESTAMP, OperationType } from "./TutanotaConstants-3bwAESYA.js";
import "./Icon-BuqNK7vz.js";
import "./Icons-Dl3nFav5.js";
import "./KeyManager-B0OGXEyJ.js";
import "./WindowFacade-B9kSBKw7.js";
import "./Modal-g4c-b9IU.js";
import { colorForBg, pureComponent } from "./Dialog-B6-HFvZd.js";
import "./CountryList-DkVQtcTj.js";
import "./IconButton-DsU60HJ_.js";
import { NotFoundError } from "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import { require_stream } from "./stream-u2PttBAC.js";
import "./luxon-D6cgmg6Q.js";
import "./CalendarEventWhenModel-DEedSoEH.js";
import { GENERATED_MAX_ID, assertIsEntity, assertIsEntity2, elementIdPart, getElementId, isSameId, listIdPart, sortCompareByReverseId } from "./EntityUtils-RQxXZlcV.js";
import "./CommonCalendarUtils-DKaO7v1K.js";
import "./Formatter-zB15D6XI.js";
import "./TypeModels-XIXYys8J.js";
import { CalendarEventTypeRef, ContactTypeRef, MailTypeRef } from "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import "./TypeRefs-BP1jvX9p.js";
import { generateCalendarInstancesInRange, getStartOfTheWeekOffsetForUser, retrieveClientOnlyEventsForUser } from "./CalendarUtils-C6jeYrj9.js";
import "./ProgressMonitor-HBfOF56H.js";
import "./Notifications-DLibQbV7.js";
import "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import { loadMultipleFromLists } from "./EntityClient-B0RSdk2i.js";
import "./SetupMultipleError-B6uY8P-x.js";
import "./dist-DcZ1Y4qd.js";
import "./Services-CZFE0084.js";
import "./Services-DCx-CeM7.js";
import "./CalendarFacade-CaovxyFN.js";
import "./CalendarModel-DK762b35.js";
import { containsEventOfType, getEventOfType, isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import "./GroupUtils-CpT2lvVS.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import "./ImportExportUtils-B1MoOmZ0.js";
import "./FormatValidator-2BBermUe.js";
import "./UserError-DfXlMLTl.js";
import "./MailAddressParser-BgYy6oyp.js";
import "./GroupUtils-0ZkLIAeC.js";
import "./DataFile-CY7uuk9j.js";
import "./FileUtils-W-u2-gZz.js";
import "./ProgressDialog-CJfJjh62.js";
import "./BlobUtils-D5ADcckZ.js";
import "./SharedMailUtils-AmFaSJP6.js";
import "./PasswordUtils-C4jlV9GF.js";
import "./Recipient-BFxhfecW.js";
import "./BirthdayUtils-BcCMglSq.js";
import "./ContactUtils-Bbon2oOk.js";
import "./RecipientsModel-DxwXuUvL.js";
import { getClientOnlyCalendars } from "./CalendarGuiUtils-CkzhFM1K.js";
import "./UpgradeRequiredError-CbZr7beN.js";
import "./ColorPickerModel-C1q3CWkL.js";
import "./SubscriptionDialogs-DAlWs68I.js";
import "./ExternalLink-rsCBSC7U.js";
import "./ToggleButton-DxuDa0rS.js";
import "./ColumnEmptyMessageBox-TSIJJX7z.js";
import "./ErrorHandler-DbW1lJbv.js";
import "./SnackBar-CoP3lSVs.js";
import "./Credentials-BM35X_na.js";
import "./NotificationOverlay-C-YNCUiT.js";
import "./Checkbox-WCw-l_7A.js";
import "./Expander-Bautb1_0.js";
import "./ClipboardUtils-mz40UK5S.js";
import "./ErrorReporter-7sfLhWZg.js";
import "./Services-CupYet_j.js";
import "./BubbleButton-DGGInJMg.js";
import "./SessionType-rxSDsswH.js";
import "./PasswordField-CPKPoLq8.js";
import "./PasswordRequestDialog-B7ZIVTVw.js";
import "./ErrorHandlerImpl-DRpk8tE9.js";
import { ListAutoSelectBehavior } from "./DeviceConfig-payZM407.js";
import { ListLoadingState } from "./List-CdKNFQkI.js";
import "./SelectableRowContainer-CWm9GtOE.js";
import "./CalendarRow-DM7ryi94.js";
import "./CustomerUtils-DmaZpb7Y.js";
import "./EventQueue-c-5UmjJa.js";
import "./EntityRestClient--6dT7ZRF.js";
import "./MessageDispatcher-wJwFhXWv.js";
import "./SqlValue-CkGu32Qd.js";
import "./Sql-C9YhYNym.js";
import "./RestClient-CmoHrId4.js";
import "./LoginViewModel-BX-8ry63.js";
import "./LoginButton-DzCRy0Yt.js";
import "./UsageTestModel-CjGx3RZo.js";
import "./inlineImagesUtils-BekMwI7k.js";
import "./CommonMailUtils-DNufl6ib.js";
import "./PermissionType-Bwii3hCe.js";
import "./AttachmentBubble-CloIefNF.js";
import "./RouteChange-im6yOAT2.js";
import { SearchCategoryTypes, createRestriction, decodeCalendarSearchKey, encodeCalendarSearchKey, getRestriction, getSearchUrl, searchCategoryForRestriction } from "./SearchUtils-Cu31OiTT.js";
import { areResultsForTheSameQuery, hasMoreResults, isSameSearchRestriction, mailLocator } from "./mailLocator-CrvEYt1k.js";
import "./PageContextLoginListener-dgY8O-YX.js";
import "./Scheduler-B2H65_EO.js";
import "./MailUtils-ChhZAFAd.js";
import "./FolderSystem-DLrUB8MO.js";
import "./MailChecks-PhVUoR7f.js";
import { FontIcons, getMailFilterForType } from "./MailViewerViewModel-D_nVDgz3.js";
import "./emlUtils-afBEUvhM.js";
import "./LoadingState-DqrMrOAm.js";
import { compareContacts } from "./ContactGuiUtils-BOj2qfyh.js";
import "./ContactListView-A76nls8J.js";
import "./ListModel-jYF3dysm.js";
import { ListElementListModel } from "./ListElementListModel-DYHUNydL.js";
import "./Badge-Z06TZUGC.js";

//#region ../src/common/gui/base/Label.ts
const supportsRelativeHslColors = CSS.supports("color", `hsl(from #ccc h calc(min(50, s)) l)`);
function getLabelColor(backgroundColor) {
	const labelColor = backgroundColor ?? theme.content_accent;
	const isDarkTheme = !isColorLight(theme.content_bg);
	return isDarkTheme ? limitedSaturationColor(labelColor) : labelColor;
}
function limitedSaturationColor(color) {
	return supportsRelativeHslColors ? `hsl(from ${color} h calc(min(50, s)) l)` : `hsl(from ${color} h calc(min(50%, s)) l)`;
}
const Label = pureComponent(function Label$1({ text, color }) {
	const labelColor = getLabelColor(color);
	return mithril_default("span.small.text-center.text-ellipsis.border-radius-m", { style: {
		backgroundColor: labelColor,
		color: colorForBg(color ?? theme.content_accent),
		padding: `1px ${size.vpad_xsm}px`
	} }, text);
});

//#endregion
//#region ../src/mail-app/mail/view/MailRow.ts
const iconMap = {
	[MailSetKind.CUSTOM]: FontIcons.Folder,
	[MailSetKind.INBOX]: FontIcons.Inbox,
	[MailSetKind.SENT]: FontIcons.Sent,
	[MailSetKind.TRASH]: FontIcons.Trash,
	[MailSetKind.ARCHIVE]: FontIcons.Archive,
	[MailSetKind.SPAM]: FontIcons.Spam,
	[MailSetKind.DRAFT]: FontIcons.Draft,
	[MailSetKind.ALL]: FontIcons.Folder,
	[MailSetKind.LABEL]: FontIcons.Folder,
	[MailSetKind.Imported]: FontIcons.Folder
};
const shiftByForCheckbox = px(10);
const translateXShow = `translateX(${shiftByForCheckbox})`;

//#endregion
//#region ../src/mail-app/search/view/SearchListView.ts
assertMainOrNode();
var SearchResultListEntry = class {
	constructor(entry) {
		this.entry = entry;
	}
	get _id() {
		return this.entry._id;
	}
};

//#endregion
//#region ../src/mail-app/search/view/SearchViewModel.ts
var import_stream = __toESM(require_stream(), 1);
const SEARCH_PAGE_SIZE = 100;
let PaidFunctionResult = function(PaidFunctionResult$1) {
	PaidFunctionResult$1[PaidFunctionResult$1["Success"] = 0] = "Success";
	PaidFunctionResult$1[PaidFunctionResult$1["PaidSubscriptionNeeded"] = 1] = "PaidSubscriptionNeeded";
	return PaidFunctionResult$1;
}({});
var SearchViewModel = class {
	_listModel;
	get listModel() {
		return this._listModel;
	}
	_includeRepeatingEvents = true;
	get includeRepeatingEvents() {
		return this._includeRepeatingEvents;
	}
	get warning() {
		if (this.startDate && this.startDate.getTime() > this.endDate.getTime()) return "startafterend";
else if (this.startDate && this.endDate.getTime() - this.startDate.getTime() > YEAR_IN_MILLIS) return "long";
else return null;
	}
	/**
	* the type ref that determines which search filters and details
	* viewers this view should show.
	* taken from the current results' restriction or, if result is nonexistent,
	* the URL.
	*
	* result might be nonexistent if there is no query or we're not done searching
	* yet.
	*/
	get searchedType() {
		return (this.searchResult?.restriction ?? this.router.getRestriction()).type;
	}
	_conversationViewModel = null;
	get conversationViewModel() {
		return this._conversationViewModel;
	}
	_startDate = null;
	get startDate() {
		return this._startDate ?? this.getCurrentMailIndexDate();
	}
	_endDate = null;
	get endDate() {
		if (this._endDate) return this._endDate;
else if (this.getCategory() === SearchCategoryTypes.calendar) {
			let returnDate = incrementMonth(new Date(), 3);
			returnDate.setDate(0);
			return returnDate;
		} else return new Date();
	}
	_selectedMailFolder = [];
	get selectedMailFolder() {
		return this._selectedMailFolder;
	}
	_selectedCalendar = null;
	get selectedCalendar() {
		return this._selectedCalendar;
	}
	_mailboxes = [];
	get mailboxes() {
		return this._mailboxes;
	}
	_selectedMailField = null;
	get selectedMailField() {
		return this._selectedMailField;
	}
	searchResult = null;
	mailFilterType = null;
	latestMailRestriction = null;
	latestCalendarRestriction = null;
	mailboxSubscription = null;
	resultSubscription = null;
	listStateSubscription = null;
	loadingAllForSearchResult = null;
	lazyCalendarInfos = new LazyLoaded(async () => {
		const calendarModel = await locator.calendarModel();
		const calendarInfos = await calendarModel.getCalendarInfos();
		mithril_default.redraw();
		return calendarInfos;
	});
	userHasNewPaidPlan = new LazyLoaded(async () => {
		return await this.logins.getUserController().isNewPaidPlan();
	});
	currentQuery = "";
	extendIndexConfirmationCallback = null;
	constructor(router, search, searchFacade, mailboxModel, logins, indexerFacade, entityClient, eventController, mailOpenedListener, calendarFacade, progressTracker, conversationViewModelFactory, eventsRepository, updateUi, selectionBehavior, localCalendars) {
		this.router = router;
		this.search = search;
		this.searchFacade = searchFacade;
		this.mailboxModel = mailboxModel;
		this.logins = logins;
		this.indexerFacade = indexerFacade;
		this.entityClient = entityClient;
		this.eventController = eventController;
		this.mailOpenedListener = mailOpenedListener;
		this.calendarFacade = calendarFacade;
		this.progressTracker = progressTracker;
		this.conversationViewModelFactory = conversationViewModelFactory;
		this.eventsRepository = eventsRepository;
		this.updateUi = updateUi;
		this.selectionBehavior = selectionBehavior;
		this.localCalendars = localCalendars;
		this.currentQuery = this.search.result()?.query ?? "";
		this._listModel = this.createList();
	}
	getLazyCalendarInfos() {
		return this.lazyCalendarInfos;
	}
	getUserHasNewPaidPlan() {
		return this.userHasNewPaidPlan;
	}
	init(extendIndexConfirmationCallback) {
		if (this.extendIndexConfirmationCallback) return;
		this.extendIndexConfirmationCallback = extendIndexConfirmationCallback;
		this.resultSubscription = this.search.result.map((result) => {
			if (!result || !isSameTypeRef(result.restriction.type, MailTypeRef)) this.mailFilterType = null;
			if (this.searchResult == null || result == null || !areResultsForTheSameQuery(result, this.searchResult)) {
				this._listModel.cancelLoadAll();
				this.searchResult = result;
				this._listModel = this.createList();
				this.setMailFilter(this.mailFilterType);
				this.applyMailFilterIfNeeded();
				this._listModel.loadInitial();
				this.listStateSubscription?.end(true);
				this.listStateSubscription = this._listModel.stateStream.map((state) => this.onListStateChange(state));
			}
		});
		this.mailboxSubscription = this.mailboxModel.mailboxDetails.map((mailboxes) => {
			this.onMailboxesChanged(mailboxes);
		});
		this.eventController.addEntityListener(this.entityEventsListener);
	}
	getRestriction() {
		return this.router.getRestriction();
	}
	entityEventsListener = async (updates) => {
		for (const update of updates) {
			const mergedUpdate = this.mergeOperationsIfNeeded(update, updates);
			if (mergedUpdate == null) continue;
			await this.entityEventReceived(mergedUpdate);
		}
	};
	mergeOperationsIfNeeded(update, updates) {
		if (!isUpdateForTypeRef(MailTypeRef, update) || this.searchResult == null) return update;
		if (update.operation === OperationType.CREATE && containsEventOfType(updates, OperationType.DELETE, update.instanceId)) if (this.listIdMatchesRestriction(update.instanceListId, this.searchResult.restriction)) return {
			...update,
			operation: OperationType.UPDATE
		};
else return null;
else if (update.operation === OperationType.DELETE && containsEventOfType(updates, OperationType.CREATE, update.instanceId)) {
			const createOperation = assertNotNull(getEventOfType(updates, OperationType.CREATE, update.instanceId));
			if (this.listIdMatchesRestriction(createOperation.instanceListId, this.searchResult.restriction)) return null;
else return update;
		} else return update;
	}
	listIdMatchesRestriction(listId, restriction) {
		return restriction.folderIds.length === 0 || restriction.folderIds.includes(listId);
	}
	onNewUrl(args, requestedPath) {
		let restriction;
		try {
			restriction = getRestriction(requestedPath);
		} catch (e) {
			this.router.routeTo(args.query, createRestriction(SearchCategoryTypes.mail, null, null, null, [], null));
			return;
		}
		this.currentQuery = args.query;
		const lastQuery = this.search.lastQueryString();
		const maxResults = isSameTypeRef(MailTypeRef, restriction.type) ? SEARCH_PAGE_SIZE : null;
		const listModel = this._listModel;
		if (Object.hasOwn(args, "query") && this.search.isNewSearch(args.query, restriction)) {
			this.searchResult = null;
			listModel.updateLoadingStatus(ListLoadingState.Loading);
			this.search.search({
				query: args.query,
				restriction,
				minSuggestionCount: 0,
				maxResults
			}, this.progressTracker).then(() => listModel.updateLoadingStatus(ListLoadingState.Done)).catch(() => listModel.updateLoadingStatus(ListLoadingState.ConnectionLost));
		} else if (lastQuery && this.search.isNewSearch(lastQuery, restriction)) {
			this.searchResult = null;
			listModel.selectNone();
			listModel.updateLoadingStatus(ListLoadingState.Loading);
			this.search.search({
				query: lastQuery,
				restriction,
				minSuggestionCount: 0,
				maxResults
			}, this.progressTracker).then(() => listModel.updateLoadingStatus(ListLoadingState.Done)).catch(() => listModel.updateLoadingStatus(ListLoadingState.ConnectionLost));
		} else if (!Object.hasOwn(args, "query") && !lastQuery) listModel.updateLoadingStatus(ListLoadingState.Done);
		if (isSameTypeRef(restriction.type, ContactTypeRef)) this.loadAndSelectIfNeeded(args.id);
else if (isSameTypeRef(restriction.type, MailTypeRef)) {
			this._selectedMailField = restriction.field;
			this._startDate = restriction.end ? new Date(restriction.end) : null;
			this._endDate = restriction.start ? new Date(restriction.start) : null;
			this._selectedMailFolder = restriction.folderIds;
			this.loadAndSelectIfNeeded(args.id);
			this.latestMailRestriction = restriction;
		} else if (isSameTypeRef(restriction.type, CalendarEventTypeRef)) {
			this._startDate = restriction.start ? new Date(restriction.start) : null;
			this._endDate = restriction.end ? new Date(restriction.end) : null;
			this._includeRepeatingEvents = restriction.eventSeries ?? true;
			this.lazyCalendarInfos.load();
			this.userHasNewPaidPlan.load();
			this.latestCalendarRestriction = restriction;
			const selectedCalendar = this.extractCalendarListIds(restriction.folderIds);
			if (!selectedCalendar || Array.isArray(selectedCalendar)) this._selectedCalendar = selectedCalendar;
else if (CLIENT_ONLY_CALENDARS.has(selectedCalendar.toString())) this.getUserHasNewPaidPlan().getAsync().then((isNewPaidPlan) => {
				if (!isNewPaidPlan) return this._selectedCalendar = null;
				this._selectedCalendar = selectedCalendar;
			});
			if (args.id != null) try {
				const { start, id } = decodeCalendarSearchKey(args.id);
				this.loadAndSelectIfNeeded(id, ({ entry }) => {
					entry = entry;
					return id === getElementId(entry) && start === entry.startTime.getTime();
				});
			} catch (err) {
				console.log("Invalid ID, selecting none");
				this.listModel.selectNone();
			}
		}
	}
	extractCalendarListIds(listIds) {
		if (listIds.length < 1) return null;
else if (listIds.length === 1) return listIds[0];
		return [listIds[0], listIds[1]];
	}
	loadAndSelectIfNeeded(id, finder) {
		if (id == null) return;
		if (!this._listModel.isItemSelected(id)) {
			if (!this._listModel.isItemSelected(id)) this.handleLoadAndSelection(id, finder);
		}
	}
	handleLoadAndSelection(id, finder) {
		if (this._listModel.isLoadedCompletely()) return this.selectItem(id, finder);
		const listStateStream = import_stream.default.combine((a) => a(), [this._listModel.stateStream]);
		listStateStream.map((state) => {
			if (state.loadingStatus === ListLoadingState.Done) {
				this.selectItem(id, finder);
				listStateStream.end(true);
			}
		});
	}
	selectItem(id, finder) {
		const listModel = this._listModel;
		this._listModel.loadAndSelect(id, () => !deepEqual(this._listModel, listModel), finder);
	}
	async loadAll() {
		if (this.loadingAllForSearchResult != null) return;
		this.loadingAllForSearchResult = this.searchResult ?? null;
		this._listModel.selectAll();
		try {
			while (this.searchResult?.restriction && this.loadingAllForSearchResult && isSameSearchRestriction(this.searchResult?.restriction, this.loadingAllForSearchResult.restriction) && !this._listModel.isLoadedCompletely()) {
				await this._listModel.loadMore();
				if (this.searchResult.restriction && this.loadingAllForSearchResult.restriction && isSameSearchRestriction(this.searchResult.restriction, this.loadingAllForSearchResult.restriction)) this._listModel.selectAll();
			}
		} finally {
			this.loadingAllForSearchResult = null;
		}
	}
	stopLoadAll() {
		this._listModel.cancelLoadAll();
	}
	selectMailField(field) {
		if (this.logins.getUserController().isFreeAccount() && field != null) return PaidFunctionResult.PaidSubscriptionNeeded;
else {
			this._selectedMailField = field;
			this.searchAgain();
			return PaidFunctionResult.Success;
		}
	}
	canSelectTimePeriod() {
		return !this.logins.getUserController().isFreeAccount();
	}
	getStartOfTheWeekOffset() {
		return getStartOfTheWeekOffsetForUser(this.logins.getUserController().userSettingsGroupRoot);
	}
	async selectStartDate(startDate) {
		if (isSameDayOfDate(this.startDate, startDate)) return PaidFunctionResult.Success;
		if (!this.canSelectTimePeriod()) return PaidFunctionResult.PaidSubscriptionNeeded;
		if (startDate && this.getCategory() === SearchCategoryTypes.mail && startDate.getTime() < this.search.indexState().currentMailIndexTimestamp && startDate) {
			const confirmed = await this.extendIndexConfirmationCallback?.() ?? true;
			if (confirmed) {
				this._startDate = startDate;
				this.indexerFacade.extendMailIndex(startDate.getTime()).then(() => {
					this.updateSearchUrl();
					this.updateUi();
				});
			} else return PaidFunctionResult.Success;
		} else this._startDate = startDate;
		this.searchAgain();
		return PaidFunctionResult.Success;
	}
	selectEndDate(endDate) {
		if (isSameDayOfDate(this.endDate, endDate)) return PaidFunctionResult.Success;
		if (!this.canSelectTimePeriod()) return PaidFunctionResult.PaidSubscriptionNeeded;
		this._endDate = endDate;
		this.searchAgain();
		return PaidFunctionResult.Success;
	}
	selectCalendar(calendarInfo) {
		if (typeof calendarInfo === "string" || calendarInfo == null) this._selectedCalendar = calendarInfo;
else this._selectedCalendar = [calendarInfo.groupRoot.longEvents, calendarInfo.groupRoot.shortEvents];
		this.searchAgain();
	}
	selectMailFolder(folder) {
		if (this.logins.getUserController().isFreeAccount() && folder != null) return PaidFunctionResult.PaidSubscriptionNeeded;
else {
			this._selectedMailFolder = folder;
			this.searchAgain();
			return PaidFunctionResult.Success;
		}
	}
	selectIncludeRepeatingEvents(include) {
		this._includeRepeatingEvents = include;
		this.searchAgain();
	}
	/**
	* @returns null if the complete mailbox is indexed
	*/
	getCurrentMailIndexDate() {
		let timestamp = this.search.indexState().currentMailIndexTimestamp;
		if (timestamp === FULL_INDEXED_TIMESTAMP) return null;
else if (timestamp === NOTHING_INDEXED_TIMESTAMP) return getEndOfDay(new Date());
else return new Date(timestamp);
	}
	searchAgain() {
		this.updateSearchUrl();
		this.updateUi();
	}
	getUrlFromSearchCategory(category) {
		if (this.currentQuery) {
			let latestRestriction = null;
			switch (category) {
				case SearchCategoryTypes.mail:
					latestRestriction = this.latestMailRestriction;
					break;
				case SearchCategoryTypes.calendar:
					latestRestriction = this.latestCalendarRestriction;
					break;
				case SearchCategoryTypes.contact: break;
			}
			if (latestRestriction) return getSearchUrl(this.currentQuery, latestRestriction);
else return getSearchUrl(this.currentQuery, createRestriction(category, null, null, null, [], null));
		} else return getSearchUrl("", createRestriction(category, null, null, null, [], null));
	}
	get mailFilter() {
		return this.mailFilterType;
	}
	setMailFilter(filter) {
		this.mailFilterType = filter;
		this.applyMailFilterIfNeeded();
	}
	applyMailFilterIfNeeded() {
		if (isSameTypeRef(this.searchedType, MailTypeRef)) {
			const filterFunction = getMailFilterForType(this.mailFilterType);
			const liftedFilter = filterFunction ? (entry) => filterFunction(entry.entry) : null;
			this._listModel?.setFilter(liftedFilter);
		}
	}
	updateSearchUrl() {
		const selectedElement = this._listModel.state.selectedItems.size === 1 ? this._listModel.getSelectedAsArray().at(0) : null;
		if (isSameTypeRef(this.searchedType, MailTypeRef)) this.routeMail(selectedElement?.entry ?? null, createRestriction(this.getCategory(), this._endDate ? getEndOfDay(this._endDate).getTime() : null, this._startDate ? getStartOfDay(this._startDate).getTime() : null, this._selectedMailField, this._selectedMailFolder, null));
else if (isSameTypeRef(this.searchedType, CalendarEventTypeRef)) this.routeCalendar(selectedElement?.entry ?? null, createRestriction(this.getCategory(), this._startDate ? getStartOfDay(this._startDate).getTime() : null, this._endDate ? getEndOfDay(this._endDate).getTime() : null, null, this.getFolderIds(), this._includeRepeatingEvents));
else if (isSameTypeRef(this.searchedType, ContactTypeRef)) this.routeContact(selectedElement?.entry ?? null, createRestriction(this.getCategory(), null, null, null, [], null));
	}
	getFolderIds() {
		if (typeof this.selectedCalendar === "string") return [this.selectedCalendar];
else if (this.selectedCalendar != null) return [...this.selectedCalendar];
		return [];
	}
	routeCalendar(element, restriction) {
		const selectionKey = this.generateSelectionKey(element);
		this.router.routeTo(this.currentQuery, restriction, selectionKey);
	}
	routeMail(element, restriction) {
		this.router.routeTo(this.currentQuery, restriction, this.generateSelectionKey(element));
	}
	routeContact(element, restriction) {
		this.router.routeTo(this.currentQuery, restriction, this.generateSelectionKey(element));
	}
	generateSelectionKey(element) {
		if (element == null) return null;
		if (assertIsEntity(element, CalendarEventTypeRef)) return encodeCalendarSearchKey(element);
else return getElementId(element);
	}
	getCategory() {
		const restriction = this.router.getRestriction();
		return searchCategoryForRestriction(restriction);
	}
	async onMailboxesChanged(mailboxes) {
		this._mailboxes = mailboxes;
		const selectedMailFolder = this._selectedMailFolder;
		if (selectedMailFolder[0]) {
			const mailFolder = await mailLocator.mailModel.getMailSetById(selectedMailFolder[0]);
			if (!mailFolder) {
				const folderSystem = assertNotNull(mailLocator.mailModel.getFolderSystemByGroupId(mailboxes[0].mailGroup._id));
				this._selectedMailFolder = [getElementId(assertNotNull(folderSystem.getSystemFolderByType(MailSetKind.INBOX)))];
				this.updateUi();
			}
		}
	}
	isPossibleABirthdayContactUpdate(update) {
		if (isUpdateForTypeRef(ContactTypeRef, update) && isSameTypeRef(this.searchedType, CalendarEventTypeRef)) {
			const { instanceListId, instanceId } = update;
			const encodedContactId = stringToBase64(`${instanceListId}/${instanceId}`);
			return this.listModel.stateStream().items.some((searchEntry) => searchEntry._id[1].endsWith(encodedContactId));
		}
		return false;
	}
	isSelectedEventAnUpdatedBirthday(update) {
		if (isUpdateForTypeRef(ContactTypeRef, update) && isSameTypeRef(this.searchedType, CalendarEventTypeRef)) {
			const { instanceListId, instanceId } = update;
			const encodedContactId = stringToBase64(`${instanceListId}/${instanceId}`);
			const selectedItem = this.listModel.getSelectedAsArray().at(0);
			if (!selectedItem) return false;
			return selectedItem._id[1].endsWith(encodedContactId);
		}
		return false;
	}
	async entityEventReceived(update) {
		const lastType = this.searchedType;
		const isPossibleABirthdayContactUpdate = this.isPossibleABirthdayContactUpdate(update);
		if (!isUpdateForTypeRef(lastType, update) && !isPossibleABirthdayContactUpdate) return;
		const { instanceListId, instanceId, operation } = update;
		const id = [neverNull(instanceListId), instanceId];
		const typeRef = new TypeRef(update.application, update.type);
		if (!this.isInSearchResult(typeRef, id) && !isPossibleABirthdayContactUpdate) return;
		if (isUpdateForTypeRef(MailTypeRef, update) && operation === OperationType.UPDATE) {
			if (this.searchResult && this.searchResult.results) {
				const index = this.searchResult?.results.findIndex((email) => update.instanceId === elementIdPart(email) && update.instanceListId !== listIdPart(email));
				if (index >= 0) {
					const restrictionLength = this.searchResult.restriction.folderIds.length;
					if (restrictionLength > 0 && this.searchResult.restriction.folderIds.includes(update.instanceListId) || restrictionLength === 0) {
						const newIdTuple = [update.instanceListId, update.instanceId];
						this.searchResult.results[index] = newIdTuple;
					}
				}
			}
		} else if (isUpdateForTypeRef(CalendarEventTypeRef, update) && isSameTypeRef(lastType, CalendarEventTypeRef) || isPossibleABirthdayContactUpdate) {
			const selectedItem = this._listModel.getSelectedAsArray().at(0);
			const listModel = this.createList();
			this.setMailFilter(this.mailFilterType);
			this.applyMailFilterIfNeeded();
			if (isPossibleABirthdayContactUpdate && await this.eventsRepository.canLoadBirthdaysCalendar()) await this.eventsRepository.loadContactsBirthdays(true);
			await listModel.loadInitial();
			if (selectedItem != null) {
				if (isPossibleABirthdayContactUpdate && this.isSelectedEventAnUpdatedBirthday(update)) this.listModel.selectNone();
				await listModel.loadAndSelect(elementIdPart(selectedItem._id), () => false);
			}
			this._listModel = listModel;
			this.listStateSubscription?.end(true);
			this.listStateSubscription = this._listModel.stateStream.map((state) => this.onListStateChange(state));
			this.updateSearchUrl();
			this.updateUi();
			return;
		}
		this._listModel.getUnfilteredAsArray();
		await this._listModel.entityEventReceived(instanceListId, instanceId, operation);
		if (operation === OperationType.UPDATE && this._listModel?.isItemSelected(elementIdPart(id))) try {
			await this.entityClient.load(typeRef, id);
			this.updateUi();
		} catch (e) {}
	}
	getSelectedMails() {
		return this._listModel.getSelectedAsArray().map((e) => e.entry).filter(assertIsEntity2(MailTypeRef));
	}
	getSelectedContacts() {
		return this._listModel.getSelectedAsArray().map((e) => e.entry).filter(assertIsEntity2(ContactTypeRef));
	}
	getSelectedEvents() {
		return this._listModel.getSelectedAsArray().map((e) => e.entry).filter(assertIsEntity2(CalendarEventTypeRef));
	}
	onListStateChange(newState) {
		if (isSameTypeRef(this.searchedType, MailTypeRef)) if (!newState.inMultiselect && newState.selectedItems.size === 1) {
			const mail = this.getSelectedMails()[0];
			if (mail) {
				if (!this._conversationViewModel) this.updateDisplayedConversation(mail);
else if (this._conversationViewModel) {
					const isSameElementId = isSameId(elementIdPart(this._conversationViewModel?.primaryMail._id), elementIdPart(mail._id));
					const isSameListId = isSameId(listIdPart(this._conversationViewModel?.primaryMail._id), listIdPart(mail._id));
					if (!isSameElementId || !isSameListId) {
						this.updateSearchUrl();
						this.updateDisplayedConversation(mail);
					}
				}
			} else this._conversationViewModel = null;
		} else this._conversationViewModel = null;
else this._conversationViewModel = null;
		this.updateUi();
	}
	updateDisplayedConversation(mail) {
		if (this.conversationViewModelFactory && this.mailOpenedListener) {
			this._conversationViewModel = this.conversationViewModelFactory({
				mail,
				showFolder: true
			});
			this.mailOpenedListener.onEmailOpened(mail);
		}
	}
	createList() {
		return new ListElementListModel({
			fetch: async (lastFetchedEntity, count) => {
				const startId = lastFetchedEntity == null ? GENERATED_MAX_ID : getElementId(lastFetchedEntity);
				const lastResult = this.searchResult;
				if (lastResult !== this.searchResult) {
					console.warn("got a fetch request for outdated results object, ignoring");
					return {
						items: [],
						complete: true
					};
				}
				await awaitSearchInitialized(this.search);
				if (!lastResult || lastResult.results.length === 0 && !hasMoreResults(lastResult)) return {
					items: [],
					complete: true
				};
				const { items, newSearchResult } = await this.loadSearchResults(lastResult, startId, count);
				const entries = items.map((instance) => new SearchResultListEntry(instance));
				const complete = !hasMoreResults(newSearchResult);
				return {
					items: entries,
					complete
				};
			},
			loadSingle: async (_listId, elementId) => {
				const lastResult = this.searchResult;
				if (!lastResult) return null;
				const id = lastResult.results.find((resultId) => elementIdPart(resultId) === elementId);
				if (id) return this.entityClient.load(lastResult.restriction.type, id).then((entity) => new SearchResultListEntry(entity)).catch(ofClass(NotFoundError, (_) => {
					return null;
				}));
else return null;
			},
			sortCompare: (o1, o2) => {
				if (isSameTypeRef(o1.entry._type, ContactTypeRef)) return compareContacts(o1.entry, o2.entry);
else if (isSameTypeRef(o1.entry._type, CalendarEventTypeRef)) return downcast(o1.entry).startTime.getTime() - downcast(o2.entry).startTime.getTime();
else return sortCompareByReverseId(o1.entry, o2.entry);
			},
			autoSelectBehavior: () => isSameTypeRef(this.searchedType, MailTypeRef) ? this.selectionBehavior : ListAutoSelectBehavior.OLDER
		});
	}
	isInSearchResult(typeRef, id) {
		const result = this.searchResult;
		if (result && isSameTypeRef(typeRef, result.restriction.type)) {
			const ignoreList = isSameTypeRef(typeRef, MailTypeRef) && result.restriction.folderIds.length === 0;
			return result.results.some((r) => this.compareItemId(r, id, ignoreList));
		}
		return false;
	}
	compareItemId(id1, id2, ignoreList) {
		return ignoreList ? isSameId(elementIdPart(id1), elementIdPart(id2)) : isSameId(id1, id2);
	}
	async loadSearchResults(currentResult, startId, count) {
		const updatedResult = hasMoreResults(currentResult) ? await this.searchFacade.getMoreSearchResults(currentResult, count) : currentResult;
		this.searchResult = updatedResult;
		let items;
		if (isSameTypeRef(currentResult.restriction.type, MailTypeRef)) {
			let startIndex = 0;
			if (startId !== GENERATED_MAX_ID) {
				startIndex = updatedResult.results.findIndex((id) => id[1] <= startId);
				if (elementIdPart(updatedResult.results[startIndex]) === startId) startIndex++;
else if (startIndex === -1) startIndex = Math.max(updatedResult.results.length - 1, 0);
			}
			const toLoad = updatedResult.results.slice(startIndex);
			items = await this.loadAndFilterInstances(currentResult.restriction.type, toLoad, updatedResult, startIndex);
		} else if (isSameTypeRef(currentResult.restriction.type, ContactTypeRef)) try {
			items = await this.loadAndFilterInstances(currentResult.restriction.type, updatedResult.results, updatedResult, 0);
		} finally {
			this.updateUi();
		}
else if (isSameTypeRef(currentResult.restriction.type, CalendarEventTypeRef)) try {
			const { start, end } = currentResult.restriction;
			if (start == null || end == null) throw new ProgrammingError("invalid search time range for calendar");
			items = [...await this.calendarFacade.reifyCalendarSearchResult(start, end, updatedResult.results), ...await this.getClientOnlyEventsSeries(start, end, updatedResult.results)];
		} finally {
			this.updateUi();
		}
else items = [];
		return {
			items,
			newSearchResult: updatedResult
		};
	}
	async getClientOnlyEventsSeries(start, end, events) {
		const eventList = await retrieveClientOnlyEventsForUser(this.logins, events, this.eventsRepository.getBirthdayEvents());
		return generateCalendarInstancesInRange(eventList, {
			start,
			end
		});
	}
	/**
	* take a list of IDs and load them by list, filtering out the ones that could not be loaded.
	* updates the passed currentResult.result list to not include the failed IDs anymore
	*/
	async loadAndFilterInstances(type, toLoad, currentResult, startIndex) {
		const instances = await loadMultipleFromLists(type, this.entityClient, toLoad);
		if (instances.length < toLoad.length) {
			const resultLength = currentResult.results.length;
			console.log(`Could not load some results: ${instances.length} out of ${toLoad.length}`);
			for (let i = toLoad.length - 1; i >= 0; i--) {
				const toLoadId = toLoad[i];
				if (!instances.some((instance) => isSameId(instance._id, toLoadId))) {
					currentResult.results.splice(startIndex + i, 1);
					if (instances.length === toLoad.length) break;
				}
			}
			console.log(`Fixed results, before ${resultLength}, after: ${currentResult.results.length}`);
		}
		return instances;
	}
	sendStopLoadingSignal() {
		this.search.sendCancelSignal();
	}
	getLocalCalendars() {
		return getClientOnlyCalendars(this.logins.getUserController().userId, this.localCalendars);
	}
	dispose() {
		this.stopLoadAll();
		this.extendIndexConfirmationCallback = null;
		this.resultSubscription?.end(true);
		this.resultSubscription = null;
		this.mailboxSubscription?.end(true);
		this.mailboxSubscription = null;
		this.listStateSubscription?.end(true);
		this.listStateSubscription = null;
		this.search.sendCancelSignal();
		this.eventController.removeEntityListener(this.entityEventsListener);
	}
	getLabelsForMail(mail) {
		return mailLocator.mailModel.getLabelsForMail(mail);
	}
};
function awaitSearchInitialized(searchModel) {
	const deferred = defer();
	const dep = searchModel.indexState.map((state) => {
		if (!state.initializing) Promise.resolve().then(() => {
			dep.end(true);
			deferred.resolve(undefined);
		});
	});
	return deferred.promise;
}

//#endregion
export { SearchViewModel };
//# sourceMappingURL=SearchViewModel-D1L5qbZi.js.map