{"version":3,"file":"OfflineDbFacadeTest-D3DaePz6.js","names":["factory: OfflineDbFactory","offlineDbRefCounter: OfflineDbRefCounter","db: DesktopSqlCipher","promise: Promise<void> | null","startId: number","finishOrder: Array<number>"],"sources":["../tests/desktop/db/OfflineDbFacadeTest.ts"],"sourcesContent":["import o from \"@tutao/otest\"\nimport { object, when } from \"testdouble\"\nimport { verify } from \"@tutao/tutanota-test-utils\"\nimport { OfflineDbFactory } from \"../../../../src/common/desktop/db/PerWindowSqlCipherFacade.js\"\nimport { delay } from \"@tutao/tutanota-utils\"\nimport { DesktopSqlCipher } from \"../../../../src/common/desktop/db/DesktopSqlCipher.js\"\nimport { OfflineDbRefCounter } from \"../../../../src/common/desktop/db/OfflineDbRefCounter.js\"\n\no.spec(\"OfflineDbFacade\", function () {\n\tlet factory: OfflineDbFactory\n\tlet offlineDbRefCounter: OfflineDbRefCounter\n\tconst userId = \"123\"\n\tconst databaseKey = new Uint8Array([1, 2, 3])\n\tlet db: DesktopSqlCipher\n\n\to.beforeEach(function () {\n\t\tfactory = object()\n\t\tofflineDbRefCounter = new OfflineDbRefCounter(factory)\n\t\tdb = object<DesktopSqlCipher>()\n\t\twhen(factory.create(userId, databaseKey)).thenResolve(db)\n\t})\n\n\to(\"when opening database for the first time, it is created\", async function () {\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\n\t\tverify(factory.create(userId, databaseKey))\n\t})\n\n\to(\"when opening database after everytime after the first time, it is not created\", async function () {\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\n\t\tverify(factory.create(userId, databaseKey), { times: 1 })\n\t})\n\n\to(\"when closing database which was opened once, it is closed\", async function () {\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\t\tawait offlineDbRefCounter.disposeDb(userId)\n\n\t\tverify(db.closeDb())\n\t})\n\n\to(\"when closing database which was opened more than once, it is not closed\", async function () {\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\t\tawait offlineDbRefCounter.disposeDb(userId)\n\n\t\tverify(db.closeDb(), { times: 0 })\n\t})\n\n\to(\"when closing database twice which was opened twice, it is closed\", async function () {\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\t\tawait offlineDbRefCounter.disposeDb(userId)\n\t\tawait offlineDbRefCounter.disposeDb(userId)\n\n\t\tverify(db.closeDb(), { times: 1 })\n\t})\n\n\to(\"when reopening database, it is created\", async function () {\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\t\tawait offlineDbRefCounter.disposeDb(userId)\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, databaseKey)\n\n\t\tverify(factory.create(userId, databaseKey), { times: 2 })\n\t})\n\n\to(\"ranges database is locked when writing/reading to/from it\", async function () {\n\t\tconst listId = \"listId\"\n\n\t\tawait offlineDbRefCounter.getOrCreateDb(userId, new Uint8Array())\n\n\t\t// Hold the lock for the ranges database until @param defer is resolved.\n\t\tasync function holdRangesDbLock(promise: Promise<void> | null, startId: number): Promise<number> {\n\t\t\tawait offlineDbRefCounter.lockRangesDbAccess(userId, listId)\n\t\t\tawait promise\n\t\t\tawait offlineDbRefCounter.unlockRangesDbAccess(userId, listId)\n\t\t\treturn startId\n\t\t}\n\n\t\tconst finishOrder: Array<number> = []\n\t\t// Delay Task 1\n\t\tconst longRunningTask1 = delay(100)\n\n\t\t// Task 1\n\t\tlet task1 = holdRangesDbLock(longRunningTask1, 1).then((startId) => {\n\t\t\tfinishOrder.push(startId)\n\t\t})\n\t\t// Task 2\n\t\tlet task2 = holdRangesDbLock(null, 2).then((startId) => {\n\t\t\tfinishOrder.push(startId)\n\t\t})\n\t\tawait Promise.all([task1, task2])\n\n\t\t// Assert that task 1 finishes before task 2\n\t\to(finishOrder).deepEquals([1, 2])\n\t})\n})\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,aAAE,KAAK,mBAAmB,WAAY;CACrC,IAAIA;CACJ,IAAIC;CACJ,MAAM,SAAS;CACf,MAAM,cAAc,IAAI,WAAW;EAAC;EAAG;EAAG;CAAE;CAC5C,IAAIC;AAEJ,cAAE,WAAW,WAAY;AACxB,YAAU,+BAAQ;AAClB,wBAAsB,IAAI,oBAAoB;AAC9C,OAAK,+BAA0B;AAC/B,8BAAK,QAAQ,OAAO,QAAQ,YAAY,CAAC,CAAC,YAAY,GAAG;CACzD,EAAC;AAEF,cAAE,2DAA2D,iBAAkB;AAC9E,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAE5D,SAAO,QAAQ,OAAO,QAAQ,YAAY,CAAC;CAC3C,EAAC;AAEF,cAAE,iFAAiF,iBAAkB;AACpG,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAC5D,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAE5D,SAAO,QAAQ,OAAO,QAAQ,YAAY,EAAE,EAAE,OAAO,EAAG,EAAC;CACzD,EAAC;AAEF,cAAE,6DAA6D,iBAAkB;AAChF,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAC5D,QAAM,oBAAoB,UAAU,OAAO;AAE3C,SAAO,GAAG,SAAS,CAAC;CACpB,EAAC;AAEF,cAAE,2EAA2E,iBAAkB;AAC9F,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAC5D,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAC5D,QAAM,oBAAoB,UAAU,OAAO;AAE3C,SAAO,GAAG,SAAS,EAAE,EAAE,OAAO,EAAG,EAAC;CAClC,EAAC;AAEF,cAAE,oEAAoE,iBAAkB;AACvF,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAC5D,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAC5D,QAAM,oBAAoB,UAAU,OAAO;AAC3C,QAAM,oBAAoB,UAAU,OAAO;AAE3C,SAAO,GAAG,SAAS,EAAE,EAAE,OAAO,EAAG,EAAC;CAClC,EAAC;AAEF,cAAE,0CAA0C,iBAAkB;AAC7D,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAC5D,QAAM,oBAAoB,UAAU,OAAO;AAC3C,QAAM,oBAAoB,cAAc,QAAQ,YAAY;AAE5D,SAAO,QAAQ,OAAO,QAAQ,YAAY,EAAE,EAAE,OAAO,EAAG,EAAC;CACzD,EAAC;AAEF,cAAE,6DAA6D,iBAAkB;EAChF,MAAM,SAAS;AAEf,QAAM,oBAAoB,cAAc,QAAQ,IAAI,aAAa;EAGjE,eAAe,iBAAiBC,SAA+BC,SAAkC;AAChG,SAAM,oBAAoB,mBAAmB,QAAQ,OAAO;AAC5D,SAAM;AACN,SAAM,oBAAoB,qBAAqB,QAAQ,OAAO;AAC9D,UAAO;EACP;EAED,MAAMC,cAA6B,CAAE;EAErC,MAAM,mBAAmB,MAAM,IAAI;EAGnC,IAAI,QAAQ,iBAAiB,kBAAkB,EAAE,CAAC,KAAK,CAAC,YAAY;AACnE,eAAY,KAAK,QAAQ;EACzB,EAAC;EAEF,IAAI,QAAQ,iBAAiB,MAAM,EAAE,CAAC,KAAK,CAAC,YAAY;AACvD,eAAY,KAAK,QAAQ;EACzB,EAAC;AACF,QAAM,QAAQ,IAAI,CAAC,OAAO,KAAM,EAAC;AAGjC,eAAE,YAAY,CAAC,WAAW,CAAC,GAAG,CAAE,EAAC;CACjC,EAAC;AACF,EAAC"}