{"version":3,"file":"EventQueue-c-5UmjJa.js","names":["batchId: Id","batch: ReadonlyArray<EntityUpdate>","entityUpdate: EntityUpdate","update: EntityUpdate","tag: string","optimizationEnabled: boolean","queueAction: QueueAction","batches: ReadonlyArray<QueuedBatch>","progressMonitor: ProgressMonitorDelegate","groupId: Id","newEvents: ReadonlyArray<EntityUpdate>","newBatch: QueuedBatch","operationKey: LastOperationKey","startIndex: number"],"sources":["../../src/common/api/worker/EventQueue.ts"],"sourcesContent":["import { OperationType } from \"../common/TutanotaConstants.js\"\nimport { findAllAndRemove } from \"@tutao/tutanota-utils\"\nimport { ConnectionError, ServiceUnavailableError } from \"../common/error/RestError.js\"\nimport type { EntityUpdate } from \"../entities/sys/TypeRefs.js\"\nimport { ProgrammingError } from \"../common/error/ProgrammingError.js\"\nimport { ProgressMonitorDelegate } from \"./ProgressMonitorDelegate.js\"\n\nexport type QueuedBatch = {\n\tevents: EntityUpdate[]\n\tgroupId: Id\n\tbatchId: Id\n}\n\nexport const enum EntityModificationType {\n\tCREATE = \"CREATE\",\n\tUPDATE = \"UPDATE\",\n\tDELETE = \"DELETE\",\n}\n\ntype QueueAction = (nextElement: QueuedBatch) => Promise<void>\n\n/**\n * Checks which modification is applied in the given batch for the entity id.\n * @param batch entity updates of the batch.\n * @private visibleForTests\n */\nexport function batchMod(batchId: Id, batch: ReadonlyArray<EntityUpdate>, entityUpdate: EntityUpdate): EntityModificationType {\n\tfor (const batchEvent of batch) {\n\t\tif (\n\t\t\tentityUpdate.instanceId === batchEvent.instanceId &&\n\t\t\tentityUpdate.instanceListId === batchEvent.instanceListId &&\n\t\t\tentityUpdate.application === batchEvent.application &&\n\t\t\tentityUpdate.type === batchEvent.type\n\t\t) {\n\t\t\tswitch (batchEvent.operation) {\n\t\t\t\tcase OperationType.CREATE:\n\t\t\t\t\treturn EntityModificationType.CREATE\n\n\t\t\t\tcase OperationType.UPDATE:\n\t\t\t\t\treturn EntityModificationType.UPDATE\n\n\t\t\t\tcase OperationType.DELETE:\n\t\t\t\t\treturn EntityModificationType.DELETE\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ProgrammingError(`Unknown operation: ${batchEvent.operation}`)\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow new ProgrammingError(\n\t\t`Batch does not have events for ${entityUpdate.application}/${entityUpdate.type} ${lastOperationKey(entityUpdate)}, batchId: ${batchId}`,\n\t)\n}\n\n// A key for _lastOperationForEntity.\n// At runtime just an element id or listId/elementId.\n// Adding brand for type safety.\ntype LastOperationKey = string & { __brand: \"lastOpeKey\" }\n\nfunction lastOperationKey(update: EntityUpdate): LastOperationKey {\n\tconst typeIdentifier = `${update.application}/${update.type}`\n\tif (update.instanceListId) {\n\t\treturn `${typeIdentifier}/${update.instanceListId}/${update.instanceId}` as LastOperationKey\n\t} else {\n\t\treturn `${typeIdentifier}/${update.instanceId}` as LastOperationKey\n\t}\n}\n\nexport class EventQueue {\n\t/** Batches to process. Oldest first. */\n\tprivate readonly eventQueue: Array<QueuedBatch>\n\t// the last processed operation for a given entity id\n\tprivate readonly lastOperationForEntity: Map<LastOperationKey, QueuedBatch>\n\tprivate processingBatch: QueuedBatch | null\n\tprivate paused: boolean\n\tprivate progressMonitor: ProgressMonitorDelegate | null\n\n\t/**\n\t * @param tag identifier to make for better log messages\n\t * @param optimizationEnabled whether the queue should try to optimize events and remove unnecessary ones with the knowledge of newer ones\n\t * @param queueAction which is executed for each batch. Must *never* throw.\n\t */\n\tconstructor(private readonly tag: string, private readonly optimizationEnabled: boolean, private readonly queueAction: QueueAction) {\n\t\tthis.eventQueue = []\n\t\tthis.lastOperationForEntity = new Map()\n\t\tthis.processingBatch = null\n\t\tthis.paused = false\n\t\tthis.progressMonitor = null\n\t}\n\n\taddBatches(batches: ReadonlyArray<QueuedBatch>) {\n\t\tfor (const batch of batches) {\n\t\t\tthis.add(batch.batchId, batch.groupId, batch.events)\n\t\t}\n\t}\n\n\tsetProgressMonitor(progressMonitor: ProgressMonitorDelegate) {\n\t\tthis.progressMonitor?.completed() // make sure any old monitor does not have pending work\n\t\tthis.progressMonitor = progressMonitor\n\t}\n\n\t/**\n\t * @return whether the batch was added (not optimized away)\n\t */\n\tadd(batchId: Id, groupId: Id, newEvents: ReadonlyArray<EntityUpdate>): boolean {\n\t\tconst newBatch: QueuedBatch = {\n\t\t\tevents: [],\n\t\t\tgroupId,\n\t\t\tbatchId,\n\t\t}\n\n\t\tif (!this.optimizationEnabled) {\n\t\t\tnewBatch.events.push(...newEvents)\n\t\t} else {\n\t\t\tthis.optimizingAddEvents(newBatch, batchId, groupId, newEvents)\n\t\t}\n\n\t\tif (newBatch.events.length !== 0) {\n\t\t\tthis.eventQueue.push(newBatch)\n\n\t\t\tfor (const update of newBatch.events) {\n\t\t\t\tthis.lastOperationForEntity.set(lastOperationKey(update), newBatch)\n\t\t\t}\n\t\t}\n\n\t\t// ensures that events are processed when not paused\n\t\tthis.start()\n\t\treturn newBatch.events.length > 0\n\t}\n\n\tprivate optimizingAddEvents(newBatch: QueuedBatch, batchId: Id, groupId: Id, newEvents: ReadonlyArray<EntityUpdate>): void {\n\t\tfor (const newEvent of newEvents) {\n\t\t\tconst lastOpKey = lastOperationKey(newEvent)\n\t\t\tconst lastBatchForEntity = this.lastOperationForEntity.get(lastOpKey)\n\t\t\tif (\n\t\t\t\tlastBatchForEntity == null ||\n\t\t\t\t(this.processingBatch != null && this.processingBatch === lastBatchForEntity) ||\n\t\t\t\tgroupId !== lastBatchForEntity.groupId\n\t\t\t) {\n\t\t\t\t// If there's no current operation, there's nothing to merge, just add\n\t\t\t\t// If current operation is already being processed, don't modify it, we cannot merge anymore and should just append.\n\t\t\t\tnewBatch.events.push(newEvent)\n\t\t\t} else {\n\t\t\t\tconst newEntityModification = batchMod(batchId, newEvents, newEvent)\n\t\t\t\tconst lastEntityModification = batchMod(lastBatchForEntity.batchId, lastBatchForEntity.events, newEvent)\n\n\t\t\t\tif (newEntityModification === EntityModificationType.UPDATE) {\n\t\t\t\t\tswitch (lastEntityModification) {\n\t\t\t\t\t\tcase EntityModificationType.CREATE:\n\t\t\t\t\t\t\t// Skip create because the create was not processed yet and we will download the updated version already\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase EntityModificationType.UPDATE:\n\t\t\t\t\t\t\t// Skip update because the previous update was not processed yet and we will download the updated version already\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase EntityModificationType.DELETE:\n\t\t\t\t\t\t\tthrow new ProgrammingError(\n\t\t\t\t\t\t\t\t`UPDATE not allowed after DELETE. Last batch: ${lastBatchForEntity.batchId}, new batch: ${batchId}, ${newEvent.type} ${lastOpKey}`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t} else if (newEntityModification === EntityModificationType.DELETE) {\n\t\t\t\t\t// delete all other events because they don't matter if the entity is already gone\n\t\t\t\t\tthis.removeEventsForInstance(lastOpKey)\n\t\t\t\t\t// set last operation early to make sure that it's not some empty batch that is the last operation, otherwise batchMod will fail.\n\t\t\t\t\t// this shouldn't happen (because delete + create for the same entity in the same batch is not really a thing) and is a bit hacky,\n\t\t\t\t\t// but it works?\n\t\t\t\t\tthis.lastOperationForEntity.set(lastOpKey, newBatch)\n\t\t\t\t\t// add delete event\n\t\t\t\t\tnewBatch.events.push(newEvent)\n\t\t\t\t} else if (newEntityModification === EntityModificationType.CREATE) {\n\t\t\t\t\tif (lastEntityModification === EntityModificationType.DELETE || lastEntityModification === EntityModificationType.CREATE) {\n\t\t\t\t\t\t// It is likely custom id instance which got re-created\n\t\t\t\t\t\tnewBatch.events.push(newEvent)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new ProgrammingError(\n\t\t\t\t\t\t\t`Impossible modification combination ${lastEntityModification} ${newEntityModification} ${JSON.stringify(newEvent)}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new ProgrammingError(\n\t\t\t\t\t\t`Impossible modification combination ${lastEntityModification} ${newEntityModification} ${JSON.stringify(newEvent)}`,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate removeEventsForInstance(operationKey: LastOperationKey, startIndex: number = 0): void {\n\t\t// We keep empty batches because we expect certain number of batches to be processed and it's easier to just keep them.\n\t\tfor (let i = startIndex; i < this.eventQueue.length; i++) {\n\t\t\tconst batchInThePast = this.eventQueue[i]\n\t\t\tif (this.processingBatch === batchInThePast) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// this will remove all events for the element id from the batch\n\t\t\t// we keep delete events because they don't hurt generally and we also want things to be timely deleted\n\t\t\tfindAllAndRemove(batchInThePast.events, (event) => event.operation !== OperationType.DELETE && lastOperationKey(event) === operationKey)\n\t\t}\n\t}\n\n\tstart() {\n\t\tif (this.processingBatch) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.processNext()\n\t}\n\n\tqueueSize(): number {\n\t\treturn this.eventQueue.length\n\t}\n\n\tprivate processNext() {\n\t\tif (this.paused) {\n\t\t\treturn\n\t\t}\n\n\t\tconst next = this.eventQueue[0]\n\n\t\tif (next) {\n\t\t\tthis.processingBatch = next\n\n\t\t\tthis.queueAction(next)\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis.eventQueue.shift()\n\t\t\t\t\tthis.progressMonitor?.workDone(1)\n\t\t\t\t\tthis.processingBatch = null\n\n\t\t\t\t\t// When we are done with the batch, we don't want to merge with it anymore\n\t\t\t\t\tfor (const event of next.events) {\n\t\t\t\t\t\tconst concatenatedId = lastOperationKey(event)\n\t\t\t\t\t\tif (this.lastOperationForEntity.get(concatenatedId) === next) {\n\t\t\t\t\t\t\tthis.lastOperationForEntity.delete(concatenatedId)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.processNext()\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tconsole.log(\"EventQueue\", this.tag, this.optimizationEnabled, \"error\", next, e)\n\t\t\t\t\t// processing continues if the event bus receives a new event\n\t\t\t\t\tthis.processingBatch = null\n\n\t\t\t\t\tif (!(e instanceof ServiceUnavailableError || e instanceof ConnectionError)) {\n\t\t\t\t\t\tconsole.error(\"Uncaught EventQueue error!\", e, next)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis.eventQueue.splice(0)\n\n\t\tthis.processingBatch = null\n\n\t\tfor (const k of this.lastOperationForEntity.keys()) {\n\t\t\tthis.lastOperationForEntity.delete(k)\n\t\t}\n\t}\n\n\tpause() {\n\t\tthis.paused = true\n\t}\n\n\tresume() {\n\t\tthis.paused = false\n\t\tthis.start()\n\t}\n\n\t/** @private visibleForTesting */\n\tget __processingBatch(): QueuedBatch | null {\n\t\treturn this.processingBatch\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAakB,4DAAX;AACN;AACA;AACA;;AACA;AASM,SAAS,SAASA,SAAaC,OAAoCC,cAAoD;AAC7H,MAAK,MAAM,cAAc,MACxB,KACC,aAAa,eAAe,WAAW,cACvC,aAAa,mBAAmB,WAAW,kBAC3C,aAAa,gBAAgB,WAAW,eACxC,aAAa,SAAS,WAAW,KAEjC,SAAQ,WAAW,WAAnB;AACC,OAAK,cAAc,OAClB,QAAO,uBAAuB;AAE/B,OAAK,cAAc,OAClB,QAAO,uBAAuB;AAE/B,OAAK,cAAc,OAClB,QAAO,uBAAuB;AAE/B,UACC,OAAM,IAAI,kBAAkB,qBAAqB,WAAW,UAAU;CACvE;AAIH,OAAM,IAAI,kBACR,iCAAiC,aAAa,YAAY,GAAG,aAAa,KAAK,GAAG,iBAAiB,aAAa,CAAC,aAAa,QAAQ;AAExI;AAOD,SAAS,iBAAiBC,QAAwC;CACjE,MAAM,kBAAkB,EAAE,OAAO,YAAY,GAAG,OAAO,KAAK;AAC5D,KAAI,OAAO,eACV,SAAQ,EAAE,eAAe,GAAG,OAAO,eAAe,GAAG,OAAO,WAAW;IAEvE,SAAQ,EAAE,eAAe,GAAG,OAAO,WAAW;AAE/C;IAEY,aAAN,MAAiB;;CAEvB,AAAiB;CAEjB,AAAiB;CACjB,AAAQ;CACR,AAAQ;CACR,AAAQ;;;;;;CAOR,YAA6BC,KAA8BC,qBAA+CC,aAA0B;EAkMpI,KAlM6B;EAkM5B,KAlM0D;EAkMzD,KAlMwG;AACzG,OAAK,aAAa,CAAE;AACpB,OAAK,yBAAyB,IAAI;AAClC,OAAK,kBAAkB;AACvB,OAAK,SAAS;AACd,OAAK,kBAAkB;CACvB;CAED,WAAWC,SAAqC;AAC/C,OAAK,MAAM,SAAS,QACnB,MAAK,IAAI,MAAM,SAAS,MAAM,SAAS,MAAM,OAAO;CAErD;CAED,mBAAmBC,iBAA0C;AAC5D,OAAK,iBAAiB,WAAW;AACjC,OAAK,kBAAkB;CACvB;;;;CAKD,IAAIR,SAAaS,SAAaC,WAAiD;EAC9E,MAAMC,WAAwB;GAC7B,QAAQ,CAAE;GACV;GACA;EACA;AAED,OAAK,KAAK,oBACT,UAAS,OAAO,KAAK,GAAG,UAAU;IAElC,MAAK,oBAAoB,UAAU,SAAS,SAAS,UAAU;AAGhE,MAAI,SAAS,OAAO,WAAW,GAAG;AACjC,QAAK,WAAW,KAAK,SAAS;AAE9B,QAAK,MAAM,UAAU,SAAS,OAC7B,MAAK,uBAAuB,IAAI,iBAAiB,OAAO,EAAE,SAAS;EAEpE;AAGD,OAAK,OAAO;AACZ,SAAO,SAAS,OAAO,SAAS;CAChC;CAED,AAAQ,oBAAoBA,UAAuBX,SAAaS,SAAaC,WAA8C;AAC1H,OAAK,MAAM,YAAY,WAAW;GACjC,MAAM,YAAY,iBAAiB,SAAS;GAC5C,MAAM,qBAAqB,KAAK,uBAAuB,IAAI,UAAU;AACrE,OACC,sBAAsB,QACrB,KAAK,mBAAmB,QAAQ,KAAK,oBAAoB,sBAC1D,YAAY,mBAAmB,QAI/B,UAAS,OAAO,KAAK,SAAS;KACxB;IACN,MAAM,wBAAwB,SAAS,SAAS,WAAW,SAAS;IACpE,MAAM,yBAAyB,SAAS,mBAAmB,SAAS,mBAAmB,QAAQ,SAAS;AAExG,QAAI,0BAA0B,uBAAuB,OACpD,SAAQ,wBAAR;AACC,UAAK,uBAAuB,OAE3B;AAED,UAAK,uBAAuB,OAE3B;AAED,UAAK,uBAAuB,OAC3B,OAAM,IAAI,kBACR,+CAA+C,mBAAmB,QAAQ,eAAe,QAAQ,IAAI,SAAS,KAAK,GAAG,UAAU;IAEnI;SACS,0BAA0B,uBAAuB,QAAQ;AAEnE,UAAK,wBAAwB,UAAU;AAIvC,UAAK,uBAAuB,IAAI,WAAW,SAAS;AAEpD,cAAS,OAAO,KAAK,SAAS;IAC9B,WAAU,0BAA0B,uBAAuB,OAC3D,KAAI,2BAA2B,uBAAuB,UAAU,2BAA2B,uBAAuB,OAEjH,UAAS,OAAO,KAAK,SAAS;IAE9B,OAAM,IAAI,kBACR,sCAAsC,uBAAuB,GAAG,sBAAsB,GAAG,KAAK,UAAU,SAAS,CAAC;IAIrH,OAAM,IAAI,kBACR,sCAAsC,uBAAuB,GAAG,sBAAsB,GAAG,KAAK,UAAU,SAAS,CAAC;GAGrH;EACD;CACD;CAED,AAAQ,wBAAwBE,cAAgCC,aAAqB,GAAS;AAE7F,OAAK,IAAI,IAAI,YAAY,IAAI,KAAK,WAAW,QAAQ,KAAK;GACzD,MAAM,iBAAiB,KAAK,WAAW;AACvC,OAAI,KAAK,oBAAoB,eAC5B;AAKD,oBAAiB,eAAe,QAAQ,CAAC,UAAU,MAAM,cAAc,cAAc,UAAU,iBAAiB,MAAM,KAAK,aAAa;EACxI;CACD;CAED,QAAQ;AACP,MAAI,KAAK,gBACR;AAGD,OAAK,aAAa;CAClB;CAED,YAAoB;AACnB,SAAO,KAAK,WAAW;CACvB;CAED,AAAQ,cAAc;AACrB,MAAI,KAAK,OACR;EAGD,MAAM,OAAO,KAAK,WAAW;AAE7B,MAAI,MAAM;AACT,QAAK,kBAAkB;AAEvB,QAAK,YAAY,KAAK,CACpB,KAAK,MAAM;AACX,SAAK,WAAW,OAAO;AACvB,SAAK,iBAAiB,SAAS,EAAE;AACjC,SAAK,kBAAkB;AAGvB,SAAK,MAAM,SAAS,KAAK,QAAQ;KAChC,MAAM,iBAAiB,iBAAiB,MAAM;AAC9C,SAAI,KAAK,uBAAuB,IAAI,eAAe,KAAK,KACvD,MAAK,uBAAuB,OAAO,eAAe;IAEnD;AAED,SAAK,aAAa;GAClB,EAAC,CACD,MAAM,CAAC,MAAM;AACb,YAAQ,IAAI,cAAc,KAAK,KAAK,KAAK,qBAAqB,SAAS,MAAM,EAAE;AAE/E,SAAK,kBAAkB;AAEvB,UAAM,aAAa,2BAA2B,aAAa,iBAC1D,SAAQ,MAAM,8BAA8B,GAAG,KAAK;GAErD,EAAC;EACH;CACD;CAED,QAAQ;AACP,OAAK,WAAW,OAAO,EAAE;AAEzB,OAAK,kBAAkB;AAEvB,OAAK,MAAM,KAAK,KAAK,uBAAuB,MAAM,CACjD,MAAK,uBAAuB,OAAO,EAAE;CAEtC;CAED,QAAQ;AACP,OAAK,SAAS;CACd;CAED,SAAS;AACR,OAAK,SAAS;AACd,OAAK,OAAO;CACZ;;CAGD,IAAI,oBAAwC;AAC3C,SAAO,KAAK;CACZ;AACD"}