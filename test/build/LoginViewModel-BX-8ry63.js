
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { first, mapNullable, noOp } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertMainOrNode, isApp, isDesktop, isOfflineStorageAvailable } from "./Env-D5xGlXfw.js";
import { getWhitelabelCustomizations } from "./WhitelabelCustomizations-D1L5qbZi.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { px, size, styles, theme } from "./HtmlUtils-C-ecR7U7.js";
import { client } from "./ClientDetector-D0v6Vqu6.js";
import { ApprovalStatus, Keys, SubscriptionType, getCustomerApprovalStatus } from "./TutanotaConstants-3bwAESYA.js";
import { Button, ButtonType } from "./Icon-BuqNK7vz.js";
import { useKeyHandler } from "./KeyManager-B0OGXEyJ.js";
import { AriaLandmarks, Autocomplete, Dialog, TextField, TextFieldType, landmarkAttrs, liveDataAttrs, pureComponent } from "./Dialog-B6-HFvZd.js";
import { AccessBlockedError, AccessDeactivatedError, AccessExpiredError, BadRequestError, ConnectionError, NotAuthenticatedError, TooManyRequestsError } from "./RestError-D17JEBMr.js";
import { CredentialAuthenticationError, isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { DeviceStorageUnavailableError } from "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import { KeyPermanentlyInvalidatedError } from "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { generatedIdToTimestamp } from "./EntityUtils-RQxXZlcV.js";
import { credentialsToUnencrypted } from "./Credentials-BM35X_na.js";
import { Checkbox } from "./Checkbox-WCw-l_7A.js";
import { SessionType } from "./SessionType-rxSDsswH.js";
import { PasswordField } from "./PasswordField-CPKPoLq8.js";
import { LoginButton } from "./LoginButton-DzCRy0Yt.js";

//#region ../src/common/misc/LoginUtils.ts
function checkApprovalStatus(logins, includeInvoiceNotPaidForAdmin, defaultStatus) {
	if (!logins.getUserController().isInternalUser()) return Promise.resolve(true);
	return logins.getUserController().loadCustomer().then((customer) => {
		const approvalStatus = getCustomerApprovalStatus(customer);
		const status = approvalStatus === ApprovalStatus.REGISTRATION_APPROVED && defaultStatus != null ? defaultStatus : approvalStatus;
		if (status === ApprovalStatus.REGISTRATION_APPROVAL_NEEDED || status === ApprovalStatus.DELAYED || status === ApprovalStatus.REGISTRATION_APPROVAL_NEEDED_AND_INITIALLY_ACCESSED) return Dialog.message("waitingForApproval_msg").then(() => false);
else if (status === ApprovalStatus.DELAYED_AND_INITIALLY_ACCESSED) if (new Date().getTime() - generatedIdToTimestamp(customer._id) > 1728e5) return Dialog.message("requestApproval_msg").then(() => true);
else return Dialog.message("waitingForApproval_msg").then(() => false);
else if (status === ApprovalStatus.INVOICE_NOT_PAID) if (logins.getUserController().isGlobalAdmin()) if (includeInvoiceNotPaidForAdmin) return Dialog.message("invoiceNotPaid_msg").then(() => {}).then(() => true);
else return true;
else {
			const errorMessage = lang.makeTranslation("invoiceNotPaidUser_msg", lang.get("invoiceNotPaidUser_msg") + " " + lang.get("contactAdmin_msg"));
			return Dialog.message(errorMessage).then(() => false);
		}
else if (status === ApprovalStatus.SPAM_SENDER) {
			Dialog.message("loginAbuseDetected_msg");
			return false;
		} else if (status === ApprovalStatus.PAID_SUBSCRIPTION_NEEDED) {
			const message = lang.get("upgradeNeeded_msg");
			return Dialog.reminder(lang.get("upgradeReminderTitle_msg"), message).then((confirmed) => {
				if (confirmed) import("./UpgradeSubscriptionWizard-CBu6JZbq.js").then((m) => m.showUpgradeWizard(logins));
				return false;
			});
		} else return true;
	});
}
function getLoginErrorMessage(error, isExternalLogin) {
	switch (error.constructor) {
		case BadRequestError:
		case NotAuthenticatedError:
		case AccessDeactivatedError: return "loginFailed_msg";
		case AccessBlockedError: return "loginFailedOften_msg";
		case AccessExpiredError: return isExternalLogin ? "expiredLink_msg" : "inactiveAccount_msg";
		case TooManyRequestsError: return "tooManyAttempts_msg";
		case CancelledError: return "emptyString_msg";
		case CredentialAuthenticationError: return lang.getTranslation("couldNotUnlockCredentials_msg", { "{reason}": error.message });
		case ConnectionError: return "connectionLostLong_msg";
		default: return "emptyString_msg";
	}
}
function handleExpectedLoginError(error, handler) {
	if (error instanceof BadRequestError || error instanceof NotAuthenticatedError || error instanceof AccessExpiredError || error instanceof AccessBlockedError || error instanceof AccessDeactivatedError || error instanceof TooManyRequestsError || error instanceof CancelledError || error instanceof CredentialAuthenticationError || error instanceof ConnectionError) handler(error);
else throw error;
}
function stringToSubscriptionType(string) {
	switch (string.toLowerCase()) {
		case "business": return SubscriptionType.Business;
		case "private": return SubscriptionType.Personal;
		case "privatepaid": return SubscriptionType.PaidPersonal;
		default: throw new Error(`Failed to get subscription type: ${string}`);
	}
}

//#endregion
//#region ../src/common/login/LoginForm.ts
var import_stream$1 = __toESM(require_stream(), 1);
var LoginForm = class {
	mailAddressTextField;
	passwordTextField;
	autofillUpdateHandler;
	oncreate(vnode) {
		const a = vnode.attrs;
		this.autofillUpdateHandler = import_stream$1.default.combine(() => {
			requestAnimationFrame(() => {
				const oldAddress = a.mailAddress();
				const newAddress = this.mailAddressTextField.value;
				const oldPassword = a.password();
				const newPassword = this.passwordTextField.value;
				if (oldAddress !== newAddress && newAddress != "") a.mailAddress(newAddress);
				if (oldPassword !== newPassword && newPassword != "") a.password(newPassword);
			});
		}, [a.mailAddress, a.password]);
	}
	onremove(vnode) {
		vnode.attrs.password("");
		this.autofillUpdateHandler.end(true);
		this.passwordTextField.value = "";
	}
	view(vnode) {
		const a = vnode.attrs;
		const canSaveCredentials = client.localStorage();
		if (a.savePassword && (isApp() || isDesktop())) a.savePassword(true);
		return mithril_default("form", { onsubmit: (e) => {
			e.preventDefault();
		} }, [
			mithril_default("", mithril_default(TextField, {
				label: "mailAddress_label",
				value: a.mailAddress(),
				oninput: a.mailAddress,
				type: TextFieldType.Email,
				autocompleteAs: Autocomplete.email,
				onDomInputCreated: (dom) => {
					this.mailAddressTextField = dom;
					if (!client.isMobileDevice()) dom.focus();
				},
				keyHandler: (key) => {
					if (key.key != null && key.key.toLowerCase() === Keys.RETURN.code) {
						a.onSubmit(a.mailAddress(), a.password());
						return false;
					}
					return true;
				}
			})),
			mithril_default("", mithril_default(PasswordField, {
				value: a.password(),
				oninput: a.password,
				autocompleteAs: Autocomplete.currentPassword,
				onDomInputCreated: (dom) => this.passwordTextField = dom,
				keyHandler: (key) => {
					if (key.key != null && key.key.toLowerCase() === Keys.RETURN.code) {
						a.onSubmit(a.mailAddress(), a.password());
						return false;
					}
					return true;
				}
			})),
			a.savePassword ? isApp() || isDesktop() ? mithril_default("small.block.content-fg", lang.get("dataWillBeStored_msg")) : mithril_default("", { onkeydown: (e) => {
				useKeyHandler(e, (key) => {
					if (key.key != null && key.key.toLowerCase() === Keys.RETURN.code) {
						a.onSubmit(a.mailAddress(), a.password());
						e.preventDefault();
						return false;
					}
					return false;
				});
			} }, mithril_default(Checkbox, {
				label: () => lang.get("storePassword_action"),
				checked: a.savePassword(),
				onChecked: a.savePassword,
				helpLabel: canSaveCredentials ? lang.makeTranslation("onlyPrivateComputer_msg", lang.get("onlyPrivateComputer_msg") + (isOfflineStorageAvailable() ? "\n" + lang.get("dataWillBeStored_msg") : "")) : "functionNotSupported_msg",
				disabled: !canSaveCredentials
			})) : null,
			mithril_default(".pt", mithril_default(LoginButton, {
				label: isApp() || isDesktop() ? "addAccount_action" : "login_action",
				onclick: () => a.onSubmit(a.mailAddress(), a.password())
			})),
			mithril_default("p.center.statusTextColor.mt-s", { style: { marginBottom: 0 } }, mithril_default("small", liveDataAttrs(), [
				a.helpText ? a.helpText : null,
				" ",
				a.invalidCredentials && a.showRecoveryOption ? mithril_default("a", {
					href: "/recover",
					onclick: (e) => {
						mithril_default.route.set("/recover", {
							mailAddress: a.mailAddress(),
							resetAction: "password"
						});
						e.preventDefault();
					}
				}, lang.get("recoverAccountAccess_action")) : a.accessExpired && a.accessExpired ? mithril_default("a", {
					href: "#",
					onclick: (e) => {
						import("./TakeOverDeletedAddressDialog-CvG2R-Cb.js").then(({ showTakeOverDialog }) => showTakeOverDialog(a.mailAddress(), a.password()));
						e.preventDefault();
					}
				}, lang.get("help_label")) : null
			]))
		]);
	}
};

//#endregion
//#region ../src/common/login/CredentialsSelector.ts
var CredentialsSelector = class {
	view(vnode) {
		const a = vnode.attrs;
		return a.credentials.map((c) => {
			const buttons = [];
			const onCredentialsDeleted = a.onCredentialsDeleted;
			buttons.push(mithril_default(LoginButton, {
				label: lang.makeTranslation("login_label", c.login),
				onclick: () => a.onCredentialsSelected(c)
			}));
			if (onCredentialsDeleted) buttons.push(mithril_default(Button, {
				label: "delete_action",
				click: () => onCredentialsDeleted(c),
				type: ButtonType.Secondary
			}));
			return mithril_default(".flex-space-between.pt.child-grow.last-child-fixed", buttons);
		});
	}
};

//#endregion
//#region ../src/common/gui/BaseTopLevelView.ts
var BaseTopLevelView = class {
	lastPath = "";
	oninit({ attrs }) {
		this.lastPath = attrs.requestedPath;
		this.onNewUrl(attrs.args, attrs.requestedPath);
	}
	onbeforeupdate({ attrs }) {
		if (this.lastPath !== attrs.requestedPath) {
			this.lastPath = attrs.requestedPath;
			this.onNewUrl(attrs.args, attrs.requestedPath);
		}
	}
};

//#endregion
//#region ../src/common/gui/base/DesktopBaseHeader.ts
var DesktopBaseHeader = class {
	view(vnode) {
		return mithril_default(".header-nav.flex.items-center.rel", [this.renderLogo(), vnode.children]);
	}
	renderLogo() {
		return mithril_default(".logo-height", {
			...landmarkAttrs(AriaLandmarks.Banner, "Tuta logo"),
			style: { "margin-left": px(size.drawer_menu_width + size.hpad + size.hpad_button) }
		}, mithril_default.trust(theme.logo));
	}
};

//#endregion
//#region ../src/common/gui/LoginScreenHeader.ts
const LoginScreenHeader = pureComponent(() => styles.isDesktopLayout() ? mithril_default(DesktopBaseHeader) : mithril_default(".mt-l.flex.justify-center.mb", mithril_default(".logo.logo-height.mt-safe-inset", { ...landmarkAttrs(AriaLandmarks.Banner, "Tuta Mail logo") }, mithril_default.trust(theme.logo))));

//#endregion
//#region ../src/common/login/LoginView.ts
assertMainOrNode();
function getWhitelabelRegistrationDomains() {
	return mapNullable(getWhitelabelCustomizations(window), (c) => c.registrationDomains) || [];
}

//#endregion
//#region ../src/common/login/LoginViewModel.ts
var import_stream = __toESM(require_stream(), 1);
assertMainOrNode();
let DisplayMode = function(DisplayMode$1) {
	DisplayMode$1["Credentials"] = "credentials";
	DisplayMode$1["Form"] = "form";
	DisplayMode$1["DeleteCredentials"] = "deleteCredentials";
	return DisplayMode$1;
}({});
let LoginState = function(LoginState$1) {
	LoginState$1["LoggingIn"] = "LoggingIn";
	LoginState$1["UnknownError"] = "UnknownError";
	LoginState$1["InvalidCredentials"] = "InvalidCredentials";
	LoginState$1["AccessExpired"] = "AccessExpired";
	LoginState$1["NotAuthenticated"] = "NotAuthenticated";
	LoginState$1["LoggedIn"] = "LoggedIn";
	return LoginState$1;
}({});
var LoginViewModel = class {
	mailAddress;
	password;
	displayMode;
	state;
	helpText;
	savePassword;
	savedInternalCredentials;
	autoLoginCredentials;
	constructor(loginController, credentialsProvider, secondFactorHandler, deviceConfig, domainConfig, credentialRemovalHandler, pushServiceApp, appLock) {
		this.loginController = loginController;
		this.credentialsProvider = credentialsProvider;
		this.secondFactorHandler = secondFactorHandler;
		this.deviceConfig = deviceConfig;
		this.domainConfig = domainConfig;
		this.credentialRemovalHandler = credentialRemovalHandler;
		this.pushServiceApp = pushServiceApp;
		this.appLock = appLock;
		this.state = LoginState.NotAuthenticated;
		this.displayMode = DisplayMode.Form;
		this.helpText = "emptyString_msg";
		this.mailAddress = (0, import_stream.default)("");
		this.password = (0, import_stream.default)("");
		this.autoLoginCredentials = null;
		this.savePassword = (0, import_stream.default)(false);
		this.savedInternalCredentials = [];
	}
	/**
	* This method should be called right after creation of the view model by whoever created the viewmodel. The view model will not be
	* fully functional before this method has been called!
	* @returns {Promise<void>}
	*/
	async init() {
		await this.updateCachedCredentials();
	}
	async useUserId(userId) {
		this.autoLoginCredentials = await this.credentialsProvider.getCredentialsInfoByUserId(userId);
		if (this.autoLoginCredentials) this.displayMode = DisplayMode.Credentials;
else this.displayMode = DisplayMode.Form;
	}
	canLogin() {
		if (this.displayMode === DisplayMode.Credentials) return this.autoLoginCredentials != null || this.savedInternalCredentials.length === 1;
else if (this.displayMode === DisplayMode.Form) return Boolean(this.mailAddress() && this.password());
else return false;
	}
	async useCredentials(encryptedCredentials) {
		const credentialsInfo = await this.credentialsProvider.getCredentialsInfoByUserId(encryptedCredentials.userId);
		if (credentialsInfo) {
			this.autoLoginCredentials = credentialsInfo;
			this.displayMode = DisplayMode.Credentials;
		}
	}
	async login() {
		if (this.state === LoginState.LoggingIn) return;
		this.state = LoginState.LoggingIn;
		if (this.displayMode === DisplayMode.Credentials || this.displayMode === DisplayMode.DeleteCredentials) await this.autologin();
else if (this.displayMode === DisplayMode.Form) await this.formLogin();
else throw new ProgrammingError(`Cannot login with current display mode: ${this.displayMode}`);
	}
	async deleteCredentials(credentialsInfo) {
		let credentials;
		try {
			/**
			* We have to decrypt the credentials here (and hence deal with any potential errors), because :LoginController.deleteOldSession
			* expects the full credentials. The reason for this is that the accessToken contained within credentials has a double function:
			* 1. It is used as an actual access token to re-authenticate
			* 2. It is used as a session ID
			* Since we want to also delete the session from the server, we need the (decrypted) accessToken in its function as a session id.
			*/
			credentials = await this.unlockAppAndGetCredentials(credentialsInfo.userId);
		} catch (e) {
			if (e instanceof KeyPermanentlyInvalidatedError) {
				await this.credentialsProvider.clearCredentials(e);
				await this.updateCachedCredentials();
				this.state = LoginState.NotAuthenticated;
				return null;
			} else if (e instanceof CancelledError) return null;
else if (e instanceof CredentialAuthenticationError) {
				this.helpText = getLoginErrorMessage(e, false);
				return null;
			} else if (e instanceof DeviceStorageUnavailableError) {
				await this.credentialsProvider.deleteByUserId(credentialsInfo.userId);
				await this.credentialRemovalHandler.onCredentialsRemoved(credentialsInfo);
				await this.updateCachedCredentials();
			} else throw e;
		}
		if (credentials) {
			await this.credentialsProvider.deleteByUserId(credentials.credentialInfo.userId);
			await this.credentialRemovalHandler.onCredentialsRemoved(credentials.credentialInfo);
			await this.updateCachedCredentials();
			try {
				await this.loginController.deleteOldSession(credentials, await this.pushServiceApp?.loadPushIdentifierFromNative() ?? null);
			} catch (e) {
				if (isOfflineError(e)) return "networkError";
			}
		}
		return null;
	}
	/** @throws CredentialAuthenticationError */
	async unlockAppAndGetCredentials(userId) {
		await this.appLock.enforce();
		return await this.credentialsProvider.getDecryptedCredentialsByUserId(userId);
	}
	getSavedCredentials() {
		return this.savedInternalCredentials;
	}
	switchDeleteState() {
		if (this.displayMode === DisplayMode.DeleteCredentials) this.displayMode = DisplayMode.Credentials;
else if (this.displayMode === DisplayMode.Credentials) this.displayMode = DisplayMode.DeleteCredentials;
else throw new ProgrammingError("invalid state");
	}
	showLoginForm() {
		this.displayMode = DisplayMode.Form;
		this.helpText = "emptyString_msg";
	}
	showCredentials() {
		this.displayMode = DisplayMode.Credentials;
		this.helpText = "emptyString_msg";
	}
	shouldShowRecover() {
		return this.domainConfig.firstPartyDomain;
	}
	shouldShowSignup() {
		return this.domainConfig.firstPartyDomain || getWhitelabelRegistrationDomains().length > 0;
	}
	shouldShowAppButtons() {
		return this.domainConfig.firstPartyDomain;
	}
	async updateCachedCredentials() {
		this.savedInternalCredentials = await this.credentialsProvider.getInternalCredentialsInfos();
		this.autoLoginCredentials = null;
		if (this.savedInternalCredentials.length > 0) {
			if (this.displayMode !== DisplayMode.DeleteCredentials) this.displayMode = DisplayMode.Credentials;
		} else this.displayMode = DisplayMode.Form;
	}
	async autologin() {
		let credentials = null;
		try {
			if (this.autoLoginCredentials == null) {
				const allCredentials = await this.credentialsProvider.getInternalCredentialsInfos();
				this.autoLoginCredentials = first(allCredentials);
			}
			if (this.autoLoginCredentials) {
				credentials = await this.unlockAppAndGetCredentials(this.autoLoginCredentials.userId);
				if (credentials) {
					const offlineTimeRange = this.deviceConfig.getOfflineTimeRangeDays(this.autoLoginCredentials.userId);
					const result = await this.loginController.resumeSession(credentials, null, offlineTimeRange);
					if (result.type == "success") await this.onLogin();
else {
						this.state = LoginState.NotAuthenticated;
						this.helpText = "offlineLoginPremiumOnly_msg";
					}
				}
			} else this.state = LoginState.NotAuthenticated;
		} catch (e) {
			if (e instanceof NotAuthenticatedError && this.autoLoginCredentials) {
				const autoLoginCredentials = this.autoLoginCredentials;
				await this.credentialsProvider.deleteByUserId(autoLoginCredentials.userId);
				if (credentials) await this.credentialRemovalHandler.onCredentialsRemoved(credentials.credentialInfo);
				await this.updateCachedCredentials();
				await this.onLoginFailed(e);
			} else if (e instanceof KeyPermanentlyInvalidatedError) {
				await this.credentialsProvider.clearCredentials(e);
				await this.updateCachedCredentials();
				this.state = LoginState.NotAuthenticated;
				this.helpText = "credentialsKeyInvalidated_msg";
			} else if (e instanceof DeviceStorageUnavailableError) {
				this.state = LoginState.NotAuthenticated;
				this.helpText = lang.makeTranslation("help_text", "Could not access secret storage");
			} else await this.onLoginFailed(e);
		}
		if (this.state === LoginState.AccessExpired || this.state === LoginState.InvalidCredentials) {
			this.displayMode = DisplayMode.Form;
			this.mailAddress(this.autoLoginCredentials?.login ?? "");
		}
	}
	async formLogin() {
		const mailAddress = this.mailAddress();
		const password = this.password();
		const savePassword = this.savePassword();
		if (mailAddress === "" || password === "") {
			this.state = LoginState.InvalidCredentials;
			this.helpText = "loginFailed_msg";
			return;
		}
		this.helpText = "login_msg";
		try {
			const sessionType = savePassword ? SessionType.Persistent : SessionType.Login;
			const { credentials, databaseKey } = await this.loginController.createSession(mailAddress, password, sessionType);
			await this.onLogin();
			await this.appLock.enforce();
			const storedCredentialsToDelete = this.savedInternalCredentials.filter((c) => c.login === mailAddress || c.userId === credentials.userId);
			for (const credentialToDelete of storedCredentialsToDelete) {
				const credentials$1 = await this.credentialsProvider.getDecryptedCredentialsByUserId(credentialToDelete.userId);
				if (credentials$1) {
					await this.loginController.deleteOldSession(credentials$1);
					await this.credentialsProvider.deleteByUserId(credentials$1.credentialInfo.userId, { deleteOfflineDb: false });
				}
			}
			if (savePassword) try {
				await this.credentialsProvider.store(credentialsToUnencrypted(credentials, databaseKey));
			} catch (e) {
				if (e instanceof KeyPermanentlyInvalidatedError) {
					await this.credentialsProvider.clearCredentials(e);
					await this.updateCachedCredentials();
				} else if (e instanceof DeviceStorageUnavailableError || e instanceof CancelledError) console.warn("will proceed with ephemeral credentials because device storage is unavailable:", e);
else throw e;
			}
		} catch (e) {
			if (e instanceof DeviceStorageUnavailableError) console.warn("cannot log in: failed to get credentials from device storage", e);
			await this.onLoginFailed(e);
		} finally {
			await this.secondFactorHandler.closeWaitingForSecondFactorDialog();
		}
	}
	async onLogin() {
		this.helpText = "emptyString_msg";
		this.state = LoginState.LoggedIn;
	}
	async onLoginFailed(error) {
		this.helpText = getLoginErrorMessage(error, false);
		if (error instanceof BadRequestError || error instanceof NotAuthenticatedError) this.state = LoginState.InvalidCredentials;
else if (error instanceof AccessExpiredError) this.state = LoginState.AccessExpired;
else this.state = LoginState.UnknownError;
		handleExpectedLoginError(error, noOp);
	}
};

//#endregion
export { BaseTopLevelView, CredentialsSelector, DesktopBaseHeader, DisplayMode, LoginForm, LoginState, LoginViewModel, checkApprovalStatus, getLoginErrorMessage, getWhitelabelRegistrationDomains, handleExpectedLoginError, stringToSubscriptionType };
//# sourceMappingURL=LoginViewModel-BX-8ry63.js.map