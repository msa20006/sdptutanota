
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { NBSP, TypeRef, assertNotNull, base64ExtToBase64, base64ToUint8Array, defer, delay, downcast, getFirstOrThrow, neverNull, noOp, ofClass, pMap } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertMainOrNode, isIOSApp } from "./Env-D5xGlXfw.js";
import { InfoLink, lang } from "./LanguageViewModel-BNC5ekpO.js";
import { DefaultAnimationTime, px, size, styles, theme } from "./HtmlUtils-C-ecR7U7.js";
import { client } from "./ClientDetector-D0v6Vqu6.js";
import { AccountType, AvailablePlans, BookingFailureReason, BookingItemFeatureType, Const, DEFAULT_FREE_MAIL_ADDRESS_SIGNUP_DOMAIN, DEFAULT_PAID_MAIL_ADDRESS_SIGNUP_DOMAIN, FeatureType, HighlightedPlans, Keys, LegacyPlans, NewBusinessPlans, NewPaidPlans, NewPersonalPlans, PaymentDataResultType, PaymentMethodType, PaymentMethodTypeToName, PlanType, PlanTypeToName, SubscriptionType, TUTA_MAIL_ADDRESS_SIGNUP_DOMAINS, UnsubscribeFailureReason, getClientType, getDefaultPaymentMethod, getPaymentMethodType } from "./TutanotaConstants-3bwAESYA.js";
import { BaseButton, BootIcons, Button, ButtonType, Icon } from "./Icon-BuqNK7vz.js";
import { PayPalLogo, VisSignupImage } from "./Icons-Dl3nFav5.js";
import { Autocapitalize, Autocomplete, Dialog, DialogType, DropDownSelector, TextField, attachDropdown, inputLineHeight$1 as inputLineHeight, renderCountryDropdown } from "./Dialog-B6-HFvZd.js";
import { Countries, CountryType, getByAbbreviation } from "./CountryList-DkVQtcTj.js";
import { ButtonSize, IconButton } from "./IconButton-DsU60HJ_.js";
import { AccessDeactivatedError, BadGatewayError, BadRequestError, InvalidDataError, PreconditionFailedError } from "./RestError-D17JEBMr.js";
import { MobilePaymentError } from "./ErrorUtils-o1-v67Dd.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { formatMailAddressFromParts } from "./Formatter-zB15D6XI.js";
import { AccountingInfoTypeRef, InvoiceInfoTypeRef, createSurveyData, createSwitchAccountTypePostIn } from "./TypeRefs-BP1jvX9p.js";
import { LocationService, SwitchAccountTypeService } from "./Services-CZFE0084.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { isMailAddress } from "./FormatValidator-2BBermUe.js";
import { showProgressDialog } from "./ProgressDialog-CJfJjh62.js";
import { isTutaMailAddress } from "./SharedMailUtils-AmFaSJP6.js";
import { ExternalLink } from "./ExternalLink-rsCBSC7U.js";
import { Checkbox } from "./Checkbox-WCw-l_7A.js";
import { SessionType } from "./SessionType-rxSDsswH.js";
import { deviceConfig } from "./DeviceConfig-payZM407.js";
import { RatingCheckResult, getRatingAllowed } from "./InAppRatingUtils-DwsFPPTC.js";
import { showAppRatingDialog } from "./InAppRatingDialog-Cp5yqAc1.js";
import { isCustomizationEnabledForCustomer } from "./CustomerUtils-DmaZpb7Y.js";
import { formatNameAndAddress } from "./CommonFormatter-DiwVeRKZ.js";
import { HtmlEditor, HtmlEditorMode } from "./HtmlEditor-DkqWVGt0.js";
import { getWhitelabelRegistrationDomains, stringToSubscriptionType } from "./LoginViewModel-BX-8ry63.js";
import { LoginButton } from "./LoginButton-DzCRy0Yt.js";
import { StorageBehavior } from "./UsageTestModel-CjGx3RZo.js";
import { PasswordForm, PasswordModel } from "./PasswordForm-f7LrLbA9.js";
import { WizardEventType, createWizardDialog, emitWizardEvent, wizardPageWrapper } from "./WizardDialog-DYBfLN1U.js";
import { SegmentControl } from "./SegmentControl-DpoAc28w.js";
import { UpgradeType, appStorePlanName, getLazyLoadedPayPalUrl, getPreconditionFailedPaymentMsg, hasRunningAppStoreSubscription, queryAppStoreSubscriptionOwnership } from "./SubscriptionUtils-D0qLWHbE.js";
import { RecoverCodeField } from "./RecoverCodeDialog-nRHUDXK5.js";
import { isPaidPlanDomain } from "./MailAddressesUtils-yYLKhrr9.js";
import { FeatureListProvider, PaymentInterval, PriceAndConfigProvider, UpgradePriceType, asPaymentInterval, formatMonthlyPrice, formatPriceWithInfo, getDisplayNameOfPlanType, getPaymentMethodName, isReferenceDateWithinCyberMondayCampaign } from "./PriceUtils-DA-dFW8L.js";
import { BOX_MARGIN, BuyOptionBox, BuyOptionDetails, CURRENT_PRIVACY_VERSION, CURRENT_TERMS_VERSION, TermsSection, getActiveSubscriptionActionButtonReplacement, renderTermsAndConditionsButton } from "./PurchaseGiftCardDialog-B0R5zMg4.js";
import { MessageBox } from "./MessageBox-C_T1dO_P.js";
import { SimplifiedCreditCardViewModel, runCaptchaFlow } from "./Captcha-BgtCMZz1.js";
import { mailLocator } from "./mailLocator-CrvEYt1k.js";

//#region ../src/common/subscription/SubscriptionSelector.ts
const BusinessUseItems = [{
	name: lang.get("pricing.privateUse_label"),
	value: false
}, {
	name: lang.get("pricing.businessUse_label"),
	value: true
}];
function getActionButtonBySubscription(actionButtons, subscription) {
	const ret = actionButtons[subscription];
	if (ret == null) throw new ProgrammingError("Plan is not valid");
	return () => mithril_default(LoginButton, ret());
}
var SubscriptionSelector = class {
	containerDOM = null;
	featuresExpanded = {
		[PlanType.Free]: false,
		[PlanType.Revolutionary]: false,
		[PlanType.Legend]: false,
		[PlanType.Essential]: false,
		[PlanType.Advanced]: false,
		[PlanType.Unlimited]: false,
		All: false
	};
	oninit(vnode) {
		const acceptedPlans = vnode.attrs.acceptedPlans;
		const onlyBusinessPlansAccepted = acceptedPlans.every((plan) => NewBusinessPlans.includes(plan));
		if (onlyBusinessPlansAccepted) vnode.attrs.options.businessUse(true);
	}
	renderHeadline(msg, currentPlanType, priceInfoTextId, isBusiness, isCyberMonday) {
		const wrapInDiv = (text, style) => {
			return mithril_default(".b.center", { style }, text);
		};
		if (msg) return wrapInDiv(lang.getTranslationText(msg));
else if (currentPlanType != null && LegacyPlans.includes(currentPlanType)) return wrapInDiv(lang.get("currentPlanDiscontinued_msg"));
		if (priceInfoTextId && lang.exists(priceInfoTextId)) return wrapInDiv(lang.get(priceInfoTextId));
		if (isCyberMonday && !isBusiness) return wrapInDiv(lang.get("pricing.cyber_monday_msg"), {
			width: "230px",
			margin: "1em auto 0 auto"
		});
	}
	view(vnode) {
		const { acceptedPlans, priceInfoTextId, msg, featureListProvider, currentPlanType, options, boxWidth } = vnode.attrs;
		const columnWidth = boxWidth + BOX_MARGIN * 2;
		const inMobileView = (this.containerDOM && this.containerDOM.clientWidth < columnWidth * 2) == true;
		const featureExpander = this.renderFeatureExpanders(inMobileView, featureListProvider);
		let additionalInfo;
		let plans;
		const currentPlan = currentPlanType;
		const signup$1 = currentPlan == null;
		const onlyBusinessPlansAccepted = acceptedPlans.every((plan) => NewBusinessPlans.includes(plan));
		const onlyPersonalPlansAccepted = acceptedPlans.every((plan) => NewPersonalPlans.includes(plan));
		const showBusinessSelector = !onlyBusinessPlansAccepted && !onlyPersonalPlansAccepted && !isIOSApp();
		const isCyberMonday = isReferenceDateWithinCyberMondayCampaign(Const.CURRENT_DATE ?? new Date());
		let subscriptionPeriodInfoMsg = !signup$1 && currentPlan !== PlanType.Free ? lang.get("switchSubscriptionInfo_msg") + " " : "";
		if (options.businessUse()) {
			plans = [
				PlanType.Essential,
				PlanType.Advanced,
				PlanType.Unlimited
			];
			subscriptionPeriodInfoMsg += lang.get("pricing.subscriptionPeriodInfoBusiness_msg");
		} else {
			if (inMobileView) if (isCyberMonday) plans = [
				PlanType.Legend,
				PlanType.Revolutionary,
				PlanType.Free
			];
else plans = [
				PlanType.Revolutionary,
				PlanType.Legend,
				PlanType.Free
			];
else if (isCyberMonday) plans = [
				PlanType.Free,
				PlanType.Legend,
				PlanType.Revolutionary
			];
else plans = [
				PlanType.Free,
				PlanType.Revolutionary,
				PlanType.Legend
			];
			subscriptionPeriodInfoMsg += lang.get("pricing.subscriptionPeriodInfoPrivate_msg");
		}
		const shouldShowFirstYearDiscountNotice = !isIOSApp() && isCyberMonday && !options.businessUse() && options.paymentInterval() === PaymentInterval.Yearly;
		additionalInfo = mithril_default(".flex.flex-column.items-center", [
			featureExpander.All,
			mithril_default(".smaller.mb.center", subscriptionPeriodInfoMsg),
			shouldShowFirstYearDiscountNotice && mithril_default(".smaller.mb.center", `* ${lang.get("pricing.legendAsterisk_msg")}`)
		]);
		const buyBoxesViewPlacement = plans.filter((plan) => acceptedPlans.includes(plan) || currentPlanType === plan).map((personalPlan, i) => {
			return [this.renderBuyOptionBox(vnode.attrs, inMobileView, personalPlan, isCyberMonday), this.renderBuyOptionDetails(vnode.attrs, i === 0, personalPlan, featureExpander, isCyberMonday)];
		});
		return mithril_default("", { lang: lang.code }, [
			showBusinessSelector ? mithril_default(SegmentControl, {
				selectedValue: options.businessUse(),
				onValueSelected: options.businessUse,
				items: BusinessUseItems
			}) : null,
			this.renderHeadline(msg, currentPlanType, priceInfoTextId, options.businessUse(), isCyberMonday),
			mithril_default(".flex.center-horizontally.wrap", {
				"data-testid": "dialog:select-subscription",
				oncreate: (vnode$1) => {
					this.containerDOM = vnode$1.dom;
					mithril_default.redraw();
				},
				style: { "column-gap": px(BOX_MARGIN) }
			}, mithril_default(".plans-grid", buyBoxesViewPlacement.flat()), additionalInfo)
		]);
	}
	renderBuyOptionBox(attrs, inMobileView, planType, isCyberMonday) {
		return mithril_default("", { style: { width: attrs.boxWidth ? px(attrs.boxWidth) : px(230) } }, mithril_default(BuyOptionBox, this.createBuyOptionBoxAttr(attrs, planType, inMobileView, isCyberMonday)));
	}
	renderBuyOptionDetails(attrs, renderCategoryTitle, planType, featureExpander, isCyberMonday) {
		return mithril_default("", { style: { width: attrs.boxWidth ? px(attrs.boxWidth) : px(230) } }, mithril_default(BuyOptionDetails, this.createBuyOptionBoxDetailsAttr(attrs, planType, renderCategoryTitle, isCyberMonday)), featureExpander[planType]);
	}
	createBuyOptionBoxAttr(selectorAttrs, targetSubscription, mobile, isCyberMonday) {
		const { priceAndConfigProvider } = selectorAttrs;
		const interval = selectorAttrs.options.paymentInterval();
		const upgradingToPaidAccount = !selectorAttrs.currentPlanType || selectorAttrs.currentPlanType === PlanType.Free;
		const isHighlighted = (() => {
			if (isCyberMonday) return targetSubscription === PlanType.Legend;
			return upgradingToPaidAccount && HighlightedPlans.includes(targetSubscription);
		})();
		const multiuser = NewBusinessPlans.includes(targetSubscription) || LegacyPlans.includes(targetSubscription) || selectorAttrs.multipleUsersAllowed;
		const subscriptionPrice = priceAndConfigProvider.getSubscriptionPrice(interval, targetSubscription, UpgradePriceType.PlanActualPrice);
		let priceStr;
		let referencePriceStr = undefined;
		if (isIOSApp()) {
			const prices = priceAndConfigProvider.getMobilePrices().get(PlanTypeToName[targetSubscription].toLowerCase());
			if (prices != null) if (isCyberMonday && targetSubscription === PlanType.Legend && interval == PaymentInterval.Yearly) {
				const revolutionaryPrice = priceAndConfigProvider.getMobilePrices().get(PlanTypeToName[PlanType.Revolutionary].toLowerCase());
				priceStr = revolutionaryPrice?.displayYearlyPerMonth ?? NBSP;
				referencePriceStr = prices?.displayYearlyPerMonth;
			} else switch (interval) {
				case PaymentInterval.Monthly:
					priceStr = prices.displayMonthlyPerMonth;
					break;
				case PaymentInterval.Yearly:
					priceStr = prices.displayYearlyPerYear;
					break;
			}
else {
				priceStr = NBSP;
				referencePriceStr = NBSP;
			}
		} else {
			const referencePrice = priceAndConfigProvider.getSubscriptionPrice(interval, targetSubscription, UpgradePriceType.PlanReferencePrice);
			priceStr = formatMonthlyPrice(subscriptionPrice, interval);
			if (referencePrice > subscriptionPrice) referencePriceStr = formatMonthlyPrice(referencePrice, interval);
else if (interval == PaymentInterval.Yearly && subscriptionPrice !== 0 && !isCyberMonday) {
				const monthlyReferencePrice = priceAndConfigProvider.getSubscriptionPrice(PaymentInterval.Monthly, targetSubscription, UpgradePriceType.PlanActualPrice);
				referencePriceStr = formatMonthlyPrice(monthlyReferencePrice, PaymentInterval.Monthly);
			}
		}
		const asteriskOrEmptyString = !isIOSApp() && isCyberMonday && targetSubscription === PlanType.Legend && interval === PaymentInterval.Yearly ? "*" : "";
		return {
			heading: getDisplayNameOfPlanType(targetSubscription),
			actionButton: selectorAttrs.currentPlanType === targetSubscription ? getActiveSubscriptionActionButtonReplacement() : getActionButtonBySubscription(selectorAttrs.actionButtons, targetSubscription),
			price: priceStr,
			referencePrice: referencePriceStr,
			priceHint: lang.makeTranslation("price_hint", `${getPriceHint(subscriptionPrice, interval, multiuser)}${asteriskOrEmptyString}`),
			helpLabel: getHelpLabel(targetSubscription, selectorAttrs.options.businessUse()),
			width: selectorAttrs.boxWidth,
			height: selectorAttrs.boxHeight,
			selectedPaymentInterval: selectorAttrs.allowSwitchingPaymentInterval && targetSubscription !== PlanType.Free ? selectorAttrs.options.paymentInterval : null,
			accountPaymentInterval: interval,
			highlighted: isHighlighted,
			mobile,
			bonusMonths: targetSubscription !== PlanType.Free && interval === PaymentInterval.Yearly ? Number(selectorAttrs.priceAndConfigProvider.getRawPricingData().bonusMonthsForYearlyPlan) : 0,
			targetSubscription
		};
	}
	createBuyOptionBoxDetailsAttr(selectorAttrs, targetSubscription, renderCategoryTitle, isCyberMonday) {
		const { featureListProvider } = selectorAttrs;
		const subscriptionFeatures = featureListProvider.getFeatureList(targetSubscription);
		const categoriesToShow = subscriptionFeatures.categories.map((fc) => {
			return localizeFeatureCategory(fc, targetSubscription, selectorAttrs);
		}).filter((fc) => fc != null);
		const isLegend = targetSubscription === PlanType.Legend;
		const isYearly = selectorAttrs.options.paymentInterval() === PaymentInterval.Yearly;
		return {
			categories: categoriesToShow,
			featuresExpanded: this.featuresExpanded[targetSubscription] || this.featuresExpanded.All,
			renderCategoryTitle,
			iconStyle: isCyberMonday && isYearly && isLegend ? { fill: theme.content_accent_cyber_monday } : undefined
		};
	}
	/**
	* Renders the feature expanders depending on whether currently displaying the feature list in single-column layout or in multi-column layout.
	* If a specific expander is not needed and thus should not be renderer, null | undefined is returned
	*/
	renderFeatureExpanders(inMobileView, featureListProvider) {
		if (!featureListProvider.featureLoadingDone()) return {
			[PlanType.Free]: null,
			[PlanType.Revolutionary]: null,
			[PlanType.Legend]: null,
			[PlanType.Essential]: null,
			[PlanType.Advanced]: null,
			[PlanType.Unlimited]: null,
			All: null
		};
		if (inMobileView) {
			if (this.featuresExpanded.All) for (const k in this.featuresExpanded) this.featuresExpanded[k] = true;
			return {
				[PlanType.Free]: this.renderExpander(PlanType.Free),
				[PlanType.Revolutionary]: this.renderExpander(PlanType.Revolutionary),
				[PlanType.Legend]: this.renderExpander(PlanType.Legend),
				[PlanType.Advanced]: this.renderExpander(PlanType.Advanced),
				[PlanType.Essential]: this.renderExpander(PlanType.Essential),
				[PlanType.Unlimited]: this.renderExpander(PlanType.Unlimited),
				All: null
			};
		} else {
			for (const k in this.featuresExpanded) this.featuresExpanded[k] = this.featuresExpanded.All;
			return Object.assign({}, { All: this.renderExpander("All") });
		}
	}
	/**
	* Renders a single feature expander.
	* @param subType The current expander that should be rendered
	* @private
	*/
	renderExpander(subType) {
		return this.featuresExpanded[subType] ? null : mithril_default(Button, {
			label: "pricing.showAllFeatures",
			type: ButtonType.Secondary,
			click: (event) => {
				this.featuresExpanded[subType] = !this.featuresExpanded[subType];
				event.stopPropagation();
			}
		});
	}
};
function localizeFeatureListItem(item, targetSubscription, attrs) {
	const text = tryGetTranslation(item.text, getReplacement(item.replacements, targetSubscription, attrs));
	if (text == null) return null;
	if (!item.toolTip) return {
		text,
		key: item.text,
		antiFeature: item.antiFeature,
		omit: item.omit,
		heart: !!item.heart
	};
else {
		const toolTipText = tryGetTranslation(item.toolTip);
		if (toolTipText === null) return null;
		const toolTip = item.toolTip.endsWith("_markdown") ? mithril_default.trust(toolTipText) : toolTipText;
		return {
			text,
			toolTip,
			key: item.text,
			antiFeature: item.antiFeature,
			omit: item.omit,
			heart: !!item.heart
		};
	}
}
function localizeFeatureCategory(category, targetSubscription, attrs) {
	const title = tryGetTranslation(category.title);
	const features = downcast(category.features.map((f) => localizeFeatureListItem(f, targetSubscription, attrs)).filter((it) => it != null));
	return {
		title,
		key: category.title,
		features,
		featureCount: category.featureCount
	};
}
function tryGetTranslation(key, replacements) {
	try {
		return lang.get(key, replacements);
	} catch (e) {
		console.log("could not translate feature text for key", key, "hiding feature item");
		return null;
	}
}
function getReplacement(key, subscription, attrs) {
	const { priceAndConfigProvider } = attrs;
	switch (key) {
		case "customDomains": return { "{amount}": priceAndConfigProvider.getPlanPricesForPlan(subscription).customDomains };
		case "mailAddressAliases": return { "{amount}": priceAndConfigProvider.getPlanPricesForPlan(subscription).includedAliases };
		case "storage": return { "{amount}": priceAndConfigProvider.getPlanPricesForPlan(subscription).includedStorage };
	}
}
function getHelpLabel(planType, businessUse) {
	if (planType === PlanType.Free) return "pricing.upgradeLater_msg";
	return businessUse ? "pricing.excludesTaxes_msg" : "pricing.includesTaxes_msg";
}
function getPriceHint(subscriptionPrice, paymentInterval, multiuser) {
	if (subscriptionPrice > 0) if (multiuser) return lang.get(paymentInterval === PaymentInterval.Yearly ? "pricing.perUserMonthPaidYearly_label" : "pricing.perUserMonth_label");
else return lang.get(paymentInterval === PaymentInterval.Yearly ? "pricing.perMonthPaidYearly_label" : "pricing.perMonth_label");
	return "";
}

//#endregion
//#region ../src/common/subscription/SwitchSubscriptionDialogModel.ts
var SwitchSubscriptionDialogModel = class {
	currentPlanInfo;
	constructor(customer, accountingInfo, planType, lastBooking) {
		this.customer = customer;
		this.accountingInfo = accountingInfo;
		this.planType = planType;
		this.lastBooking = lastBooking;
		this.currentPlanInfo = this._initCurrentPlanInfo();
	}
	_initCurrentPlanInfo() {
		const paymentInterval = asPaymentInterval(this.accountingInfo.paymentInterval);
		return {
			businessUse: this.customer.businessUse,
			planType: this.planType,
			paymentInterval
		};
	}
	/**
	* Check if the user's current plan has multiple users due to a legacy agreement and will continue to do so if the user switches plans.
	*
	* @return true if multiple users are supported due to legacy, false if not; note that returning false does not mean that the current plan does not actually support multiple users
	*/
	multipleUsersStillSupportedLegacy() {
		if (isCustomizationEnabledForCustomer(this.customer, FeatureType.MultipleUsers)) return true;
		if (LegacyPlans.includes(this.planType)) {
			const userItem = this.lastBooking.items.find((item) => item.featureType === BookingItemFeatureType.LegacyUsers);
			const sharedMailItem = this.lastBooking.items.find((item) => item.featureType === BookingItemFeatureType.SharedMailGroup);
			const localAdminItem = this.lastBooking.items.find((item) => item.featureType === BookingItemFeatureType.LocalAdminGroup);
			const userCount = Number(userItem?.currentCount);
			const sharedMailCount = sharedMailItem ? Number(sharedMailItem.currentCount) : 0;
			const localAdminCount = localAdminItem ? Number(localAdminItem.currentCount) : 0;
			return userCount + sharedMailCount + localAdminCount > 1;
		}
		return false;
	}
};

//#endregion
//#region ../src/common/subscription/InvoiceDataInput.ts
var import_stream$7 = __toESM(require_stream(), 1);
let InvoiceDataInputLocation = function(InvoiceDataInputLocation$1) {
	InvoiceDataInputLocation$1[InvoiceDataInputLocation$1["InWizard"] = 0] = "InWizard";
	InvoiceDataInputLocation$1[InvoiceDataInputLocation$1["Other"] = 1] = "Other";
	return InvoiceDataInputLocation$1;
}({});
var InvoiceDataInput = class {
	invoiceAddressComponent;
	selectedCountry;
	vatNumber = "";
	__paymentPaypalTest;
	constructor(businessUse, invoiceData, location = InvoiceDataInputLocation.Other) {
		this.businessUse = businessUse;
		this.location = location;
		this.__paymentPaypalTest = locator.usageTestController.getTest("payment.paypal");
		this.invoiceAddressComponent = new HtmlEditor().setStaticNumberOfLines(5).showBorders().setPlaceholderId("invoiceAddress_label").setMode(HtmlEditorMode.HTML).setHtmlMonospace(false).setValue(invoiceData.invoiceAddress);
		this.selectedCountry = (0, import_stream$7.default)(invoiceData.country);
		this.view = this.view.bind(this);
		this.oncreate = this.oncreate.bind(this);
	}
	view() {
		return [
			this.businessUse || this.location !== InvoiceDataInputLocation.InWizard ? mithril_default("", [mithril_default(".pt", mithril_default(this.invoiceAddressComponent)), mithril_default(".small", lang.get(this.businessUse ? "invoiceAddressInfoBusiness_msg" : "invoiceAddressInfoPrivate_msg"))]) : null,
			renderCountryDropdown({
				selectedCountry: this.selectedCountry(),
				onSelectionChanged: this.selectedCountry,
				helpLabel: () => lang.get("invoiceCountryInfoConsumer_msg")
			}),
			this.isVatIdFieldVisible() ? mithril_default(TextField, {
				label: "invoiceVatIdNo_label",
				value: this.vatNumber,
				oninput: (value) => this.vatNumber = value,
				helpLabel: () => lang.get("invoiceVatIdNoInfoBusiness_msg")
			}) : null
		];
	}
	oncreate() {
		locator.serviceExecutor.get(LocationService, null).then((location) => {
			if (!this.selectedCountry()) {
				const country = Countries.find((c) => c.a === location.country);
				if (country) {
					this.selectedCountry(country);
					mithril_default.redraw();
				}
			}
		});
	}
	validateInvoiceData() {
		const address = this.getAddress();
		const countrySelected = this.selectedCountry() != null;
		if (this.businessUse) {
			if (address.trim() === "" || address.split("\n").length > 5) return "invoiceAddressInfoBusiness_msg";
else if (!countrySelected) return "invoiceCountryInfoBusiness_msg";
		} else if (!countrySelected) return "invoiceCountryInfoBusiness_msg";
else if (address.split("\n").length > 4) return "invoiceAddressInfoBusiness_msg";
		this.__paymentPaypalTest?.getStage(3).complete();
		return null;
	}
	getInvoiceData() {
		const address = this.getAddress();
		const selectedCountry = this.selectedCountry();
		return {
			invoiceAddress: address,
			country: selectedCountry,
			vatNumber: selectedCountry?.t === CountryType.EU && this.businessUse ? this.vatNumber : ""
		};
	}
	isVatIdFieldVisible() {
		const selectedCountry = this.selectedCountry();
		return this.businessUse && selectedCountry != null && selectedCountry.t === CountryType.EU;
	}
	getAddress() {
		return this.invoiceAddressComponent.getValue().split("\n").filter((line) => line.trim().length > 0).join("\n");
	}
};

//#endregion
//#region ../src/common/subscription/SimplifiedCreditCardInput.ts
function restoreSelection(domInput) {
	const { selectionStart, selectionEnd, selectionDirection } = domInput;
	const isAtEnd = domInput.value.length === selectionStart;
	setTimeout(() => {
		const currentLength = domInput.value.length;
		domInput.setSelectionRange(isAtEnd ? currentLength : selectionStart, isAtEnd ? currentLength : selectionEnd, selectionDirection ?? undefined);
	}, 0);
}
var SimplifiedCreditCardInput = class {
	dateFieldLeft = false;
	numberFieldLeft = false;
	cvvFieldLeft = false;
	ccNumberDom = null;
	expDateDom = null;
	view(vnode) {
		let { viewModel } = vnode.attrs;
		return [
			mithril_default(TextField, {
				label: "creditCardNumber_label",
				helpLabel: () => this.renderCcNumberHelpLabel(viewModel),
				value: viewModel.creditCardNumber,
				oninput: (newValue) => {
					viewModel.creditCardNumber = newValue;
					restoreSelection(this.ccNumberDom);
				},
				onblur: () => this.numberFieldLeft = true,
				autocompleteAs: Autocomplete.ccNumber,
				onDomInputCreated: (dom) => this.ccNumberDom = dom
			}),
			mithril_default(TextField, {
				label: "creditCardExpirationDateWithFormat_label",
				value: viewModel.expirationDate,
				helpLabel: () => this.dateFieldLeft ? lang.get(viewModel.getExpirationDateErrorHint() ?? "emptyString_msg") : lang.get("emptyString_msg"),
				onblur: () => this.dateFieldLeft = true,
				oninput: (newValue) => {
					viewModel.expirationDate = newValue;
					restoreSelection(this.expDateDom);
				},
				onDomInputCreated: (dom) => this.expDateDom = dom,
				autocompleteAs: Autocomplete.ccExp
			}),
			mithril_default(TextField, {
				label: lang.makeTranslation("cvv", viewModel.getCvvLabel()),
				value: viewModel.cvv,
				helpLabel: () => this.renderCvvNumberHelpLabel(viewModel),
				oninput: (newValue) => viewModel.cvv = newValue,
				onblur: () => this.cvvFieldLeft = true,
				autocompleteAs: Autocomplete.ccCsc
			})
		];
	}
	renderCcNumberHelpLabel(model) {
		const hint = model.getCreditCardNumberHint();
		const error = model.getCreditCardNumberErrorHint();
		if (this.numberFieldLeft) if (hint) return error ? lang.get("creditCardHintWithError_msg", {
			"{hint}": hint,
			"{errorText}": error
		}) : hint;
else return error ? error : lang.get("emptyString_msg");
else return hint ?? lang.get("emptyString_msg");
	}
	renderCvvNumberHelpLabel(model) {
		const cvvHint = model.getCvvHint();
		const cvvError = model.getCvvErrorHint();
		if (this.cvvFieldLeft) if (cvvHint) return cvvError ? lang.get("creditCardHintWithError_msg", {
			"{hint}": cvvHint,
			"{errorText}": cvvError
		}) : cvvHint;
else return cvvError ? cvvError : lang.get("emptyString_msg");
else return cvvHint ?? lang.get("emptyString_msg");
	}
};

//#endregion
//#region ../src/common/subscription/PaymentMethodInput.ts
var PaymentMethodInput = class {
	ccViewModel;
	_payPalAttrs;
	_selectedCountry;
	_selectedPaymentMethod;
	_subscriptionOptions;
	_accountingInfo;
	_entityEventListener;
	__paymentPaypalTest;
	constructor(subscriptionOptions, selectedCountry, accountingInfo, payPalRequestUrl, defaultPaymentMethod) {
		this._selectedCountry = selectedCountry;
		this._subscriptionOptions = subscriptionOptions;
		this.ccViewModel = new SimplifiedCreditCardViewModel(lang);
		this._accountingInfo = accountingInfo;
		this._payPalAttrs = {
			payPalRequestUrl,
			accountingInfo: this._accountingInfo
		};
		this.__paymentPaypalTest = locator.usageTestController.getTest("payment.paypal");
		this._entityEventListener = (updates) => {
			return pMap(updates, (update) => {
				if (isUpdateForTypeRef(AccountingInfoTypeRef, update)) return locator.entityClient.load(AccountingInfoTypeRef, update.instanceId).then((accountingInfo$1) => {
					this.__paymentPaypalTest?.getStage(2).complete();
					this._accountingInfo = accountingInfo$1;
					this._payPalAttrs.accountingInfo = accountingInfo$1;
					mithril_default.redraw();
				});
			}).then(noOp);
		};
		this._selectedPaymentMethod = defaultPaymentMethod;
	}
	oncreate() {
		locator.eventController.addEntityListener(this._entityEventListener);
	}
	onremove() {
		locator.eventController.removeEntityListener(this._entityEventListener);
	}
	view() {
		switch (this._selectedPaymentMethod) {
			case PaymentMethodType.Invoice: return mithril_default(".flex-center", mithril_default(MessageBox, { style: { marginTop: px(16) } }, this.isOnAccountAllowed() ? lang.get("paymentMethodOnAccount_msg") + " " + lang.get("paymentProcessingTime_msg") : lang.get("paymentMethodNotAvailable_msg")));
			case PaymentMethodType.AccountBalance: return mithril_default(".flex-center", mithril_default(MessageBox, { style: { marginTop: px(16) } }, lang.get("paymentMethodAccountBalance_msg")));
			case PaymentMethodType.Paypal: return mithril_default(PaypalInput, this._payPalAttrs);
			default: return mithril_default(SimplifiedCreditCardInput, { viewModel: this.ccViewModel });
		}
	}
	isOnAccountAllowed() {
		const country = this._selectedCountry();
		if (!country) return false;
else if (this._accountingInfo.paymentMethod === PaymentMethodType.Invoice) return true;
else if (this._subscriptionOptions.businessUse() && country.t !== CountryType.OTHER) return true;
else return false;
	}
	isPaypalAssigned() {
		return isPaypalAssigned(this._accountingInfo);
	}
	validatePaymentData() {
		if (!this._selectedPaymentMethod) return "invoicePaymentMethodInfo_msg";
else if (this._selectedPaymentMethod === PaymentMethodType.Invoice) if (!this.isOnAccountAllowed()) return "paymentMethodNotAvailable_msg";
else return null;
else if (this._selectedPaymentMethod === PaymentMethodType.Paypal) return isPaypalAssigned(this._accountingInfo) ? null : "paymentDataPayPalLogin_msg";
else if (this._selectedPaymentMethod === PaymentMethodType.CreditCard) return this.ccViewModel.validateCreditCardPaymentData();
else return null;
	}
	updatePaymentMethod(value, paymentData) {
		this._selectedPaymentMethod = value;
		if (value === PaymentMethodType.CreditCard) {
			if (paymentData) this.ccViewModel.setCreditCardData(paymentData.creditCardData);
			if (this.__paymentPaypalTest) this.__paymentPaypalTest.active = false;
		} else if (value === PaymentMethodType.Paypal) {
			this._payPalAttrs.payPalRequestUrl.getAsync().then(() => mithril_default.redraw());
			if (this.__paymentPaypalTest) this.__paymentPaypalTest.active = true;
			this.__paymentPaypalTest?.getStage(0).complete();
		}
		mithril_default.redraw();
	}
	getPaymentData() {
		return {
			paymentMethod: this._selectedPaymentMethod,
			creditCardData: this._selectedPaymentMethod === PaymentMethodType.CreditCard ? this.ccViewModel.getCreditCardData() : null
		};
	}
	getVisiblePaymentMethods() {
		const availablePaymentMethods = [{
			name: lang.get("paymentMethodCreditCard_label"),
			value: PaymentMethodType.CreditCard
		}, {
			name: "PayPal",
			value: PaymentMethodType.Paypal
		}];
		if (this._subscriptionOptions.businessUse() || this._accountingInfo.paymentMethod === PaymentMethodType.Invoice) availablePaymentMethods.push({
			name: lang.get("paymentMethodOnAccount_label"),
			value: PaymentMethodType.Invoice
		});
		if (this._accountingInfo.paymentMethod === PaymentMethodType.AccountBalance) availablePaymentMethods.push({
			name: lang.get("paymentMethodAccountBalance_label"),
			value: PaymentMethodType.AccountBalance
		});
		return availablePaymentMethods;
	}
};
var PaypalInput = class {
	__paymentPaypalTest;
	constructor() {
		this.__paymentPaypalTest = locator.usageTestController.getTest("payment.paypal");
	}
	view(vnode) {
		let attrs = vnode.attrs;
		return [mithril_default(".flex-center", { style: { "margin-top": "50px" } }, mithril_default(BaseButton, {
			label: lang.makeTranslation("PayPal", "PayPal"),
			icon: mithril_default(".payment-logo.flex", mithril_default.trust(PayPalLogo)),
			class: "border border-radius bg-white button-height plr",
			onclick: () => {
				this.__paymentPaypalTest?.getStage(1).complete();
				if (attrs.payPalRequestUrl.isLoaded()) window.open(attrs.payPalRequestUrl.getLoaded());
else showProgressDialog("payPalRedirect_msg", attrs.payPalRequestUrl.getAsync()).then((url) => window.open(url));
			}
		})), mithril_default(".small.pt.center", isPaypalAssigned(attrs.accountingInfo) ? lang.get("paymentDataPayPalFinished_msg", { "{accountAddress}": attrs.accountingInfo.paymentMethodInfo ?? "" }) : lang.get("paymentDataPayPalLogin_msg"))];
	}
};
function isPaypalAssigned(accountingInfo) {
	return accountingInfo.paypalBillingAgreement != null;
}

//#endregion
//#region ../src/common/subscription/InvoiceAndPaymentDataPage.ts
var import_stream$6 = __toESM(require_stream(), 1);
var InvoiceAndPaymentDataPage = class {
	_paymentMethodInput = null;
	_invoiceDataInput = null;
	_availablePaymentMethods = null;
	_selectedPaymentMethod;
	dom;
	__signupPaidTest;
	__paymentPaypalTest;
	constructor() {
		this.__signupPaidTest = locator.usageTestController.getTest("signup.paid");
		this.__paymentPaypalTest = locator.usageTestController.getTest("payment.paypal");
		this._selectedPaymentMethod = (0, import_stream$6.default)();
		this._selectedPaymentMethod.map((method) => neverNull(this._paymentMethodInput).updatePaymentMethod(method));
	}
	onremove(vnode) {
		const data = vnode.attrs.data;
		if (this._invoiceDataInput && this._paymentMethodInput) {
			data.invoiceData = this._invoiceDataInput.getInvoiceData();
			data.paymentData = this._paymentMethodInput.getPaymentData();
		}
	}
	oncreate(vnode) {
		this.dom = vnode.dom;
		const data = vnode.attrs.data;
		if (this._invoiceDataInput && this._paymentMethodInput) {
			data.invoiceData = this._invoiceDataInput.getInvoiceData();
			data.paymentData = this._paymentMethodInput.getPaymentData();
		}
		let login = Promise.resolve(null);
		if (!locator.logins.isUserLoggedIn()) login = locator.logins.createSession(neverNull(data.newAccountData).mailAddress, neverNull(data.newAccountData).password, SessionType.Temporary).then((newSessionData) => newSessionData.credentials);
		login.then(() => {
			if (!data.accountingInfo || !data.customer) return locator.logins.getUserController().loadCustomer().then((customer) => {
				data.customer = customer;
				return locator.logins.getUserController().loadCustomerInfo();
			}).then((customerInfo) => locator.entityClient.load(AccountingInfoTypeRef, customerInfo.accountingInfo).then((accountingInfo) => {
				data.accountingInfo = accountingInfo;
			}));
		}).then(() => getDefaultPaymentMethod()).then((defaultPaymentMethod) => {
			this._invoiceDataInput = new InvoiceDataInput(data.options.businessUse(), data.invoiceData, InvoiceDataInputLocation.InWizard);
			let payPalRequestUrl = getLazyLoadedPayPalUrl();
			if (locator.logins.isUserLoggedIn()) locator.logins.waitForFullLogin().then(() => payPalRequestUrl.getAsync());
			this._paymentMethodInput = new PaymentMethodInput(data.options, this._invoiceDataInput.selectedCountry, neverNull(data.accountingInfo), payPalRequestUrl, defaultPaymentMethod);
			this._availablePaymentMethods = this._paymentMethodInput.getVisiblePaymentMethods();
			this._selectedPaymentMethod(data.paymentData.paymentMethod);
			this._paymentMethodInput.updatePaymentMethod(data.paymentData.paymentMethod, data.paymentData);
		});
	}
	view(vnode) {
		const a = vnode.attrs;
		const onNextClick = () => {
			const invoiceDataInput = assertNotNull(this._invoiceDataInput);
			const paymentMethodInput = assertNotNull(this._paymentMethodInput);
			let error = invoiceDataInput.validateInvoiceData() || paymentMethodInput.validatePaymentData();
			if (error) return Dialog.message(error).then(() => null);
else {
				a.data.invoiceData = invoiceDataInput.getInvoiceData();
				a.data.paymentData = paymentMethodInput.getPaymentData();
				return showProgressDialog("updatePaymentDataBusy_msg", Promise.resolve().then(() => {
					let customer = neverNull(a.data.customer);
					if (customer.businessUse !== a.data.options.businessUse()) {
						customer.businessUse = a.data.options.businessUse();
						return locator.entityClient.update(customer);
					}
				}).then(() => updatePaymentData(a.data.options.paymentInterval(), a.data.invoiceData, a.data.paymentData, null, a.data.upgradeType === UpgradeType.Signup, neverNull(a.data.price?.rawPrice), neverNull(a.data.accountingInfo)).then((success) => {
					if (success) {
						const paymentMethodConfirmationStage = this.__signupPaidTest?.getStage(4);
						paymentMethodConfirmationStage?.setMetric({
							name: "paymentMethod",
							value: PaymentMethodTypeToName[a.data.paymentData.paymentMethod]
						});
						paymentMethodConfirmationStage?.complete();
						emitWizardEvent(this.dom, WizardEventType.SHOW_NEXT_PAGE);
					}
				})));
			}
		};
		return mithril_default(".pt", this._availablePaymentMethods ? [
			mithril_default(SegmentControl, {
				items: this._availablePaymentMethods,
				selectedValue: this._selectedPaymentMethod(),
				onValueSelected: this._selectedPaymentMethod
			}),
			mithril_default(".flex-space-around.flex-wrap.pt", [mithril_default(".flex-grow-shrink-half.plr-l", { style: { minWidth: "260px" } }, mithril_default(neverNull(this._invoiceDataInput))), mithril_default(".flex-grow-shrink-half.plr-l", { style: { minWidth: "260px" } }, mithril_default(neverNull(this._paymentMethodInput)))]),
			mithril_default(".flex-center.full-width.pt-l", mithril_default(LoginButton, {
				label: "next_action",
				class: "small-login-button",
				onclick: onNextClick
			}))
		] : null);
	}
};
var InvoiceAndPaymentDataPageAttrs = class {
	data;
	_enabled = () => true;
	constructor(upgradeData) {
		this.data = upgradeData;
	}
	nextAction(showErrorDialog) {
		return Promise.resolve(true);
	}
	headerTitle() {
		return "adminPayment_action";
	}
	isSkipAvailable() {
		return false;
	}
	isEnabled() {
		return this._enabled();
	}
	/**
	* Set the enabled function for isEnabled
	* @param enabled
	*/
	setEnabledFunction(enabled) {
		this._enabled = enabled;
	}
};
async function updatePaymentData(paymentInterval, invoiceData, paymentData, confirmedCountry, isSignup, price, accountingInfo) {
	const paymentResult = await locator.customerFacade.updatePaymentData(paymentInterval, invoiceData, paymentData, confirmedCountry);
	const statusCode = paymentResult.result;
	if (statusCode === PaymentDataResultType.OK) {
		let braintree3ds = paymentResult.braintree3dsRequest;
		if (braintree3ds) return verifyCreditCard(accountingInfo, braintree3ds, price);
else return true;
	} else if (statusCode === PaymentDataResultType.COUNTRY_MISMATCH) {
		const countryName = invoiceData.country ? invoiceData.country.n : "";
		const confirmMessage = lang.getTranslation("confirmCountry_msg", { "{1}": countryName });
		const confirmed = await Dialog.confirm(confirmMessage);
		if (confirmed) return updatePaymentData(paymentInterval, invoiceData, paymentData, invoiceData.country, isSignup, price, accountingInfo);
else return false;
	} else if (statusCode === PaymentDataResultType.INVALID_VATID_NUMBER) await Dialog.message(lang.makeTranslation("invalidVatIdNumber_msg", lang.get("invalidVatIdNumber_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
else if (statusCode === PaymentDataResultType.CREDIT_CARD_DECLINED) await Dialog.message(lang.makeTranslation("creditCardDeclined_msg", lang.get("creditCardDeclined_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
else if (statusCode === PaymentDataResultType.CREDIT_CARD_CVV_INVALID) await Dialog.message("creditCardCVVInvalid_msg");
else if (statusCode === PaymentDataResultType.PAYMENT_PROVIDER_NOT_AVAILABLE) await Dialog.message(lang.makeTranslation("paymentProviderNotAvailableError_msg", lang.get("paymentProviderNotAvailableError_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
else if (statusCode === PaymentDataResultType.OTHER_PAYMENT_ACCOUNT_REJECTED) await Dialog.message(lang.makeTranslation("paymentAccountRejected_msg", lang.get("paymentAccountRejected_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
else if (statusCode === PaymentDataResultType.CREDIT_CARD_DATE_INVALID) await Dialog.message("creditCardExprationDateInvalid_msg");
else if (statusCode === PaymentDataResultType.CREDIT_CARD_NUMBER_INVALID) await Dialog.message(lang.makeTranslation("creditCardNumberInvalid_msg", lang.get("creditCardNumberInvalid_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
else if (statusCode === PaymentDataResultType.COULD_NOT_VERIFY_VATID) await Dialog.message(lang.makeTranslation("invalidVatIdValidationFailed_msg", lang.get("invalidVatIdValidationFailed_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
else if (statusCode === PaymentDataResultType.CREDIT_CARD_VERIFICATION_LIMIT_REACHED) await Dialog.message(lang.makeTranslation("creditCardVerificationLimitReached_msg", lang.get("creditCardVerificationLimitReached_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
else await Dialog.message(lang.makeTranslation("otherPaymentProviderError_msg", lang.get("otherPaymentProviderError_msg") + (isSignup ? " " + lang.get("accountWasStillCreated_msg") : "")));
	return false;
}
/**
* Displays a progress dialog that allows to cancel the verification and opens a new window to do the actual verification with the bank.
*/
function verifyCreditCard(accountingInfo, braintree3ds, price) {
	return locator.entityClient.load(InvoiceInfoTypeRef, neverNull(accountingInfo.invoiceInfo)).then((invoiceInfo) => {
		let invoiceInfoWrapper = { invoiceInfo };
		let resolve;
		let progressDialogPromise = new Promise((res) => resolve = res);
		let progressDialog;
		const closeAction = () => {
			progressDialog.close();
			setTimeout(() => resolve(false), DefaultAnimationTime);
		};
		progressDialog = new Dialog(DialogType.Alert, { view: () => [mithril_default(".dialog-contentButtonsBottom.text-break.selectable", lang.get("creditCardPendingVerification_msg")), mithril_default(".flex-center.dialog-buttons", mithril_default(Button, {
			label: "cancel_action",
			click: closeAction,
			type: ButtonType.Primary
		}))] }).setCloseHandler(closeAction).addShortcut({
			key: Keys.RETURN,
			shift: false,
			exec: closeAction,
			help: "close_alt"
		}).addShortcut({
			key: Keys.ESC,
			shift: false,
			exec: closeAction,
			help: "close_alt"
		});
		let entityEventListener = (updates, eventOwnerGroupId) => {
			return pMap(updates, (update) => {
				if (isUpdateForTypeRef(InvoiceInfoTypeRef, update)) return locator.entityClient.load(InvoiceInfoTypeRef, update.instanceId).then((invoiceInfo$1) => {
					invoiceInfoWrapper.invoiceInfo = invoiceInfo$1;
					if (!invoiceInfo$1.paymentErrorInfo) {
						progressDialog.close();
						resolve(true);
					} else if (invoiceInfo$1.paymentErrorInfo && invoiceInfo$1.paymentErrorInfo.errorCode === "card.3ds2_pending") {} else if (invoiceInfo$1.paymentErrorInfo && invoiceInfo$1.paymentErrorInfo.errorCode !== null) {
						let error = "3dsFailedOther";
						switch (invoiceInfo$1.paymentErrorInfo.errorCode) {
							case "card.cvv_invalid":
								error = "cvvInvalid";
								break;
							case "card.number_invalid":
								error = "ccNumberInvalid";
								break;
							case "card.date_invalid":
								error = "expirationDate";
								break;
							case "card.insufficient_funds":
								error = "insufficientFunds";
								break;
							case "card.expired_card":
								error = "cardExpired";
								break;
							case "card.3ds2_failed":
								error = "3dsFailed";
								break;
						}
						Dialog.message(getPreconditionFailedPaymentMsg(invoiceInfo$1.paymentErrorInfo.errorCode));
						resolve(false);
						progressDialog.close();
					}
					mithril_default.redraw();
				});
			}).then(noOp);
		};
		locator.eventController.addEntityListener(entityEventListener);
		const app = client.isCalendarApp() ? "calendar" : "mail";
		let params = `clientToken=${encodeURIComponent(braintree3ds.clientToken)}&nonce=${encodeURIComponent(braintree3ds.nonce)}&bin=${encodeURIComponent(braintree3ds.bin)}&price=${encodeURIComponent(price)}&message=${encodeURIComponent(lang.get("creditCardVerification_msg"))}&clientType=${getClientType()}&app=${app}`;
		Dialog.message("creditCardVerificationNeededPopup_msg").then(() => {
			const paymentUrlString = locator.domainConfigProvider().getCurrentDomainConfig().paymentUrl;
			const paymentUrl = new URL(paymentUrlString);
			paymentUrl.hash += params;
			window.open(paymentUrl);
			progressDialog.show();
		});
		return progressDialogPromise.finally(() => locator.eventController.removeEntityListener(entityEventListener));
	});
}

//#endregion
//#region ../src/common/subscription/SwitchToBusinessInvoiceDataDialog.ts
function showSwitchToBusinessInvoiceDataDialog(customer, invoiceData, accountingInfo) {
	if (customer.businessUse) throw new ProgrammingError("cannot show invoice data dialog if the customer is already a business customer");
	const invoiceDataInput = new InvoiceDataInput(true, invoiceData, InvoiceDataInputLocation.InWizard);
	const result = defer();
	const confirmAction = async () => {
		let error = invoiceDataInput.validateInvoiceData();
		if (error) Dialog.message(error);
else {
			showProgressDialog("pleaseWait_msg", result.promise);
			const success = await updatePaymentData(asPaymentInterval(accountingInfo.paymentInterval), invoiceDataInput.getInvoiceData(), null, null, false, "0", accountingInfo).catch(ofClass(BadRequestError, () => {
				Dialog.message("paymentMethodNotAvailable_msg");
				return false;
			})).catch((e) => {
				result.reject(e);
			});
			if (success) {
				dialog.close();
				result.resolve(true);
			} else result.resolve(false);
		}
	};
	const cancelAction = () => result.resolve(false);
	const dialog = Dialog.showActionDialog({
		title: "invoiceData_msg",
		child: { view: () => mithril_default("#changeInvoiceDataDialog", [mithril_default(invoiceDataInput)]) },
		okAction: confirmAction,
		cancelAction,
		allowCancel: true,
		okActionTextId: "save_action"
	});
	return result.promise;
}

//#endregion
//#region ../src/common/subscription/SetupLeavingUserSurveyPage.ts
var SetupLeavingUserSurveyPage = class {
	view(vnode) {
		return mithril_default("#leaving-user-survey-dialog.pt.flex-center", [mithril_default(".flex.flex-column.max-width-m.pt.pb.plr-l", { style: {
			minHeight: styles.isDesktopLayout() ? "850px" : "",
			minWidth: styles.isDesktopLayout() ? "450px" : "360px"
		} }, [
			mithril_default(".mb", { style: {
				height: styles.isDesktopLayout() ? "360px" : "",
				...vnode.attrs.imageStyle
			} }, mithril_default("img.pb.block.full-width.height-100p", {
				src: `${window.tutao.appState.prefixWithoutFile}/images/leaving-wizard/${vnode.attrs.image}.png`,
				alt: "",
				rel: "noreferrer",
				loading: "lazy",
				decoding: "async"
			})),
			mithril_default("h3.center.b", lang.get(vnode.attrs.mainMessage)),
			mithril_default("p.center", { style: { height: styles.isDesktopLayout() ? "45px" : "77.5px" } }, lang.get(vnode.attrs.secondaryMessage)),
			vnode.children,
			mithril_default(".full-width", { style: { margin: styles.isDesktopLayout() ? "auto 0 0 0" : "16px 0 0 0" } }, mithril_default(LoginButton, {
				label: vnode.attrs.nextButtonLabel,
				onclick: () => vnode.attrs.closeAction(),
				class: vnode.attrs.nextButtonEnabled ? "no-hover button-bg" : "",
				disabled: vnode.attrs.nextButtonEnabled
			}))
		])]);
	}
};

//#endregion
//#region ../src/common/subscription/LeavingUserSurveyCategoryPage.ts
var LeavingUserSurveyCategoryPage = class {
	_dom = null;
	oncreate(vnode) {
		this._dom = vnode.dom;
	}
	view(vnode) {
		return mithril_default(SetupLeavingUserSurveyPage, {
			closeAction: () => this.showNextPage(),
			nextButtonLabel: "next_action",
			nextButtonEnabled: !vnode.attrs.data.category,
			image: "main",
			mainMessage: "surveyMainMessageDelete_label",
			secondaryMessage: vnode.attrs.data.showDowngradeMessage ? "surveySecondaryMessageDowngrade_label" : "surveySecondaryMessageDelete_label"
		}, [mithril_default(DropDownSelector, {
			style: {
				border: `2px solid ${theme.content_border}`,
				borderRadius: "6px",
				padding: "4px 8px"
			},
			doShowBorder: false,
			label: "surveyUnhappy_label",
			items: this.getCategoryDropdownItems(vnode.attrs.data.showPriceCategory),
			selectedValue: vnode.attrs.data.category,
			selectionChangedHandler: (category) => {
				vnode.attrs.data.category = category;
			},
			dropdownWidth: 350
		}), mithril_default(".mlr-s.mt-xs", mithril_default("small", lang.get("cancellationConfirmation_msg")))]);
	}
	getCategoryDropdownItems(showPriceCategory) {
		const items = [
			{
				name: lang.get("experienceSamplingAnswer_label"),
				value: null
			},
			{
				name: lang.get("surveyPrice_label"),
				value: "0"
			},
			{
				name: lang.get("surveyAccountProblems_label"),
				value: "1"
			},
			{
				name: lang.get("surveyMissingFeature_label"),
				value: "2"
			},
			{
				name: lang.get("surveyFeatureDesignProblems_label"),
				value: "3"
			},
			{
				name: lang.get("surveyOtherReason_label"),
				value: "4"
			}
		];
		if (!showPriceCategory) items.splice(1, 1);
		return items;
	}
	showNextPage() {
		if (this._dom) emitWizardEvent(this._dom, WizardEventType.SHOW_NEXT_PAGE);
	}
};
var LeavingUserSurveyPageAttrs = class {
	data;
	constructor(leavingUserSurveyData) {
		this.data = leavingUserSurveyData;
	}
	headerTitle() {
		return "survey_label";
	}
	nextAction(showErrorDialog) {
		return Promise.resolve(this.data.category != null);
	}
	isSkipAvailable() {
		return false;
	}
	isEnabled() {
		return true;
	}
};

//#endregion
//#region ../src/common/subscription/LeavingUserSurveyConstants.ts
const SURVEY_VERSION_NUMBER = "0";
let CategoryType = function(CategoryType$1) {
	CategoryType$1["Price"] = "0";
	CategoryType$1["Account"] = "1";
	CategoryType$1["Feature"] = "2";
	CategoryType$1["Problem"] = "3";
	CategoryType$1["Other"] = "4";
	return CategoryType$1;
}({});
function getCategoryType(category) {
	return category;
}
const CATEGORY_TO_IMAGE = new Map([
	[CategoryType.Price, {
		image: "price",
		translationKey: "surveyPrice_label"
	}],
	[CategoryType.Account, {
		image: "account",
		translationKey: "surveyAccountProblems_label"
	}],
	[CategoryType.Feature, {
		image: "feature",
		translationKey: "surveyMissingFeature_label"
	}],
	[CategoryType.Problem, {
		image: "problem",
		translationKey: "surveyFeatureDesignProblems_label"
	}],
	[CategoryType.Other, {
		image: "other",
		translationKey: "surveyOtherReason_label"
	}]
]);
const CATEGORY_TO_REASON = new Map([
	[CategoryType.Price, [
		{
			value: "0",
			translationKey: "surveyPriceReasonPaidFeatures_label"
		},
		{
			value: "1",
			translationKey: "surveyPriceReasonTooExpensive_label"
		},
		{
			value: "2",
			translationKey: "surveyPriceReasonPricesTooHigh_label"
		},
		{
			value: "3",
			translationKey: "surveyPriceReasonStudentDiscount_label"
		},
		{
			value: "4",
			translationKey: "surveyPriceReasonFamilyDiscount_label"
		},
		{
			value: "5",
			translationKey: "surveyPriceReasonAutoRenewal_label"
		},
		{
			value: "6",
			translationKey: "surveyPriceReasonPaymentNotWorking_label"
		},
		{
			value: "7",
			translationKey: "surveyOtherReasonProvideDetails_label"
		}
	]],
	[CategoryType.Account, [
		{
			value: "8",
			translationKey: "surveyAccountReasonAccountApproval_label"
		},
		{
			value: "9",
			translationKey: "surveyAccountReasonSupportNoHelp_label"
		},
		{
			value: "10",
			translationKey: "surveyAccountReasonForgotPassword_label"
		},
		{
			value: "11",
			translationKey: "surveyAccountReasonForgotRecoveryCode_label"
		},
		{
			value: "12",
			translationKey: "surveyAccountReasonCantAddUsers_label"
		},
		{
			value: "13",
			translationKey: "surveyAccountReasonServicesBlocked_label"
		},
		{
			value: "14",
			translationKey: "surveyAccountReasonAccountBlocked_label"
		},
		{
			value: "15",
			translationKey: "surveyOtherReasonProvideDetails_label"
		}
	]],
	[CategoryType.Feature, [
		{
			value: "16",
			translationKey: "surveyFeatureReasonNoIMAP_label"
		},
		{
			value: "17",
			translationKey: "surveyFeatureReasonNoEmailImport_label"
		},
		{
			value: "18",
			translationKey: "surveyFeatureReasonNoAdjustableColumns_label"
		},
		{
			value: "19",
			translationKey: "surveyFeatureReasonNoEmailLabels_label"
		},
		{
			value: "20",
			translationKey: "surveyFeatureReasonMoreFormattingOptions_label"
		},
		{
			value: "21",
			translationKey: "surveyFeatureReasonAutoForward_label"
		},
		{
			value: "22",
			translationKey: "surveyFeatureReasonCloudStorage_label"
		},
		{
			value: "23",
			translationKey: "surveyFeatureReasonEmailTranslations_label"
		},
		{
			value: "24",
			translationKey: "surveyFeatureReasonOther_label"
		}
	]],
	[CategoryType.Problem, [
		{
			value: "25",
			translationKey: "surveyProblemReasonSearch_label"
		},
		{
			value: "26",
			translationKey: "surveyProblemReasonCalendar_label"
		},
		{
			value: "27",
			translationKey: "surveyProblemReasonThemeCustomization_label"
		},
		{
			value: "28",
			translationKey: "surveyProblemReasonSpamProtection_label"
		},
		{
			value: "29",
			translationKey: "surveyProblemReasonAppAppearance_label"
		},
		{
			value: "30",
			translationKey: "surveyProblemReasonTooHardToUse_label"
		}
	]],
	[CategoryType.Other, [
		{
			value: "31",
			translationKey: "surveyOtherReasonWrongEmailAddress_label"
		},
		{
			value: "32",
			translationKey: "surveyOtherReasonMergeAccounts_label"
		},
		{
			value: "33",
			translationKey: "surveyOtherReasonProvideDetails_label"
		}
	]]
]);

//#endregion
//#region ../src/common/subscription/LeavingUserSurveyReasonPage.ts
var LeavingUserSurveyReasonPage = class {
	_dom = null;
	dropdownItemsFromCategory = [];
	customReasonEditor;
	constructor() {
		let NUMBER_OF_EDITOR_LINES = styles.isDesktopLayout() ? 5 : 1;
		this.customReasonEditor = new HtmlEditor().setStaticNumberOfLines(NUMBER_OF_EDITOR_LINES).showBorders().setPlaceholderId("enterDetails_msg").setMode(HtmlEditorMode.HTML).setHtmlMonospace(false).setValue("");
	}
	oncreate(vnode) {
		this._dom = vnode.dom;
	}
	oninit(vnode) {
		this.dropdownItemsFromCategory = this.getDropdownItemsFromCategory(vnode.attrs.data.category);
		vnode.attrs.data.reason = null;
	}
	view(vnode) {
		return mithril_default(SetupLeavingUserSurveyPage, {
			closeAction: () => {
				vnode.attrs.data.details = this.customReasonEditor.getValue();
				vnode.attrs.data.submitted = true;
				this.closeDialog();
			},
			nextButtonLabel: "submit_action",
			nextButtonEnabled: !vnode.attrs.data.reason,
			image: CATEGORY_TO_IMAGE.get(getCategoryType(vnode.attrs.data.category))?.image,
			imageStyle: { paddingBottom: "60px" },
			mainMessage: CATEGORY_TO_IMAGE.get(getCategoryType(vnode.attrs.data.category))?.translationKey,
			secondaryMessage: "surveyReasonSecondaryMessage_label"
		}, [mithril_default(DropDownSelector, {
			style: {
				border: `2px solid ${theme.content_border}`,
				borderRadius: "6px",
				padding: "4px 8px"
			},
			doShowBorder: false,
			label: "surveyChooseReason_label",
			items: this.dropdownItemsFromCategory,
			selectedValue: vnode.attrs.data.reason,
			selectionChangedHandler: (reason) => {
				vnode.attrs.data.reason = reason;
			},
			dropdownWidth: 350
		}), mithril_default(".pt", mithril_default(this.customReasonEditor))]);
	}
	closeDialog() {
		if (this._dom) emitWizardEvent(this._dom, WizardEventType.CLOSE_DIALOG);
	}
	getDropdownItemsFromCategory(category) {
		const categoryType = getCategoryType(category);
		const reasonList = CATEGORY_TO_REASON.get(categoryType);
		const unselected = [{
			name: lang.get("experienceSamplingAnswer_label"),
			value: null
		}];
		if (!reasonList) return [];
		return unselected.concat(reasonList.map((r) => ({
			name: lang.get(r.translationKey),
			value: r.value
		})));
	}
};

//#endregion
//#region ../src/common/subscription/LeavingUserSurveyWizard.ts
async function showLeavingUserSurveyWizard(showPriceCategory, showDowngradeMessage) {
	let category = null;
	let reason = null;
	let details = null;
	let submitted = false;
	const leavingUserSurveyData = {
		category,
		reason,
		details,
		submitted,
		showPriceCategory,
		showDowngradeMessage
	};
	const wizardPages = [wizardPageWrapper(LeavingUserSurveyCategoryPage, new LeavingUserSurveyPageAttrs(leavingUserSurveyData)), wizardPageWrapper(LeavingUserSurveyReasonPage, new LeavingUserSurveyPageAttrs(leavingUserSurveyData))];
	const deferred = defer();
	const wizardBuilder = createWizardDialog(leavingUserSurveyData, wizardPages, async () => {
		deferred.resolve(leavingUserSurveyData);
	}, DialogType.EditLarge, "surveySkip_action");
	wizardBuilder.dialog.show();
	return deferred.promise;
}

//#endregion
//#region ../src/common/native/common/generatedipc/MobilePaymentSubscriptionOwnership.ts
let MobilePaymentSubscriptionOwnership = function(MobilePaymentSubscriptionOwnership$1) {
	MobilePaymentSubscriptionOwnership$1["Owner"] = "0";
	MobilePaymentSubscriptionOwnership$1["NotOwner"] = "1";
	MobilePaymentSubscriptionOwnership$1["NoSubscription"] = "2";
	return MobilePaymentSubscriptionOwnership$1;
}({});

//#endregion
//#region ../src/common/subscription/PaymentDataDialog.ts
var import_stream$5 = __toESM(require_stream(), 1);

//#endregion
//#region ../src/common/api/entities/accounting/TypeRefs.ts
const CustomerAccountPostingTypeRef = new TypeRef("accounting", "CustomerAccountPosting");
const CustomerAccountReturnTypeRef = new TypeRef("accounting", "CustomerAccountReturn");

//#endregion
//#region ../src/common/api/entities/accounting/Services.ts
const CustomerAccountService = Object.freeze({
	app: "accounting",
	name: "CustomerAccountService",
	get: {
		data: null,
		return: CustomerAccountReturnTypeRef
	},
	post: null,
	put: null,
	delete: null
});

//#endregion
//#region ../src/common/subscription/PaymentViewer.ts
assertMainOrNode();
async function showManageThroughAppStoreDialog() {
	const confirmed = await Dialog.confirm(lang.getTranslation("storeSubscription_msg", { "{AppStorePayment}": InfoLink.AppStorePayment }));
	if (confirmed) window.open("https://apps.apple.com/account/subscriptions", "_blank", "noopener,noreferrer");
}

//#endregion
//#region ../src/common/subscription/UpgradeSubscriptionPage.ts
var import_stream$4 = __toESM(require_stream(), 1);
const PlanTypeParameter = Object.freeze({
	FREE: "free",
	REVOLUTIONARY: "revolutionary",
	LEGEND: "legend",
	ESSENTIAL: "essential",
	ADVANCED: "advanced",
	UNLIMITED: "unlimited"
});
var UpgradeSubscriptionPage = class {
	_dom = null;
	__signupFreeTest;
	__signupPaidTest;
	upgradeType = null;
	oncreate(vnode) {
		this._dom = vnode.dom;
		const subscriptionParameters = vnode.attrs.data.subscriptionParameters;
		this.upgradeType = vnode.attrs.data.upgradeType;
		this.__signupFreeTest = locator.usageTestController.getTest("signup.free");
		this.__signupFreeTest.active = false;
		this.__signupPaidTest = locator.usageTestController.getTest("signup.paid");
		this.__signupPaidTest.active = false;
		if (subscriptionParameters) {
			const paymentInterval = subscriptionParameters.interval ? asPaymentInterval(subscriptionParameters.interval) : PaymentInterval.Yearly;
			vnode.attrs.data.subscriptionParameters = null;
			vnode.attrs.data.options.paymentInterval = (0, import_stream$4.default)(paymentInterval);
			this.goToNextPageWithPreselectedSubscription(subscriptionParameters, vnode.attrs.data);
		}
	}
	view(vnode) {
		const data = vnode.attrs.data;
		let availablePlans = vnode.attrs.data.acceptedPlans;
		if (!!data.newAccountData && data.newAccountData.mailAddress.includes("tuta.com") && availablePlans.includes(PlanType.Free)) availablePlans = availablePlans.filter((plan) => plan != PlanType.Free);
		const isYearly = data.options.paymentInterval() === PaymentInterval.Yearly;
		const isCyberMonday = isReferenceDateWithinCyberMondayCampaign(Const.CURRENT_DATE ?? new Date());
		const shouldApplyCyberMonday = isYearly && isCyberMonday;
		const subscriptionActionButtons = {
			[PlanType.Free]: () => {
				return {
					label: "pricing.select_action",
					onclick: () => this.selectFree(data)
				};
			},
			[PlanType.Revolutionary]: this.createUpgradeButton(data, PlanType.Revolutionary),
			[PlanType.Legend]: () => ({
				label: shouldApplyCyberMonday ? "pricing.cyber_monday_select_action" : "pricing.select_action",
				class: shouldApplyCyberMonday ? "accent-bg-cyber-monday" : undefined,
				onclick: () => this.setNonFreeDataAndGoToNextPage(data, PlanType.Legend)
			}),
			[PlanType.Essential]: this.createUpgradeButton(data, PlanType.Essential),
			[PlanType.Advanced]: this.createUpgradeButton(data, PlanType.Advanced),
			[PlanType.Unlimited]: this.createUpgradeButton(data, PlanType.Unlimited)
		};
		return mithril_default(".pt", [mithril_default(SubscriptionSelector, {
			options: data.options,
			priceInfoTextId: data.priceInfoTextId,
			boxWidth: 230,
			boxHeight: 270,
			acceptedPlans: availablePlans,
			allowSwitchingPaymentInterval: data.upgradeType !== UpgradeType.Switch,
			currentPlanType: data.currentPlan,
			actionButtons: subscriptionActionButtons,
			featureListProvider: vnode.attrs.data.featureListProvider,
			priceAndConfigProvider: vnode.attrs.data.planPrices,
			multipleUsersAllowed: vnode.attrs.data.multipleUsersAllowed,
			msg: data.msg
		})]);
	}
	selectFree(data) {
		if (this.__signupPaidTest) this.__signupPaidTest.active = false;
		if (this.__signupFreeTest && this.upgradeType == UpgradeType.Signup) {
			this.__signupFreeTest.active = true;
			this.__signupFreeTest.getStage(0).complete();
		}
		confirmFreeSubscription().then((confirmed) => {
			if (confirmed) {
				this.__signupFreeTest?.getStage(1).complete();
				data.type = PlanType.Free;
				data.price = null;
				data.nextYearPrice = null;
				this.showNextPage();
			}
		});
	}
	showNextPage() {
		if (this._dom) emitWizardEvent(this._dom, WizardEventType.SHOW_NEXT_PAGE);
	}
	goToNextPageWithPreselectedSubscription(subscriptionParameters, data) {
		let subscriptionType;
		try {
			subscriptionType = subscriptionParameters.type == null ? null : stringToSubscriptionType(subscriptionParameters.type);
		} catch (e) {
			subscriptionType = null;
		}
		if (subscriptionType === SubscriptionType.Personal || subscriptionType === SubscriptionType.PaidPersonal) {
			data.options.businessUse(false);
			switch (subscriptionParameters.subscription) {
				case PlanTypeParameter.FREE:
					this.selectFree(data);
					break;
				case PlanTypeParameter.REVOLUTIONARY:
					this.setNonFreeDataAndGoToNextPage(data, PlanType.Revolutionary);
					break;
				case PlanTypeParameter.LEGEND:
					this.setNonFreeDataAndGoToNextPage(data, PlanType.Legend);
					break;
				default:
					console.log("Unknown subscription passed: ", subscriptionParameters);
					break;
			}
		} else if (subscriptionType === SubscriptionType.Business) {
			data.options.businessUse(true);
			switch (subscriptionParameters.subscription) {
				case PlanTypeParameter.ESSENTIAL:
					this.setNonFreeDataAndGoToNextPage(data, PlanType.Essential);
					break;
				case PlanTypeParameter.ADVANCED:
					this.setNonFreeDataAndGoToNextPage(data, PlanType.Advanced);
					break;
				case PlanTypeParameter.UNLIMITED:
					this.setNonFreeDataAndGoToNextPage(data, PlanType.Unlimited);
					break;
				default:
					console.log("Unknown subscription passed: ", subscriptionParameters);
					break;
			}
		} else console.log("Unknown subscription type passed: ", subscriptionParameters);
	}
	setNonFreeDataAndGoToNextPage(data, planType) {
		if (this.__signupFreeTest) this.__signupFreeTest.active = false;
		if (this.__signupPaidTest && this.upgradeType == UpgradeType.Signup) {
			this.__signupPaidTest.active = true;
			this.__signupPaidTest.getStage(0).complete();
		}
		data.type = planType;
		const { planPrices, options } = data;
		try {
			data.price = planPrices.getSubscriptionPriceWithCurrency(options.paymentInterval(), data.type, UpgradePriceType.PlanActualPrice);
			const nextYear = planPrices.getSubscriptionPriceWithCurrency(options.paymentInterval(), data.type, UpgradePriceType.PlanNextYearsPrice);
			data.nextYearPrice = data.price.rawPrice !== nextYear.rawPrice ? nextYear : null;
		} catch (e) {
			console.error(e);
			Dialog.message("appStoreNotAvailable_msg");
			return;
		}
		this.showNextPage();
	}
	createUpgradeButton(data, planType) {
		return () => ({
			label: "pricing.select_action",
			onclick: () => this.setNonFreeDataAndGoToNextPage(data, planType)
		});
	}
};
function confirmFreeSubscription() {
	return new Promise((resolve) => {
		let oneAccountValue = (0, import_stream$4.default)(false);
		let privateUseValue = (0, import_stream$4.default)(false);
		let dialog;
		const closeAction = (confirmed) => {
			dialog.close();
			setTimeout(() => resolve(confirmed), DefaultAnimationTime);
		};
		const isFormValid = () => oneAccountValue() && privateUseValue();
		dialog = new Dialog(DialogType.Alert, { view: () => [
			mithril_default("#dialog-message.dialog-contentButtonsBottom.text-break.text-prewrap.selectable", lang.getTranslationText("freeAccountInfo_msg")),
			mithril_default(".dialog-contentButtonsBottom", [mithril_default(Checkbox, {
				label: () => lang.get("confirmNoOtherFreeAccount_msg"),
				checked: oneAccountValue(),
				onChecked: oneAccountValue
			}), mithril_default(Checkbox, {
				label: () => lang.get("confirmPrivateUse_msg"),
				checked: privateUseValue(),
				onChecked: privateUseValue
			})]),
			mithril_default(".flex-center.dialog-buttons", [mithril_default(Button, {
				label: "cancel_action",
				click: () => closeAction(false),
				type: ButtonType.Secondary
			}), mithril_default(Button, {
				label: "ok_action",
				click: () => {
					if (isFormValid()) closeAction(true);
				},
				type: ButtonType.Primary
			})])
		] }).setCloseHandler(() => closeAction(false)).addShortcut({
			key: Keys.ESC,
			shift: false,
			exec: () => closeAction(false),
			help: "cancel_action"
		}).addShortcut({
			key: Keys.RETURN,
			shift: false,
			exec: () => {
				if (isFormValid()) closeAction(true);
			},
			help: "ok_action"
		}).show();
	});
}
var UpgradeSubscriptionPageAttrs = class {
	data;
	constructor(upgradeData) {
		this.data = upgradeData;
	}
	headerTitle() {
		return "subscription_label";
	}
	nextAction(showErrorDialog) {
		return Promise.resolve(true);
	}
	isSkipAvailable() {
		return false;
	}
	isEnabled() {
		return true;
	}
};

//#endregion
//#region ../src/common/subscription/UpgradeCongratulationsPage.ts
var UpgradeCongratulationsPage = class {
	dom;
	__signupPaidTest;
	__signupFreeTest;
	oncreate(vnode) {
		this.__signupPaidTest = locator.usageTestController.getTest("signup.paid");
		this.__signupFreeTest = locator.usageTestController.getTest("signup.free");
		this.dom = vnode.dom;
	}
	view({ attrs }) {
		const { newAccountData } = attrs.data;
		return [
			mithril_default(".center.h4.pt", lang.get("accountCreationCongratulation_msg")),
			newAccountData ? mithril_default(".plr-l", [mithril_default(RecoverCodeField, {
				showMessage: true,
				recoverCode: newAccountData.recoverCode,
				image: {
					src: VisSignupImage,
					alt: "vitor_alt"
				}
			})]) : null,
			mithril_default(".flex-center.full-width.pt-l", mithril_default(LoginButton, {
				label: "ok_action",
				class: "small-login-button",
				onclick: () => {
					if (attrs.data.type === PlanType.Free) {
						const recoveryConfirmationStageFree = this.__signupFreeTest?.getStage(5);
						recoveryConfirmationStageFree?.setMetric({
							name: "switchedFromPaid",
							value: (this.__signupPaidTest?.isStarted() ?? false).toString()
						});
						recoveryConfirmationStageFree?.complete();
					}
					this.close(attrs.data, this.dom);
				}
			}))
		];
	}
	close(data, dom) {
		let promise = Promise.resolve();
		if (data.newAccountData && locator.logins.isUserLoggedIn()) promise = locator.logins.logout(false);
		promise.then(() => {
			emitWizardEvent(dom, WizardEventType.SHOW_NEXT_PAGE);
		});
	}
};
var UpgradeCongratulationsPageAttrs = class {
	data;
	preventGoBack = true;
	hidePagingButtonForPage = true;
	constructor(upgradeData) {
		this.data = upgradeData;
	}
	headerTitle() {
		return "accountCongratulations_msg";
	}
	nextAction(showDialogs) {
		return Promise.resolve(true);
	}
	isSkipAvailable() {
		return false;
	}
	isEnabled() {
		return true;
	}
};

//#endregion
//#region ../src/common/settings/SelectMailAddressForm.ts
assertMainOrNode();
const VALID_MESSAGE_ID = "mailAddressAvailable_msg";
var SelectMailAddressForm = class {
	username;
	messageId;
	checkAddressTimeout;
	isVerificationBusy;
	lastAttrs;
	constructor({ attrs }) {
		this.lastAttrs = attrs;
		this.isVerificationBusy = false;
		this.checkAddressTimeout = null;
		this.username = "";
		this.messageId = "mailAddressNeutral_msg";
	}
	onupdate(vnode) {
		if (this.lastAttrs.selectedDomain.domain !== vnode.attrs.selectedDomain.domain) this.verifyMailAddress(vnode.attrs);
		this.lastAttrs = vnode.attrs;
	}
	view({ attrs }) {
		if (attrs.injectionsRightButtonAttrs?.click) {
			const originalCallback = attrs.injectionsRightButtonAttrs.click;
			attrs.injectionsRightButtonAttrs.click = (event, dom) => {
				originalCallback(event, dom);
				this.username = "";
				this.messageId = "mailAddressNeutral_msg";
			};
		}
		return mithril_default(TextField, {
			label: "mailAddress_label",
			value: this.username,
			alignRight: true,
			autocompleteAs: Autocomplete.newPassword,
			autocapitalize: Autocapitalize.none,
			helpLabel: () => this.addressHelpLabel(),
			fontSize: px(size.font_size_smaller),
			oninput: (value) => {
				this.username = value;
				this.verifyMailAddress(attrs);
			},
			injectionsRight: () => [mithril_default(".flex.items-end.align-self-end", { style: {
				"padding-bottom": "1px",
				flex: "1 1 auto",
				fontSize: px(size.font_size_smaller),
				lineHeight: px(inputLineHeight)
			} }, `@${attrs.selectedDomain.domain}`), attrs.availableDomains.length > 1 ? mithril_default(IconButton, attachDropdown({
				mainButtonAttrs: {
					title: "domain_label",
					icon: BootIcons.Expand,
					size: ButtonSize.Compact
				},
				childAttrs: () => attrs.availableDomains.map((domain) => this.createDropdownItemAttrs(domain, attrs)),
				showDropdown: () => true,
				width: 250
			})) : attrs.injectionsRightButtonAttrs ? mithril_default(IconButton, attrs.injectionsRightButtonAttrs) : null]
		});
	}
	getCleanMailAddress(attrs) {
		return formatMailAddressFromParts(this.username, attrs.selectedDomain.domain);
	}
	addressHelpLabel() {
		return this.isVerificationBusy ? mithril_default(".flex.items-center.mt-s", [this.progressIcon(), lang.get("mailAddressBusy_msg")]) : mithril_default(".mt-s", lang.get(this.messageId ?? VALID_MESSAGE_ID));
	}
	progressIcon() {
		return mithril_default(Icon, {
			icon: BootIcons.Progress,
			class: "icon-progress mr-s"
		});
	}
	createDropdownItemAttrs(domainData, attrs) {
		return {
			label: lang.makeTranslation("domain", domainData.domain),
			click: () => {
				attrs.onDomainChanged(domainData);
			},
			icon: domainData.isPaid ? BootIcons.Premium : undefined
		};
	}
	onBusyStateChanged(isBusy, onBusyStateChanged) {
		this.isVerificationBusy = isBusy;
		onBusyStateChanged(isBusy);
		mithril_default.redraw();
	}
	onValidationFinished(email, validationResult, onValidationResult) {
		this.messageId = validationResult.errorId;
		onValidationResult(email, validationResult);
	}
	verifyMailAddress(attrs) {
		const { onValidationResult, onBusyStateChanged } = attrs;
		if (this.checkAddressTimeout) clearTimeout(this.checkAddressTimeout);
		const cleanMailAddress = this.getCleanMailAddress(attrs);
		const cleanUsername = this.username.trim().toLowerCase();
		if (cleanUsername === "") {
			this.onValidationFinished(cleanMailAddress, {
				isValid: false,
				errorId: "mailAddressNeutral_msg"
			}, onValidationResult);
			this.onBusyStateChanged(false, onBusyStateChanged);
			return;
		} else if (!isMailAddress(cleanMailAddress, true) || isTutaMailAddress(cleanMailAddress) && cleanUsername.length < 3) {
			this.onValidationFinished(cleanMailAddress, {
				isValid: false,
				errorId: "mailAddressInvalid_msg"
			}, onValidationResult);
			this.onBusyStateChanged(false, onBusyStateChanged);
			return;
		}
		this.onBusyStateChanged(true, onBusyStateChanged);
		this.checkAddressTimeout = setTimeout(async () => {
			if (this.getCleanMailAddress(attrs) !== cleanMailAddress) return;
			let result;
			try {
				const available = await locator.mailAddressFacade.isMailAddressAvailable(cleanMailAddress);
				result = available ? {
					isValid: true,
					errorId: null
				} : {
					isValid: false,
					errorId: attrs.mailAddressNAError ?? "mailAddressNA_msg"
				};
			} catch (e) {
				if (e instanceof AccessDeactivatedError) result = {
					isValid: false,
					errorId: "mailAddressDelay_msg"
				};
else throw e;
			} finally {
				if (this.getCleanMailAddress(attrs) === cleanMailAddress) this.onBusyStateChanged(false, onBusyStateChanged);
			}
			if (this.getCleanMailAddress(attrs) === cleanMailAddress) this.onValidationFinished(cleanMailAddress, result, onValidationResult);
		}, 500);
	}
};

//#endregion
//#region ../src/common/subscription/SignupForm.ts
var import_stream$3 = __toESM(require_stream(), 1);
var SignupForm = class {
	passwordModel;
	_confirmTerms;
	_confirmAge;
	_code;
	selectedDomain;
	_mailAddressFormErrorId = null;
	_mailAddress;
	_isMailVerificationBusy;
	__mailValid;
	__lastMailValidationError;
	__signupFreeTest;
	__signupPaidTest;
	availableDomains = (locator.domainConfigProvider().getCurrentDomainConfig().firstPartyDomain ? TUTA_MAIL_ADDRESS_SIGNUP_DOMAINS : getWhitelabelRegistrationDomains()).map((domain) => ({
		domain,
		isPaid: isPaidPlanDomain(domain)
	}));
	constructor(vnode) {
		this.selectedDomain = getFirstOrThrow(this.availableDomains);
		if (vnode.attrs.isPaidSubscription()) this.selectedDomain = this.availableDomains.find((domain) => domain.domain === DEFAULT_PAID_MAIL_ADDRESS_SIGNUP_DOMAIN) ?? this.selectedDomain;
else this.selectedDomain = this.availableDomains.find((domain) => domain.domain === DEFAULT_FREE_MAIL_ADDRESS_SIGNUP_DOMAIN) ?? this.selectedDomain;
		this.__mailValid = (0, import_stream$3.default)(false);
		this.__lastMailValidationError = (0, import_stream$3.default)(null);
		this.passwordModel = new PasswordModel(locator.usageTestController, locator.logins, {
			checkOldPassword: false,
			enforceStrength: true,
			reservedStrings: () => this._mailAddress ? [this._mailAddress.split("@")[0]] : []
		}, this.__mailValid);
		this.__signupFreeTest = locator.usageTestController.getTest("signup.free");
		this.__signupPaidTest = locator.usageTestController.getTest("signup.paid");
		this._confirmTerms = (0, import_stream$3.default)(false);
		this._confirmAge = (0, import_stream$3.default)(false);
		this._code = (0, import_stream$3.default)("");
		this._isMailVerificationBusy = false;
		this._mailAddressFormErrorId = "mailAddressNeutral_msg";
	}
	view(vnode) {
		const a = vnode.attrs;
		const mailAddressFormAttrs = {
			selectedDomain: this.selectedDomain,
			onDomainChanged: (domain) => {
				if (!domain.isPaid || a.isPaidSubscription()) this.selectedDomain = domain;
else Dialog.confirm(lang.makeTranslation("confirm_msg", `${lang.get("paidEmailDomainSignup_msg")}\n${lang.get("changePaidPlan_msg")}`)).then((confirmed) => {
					if (confirmed) vnode.attrs.onChangePlan();
				});
			},
			availableDomains: this.availableDomains,
			onValidationResult: (email, validationResult) => {
				this.__mailValid(validationResult.isValid);
				if (validationResult.isValid) {
					this._mailAddress = email;
					this.passwordModel.recalculatePasswordStrength();
					this._mailAddressFormErrorId = null;
				} else this._mailAddressFormErrorId = validationResult.errorId;
			},
			onBusyStateChanged: (isBusy) => {
				this._isMailVerificationBusy = isBusy;
			}
		};
		const confirmTermsCheckBoxAttrs = {
			label: renderTermsLabel,
			checked: this._confirmTerms(),
			onChecked: this._confirmTerms
		};
		const confirmAgeCheckBoxAttrs = {
			label: () => lang.get("ageConfirmation_msg"),
			checked: this._confirmAge(),
			onChecked: this._confirmAge
		};
		const submit = () => {
			if (this._isMailVerificationBusy) return;
			if (a.readonly) {
				this.__completePreviousStages();
				return a.onComplete(null);
			}
			const errorMessage = this._mailAddressFormErrorId || this.passwordModel.getErrorMessageId() || (!this._confirmTerms() ? "termsAcceptedNeutral_msg" : null);
			if (errorMessage) {
				Dialog.message(errorMessage);
				return;
			}
			const ageConfirmPromise = this._confirmAge() ? Promise.resolve(true) : Dialog.confirm("parentConfirmation_msg", "paymentDataValidation_action");
			ageConfirmPromise.then((confirmed) => {
				if (confirmed) {
					this.__completePreviousStages();
					return signup(this._mailAddress, this.passwordModel.getNewPassword(), this._code(), a.isBusinessUse(), a.isPaidSubscription(), a.campaign()).then((newAccountData) => {
						a.onComplete(newAccountData ? newAccountData : null);
					});
				}
			});
		};
		return mithril_default("#signup-account-dialog.flex-center", mithril_default(".flex-grow-shrink-auto.max-width-m.pt.pb.plr-l", [a.readonly ? mithril_default(TextField, {
			label: "mailAddress_label",
			value: a.prefilledMailAddress ?? "",
			autocompleteAs: Autocomplete.newPassword,
			isReadOnly: true
		}) : [
			mithril_default(SelectMailAddressForm, mailAddressFormAttrs),
			a.isPaidSubscription() ? mithril_default(".small.mt-s", lang.get("configureCustomDomainAfterSignup_msg"), [mithril_default(ExternalLink, {
				href: InfoLink.DomainInfo,
				isCompanySite: true
			})]) : null,
			mithril_default(PasswordForm, {
				model: this.passwordModel,
				passwordInfoKey: "passwordImportance_msg"
			}),
			getWhitelabelRegistrationDomains().length > 0 ? mithril_default(TextField, {
				value: this._code(),
				oninput: this._code,
				label: "whitelabelRegistrationCode_label"
			}) : null,
			mithril_default(Checkbox, confirmTermsCheckBoxAttrs),
			mithril_default("div", renderTermsAndConditionsButton(TermsSection.Terms, CURRENT_TERMS_VERSION)),
			mithril_default("div", renderTermsAndConditionsButton(TermsSection.Privacy, CURRENT_PRIVACY_VERSION)),
			mithril_default(Checkbox, confirmAgeCheckBoxAttrs)
		], mithril_default(".mt-l.mb-l", mithril_default(LoginButton, {
			label: "next_action",
			onclick: submit
		}))]));
	}
	async __completePreviousStages() {
		if (this.__signupFreeTest) {
			await this.__signupFreeTest.getStage(2).complete();
			await this.__signupFreeTest.getStage(3).complete();
			await this.__signupFreeTest.getStage(4).complete();
		}
		if (this.__signupPaidTest) {
			await this.__signupPaidTest.getStage(1).complete();
			await this.__signupPaidTest.getStage(2).complete();
			await this.__signupPaidTest.getStage(3).complete();
		}
	}
};
function renderTermsLabel() {
	return lang.get("termsAndConditions_label");
}
/**
* @return Signs the user up, if no captcha is needed or it has been solved correctly
*/
function signup(mailAddress, pw, registrationCode, isBusinessUse, isPaidSubscription, campaign) {
	const { customerFacade } = locator;
	const operation = locator.operationProgressTracker.startNewOperation();
	return showProgressDialog("createAccountRunning_msg", customerFacade.generateSignupKeys(operation.id).then((keyPairs) => {
		return runCaptchaFlow(mailAddress, isBusinessUse, isPaidSubscription, campaign).then(async (regDataId) => {
			if (regDataId) {
				const app = client.isCalendarApp() ? SubscriptionApp.Calendar : SubscriptionApp.Mail;
				return customerFacade.signup(keyPairs, AccountType.FREE, regDataId, mailAddress, pw, registrationCode, lang.code, app).then((recoverCode) => {
					return {
						mailAddress,
						password: pw,
						recoverCode
					};
				});
			}
		});
	}), operation.progress).catch(ofClass(InvalidDataError, () => {
		Dialog.message("invalidRegistrationCode_msg");
	})).finally(() => operation.done());
}

//#endregion
//#region ../src/common/subscription/SignupPage.ts
var SignupPage = class {
	dom;
	oncreate(vnode) {
		this.dom = vnode.dom;
	}
	view(vnode) {
		const data = vnode.attrs.data;
		const newAccountData = data.newAccountData;
		let mailAddress = undefined;
		if (newAccountData) mailAddress = newAccountData.mailAddress;
		return mithril_default(SignupForm, {
			onComplete: (newAccountData$1) => {
				if (newAccountData$1) data.newAccountData = newAccountData$1;
				emitWizardEvent(this.dom, WizardEventType.SHOW_NEXT_PAGE);
			},
			onChangePlan: () => {
				emitWizardEvent(this.dom, WizardEventType.SHOW_PREVIOUS_PAGE);
			},
			isBusinessUse: data.options.businessUse,
			isPaidSubscription: () => data.type !== PlanType.Free,
			campaign: () => data.registrationDataId,
			prefilledMailAddress: mailAddress,
			readonly: !!newAccountData
		});
	}
};
var SignupPageAttrs = class {
	data;
	constructor(signupData) {
		this.data = signupData;
	}
	headerTitle() {
		const title = getDisplayNameOfPlanType(this.data.type);
		if (this.data.type === PlanType.Essential || this.data.type === PlanType.Advanced) return lang.makeTranslation("signup_business", title + " Business");
else return lang.makeTranslation("signup_title", title);
	}
	nextAction(showErrorDialog) {
		return Promise.resolve(true);
	}
	isSkipAvailable() {
		return false;
	}
	isEnabled() {
		return true;
	}
};

//#endregion
//#region ../src/common/native/common/generatedipc/MobilePaymentResultType.ts
let MobilePaymentResultType = function(MobilePaymentResultType$1) {
	MobilePaymentResultType$1["Success"] = "0";
	MobilePaymentResultType$1["Cancelled"] = "1";
	MobilePaymentResultType$1["Pending"] = "2";
	return MobilePaymentResultType$1;
}({});

//#endregion
//#region ../src/common/subscription/UpgradeConfirmSubscriptionPage.ts
var UpgradeConfirmSubscriptionPage = class {
	dom;
	__signupPaidTest;
	__signupFreeTest;
	oncreate(vnode) {
		this.__signupPaidTest = locator.usageTestController.getTest("signup.paid");
		this.__signupFreeTest = locator.usageTestController.getTest("signup.free");
		this.dom = vnode.dom;
	}
	view({ attrs }) {
		return this.renderConfirmSubscription(attrs);
	}
	async upgrade(data) {
		if (data.paymentData.paymentMethod === PaymentMethodType.AppStore) {
			const success = await this.handleAppStorePayment(data);
			if (!success) return;
		}
		const serviceData = createSwitchAccountTypePostIn({
			accountType: AccountType.PAID,
			customer: null,
			plan: data.type,
			date: Const.CURRENT_DATE,
			referralCode: data.referralCode,
			specialPriceUserSingle: null,
			surveyData: null,
			app: client.isCalendarApp() ? SubscriptionApp.Calendar : SubscriptionApp.Mail
		});
		showProgressDialog("pleaseWait_msg", locator.serviceExecutor.post(SwitchAccountTypeService, serviceData).then(() => {
			return locator.customerFacade.switchFreeToPremiumGroup();
		})).then(() => {
			const orderConfirmationStage = this.__signupPaidTest?.getStage(5);
			orderConfirmationStage?.setMetric({
				name: "paymentMethod",
				value: PaymentMethodTypeToName[data.paymentData.paymentMethod]
			});
			orderConfirmationStage?.setMetric({
				name: "switchedFromFree",
				value: (this.__signupFreeTest?.isStarted() ?? false).toString()
			});
			orderConfirmationStage?.complete();
			return this.close(data, this.dom);
		}).then(async () => {
			const ratingCheckResult = await getRatingAllowed(new Date(), deviceConfig, isIOSApp());
			if (ratingCheckResult === RatingCheckResult.RATING_ALLOWED) setTimeout(async () => {
				void showAppRatingDialog();
			}, 2e3);
		}).catch(ofClass(PreconditionFailedError, (e) => {
			Dialog.message(lang.makeTranslation("precondition_failed", lang.get(getPreconditionFailedPaymentMsg(e.data)) + (data.upgradeType === UpgradeType.Signup ? " " + lang.get("accountWasStillCreated_msg") : "")));
		})).catch(ofClass(BadGatewayError, (e) => {
			Dialog.message(lang.makeTranslation("payment_failed", lang.get("paymentProviderNotAvailableError_msg") + (data.upgradeType === UpgradeType.Signup ? " " + lang.get("accountWasStillCreated_msg") : "")));
		}));
	}
	/** @return whether subscribed successfully */
	async handleAppStorePayment(data) {
		if (!locator.logins.isUserLoggedIn()) await locator.logins.createSession(neverNull(data.newAccountData).mailAddress, neverNull(data.newAccountData).password, SessionType.Temporary);
		const customerId = locator.logins.getUserController().user.customer;
		const customerIdBytes = base64ToUint8Array(base64ExtToBase64(customerId));
		try {
			const result = await showProgressDialog("pleaseWait_msg", locator.mobilePaymentsFacade.requestSubscriptionToPlan(appStorePlanName(data.type), data.options.paymentInterval(), customerIdBytes));
			if (result.result !== MobilePaymentResultType.Success) return false;
		} catch (e) {
			if (e instanceof MobilePaymentError) {
				console.error("AppStore subscription failed", e);
				Dialog.message("appStoreSubscriptionError_msg", e.message);
				return false;
			} else throw e;
		}
		return await updatePaymentData(data.options.paymentInterval(), data.invoiceData, data.paymentData, null, data.newAccountData != null, null, data.accountingInfo);
	}
	renderConfirmSubscription(attrs) {
		const isYearly = attrs.data.options.paymentInterval() === PaymentInterval.Yearly;
		const subscription = isYearly ? lang.get("pricing.yearly_label") : lang.get("pricing.monthly_label");
		return [
			mithril_default(".center.h4.pt", lang.get("upgradeConfirm_msg")),
			mithril_default(".pt.pb.plr-l", [
				mithril_default(TextField, {
					label: "subscription_label",
					value: getDisplayNameOfPlanType(attrs.data.type),
					isReadOnly: true
				}),
				mithril_default(TextField, {
					label: "paymentInterval_label",
					value: subscription,
					isReadOnly: true
				}),
				mithril_default(TextField, {
					label: isYearly && attrs.data.nextYearPrice ? "priceFirstYear_label" : "price_label",
					value: buildPriceString(attrs.data.price?.displayPrice ?? "0", attrs.data.options),
					isReadOnly: true
				}),
				this.renderPriceNextYear(attrs),
				mithril_default(TextField, {
					label: "paymentMethod_label",
					value: getPaymentMethodName(attrs.data.paymentData.paymentMethod),
					isReadOnly: true
				})
			]),
			mithril_default(".smaller.center.pt-l", attrs.data.options.businessUse() ? lang.get("pricing.subscriptionPeriodInfoBusiness_msg") : lang.get("pricing.subscriptionPeriodInfoPrivate_msg")),
			mithril_default(".flex-center.full-width.pt-l", mithril_default(LoginButton, {
				label: "buy_action",
				class: "small-login-button",
				onclick: () => this.upgrade(attrs.data)
			}))
		];
	}
	renderPriceNextYear(attrs) {
		return attrs.data.nextYearPrice ? mithril_default(TextField, {
			label: "priceForNextYear_label",
			value: buildPriceString(attrs.data.nextYearPrice.displayPrice, attrs.data.options),
			isReadOnly: true
		}) : null;
	}
	close(data, dom) {
		emitWizardEvent(dom, WizardEventType.SHOW_NEXT_PAGE);
	}
};
function buildPriceString(price, options) {
	return formatPriceWithInfo(price, options.paymentInterval(), !options.businessUse());
}

//#endregion
//#region ../src/common/subscription/UpgradeSubscriptionWizard.ts
var import_stream$2 = __toESM(require_stream(), 1);
assertMainOrNode();
async function showUpgradeWizard(logins, acceptedPlans = NewPaidPlans, msg) {
	const [customer, accountingInfo] = await Promise.all([logins.getUserController().loadCustomer(), logins.getUserController().loadAccountingInfo()]);
	const priceDataProvider = await PriceAndConfigProvider.getInitializedInstance(null, locator.serviceExecutor, null);
	const prices = priceDataProvider.getRawPricingData();
	const domainConfig = locator.domainConfigProvider().getCurrentDomainConfig();
	const featureListProvider = await FeatureListProvider.getInitializedInstance(domainConfig);
	const upgradeData = {
		options: {
			businessUse: (0, import_stream$2.default)(prices.business),
			paymentInterval: (0, import_stream$2.default)(asPaymentInterval(accountingInfo.paymentInterval))
		},
		invoiceData: {
			invoiceAddress: formatNameAndAddress(accountingInfo.invoiceName, accountingInfo.invoiceAddress),
			country: accountingInfo.invoiceCountry ? getByAbbreviation(accountingInfo.invoiceCountry) : null,
			vatNumber: accountingInfo.invoiceVatIdNo
		},
		paymentData: {
			paymentMethod: getPaymentMethodType(accountingInfo) || await getDefaultPaymentMethod(),
			creditCardData: null
		},
		price: null,
		type: PlanType.Revolutionary,
		nextYearPrice: null,
		accountingInfo,
		customer,
		newAccountData: null,
		registrationDataId: null,
		priceInfoTextId: priceDataProvider.getPriceInfoMessage(),
		upgradeType: UpgradeType.Initial,
		currentPlan: logins.getUserController().isFreeAccount() ? PlanType.Free : null,
		subscriptionParameters: null,
		planPrices: priceDataProvider,
		featureListProvider,
		referralCode: null,
		multipleUsersAllowed: false,
		acceptedPlans,
		msg: msg != null ? msg : null
	};
	const wizardPages = [
		wizardPageWrapper(UpgradeSubscriptionPage, new UpgradeSubscriptionPageAttrs(upgradeData)),
		wizardPageWrapper(InvoiceAndPaymentDataPage, new InvoiceAndPaymentDataPageAttrs(upgradeData)),
		wizardPageWrapper(UpgradeConfirmSubscriptionPage, new InvoiceAndPaymentDataPageAttrs(upgradeData))
	];
	if (isIOSApp()) wizardPages.splice(1, 1);
	const deferred = defer();
	const wizardBuilder = createWizardDialog(upgradeData, wizardPages, async () => {
		deferred.resolve();
	}, DialogType.EditLarge);
	wizardBuilder.dialog.show();
	return deferred.promise;
}
async function loadSignupWizard(subscriptionParameters, registrationDataId, referralCode, acceptedPlans = AvailablePlans) {
	const usageTestModel = locator.usageTestModel;
	usageTestModel.setStorageBehavior(StorageBehavior.Ephemeral);
	locator.usageTestController.setTests(await usageTestModel.loadActiveUsageTests());
	const priceDataProvider = await PriceAndConfigProvider.getInitializedInstance(registrationDataId, locator.serviceExecutor, referralCode);
	const prices = priceDataProvider.getRawPricingData();
	const domainConfig = locator.domainConfigProvider().getCurrentDomainConfig();
	const featureListProvider = await FeatureListProvider.getInitializedInstance(domainConfig);
	let message;
	if (isIOSApp()) {
		const appstoreSubscriptionOwnership = await queryAppStoreSubscriptionOwnership(null);
		if (appstoreSubscriptionOwnership !== MobilePaymentSubscriptionOwnership.NoSubscription) acceptedPlans = acceptedPlans.filter((plan) => plan === PlanType.Free);
		message = appstoreSubscriptionOwnership != MobilePaymentSubscriptionOwnership.NoSubscription ? lang.getTranslation("storeMultiSubscriptionError_msg", { "{AppStorePayment}": InfoLink.AppStorePayment }) : null;
	} else message = null;
	const signupData = {
		options: {
			businessUse: (0, import_stream$2.default)(prices.business),
			paymentInterval: (0, import_stream$2.default)(PaymentInterval.Yearly)
		},
		invoiceData: {
			invoiceAddress: "",
			country: null,
			vatNumber: ""
		},
		paymentData: {
			paymentMethod: await getDefaultPaymentMethod(),
			creditCardData: null
		},
		price: null,
		nextYearPrice: null,
		type: PlanType.Free,
		accountingInfo: null,
		customer: null,
		newAccountData: null,
		registrationDataId,
		priceInfoTextId: priceDataProvider.getPriceInfoMessage(),
		upgradeType: UpgradeType.Signup,
		planPrices: priceDataProvider,
		currentPlan: null,
		subscriptionParameters,
		featureListProvider,
		referralCode,
		multipleUsersAllowed: false,
		acceptedPlans,
		msg: message
	};
	const invoiceAttrs = new InvoiceAndPaymentDataPageAttrs(signupData);
	const wizardPages = [
		wizardPageWrapper(UpgradeSubscriptionPage, new UpgradeSubscriptionPageAttrs(signupData)),
		wizardPageWrapper(SignupPage, new SignupPageAttrs(signupData)),
		wizardPageWrapper(InvoiceAndPaymentDataPage, invoiceAttrs),
		wizardPageWrapper(UpgradeConfirmSubscriptionPage, invoiceAttrs),
		wizardPageWrapper(UpgradeCongratulationsPage, new UpgradeCongratulationsPageAttrs(signupData))
	];
	if (isIOSApp()) wizardPages.splice(2, 1);
	const wizardBuilder = createWizardDialog(signupData, wizardPages, async () => {
		if (locator.logins.isUserLoggedIn()) await locator.logins.logout(false);
		if (signupData.newAccountData) mithril_default.route.set("/login", {
			noAutoLogin: true,
			loginWith: signupData.newAccountData.mailAddress
		});
else mithril_default.route.set("/login", { noAutoLogin: true });
	}, DialogType.EditLarge);
	invoiceAttrs.setEnabledFunction(() => signupData.type !== PlanType.Free && wizardBuilder.attrs.currentPage !== wizardPages[0]);
	wizardBuilder.dialog.show();
}

//#endregion
//#region ../src/common/subscription/SignOrderProcessingAgreementDialog.ts
assertMainOrNode();

//#endregion
//#region ../src/common/subscription/SubscriptionViewer.ts
var import_stream$1 = __toESM(require_stream(), 1);
assertMainOrNode();
let SubscriptionApp = function(SubscriptionApp$1) {
	SubscriptionApp$1["Mail"] = "0";
	SubscriptionApp$1["Calendar"] = "1";
	return SubscriptionApp$1;
}({});

//#endregion
//#region ../src/common/subscription/SwitchSubscriptionDialog.ts
var import_stream = __toESM(require_stream(), 1);
async function showSwitchDialog(customer, customerInfo, accountingInfo, lastBooking, acceptedPlans, reason) {
	if (hasRunningAppStoreSubscription(accountingInfo) && !isIOSApp()) {
		await showManageThroughAppStoreDialog();
		return;
	}
	const [featureListProvider, priceAndConfigProvider] = await showProgressDialog("pleaseWait_msg", Promise.all([FeatureListProvider.getInitializedInstance(locator.domainConfigProvider().getCurrentDomainConfig()), PriceAndConfigProvider.getInitializedInstance(null, locator.serviceExecutor, null)]));
	const model = new SwitchSubscriptionDialogModel(customer, accountingInfo, await locator.logins.getUserController().getPlanType(), lastBooking);
	const cancelAction = () => {
		dialog.close();
	};
	const headerBarAttrs = {
		left: [{
			label: "cancel_action",
			click: cancelAction,
			type: ButtonType.Secondary
		}],
		right: [],
		middle: "subscription_label"
	};
	const currentPlanInfo = model.currentPlanInfo;
	const businessUse = (0, import_stream.default)(currentPlanInfo.businessUse);
	const paymentInterval = (0, import_stream.default)(PaymentInterval.Yearly);
	const multipleUsersAllowed = model.multipleUsersStillSupportedLegacy();
	const dialog = Dialog.largeDialog(headerBarAttrs, { view: () => mithril_default(".pt", mithril_default(SubscriptionSelector, {
		options: {
			businessUse,
			paymentInterval
		},
		priceInfoTextId: priceAndConfigProvider.getPriceInfoMessage(),
		msg: reason,
		boxWidth: 230,
		boxHeight: 270,
		acceptedPlans,
		currentPlanType: currentPlanInfo.planType,
		allowSwitchingPaymentInterval: currentPlanInfo.paymentInterval !== PaymentInterval.Yearly,
		actionButtons: subscriptionActionButtons,
		featureListProvider,
		priceAndConfigProvider,
		multipleUsersAllowed
	})) }).addShortcut({
		key: Keys.ESC,
		exec: cancelAction,
		help: "close_alt"
	}).setCloseHandler(cancelAction);
	const subscriptionActionButtons = {
		[PlanType.Free]: () => ({
			label: "pricing.select_action",
			onclick: () => onSwitchToFree(customer, dialog, currentPlanInfo)
		}),
		[PlanType.Revolutionary]: createPlanButton(dialog, PlanType.Revolutionary, currentPlanInfo, paymentInterval, accountingInfo),
		[PlanType.Legend]: createPlanButton(dialog, PlanType.Legend, currentPlanInfo, paymentInterval, accountingInfo),
		[PlanType.Essential]: createPlanButton(dialog, PlanType.Essential, currentPlanInfo, paymentInterval, accountingInfo),
		[PlanType.Advanced]: createPlanButton(dialog, PlanType.Advanced, currentPlanInfo, paymentInterval, accountingInfo),
		[PlanType.Unlimited]: createPlanButton(dialog, PlanType.Unlimited, currentPlanInfo, paymentInterval, accountingInfo)
	};
	dialog.show();
	return;
}
async function onSwitchToFree(customer, dialog, currentPlanInfo) {
	if (isIOSApp()) {
		const ownership = await locator.mobilePaymentsFacade.queryAppStoreSubscriptionOwnership(base64ToUint8Array(base64ExtToBase64(customer._id)));
		if (ownership === MobilePaymentSubscriptionOwnership.Owner && await locator.mobilePaymentsFacade.isAppStoreRenewalEnabled()) {
			await locator.mobilePaymentsFacade.showSubscriptionConfigView();
			await showProgressDialog("pleaseWait_msg", waitUntilRenewalDisabled());
			if (await locator.mobilePaymentsFacade.isAppStoreRenewalEnabled()) {
				console.log("AppStore renewal is still enabled, canceling downgrade");
				return;
			}
		}
	}
	const reason = await showLeavingUserSurveyWizard(true, true);
	const data = reason.submitted && reason.category && reason.reason ? createSurveyData({
		category: reason.category,
		reason: reason.reason,
		details: reason.details,
		version: SURVEY_VERSION_NUMBER
	}) : null;
	const newPlanType = await cancelSubscription(dialog, currentPlanInfo, customer, data);
	if (newPlanType === PlanType.Free) for (const importedMailSet of mailLocator.mailModel.getImportedMailSets()) mailLocator.mailModel.finallyDeleteCustomMailFolder(importedMailSet);
}
async function waitUntilRenewalDisabled() {
	for (let i = 0; i < 3; i++) {
		await delay(2e3);
		if (!await locator.mobilePaymentsFacade.isAppStoreRenewalEnabled()) return;
	}
}
async function doSwitchToPaidPlan(accountingInfo, newPaymentInterval, targetSubscription, dialog, currentPlanInfo) {
	if (isIOSApp() && getPaymentMethodType(accountingInfo) === PaymentMethodType.AppStore) {
		const customerIdBytes = base64ToUint8Array(base64ExtToBase64(assertNotNull(locator.logins.getUserController().user.customer)));
		dialog.close();
		try {
			await locator.mobilePaymentsFacade.requestSubscriptionToPlan(appStorePlanName(targetSubscription), newPaymentInterval, customerIdBytes);
		} catch (e) {
			if (e instanceof MobilePaymentError) {
				console.error("AppStore subscription failed", e);
				Dialog.message("appStoreSubscriptionError_msg", e.message);
			} else throw e;
		}
	} else {
		if (currentPlanInfo.paymentInterval !== newPaymentInterval) await locator.customerFacade.changePaymentInterval(accountingInfo, newPaymentInterval);
		await switchSubscription(targetSubscription, dialog, currentPlanInfo);
	}
}
function createPlanButton(dialog, targetSubscription, currentPlanInfo, newPaymentInterval, accountingInfo) {
	return () => ({
		label: "buy_action",
		onclick: async () => {
			if (LegacyPlans.includes(currentPlanInfo.planType) && !await Dialog.confirm(lang.getTranslation("upgradePlan_msg", { "{plan}": PlanTypeToName[targetSubscription] }))) return;
			await showProgressDialog("pleaseWait_msg", doSwitchToPaidPlan(accountingInfo, newPaymentInterval(), targetSubscription, dialog, currentPlanInfo));
		}
	});
}
function handleSwitchAccountPreconditionFailed(e) {
	const reason = e.data;
	if (reason == null) return Dialog.message("unknownError_msg");
else {
		let detailMsg;
		switch (reason) {
			case UnsubscribeFailureReason.TOO_MANY_ENABLED_USERS:
				detailMsg = lang.get("accountSwitchTooManyActiveUsers_msg");
				break;
			case UnsubscribeFailureReason.CUSTOM_MAIL_ADDRESS:
				detailMsg = lang.get("accountSwitchCustomMailAddress_msg");
				break;
			case UnsubscribeFailureReason.TOO_MANY_CALENDARS:
				detailMsg = lang.get("accountSwitchMultipleCalendars_msg");
				break;
			case UnsubscribeFailureReason.CALENDAR_TYPE:
				detailMsg = lang.get("accountSwitchSharedCalendar_msg");
				break;
			case UnsubscribeFailureReason.TOO_MANY_ALIASES:
			case BookingFailureReason.TOO_MANY_ALIASES:
				detailMsg = lang.get("accountSwitchAliases_msg");
				break;
			case UnsubscribeFailureReason.TOO_MUCH_STORAGE_USED:
			case BookingFailureReason.TOO_MUCH_STORAGE_USED:
				detailMsg = lang.get("storageCapacityTooManyUsedForBooking_msg");
				break;
			case UnsubscribeFailureReason.TOO_MANY_DOMAINS:
			case BookingFailureReason.TOO_MANY_DOMAINS:
				detailMsg = lang.get("tooManyCustomDomains_msg");
				break;
			case UnsubscribeFailureReason.HAS_TEMPLATE_GROUP:
			case BookingFailureReason.HAS_TEMPLATE_GROUP:
				detailMsg = lang.get("deleteTemplateGroups_msg");
				break;
			case UnsubscribeFailureReason.WHITELABEL_DOMAIN_ACTIVE:
			case BookingFailureReason.WHITELABEL_DOMAIN_ACTIVE:
				detailMsg = lang.get("whitelabelDomainExisting_msg");
				break;
			case UnsubscribeFailureReason.HAS_CONTACT_LIST_GROUP:
				detailMsg = lang.get("contactListExisting_msg");
				break;
			case UnsubscribeFailureReason.NOT_ENOUGH_CREDIT: return Dialog.message("insufficientBalanceError_msg");
			case UnsubscribeFailureReason.INVOICE_NOT_PAID: return Dialog.message("invoiceNotPaidSwitch_msg");
			case UnsubscribeFailureReason.ACTIVE_APPSTORE_SUBSCRIPTION: if (isIOSApp()) return locator.mobilePaymentsFacade.showSubscriptionConfigView();
else return showManageThroughAppStoreDialog();
			case UnsubscribeFailureReason.LABEL_LIMIT_EXCEEDED: return Dialog.message("labelLimitExceeded_msg");
			default: throw e;
		}
		return Dialog.message(lang.getTranslation("accountSwitchNotPossible_msg", { "{detailMsg}": detailMsg }));
	}
}
/**
* @param customer
* @param currentPlanInfo
* @param surveyData
* @returns the new plan type after the attempt.
*/
async function tryDowngradePremiumToFree(customer, currentPlanInfo, surveyData) {
	const switchAccountTypeData = createSwitchAccountTypePostIn({
		accountType: AccountType.FREE,
		date: Const.CURRENT_DATE,
		customer: customer._id,
		specialPriceUserSingle: null,
		referralCode: null,
		plan: PlanType.Free,
		surveyData,
		app: client.isCalendarApp() ? SubscriptionApp.Calendar : SubscriptionApp.Mail
	});
	try {
		await locator.serviceExecutor.post(SwitchAccountTypeService, switchAccountTypeData);
		await locator.customerFacade.switchPremiumToFreeGroup();
		return PlanType.Free;
	} catch (e) {
		if (e instanceof PreconditionFailedError) await handleSwitchAccountPreconditionFailed(e);
else if (e instanceof InvalidDataError) await Dialog.message("accountSwitchTooManyActiveUsers_msg");
else if (e instanceof BadRequestError) await Dialog.message("deactivatePremiumWithCustomDomainError_msg");
else throw e;
		return currentPlanInfo.planType;
	}
}
async function cancelSubscription(dialog, currentPlanInfo, customer, surveyData = null) {
	const confirmCancelSubscription = Dialog.confirm("unsubscribeConfirm_msg", "ok_action", () => {
		return mithril_default(".pt", mithril_default("ul.usage-test-opt-in-bullets", [
			mithril_default("li", lang.get("importedMailsWillBeDeleted_label")),
			mithril_default("li", lang.get("accountWillBeDeactivatedIn6Month_label")),
			mithril_default("li", lang.get("accountWillHaveLessStorage_label"))
		]));
	});
	if (!await confirmCancelSubscription) return currentPlanInfo.planType;
	try {
		return await showProgressDialog("pleaseWait_msg", tryDowngradePremiumToFree(customer, currentPlanInfo, surveyData));
	} finally {
		dialog.close();
	}
}
async function switchSubscription(targetSubscription, dialog, currentPlanInfo) {
	if (targetSubscription === currentPlanInfo.planType) return currentPlanInfo.planType;
	const userController = locator.logins.getUserController();
	const customer = await userController.loadCustomer();
	if (!customer.businessUse && NewBusinessPlans.includes(downcast(targetSubscription))) {
		const accountingInfo = await userController.loadAccountingInfo();
		const invoiceData = {
			invoiceAddress: formatNameAndAddress(accountingInfo.invoiceName, accountingInfo.invoiceAddress),
			country: accountingInfo.invoiceCountry ? getByAbbreviation(accountingInfo.invoiceCountry) : null,
			vatNumber: accountingInfo.invoiceVatIdNo
		};
		const updatedInvoiceData = await showSwitchToBusinessInvoiceDataDialog(customer, invoiceData, accountingInfo);
		if (!updatedInvoiceData) return currentPlanInfo.planType;
	}
	try {
		const postIn = createSwitchAccountTypePostIn({
			accountType: AccountType.PAID,
			plan: targetSubscription,
			date: Const.CURRENT_DATE,
			referralCode: null,
			customer: customer._id,
			specialPriceUserSingle: null,
			surveyData: null,
			app: client.isCalendarApp() ? SubscriptionApp.Calendar : SubscriptionApp.Mail
		});
		try {
			await showProgressDialog("pleaseWait_msg", locator.serviceExecutor.post(SwitchAccountTypeService, postIn));
			return targetSubscription;
		} catch (e) {
			if (e instanceof PreconditionFailedError) {
				await handleSwitchAccountPreconditionFailed(e);
				return currentPlanInfo.planType;
			}
			throw e;
		}
	} finally {
		dialog.close();
	}
}

//#endregion
export { SignupForm, loadSignupWizard, showSwitchDialog, showUpgradeWizard };
//# sourceMappingURL=SwitchSubscriptionDialog-Rk9U8Iqn.js.map