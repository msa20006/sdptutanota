{"version":3,"file":"DesktopSqlCipher-BloqMDJx.js","names":["nativeBindingPath: string","dbPath: string","integrityCheck: boolean","userId: string","dbKey: Uint8Array","Sqlite","query: string","params: TaggedSqlValue[]","userId: Id","errors: []"],"sources":["../../src/common/desktop/db/DesktopSqlCipher.ts"],"sourcesContent":["import { Database, default as Sqlite } from \"better-sqlite3\"\nimport { mapNullable, uint8ArrayToHex } from \"@tutao/tutanota-utils\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { OfflineDbClosedError } from \"../../api/common/error/OfflineDbClosedError.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\nimport { TaggedSqlValue, tagSqlObject, untagSqlValue } from \"../../api/worker/offline/SqlValue.js\"\n\nexport class DesktopSqlCipher implements SqlCipherFacade {\n\tprivate _db: Database | null = null\n\tprivate get db(): Database {\n\t\tif (this._db == null) {\n\t\t\tthrow new OfflineDbClosedError()\n\t\t}\n\t\treturn this._db\n\t}\n\n\t/**\n\t * @param nativeBindingPath the path to the sqlite native module\n\t * @param dbPath the path to the database file to use\n\t * @param integrityCheck whether to check the integrity of the db file during initialization\n\t */\n\tconstructor(private readonly nativeBindingPath: string, private readonly dbPath: string, private readonly integrityCheck: boolean) {\n\t\tprocess.on(\"exit\", () => this._db?.close())\n\t}\n\n\tasync openDb(userId: string, dbKey: Uint8Array): Promise<void> {\n\t\tthis._db = new Sqlite(this.dbPath, {\n\t\t\t// Remove ts-ignore once proper definition of Options exists, see https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/59049#\n\t\t\t// @ts-ignore missing type\n\t\t\tnativeBinding: this.nativeBindingPath,\n\t\t\t// verbose: (message, args) => console.log(\"DB\", message, args),\n\t\t})\n\t\ttry {\n\t\t\tthis.initSqlcipher({ databaseKey: dbKey, enableMemorySecurity: true, integrityCheck: this.integrityCheck })\n\t\t} catch (e) {\n\t\t\t// If we can't initialize the database we don't want to be stuck in a state where we hold the file lock, we need to retry the whole process again\n\t\t\tthis.db.close()\n\t\t\tthis._db = null\n\t\t\tthrow e // \"file is not a database\" is most likely wrong database key\n\t\t}\n\t}\n\n\tasync closeDb(): Promise<void> {\n\t\ttry {\n\t\t\t// We are performing defragmentation (incremental_vacuum) the database before closing.\n\t\t\t// But if it fails for some reason we don't want ot get stuck with non-closed database that we cannot delete so we close it and rethrow.\n\t\t\tthis.db.pragma(\"incremental_vacuum\")\n\t\t} finally {\n\t\t\tthis.db.close()\n\t\t\tthis._db = null\n\t\t}\n\t}\n\n\t/**\n\t * not implemented because we delete the DB directly from the per-window facade\n\t */\n\tdeleteDb(userId: string): Promise<void> {\n\t\tthrow new ProgrammingError(\"Not implemented\")\n\t}\n\n\t/**\n\t * Initialise sqlcipher with a database key, configuration:\n\t * - Sqlcipher always uses aes-256 for encryption.\n\t * - Sqlcipher always creates per page hmac for integrity with sha512.\n\t * - Sqlcipher generates a database salt value randomly and stores in the first 16 bytes of the database.\n\t * - We pass the database key directly to sqlcipher rather than using a password and therefore do not configure key derivation.\n\t * - we assume that adding entropy to entropy pool of the crypto provide (cipher_add_random) \"is not necessary [...], since [openssl] does (re-)seed itself automatically using trusted system entropy sources\", https://www.openssl.org/docs/man1.1.1/man3/RAND_add.html\n\t * @param databaseKey\n\t * @param enableMemorySecurity if true the the memory security option (that was default until 4.5, https://www.zetetic.net/blog/2021/10/28/sqlcipher-4.5.0-release/) to wipe memory allocated by SQLite internally, including the page cache is enabled.\n\t * @param integrityCheck: if true the hmac stored with each page of the database is verified to detect modification.\n\t * @throws if an error is detected during the integrity check\n\t */\n\tprivate initSqlcipher({\n\t\tdatabaseKey,\n\t\tenableMemorySecurity,\n\t\tintegrityCheck,\n\t}: {\n\t\tdatabaseKey: Uint8Array\n\t\tenableMemorySecurity: boolean\n\t\t// integrity check breaks tests\n\t\tintegrityCheck: boolean\n\t}) {\n\t\tif (enableMemorySecurity) {\n\t\t\tthis.db.pragma(\"cipher_memory_security = ON\")\n\t\t}\n\n\t\tconst key = `x'${uint8ArrayToHex(databaseKey)}'`\n\t\tthis.db.pragma(`KEY = \"${key}\"`)\n\n\t\t// We are using the auto_vacuum=incremental mode to allow for a faster vacuum execution\n\t\t// After changing the auto_vacuum mode we need to run \"vacuum\" once\n\t\t// auto_vacuum mode: 0 (NONE) | 1 (FULL) | 2 (INCREMENTAL)\n\t\tif (this.db.pragma(\"auto_vacuum\", { simple: true }) != 2) {\n\t\t\tthis.db.pragma(\"auto_vacuum = incremental\")\n\t\t\tthis.db.pragma(\"vacuum\")\n\t\t}\n\n\t\tif (integrityCheck) {\n\t\t\tthis.checkIntegrity()\n\t\t}\n\t}\n\n\t/**\n\t * Execute a query\n\t */\n\tasync run(query: string, params: TaggedSqlValue[]): Promise<void> {\n\t\tthis.db.prepare(query).run(params.map(untagSqlValue))\n\t}\n\n\t/**\n\t * Execute a query\n\t * @returns a single object or undefined if the query returns nothing\n\t */\n\tasync get(query: string, params: TaggedSqlValue[]): Promise<Record<string, TaggedSqlValue> | null> {\n\t\tconst result = this.db.prepare(query).get(params.map(untagSqlValue)) ?? null\n\t\treturn mapNullable(result, tagSqlObject)\n\t}\n\n\t/**\n\t * Execute a query\n\t * @returns a list of objects or an empty list if the query returns nothing\n\t */\n\tasync all(query: string, params: TaggedSqlValue[]): Promise<Array<Record<string, TaggedSqlValue>>> {\n\t\tconst result = this.db.prepare(query).all(params.map(untagSqlValue))\n\t\treturn result.map(tagSqlObject)\n\t}\n\n\t/**\n\t * not implemented because we lock the \"ranges\" DB directly from the per-window facade\n\t * we return Promise.resolve() in order to allow testing of the \"clearExcludedData\" function\n\t */\n\tlockRangesDbAccess(userId: Id): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n\n\t/**\n\t * not implemented because we unlock the \"ranges\" DB directly from the per-window facade\n\t * we return Promise.resolve() in order to allow testing of the \"clearExcludedData\" function\n\t */\n\tunlockRangesDbAccess(userId: Id): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n\n\tprivate checkIntegrity() {\n\t\t/**\n\t\t * Throws a CryptoError if MAC verification fails\n\t\t */\n\t\tconst errors: [] = this.db.pragma(\"cipher_integrity_check\")\n\t\tif (errors.length > 0) {\n\t\t\tthrow new CryptoError(`Integrity check failed with result : ${JSON.stringify(errors)}`)\n\t\t}\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAQa,mBAAN,MAAkD;CACxD,AAAQ,MAAuB;CAC/B,IAAY,KAAe;AAC1B,MAAI,KAAK,OAAO,KACf,OAAM,IAAI;AAEX,SAAO,KAAK;CACZ;;;;;;CAOD,YAA6BA,mBAA4CC,QAAiCC,gBAAyB;EAoInI,KApI6B;EAoI5B,KApIwE;EAoIvE,KApIwG;AACzG,UAAQ,GAAG,QAAQ,MAAM,KAAK,KAAK,OAAO,CAAC;CAC3C;CAED,MAAM,OAAOC,QAAgBC,OAAkC;AAC9D,OAAK,MAAM,IAAIC,MAAO,KAAK,QAAQ,EAGlC,eAAe,KAAK,kBAEpB;AACD,MAAI;AACH,QAAK,cAAc;IAAE,aAAa;IAAO,sBAAsB;IAAM,gBAAgB,KAAK;GAAgB,EAAC;EAC3G,SAAQ,GAAG;AAEX,QAAK,GAAG,OAAO;AACf,QAAK,MAAM;AACX,SAAM;EACN;CACD;CAED,MAAM,UAAyB;AAC9B,MAAI;AAGH,QAAK,GAAG,OAAO,qBAAqB;EACpC,UAAS;AACT,QAAK,GAAG,OAAO;AACf,QAAK,MAAM;EACX;CACD;;;;CAKD,SAASF,QAA+B;AACvC,QAAM,IAAI,iBAAiB;CAC3B;;;;;;;;;;;;;CAcD,AAAQ,cAAc,EACrB,aACA,sBACA,gBAMA,EAAE;AACF,MAAI,qBACH,MAAK,GAAG,OAAO,8BAA8B;EAG9C,MAAM,OAAO,IAAI,gBAAgB,YAAY,CAAC;AAC9C,OAAK,GAAG,QAAQ,SAAS,IAAI,GAAG;AAKhC,MAAI,KAAK,GAAG,OAAO,eAAe,EAAE,QAAQ,KAAM,EAAC,IAAI,GAAG;AACzD,QAAK,GAAG,OAAO,4BAA4B;AAC3C,QAAK,GAAG,OAAO,SAAS;EACxB;AAED,MAAI,eACH,MAAK,gBAAgB;CAEtB;;;;CAKD,MAAM,IAAIG,OAAeC,QAAyC;AACjE,OAAK,GAAG,QAAQ,MAAM,CAAC,IAAI,OAAO,IAAI,cAAc,CAAC;CACrD;;;;;CAMD,MAAM,IAAID,OAAeC,QAA0E;EAClG,MAAM,SAAS,KAAK,GAAG,QAAQ,MAAM,CAAC,IAAI,OAAO,IAAI,cAAc,CAAC,IAAI;AACxE,SAAO,YAAY,QAAQ,aAAa;CACxC;;;;;CAMD,MAAM,IAAID,OAAeC,QAA0E;EAClG,MAAM,SAAS,KAAK,GAAG,QAAQ,MAAM,CAAC,IAAI,OAAO,IAAI,cAAc,CAAC;AACpE,SAAO,OAAO,IAAI,aAAa;CAC/B;;;;;CAMD,mBAAmBC,QAA2B;AAC7C,SAAO,QAAQ,SAAS;CACxB;;;;;CAMD,qBAAqBA,QAA2B;AAC/C,SAAO,QAAQ,SAAS;CACxB;CAED,AAAQ,iBAAiB;;;;EAIxB,MAAMC,SAAa,KAAK,GAAG,OAAO,yBAAyB;AAC3D,MAAI,OAAO,SAAS,EACnB,OAAM,IAAI,aAAa,uCAAuC,KAAK,UAAU,OAAO,CAAC;CAEtF;AACD"}