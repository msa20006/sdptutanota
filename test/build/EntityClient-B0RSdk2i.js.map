{"version":3,"file":"EntityClient-B0RSdk2i.js","names":["target: EntityRestInterface","typeRef: TypeRef<T>","id: PropertyType<T, \"_id\">","opts: EntityRestClientLoadOptions","listId: Id","start?: Id","start: Id","end: Id","rangeItemLimit: number","count: number","reverse: boolean","listId: Id | null","elementIds: Id[]","ownerEncSessionKeyProvider?: OwnerEncSessionKeyProvider","instance: T","extraHeaders?: Dict","options?: EntityRestClientSetupOptions","instances: ReadonlyArray<T>","options?: EntityRestClientUpdateOptions","options?: EntityRestClientEraseOptions","groupId: Id","loadedEntities: Array<T>","filteredEntities: Array<T>","type: TypeRef<T>","entityClient: EntityClient","toLoad: Array<IdTuple>"],"sources":["../../src/common/api/common/EntityClient.ts"],"sourcesContent":["import {\n\tEntityRestClientEraseOptions,\n\tEntityRestClientLoadOptions,\n\tEntityRestClientSetupOptions,\n\tEntityRestClientUpdateOptions,\n\tEntityRestInterface,\n\tOwnerEncSessionKeyProvider,\n} from \"../worker/rest/EntityRestClient\"\nimport type { RootInstance } from \"../entities/sys/TypeRefs.js\"\nimport { RootInstanceTypeRef } from \"../entities/sys/TypeRefs.js\"\nimport {\n\tCUSTOM_MIN_ID,\n\telementIdPart,\n\tfirstBiggerThanSecond,\n\tGENERATED_MIN_ID,\n\tgetElementId,\n\tgetLetId,\n\tlistIdPart,\n\tRANGE_ITEM_LIMIT,\n} from \"./utils/EntityUtils\"\nimport { Type, ValueType } from \"./EntityConstants.js\"\nimport { downcast, groupByAndMap, last, promiseMap, TypeRef } from \"@tutao/tutanota-utils\"\nimport { resolveTypeReference } from \"./EntityFunctions\"\nimport type { ElementEntity, ListElementEntity, SomeEntity } from \"./EntityTypes\"\nimport { NotAuthorizedError, NotFoundError } from \"./error/RestError.js\"\n\nexport class EntityClient {\n\t_target: EntityRestInterface\n\n\tconstructor(target: EntityRestInterface) {\n\t\tthis._target = target\n\t}\n\n\t/**\n\t * Important: we can't pass functions through the bridge, so we can't pass ownerKeyProvider from the page context.\n\t */\n\tload<T extends SomeEntity>(typeRef: TypeRef<T>, id: PropertyType<T, \"_id\">, opts: EntityRestClientLoadOptions = {}): Promise<T> {\n\t\treturn this._target.load(typeRef, id, opts)\n\t}\n\n\tasync loadAll<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, start?: Id): Promise<T[]> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\n\t\tif (!start) {\n\t\t\tstart = typeModel.values[\"_id\"].type === ValueType.GeneratedId ? GENERATED_MIN_ID : CUSTOM_MIN_ID\n\t\t}\n\n\t\tconst elements = await this.loadRange<T>(typeRef, listId, start, RANGE_ITEM_LIMIT, false)\n\t\tif (elements.length === RANGE_ITEM_LIMIT) {\n\t\t\tlet lastElementId = getLetId(elements[elements.length - 1])[1]\n\t\t\tconst nextElements = await this.loadAll<T>(typeRef, listId, lastElementId)\n\t\t\treturn elements.concat(nextElements)\n\t\t} else {\n\t\t\treturn elements\n\t\t}\n\t}\n\n\tasync loadReverseRangeBetween<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tend: Id,\n\t\trangeItemLimit: number = RANGE_ITEM_LIMIT,\n\t): Promise<{\n\t\telements: T[]\n\t\tloadedCompletely: boolean\n\t}> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tif (typeModel.type !== Type.ListElement) throw new Error(\"only ListElement types are permitted\")\n\t\tconst loadedEntities = await this._target.loadRange<T>(typeRef, listId, start, rangeItemLimit, true)\n\t\tconst filteredEntities = loadedEntities.filter((entity) => firstBiggerThanSecond(getElementId(entity), end, typeModel))\n\n\t\tif (filteredEntities.length === rangeItemLimit) {\n\t\t\tconst lastElementId = getElementId(filteredEntities[loadedEntities.length - 1])\n\t\t\tconst { elements: remainingEntities, loadedCompletely } = await this.loadReverseRangeBetween<T>(typeRef, listId, lastElementId, end, rangeItemLimit)\n\t\t\treturn {\n\t\t\t\telements: filteredEntities.concat(remainingEntities),\n\t\t\t\tloadedCompletely,\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\telements: filteredEntities,\n\t\t\t\tloadedCompletely: wasReverseRangeCompletelyLoaded(rangeItemLimit, loadedEntities, filteredEntities),\n\t\t\t}\n\t\t}\n\t}\n\n\tloadRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\topts: EntityRestClientLoadOptions = {},\n\t): Promise<T[]> {\n\t\treturn this._target.loadRange(typeRef, listId, start, count, reverse, opts)\n\t}\n\n\t/**\n\t * load multiple does not guarantee order or completeness of returned elements.\n\t */\n\tloadMultiple<T extends SomeEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id | null,\n\t\telementIds: Id[],\n\t\townerEncSessionKeyProvider?: OwnerEncSessionKeyProvider,\n\t\topts: EntityRestClientLoadOptions = {},\n\t): Promise<T[]> {\n\t\treturn this._target.loadMultiple(typeRef, listId, elementIds, ownerEncSessionKeyProvider, opts)\n\t}\n\n\tsetup<T extends SomeEntity>(listId: Id | null, instance: T, extraHeaders?: Dict, options?: EntityRestClientSetupOptions): Promise<Id> {\n\t\treturn this._target.setup(listId, instance, extraHeaders, options)\n\t}\n\n\tsetupMultipleEntities<T extends SomeEntity>(listId: Id | null, instances: ReadonlyArray<T>): Promise<Array<Id>> {\n\t\treturn this._target.setupMultiple(listId, instances)\n\t}\n\n\tupdate<T extends SomeEntity>(instance: T, options?: EntityRestClientUpdateOptions): Promise<void> {\n\t\treturn this._target.update(instance, options)\n\t}\n\n\terase<T extends SomeEntity>(instance: T, options?: EntityRestClientEraseOptions): Promise<void> {\n\t\treturn this._target.erase(instance, options)\n\t}\n\n\tasync loadRoot<T extends ElementEntity>(typeRef: TypeRef<T>, groupId: Id, opts: EntityRestClientLoadOptions = {}): Promise<T> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst rootId = [groupId, typeModel.rootId] as const\n\t\tconst root = await this.load<RootInstance>(RootInstanceTypeRef, rootId, opts)\n\t\treturn this.load<T>(typeRef, downcast(root.reference), opts)\n\t}\n}\n\nfunction wasReverseRangeCompletelyLoaded<T extends ListElementEntity>(rangeItemLimit: number, loadedEntities: Array<T>, filteredEntities: Array<T>): boolean {\n\tif (loadedEntities.length < rangeItemLimit) {\n\t\tconst lastLoaded = last(loadedEntities)\n\t\tconst lastFiltered = last(filteredEntities)\n\n\t\tif (!lastLoaded) {\n\t\t\treturn true\n\t\t}\n\n\t\treturn lastLoaded === lastFiltered\n\t}\n\n\treturn false\n}\n\n/**\n * load multiple instances of the same type concurrently from multiple lists using\n * one request per list if possible\n *\n * @returns an array of all the instances excluding the ones throwing NotFoundError or NotAuthorizedError, in arbitrary order.\n */\nexport async function loadMultipleFromLists<T extends ListElementEntity>(\n\ttype: TypeRef<T>,\n\tentityClient: EntityClient,\n\ttoLoad: Array<IdTuple>,\n): Promise<Array<T>> {\n\tif (toLoad.length === 0) {\n\t\treturn []\n\t}\n\tconst indexedEventIds = groupByAndMap<IdTuple, Id, Id>(toLoad, listIdPart, elementIdPart)\n\n\treturn (\n\t\tawait promiseMap(\n\t\t\tindexedEventIds,\n\t\t\tasync ([listId, elementIds]) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await entityClient.loadMultiple(type, listId, elementIds)\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// these are thrown if the list itself is inaccessible. elements will just be missing\n\t\t\t\t\t// in the loadMultiple result.\n\t\t\t\t\tif (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\t\t\tconsole.log(`could not load entities of type ${type} from list ${listId}: ${e.name}`)\n\t\t\t\t\t\treturn []\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ concurrency: 3 },\n\t\t)\n\t).flat()\n}\n"],"mappings":"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"}