{"version":3,"file":"ErrorHandler-DbW1lJbv.js","names":["ms: number","fn: () => Promise<R>","e: Error","e"],"sources":["../../src/common/misc/ErrorHandler.ts"],"sourcesContent":["/**\n * @file Handler for all the uncaught errors.\n * ErrorHandler is decoupled from ErrorHandlerImpl to reduce boot bundle size.\n */\nimport { assertMainOrNodeBoot, isTest } from \"../api/common/Env\"\nimport { delay } from \"@tutao/tutanota-utils\"\n\nassertMainOrNodeBoot()\n\n/** Produced async function which will not try to run more often than @param ms. Does not cache the result. */\nfunction produceThrottledFunction<R>(ms: number, fn: () => Promise<R>): () => Promise<R> {\n\tlet lastTry = 0\n\treturn async () => {\n\t\tconst previousTry = lastTry\n\t\tlastTry = Date.now()\n\t\tconst sincePreviousTry = Date.now() - previousTry\n\n\t\t// |---|----|--------------|-----|\n\t\t//   1001  1003           1011\n\t\t//    a     b              c\n\t\t// ms: 10\n\t\t// a: previousTry\n\t\t// b: Date.now()\n\t\t// c: previousTry + ms\n\t\t// If the last call was at 1001 and we are now calling fn again at 1003 then we want to wait until 1011 which would be (a + ms) - b.\n\n\t\tif (previousTry !== 0 && sincePreviousTry < ms) {\n\t\t\tconst waitShouldEndAt = previousTry + ms\n\t\t\tconst timeUntilWaitEnd = waitShouldEndAt - Date.now()\n\t\t\tawait delay(timeUntilWaitEnd)\n\t\t}\n\n\t\treturn fn()\n\t}\n}\n\n/**\n * Throttled error handler. We have issues with error loops when reloading the page in Firefox and this gives browser a break of event\n * loop to be able to reload the page properly.\n * */\nconst importErrorHandler = produceThrottledFunction(200, () => import(\"./ErrorHandlerImpl.js\"))\n\nexport async function handleUncaughtError(e: Error) {\n\tif (isTest()) {\n\t\tthrow e\n\t}\n\n\ttry {\n\t\tconsole.log(\"error\", e, e.stack)\n\t\tconst { handleUncaughtErrorImpl } = await importErrorHandler()\n\t\tawait handleUncaughtErrorImpl(e)\n\t} catch (e) {\n\t\tconsole.error(\"Encountered error when trying to handle errors with ErrorHandlerImpl\", e)\n\t}\n}\n\nexport async function disableErrorHandlingDuringLogout() {\n\ttry {\n\t\tconst { disableErrorHandlingDuringLogout } = await importErrorHandler()\n\t\tdisableErrorHandlingDuringLogout()\n\t} catch (e) {\n\t\tconsole.error(\"Could not import ErrorHandlerImpl\", e)\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,sBAAsB;;AAGtB,SAAS,yBAA4BA,IAAYC,IAAwC;CACxF,IAAI,UAAU;AACd,QAAO,YAAY;EAClB,MAAM,cAAc;AACpB,YAAU,KAAK,KAAK;EACpB,MAAM,mBAAmB,KAAK,KAAK,GAAG;AAWtC,MAAI,gBAAgB,KAAK,mBAAmB,IAAI;GAC/C,MAAM,kBAAkB,cAAc;GACtC,MAAM,mBAAmB,kBAAkB,KAAK,KAAK;AACrD,SAAM,MAAM,iBAAiB;EAC7B;AAED,SAAO,IAAI;CACX;AACD;;;;;AAMD,MAAM,qBAAqB,yBAAyB,KAAK,MAAM,OAAO,kCAAyB;AAExF,eAAe,oBAAoBC,GAAU;AACnD,KAAI,QAAQ,CACX,OAAM;AAGP,KAAI;AACH,UAAQ,IAAI,SAAS,GAAG,EAAE,MAAM;EAChC,MAAM,EAAE,yBAAyB,GAAG,MAAM,oBAAoB;AAC9D,QAAM,wBAAwB,EAAE;CAChC,SAAQC,KAAG;AACX,UAAQ,MAAM,wEAAwEA,IAAE;CACxF;AACD"}