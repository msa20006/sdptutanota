{"version":3,"file":"ConfigurationDatabase-ClkJ3kmL.js","names":["VERSION: number","DB_KEY_PREFIX: string","ExternalImageListOS: ObjectStoreName","ConfigurationMetaDataOS: ObjectStoreName","item: string","key: Aes256Key","iv: Uint8Array","encryptedAddress: Uint8Array","keyLoaderFacade: KeyLoaderFacade","userFacade: UserFacade","dbLoadFn: (arg0: User, arg1: KeyLoaderFacade) => Promise<ConfigDb>","user: User","keyLoaderFacade","address: string","rule: ExternalImageRule","db","metaData","batch: QueuedBatch","userId: Id","metaData: EncryptedDbKeyBaseMetaData","db: DbFacade","id: string","objectStoreName: ObjectStoreName","userGroupKey: VersionedKey","dbKey: AesKey","dbIv: Uint8Array","objectStoreName: string"],"sources":["../../src/common/api/worker/facades/lazy/ConfigurationDatabase.ts"],"sourcesContent":["import { b64UserIdHash, DbFacade } from \"../../search/DbFacade.js\"\nimport { assertNotNull, concat, downcast, isSameTypeRefByAttr, LazyLoaded, stringToUtf8Uint8Array, utf8Uint8ArrayToString } from \"@tutao/tutanota-utils\"\nimport { User, UserTypeRef } from \"../../../entities/sys/TypeRefs.js\"\nimport { ExternalImageRule, OperationType } from \"../../../common/TutanotaConstants.js\"\nimport {\n\tAes128Key,\n\tAes256Key,\n\taes256RandomKey,\n\taesEncrypt,\n\tAesKey,\n\tdecryptKey,\n\tIV_BYTE_LENGTH,\n\trandom,\n\tunauthenticatedAesDecrypt,\n} from \"@tutao/tutanota-crypto\"\nimport { UserFacade } from \"../UserFacade.js\"\nimport { EncryptedDbKeyBaseMetaData, EncryptedIndexerMetaData, Metadata, ObjectStoreName } from \"../../search/IndexTables.js\"\nimport { DbError } from \"../../../common/error/DbError.js\"\nimport { KeyLoaderFacade } from \"../KeyLoaderFacade.js\"\nimport type { QueuedBatch } from \"../../EventQueue.js\"\nimport { encryptKeyWithVersionedKey, VersionedKey } from \"../../crypto/CryptoWrapper.js\"\n\nconst VERSION: number = 2\nconst DB_KEY_PREFIX: string = \"ConfigStorage\"\nconst ExternalImageListOS: ObjectStoreName = \"ExternalAllowListOS\"\nexport const ConfigurationMetaDataOS: ObjectStoreName = \"MetaDataOS\"\ntype EncryptionMetadata = {\n\treadonly key: Aes128Key\n\treadonly iv: Uint8Array\n}\ntype ConfigDb = {\n\treadonly db: DbFacade\n\treadonly metaData: EncryptionMetadata\n}\n\n/** @PublicForTesting */\nexport async function encryptItem(item: string, key: Aes256Key, iv: Uint8Array): Promise<Uint8Array> {\n\treturn aesEncrypt(key, stringToUtf8Uint8Array(item), iv, true)\n}\n\nexport async function decryptLegacyItem(encryptedAddress: Uint8Array, key: Aes256Key, iv: Uint8Array): Promise<string> {\n\treturn utf8Uint8ArrayToString(unauthenticatedAesDecrypt(key, concat(iv, encryptedAddress)))\n}\n\n/**\n * A local configuration database that can be used as an alternative to DeviceConfig:\n * Ideal for cases where the configuration values should be stored encrypted,\n * Or when the configuration is a growing list or object, which would be unsuitable for localStorage\n * Or when the configuration is only required in the Worker\n */\nexport class ConfigurationDatabase {\n\t// visible for testing\n\treadonly db: LazyLoaded<ConfigDb>\n\n\tconstructor(\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t\tuserFacade: UserFacade,\n\t\tdbLoadFn: (arg0: User, arg1: KeyLoaderFacade) => Promise<ConfigDb> = (user: User, keyLoaderFacade: KeyLoaderFacade) =>\n\t\t\tthis.loadConfigDb(user, keyLoaderFacade),\n\t) {\n\t\tthis.db = new LazyLoaded(() => {\n\t\t\tconst user = assertNotNull(userFacade.getLoggedInUser())\n\t\t\treturn dbLoadFn(user, keyLoaderFacade)\n\t\t})\n\t}\n\n\tasync addExternalImageRule(address: string, rule: ExternalImageRule): Promise<void> {\n\t\tconst { db, metaData } = await this.db.getAsync()\n\t\tif (!db.indexingSupported) return\n\t\tconst encryptedAddress = await encryptItem(address, metaData.key, metaData.iv)\n\t\treturn addAddressToImageList(db, encryptedAddress, rule)\n\t}\n\n\tasync getExternalImageRule(address: string): Promise<ExternalImageRule> {\n\t\tconst { db, metaData } = await this.db.getAsync()\n\t\tif (!db.indexingSupported) return ExternalImageRule.None\n\t\tconst encryptedAddress = await encryptItem(address, metaData.key, metaData.iv)\n\t\tconst transaction = await db.createTransaction(true, [ExternalImageListOS])\n\t\tconst entry = await transaction.get(ExternalImageListOS, encryptedAddress)\n\t\tlet rule = ExternalImageRule.None\n\n\t\tif (entry != null) {\n\t\t\tif (entry.rule != null) {\n\t\t\t\trule = entry.rule\n\t\t\t} else {\n\t\t\t\t// No rule set from earlier version means Allow\n\t\t\t\tawait addAddressToImageList(db, encryptedAddress, ExternalImageRule.Allow)\n\t\t\t\trule = ExternalImageRule.Allow\n\t\t\t}\n\t\t}\n\n\t\treturn rule\n\t}\n\n\tasync loadConfigDb(user: User, keyLoaderFacade: KeyLoaderFacade): Promise<ConfigDb> {\n\t\tconst id = this.getDbId(user._id)\n\t\tconst db = new DbFacade(VERSION, async (event, db, dbFacade) => {\n\t\t\tif (event.oldVersion === 0) {\n\t\t\t\tdb.createObjectStore(ConfigurationMetaDataOS)\n\t\t\t\tdb.createObjectStore(ExternalImageListOS, {\n\t\t\t\t\tkeyPath: \"address\",\n\t\t\t\t})\n\t\t\t}\n\t\t\tconst metaData =\n\t\t\t\t(await loadEncryptionMetadata(dbFacade, id, keyLoaderFacade, ConfigurationMetaDataOS)) ||\n\t\t\t\t(await initializeDb(dbFacade, id, keyLoaderFacade, ConfigurationMetaDataOS))\n\n\t\t\tif (event.oldVersion === 1) {\n\t\t\t\t// migrate from plain, mac-and-static-iv aes256 to aes256 with mac\n\t\t\t\tconst transaction = await dbFacade.createTransaction(true, [ExternalImageListOS])\n\t\t\t\tconst entries = await transaction.getAll(ExternalImageListOS)\n\t\t\t\tconst { key, iv } = metaData\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tconst address = await decryptLegacyItem(new Uint8Array(downcast(entry.key)), key, iv)\n\t\t\t\t\tawait this.addExternalImageRule(address, entry.value.rule)\n\t\t\t\t\tconst deleteTransaction = await dbFacade.createTransaction(false, [ExternalImageListOS])\n\t\t\t\t\tawait deleteTransaction.delete(ExternalImageListOS, entry.key)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tconst metaData =\n\t\t\t(await loadEncryptionMetadata(db, id, keyLoaderFacade, ConfigurationMetaDataOS)) ||\n\t\t\t(await initializeDb(db, id, keyLoaderFacade, ConfigurationMetaDataOS))\n\t\treturn {\n\t\t\tdb,\n\t\t\tmetaData,\n\t\t}\n\t}\n\n\tasync onEntityEventsReceived(batch: QueuedBatch): Promise<any> {\n\t\tconst { events, groupId, batchId } = batch\n\t\tfor (const event of events) {\n\t\t\tif (!(event.operation === OperationType.UPDATE && isSameTypeRefByAttr(UserTypeRef, event.application, event.type))) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconst configDb = await this.db.getAsync()\n\t\t\tif (configDb.db.isSameDbId(this.getDbId(event.instanceId))) {\n\t\t\t\treturn updateEncryptionMetadata(configDb.db, this.keyLoaderFacade, ConfigurationMetaDataOS)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync delete(userId: Id): Promise<void> {\n\t\tconst dbId = this.getDbId(userId)\n\t\tif (this.db.isLoadedOrLoading()) {\n\t\t\tconst { db } = await this.db.getAsync()\n\t\t\tawait db.deleteDatabase(dbId)\n\t\t} else {\n\t\t\tawait DbFacade.deleteDb(dbId)\n\t\t}\n\t}\n\n\tprivate getDbId(userId: Id): string {\n\t\treturn `${DB_KEY_PREFIX}_${b64UserIdHash(userId)}`\n\t}\n}\n\nasync function decryptMetaData(keyLoaderFacade: KeyLoaderFacade, metaData: EncryptedDbKeyBaseMetaData): Promise<EncryptionMetadata> {\n\tconst userGroupKey = await keyLoaderFacade.loadSymUserGroupKey(metaData.userGroupKeyVersion)\n\tconst key = decryptKey(userGroupKey, metaData.userEncDbKey)\n\tconst iv = unauthenticatedAesDecrypt(key, metaData.encDbIv)\n\treturn {\n\t\tkey,\n\t\tiv,\n\t}\n}\n\n/**\n * Load the encryption key and iv from the db\n * @return { key, iv } or null if one or both don't exist\n * @VisibleForTesting\n */\nexport async function loadEncryptionMetadata(\n\tdb: DbFacade,\n\tid: string,\n\tkeyLoaderFacade: KeyLoaderFacade,\n\tobjectStoreName: ObjectStoreName,\n): Promise<EncryptionMetadata | null> {\n\tawait db.open(id)\n\tconst metaData = await getMetaData(db, objectStoreName)\n\tif (metaData != null) {\n\t\treturn await decryptMetaData(keyLoaderFacade, metaData)\n\t} else {\n\t\treturn null\n\t}\n}\n\n/**\n * Reencrypt the DB key and IV if there is a new userGroupKey\n * @VisibleForTesting\n */\nexport async function updateEncryptionMetadata(db: DbFacade, keyLoaderFacade: KeyLoaderFacade, objectStoreName: ObjectStoreName): Promise<void> {\n\tconst metaData = await getMetaData(db, objectStoreName)\n\tconst currentUserGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey()\n\n\tif (metaData == null || currentUserGroupKey.version === metaData.userGroupKeyVersion) return\n\n\tconst encryptionMetadata = await decryptMetaData(keyLoaderFacade, metaData)\n\tif (encryptionMetadata == null) return\n\tconst { key, iv } = encryptionMetadata\n\tawait encryptAndSaveDbKey(currentUserGroupKey, key, iv, db, objectStoreName)\n}\n\n/**\n * Helper function to get the group key version for the group key that was used to encrypt the db key. In case the version has not been written to the db we assume 0.\n * @param db the dbFacade corresponding to the object store\n * @param objectStoreName the objectStore to get the metadata from\n */\nexport async function getMetaData(db: DbFacade, objectStoreName: ObjectStoreName): Promise<EncryptedDbKeyBaseMetaData | null> {\n\tconst transaction = await db.createTransaction(true, [objectStoreName])\n\tconst userEncDbKey = (await transaction.get(objectStoreName, Metadata.userEncDbKey)) as Uint8Array\n\tconst encDbIv = (await transaction.get(objectStoreName, Metadata.encDbIv)) as Uint8Array\n\tconst userGroupKeyVersion = (await transaction.get<number>(objectStoreName, Metadata.userGroupKeyVersion)) ?? 0 // was not written for old dbs\n\tif (userEncDbKey == null || encDbIv == null) {\n\t\treturn null\n\t} else {\n\t\treturn {\n\t\t\tuserEncDbKey,\n\t\t\tencDbIv,\n\t\t\tuserGroupKeyVersion,\n\t\t}\n\t}\n}\n\n/**\n * Helper function to get the group key version for the group key that was used to encrypt the db key. In case the version has not been written to the db we assume 0.\n * @param db the dbFacade corresponding to the object store\n * @param objectStoreName the objectStore to get the metadata from\n */\nexport async function getIndexerMetaData(db: DbFacade, objectStoreName: ObjectStoreName): Promise<EncryptedIndexerMetaData | null> {\n\tconst transaction = await db.createTransaction(true, [objectStoreName])\n\tconst userEncDbKey = (await transaction.get(objectStoreName, Metadata.userEncDbKey)) as Uint8Array\n\tconst encDbIv = (await transaction.get(objectStoreName, Metadata.encDbIv)) as Uint8Array\n\tconst userGroupKeyVersion = (await transaction.get<number>(objectStoreName, Metadata.userGroupKeyVersion)) ?? 0 // was not written for old dbs\n\tconst mailIndexingEnabled = (await transaction.get(objectStoreName, Metadata.mailIndexingEnabled)) as boolean\n\tconst excludedListIds = (await transaction.get(objectStoreName, Metadata.excludedListIds)) as Id[]\n\tconst lastEventIndexTimeMs = (await transaction.get(objectStoreName, Metadata.lastEventIndexTimeMs)) as number\n\tif (userEncDbKey == null || encDbIv == null) {\n\t\treturn null\n\t} else {\n\t\treturn {\n\t\t\tuserEncDbKey,\n\t\t\tencDbIv,\n\t\t\tuserGroupKeyVersion,\n\t\t\tmailIndexingEnabled,\n\t\t\texcludedListIds,\n\t\t\tlastEventIndexTimeMs,\n\t\t}\n\t}\n}\n\nasync function encryptAndSaveDbKey(userGroupKey: VersionedKey, dbKey: AesKey, dbIv: Uint8Array, db: DbFacade, objectStoreName: string) {\n\tconst transaction = await db.createTransaction(false, [objectStoreName]) // create a new transaction to avoid timeouts and for writing\n\tconst groupEncSessionKey = encryptKeyWithVersionedKey(userGroupKey, dbKey)\n\tawait transaction.put(objectStoreName, Metadata.userEncDbKey, groupEncSessionKey.key)\n\tawait transaction.put(objectStoreName, Metadata.userGroupKeyVersion, groupEncSessionKey.encryptingKeyVersion)\n\tawait transaction.put(objectStoreName, Metadata.encDbIv, aesEncrypt(dbKey, dbIv))\n}\n\n/**\n * @caution This will clear any existing data in the database, because they key and IV will be regenerated\n * @return the newly generated key and iv for the database contents\n * @VisibleForTesting\n *\n */\nexport async function initializeDb(db: DbFacade, id: string, keyLoaderFacade: KeyLoaderFacade, objectStoreName: ObjectStoreName): Promise<EncryptionMetadata> {\n\tawait db.deleteDatabase(id).then(() => db.open(id))\n\tconst key = aes256RandomKey()\n\tconst iv = random.generateRandomData(IV_BYTE_LENGTH)\n\tconst userGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey()\n\tawait encryptAndSaveDbKey(userGroupKey, key, iv, db, objectStoreName)\n\treturn {\n\t\tkey,\n\t\tiv,\n\t}\n}\n\nasync function addAddressToImageList(db: DbFacade, encryptedAddress: Uint8Array, rule: ExternalImageRule): Promise<void> {\n\ttry {\n\t\tconst transaction = await db.createTransaction(false, [ExternalImageListOS])\n\t\tawait transaction.put(ExternalImageListOS, null, {\n\t\t\taddress: encryptedAddress,\n\t\t\trule: rule,\n\t\t})\n\t} catch (e) {\n\t\tif (e instanceof DbError) {\n\t\t\tconsole.error(\"failed to add address to image list:\", e.message)\n\t\t\treturn\n\t\t}\n\t\tthrow e\n\t}\n}\n"],"mappings":"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"}