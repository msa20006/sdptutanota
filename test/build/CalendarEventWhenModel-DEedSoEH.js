
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { TIMESTAMP_ZERO_YEAR, assertNotNull, clone, filterInt, incrementDate, noOp, pad } from "./dist-CJHwsXKY.js";
import { EndType, RepeatPeriod } from "./TutanotaConstants-3bwAESYA.js";
import { DateTime } from "./luxon-D6cgmg6Q.js";
import { getAllDayDateUTC, getEventWithDefaultTimes, isAllDayEvent } from "./CommonCalendarUtils-DKaO7v1K.js";
import { createDateWrapper, createRepeatRule } from "./TypeRefs-BP1jvX9p.js";
import { areExcludedDatesEqual, areRepeatRulesEqual, getAllDayDateUTCFromZone, getEventEnd, getEventStart, getRepeatEndTimeForDisplay, getStartOfDayWithZone, getStartOfNextDayWithZone, incrementByRepeatPeriod } from "./CalendarUtils-C6jeYrj9.js";
import { UserError } from "./UserError-DfXlMLTl.js";

//#region ../src/common/calendar/date/Time.ts
var Time = class Time {
	hour;
	minute;
	constructor(hour, minute) {
		this.hour = Math.floor(hour) % 24;
		this.minute = Math.floor(minute) % 60;
	}
	/**
	* create a time by extracting hour and minute from a date object.
	* @param date the date to extract the time from
	* NOTE: all calculations are done in local time.
	*/
	static fromDate(date) {
		return new Time(date.getHours(), date.getMinutes());
	}
	static fromDateTime({ hour, minute }) {
		return new Time(hour, minute);
	}
	/**
	* Accepts 2, 2:30, 2:5, 02:05, 02:30, 24:30, 2430, 12:30pm, 12:30 p.m.
	*/
	static parseFromString(timeString) {
		let suffix;
		let hours;
		let minutes;
		let mt = timeString.match(/^(\d{1,2}):(\d{1,2})\s*(am|pm|a\.m\.|p\.m\.)?$/i);
		if (mt != null) {
			suffix = mt[3];
			hours = parseInt(mt[1], 10);
			minutes = parseInt(mt[2], 10);
		} else {
			mt = timeString.match(/^(\d{1,4})\s*(am|pm|a\.m\.|p\.m\.)?$/i);
			if (mt != null) {
				suffix = mt[2];
				const digits = mt[1];
				if (digits.length <= 2) {
					hours = parseInt(digits, 10);
					minutes = 0;
				} else {
					hours = parseInt(digits.substring(0, digits.length - 2), 10);
					minutes = parseInt(digits.slice(-2), 10);
				}
			} else return null;
		}
		if (isNaN(hours) || isNaN(minutes) || minutes > 59) return null;
		if (suffix) suffix = suffix.toUpperCase();
		if (suffix === "PM" || suffix === "P.M.") {
			if (hours > 12) return null;
			if (hours !== 12) hours = hours + 12;
		} else if (suffix === "AM" || suffix === "A.M.") {
			if (hours > 12) return null;
			if (hours === 12) hours = 0;
		} else if (hours > 23) return null;
		return new Time(hours, minutes);
	}
	/**
	* convert into a date
	* if base date is set it will use the date values from that,
	* otherwise it will use the current date.
	*
	* NOTE: calculations are done in the local time.
	*/
	toDate(baseDate) {
		const date = baseDate ? new Date(baseDate) : new Date();
		date.setHours(this.hour);
		date.setMinutes(this.minute);
		date.setSeconds(0);
		date.setMilliseconds(0);
		return date;
	}
	toDateTime(baseDate, zone) {
		return DateTime.fromJSDate(baseDate, { zone }).set(this);
	}
	equals(otherTime) {
		return this.hour === otherTime.hour && this.minute === otherTime.minute;
	}
	toString(amPmFormat) {
		return amPmFormat ? this.to12HourString() : this.to24HourString();
	}
	to12HourString() {
		const minutesString = pad(this.minute, 2);
		if (this.hour === 0) return `12:${minutesString} am`;
else if (this.hour === 12) return `12:${minutesString} pm`;
else if (this.hour > 12) return `${this.hour - 12}:${minutesString} pm`;
else return `${this.hour}:${minutesString} am`;
	}
	to24HourString() {
		const hours = pad(this.hour, 2);
		const minutes = pad(this.minute, 2);
		return `${hours}:${minutes}`;
	}
	toObject() {
		return {
			hours: this.hour,
			minutes: this.minute
		};
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventWhenModel.ts
var CalendarEventWhenModel = class {
	repeatRule = null;
	_isAllDay;
	/** represents the start of day of the start date in local time. */
	_startDate;
	/** represents the start of day of the end date in local time. */
	_endDate;
	/** we're setting time to null on all-day events to be able to have the default time set when someone unsets the all-day flag. */
	_startTime;
	_endTime;
	constructor(initialValues, zone, uiUpdateCallback = noOp) {
		this.initialValues = initialValues;
		this.zone = zone;
		this.uiUpdateCallback = uiUpdateCallback;
		let initialTimes;
		if (initialValues.startTime == null || initialValues.endTime == null) {
			const defaultTimes = getEventWithDefaultTimes(initialValues.startTime);
			initialTimes = {
				startTime: initialValues.startTime ?? defaultTimes.startTime,
				endTime: initialValues.endTime ?? defaultTimes.endTime
			};
		} else initialTimes = {
			startTime: initialValues.startTime,
			endTime: initialValues.endTime
		};
		initialTimes.startTime = DateTime.fromJSDate(initialTimes.startTime, { zone }).set({
			second: 0,
			millisecond: 0
		}).toJSDate();
		initialTimes.endTime = DateTime.fromJSDate(initialTimes.endTime, { zone }).set({
			second: 0,
			millisecond: 0
		}).toJSDate();
		this._isAllDay = isAllDayEvent(initialTimes);
		this.repeatRule = clone(initialValues.repeatRule ?? null);
		const start = getEventStart(initialTimes, this.zone);
		const end = getEventEnd(initialTimes, this.zone);
		if (this._isAllDay) {
			this._startTime = null;
			this._endTime = null;
			this._startDate = getStartOfDayWithZone(DateTime.fromJSDate(start, { zone }).toJSDate(), zone);
			this._endDate = incrementDate(end, -1);
		} else {
			this._startTime = Time.fromDateTime(DateTime.fromJSDate(start, { zone }));
			this._endTime = Time.fromDateTime(DateTime.fromJSDate(end, { zone }));
			this._startDate = getStartOfDayWithZone(DateTime.fromJSDate(start, { zone }).toJSDate(), zone);
			this._endDate = getStartOfDayWithZone(DateTime.fromJSDate(end, { zone }).toJSDate(), zone);
		}
	}
	/**
	* set whether this event should be considered all-day
	*
	* will also modify the excluded dates if there are any to still exclude the
	* same occurrence dates.
	*/
	set isAllDay(value) {
		if (this._isAllDay === value) return;
		if (!value && this._startTime == null || this._endTime == null) {
			const defaultTimes = getEventWithDefaultTimes();
			this._startTime = Time.fromDateTime(DateTime.fromJSDate(defaultTimes.startTime, this));
			this._endTime = Time.fromDateTime(DateTime.fromJSDate(defaultTimes.endTime, this));
		}
		if (this.repeatRule == null) this._isAllDay = value;
else {
			const previousEndDate = this.repeatEndDateForDisplay;
			this._isAllDay = value;
			this.repeatEndDateForDisplay = previousEndDate;
			if (value) this.repeatRule.excludedDates = this.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateUTC(date) }));
else {
				const startTime = this.startTime;
				this.repeatRule.excludedDates = this.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date: startTime.toDate(date) }));
			}
		}
		this.uiUpdateCallback();
	}
	get isAllDay() {
		return this._isAllDay;
	}
	/**
	* the current start time (hour:minutes) of the event in the local time zone.
	* will return 00:00 for all-day events.
	*/
	get startTime() {
		return this._isAllDay ? new Time(0, 0) : this._startTime;
	}
	/**
	* set the time portion of the events start time. the date portion will not be modified.
	* will also adjust the end time accordingly to keep the event length the same.
	*  */
	set startTime(v) {
		if (v == null || this._isAllDay) return;
		const startTime = this._startTime;
		const delta = ((v.hour - startTime.hour) * 60 + (v.minute - startTime.minute)) * 6e4;
		if (delta === 0) return;
		this.rescheduleEvent({ millisecond: delta });
		this.uiUpdateCallback();
	}
	/**
	* the current end time (hour:minutes) of the event in the local time zone.
	* will return 00:00 for all-day events independently of the time zone.
	*/
	get endTime() {
		return this._isAllDay ? new Time(0, 0) : this._endTime;
	}
	/**
	* set the time portion of the events end time. the date portion will not be modified.
	*
	*/
	set endTime(v) {
		if (v == null || this._isAllDay) return;
		const startTime = this._startTime;
		const currentStart = startTime.toDate(this._startDate);
		const newEnd = v.toDate(this._endDate);
		if (newEnd < currentStart) return;
		this._endTime = v;
		this.uiUpdateCallback();
	}
	/** return the duration of the event in minutes */
	get duration() {
		const { startTime, endTime } = this.getTimes();
		const duration = DateTime.fromJSDate(endTime).diff(DateTime.fromJSDate(startTime));
		return { minutes: duration.as("minutes") };
	}
	/** set the duration of the event in minutes, effectively setting the endDate and endTime. */
	set duration(value) {
		if (value.minutes < 1) return;
		const diff = { minutes: this.duration.minutes - value.minutes };
		const oldEndTime = this.endTime.toDateTime(this.endDate, this.zone);
		const newEndTime = oldEndTime.plus(diff);
		this._endDate = getStartOfDayWithZone(newEndTime.toJSDate(), this.zone);
		if (!this._isAllDay) this._endTime = Time.fromDateTime(newEndTime);
	}
	/**
	* get the start time of the day this event currently starts in UTC, in local time
	* for display purposes.
	*
	* will always be a start of day in local time.
	*/
	get startDate() {
		return this._startDate;
	}
	/**
	* set the date portion of the events start time (value's time component is ignored)
	* will also update the end date and move it the same amount of days as the start date was moved.
	*
	* setting a date before 1970 will result in the date being set to CURRENT_YEAR
	* */
	set startDate(value) {
		if (value.getTime() === this._startDate.getTime()) return;
		if (value.getTime() < TIMESTAMP_ZERO_YEAR) {
			const thisYear = new Date().getFullYear();
			value.setFullYear(thisYear);
		}
		const valueDateTime = DateTime.fromJSDate(value, { zone: this.zone });
		const diff = valueDateTime.diff(DateTime.fromJSDate(this._startDate, this), ["day", "millisecond"]);
		if (diff.as("millisecond") === 0) return;
		this.rescheduleEvent({ days: diff.days });
		this.uiUpdateCallback();
	}
	/**
	* for display purposes.
	*
	* will always be a start of day in local time.
	*/
	get endDate() {
		return this._endDate;
	}
	/**
	* set the date portion of the events end time (value's time component is ignored)
	*
	* */
	set endDate(value) {
		if (value.getTime() === this._endDate.getTime()) return;
		const startTime = this._startTime ?? new Time(0, 0);
		const endTime = this._endTime ?? new Time(0, 0);
		const currentStart = startTime.toDate(this._startDate);
		const newEnd = endTime.toDate(value);
		if (newEnd < currentStart) {
			console.log("tried to set the end date to before the start date");
			return;
		}
		this._endDate = DateTime.fromJSDate(value, this).set({
			hour: 0,
			minute: 0,
			second: 0,
			millisecond: 0
		}).toJSDate();
		this.uiUpdateCallback();
	}
	get repeatPeriod() {
		return this.repeatRule ? this.repeatRule.frequency : null;
	}
	set repeatPeriod(repeatPeriod) {
		if (this.repeatRule?.frequency === repeatPeriod) return;
else if (repeatPeriod == null) this.repeatRule = null;
else if (this.repeatRule != null) this.repeatRule.frequency = repeatPeriod;
else {
			this.repeatRule = this.initialValues.repeatRule ? clone(this.initialValues.repeatRule) : createRepeatRule({
				interval: "1",
				endType: EndType.Never,
				endValue: "1",
				frequency: RepeatPeriod.DAILY,
				excludedDates: [],
				timeZone: "",
				advancedRules: []
			});
			this.repeatRule.frequency = repeatPeriod;
		}
		this.uiUpdateCallback();
	}
	/**
	* get the current interval this series repeats in.
	*
	* if the event is not set to
	*/
	get repeatInterval() {
		if (!this.repeatRule?.interval) return 1;
		return filterInt(this.repeatRule?.interval);
	}
	/**
	* set the event to occur on every nth of its repeat period (ie every second, third, fourth day/month/year...).
	* setting it to something less than 1 will set the interval to 1
	* @param interval
	*/
	set repeatInterval(interval) {
		if (interval < 1) interval = 1;
		const stringInterval = String(interval);
		if (this.repeatRule && this.repeatRule?.interval !== stringInterval) this.repeatRule.interval = stringInterval;
		this.uiUpdateCallback();
	}
	/**
	* get the current way for the event series to end.
	*/
	get repeatEndType() {
		return this.repeatRule?.endType ?? EndType.Never;
	}
	/**
	* set the way the event series will stop repeating. if this causes a change in the event,
	* the endValue will be set to the default for the selected EndType.
	*
	* @param endType
	*/
	set repeatEndType(endType) {
		if (!this.repeatRule) return;
		if (this.repeatRule.endType === endType) return;
		this.repeatRule.endType = endType;
		switch (endType) {
			case EndType.UntilDate:
				this.repeatRule.endValue = getDefaultEndDateEndValue({
					startTime: this._startDate,
					endTime: this._endDate
				}, this.zone);
				return;
			case EndType.Count:
			case EndType.Never: this.repeatRule.endValue = getDefaultEndCountValue();
		}
		this.uiUpdateCallback();
	}
	/**
	* get the current maximum number of repeats. if the event is not set to repeat or
	* end after number of occurrences, returns the default max repeat number.
	*/
	get repeatEndOccurrences() {
		if (this.repeatRule?.endType === EndType.Count && this.repeatRule?.endValue) return filterInt(this.repeatRule?.endValue);
else return filterInt(getDefaultEndCountValue());
	}
	/**
	* set the max number of repeats for the event series. if the event is not set to repeat or
	* not set to repeat a maximum number of times, this is a no-op.
	* @param endValue
	*/
	set repeatEndOccurrences(endValue) {
		const stringEndValue = String(endValue);
		if (this.repeatRule && this.repeatRule.endType === EndType.Count && this.repeatRule.endValue !== stringEndValue) this.repeatRule.endValue = stringEndValue;
		this.uiUpdateCallback();
	}
	/**
	* get the date after which the event series will stop repeating.
	*
	* returns the default value of a month after the start date if the event is not
	* set to stop repeating after a certain date.
	*/
	get repeatEndDateForDisplay() {
		if (this.repeatRule?.endType === EndType.UntilDate) return getRepeatEndTimeForDisplay(this.repeatRule, this.isAllDay, this.zone);
else return new Date(filterInt(getDefaultEndDateEndValue({
			startTime: this._startDate,
			endTime: this._endDate
		}, this.zone)));
	}
	/**
	* set the date after which the event series ends. if the event does not repeat or the series is
	* not set to end after a date, this is a no-op.
	*
	* @param newRepeatEndDate the new end date, as displayed in local time zone.
	*/
	set repeatEndDateForDisplay(newRepeatEndDate) {
		if (this.repeatRule == null || this.repeatRule.endType !== EndType.UntilDate) return;
		const repeatEndDate = incrementByRepeatPeriod(newRepeatEndDate, RepeatPeriod.DAILY, 1, this.zone);
		const times = this.getTimes();
		if (repeatEndDate < getEventStart(times, this.zone)) throw new UserError("startAfterEnd_label");
		const numberEndDate = (this.isAllDay ? getAllDayDateUTCFromZone(repeatEndDate, this.zone) : repeatEndDate).getTime();
		this.repeatRule.endValue = String(numberEndDate);
		this.uiUpdateCallback();
	}
	get excludedDates() {
		return this.repeatRule?.excludedDates.map(({ date }) => date) ?? [];
	}
	/**
	* calling this adds an exclusion for the event instance starting at dateToExclude to the repeat rule of the event,
	* which will cause the instance to not be rendered or fire alarms.
	* Exclusions are the start date/time of the event (as a utc timestamp)
	*
	* the list of exclusions is maintained sorted from earliest to latest.
	*/
	excludeDate(date) {
		if (this.repeatRule == null) {
			console.log("tried to add an exclusion for an event without a repeat rule. should probably delete the event.");
			return;
		}
		const timeToInsert = date.getTime();
		let insertionIndex = -1;
		for (const [index, { date: date$1 }] of this.repeatRule.excludedDates.entries()) if (date$1.getTime() === timeToInsert) return;
else if (date$1.getTime() > timeToInsert) {
			insertionIndex = index;
			break;
		}
		const wrapperToInsert = createDateWrapper({ date });
		if (insertionIndex < 0) this.repeatRule.excludedDates.push(wrapperToInsert);
else this.repeatRule.excludedDates.splice(insertionIndex, 0, wrapperToInsert);
	}
	/**
	* completely delete all exclusions. will cause the event to be rendered and fire alarms on all
	* occurrences as dictated by its repeat rule.
	*/
	deleteExcludedDates() {
		if (!this.repeatRule) return;
		this.repeatRule.excludedDates.length = 0;
	}
	/**
	* change start and end time and dates of the event by a fixed amount.
	* @param diff an object containing a duration in luxons year/quarter/... format
	*/
	rescheduleEvent(diff) {
		const oldStartTime = this.startTime.toDateTime(this.startDate, this.zone);
		const oldEndTime = this.endTime.toDateTime(this.endDate, this.zone);
		const newStartDate = oldStartTime.plus(diff);
		const newEndDate = oldEndTime.plus(diff);
		this._startDate = getStartOfDayWithZone(newStartDate.toJSDate(), this.zone);
		this._endDate = getStartOfDayWithZone(newEndDate.toJSDate(), this.zone);
		if (!this._isAllDay) {
			this._startTime = Time.fromDateTime(newStartDate);
			this._endTime = Time.fromDateTime(newEndDate);
		}
	}
	get result() {
		const repeatRule = this.repeatRule ? {
			...createRepeatRule({
				timeZone: "",
				excludedDates: [],
				endType: "0",
				endValue: null,
				interval: "0",
				frequency: "0",
				advancedRules: []
			}),
			...this.repeatRule,
			timeZone: this.zone
		} : null;
		this.deleteExcludedDatesIfNecessary(repeatRule);
		const { startTime, endTime } = this.getTimes();
		return {
			startTime,
			endTime,
			repeatRule
		};
	}
	/**
	* get the JS dates where the event starts and ends as they would be saved on the server (display may vary)
	* @param startDate base date to use for the start date
	* @param endDate base date to use for the end date.
	* @private
	*/
	getTimes({ startDate, endDate } = {
		startDate: this._startDate,
		endDate: this._endDate
	}) {
		if (this._isAllDay) {
			const startTime = getAllDayDateUTCFromZone(startDate, this.zone);
			const endTime = getAllDayDateUTCFromZone(getStartOfNextDayWithZone(endDate, this.zone), this.zone);
			return {
				startTime,
				endTime
			};
		} else {
			const startTime = this._startTime.toDateTime(getStartOfDayWithZone(startDate, this.zone), this.zone).toJSDate();
			const endTime = this._endTime.toDateTime(getStartOfDayWithZone(endDate, this.zone), this.zone).toJSDate();
			return {
				startTime,
				endTime
			};
		}
	}
	/**
	* ideally, we want to delete exclusions after an edit operation only when necessary.
	* @private
	*/
	deleteExcludedDatesIfNecessary(newRepeat) {
		if (newRepeat == null) return;
		const oldRepeat = this.initialValues.repeatRule ?? null;
		if (!areRepeatRulesEqual(newRepeat, oldRepeat) && areExcludedDatesEqual(newRepeat?.excludedDates ?? [], oldRepeat?.excludedDates ?? [])) {
			newRepeat.excludedDates = [];
			return;
		}
		if (this.initialValues.startTime == null) return;
		const { startTime } = this.getTimes();
		if (startTime.getTime() !== this.initialValues.startTime.getTime()) {
			newRepeat.excludedDates = [];
			return;
		}
	}
};
function getDefaultEndDateEndValue({ startTime }, timeZone) {
	return String(incrementByRepeatPeriod(startTime, RepeatPeriod.MONTHLY, 1, timeZone).getTime());
}
function getDefaultEndCountValue() {
	return "10";
}
function repeatRuleWithExcludedAlteredInstances(progenitor, recurrenceIds, timeZone) {
	const whenModel = new CalendarEventWhenModel(progenitor, timeZone);
	for (const recurrenceId of recurrenceIds) whenModel.excludeDate(recurrenceId);
	return assertNotNull(whenModel.result.repeatRule, "tried to exclude altered instance on progenitor without repeat rule!");
}

//#endregion
export { CalendarEventWhenModel, Time, getDefaultEndCountValue, getDefaultEndDateEndValue, repeatRuleWithExcludedAlteredInstances };
//# sourceMappingURL=CalendarEventWhenModel-DEedSoEH.js.map