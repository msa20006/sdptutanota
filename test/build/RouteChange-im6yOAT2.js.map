{"version":3,"file":"RouteChange-im6yOAT2.js","names":["lastUrl: string | null","lastArgs: Record<string, any>","url: string","args: Record<string, any>","a: Record<string, unknown>","b: Record<string, unknown>","LogoutUrl: string"],"sources":["../../src/common/misc/RouteChange.ts"],"sourcesContent":["import m from \"mithril\"\nimport { assertMainOrNodeBoot } from \"../api/common/Env\"\nimport { lazyMemoized } from \"@tutao/tutanota-utils\"\n\nassertMainOrNodeBoot()\n\nexport type RouteSetFn = (path: string, args: Record<string, any>) => void\n\n/** return a replacement for m.route.set that replaces the last history\n * state for reroutes that happen quickly enough instead of adding a\n * new history entry. will also latch to the route, ignoring any\n * followup calls to the same route.  */\nexport const throttleRoute = lazyMemoized((): RouteSetFn => {\n\tconst limit = 200\n\tlet lastCall = 0\n\tlet lastUrl: string | null = null\n\tlet lastArgs: Record<string, any> = {}\n\tlet lastRoute = m.route.get()\n\treturn function (url: string, args: Record<string, any>) {\n\t\t// someone might have called m.route.set() without us, so if the route changed, we need to\n\t\t// call m.route.set() in any case.\n\t\tif (m.route.get() === lastRoute && url === lastUrl && shallowCompare(lastArgs, args)) return\n\t\tlastUrl = url\n\t\tlastArgs = args\n\t\tconst now = new Date().getTime()\n\t\ttry {\n\t\t\tm.route.set(url, args, {\n\t\t\t\treplace: now - lastCall < limit,\n\t\t\t})\n\t\t\tlastRoute = m.route.get()\n\t\t} catch (e) {\n\t\t\tif (e.message.includes(\"can't access dead object\")) {\n\t\t\t\tconsole.log(`Caught error: ${e.message}`)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tlastCall = now\n\t}\n})\n\n/** return true if a and b contain the same keys with values that are the same when compared with === */\nfunction shallowCompare(a: Record<string, unknown>, b: Record<string, unknown>): boolean {\n\tif (a === b) return true\n\tconst aEntries = Object.entries(a)\n\tconst bEntries = Object.entries(b)\n\treturn aEntries.length === bEntries.length && !aEntries.some(([key, value]) => b[key] !== value)\n}\n\nexport const MAIL_PREFIX = \"/mail\"\nexport const CONTACTS_PREFIX = \"/contact\"\nexport const CONTACTLIST_PREFIX = \"/contactlist\"\nexport const CALENDAR_PREFIX = \"/calendar\"\nexport const SEARCH_PREFIX = \"/search\"\nexport const SETTINGS_PREFIX = \"/settings\"\nconst LogoutPath = \"/login?noAutoLogin=true\"\nexport const LogoutUrl: string = window.location.hash.startsWith(\"#mail\") ? \"/ext?noAutoLogin=true\" + location.hash : LogoutPath\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,sBAAsB;MAQT,gBAAgB,aAAa,MAAkB;CAC3D,MAAM,QAAQ;CACd,IAAI,WAAW;CACf,IAAIA,UAAyB;CAC7B,IAAIC,WAAgC,CAAE;CACtC,IAAI,YAAY,gBAAE,MAAM,KAAK;AAC7B,QAAO,SAAUC,KAAaC,MAA2B;AAGxD,MAAI,gBAAE,MAAM,KAAK,KAAK,aAAa,QAAQ,WAAW,eAAe,UAAU,KAAK,CAAE;AACtF,YAAU;AACV,aAAW;EACX,MAAM,MAAM,IAAI,OAAO,SAAS;AAChC,MAAI;AACH,mBAAE,MAAM,IAAI,KAAK,MAAM,EACtB,SAAS,MAAM,WAAW,MAC1B,EAAC;AACF,eAAY,gBAAE,MAAM,KAAK;EACzB,SAAQ,GAAG;AACX,OAAI,EAAE,QAAQ,SAAS,2BAA2B,CACjD,SAAQ,KAAK,gBAAgB,EAAE,QAAQ,EAAE;IAEzC,OAAM;EAEP;AAED,aAAW;CACX;AACD,EAAC;;AAGF,SAAS,eAAeC,GAA4BC,GAAqC;AACxF,KAAI,MAAM,EAAG,QAAO;CACpB,MAAM,WAAW,OAAO,QAAQ,EAAE;CAClC,MAAM,WAAW,OAAO,QAAQ,EAAE;AAClC,QAAO,SAAS,WAAW,SAAS,WAAW,SAAS,KAAK,CAAC,CAAC,KAAK,MAAM,KAAK,EAAE,SAAS,MAAM;AAChG;MAEY,cAAc;MACd,kBAAkB;MAClB,qBAAqB;MACrB,kBAAkB;MAClB,gBAAgB;MAChB,kBAAkB;AAC/B,MAAM,aAAa;MACNC,YAAoB,OAAO,SAAS,KAAK,WAAW,QAAQ,GAAG,0BAA0B,SAAS,OAAO"}