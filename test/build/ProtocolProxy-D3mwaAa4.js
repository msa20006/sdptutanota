
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __require } from "./chunk-D_5_n1c4.js";
import { lazyMemoized } from "./dist-CJHwsXKY.js";
import { errorToObj } from "./MessageDispatcher-wJwFhXWv.js";
import { log } from "./DesktopLog-yAgEoQsh.js";
import { getMimeTypeForFile } from "./DesktopFileFacade-o-Coc2Lq.js";
import path from "node:path";
import fs from "node:fs";
import url from "node:url";
import require$$0$3 from "node:util";
import require$$0$2 from "node:buffer";
import stream from "node:stream";
import require$$0 from "node:assert";
import require$$4 from "node:net";
import require$$2 from "node:http";
import require$$7 from "node:querystring";
import require$$8 from "node:events";
import require$$0$4 from "node:diagnostics_channel";
import require$$4$1 from "node:tls";
import require$$1 from "node:zlib";
import require$$5 from "node:perf_hooks";
import require$$8$1 from "node:util/types";
import require$$5$1 from "node:async_hooks";
import require$$1$2 from "node:console";
import require$$5$2 from "string_decoder";
import require$$3 from "node:worker_threads";

//#region ../libs/undici.mjs
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var undici = {};
var symbols$4 = {
	kClose: Symbol("close"),
	kDestroy: Symbol("destroy"),
	kDispatch: Symbol("dispatch"),
	kUrl: Symbol("url"),
	kWriting: Symbol("writing"),
	kResuming: Symbol("resuming"),
	kQueue: Symbol("queue"),
	kConnect: Symbol("connect"),
	kConnecting: Symbol("connecting"),
	kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
	kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
	kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
	kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
	kKeepAlive: Symbol("keep alive"),
	kHeadersTimeout: Symbol("headers timeout"),
	kBodyTimeout: Symbol("body timeout"),
	kServerName: Symbol("server name"),
	kLocalAddress: Symbol("local address"),
	kHost: Symbol("host"),
	kNoRef: Symbol("no ref"),
	kBodyUsed: Symbol("used"),
	kBody: Symbol("abstracted request body"),
	kRunning: Symbol("running"),
	kBlocking: Symbol("blocking"),
	kPending: Symbol("pending"),
	kSize: Symbol("size"),
	kBusy: Symbol("busy"),
	kQueued: Symbol("queued"),
	kFree: Symbol("free"),
	kConnected: Symbol("connected"),
	kClosed: Symbol("closed"),
	kNeedDrain: Symbol("need drain"),
	kReset: Symbol("reset"),
	kDestroyed: Symbol.for("nodejs.stream.destroyed"),
	kResume: Symbol("resume"),
	kOnError: Symbol("on error"),
	kMaxHeadersSize: Symbol("max headers size"),
	kRunningIdx: Symbol("running index"),
	kPendingIdx: Symbol("pending index"),
	kError: Symbol("error"),
	kClients: Symbol("clients"),
	kClient: Symbol("client"),
	kParser: Symbol("parser"),
	kOnDestroyed: Symbol("destroy callbacks"),
	kPipelining: Symbol("pipelining"),
	kSocket: Symbol("socket"),
	kHostHeader: Symbol("host header"),
	kConnector: Symbol("connector"),
	kStrictContentLength: Symbol("strict content length"),
	kMaxRedirections: Symbol("maxRedirections"),
	kMaxRequests: Symbol("maxRequestsPerClient"),
	kProxy: Symbol("proxy agent options"),
	kCounter: Symbol("socket request counter"),
	kInterceptors: Symbol("dispatch interceptors"),
	kMaxResponseSize: Symbol("max response size"),
	kHTTP2Session: Symbol("http2Session"),
	kHTTP2SessionState: Symbol("http2Session state"),
	kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
	kConstruct: Symbol("constructable"),
	kListeners: Symbol("listeners"),
	kHTTPContext: Symbol("http context"),
	kMaxConcurrentStreams: Symbol("max concurrent streams"),
	kNoProxyAgent: Symbol("no proxy agent"),
	kHttpProxyAgent: Symbol("http proxy agent"),
	kHttpsProxyAgent: Symbol("https proxy agent")
};
let UndiciError$2 = class UndiciError$3 extends Error {
	constructor(message) {
		super(message);
		this.name = "UndiciError";
		this.code = "UND_ERR";
	}
};
let ConnectTimeoutError$1 = class ConnectTimeoutError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "ConnectTimeoutError";
		this.message = message || "Connect Timeout Error";
		this.code = "UND_ERR_CONNECT_TIMEOUT";
	}
};
let HeadersTimeoutError$1 = class HeadersTimeoutError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "HeadersTimeoutError";
		this.message = message || "Headers Timeout Error";
		this.code = "UND_ERR_HEADERS_TIMEOUT";
	}
};
let HeadersOverflowError$1 = class HeadersOverflowError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "HeadersOverflowError";
		this.message = message || "Headers Overflow Error";
		this.code = "UND_ERR_HEADERS_OVERFLOW";
	}
};
let BodyTimeoutError$1 = class BodyTimeoutError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "BodyTimeoutError";
		this.message = message || "Body Timeout Error";
		this.code = "UND_ERR_BODY_TIMEOUT";
	}
};
let ResponseStatusCodeError$1 = class ResponseStatusCodeError$2 extends UndiciError$2 {
	constructor(message, statusCode, headers$1, body$1) {
		super(message);
		this.name = "ResponseStatusCodeError";
		this.message = message || "Response Status Code Error";
		this.code = "UND_ERR_RESPONSE_STATUS_CODE";
		this.body = body$1;
		this.status = statusCode;
		this.statusCode = statusCode;
		this.headers = headers$1;
	}
};
let InvalidArgumentError$n = class InvalidArgumentError$10 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "InvalidArgumentError";
		this.message = message || "Invalid Argument Error";
		this.code = "UND_ERR_INVALID_ARG";
	}
};
let InvalidReturnValueError$2 = class InvalidReturnValueError$3 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "InvalidReturnValueError";
		this.message = message || "Invalid Return Value Error";
		this.code = "UND_ERR_INVALID_RETURN_VALUE";
	}
};
let AbortError$1 = class AbortError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "AbortError";
		this.message = message || "The operation was aborted";
	}
};
let RequestAbortedError$8 = class RequestAbortedError$9 extends AbortError$1 {
	constructor(message) {
		super(message);
		this.name = "AbortError";
		this.message = message || "Request aborted";
		this.code = "UND_ERR_ABORTED";
	}
};
let InformationalError$3 = class InformationalError$4 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "InformationalError";
		this.message = message || "Request information";
		this.code = "UND_ERR_INFO";
	}
};
let RequestContentLengthMismatchError$2 = class RequestContentLengthMismatchError$3 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "RequestContentLengthMismatchError";
		this.message = message || "Request body length does not match content-length header";
		this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
	}
};
let ResponseContentLengthMismatchError$1 = class ResponseContentLengthMismatchError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "ResponseContentLengthMismatchError";
		this.message = message || "Response body length does not match content-length header";
		this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
	}
};
let ClientDestroyedError$2 = class ClientDestroyedError$3 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "ClientDestroyedError";
		this.message = message || "The client is destroyed";
		this.code = "UND_ERR_DESTROYED";
	}
};
let ClientClosedError$1 = class ClientClosedError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "ClientClosedError";
		this.message = message || "The client is closed";
		this.code = "UND_ERR_CLOSED";
	}
};
let SocketError$4 = class SocketError$5 extends UndiciError$2 {
	constructor(message, socket) {
		super(message);
		this.name = "SocketError";
		this.message = message || "Socket error";
		this.code = "UND_ERR_SOCKET";
		this.socket = socket;
	}
};
let NotSupportedError$2 = class NotSupportedError$3 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "NotSupportedError";
		this.message = message || "Not supported error";
		this.code = "UND_ERR_NOT_SUPPORTED";
	}
};
let BalancedPoolMissingUpstreamError$1 = class BalancedPoolMissingUpstreamError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "MissingUpstreamError";
		this.message = message || "No upstream has been added to the BalancedPool";
		this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
	}
};
let HTTPParserError$1 = class HTTPParserError$2 extends Error {
	constructor(message, code, data) {
		super(message);
		this.name = "HTTPParserError";
		this.code = code ? `HPE_${code}` : undefined;
		this.data = data ? data.toString() : undefined;
	}
};
let ResponseExceededMaxSizeError$1 = class ResponseExceededMaxSizeError$2 extends UndiciError$2 {
	constructor(message) {
		super(message);
		this.name = "ResponseExceededMaxSizeError";
		this.message = message || "Response content exceeded max size";
		this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
	}
};
let RequestRetryError$1 = class RequestRetryError$2 extends UndiciError$2 {
	constructor(message, code, { headers: headers$1, data }) {
		super(message);
		this.name = "RequestRetryError";
		this.message = message || "Request retry error";
		this.code = "UND_ERR_REQ_RETRY";
		this.statusCode = code;
		this.data = data;
		this.headers = headers$1;
	}
};
let SecureProxyConnectionError$1 = class SecureProxyConnectionError$2 extends UndiciError$2 {
	constructor(cause, message, options) {
		super(message, {
			cause,
			...options ?? {}
		});
		this.name = "SecureProxyConnectionError";
		this.message = message || "Secure Proxy Connection failed";
		this.code = "UND_ERR_PRX_TLS";
		this.cause = cause;
	}
};
var errors$1 = {
	AbortError: AbortError$1,
	HTTPParserError: HTTPParserError$1,
	UndiciError: UndiciError$2,
	HeadersTimeoutError: HeadersTimeoutError$1,
	HeadersOverflowError: HeadersOverflowError$1,
	BodyTimeoutError: BodyTimeoutError$1,
	RequestContentLengthMismatchError: RequestContentLengthMismatchError$2,
	ConnectTimeoutError: ConnectTimeoutError$1,
	ResponseStatusCodeError: ResponseStatusCodeError$1,
	InvalidArgumentError: InvalidArgumentError$n,
	InvalidReturnValueError: InvalidReturnValueError$2,
	RequestAbortedError: RequestAbortedError$8,
	ClientDestroyedError: ClientDestroyedError$2,
	ClientClosedError: ClientClosedError$1,
	InformationalError: InformationalError$3,
	SocketError: SocketError$4,
	NotSupportedError: NotSupportedError$2,
	ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,
	BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$1,
	ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1,
	RequestRetryError: RequestRetryError$1,
	SecureProxyConnectionError: SecureProxyConnectionError$1
};
/** @type {Record<string, string | undefined>} */
const headerNameLowerCasedRecord$3 = {};
const wellknownHeaderNames$1 = [
	"Accept",
	"Accept-Encoding",
	"Accept-Language",
	"Accept-Ranges",
	"Access-Control-Allow-Credentials",
	"Access-Control-Allow-Headers",
	"Access-Control-Allow-Methods",
	"Access-Control-Allow-Origin",
	"Access-Control-Expose-Headers",
	"Access-Control-Max-Age",
	"Access-Control-Request-Headers",
	"Access-Control-Request-Method",
	"Age",
	"Allow",
	"Alt-Svc",
	"Alt-Used",
	"Authorization",
	"Cache-Control",
	"Clear-Site-Data",
	"Connection",
	"Content-Disposition",
	"Content-Encoding",
	"Content-Language",
	"Content-Length",
	"Content-Location",
	"Content-Range",
	"Content-Security-Policy",
	"Content-Security-Policy-Report-Only",
	"Content-Type",
	"Cookie",
	"Cross-Origin-Embedder-Policy",
	"Cross-Origin-Opener-Policy",
	"Cross-Origin-Resource-Policy",
	"Date",
	"Device-Memory",
	"Downlink",
	"ECT",
	"ETag",
	"Expect",
	"Expect-CT",
	"Expires",
	"Forwarded",
	"From",
	"Host",
	"If-Match",
	"If-Modified-Since",
	"If-None-Match",
	"If-Range",
	"If-Unmodified-Since",
	"Keep-Alive",
	"Last-Modified",
	"Link",
	"Location",
	"Max-Forwards",
	"Origin",
	"Permissions-Policy",
	"Pragma",
	"Proxy-Authenticate",
	"Proxy-Authorization",
	"RTT",
	"Range",
	"Referer",
	"Referrer-Policy",
	"Refresh",
	"Retry-After",
	"Sec-WebSocket-Accept",
	"Sec-WebSocket-Extensions",
	"Sec-WebSocket-Key",
	"Sec-WebSocket-Protocol",
	"Sec-WebSocket-Version",
	"Server",
	"Server-Timing",
	"Service-Worker-Allowed",
	"Service-Worker-Navigation-Preload",
	"Set-Cookie",
	"SourceMap",
	"Strict-Transport-Security",
	"Supports-Loading-Mode",
	"TE",
	"Timing-Allow-Origin",
	"Trailer",
	"Transfer-Encoding",
	"Upgrade",
	"Upgrade-Insecure-Requests",
	"User-Agent",
	"Vary",
	"Via",
	"WWW-Authenticate",
	"X-Content-Type-Options",
	"X-DNS-Prefetch-Control",
	"X-Frame-Options",
	"X-Permitted-Cross-Domain-Policies",
	"X-Powered-By",
	"X-Requested-With",
	"X-XSS-Protection"
];
for (let i = 0; i < wellknownHeaderNames$1.length; ++i) {
	const key = wellknownHeaderNames$1[i];
	const lowerCasedKey = key.toLowerCase();
	headerNameLowerCasedRecord$3[key] = headerNameLowerCasedRecord$3[lowerCasedKey] = lowerCasedKey;
}
Object.setPrototypeOf(headerNameLowerCasedRecord$3, null);
var constants$5 = {
	wellknownHeaderNames: wellknownHeaderNames$1,
	headerNameLowerCasedRecord: headerNameLowerCasedRecord$3
};
const { wellknownHeaderNames, headerNameLowerCasedRecord: headerNameLowerCasedRecord$2 } = constants$5;
var TstNode = class TstNode {
	/** @type {any} */
	value = null;
	/** @type {null | TstNode} */
	left = null;
	/** @type {null | TstNode} */
	middle = null;
	/** @type {null | TstNode} */
	right = null;
	/** @type {number} */
	code;
	/**
	* @param {string} key
	* @param {any} value
	* @param {number} index
	*/
	constructor(key, value, index) {
		if (index === undefined || index >= key.length) throw new TypeError("Unreachable");
		const code = this.code = key.charCodeAt(index);
		if (code > 127) throw new TypeError("key must be ascii string");
		if (key.length !== ++index) this.middle = new TstNode(key, value, index);
else this.value = value;
	}
	/**
	* @param {string} key
	* @param {any} value
	*/
	add(key, value) {
		const length = key.length;
		if (length === 0) throw new TypeError("Unreachable");
		let index = 0;
		let node = this;
		while (true) {
			const code = key.charCodeAt(index);
			if (code > 127) throw new TypeError("key must be ascii string");
			if (node.code === code) if (length === ++index) {
				node.value = value;
				break;
			} else if (node.middle !== null) node = node.middle;
else {
				node.middle = new TstNode(key, value, index);
				break;
			}
else if (node.code < code) if (node.left !== null) node = node.left;
else {
				node.left = new TstNode(key, value, index);
				break;
			}
else if (node.right !== null) node = node.right;
else {
				node.right = new TstNode(key, value, index);
				break;
			}
		}
	}
	/**
	* @param {Uint8Array} key
	* @return {TstNode | null}
	*/
	search(key) {
		const keylength = key.length;
		let index = 0;
		let node = this;
		while (node !== null && index < keylength) {
			let code = key[index];
			if (code <= 90 && code >= 65) code |= 32;
			while (node !== null) {
				if (code === node.code) {
					if (keylength === ++index) return node;
					node = node.middle;
					break;
				}
				node = node.code < code ? node.left : node.right;
			}
		}
		return null;
	}
};
var TernarySearchTree = class {
	/** @type {TstNode | null} */
	node = null;
	/**
	* @param {string} key
	* @param {any} value
	* */
	insert(key, value) {
		if (this.node === null) this.node = new TstNode(key, value, 0);
else this.node.add(key, value);
	}
	/**
	* @param {Uint8Array} key
	* @return {any}
	*/
	lookup(key) {
		return this.node?.search(key)?.value ?? null;
	}
};
const tree$1 = new TernarySearchTree();
for (let i = 0; i < wellknownHeaderNames.length; ++i) {
	const key = headerNameLowerCasedRecord$2[wellknownHeaderNames[i]];
	tree$1.insert(key, key);
}
var tree_1 = {
	TernarySearchTree,
	tree: tree$1
};
const assert$e = require$$0;
const { kDestroyed: kDestroyed$2, kBodyUsed: kBodyUsed$1, kListeners, kBody: kBody$2 } = symbols$4;
const { IncomingMessage } = require$$2;
const stream$2 = stream;
const net$2 = require$$4;
const { Blob: Blob$1 } = require$$0$2;
const nodeUtil = require$$0$3;
const { stringify } = require$$7;
const { EventEmitter: EE$1 } = require$$8;
const { InvalidArgumentError: InvalidArgumentError$m } = errors$1;
const { headerNameLowerCasedRecord: headerNameLowerCasedRecord$1 } = constants$5;
const { tree } = tree_1;
const [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
let BodyAsyncIterable$1 = class BodyAsyncIterable$2 {
	constructor(body$1) {
		this[kBody$2] = body$1;
		this[kBodyUsed$1] = false;
	}
	async *[Symbol.asyncIterator]() {
		assert$e(!this[kBodyUsed$1], "disturbed");
		this[kBodyUsed$1] = true;
		yield* this[kBody$2];
	}
};
function wrapRequestBody$1(body$1) {
	if (isStream$1(body$1)) {
		if (bodyLength(body$1) === 0) body$1.on("data", function() {
			assert$e(false);
		});
		if (typeof body$1.readableDidRead !== "boolean") {
			body$1[kBodyUsed$1] = false;
			EE$1.prototype.on.call(body$1, "data", function() {
				this[kBodyUsed$1] = true;
			});
		}
		return body$1;
	} else if (body$1 && typeof body$1.pipeTo === "function") return new BodyAsyncIterable$1(body$1);
else if (body$1 && typeof body$1 !== "string" && !ArrayBuffer.isView(body$1) && isIterable$1(body$1)) return new BodyAsyncIterable$1(body$1);
else return body$1;
}
function nop() {}
function isStream$1(obj) {
	return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
}
function isBlobLike$1(object) {
	if (object === null) return false;
else if (object instanceof Blob$1) return true;
else if (typeof object !== "object") return false;
else {
		const sTag = object[Symbol.toStringTag];
		return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
	}
}
function buildURL$3(url$1, queryParams) {
	if (url$1.includes("?") || url$1.includes("#")) throw new Error("Query params cannot be passed when url already contains \"?\" or \"#\".");
	const stringified = stringify(queryParams);
	if (stringified) url$1 += "?" + stringified;
	return url$1;
}
function isValidPort(port) {
	const value = parseInt(port, 10);
	return value === Number(port) && value >= 0 && value <= 65535;
}
function isHttpOrHttpsPrefixed(value) {
	return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
}
function parseURL(url$1) {
	if (typeof url$1 === "string") {
		url$1 = new URL(url$1);
		if (!isHttpOrHttpsPrefixed(url$1.origin || url$1.protocol)) throw new InvalidArgumentError$m("Invalid URL protocol: the URL must start with `http:` or `https:`.");
		return url$1;
	}
	if (!url$1 || typeof url$1 !== "object") throw new InvalidArgumentError$m("Invalid URL: The URL argument must be a non-null object.");
	if (!(url$1 instanceof URL)) {
		if (url$1.port != null && url$1.port !== "" && isValidPort(url$1.port) === false) throw new InvalidArgumentError$m("Invalid URL: port must be a valid integer or a string representation of an integer.");
		if (url$1.path != null && typeof url$1.path !== "string") throw new InvalidArgumentError$m("Invalid URL path: the path must be a string or null/undefined.");
		if (url$1.pathname != null && typeof url$1.pathname !== "string") throw new InvalidArgumentError$m("Invalid URL pathname: the pathname must be a string or null/undefined.");
		if (url$1.hostname != null && typeof url$1.hostname !== "string") throw new InvalidArgumentError$m("Invalid URL hostname: the hostname must be a string or null/undefined.");
		if (url$1.origin != null && typeof url$1.origin !== "string") throw new InvalidArgumentError$m("Invalid URL origin: the origin must be a string or null/undefined.");
		if (!isHttpOrHttpsPrefixed(url$1.origin || url$1.protocol)) throw new InvalidArgumentError$m("Invalid URL protocol: the URL must start with `http:` or `https:`.");
		const port = url$1.port != null ? url$1.port : url$1.protocol === "https:" ? 443 : 80;
		let origin = url$1.origin != null ? url$1.origin : `${url$1.protocol || ""}//${url$1.hostname || ""}:${port}`;
		let path$1 = url$1.path != null ? url$1.path : `${url$1.pathname || ""}${url$1.search || ""}`;
		if (origin[origin.length - 1] === "/") origin = origin.slice(0, origin.length - 1);
		if (path$1 && path$1[0] !== "/") path$1 = `/${path$1}`;
		return new URL(`${origin}${path$1}`);
	}
	if (!isHttpOrHttpsPrefixed(url$1.origin || url$1.protocol)) throw new InvalidArgumentError$m("Invalid URL protocol: the URL must start with `http:` or `https:`.");
	return url$1;
}
function parseOrigin$1(url$1) {
	url$1 = parseURL(url$1);
	if (url$1.pathname !== "/" || url$1.search || url$1.hash) throw new InvalidArgumentError$m("invalid url");
	return url$1;
}
function getHostname(host) {
	if (host[0] === "[") {
		const idx$1 = host.indexOf("]");
		assert$e(idx$1 !== -1);
		return host.substring(1, idx$1);
	}
	const idx = host.indexOf(":");
	if (idx === -1) return host;
	return host.substring(0, idx);
}
function getServerName$1(host) {
	if (!host) return null;
	assert$e.strictEqual(typeof host, "string");
	const servername = getHostname(host);
	if (net$2.isIP(servername)) return "";
	return servername;
}
function deepClone(obj) {
	return JSON.parse(JSON.stringify(obj));
}
function isAsyncIterable(obj) {
	return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
}
function isIterable$1(obj) {
	return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
}
function bodyLength(body$1) {
	if (body$1 == null) return 0;
else if (isStream$1(body$1)) {
		const state = body$1._readableState;
		return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
	} else if (isBlobLike$1(body$1)) return body$1.size != null ? body$1.size : null;
else if (isBuffer$1(body$1)) return body$1.byteLength;
	return null;
}
function isDestroyed(body$1) {
	return body$1 && !!(body$1.destroyed || body$1[kDestroyed$2] || stream$2.isDestroyed?.(body$1));
}
function destroy$1(stream$4, err) {
	if (stream$4 == null || !isStream$1(stream$4) || isDestroyed(stream$4)) return;
	if (typeof stream$4.destroy === "function") {
		if (Object.getPrototypeOf(stream$4).constructor === IncomingMessage) stream$4.socket = null;
		stream$4.destroy(err);
	} else if (err) queueMicrotask(() => {
		stream$4.emit("error", err);
	});
	if (stream$4.destroyed !== true) stream$4[kDestroyed$2] = true;
}
const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
function parseKeepAliveTimeout(val) {
	const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
	return m ? parseInt(m[1], 10) * 1e3 : null;
}
/**
* Retrieves a header name and returns its lowercase value.
* @param {string | Buffer} value Header name
* @returns {string}
*/
function headerNameToString(value) {
	return typeof value === "string" ? headerNameLowerCasedRecord$1[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
}
/**
* Receive the buffer as a string and return its lowercase value.
* @param {Buffer} value Header name
* @returns {string}
*/
function bufferToLowerCasedHeaderName(value) {
	return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
}
/**
* @param {Record<string, string | string[]> | (Buffer | string | (Buffer | string)[])[]} headers
* @param {Record<string, string | string[]>} [obj]
* @returns {Record<string, string | string[]>}
*/
function parseHeaders$1(headers$1, obj) {
	if (obj === undefined) obj = {};
	for (let i = 0; i < headers$1.length; i += 2) {
		const key = headerNameToString(headers$1[i]);
		let val = obj[key];
		if (val) {
			if (typeof val === "string") {
				val = [val];
				obj[key] = val;
			}
			val.push(headers$1[i + 1].toString("utf8"));
		} else {
			const headersValue = headers$1[i + 1];
			if (typeof headersValue === "string") obj[key] = headersValue;
else obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
		}
	}
	if ("content-length" in obj && "content-disposition" in obj) obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
	return obj;
}
function parseRawHeaders(headers$1) {
	const len = headers$1.length;
	const ret = new Array(len);
	let hasContentLength = false;
	let contentDispositionIdx = -1;
	let key;
	let val;
	let kLen = 0;
	for (let n = 0; n < headers$1.length; n += 2) {
		key = headers$1[n];
		val = headers$1[n + 1];
		typeof key !== "string" && (key = key.toString());
		typeof val !== "string" && (val = val.toString("utf8"));
		kLen = key.length;
		if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) hasContentLength = true;
else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) contentDispositionIdx = n + 1;
		ret[n] = key;
		ret[n + 1] = val;
	}
	if (hasContentLength && contentDispositionIdx !== -1) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
	return ret;
}
function isBuffer$1(buffer) {
	return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
}
function validateHandler$1(handler, method, upgrade$2) {
	if (!handler || typeof handler !== "object") throw new InvalidArgumentError$m("handler must be an object");
	if (typeof handler.onConnect !== "function") throw new InvalidArgumentError$m("invalid onConnect method");
	if (typeof handler.onError !== "function") throw new InvalidArgumentError$m("invalid onError method");
	if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) throw new InvalidArgumentError$m("invalid onBodySent method");
	if (upgrade$2 || method === "CONNECT") {
		if (typeof handler.onUpgrade !== "function") throw new InvalidArgumentError$m("invalid onUpgrade method");
	} else {
		if (typeof handler.onHeaders !== "function") throw new InvalidArgumentError$m("invalid onHeaders method");
		if (typeof handler.onData !== "function") throw new InvalidArgumentError$m("invalid onData method");
		if (typeof handler.onComplete !== "function") throw new InvalidArgumentError$m("invalid onComplete method");
	}
}
function isDisturbed$1(body$1) {
	return !!(body$1 && (stream$2.isDisturbed(body$1) || body$1[kBodyUsed$1]));
}
function isErrored(body$1) {
	return !!(body$1 && stream$2.isErrored(body$1));
}
function isReadable(body$1) {
	return !!(body$1 && stream$2.isReadable(body$1));
}
function getSocketInfo(socket) {
	return {
		localAddress: socket.localAddress,
		localPort: socket.localPort,
		remoteAddress: socket.remoteAddress,
		remotePort: socket.remotePort,
		remoteFamily: socket.remoteFamily,
		timeout: socket.timeout,
		bytesWritten: socket.bytesWritten,
		bytesRead: socket.bytesRead
	};
}
/** @type {globalThis['ReadableStream']} */
function ReadableStreamFrom$1(iterable) {
	let iterator;
	return new ReadableStream({
		async start() {
			iterator = iterable[Symbol.asyncIterator]();
		},
		async pull(controller) {
			const { done, value } = await iterator.next();
			if (done) queueMicrotask(() => {
				controller.close();
				controller.byobRequest?.respond(0);
			});
else {
				const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
				if (buf.byteLength) controller.enqueue(new Uint8Array(buf));
			}
			return controller.desiredSize > 0;
		},
		async cancel(reason) {
			await iterator.return();
		},
		type: "bytes"
	});
}
function isFormDataLike$1(object) {
	return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
}
function addAbortListener$1(signal, listener) {
	if ("addEventListener" in signal) {
		signal.addEventListener("abort", listener, { once: true });
		return () => signal.removeEventListener("abort", listener);
	}
	signal.addListener("abort", listener);
	return () => signal.removeListener("abort", listener);
}
const hasToWellFormed = typeof String.prototype.toWellFormed === "function";
const hasIsWellFormed = typeof String.prototype.isWellFormed === "function";
/**
* @param {string} val
*/
function toUSVString(val) {
	return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
}
/**
* @param {string} val
*/
function isUSVString(val) {
	return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
}
/**
* @see https://tools.ietf.org/html/rfc7230#section-3.2.6
* @param {number} c
*/
function isTokenCharCode(c) {
	switch (c) {
		case 34:
		case 40:
		case 41:
		case 44:
		case 47:
		case 58:
		case 59:
		case 60:
		case 61:
		case 62:
		case 63:
		case 64:
		case 91:
		case 92:
		case 93:
		case 123:
		case 125: return false;
		default: return c >= 33 && c <= 126;
	}
}
/**
* @param {string} characters
*/
function isValidHTTPToken$1(characters) {
	if (characters.length === 0) return false;
	for (let i = 0; i < characters.length; ++i) if (!isTokenCharCode(characters.charCodeAt(i))) return false;
	return true;
}
/**
* Matches if val contains an invalid field-vchar
*  field-value    = *( field-content / obs-fold )
*  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
*  field-vchar    = VCHAR / obs-text
*/
const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
/**
* @param {string} characters
*/
function isValidHeaderValue$1(characters) {
	return !headerCharRegex.test(characters);
}
function parseRangeHeader$1(range) {
	if (range == null || range === "") return {
		start: 0,
		end: null,
		size: null
	};
	const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
	return m ? {
		start: parseInt(m[1]),
		end: m[2] ? parseInt(m[2]) : null,
		size: m[3] ? parseInt(m[3]) : null
	} : null;
}
function addListener$1(obj, name, listener) {
	const listeners = obj[kListeners] ??= [];
	listeners.push([name, listener]);
	obj.on(name, listener);
	return obj;
}
function removeAllListeners$1(obj) {
	for (const [name, listener] of obj[kListeners] ?? []) obj.removeListener(name, listener);
	obj[kListeners] = null;
}
function errorRequest(client$1, request$4, err) {
	try {
		request$4.onError(err);
		assert$e(request$4.aborted);
	} catch (err$1) {
		client$1.emit("error", err$1);
	}
}
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
const normalizedMethodRecordsBase = {
	delete: "DELETE",
	DELETE: "DELETE",
	get: "GET",
	GET: "GET",
	head: "HEAD",
	HEAD: "HEAD",
	options: "OPTIONS",
	OPTIONS: "OPTIONS",
	post: "POST",
	POST: "POST",
	put: "PUT",
	PUT: "PUT"
};
const normalizedMethodRecords$1 = {
	...normalizedMethodRecordsBase,
	patch: "patch",
	PATCH: "PATCH"
};
Object.setPrototypeOf(normalizedMethodRecordsBase, null);
Object.setPrototypeOf(normalizedMethodRecords$1, null);
var util$n = {
	kEnumerableProperty,
	nop,
	isDisturbed: isDisturbed$1,
	isErrored,
	isReadable,
	toUSVString,
	isUSVString,
	isBlobLike: isBlobLike$1,
	parseOrigin: parseOrigin$1,
	parseURL,
	getServerName: getServerName$1,
	isStream: isStream$1,
	isIterable: isIterable$1,
	isAsyncIterable,
	isDestroyed,
	headerNameToString,
	bufferToLowerCasedHeaderName,
	addListener: addListener$1,
	removeAllListeners: removeAllListeners$1,
	errorRequest,
	parseRawHeaders,
	parseHeaders: parseHeaders$1,
	parseKeepAliveTimeout,
	destroy: destroy$1,
	bodyLength,
	deepClone,
	ReadableStreamFrom: ReadableStreamFrom$1,
	isBuffer: isBuffer$1,
	validateHandler: validateHandler$1,
	getSocketInfo,
	isFormDataLike: isFormDataLike$1,
	buildURL: buildURL$3,
	addAbortListener: addAbortListener$1,
	isValidHTTPToken: isValidHTTPToken$1,
	isValidHeaderValue: isValidHeaderValue$1,
	isTokenCharCode,
	parseRangeHeader: parseRangeHeader$1,
	normalizedMethodRecordsBase,
	normalizedMethodRecords: normalizedMethodRecords$1,
	isValidPort,
	isHttpOrHttpsPrefixed,
	nodeMajor,
	nodeMinor,
	safeHTTPMethods: [
		"GET",
		"HEAD",
		"OPTIONS",
		"TRACE"
	],
	wrapRequestBody: wrapRequestBody$1
};
const diagnosticsChannel = require$$0$4;
const util$m = require$$0$3;
const undiciDebugLog = util$m.debuglog("undici");
const fetchDebuglog = util$m.debuglog("fetch");
const websocketDebuglog = util$m.debuglog("websocket");
let isClientSet = false;
const channels$3 = {
	beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
	connected: diagnosticsChannel.channel("undici:client:connected"),
	connectError: diagnosticsChannel.channel("undici:client:connectError"),
	sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
	create: diagnosticsChannel.channel("undici:request:create"),
	bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
	headers: diagnosticsChannel.channel("undici:request:headers"),
	trailers: diagnosticsChannel.channel("undici:request:trailers"),
	error: diagnosticsChannel.channel("undici:request:error"),
	open: diagnosticsChannel.channel("undici:websocket:open"),
	close: diagnosticsChannel.channel("undici:websocket:close"),
	socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
	ping: diagnosticsChannel.channel("undici:websocket:ping"),
	pong: diagnosticsChannel.channel("undici:websocket:pong")
};
if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
	const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
	diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
		const { connectParams: { version, protocol, port, host } } = evt;
		debuglog("connecting to %s using %s%s", `${host}${port ? `:${port}` : ""}`, protocol, version);
	});
	diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
		const { connectParams: { version, protocol, port, host } } = evt;
		debuglog("connected to %s using %s%s", `${host}${port ? `:${port}` : ""}`, protocol, version);
	});
	diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
		const { connectParams: { version, protocol, port, host }, error } = evt;
		debuglog("connection to %s using %s%s errored - %s", `${host}${port ? `:${port}` : ""}`, protocol, version, error.message);
	});
	diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
		const { request: { method, path: path$1, origin } } = evt;
		debuglog("sending request to %s %s/%s", method, origin, path$1);
	});
	diagnosticsChannel.channel("undici:request:headers").subscribe((evt) => {
		const { request: { method, path: path$1, origin }, response: { statusCode } } = evt;
		debuglog("received response to %s %s/%s - HTTP %d", method, origin, path$1, statusCode);
	});
	diagnosticsChannel.channel("undici:request:trailers").subscribe((evt) => {
		const { request: { method, path: path$1, origin } } = evt;
		debuglog("trailers received from %s %s/%s", method, origin, path$1);
	});
	diagnosticsChannel.channel("undici:request:error").subscribe((evt) => {
		const { request: { method, path: path$1, origin }, error } = evt;
		debuglog("request to %s %s/%s errored - %s", method, origin, path$1, error.message);
	});
	isClientSet = true;
}
if (websocketDebuglog.enabled) {
	if (!isClientSet) {
		const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
		diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
			const { connectParams: { version, protocol, port, host } } = evt;
			debuglog("connecting to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
		});
		diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
			const { connectParams: { version, protocol, port, host } } = evt;
			debuglog("connected to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
		});
		diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
			const { connectParams: { version, protocol, port, host }, error } = evt;
			debuglog("connection to %s%s using %s%s errored - %s", host, port ? `:${port}` : "", protocol, version, error.message);
		});
		diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
			const { request: { method, path: path$1, origin } } = evt;
			debuglog("sending request to %s %s/%s", method, origin, path$1);
		});
	}
	diagnosticsChannel.channel("undici:websocket:open").subscribe((evt) => {
		const { address: { address, port } } = evt;
		websocketDebuglog("connection opened %s%s", address, port ? `:${port}` : "");
	});
	diagnosticsChannel.channel("undici:websocket:close").subscribe((evt) => {
		const { websocket: websocket$1, code, reason } = evt;
		websocketDebuglog("closed connection to %s - %s %s", websocket$1.url, code, reason);
	});
	diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((err) => {
		websocketDebuglog("connection errored - %s", err.message);
	});
	diagnosticsChannel.channel("undici:websocket:ping").subscribe((evt) => {
		websocketDebuglog("ping received");
	});
	diagnosticsChannel.channel("undici:websocket:pong").subscribe((evt) => {
		websocketDebuglog("pong received");
	});
}
var diagnostics = { channels: channels$3 };
const { InvalidArgumentError: InvalidArgumentError$l, NotSupportedError: NotSupportedError$1 } = errors$1;
const assert$d = require$$0;
const { isValidHTTPToken, isValidHeaderValue, isStream, destroy, isBuffer, isFormDataLike, isIterable, isBlobLike, buildURL: buildURL$2, validateHandler, getServerName, normalizedMethodRecords } = util$n;
const { channels: channels$2 } = diagnostics;
const { headerNameLowerCasedRecord } = constants$5;
const invalidPathRegex = /[^\u0021-\u00ff]/;
const kHandler = Symbol("handler");
let Request$2 = class Request$3 {
	constructor(origin, { path: path$1, method, body: body$1, headers: headers$1, query, idempotent, blocking, upgrade: upgrade$2, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue, servername }, handler) {
		if (typeof path$1 !== "string") throw new InvalidArgumentError$l("path must be a string");
else if (path$1[0] !== "/" && !(path$1.startsWith("http://") || path$1.startsWith("https://")) && method !== "CONNECT") throw new InvalidArgumentError$l("path must be an absolute URL or start with a slash");
else if (invalidPathRegex.test(path$1)) throw new InvalidArgumentError$l("invalid request path");
		if (typeof method !== "string") throw new InvalidArgumentError$l("method must be a string");
else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) throw new InvalidArgumentError$l("invalid request method");
		if (upgrade$2 && typeof upgrade$2 !== "string") throw new InvalidArgumentError$l("upgrade must be a string");
		if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$l("invalid headersTimeout");
		if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$l("invalid bodyTimeout");
		if (reset != null && typeof reset !== "boolean") throw new InvalidArgumentError$l("invalid reset");
		if (expectContinue != null && typeof expectContinue !== "boolean") throw new InvalidArgumentError$l("invalid expectContinue");
		this.headersTimeout = headersTimeout;
		this.bodyTimeout = bodyTimeout;
		this.throwOnError = throwOnError === true;
		this.method = method;
		this.abort = null;
		if (body$1 == null) this.body = null;
else if (isStream(body$1)) {
			this.body = body$1;
			const rState = this.body._readableState;
			if (!rState || !rState.autoDestroy) {
				this.endHandler = function autoDestroy() {
					destroy(this);
				};
				this.body.on("end", this.endHandler);
			}
			this.errorHandler = (err) => {
				if (this.abort) this.abort(err);
else this.error = err;
			};
			this.body.on("error", this.errorHandler);
		} else if (isBuffer(body$1)) this.body = body$1.byteLength ? body$1 : null;
else if (ArrayBuffer.isView(body$1)) this.body = body$1.buffer.byteLength ? Buffer.from(body$1.buffer, body$1.byteOffset, body$1.byteLength) : null;
else if (body$1 instanceof ArrayBuffer) this.body = body$1.byteLength ? Buffer.from(body$1) : null;
else if (typeof body$1 === "string") this.body = body$1.length ? Buffer.from(body$1) : null;
else if (isFormDataLike(body$1) || isIterable(body$1) || isBlobLike(body$1)) this.body = body$1;
else throw new InvalidArgumentError$l("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
		this.completed = false;
		this.aborted = false;
		this.upgrade = upgrade$2 || null;
		this.path = query ? buildURL$2(path$1, query) : path$1;
		this.origin = origin;
		this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
		this.blocking = blocking == null ? false : blocking;
		this.reset = reset == null ? null : reset;
		this.host = null;
		this.contentLength = null;
		this.contentType = null;
		this.headers = [];
		this.expectContinue = expectContinue != null ? expectContinue : false;
		if (Array.isArray(headers$1)) {
			if (headers$1.length % 2 !== 0) throw new InvalidArgumentError$l("headers array must be even");
			for (let i = 0; i < headers$1.length; i += 2) processHeader(this, headers$1[i], headers$1[i + 1]);
		} else if (headers$1 && typeof headers$1 === "object") if (headers$1[Symbol.iterator]) for (const header of headers$1) {
			if (!Array.isArray(header) || header.length !== 2) throw new InvalidArgumentError$l("headers must be in key-value pair format");
			processHeader(this, header[0], header[1]);
		}
else {
			const keys = Object.keys(headers$1);
			for (let i = 0; i < keys.length; ++i) processHeader(this, keys[i], headers$1[keys[i]]);
		}
else if (headers$1 != null) throw new InvalidArgumentError$l("headers must be an object or an array");
		validateHandler(handler, method, upgrade$2);
		this.servername = servername || getServerName(this.host);
		this[kHandler] = handler;
		if (channels$2.create.hasSubscribers) channels$2.create.publish({ request: this });
	}
	onBodySent(chunk) {
		if (this[kHandler].onBodySent) try {
			return this[kHandler].onBodySent(chunk);
		} catch (err) {
			this.abort(err);
		}
	}
	onRequestSent() {
		if (channels$2.bodySent.hasSubscribers) channels$2.bodySent.publish({ request: this });
		if (this[kHandler].onRequestSent) try {
			return this[kHandler].onRequestSent();
		} catch (err) {
			this.abort(err);
		}
	}
	onConnect(abort$1) {
		assert$d(!this.aborted);
		assert$d(!this.completed);
		if (this.error) abort$1(this.error);
else {
			this.abort = abort$1;
			return this[kHandler].onConnect(abort$1);
		}
	}
	onResponseStarted() {
		return this[kHandler].onResponseStarted?.();
	}
	onHeaders(statusCode, headers$1, resume$1, statusText) {
		assert$d(!this.aborted);
		assert$d(!this.completed);
		if (channels$2.headers.hasSubscribers) channels$2.headers.publish({
			request: this,
			response: {
				statusCode,
				headers: headers$1,
				statusText
			}
		});
		try {
			return this[kHandler].onHeaders(statusCode, headers$1, resume$1, statusText);
		} catch (err) {
			this.abort(err);
		}
	}
	onData(chunk) {
		assert$d(!this.aborted);
		assert$d(!this.completed);
		try {
			return this[kHandler].onData(chunk);
		} catch (err) {
			this.abort(err);
			return false;
		}
	}
	onUpgrade(statusCode, headers$1, socket) {
		assert$d(!this.aborted);
		assert$d(!this.completed);
		return this[kHandler].onUpgrade(statusCode, headers$1, socket);
	}
	onComplete(trailers) {
		this.onFinally();
		assert$d(!this.aborted);
		this.completed = true;
		if (channels$2.trailers.hasSubscribers) channels$2.trailers.publish({
			request: this,
			trailers
		});
		try {
			return this[kHandler].onComplete(trailers);
		} catch (err) {
			this.onError(err);
		}
	}
	onError(error) {
		this.onFinally();
		if (channels$2.error.hasSubscribers) channels$2.error.publish({
			request: this,
			error
		});
		if (this.aborted) return;
		this.aborted = true;
		return this[kHandler].onError(error);
	}
	onFinally() {
		if (this.errorHandler) {
			this.body.off("error", this.errorHandler);
			this.errorHandler = null;
		}
		if (this.endHandler) {
			this.body.off("end", this.endHandler);
			this.endHandler = null;
		}
	}
	addHeader(key, value) {
		processHeader(this, key, value);
		return this;
	}
};
function processHeader(request$4, key, val) {
	if (val && typeof val === "object" && !Array.isArray(val)) throw new InvalidArgumentError$l(`invalid ${key} header`);
else if (val === undefined) return;
	let headerName = headerNameLowerCasedRecord[key];
	if (headerName === undefined) {
		headerName = key.toLowerCase();
		if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) throw new InvalidArgumentError$l("invalid header key");
	}
	if (Array.isArray(val)) {
		const arr = [];
		for (let i = 0; i < val.length; i++) if (typeof val[i] === "string") {
			if (!isValidHeaderValue(val[i])) throw new InvalidArgumentError$l(`invalid ${key} header`);
			arr.push(val[i]);
		} else if (val[i] === null) arr.push("");
else if (typeof val[i] === "object") throw new InvalidArgumentError$l(`invalid ${key} header`);
else arr.push(`${val[i]}`);
		val = arr;
	} else if (typeof val === "string") {
		if (!isValidHeaderValue(val)) throw new InvalidArgumentError$l(`invalid ${key} header`);
	} else if (val === null) val = "";
else val = `${val}`;
	if (request$4.host === null && headerName === "host") {
		if (typeof val !== "string") throw new InvalidArgumentError$l("invalid host header");
		request$4.host = val;
	} else if (request$4.contentLength === null && headerName === "content-length") {
		request$4.contentLength = parseInt(val, 10);
		if (!Number.isFinite(request$4.contentLength)) throw new InvalidArgumentError$l("invalid content-length header");
	} else if (request$4.contentType === null && headerName === "content-type") {
		request$4.contentType = val;
		request$4.headers.push(key, val);
	} else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") throw new InvalidArgumentError$l(`invalid ${headerName} header`);
else if (headerName === "connection") {
		const value = typeof val === "string" ? val.toLowerCase() : null;
		if (value !== "close" && value !== "keep-alive") throw new InvalidArgumentError$l("invalid connection header");
		if (value === "close") request$4.reset = true;
	} else if (headerName === "expect") throw new NotSupportedError$1("expect header not supported");
else request$4.headers.push(key, val);
}
var request$3 = Request$2;
const EventEmitter = require$$8;
let Dispatcher$4 = class Dispatcher$5 extends EventEmitter {
	dispatch() {
		throw new Error("not implemented");
	}
	close() {
		throw new Error("not implemented");
	}
	destroy() {
		throw new Error("not implemented");
	}
	compose(...args) {
		const interceptors$1 = Array.isArray(args[0]) ? args[0] : args;
		let dispatch = this.dispatch.bind(this);
		for (const interceptor of interceptors$1) {
			if (interceptor == null) continue;
			if (typeof interceptor !== "function") throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
			dispatch = interceptor(dispatch);
			if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) throw new TypeError("invalid interceptor");
		}
		return new ComposedDispatcher(this, dispatch);
	}
};
var ComposedDispatcher = class extends Dispatcher$4 {
	#dispatcher = null;
	#dispatch = null;
	constructor(dispatcher$1, dispatch) {
		super();
		this.#dispatcher = dispatcher$1;
		this.#dispatch = dispatch;
	}
	dispatch(...args) {
		this.#dispatch(...args);
	}
	close(...args) {
		return this.#dispatcher.close(...args);
	}
	destroy(...args) {
		return this.#dispatcher.destroy(...args);
	}
};
var dispatcher = Dispatcher$4;
const Dispatcher$3 = dispatcher;
const { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$k } = errors$1;
const { kDestroy: kDestroy$5, kClose: kClose$7, kClosed: kClosed$1, kDestroyed: kDestroyed$1, kDispatch: kDispatch$4, kInterceptors: kInterceptors$5 } = symbols$4;
const kOnDestroyed = Symbol("onDestroyed");
const kOnClosed = Symbol("onClosed");
const kInterceptedDispatch = Symbol("Intercepted Dispatch");
let DispatcherBase$5 = class DispatcherBase$6 extends Dispatcher$3 {
	constructor() {
		super();
		this[kDestroyed$1] = false;
		this[kOnDestroyed] = null;
		this[kClosed$1] = false;
		this[kOnClosed] = [];
	}
	get destroyed() {
		return this[kDestroyed$1];
	}
	get closed() {
		return this[kClosed$1];
	}
	get interceptors() {
		return this[kInterceptors$5];
	}
	set interceptors(newInterceptors) {
		if (newInterceptors) for (let i = newInterceptors.length - 1; i >= 0; i--) {
			const interceptor = this[kInterceptors$5][i];
			if (typeof interceptor !== "function") throw new InvalidArgumentError$k("interceptor must be an function");
		}
		this[kInterceptors$5] = newInterceptors;
	}
	close(callback) {
		if (callback === undefined) return new Promise((resolve, reject) => {
			this.close((err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		if (typeof callback !== "function") throw new InvalidArgumentError$k("invalid callback");
		if (this[kDestroyed$1]) {
			queueMicrotask(() => callback(new ClientDestroyedError$1(), null));
			return;
		}
		if (this[kClosed$1]) {
			if (this[kOnClosed]) this[kOnClosed].push(callback);
else queueMicrotask(() => callback(null, null));
			return;
		}
		this[kClosed$1] = true;
		this[kOnClosed].push(callback);
		const onClosed = () => {
			const callbacks = this[kOnClosed];
			this[kOnClosed] = null;
			for (let i = 0; i < callbacks.length; i++) callbacks[i](null, null);
		};
		this[kClose$7]().then(() => this.destroy()).then(() => {
			queueMicrotask(onClosed);
		});
	}
	destroy(err, callback) {
		if (typeof err === "function") {
			callback = err;
			err = null;
		}
		if (callback === undefined) return new Promise((resolve, reject) => {
			this.destroy(err, (err$1, data) => {
				return err$1 ? reject(err$1) : resolve(data);
			});
		});
		if (typeof callback !== "function") throw new InvalidArgumentError$k("invalid callback");
		if (this[kDestroyed$1]) {
			if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
else queueMicrotask(() => callback(null, null));
			return;
		}
		if (!err) err = new ClientDestroyedError$1();
		this[kDestroyed$1] = true;
		this[kOnDestroyed] = this[kOnDestroyed] || [];
		this[kOnDestroyed].push(callback);
		const onDestroyed = () => {
			const callbacks = this[kOnDestroyed];
			this[kOnDestroyed] = null;
			for (let i = 0; i < callbacks.length; i++) callbacks[i](null, null);
		};
		this[kDestroy$5](err).then(() => {
			queueMicrotask(onDestroyed);
		});
	}
	[kInterceptedDispatch](opts, handler) {
		if (!this[kInterceptors$5] || this[kInterceptors$5].length === 0) {
			this[kInterceptedDispatch] = this[kDispatch$4];
			return this[kDispatch$4](opts, handler);
		}
		let dispatch = this[kDispatch$4].bind(this);
		for (let i = this[kInterceptors$5].length - 1; i >= 0; i--) dispatch = this[kInterceptors$5][i](dispatch);
		this[kInterceptedDispatch] = dispatch;
		return dispatch(opts, handler);
	}
	dispatch(opts, handler) {
		if (!handler || typeof handler !== "object") throw new InvalidArgumentError$k("handler must be an object");
		try {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$k("opts must be an object.");
			if (this[kDestroyed$1] || this[kOnDestroyed]) throw new ClientDestroyedError$1();
			if (this[kClosed$1]) throw new ClientClosedError();
			return this[kInterceptedDispatch](opts, handler);
		} catch (err) {
			if (typeof handler.onError !== "function") throw new InvalidArgumentError$k("invalid onError method");
			handler.onError(err);
			return false;
		}
	}
};
var dispatcherBase = DispatcherBase$5;
const net$1 = require$$4;
const assert$c = require$$0;
const util$l = util$n;
const { InvalidArgumentError: InvalidArgumentError$j, ConnectTimeoutError } = errors$1;
let tls;
let SessionCache;
if (commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) SessionCache = class WeakSessionCache {
	constructor(maxCachedSessions) {
		this._maxCachedSessions = maxCachedSessions;
		this._sessionCache = new Map();
		this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
			if (this._sessionCache.size < this._maxCachedSessions) return;
			const ref = this._sessionCache.get(key);
			if (ref !== undefined && ref.deref() === undefined) this._sessionCache.delete(key);
		});
	}
	get(sessionKey) {
		const ref = this._sessionCache.get(sessionKey);
		return ref ? ref.deref() : null;
	}
	set(sessionKey, session) {
		if (this._maxCachedSessions === 0) return;
		this._sessionCache.set(sessionKey, new WeakRef(session));
		this._sessionRegistry.register(session, sessionKey);
	}
};
else SessionCache = class SimpleSessionCache {
	constructor(maxCachedSessions) {
		this._maxCachedSessions = maxCachedSessions;
		this._sessionCache = new Map();
	}
	get(sessionKey) {
		return this._sessionCache.get(sessionKey);
	}
	set(sessionKey, session) {
		if (this._maxCachedSessions === 0) return;
		if (this._sessionCache.size >= this._maxCachedSessions) {
			const { value: oldestKey } = this._sessionCache.keys().next();
			this._sessionCache.delete(oldestKey);
		}
		this._sessionCache.set(sessionKey, session);
	}
};
function buildConnector$4({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession,...opts }) {
	if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError$j("maxCachedSessions must be a positive integer or zero");
	const options = {
		path: socketPath,
		...opts
	};
	const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
	timeout = timeout == null ? 1e4 : timeout;
	allowH2 = allowH2 != null ? allowH2 : false;
	return function connect$4({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
		let socket;
		if (protocol === "https:") {
			if (!tls) tls = require$$4$1;
			servername = servername || options.servername || util$l.getServerName(host) || null;
			const sessionKey = servername || hostname;
			const session = customSession || sessionCache.get(sessionKey) || null;
			assert$c(sessionKey);
			socket = tls.connect({
				highWaterMark: 16384,
				...options,
				servername,
				session,
				localAddress,
				ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
				socket: httpSocket,
				port: port || 443,
				host: hostname
			});
			socket.on("session", function(session$1) {
				sessionCache.set(sessionKey, session$1);
			});
		} else {
			assert$c(!httpSocket, "httpSocket can only be sent on TLS update");
			socket = net$1.connect({
				highWaterMark: 65536,
				...options,
				localAddress,
				port: port || 80,
				host: hostname
			});
		}
		if (options.keepAlive == null || options.keepAlive) {
			const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 6e4 : options.keepAliveInitialDelay;
			socket.setKeepAlive(true, keepAliveInitialDelay);
		}
		const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
		socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
			cancelTimeout();
			if (callback) {
				const cb = callback;
				callback = null;
				cb(null, this);
			}
		}).on("error", function(err) {
			cancelTimeout();
			if (callback) {
				const cb = callback;
				callback = null;
				cb(err);
			}
		});
		return socket;
	};
}
function setupTimeout(onConnectTimeout$1, timeout) {
	if (!timeout) return () => {};
	let s1 = null;
	let s2 = null;
	const timeoutId = setTimeout(() => {
		s1 = setImmediate(() => {
			if (process.platform === "win32") s2 = setImmediate(() => onConnectTimeout$1());
else onConnectTimeout$1();
		});
	}, timeout);
	return () => {
		clearTimeout(timeoutId);
		clearImmediate(s1);
		clearImmediate(s2);
	};
}
function onConnectTimeout(socket) {
	let message = "Connect Timeout Error";
	if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")})`;
	util$l.destroy(socket, new ConnectTimeoutError(message));
}
var connect$3 = buildConnector$4;
const TICK_MS = 499;
let fastNow = Date.now();
let fastNowTimeout;
const fastTimers = [];
function onTimeout() {
	fastNow = Date.now();
	let len = fastTimers.length;
	let idx = 0;
	while (idx < len) {
		const timer = fastTimers[idx];
		if (timer.state === 0) timer.state = fastNow + timer.delay - TICK_MS;
else if (timer.state > 0 && fastNow >= timer.state) {
			timer.state = -1;
			timer.callback(timer.opaque);
		}
		if (timer.state === -1) {
			timer.state = -2;
			if (idx !== len - 1) fastTimers[idx] = fastTimers.pop();
else fastTimers.pop();
			len -= 1;
		} else idx += 1;
	}
	if (fastTimers.length > 0) refreshTimeout();
}
function refreshTimeout() {
	if (fastNowTimeout?.refresh) fastNowTimeout.refresh();
else {
		clearTimeout(fastNowTimeout);
		fastNowTimeout = setTimeout(onTimeout, TICK_MS);
		if (fastNowTimeout.unref) fastNowTimeout.unref();
	}
}
var Timeout = class {
	constructor(callback, delay, opaque) {
		this.callback = callback;
		this.delay = delay;
		this.opaque = opaque;
		this.state = -2;
		this.refresh();
	}
	refresh() {
		if (this.state === -2) {
			fastTimers.push(this);
			if (!fastNowTimeout || fastTimers.length === 1) refreshTimeout();
		}
		this.state = 0;
	}
	clear() {
		this.state = -1;
	}
};
var timers$1 = {
	setTimeout(callback, delay, opaque) {
		return delay <= 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
	},
	clearTimeout(timeout) {
		if (timeout instanceof Timeout) timeout.clear();
else clearTimeout(timeout);
	}
};
var constants$4 = {};
var utils = {};
Object.defineProperty(utils, "__esModule", { value: true });
utils.enumToMap = void 0;
function enumToMap(obj) {
	const res = {};
	Object.keys(obj).forEach((key) => {
		const value = obj[key];
		if (typeof value === "number") res[key] = value;
	});
	return res;
}
utils.enumToMap = enumToMap;
(function(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
	const utils_1 = utils;
	(function(ERROR) {
		ERROR[ERROR["OK"] = 0] = "OK";
		ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
		ERROR[ERROR["STRICT"] = 2] = "STRICT";
		ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
		ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
		ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		ERROR[ERROR["USER"] = 24] = "USER";
	})(exports.ERROR || (exports.ERROR = {}));
	(function(TYPE) {
		TYPE[TYPE["BOTH"] = 0] = "BOTH";
		TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
		TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
	})(exports.TYPE || (exports.TYPE = {}));
	(function(FLAGS) {
		FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
		FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
		FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
		FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
		FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
	})(exports.FLAGS || (exports.FLAGS = {}));
	(function(LENIENT_FLAGS) {
		LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
		LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
	})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
	var METHODS;
	(function(METHODS$1) {
		METHODS$1[METHODS$1["DELETE"] = 0] = "DELETE";
		METHODS$1[METHODS$1["GET"] = 1] = "GET";
		METHODS$1[METHODS$1["HEAD"] = 2] = "HEAD";
		METHODS$1[METHODS$1["POST"] = 3] = "POST";
		METHODS$1[METHODS$1["PUT"] = 4] = "PUT";
		METHODS$1[METHODS$1["CONNECT"] = 5] = "CONNECT";
		METHODS$1[METHODS$1["OPTIONS"] = 6] = "OPTIONS";
		METHODS$1[METHODS$1["TRACE"] = 7] = "TRACE";
		METHODS$1[METHODS$1["COPY"] = 8] = "COPY";
		METHODS$1[METHODS$1["LOCK"] = 9] = "LOCK";
		METHODS$1[METHODS$1["MKCOL"] = 10] = "MKCOL";
		METHODS$1[METHODS$1["MOVE"] = 11] = "MOVE";
		METHODS$1[METHODS$1["PROPFIND"] = 12] = "PROPFIND";
		METHODS$1[METHODS$1["PROPPATCH"] = 13] = "PROPPATCH";
		METHODS$1[METHODS$1["SEARCH"] = 14] = "SEARCH";
		METHODS$1[METHODS$1["UNLOCK"] = 15] = "UNLOCK";
		METHODS$1[METHODS$1["BIND"] = 16] = "BIND";
		METHODS$1[METHODS$1["REBIND"] = 17] = "REBIND";
		METHODS$1[METHODS$1["UNBIND"] = 18] = "UNBIND";
		METHODS$1[METHODS$1["ACL"] = 19] = "ACL";
		METHODS$1[METHODS$1["REPORT"] = 20] = "REPORT";
		METHODS$1[METHODS$1["MKACTIVITY"] = 21] = "MKACTIVITY";
		METHODS$1[METHODS$1["CHECKOUT"] = 22] = "CHECKOUT";
		METHODS$1[METHODS$1["MERGE"] = 23] = "MERGE";
		METHODS$1[METHODS$1["M-SEARCH"] = 24] = "M-SEARCH";
		METHODS$1[METHODS$1["NOTIFY"] = 25] = "NOTIFY";
		METHODS$1[METHODS$1["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		METHODS$1[METHODS$1["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		METHODS$1[METHODS$1["PATCH"] = 28] = "PATCH";
		METHODS$1[METHODS$1["PURGE"] = 29] = "PURGE";
		METHODS$1[METHODS$1["MKCALENDAR"] = 30] = "MKCALENDAR";
		METHODS$1[METHODS$1["LINK"] = 31] = "LINK";
		METHODS$1[METHODS$1["UNLINK"] = 32] = "UNLINK";
		METHODS$1[METHODS$1["SOURCE"] = 33] = "SOURCE";
		METHODS$1[METHODS$1["PRI"] = 34] = "PRI";
		METHODS$1[METHODS$1["DESCRIBE"] = 35] = "DESCRIBE";
		METHODS$1[METHODS$1["ANNOUNCE"] = 36] = "ANNOUNCE";
		METHODS$1[METHODS$1["SETUP"] = 37] = "SETUP";
		METHODS$1[METHODS$1["PLAY"] = 38] = "PLAY";
		METHODS$1[METHODS$1["PAUSE"] = 39] = "PAUSE";
		METHODS$1[METHODS$1["TEARDOWN"] = 40] = "TEARDOWN";
		METHODS$1[METHODS$1["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		METHODS$1[METHODS$1["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		METHODS$1[METHODS$1["REDIRECT"] = 43] = "REDIRECT";
		METHODS$1[METHODS$1["RECORD"] = 44] = "RECORD";
		METHODS$1[METHODS$1["FLUSH"] = 45] = "FLUSH";
	})(METHODS = exports.METHODS || (exports.METHODS = {}));
	exports.METHODS_HTTP = [
		METHODS.DELETE,
		METHODS.GET,
		METHODS.HEAD,
		METHODS.POST,
		METHODS.PUT,
		METHODS.CONNECT,
		METHODS.OPTIONS,
		METHODS.TRACE,
		METHODS.COPY,
		METHODS.LOCK,
		METHODS.MKCOL,
		METHODS.MOVE,
		METHODS.PROPFIND,
		METHODS.PROPPATCH,
		METHODS.SEARCH,
		METHODS.UNLOCK,
		METHODS.BIND,
		METHODS.REBIND,
		METHODS.UNBIND,
		METHODS.ACL,
		METHODS.REPORT,
		METHODS.MKACTIVITY,
		METHODS.CHECKOUT,
		METHODS.MERGE,
		METHODS["M-SEARCH"],
		METHODS.NOTIFY,
		METHODS.SUBSCRIBE,
		METHODS.UNSUBSCRIBE,
		METHODS.PATCH,
		METHODS.PURGE,
		METHODS.MKCALENDAR,
		METHODS.LINK,
		METHODS.UNLINK,
		METHODS.PRI,
		METHODS.SOURCE
	];
	exports.METHODS_ICE = [METHODS.SOURCE];
	exports.METHODS_RTSP = [
		METHODS.OPTIONS,
		METHODS.DESCRIBE,
		METHODS.ANNOUNCE,
		METHODS.SETUP,
		METHODS.PLAY,
		METHODS.PAUSE,
		METHODS.TEARDOWN,
		METHODS.GET_PARAMETER,
		METHODS.SET_PARAMETER,
		METHODS.REDIRECT,
		METHODS.RECORD,
		METHODS.FLUSH,
		METHODS.GET,
		METHODS.POST
	];
	exports.METHOD_MAP = utils_1.enumToMap(METHODS);
	exports.H_METHOD_MAP = {};
	Object.keys(exports.METHOD_MAP).forEach((key) => {
		if (/^H/.test(key)) exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
	});
	(function(FINISH) {
		FINISH[FINISH["SAFE"] = 0] = "SAFE";
		FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
	})(exports.FINISH || (exports.FINISH = {}));
	exports.ALPHA = [];
	for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
		exports.ALPHA.push(String.fromCharCode(i));
		exports.ALPHA.push(String.fromCharCode(i + 32));
	}
	exports.NUM_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9
	};
	exports.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	};
	exports.NUM = [
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9"
	];
	exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
	exports.MARK = [
		"-",
		"_",
		".",
		"!",
		"~",
		"*",
		"'",
		"(",
		")"
	];
	exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
		"%",
		";",
		":",
		"&",
		"=",
		"+",
		"$",
		","
	]);
	exports.STRICT_URL_CHAR = [
		"!",
		"\"",
		"$",
		"%",
		"&",
		"'",
		"(",
		")",
		"*",
		"+",
		",",
		"-",
		".",
		"/",
		":",
		";",
		"<",
		"=",
		">",
		"@",
		"[",
		"\\",
		"]",
		"^",
		"_",
		"`",
		"{",
		"|",
		"}",
		"~"
	].concat(exports.ALPHANUM);
	exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
	for (let i = 128; i <= 255; i++) exports.URL_CHAR.push(i);
	exports.HEX = exports.NUM.concat([
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F"
	]);
	exports.STRICT_TOKEN = [
		"!",
		"#",
		"$",
		"%",
		"&",
		"'",
		"*",
		"+",
		"-",
		".",
		"^",
		"_",
		"`",
		"|",
		"~"
	].concat(exports.ALPHANUM);
	exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
	exports.HEADER_CHARS = ["	"];
	for (let i = 32; i <= 255; i++) if (i !== 127) exports.HEADER_CHARS.push(i);
	exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
	exports.MAJOR = exports.NUM_MAP;
	exports.MINOR = exports.MAJOR;
	var HEADER_STATE;
	(function(HEADER_STATE$1) {
		HEADER_STATE$1[HEADER_STATE$1["GENERAL"] = 0] = "GENERAL";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION"] = 1] = "CONNECTION";
		HEADER_STATE$1[HEADER_STATE$1["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		HEADER_STATE$1[HEADER_STATE$1["UPGRADE"] = 4] = "UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
	})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
	exports.SPECIAL_HEADERS = {
		"connection": HEADER_STATE.CONNECTION,
		"content-length": HEADER_STATE.CONTENT_LENGTH,
		"proxy-connection": HEADER_STATE.CONNECTION,
		"transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
		"upgrade": HEADER_STATE.UPGRADE
	};
})(constants$4);
var llhttpWasm;
var hasRequiredLlhttpWasm;
function requireLlhttpWasm() {
	if (hasRequiredLlhttpWasm) return llhttpWasm;
	hasRequiredLlhttpWasm = 1;
	const { Buffer: Buffer$2 } = require$$0$2;
	llhttpWasm = Buffer$2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB3QE2AhwLBgAgABAyC5otAQt/IwBBEGsiCiQAQaTQACgCACIJRQRAQeTTACgCACIFRQRAQfDTAEJ/NwIAQejTAEKAgISAgIDAADcCAEHk0wAgCkEIakFwcUHYqtWqBXMiBTYCAEH40wBBADYCAEHI0wBBADYCAAtBzNMAQYDUBDYCAEGc0ABBgNQENgIAQbDQACAFNgIAQazQAEF/NgIAQdDTAEGArAM2AgADQCABQcjQAGogAUG80ABqIgI2AgAgAiABQbTQAGoiAzYCACABQcDQAGogAzYCACABQdDQAGogAUHE0ABqIgM2AgAgAyACNgIAIAFB2NAAaiABQczQAGoiAjYCACACIAM2AgAgAUHU0ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM1ARBwasDNgIAQajQAEH00wAoAgA2AgBBmNAAQcCrAzYCAEGk0ABBiNQENgIAQcz/B0E4NgIAQYjUBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBjNAAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBtNAAaiIBIABBvNAAaigCACIAKAIIIgNGBEBBjNAAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQZTQACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBtNAAaiIBIAJBvNAAaigCACICKAIIIgNGBEBBjNAAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQbTQAGohAEGg0AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGM0AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQaDQACAENgIAQZTQACAFNgIADBELQZDQACgCACILRQ0BIAtoQQJ0QbzSAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBnNAAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQZDQACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBvNIAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbzSAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBlNAAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGc0AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBlNAAKAIAIgMgBE8EQEGg0AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQZTQACACNgIAQaDQACAANgIAIAFBCGohAQwPC0GY0AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBpNAAIAA2AgBBmNAAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QeTTACgCAARAQezTACgCAAwBC0Hw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBDGpBcHFB2KrVqgVzNgIAQfjTAEEANgIAQcjTAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEH80wBBMDYCAAwPCwJAQcTTACgCACIBRQ0AQbzTACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUH80wBBMDYCAAwPC0HI0wAtAABBBHENBAJAAkAgCQRAQczTACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQMyIAQX9GDQUgAiEGQejTACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQcTTACgCACIDBEBBvNMAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDMiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDMhACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQezTACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQM0F/RwRAIAAgBmohBiABIQAMBwtBACAGaxAzGgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtByNMAQcjTACgCAEEEcjYCAAsgAkH+////B0sNASACEDMhAEEAEDMhASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBvNMAQbzTACgCACAGaiIBNgIAQcDTACgCACABSQRAQcDTACABNgIACwJAAkACQEGk0AAoAgAiAgRAQczTACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBnNAAKAIAIgFBAEcgACABT3FFBEBBnNAAIAA2AgALQQAhAUHQ0wAgBjYCAEHM0wAgADYCAEGs0ABBfzYCAEGw0ABB5NMAKAIANgIAQdjTAEEANgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBqNAAQfTTACgCADYCAEGY0AAgATYCAEGk0AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBmNAAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBqNAAQfTTACgCADYCAEGY0AAgADYCAEGk0AAgAzYCACACIAdqQTg2AgQMAQsgAEGc0AAoAgBJBEBBnNAAIAA2AgALIAAgBmohA0HM0wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBzNMAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGk0AAgBDYCAEGY0ABBmNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQaDQACgCACAGRgRAQaDQACAENgIAQZTQAEGU0AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAc2AgAgA0EQakHU0wApAgA3AgAgA0HM0wApAgA3AghB1NMAIANBCGo2AgBB0NMAIAY2AgBBzNMAIAA2AgBB2NMAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIDcUUEQEGM0AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEGQ0AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGQ0AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBmNAAKAIAIgEgBE0NAEGk0AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGY0AAgATYCAEGk0AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUH80wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBvNIAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASABQQN2dCIBcUUEQEGM0AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbzSAGohAEGQ0AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGQ0AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEG80gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQZDQACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUG00ABqIQACf0GM0AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYzQACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBvNIAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBkNAAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBvNIAaiICKAIAIABGBEAgAiADNgIAIAMNAUGQ0AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBtNAAaiEBQaDQACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYzQACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0Gg0AAgBzYCAEGU0AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfzTAEEwNgIAQX8PCyAAQRB0DwsACwvcPyIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64");
	return llhttpWasm;
}
var llhttp_simdWasm;
var hasRequiredLlhttp_simdWasm;
function requireLlhttp_simdWasm() {
	if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
	hasRequiredLlhttp_simdWasm = 1;
	const { Buffer: Buffer$2 } = require$$0$2;
	llhttp_simdWasm = Buffer$2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64");
	return llhttp_simdWasm;
}
var constants$3;
var hasRequiredConstants$2;
function requireConstants$2() {
	if (hasRequiredConstants$2) return constants$3;
	hasRequiredConstants$2 = 1;
	const corsSafeListedMethods = [
		"GET",
		"HEAD",
		"POST"
	];
	const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
	const nullBodyStatus = [
		101,
		204,
		205,
		304
	];
	const redirectStatus = [
		301,
		302,
		303,
		307,
		308
	];
	const redirectStatusSet = new Set(redirectStatus);
	const badPorts = [
		"1",
		"7",
		"9",
		"11",
		"13",
		"15",
		"17",
		"19",
		"20",
		"21",
		"22",
		"23",
		"25",
		"37",
		"42",
		"43",
		"53",
		"69",
		"77",
		"79",
		"87",
		"95",
		"101",
		"102",
		"103",
		"104",
		"109",
		"110",
		"111",
		"113",
		"115",
		"117",
		"119",
		"123",
		"135",
		"137",
		"139",
		"143",
		"161",
		"179",
		"389",
		"427",
		"465",
		"512",
		"513",
		"514",
		"515",
		"526",
		"530",
		"531",
		"532",
		"540",
		"548",
		"554",
		"556",
		"563",
		"587",
		"601",
		"636",
		"989",
		"990",
		"993",
		"995",
		"1719",
		"1720",
		"1723",
		"2049",
		"3659",
		"4045",
		"4190",
		"5060",
		"5061",
		"6000",
		"6566",
		"6665",
		"6666",
		"6667",
		"6668",
		"6669",
		"6679",
		"6697",
		"10080"
	];
	const badPortsSet = new Set(badPorts);
	const referrerPolicy = [
		"",
		"no-referrer",
		"no-referrer-when-downgrade",
		"same-origin",
		"origin",
		"strict-origin",
		"origin-when-cross-origin",
		"strict-origin-when-cross-origin",
		"unsafe-url"
	];
	const referrerPolicySet = new Set(referrerPolicy);
	const requestRedirect = [
		"follow",
		"manual",
		"error"
	];
	const safeMethods = [
		"GET",
		"HEAD",
		"OPTIONS",
		"TRACE"
	];
	const safeMethodsSet = new Set(safeMethods);
	const requestMode = [
		"navigate",
		"same-origin",
		"no-cors",
		"cors"
	];
	const requestCredentials = [
		"omit",
		"same-origin",
		"include"
	];
	const requestCache = [
		"default",
		"no-store",
		"reload",
		"no-cache",
		"force-cache",
		"only-if-cached"
	];
	const requestBodyHeader = [
		"content-encoding",
		"content-language",
		"content-location",
		"content-type",
		"content-length"
	];
	const requestDuplex = ["half"];
	const forbiddenMethods = [
		"CONNECT",
		"TRACE",
		"TRACK"
	];
	const forbiddenMethodsSet = new Set(forbiddenMethods);
	const subresource = [
		"audio",
		"audioworklet",
		"font",
		"image",
		"manifest",
		"paintworklet",
		"script",
		"style",
		"track",
		"video",
		"xslt",
		""
	];
	const subresourceSet = new Set(subresource);
	constants$3 = {
		subresource,
		forbiddenMethods,
		requestBodyHeader,
		referrerPolicy,
		requestRedirect,
		requestMode,
		requestCredentials,
		requestCache,
		redirectStatus,
		corsSafeListedMethods,
		nullBodyStatus,
		safeMethods,
		badPorts,
		requestDuplex,
		subresourceSet,
		badPortsSet,
		redirectStatusSet,
		corsSafeListedMethodsSet,
		safeMethodsSet,
		forbiddenMethodsSet,
		referrerPolicySet
	};
	return constants$3;
}
var global$2;
var hasRequiredGlobal;
function requireGlobal() {
	if (hasRequiredGlobal) return global$2;
	hasRequiredGlobal = 1;
	const globalOrigin = Symbol.for("undici.globalOrigin.1");
	function getGlobalOrigin$1() {
		return globalThis[globalOrigin];
	}
	function setGlobalOrigin$1(newOrigin) {
		if (newOrigin === undefined) {
			Object.defineProperty(globalThis, globalOrigin, {
				value: undefined,
				writable: true,
				enumerable: false,
				configurable: false
			});
			return;
		}
		const parsedURL = new URL(newOrigin);
		if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
		Object.defineProperty(globalThis, globalOrigin, {
			value: parsedURL,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	global$2 = {
		getGlobalOrigin: getGlobalOrigin$1,
		setGlobalOrigin: setGlobalOrigin$1
	};
	return global$2;
}
var dataUrl;
var hasRequiredDataUrl;
function requireDataUrl() {
	if (hasRequiredDataUrl) return dataUrl;
	hasRequiredDataUrl = 1;
	const assert$10 = require$$0;
	const encoder = new TextEncoder();
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	*/
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
	const ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	*/
	const HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
	/** @param {URL} dataURL */
	function dataURLProcessor(dataURL) {
		assert$10(dataURL.protocol === "data:");
		let input = URLSerializer(dataURL, true);
		input = input.slice(5);
		const position = { position: 0 };
		let mimeType = collectASequenceOfCodePointsFast(",", input, position);
		const mimeTypeLength = mimeType.length;
		mimeType = removeASCIIWhitespace(mimeType, true, true);
		if (position.position >= input.length) return "failure";
		position.position++;
		const encodedBody = input.slice(mimeTypeLength + 1);
		let body$1 = stringPercentDecode(encodedBody);
		if (/;(\u0020){0,}base64$/i.test(mimeType)) {
			const stringBody = isomorphicDecode(body$1);
			body$1 = forgivingBase64(stringBody);
			if (body$1 === "failure") return "failure";
			mimeType = mimeType.slice(0, -6);
			mimeType = mimeType.replace(/(\u0020)+$/, "");
			mimeType = mimeType.slice(0, -1);
		}
		if (mimeType.startsWith(";")) mimeType = "text/plain" + mimeType;
		let mimeTypeRecord = parseMIMEType$1(mimeType);
		if (mimeTypeRecord === "failure") mimeTypeRecord = parseMIMEType$1("text/plain;charset=US-ASCII");
		return {
			mimeType: mimeTypeRecord,
			body: body$1
		};
	}
	/**
	* @param {URL} url
	* @param {boolean} excludeFragment
	*/
	function URLSerializer(url$1, excludeFragment = false) {
		if (!excludeFragment) return url$1.href;
		const href = url$1.href;
		const hashLength = url$1.hash.length;
		const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
		if (!hashLength && href.endsWith("#")) return serialized.slice(0, -1);
		return serialized;
	}
	/**
	* @param {(char: string) => boolean} condition
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePoints(condition, input, position) {
		let result = "";
		while (position.position < input.length && condition(input[position.position])) {
			result += input[position.position];
			position.position++;
		}
		return result;
	}
	/**
	* A faster collectASequenceOfCodePoints that only works when comparing a single character.
	* @param {string} char
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePointsFast(char, input, position) {
		const idx = input.indexOf(char, position.position);
		const start = position.position;
		if (idx === -1) {
			position.position = input.length;
			return input.slice(start);
		}
		position.position = idx;
		return input.slice(start, position.position);
	}
	/** @param {string} input */
	function stringPercentDecode(input) {
		const bytes = encoder.encode(input);
		return percentDecode(bytes);
	}
	/**
	* @param {number} byte
	*/
	function isHexCharByte(byte) {
		return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
	}
	/**
	* @param {number} byte
	*/
	function hexByteToNumber(byte) {
		return byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55;
	}
	/** @param {Uint8Array} input */
	function percentDecode(input) {
		const length = input.length;
		/** @type {Uint8Array} */
		const output = new Uint8Array(length);
		let j = 0;
		for (let i = 0; i < length; ++i) {
			const byte = input[i];
			if (byte !== 37) output[j++] = byte;
else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) output[j++] = 37;
else {
				output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
				i += 2;
			}
		}
		return length === j ? output : output.subarray(0, j);
	}
	/** @param {string} input */
	function parseMIMEType$1(input) {
		input = removeHTTPWhitespace(input, true, true);
		const position = { position: 0 };
		const type = collectASequenceOfCodePointsFast("/", input, position);
		if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) return "failure";
		if (position.position > input.length) return "failure";
		position.position++;
		let subtype = collectASequenceOfCodePointsFast(";", input, position);
		subtype = removeHTTPWhitespace(subtype, false, true);
		if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return "failure";
		const typeLowercase = type.toLowerCase();
		const subtypeLowercase = subtype.toLowerCase();
		const mimeType = {
			type: typeLowercase,
			subtype: subtypeLowercase,
			parameters: new Map(),
			essence: `${typeLowercase}/${subtypeLowercase}`
		};
		while (position.position < input.length) {
			position.position++;
			collectASequenceOfCodePoints(
				// https://fetch.spec.whatwg.org/#http-whitespace
				(char) => HTTP_WHITESPACE_REGEX.test(char),
				input,
				position
);
			let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
			parameterName = parameterName.toLowerCase();
			if (position.position < input.length) {
				if (input[position.position] === ";") continue;
				position.position++;
			}
			if (position.position > input.length) break;
			let parameterValue = null;
			if (input[position.position] === "\"") {
				parameterValue = collectAnHTTPQuotedString(input, position, true);
				collectASequenceOfCodePointsFast(";", input, position);
			} else {
				parameterValue = collectASequenceOfCodePointsFast(";", input, position);
				parameterValue = removeHTTPWhitespace(parameterValue, false, true);
				if (parameterValue.length === 0) continue;
			}
			if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
		}
		return mimeType;
	}
	/** @param {string} data */
	function forgivingBase64(data) {
		data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
		let dataLength = data.length;
		if (dataLength % 4 === 0) {
			if (data.charCodeAt(dataLength - 1) === 61) {
				--dataLength;
				if (data.charCodeAt(dataLength - 1) === 61) --dataLength;
			}
		}
		if (dataLength % 4 === 1) return "failure";
		if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) return "failure";
		const buffer = Buffer.from(data, "base64");
		return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
	}
	/**
	* @param {string} input
	* @param {{ position: number }} position
	* @param {boolean?} extractValue
	*/
	function collectAnHTTPQuotedString(input, position, extractValue) {
		const positionStart = position.position;
		let value = "";
		assert$10(input[position.position] === "\"");
		position.position++;
		while (true) {
			value += collectASequenceOfCodePoints((char) => char !== "\"" && char !== "\\", input, position);
			if (position.position >= input.length) break;
			const quoteOrBackslash = input[position.position];
			position.position++;
			if (quoteOrBackslash === "\\") {
				if (position.position >= input.length) {
					value += "\\";
					break;
				}
				value += input[position.position];
				position.position++;
			} else {
				assert$10(quoteOrBackslash === "\"");
				break;
			}
		}
		if (extractValue) return value;
		return input.slice(positionStart, position.position);
	}
	/**
	* @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	*/
	function serializeAMimeType$1(mimeType) {
		assert$10(mimeType !== "failure");
		const { parameters, essence } = mimeType;
		let serialization = essence;
		for (let [name, value] of parameters.entries()) {
			serialization += ";";
			serialization += name;
			serialization += "=";
			if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
				value = value.replace(/(\\|")/g, "\\$1");
				value = "\"" + value;
				value += "\"";
			}
			serialization += value;
		}
		return serialization;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {number} char
	*/
	function isHTTPWhiteSpace(char) {
		return char === 13 || char === 10 || char === 9 || char === 32;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} str
	* @param {boolean} [leading=true]
	* @param {boolean} [trailing=true]
	*/
	function removeHTTPWhitespace(str, leading = true, trailing = true) {
		return removeChars(str, leading, trailing, isHTTPWhiteSpace);
	}
	/**
	* @see https://infra.spec.whatwg.org/#ascii-whitespace
	* @param {number} char
	*/
	function isASCIIWhitespace(char) {
		return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
	}
	/**
	* @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	* @param {string} str
	* @param {boolean} [leading=true]
	* @param {boolean} [trailing=true]
	*/
	function removeASCIIWhitespace(str, leading = true, trailing = true) {
		return removeChars(str, leading, trailing, isASCIIWhitespace);
	}
	/**
	* @param {string} str
	* @param {boolean} leading
	* @param {boolean} trailing
	* @param {(charCode: number) => boolean} predicate
	* @returns
	*/
	function removeChars(str, leading, trailing, predicate) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
		if (trailing) while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
		return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
	}
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-decode
	* @param {Uint8Array} input
	* @returns {string}
	*/
	function isomorphicDecode(input) {
		const length = input.length;
		if (65535 > length) return String.fromCharCode.apply(null, input);
		let result = "";
		let i = 0;
		let addition = 65535;
		while (i < length) {
			if (i + addition > length) addition = length - i;
			result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
		}
		return result;
	}
	/**
	* @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type
	* @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType
	*/
	function minimizeSupportedMimeType(mimeType) {
		switch (mimeType.essence) {
			case "application/ecmascript":
			case "application/javascript":
			case "application/x-ecmascript":
			case "application/x-javascript":
			case "text/ecmascript":
			case "text/javascript":
			case "text/javascript1.0":
			case "text/javascript1.1":
			case "text/javascript1.2":
			case "text/javascript1.3":
			case "text/javascript1.4":
			case "text/javascript1.5":
			case "text/jscript":
			case "text/livescript":
			case "text/x-ecmascript":
			case "text/x-javascript": return "text/javascript";
			case "application/json":
			case "text/json": return "application/json";
			case "image/svg+xml": return "image/svg+xml";
			case "text/xml":
			case "application/xml": return "application/xml";
		}
		if (mimeType.subtype.endsWith("+json")) return "application/json";
		if (mimeType.subtype.endsWith("+xml")) return "application/xml";
		return "";
	}
	dataUrl = {
		dataURLProcessor,
		URLSerializer,
		collectASequenceOfCodePoints,
		collectASequenceOfCodePointsFast,
		stringPercentDecode,
		parseMIMEType: parseMIMEType$1,
		collectAnHTTPQuotedString,
		serializeAMimeType: serializeAMimeType$1,
		removeChars,
		removeHTTPWhitespace,
		minimizeSupportedMimeType,
		HTTP_TOKEN_CODEPOINTS,
		isomorphicDecode
	};
	return dataUrl;
}
var webidl_1;
var hasRequiredWebidl;
function requireWebidl() {
	if (hasRequiredWebidl) return webidl_1;
	hasRequiredWebidl = 1;
	const { types, inspect } = require$$0$3;
	const { toUSVString: toUSVString$1 } = util$n;
	/** @type {import('../../../types/webidl').Webidl} */
	const webidl = {};
	webidl.converters = {};
	webidl.util = {};
	webidl.errors = {};
	webidl.errors.exception = function(message) {
		return new TypeError(`${message.header}: ${message.message}`);
	};
	webidl.errors.conversionFailed = function(context) {
		const plural = context.types.length === 1 ? "" : " one of";
		const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(", ")}.`;
		return webidl.errors.exception({
			header: context.prefix,
			message
		});
	};
	webidl.errors.invalidArgument = function(context) {
		return webidl.errors.exception({
			header: context.prefix,
			message: `"${context.value}" is an invalid ${context.type}.`
		});
	};
	webidl.brandCheck = function(V, I, opts) {
		if (opts?.strict !== false) {
			if (!(V instanceof I)) {
				const err = new TypeError("Illegal invocation");
				err.code = "ERR_INVALID_THIS";
				throw err;
			}
		} else if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {
			const err = new TypeError("Illegal invocation");
			err.code = "ERR_INVALID_THIS";
			throw err;
		}
	};
	webidl.argumentLengthCheck = function({ length }, min, ctx) {
		if (length < min) throw webidl.errors.exception({
			message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
			header: ctx
		});
	};
	webidl.illegalConstructor = function() {
		throw webidl.errors.exception({
			header: "TypeError",
			message: "Illegal constructor"
		});
	};
	webidl.util.Type = function(V) {
		switch (typeof V) {
			case "undefined": return "Undefined";
			case "boolean": return "Boolean";
			case "string": return "String";
			case "symbol": return "Symbol";
			case "number": return "Number";
			case "bigint": return "BigInt";
			case "function":
			case "object": {
				if (V === null) return "Null";
				return "Object";
			}
		}
	};
	webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
		let upperBound;
		let lowerBound;
		if (bitLength === 64) {
			upperBound = Math.pow(2, 53) - 1;
			if (signedness === "unsigned") lowerBound = 0;
else lowerBound = Math.pow(-2, 53) + 1;
		} else if (signedness === "unsigned") {
			lowerBound = 0;
			upperBound = Math.pow(2, bitLength) - 1;
		} else {
			lowerBound = Math.pow(-2, bitLength) - 1;
			upperBound = Math.pow(2, bitLength - 1) - 1;
		}
		let x = Number(V);
		if (x === 0) x = 0;
		if (opts?.enforceRange === true) {
			if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) throw webidl.errors.exception({
				header: "Integer conversion",
				message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
			});
			x = webidl.util.IntegerPart(x);
			if (x < lowerBound || x > upperBound) throw webidl.errors.exception({
				header: "Integer conversion",
				message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
			});
			return x;
		}
		if (!Number.isNaN(x) && opts?.clamp === true) {
			x = Math.min(Math.max(x, lowerBound), upperBound);
			if (Math.floor(x) % 2 === 0) x = Math.floor(x);
else x = Math.ceil(x);
			return x;
		}
		if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) return 0;
		x = webidl.util.IntegerPart(x);
		x = x % Math.pow(2, bitLength);
		if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) return x - Math.pow(2, bitLength);
		return x;
	};
	webidl.util.IntegerPart = function(n) {
		const r = Math.floor(Math.abs(n));
		if (n < 0) return -1 * r;
		return r;
	};
	webidl.util.Stringify = function(V) {
		const type = webidl.util.Type(V);
		switch (type) {
			case "Symbol": return `Symbol(${V.description})`;
			case "Object": return inspect(V);
			case "String": return `"${V}"`;
			default: return `${V}`;
		}
	};
	webidl.sequenceConverter = function(converter) {
		return (V, prefix, argument, Iterable) => {
			if (webidl.util.Type(V) !== "Object") throw webidl.errors.exception({
				header: prefix,
				message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
			});
			/** @type {Generator} */
			const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
			const seq = [];
			let index = 0;
			if (method === undefined || typeof method.next !== "function") throw webidl.errors.exception({
				header: prefix,
				message: `${argument} is not iterable.`
			});
			while (true) {
				const { done, value } = method.next();
				if (done) break;
				seq.push(converter(value, prefix, `${argument}[${index++}]`));
			}
			return seq;
		};
	};
	webidl.recordConverter = function(keyConverter, valueConverter) {
		return (O, prefix, argument) => {
			if (webidl.util.Type(O) !== "Object") throw webidl.errors.exception({
				header: prefix,
				message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
			});
			const result = {};
			if (!types.isProxy(O)) {
				const keys$1 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
				for (const key of keys$1) {
					const typedKey = keyConverter(key, prefix, argument);
					const typedValue = valueConverter(O[key], prefix, argument);
					result[typedKey] = typedValue;
				}
				return result;
			}
			const keys = Reflect.ownKeys(O);
			for (const key of keys) {
				const desc = Reflect.getOwnPropertyDescriptor(O, key);
				if (desc?.enumerable) {
					const typedKey = keyConverter(key, prefix, argument);
					const typedValue = valueConverter(O[key], prefix, argument);
					result[typedKey] = typedValue;
				}
			}
			return result;
		};
	};
	webidl.interfaceConverter = function(i) {
		return (V, prefix, argument, opts) => {
			if (opts?.strict !== false && !(V instanceof i)) throw webidl.errors.exception({
				header: prefix,
				message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
			});
			return V;
		};
	};
	webidl.dictionaryConverter = function(converters) {
		return (dictionary, prefix, argument) => {
			const type = webidl.util.Type(dictionary);
			const dict = {};
			if (type === "Null" || type === "Undefined") return dict;
else if (type !== "Object") throw webidl.errors.exception({
				header: prefix,
				message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
			});
			for (const options of converters) {
				const { key, defaultValue, required, converter } = options;
				if (required === true) {
					if (!Object.hasOwn(dictionary, key)) throw webidl.errors.exception({
						header: prefix,
						message: `Missing required key "${key}".`
					});
				}
				let value = dictionary[key];
				const hasDefault = Object.hasOwn(options, "defaultValue");
				if (hasDefault && value !== null) value ??= defaultValue();
				if (required || hasDefault || value !== undefined) {
					value = converter(value, prefix, `${argument}.${key}`);
					if (options.allowedValues && !options.allowedValues.includes(value)) throw webidl.errors.exception({
						header: prefix,
						message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
					});
					dict[key] = value;
				}
			}
			return dict;
		};
	};
	webidl.nullableConverter = function(converter) {
		return (V, prefix, argument) => {
			if (V === null) return V;
			return converter(V, prefix, argument);
		};
	};
	webidl.converters.DOMString = function(V, prefix, argument, opts) {
		if (V === null && opts?.legacyNullToEmptyString) return "";
		if (typeof V === "symbol") throw webidl.errors.exception({
			header: prefix,
			message: `${argument} is a symbol, which cannot be converted to a DOMString.`
		});
		return String(V);
	};
	webidl.converters.ByteString = function(V, prefix, argument) {
		const x = webidl.converters.DOMString(V, prefix, argument);
		for (let index = 0; index < x.length; index++) if (x.charCodeAt(index) > 255) throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
		return x;
	};
	webidl.converters.USVString = toUSVString$1;
	webidl.converters.boolean = function(V) {
		const x = Boolean(V);
		return x;
	};
	webidl.converters.any = function(V) {
		return V;
	};
	webidl.converters["long long"] = function(V, prefix, argument) {
		const x = webidl.util.ConvertToInt(V, 64, "signed", undefined, prefix, argument);
		return x;
	};
	webidl.converters["unsigned long long"] = function(V, prefix, argument) {
		const x = webidl.util.ConvertToInt(V, 64, "unsigned", undefined, prefix, argument);
		return x;
	};
	webidl.converters["unsigned long"] = function(V, prefix, argument) {
		const x = webidl.util.ConvertToInt(V, 32, "unsigned", undefined, prefix, argument);
		return x;
	};
	webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
		const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
		return x;
	};
	webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
		if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) throw webidl.errors.conversionFailed({
			prefix,
			argument: `${argument} ("${webidl.util.Stringify(V)}")`,
			types: ["ArrayBuffer"]
		});
		if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		if (V.resizable || V.growable) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "Received a resizable ArrayBuffer."
		});
		return V;
	};
	webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
		if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) throw webidl.errors.conversionFailed({
			prefix,
			argument: `${name} ("${webidl.util.Stringify(V)}")`,
			types: [T.name]
		});
		if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		if (V.buffer.resizable || V.buffer.growable) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "Received a resizable ArrayBuffer."
		});
		return V;
	};
	webidl.converters.DataView = function(V, prefix, name, opts) {
		if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) throw webidl.errors.exception({
			header: prefix,
			message: `${name} is not a DataView.`
		});
		if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		if (V.buffer.resizable || V.buffer.growable) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "Received a resizable ArrayBuffer."
		});
		return V;
	};
	webidl.converters.BufferSource = function(V, prefix, name, opts) {
		if (types.isAnyArrayBuffer(V)) return webidl.converters.ArrayBuffer(V, prefix, name, {
			...opts,
			allowShared: false
		});
		if (types.isTypedArray(V)) return webidl.converters.TypedArray(V, V.constructor, prefix, name, {
			...opts,
			allowShared: false
		});
		if (types.isDataView(V)) return webidl.converters.DataView(V, prefix, name, {
			...opts,
			allowShared: false
		});
		throw webidl.errors.conversionFailed({
			prefix,
			argument: `${name} ("${webidl.util.Stringify(V)}")`,
			types: ["BufferSource"]
		});
	};
	webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
	webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
	webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
	webidl_1 = { webidl };
	return webidl_1;
}
var util$k;
var hasRequiredUtil$5;
function requireUtil$5() {
	if (hasRequiredUtil$5) return util$k;
	hasRequiredUtil$5 = 1;
	const { Transform: Transform$1 } = stream;
	const zlib = require$$1;
	const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = requireConstants$2();
	const { getGlobalOrigin: getGlobalOrigin$1 } = requireGlobal();
	const { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType: parseMIMEType$1 } = requireDataUrl();
	const { performance: performance$1 } = require$$5;
	const { isBlobLike: isBlobLike$2, ReadableStreamFrom: ReadableStreamFrom$2, isValidHTTPToken: isValidHTTPToken$2, normalizedMethodRecordsBase: normalizedMethodRecordsBase$1 } = util$n;
	const assert$10 = require$$0;
	const { isUint8Array } = require$$8$1;
	const { webidl } = requireWebidl();
	let supportedHashes = [];
	/** @type {import('crypto')} */
	let crypto;
	try {
		crypto = __require("node:crypto");
		const possibleRelevantHashes = [
			"sha256",
			"sha384",
			"sha512"
		];
		supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	} catch {}
	function responseURL(response$1) {
		const urlList = response$1.urlList;
		const length = urlList.length;
		return length === 0 ? null : urlList[length - 1].toString();
	}
	function responseLocationURL(response$1, requestFragment) {
		if (!redirectStatusSet.has(response$1.status)) return null;
		let location = response$1.headersList.get("location", true);
		if (location !== null && isValidHeaderValue$2(location)) {
			if (!isValidEncodedURL(location)) location = normalizeBinaryStringToUtf8(location);
			location = new URL(location, responseURL(response$1));
		}
		if (location && !location.hash) location.hash = requestFragment;
		return location;
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2
	* @param {string} url
	* @returns {boolean}
	*/
	function isValidEncodedURL(url$1) {
		for (let i = 0; i < url$1.length; ++i) {
			const code = url$1.charCodeAt(i);
			if (code > 126 || code < 32) return false;
		}
		return true;
	}
	/**
	* If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.
	* Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.
	* @param {string} value
	* @returns {string}
	*/
	function normalizeBinaryStringToUtf8(value) {
		return Buffer.from(value, "binary").toString("utf8");
	}
	/** @returns {URL} */
	function requestCurrentURL(request$4) {
		return request$4.urlList[request$4.urlList.length - 1];
	}
	function requestBadPort(request$4) {
		const url$1 = requestCurrentURL(request$4);
		if (urlIsHttpHttpsScheme(url$1) && badPortsSet.has(url$1.port)) return "blocked";
		return "allowed";
	}
	function isErrorLike(object) {
		return object instanceof Error || object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException";
	}
	function isValidReasonPhrase(statusText) {
		for (let i = 0; i < statusText.length; ++i) {
			const c = statusText.charCodeAt(i);
			if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) return false;
		}
		return true;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-name
	* @param {string} potentialValue
	*/
	const isValidHeaderName = isValidHTTPToken$2;
	/**
	* @see https://fetch.spec.whatwg.org/#header-value
	* @param {string} potentialValue
	*/
	function isValidHeaderValue$2(potentialValue) {
		return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
	}
	function setRequestReferrerPolicyOnRedirect(request$4, actualResponse) {
		const { headersList } = actualResponse;
		const policyHeader = (headersList.get("referrer-policy", true) ?? "").split(",");
		let policy = "";
		if (policyHeader.length > 0) for (let i = policyHeader.length; i !== 0; i--) {
			const token = policyHeader[i - 1].trim();
			if (referrerPolicyTokens.has(token)) {
				policy = token;
				break;
			}
		}
		if (policy !== "") request$4.referrerPolicy = policy;
	}
	function crossOriginResourcePolicyCheck() {
		return "allowed";
	}
	function corsCheck() {
		return "success";
	}
	function TAOCheck() {
		return "success";
	}
	function appendFetchMetadata(httpRequest) {
		let header = null;
		header = httpRequest.mode;
		httpRequest.headersList.set("sec-fetch-mode", header, true);
	}
	function appendRequestOriginHeader(request$4) {
		let serializedOrigin = request$4.origin;
		if (serializedOrigin === "client" || serializedOrigin === undefined) return;
		if (request$4.responseTainting === "cors" || request$4.mode === "websocket") request$4.headersList.append("origin", serializedOrigin, true);
else if (request$4.method !== "GET" && request$4.method !== "HEAD") {
			switch (request$4.referrerPolicy) {
				case "no-referrer":
					serializedOrigin = null;
					break;
				case "no-referrer-when-downgrade":
				case "strict-origin":
				case "strict-origin-when-cross-origin":
					if (request$4.origin && urlHasHttpsScheme(request$4.origin) && !urlHasHttpsScheme(requestCurrentURL(request$4))) serializedOrigin = null;
					break;
				case "same-origin":
					if (!sameOrigin(request$4, requestCurrentURL(request$4))) serializedOrigin = null;
					break;
			}
			request$4.headersList.append("origin", serializedOrigin, true);
		}
	}
	function coarsenTime(timestamp, crossOriginIsolatedCapability) {
		return timestamp;
	}
	function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
		if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) return {
			domainLookupStartTime: defaultStartTime,
			domainLookupEndTime: defaultStartTime,
			connectionStartTime: defaultStartTime,
			connectionEndTime: defaultStartTime,
			secureConnectionStartTime: defaultStartTime,
			ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
		};
		return {
			domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime),
			domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime),
			connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime),
			connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime),
			secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime),
			ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
		};
	}
	function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
		return coarsenTime(performance$1.now());
	}
	function createOpaqueTimingInfo(timingInfo) {
		return {
			startTime: timingInfo.startTime ?? 0,
			redirectStartTime: 0,
			redirectEndTime: 0,
			postRedirectStartTime: timingInfo.startTime ?? 0,
			finalServiceWorkerStartTime: 0,
			finalNetworkResponseStartTime: 0,
			finalNetworkRequestStartTime: 0,
			endTime: 0,
			encodedBodySize: 0,
			decodedBodySize: 0,
			finalConnectionTimingInfo: null
		};
	}
	function makePolicyContainer() {
		return { referrerPolicy: "strict-origin-when-cross-origin" };
	}
	function clonePolicyContainer(policyContainer) {
		return { referrerPolicy: policyContainer.referrerPolicy };
	}
	function determineRequestsReferrer(request$4) {
		const policy = request$4.referrerPolicy;
		assert$10(policy);
		let referrerSource = null;
		if (request$4.referrer === "client") {
			const globalOrigin = getGlobalOrigin$1();
			if (!globalOrigin || globalOrigin.origin === "null") return "no-referrer";
			referrerSource = new URL(globalOrigin);
		} else if (request$4.referrer instanceof URL) referrerSource = request$4.referrer;
		let referrerURL = stripURLForReferrer(referrerSource);
		const referrerOrigin = stripURLForReferrer(referrerSource, true);
		if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
		const areSameOrigin = sameOrigin(request$4, referrerURL);
		const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request$4.url);
		switch (policy) {
			case "origin": return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
			case "unsafe-url": return referrerURL;
			case "same-origin": return areSameOrigin ? referrerOrigin : "no-referrer";
			case "origin-when-cross-origin": return areSameOrigin ? referrerURL : referrerOrigin;
			case "strict-origin-when-cross-origin": {
				const currentURL = requestCurrentURL(request$4);
				if (sameOrigin(referrerURL, currentURL)) return referrerURL;
				if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return "no-referrer";
				return referrerOrigin;
			}
			case "strict-origin":
			case "no-referrer-when-downgrade":
			default: return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	* @param {URL} url
	* @param {boolean|undefined} originOnly
	*/
	function stripURLForReferrer(url$1, originOnly) {
		assert$10(url$1 instanceof URL);
		url$1 = new URL(url$1);
		if (url$1.protocol === "file:" || url$1.protocol === "about:" || url$1.protocol === "blank:") return "no-referrer";
		url$1.username = "";
		url$1.password = "";
		url$1.hash = "";
		if (originOnly) {
			url$1.pathname = "";
			url$1.search = "";
		}
		return url$1;
	}
	function isURLPotentiallyTrustworthy(url$1) {
		if (!(url$1 instanceof URL)) return false;
		if (url$1.href === "about:blank" || url$1.href === "about:srcdoc") return true;
		if (url$1.protocol === "data:") return true;
		if (url$1.protocol === "file:") return true;
		return isOriginPotentiallyTrustworthy(url$1.origin);
		function isOriginPotentiallyTrustworthy(origin) {
			if (origin == null || origin === "null") return false;
			const originAsURL = new URL(origin);
			if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") return true;
			if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost")) return true;
			return false;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	* @param {Uint8Array} bytes
	* @param {string} metadataList
	*/
	function bytesMatch(bytes, metadataList) {
		if (crypto === undefined) return true;
		const parsedMetadata = parseMetadata(metadataList);
		if (parsedMetadata === "no metadata") return true;
		if (parsedMetadata.length === 0) return true;
		const strongest = getStrongestMetadata(parsedMetadata);
		const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
		for (const item of metadata) {
			const algorithm = item.algo;
			const expectedValue = item.hash;
			let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
			if (actualValue[actualValue.length - 1] === "=") if (actualValue[actualValue.length - 2] === "=") actualValue = actualValue.slice(0, -2);
else actualValue = actualValue.slice(0, -1);
			if (compareBase64Mixed(actualValue, expectedValue)) return true;
		}
		return false;
	}
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	* @param {string} metadata
	*/
	function parseMetadata(metadata) {
		/** @type {{ algo: string, hash: string }[]} */
		const result = [];
		let empty = true;
		for (const token of metadata.split(" ")) {
			empty = false;
			const parsedToken = parseHashWithOptions.exec(token);
			if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) continue;
			const algorithm = parsedToken.groups.algo.toLowerCase();
			if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
		}
		if (empty === true) return "no metadata";
		return result;
	}
	/**
	* @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	*/
	function getStrongestMetadata(metadataList) {
		let algorithm = metadataList[0].algo;
		if (algorithm[3] === "5") return algorithm;
		for (let i = 1; i < metadataList.length; ++i) {
			const metadata = metadataList[i];
			if (metadata.algo[3] === "5") {
				algorithm = "sha512";
				break;
			} else if (algorithm[3] === "3") continue;
else if (metadata.algo[3] === "3") algorithm = "sha384";
		}
		return algorithm;
	}
	function filterMetadataListByAlgorithm(metadataList, algorithm) {
		if (metadataList.length === 1) return metadataList;
		let pos = 0;
		for (let i = 0; i < metadataList.length; ++i) if (metadataList[i].algo === algorithm) metadataList[pos++] = metadataList[i];
		metadataList.length = pos;
		return metadataList;
	}
	/**
	* Compares two base64 strings, allowing for base64url
	* in the second string.
	*
	* @param {string} actualValue always base64
	* @param {string} expectedValue base64 or base64url
	* @returns {boolean}
	*/
	function compareBase64Mixed(actualValue, expectedValue) {
		if (actualValue.length !== expectedValue.length) return false;
		for (let i = 0; i < actualValue.length; ++i) if (actualValue[i] !== expectedValue[i]) {
			if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") continue;
			return false;
		}
		return true;
	}
	function tryUpgradeRequestToAPotentiallyTrustworthyURL(request$4) {}
	/**
	* @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	* @param {URL} A
	* @param {URL} B
	*/
	function sameOrigin(A, B) {
		if (A.origin === B.origin && A.origin === "null") return true;
		if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) return true;
		return false;
	}
	function createDeferredPromise() {
		let res;
		let rej;
		const promise = new Promise((resolve, reject) => {
			res = resolve;
			rej = reject;
		});
		return {
			promise,
			resolve: res,
			reject: rej
		};
	}
	function isAborted(fetchParams) {
		return fetchParams.controller.state === "aborted";
	}
	function isCancelled(fetchParams) {
		return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-method-normalize
	* @param {string} method
	*/
	function normalizeMethod(method) {
		return normalizedMethodRecordsBase$1[method.toLowerCase()] ?? method;
	}
	function serializeJavascriptValueToJSONString(value) {
		const result = JSON.stringify(value);
		if (result === undefined) throw new TypeError("Value is not JSON serializable");
		assert$10(typeof result === "string");
		return result;
	}
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
	/**
	* @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	* @param {string} name name of the instance
	* @param {symbol} kInternalIterator
	* @param {string | number} [keyIndex]
	* @param {string | number} [valueIndex]
	*/
	function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
		class FastIterableIterator {
			/** @type {any} */
			#target;
			/** @type {'key' | 'value' | 'key+value'} */
			#kind;
			/** @type {number} */
			#index;
			/**
			* @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
			* @param {unknown} target
			* @param {'key' | 'value' | 'key+value'} kind
			*/
			constructor(target, kind) {
				this.#target = target;
				this.#kind = kind;
				this.#index = 0;
			}
			next() {
				if (typeof this !== "object" || this === null || !(#target in this)) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
				const index = this.#index;
				const values = this.#target[kInternalIterator];
				const len = values.length;
				if (index >= len) return {
					value: undefined,
					done: true
				};
				const { [keyIndex]: key, [valueIndex]: value } = values[index];
				this.#index = index + 1;
				let result;
				switch (this.#kind) {
					case "key":
						result = key;
						break;
					case "value":
						result = value;
						break;
					case "key+value":
						result = [key, value];
						break;
				}
				return {
					value: result,
					done: false
				};
			}
		}
		delete FastIterableIterator.prototype.constructor;
		Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
		Object.defineProperties(FastIterableIterator.prototype, {
			[Symbol.toStringTag]: {
				writable: false,
				enumerable: false,
				configurable: true,
				value: `${name} Iterator`
			},
			next: {
				writable: true,
				enumerable: true,
				configurable: true
			}
		});
		/**
		* @param {unknown} target
		* @param {'key' | 'value' | 'key+value'} kind
		* @returns {IterableIterator<any>}
		*/
		return function(target, kind) {
			return new FastIterableIterator(target, kind);
		};
	}
	/**
	* @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	* @param {string} name name of the instance
	* @param {any} object class
	* @param {symbol} kInternalIterator
	* @param {string | number} [keyIndex]
	* @param {string | number} [valueIndex]
	*/
	function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
		const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
		const properties = {
			keys: {
				writable: true,
				enumerable: true,
				configurable: true,
				value: function keys() {
					webidl.brandCheck(this, object);
					return makeIterator(this, "key");
				}
			},
			values: {
				writable: true,
				enumerable: true,
				configurable: true,
				value: function values() {
					webidl.brandCheck(this, object);
					return makeIterator(this, "value");
				}
			},
			entries: {
				writable: true,
				enumerable: true,
				configurable: true,
				value: function entries() {
					webidl.brandCheck(this, object);
					return makeIterator(this, "key+value");
				}
			},
			forEach: {
				writable: true,
				enumerable: true,
				configurable: true,
				value: function forEach(callbackfn, thisArg = globalThis) {
					webidl.brandCheck(this, object);
					webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
					if (typeof callbackfn !== "function") throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);
					for (const { 0: key, 1: value } of makeIterator(this, "key+value")) callbackfn.call(thisArg, value, key, this);
				}
			}
		};
		return Object.defineProperties(object.prototype, {
			...properties,
			[Symbol.iterator]: {
				writable: true,
				enumerable: false,
				configurable: true,
				value: properties.entries.value
			}
		});
	}
	/**
	* @see https://fetch.spec.whatwg.org/#body-fully-read
	*/
	async function fullyReadBody(body$1, processBody, processBodyError) {
		const successSteps = processBody;
		const errorSteps = processBodyError;
		let reader;
		try {
			reader = body$1.stream.getReader();
		} catch (e) {
			errorSteps(e);
			return;
		}
		try {
			successSteps(await readAllBytes(reader));
		} catch (e) {
			errorSteps(e);
		}
	}
	function isReadableStreamLike(stream$4) {
		return stream$4 instanceof ReadableStream || stream$4[Symbol.toStringTag] === "ReadableStream" && typeof stream$4.tee === "function";
	}
	/**
	* @param {ReadableStreamController<Uint8Array>} controller
	*/
	function readableStreamClose(controller) {
		try {
			controller.close();
			controller.byobRequest?.respond(0);
		} catch (err) {
			if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) throw err;
		}
	}
	const invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-encode
	* @param {string} input
	*/
	function isomorphicEncode(input) {
		assert$10(!invalidIsomorphicEncodeValueRegex.test(input));
		return input;
	}
	/**
	* @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	* @see https://streams.spec.whatwg.org/#read-loop
	* @param {ReadableStreamDefaultReader} reader
	*/
	async function readAllBytes(reader) {
		const bytes = [];
		let byteLength = 0;
		while (true) {
			const { done, value: chunk } = await reader.read();
			if (done) return Buffer.concat(bytes, byteLength);
			if (!isUint8Array(chunk)) throw new TypeError("Received non-Uint8Array chunk");
			bytes.push(chunk);
			byteLength += chunk.length;
		}
	}
	/**
	* @see https://fetch.spec.whatwg.org/#is-local
	* @param {URL} url
	*/
	function urlIsLocal(url$1) {
		assert$10("protocol" in url$1);
		const protocol = url$1.protocol;
		return protocol === "about:" || protocol === "blob:" || protocol === "data:";
	}
	/**
	* @param {string|URL} url
	* @returns {boolean}
	*/
	function urlHasHttpsScheme(url$1) {
		return typeof url$1 === "string" && url$1[5] === ":" && url$1[0] === "h" && url$1[1] === "t" && url$1[2] === "t" && url$1[3] === "p" && url$1[4] === "s" || url$1.protocol === "https:";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-scheme
	* @param {URL} url
	*/
	function urlIsHttpHttpsScheme(url$1) {
		assert$10("protocol" in url$1);
		const protocol = url$1.protocol;
		return protocol === "http:" || protocol === "https:";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#simple-range-header-value
	* @param {string} value
	* @param {boolean} allowWhitespace
	*/
	function simpleRangeHeaderValue(value, allowWhitespace) {
		const data = value;
		if (!data.startsWith("bytes")) return "failure";
		const position = { position: 5 };
		if (allowWhitespace) collectASequenceOfCodePoints((char) => char === "	" || char === " ", data, position);
		if (data.charCodeAt(position.position) !== 61) return "failure";
		position.position++;
		if (allowWhitespace) collectASequenceOfCodePoints((char) => char === "	" || char === " ", data, position);
		const rangeStart = collectASequenceOfCodePoints((char) => {
			const code = char.charCodeAt(0);
			return code >= 48 && code <= 57;
		}, data, position);
		const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
		if (allowWhitespace) collectASequenceOfCodePoints((char) => char === "	" || char === " ", data, position);
		if (data.charCodeAt(position.position) !== 45) return "failure";
		position.position++;
		if (allowWhitespace) collectASequenceOfCodePoints((char) => char === "	" || char === " ", data, position);
		const rangeEnd = collectASequenceOfCodePoints((char) => {
			const code = char.charCodeAt(0);
			return code >= 48 && code <= 57;
		}, data, position);
		const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
		if (position.position < data.length) return "failure";
		if (rangeEndValue === null && rangeStartValue === null) return "failure";
		if (rangeStartValue > rangeEndValue) return "failure";
		return {
			rangeStartValue,
			rangeEndValue
		};
	}
	/**
	* @see https://fetch.spec.whatwg.org/#build-a-content-range
	* @param {number} rangeStart
	* @param {number} rangeEnd
	* @param {number} fullLength
	*/
	function buildContentRange(rangeStart, rangeEnd, fullLength) {
		let contentRange = "bytes ";
		contentRange += isomorphicEncode(`${rangeStart}`);
		contentRange += "-";
		contentRange += isomorphicEncode(`${rangeEnd}`);
		contentRange += "/";
		contentRange += isomorphicEncode(`${fullLength}`);
		return contentRange;
	}
	class InflateStream extends Transform$1 {
		_transform(chunk, encoding$1, callback) {
			if (!this._inflateStream) {
				if (chunk.length === 0) {
					callback();
					return;
				}
				this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate() : zlib.createInflateRaw();
				this._inflateStream.on("data", this.push.bind(this));
				this._inflateStream.on("end", () => this.push(null));
				this._inflateStream.on("error", (err) => this.destroy(err));
			}
			this._inflateStream.write(chunk, encoding$1, callback);
		}
		_final(callback) {
			if (this._inflateStream) {
				this._inflateStream.end();
				this._inflateStream = null;
			}
			callback();
		}
	}
	function createInflate() {
		return new InflateStream();
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type
	* @param {import('./headers').HeadersList} headers
	*/
	function extractMimeType(headers$1) {
		let charset = null;
		let essence = null;
		let mimeType = null;
		const values = getDecodeSplit("content-type", headers$1);
		if (values === null) return "failure";
		for (const value of values) {
			const temporaryMimeType = parseMIMEType$1(value);
			if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") continue;
			mimeType = temporaryMimeType;
			if (mimeType.essence !== essence) {
				charset = null;
				if (mimeType.parameters.has("charset")) charset = mimeType.parameters.get("charset");
				essence = mimeType.essence;
			} else if (!mimeType.parameters.has("charset") && charset !== null) mimeType.parameters.set("charset", charset);
		}
		if (mimeType == null) return "failure";
		return mimeType;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split
	* @param {string|null} value
	*/
	function gettingDecodingSplitting(value) {
		const input = value;
		const position = { position: 0 };
		const values = [];
		let temporaryValue = "";
		while (position.position < input.length) {
			temporaryValue += collectASequenceOfCodePoints((char) => char !== "\"" && char !== ",", input, position);
			if (position.position < input.length) if (input.charCodeAt(position.position) === 34) {
				temporaryValue += collectAnHTTPQuotedString(input, position);
				if (position.position < input.length) continue;
			} else {
				assert$10(input.charCodeAt(position.position) === 44);
				position.position++;
			}
			temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
			values.push(temporaryValue);
			temporaryValue = "";
		}
		return values;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split
	* @param {string} name lowercase header name
	* @param {import('./headers').HeadersList} list
	*/
	function getDecodeSplit(name, list) {
		const value = list.get(name, true);
		if (value === null) return null;
		return gettingDecodingSplitting(value);
	}
	const textDecoder = new TextDecoder();
	/**
	* @see https://encoding.spec.whatwg.org/#utf-8-decode
	* @param {Buffer} buffer
	*/
	function utf8DecodeBytes(buffer) {
		if (buffer.length === 0) return "";
		if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) buffer = buffer.subarray(3);
		const output = textDecoder.decode(buffer);
		return output;
	}
	class EnvironmentSettingsObjectBase {
		get baseUrl() {
			return getGlobalOrigin$1();
		}
		get origin() {
			return this.baseUrl?.origin;
		}
		policyContainer = makePolicyContainer();
	}
	class EnvironmentSettingsObject {
		settingsObject = new EnvironmentSettingsObjectBase();
	}
	const environmentSettingsObject = new EnvironmentSettingsObject();
	util$k = {
		isAborted,
		isCancelled,
		isValidEncodedURL,
		createDeferredPromise,
		ReadableStreamFrom: ReadableStreamFrom$2,
		tryUpgradeRequestToAPotentiallyTrustworthyURL,
		clampAndCoarsenConnectionTimingInfo,
		coarsenedSharedCurrentTime,
		determineRequestsReferrer,
		makePolicyContainer,
		clonePolicyContainer,
		appendFetchMetadata,
		appendRequestOriginHeader,
		TAOCheck,
		corsCheck,
		crossOriginResourcePolicyCheck,
		createOpaqueTimingInfo,
		setRequestReferrerPolicyOnRedirect,
		isValidHTTPToken: isValidHTTPToken$2,
		requestBadPort,
		requestCurrentURL,
		responseURL,
		responseLocationURL,
		isBlobLike: isBlobLike$2,
		isURLPotentiallyTrustworthy,
		isValidReasonPhrase,
		sameOrigin,
		normalizeMethod,
		serializeJavascriptValueToJSONString,
		iteratorMixin,
		createIterator,
		isValidHeaderName,
		isValidHeaderValue: isValidHeaderValue$2,
		isErrorLike,
		fullyReadBody,
		bytesMatch,
		isReadableStreamLike,
		readableStreamClose,
		isomorphicEncode,
		urlIsLocal,
		urlHasHttpsScheme,
		urlIsHttpHttpsScheme,
		readAllBytes,
		simpleRangeHeaderValue,
		buildContentRange,
		parseMetadata,
		createInflate,
		extractMimeType,
		getDecodeSplit,
		utf8DecodeBytes,
		environmentSettingsObject
	};
	return util$k;
}
var symbols$3;
var hasRequiredSymbols$3;
function requireSymbols$3() {
	if (hasRequiredSymbols$3) return symbols$3;
	hasRequiredSymbols$3 = 1;
	symbols$3 = {
		kUrl: Symbol("url"),
		kHeaders: Symbol("headers"),
		kSignal: Symbol("signal"),
		kState: Symbol("state"),
		kDispatcher: Symbol("dispatcher")
	};
	return symbols$3;
}
var file;
var hasRequiredFile;
function requireFile() {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;
	const { Blob: Blob$2, File: File$1 } = require$$0$2;
	const { kState } = requireSymbols$3();
	const { webidl } = requireWebidl();
	class FileLike {
		constructor(blobLike, fileName, options = {}) {
			const n = fileName;
			const t = options.type;
			const d = options.lastModified ?? Date.now();
			this[kState] = {
				blobLike,
				name: n,
				type: t,
				lastModified: d
			};
		}
		stream(...args) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.stream(...args);
		}
		arrayBuffer(...args) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.arrayBuffer(...args);
		}
		slice(...args) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.slice(...args);
		}
		text(...args) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.text(...args);
		}
		get size() {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.size;
		}
		get type() {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.type;
		}
		get name() {
			webidl.brandCheck(this, FileLike);
			return this[kState].name;
		}
		get lastModified() {
			webidl.brandCheck(this, FileLike);
			return this[kState].lastModified;
		}
		get [Symbol.toStringTag]() {
			return "File";
		}
	}
	webidl.converters.Blob = webidl.interfaceConverter(Blob$2);
	function isFileLike(object) {
		return object instanceof File$1 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
	}
	file = {
		FileLike,
		isFileLike
	};
	return file;
}
var formdata;
var hasRequiredFormdata;
function requireFormdata() {
	if (hasRequiredFormdata) return formdata;
	hasRequiredFormdata = 1;
	const { isBlobLike: isBlobLike$2, iteratorMixin } = requireUtil$5();
	const { kState } = requireSymbols$3();
	const { kEnumerableProperty: kEnumerableProperty$1 } = util$n;
	const { FileLike, isFileLike } = requireFile();
	const { webidl } = requireWebidl();
	const { File: NativeFile } = require$$0$2;
	const nodeUtil$1 = require$$0$3;
	/** @type {globalThis['File']} */
	const File$1 = globalThis.File ?? NativeFile;
	class FormData$1 {
		constructor(form) {
			if (form !== undefined) throw webidl.errors.conversionFailed({
				prefix: "FormData constructor",
				argument: "Argument 1",
				types: ["undefined"]
			});
			this[kState] = [];
		}
		append(name, value, filename = undefined) {
			webidl.brandCheck(this, FormData$1);
			const prefix = "FormData.append";
			webidl.argumentLengthCheck(arguments, 2, prefix);
			if (arguments.length === 3 && !isBlobLike$2(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl.converters.USVString(name, prefix, "name");
			value = isBlobLike$2(value) ? webidl.converters.Blob(value, prefix, "value", { strict: false }) : webidl.converters.USVString(value, prefix, "value");
			filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "filename") : undefined;
			const entry = makeEntry(name, value, filename);
			this[kState].push(entry);
		}
		delete(name) {
			webidl.brandCheck(this, FormData$1);
			const prefix = "FormData.delete";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			name = webidl.converters.USVString(name, prefix, "name");
			this[kState] = this[kState].filter((entry) => entry.name !== name);
		}
		get(name) {
			webidl.brandCheck(this, FormData$1);
			const prefix = "FormData.get";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			name = webidl.converters.USVString(name, prefix, "name");
			const idx = this[kState].findIndex((entry) => entry.name === name);
			if (idx === -1) return null;
			return this[kState][idx].value;
		}
		getAll(name) {
			webidl.brandCheck(this, FormData$1);
			const prefix = "FormData.getAll";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			name = webidl.converters.USVString(name, prefix, "name");
			return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
		}
		has(name) {
			webidl.brandCheck(this, FormData$1);
			const prefix = "FormData.has";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			name = webidl.converters.USVString(name, prefix, "name");
			return this[kState].findIndex((entry) => entry.name === name) !== -1;
		}
		set(name, value, filename = undefined) {
			webidl.brandCheck(this, FormData$1);
			const prefix = "FormData.set";
			webidl.argumentLengthCheck(arguments, 2, prefix);
			if (arguments.length === 3 && !isBlobLike$2(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl.converters.USVString(name, prefix, "name");
			value = isBlobLike$2(value) ? webidl.converters.Blob(value, prefix, "name", { strict: false }) : webidl.converters.USVString(value, prefix, "name");
			filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "name") : undefined;
			const entry = makeEntry(name, value, filename);
			const idx = this[kState].findIndex((entry$1) => entry$1.name === name);
			if (idx !== -1) this[kState] = [
				...this[kState].slice(0, idx),
				entry,
				...this[kState].slice(idx + 1).filter((entry$1) => entry$1.name !== name)
			];
else this[kState].push(entry);
		}
		[nodeUtil$1.inspect.custom](depth, options) {
			const state = this[kState].reduce((a, b) => {
				if (a[b.name]) if (Array.isArray(a[b.name])) a[b.name].push(b.value);
else a[b.name] = [a[b.name], b.value];
else a[b.name] = b.value;
				return a;
			}, { __proto__: null });
			options.depth ??= depth;
			options.colors ??= true;
			const output = nodeUtil$1.formatWithOptions(options, state);
			return `FormData ${output.slice(output.indexOf("]") + 2)}`;
		}
	}
	iteratorMixin("FormData", FormData$1, kState, "name", "value");
	Object.defineProperties(FormData$1.prototype, {
		append: kEnumerableProperty$1,
		delete: kEnumerableProperty$1,
		get: kEnumerableProperty$1,
		getAll: kEnumerableProperty$1,
		has: kEnumerableProperty$1,
		set: kEnumerableProperty$1,
		[Symbol.toStringTag]: {
			value: "FormData",
			configurable: true
		}
	});
	/**
	* @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	* @param {string} name
	* @param {string|Blob} value
	* @param {?string} filename
	* @returns
	*/
	function makeEntry(name, value, filename) {
		if (typeof value === "string");
else {
			if (!isFileLike(value)) value = value instanceof Blob ? new File$1([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
			if (filename !== undefined) {
				/** @type {FilePropertyBag} */
				const options = {
					type: value.type,
					lastModified: value.lastModified
				};
				value = value instanceof NativeFile ? new File$1([value], filename, options) : new FileLike(value, filename, options);
			}
		}
		return {
			name,
			value
		};
	}
	formdata = {
		FormData: FormData$1,
		makeEntry
	};
	return formdata;
}
var formdataParser;
var hasRequiredFormdataParser;
function requireFormdataParser() {
	if (hasRequiredFormdataParser) return formdataParser;
	hasRequiredFormdataParser = 1;
	const { isUSVString: isUSVString$1, bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName$1 } = util$n;
	const { utf8DecodeBytes } = requireUtil$5();
	const { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = requireDataUrl();
	const { isFileLike } = requireFile();
	const { makeEntry } = requireFormdata();
	const assert$10 = require$$0;
	const { File: NodeFile } = require$$0$2;
	const File$1 = globalThis.File ?? NodeFile;
	const formDataNameBuffer = Buffer.from("form-data; name=\"");
	const filenameBuffer = Buffer.from("; filename");
	const dd = Buffer.from("--");
	const ddcrlf = Buffer.from("--\r\n");
	/**
	* @param {string} chars
	*/
	function isAsciiString(chars) {
		for (let i = 0; i < chars.length; ++i) if ((chars.charCodeAt(i) & -128) !== 0) return false;
		return true;
	}
	/**
	* @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary
	* @param {string} boundary
	*/
	function validateBoundary(boundary) {
		const length = boundary.length;
		if (length < 27 || length > 70) return false;
		for (let i = 0; i < length; ++i) {
			const cp = boundary.charCodeAt(i);
			if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) return false;
		}
		return true;
	}
	/**
	* @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser
	* @param {Buffer} input
	* @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType
	*/
	function multipartFormDataParser(input, mimeType) {
		assert$10(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
		const boundaryString = mimeType.parameters.get("boundary");
		if (boundaryString === undefined) return "failure";
		const boundary = Buffer.from(`--${boundaryString}`, "utf8");
		const entryList = [];
		const position = { position: 0 };
		if (input[0] === 13 && input[1] === 10) position.position += 2;
		while (true) {
			if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) position.position += boundary.length;
else return "failure";
			if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) return entryList;
			if (input[position.position] !== 13 || input[position.position + 1] !== 10) return "failure";
			position.position += 2;
			const result = parseMultipartFormDataHeaders(input, position);
			if (result === "failure") return "failure";
			let { name, filename, contentType, encoding: encoding$1 } = result;
			position.position += 2;
			let body$1;
			{
				const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
				if (boundaryIndex === -1) return "failure";
				body$1 = input.subarray(position.position, boundaryIndex - 4);
				position.position += body$1.length;
				if (encoding$1 === "base64") body$1 = Buffer.from(body$1.toString(), "base64");
			}
			if (input[position.position] !== 13 || input[position.position + 1] !== 10) return "failure";
else position.position += 2;
			let value;
			if (filename !== null) {
				contentType ??= "text/plain";
				if (!isAsciiString(contentType)) contentType = "";
				value = new File$1([body$1], filename, { type: contentType });
			} else value = utf8DecodeBytes(Buffer.from(body$1));
			assert$10(isUSVString$1(name));
			assert$10(typeof value === "string" && isUSVString$1(value) || isFileLike(value));
			entryList.push(makeEntry(name, value, filename));
		}
	}
	/**
	* @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers
	* @param {Buffer} input
	* @param {{ position: number }} position
	*/
	function parseMultipartFormDataHeaders(input, position) {
		let name = null;
		let filename = null;
		let contentType = null;
		let encoding$1 = null;
		while (true) {
			if (input[position.position] === 13 && input[position.position + 1] === 10) {
				if (name === null) return "failure";
				return {
					name,
					filename,
					contentType,
					encoding: encoding$1
				};
			}
			let headerName = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 58, input, position);
			headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
			if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) return "failure";
			if (input[position.position] !== 58) return "failure";
			position.position++;
			collectASequenceOfBytes((char) => char === 32 || char === 9, input, position);
			switch (bufferToLowerCasedHeaderName$1(headerName)) {
				case "content-disposition": {
					name = filename = null;
					if (!bufferStartsWith(input, formDataNameBuffer, position)) return "failure";
					position.position += 17;
					name = parseMultipartFormDataName(input, position);
					if (name === null) return "failure";
					if (bufferStartsWith(input, filenameBuffer, position)) {
						let check = position.position + filenameBuffer.length;
						if (input[check] === 42) {
							position.position += 1;
							check += 1;
						}
						if (input[check] !== 61 || input[check + 1] !== 34) return "failure";
						position.position += 12;
						filename = parseMultipartFormDataName(input, position);
						if (filename === null) return "failure";
					}
					break;
				}
				case "content-type": {
					let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
					headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
					contentType = isomorphicDecode(headerValue);
					break;
				}
				case "content-transfer-encoding": {
					let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
					headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
					encoding$1 = isomorphicDecode(headerValue);
					break;
				}
				default: collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
			}
			if (input[position.position] !== 13 && input[position.position + 1] !== 10) return "failure";
else position.position += 2;
		}
	}
	/**
	* @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name
	* @param {Buffer} input
	* @param {{ position: number }} position
	*/
	function parseMultipartFormDataName(input, position) {
		assert$10(input[position.position - 1] === 34);
		/** @type {string | Buffer} */
		let name = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 34, input, position);
		if (input[position.position] !== 34) return null;
else position.position++;
		name = new TextDecoder().decode(name).replace(/%0A/gi, "\n").replace(/%0D/gi, "\r").replace(/%22/g, "\"");
		return name;
	}
	/**
	* @param {(char: number) => boolean} condition
	* @param {Buffer} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfBytes(condition, input, position) {
		let start = position.position;
		while (start < input.length && condition(input[start])) ++start;
		return input.subarray(position.position, position.position = start);
	}
	/**
	* @param {Buffer} buf
	* @param {boolean} leading
	* @param {boolean} trailing
	* @param {(charCode: number) => boolean} predicate
	* @returns {Buffer}
	*/
	function removeChars(buf, leading, trailing, predicate) {
		let lead = 0;
		let trail = buf.length - 1;
		if (leading) while (lead < buf.length && predicate(buf[lead])) lead++;
		while (trail > 0 && predicate(buf[trail])) trail--;
		return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
	}
	/**
	* Checks if {@param buffer} starts with {@param start}
	* @param {Buffer} buffer
	* @param {Buffer} start
	* @param {{ position: number }} position
	*/
	function bufferStartsWith(buffer, start, position) {
		if (buffer.length < start.length) return false;
		for (let i = 0; i < start.length; i++) if (start[i] !== buffer[position.position + i]) return false;
		return true;
	}
	formdataParser = {
		multipartFormDataParser,
		validateBoundary
	};
	return formdataParser;
}
var body;
var hasRequiredBody;
function requireBody() {
	if (hasRequiredBody) return body;
	hasRequiredBody = 1;
	const util$10 = util$n;
	const { ReadableStreamFrom: ReadableStreamFrom$2, isBlobLike: isBlobLike$2, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody, extractMimeType, utf8DecodeBytes } = requireUtil$5();
	const { FormData: FormData$1 } = requireFormdata();
	const { kState } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { Blob: Blob$2 } = require$$0$2;
	const assert$10 = require$$0;
	const { isErrored: isErrored$1 } = util$n;
	const { isArrayBuffer } = require$$8$1;
	const { serializeAMimeType: serializeAMimeType$1 } = requireDataUrl();
	const { multipartFormDataParser } = requireFormdataParser();
	const textEncoder = new TextEncoder();
	function extractBody$1(object, keepalive = false) {
		let stream$4 = null;
		if (object instanceof ReadableStream) stream$4 = object;
else if (isBlobLike$2(object)) stream$4 = object.stream();
else stream$4 = new ReadableStream({
			async pull(controller) {
				const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
				if (buffer.byteLength) controller.enqueue(buffer);
				queueMicrotask(() => readableStreamClose(controller));
			},
			start() {},
			type: "bytes"
		});
		assert$10(isReadableStreamLike(stream$4));
		let action = null;
		let source = null;
		let length = null;
		let type = null;
		if (typeof object === "string") {
			source = object;
			type = "text/plain;charset=UTF-8";
		} else if (object instanceof URLSearchParams) {
			source = object.toString();
			type = "application/x-www-form-urlencoded;charset=UTF-8";
		} else if (isArrayBuffer(object)) source = new Uint8Array(object.slice());
else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
else if (util$10.isFormDataLike(object)) {
			const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
			const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
			/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
			const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
			const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
			const blobParts = [];
			const rn = new Uint8Array([13, 10]);
			length = 0;
			let hasUnknownSizeValue = false;
			for (const [name, value] of object) if (typeof value === "string") {
				const chunk$1 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"` + `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
				blobParts.push(chunk$1);
				length += chunk$1.byteLength;
			} else {
				const chunk$1 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + "\r\n" + `Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
				blobParts.push(chunk$1, value, rn);
				if (typeof value.size === "number") length += chunk$1.byteLength + value.size + rn.byteLength;
else hasUnknownSizeValue = true;
			}
			const chunk = textEncoder.encode(`--${boundary}--`);
			blobParts.push(chunk);
			length += chunk.byteLength;
			if (hasUnknownSizeValue) length = null;
			source = object;
			action = async function* () {
				for (const part of blobParts) if (part.stream) yield* part.stream();
else yield part;
			};
			type = `multipart/form-data; boundary=${boundary}`;
		} else if (isBlobLike$2(object)) {
			source = object;
			length = object.size;
			if (object.type) type = object.type;
		} else if (typeof object[Symbol.asyncIterator] === "function") {
			if (keepalive) throw new TypeError("keepalive");
			if (util$10.isDisturbed(object) || object.locked) throw new TypeError("Response body object should not be disturbed or locked");
			stream$4 = object instanceof ReadableStream ? object : ReadableStreamFrom$2(object);
		}
		if (typeof source === "string" || util$10.isBuffer(source)) length = Buffer.byteLength(source);
		if (action != null) {
			let iterator;
			stream$4 = new ReadableStream({
				async start() {
					iterator = action(object)[Symbol.asyncIterator]();
				},
				async pull(controller) {
					const { value, done } = await iterator.next();
					if (done) queueMicrotask(() => {
						controller.close();
						controller.byobRequest?.respond(0);
					});
else if (!isErrored$1(stream$4)) {
						const buffer = new Uint8Array(value);
						if (buffer.byteLength) controller.enqueue(buffer);
					}
					return controller.desiredSize > 0;
				},
				async cancel(reason) {
					await iterator.return();
				},
				type: "bytes"
			});
		}
		const body$1 = {
			stream: stream$4,
			source,
			length
		};
		return [body$1, type];
	}
	function safelyExtractBody(object, keepalive = false) {
		if (object instanceof ReadableStream) {
			assert$10(!util$10.isDisturbed(object), "The body has already been consumed.");
			assert$10(!object.locked, "The stream is locked.");
		}
		return extractBody$1(object, keepalive);
	}
	function cloneBody(body$1) {
		const [out1, out2] = body$1.stream.tee();
		body$1.stream = out1;
		return {
			stream: out2,
			length: body$1.length,
			source: body$1.source
		};
	}
	function throwIfAborted(state) {
		if (state.aborted) throw new DOMException("The operation was aborted.", "AbortError");
	}
	function bodyMixinMethods(instance) {
		const methods = {
			blob() {
				return consumeBody(this, (bytes) => {
					let mimeType = bodyMimeType(this);
					if (mimeType === null) mimeType = "";
else if (mimeType) mimeType = serializeAMimeType$1(mimeType);
					return new Blob$2([bytes], { type: mimeType });
				}, instance);
			},
			arrayBuffer() {
				return consumeBody(this, (bytes) => {
					return new Uint8Array(bytes).buffer;
				}, instance);
			},
			text() {
				return consumeBody(this, utf8DecodeBytes, instance);
			},
			json() {
				return consumeBody(this, parseJSONFromBytes, instance);
			},
			formData() {
				return consumeBody(this, (value) => {
					const mimeType = bodyMimeType(this);
					if (mimeType !== null) switch (mimeType.essence) {
						case "multipart/form-data": {
							const parsed = multipartFormDataParser(value, mimeType);
							if (parsed === "failure") throw new TypeError("Failed to parse body as FormData.");
							const fd = new FormData$1();
							fd[kState] = parsed;
							return fd;
						}
						case "application/x-www-form-urlencoded": {
							const entries = new URLSearchParams(value.toString());
							const fd = new FormData$1();
							for (const [name, value$1] of entries) fd.append(name, value$1);
							return fd;
						}
					}
					throw new TypeError("Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".");
				}, instance);
			},
			bytes() {
				return consumeBody(this, (bytes) => {
					return new Uint8Array(bytes);
				}, instance);
			}
		};
		return methods;
	}
	function mixinBody(prototype) {
		Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	* @param {Response|Request} object
	* @param {(value: unknown) => unknown} convertBytesToJSValue
	* @param {Response|Request} instance
	*/
	async function consumeBody(object, convertBytesToJSValue, instance) {
		webidl.brandCheck(object, instance);
		if (bodyUnusable(object[kState].body)) throw new TypeError("Body is unusable: Body has already been read");
		throwIfAborted(object[kState]);
		const promise = createDeferredPromise();
		const errorSteps = (error) => promise.reject(error);
		const successSteps = (data) => {
			try {
				promise.resolve(convertBytesToJSValue(data));
			} catch (e) {
				errorSteps(e);
			}
		};
		if (object[kState].body == null) {
			successSteps(Buffer.allocUnsafe(0));
			return promise.promise;
		}
		await fullyReadBody(object[kState].body, successSteps, errorSteps);
		return promise.promise;
	}
	function bodyUnusable(body$1) {
		return body$1 != null && (body$1.stream.locked || util$10.isDisturbed(body$1.stream));
	}
	/**
	* @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	* @param {Uint8Array} bytes
	*/
	function parseJSONFromBytes(bytes) {
		return JSON.parse(utf8DecodeBytes(bytes));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	* @param {import('./response').Response|import('./request').Request} requestOrResponse
	*/
	function bodyMimeType(requestOrResponse) {
		/** @type {import('./headers').HeadersList} */
		const headers$1 = requestOrResponse[kState].headersList;
		const mimeType = extractMimeType(headers$1);
		if (mimeType === "failure") return null;
		return mimeType;
	}
	body = {
		extractBody: extractBody$1,
		safelyExtractBody,
		cloneBody,
		mixinBody
	};
	return body;
}
const assert$b = require$$0;
const util$j = util$n;
const { channels: channels$1 } = diagnostics;
const timers = timers$1;
const { RequestContentLengthMismatchError: RequestContentLengthMismatchError$1, ResponseContentLengthMismatchError, RequestAbortedError: RequestAbortedError$7, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$3, InformationalError: InformationalError$2, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError } = errors$1;
const { kUrl: kUrl$5, kReset: kReset$1, kClient: kClient$3, kParser, kBlocking, kRunning: kRunning$5, kPending: kPending$4, kSize: kSize$4, kWriting, kQueue: kQueue$3, kNoRef, kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout$1, kHostHeader: kHostHeader$1, kPendingIdx: kPendingIdx$2, kRunningIdx: kRunningIdx$2, kError: kError$2, kPipelining: kPipelining$1, kSocket: kSocket$1, kKeepAliveTimeoutValue: kKeepAliveTimeoutValue$1, kMaxHeadersSize: kMaxHeadersSize$1, kKeepAliveMaxTimeout: kKeepAliveMaxTimeout$1, kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold$1, kHeadersTimeout: kHeadersTimeout$1, kBodyTimeout: kBodyTimeout$1, kStrictContentLength: kStrictContentLength$2, kMaxRequests: kMaxRequests$1, kCounter: kCounter$1, kMaxResponseSize: kMaxResponseSize$1, kOnError: kOnError$2, kResume: kResume$3, kHTTPContext: kHTTPContext$1 } = symbols$4;
const constants$2 = constants$4;
const EMPTY_BUF = Buffer.alloc(0);
const FastBuffer = Buffer[Symbol.species];
const addListener = util$j.addListener;
const removeAllListeners = util$j.removeAllListeners;
let extractBody;
async function lazyllhttp() {
	const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : undefined;
	let mod;
	try {
		mod = await WebAssembly.compile(requireLlhttp_simdWasm());
	} catch (e) {
		mod = await WebAssembly.compile(llhttpWasmData || requireLlhttpWasm());
	}
	return await WebAssembly.instantiate(mod, { env: {
		wasm_on_url: (p, at, len) => {
			return 0;
		},
		wasm_on_status: (p, at, len) => {
			assert$b.strictEqual(currentParser.ptr, p);
			const start = at - currentBufferPtr + currentBufferRef.byteOffset;
			return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
		},
		wasm_on_message_begin: (p) => {
			assert$b.strictEqual(currentParser.ptr, p);
			return currentParser.onMessageBegin() || 0;
		},
		wasm_on_header_field: (p, at, len) => {
			assert$b.strictEqual(currentParser.ptr, p);
			const start = at - currentBufferPtr + currentBufferRef.byteOffset;
			return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
		},
		wasm_on_header_value: (p, at, len) => {
			assert$b.strictEqual(currentParser.ptr, p);
			const start = at - currentBufferPtr + currentBufferRef.byteOffset;
			return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
		},
		wasm_on_headers_complete: (p, statusCode, upgrade$2, shouldKeepAlive) => {
			assert$b.strictEqual(currentParser.ptr, p);
			return currentParser.onHeadersComplete(statusCode, Boolean(upgrade$2), Boolean(shouldKeepAlive)) || 0;
		},
		wasm_on_body: (p, at, len) => {
			assert$b.strictEqual(currentParser.ptr, p);
			const start = at - currentBufferPtr + currentBufferRef.byteOffset;
			return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
		},
		wasm_on_message_complete: (p) => {
			assert$b.strictEqual(currentParser.ptr, p);
			return currentParser.onMessageComplete() || 0;
		}
	} });
}
let llhttpInstance = null;
let llhttpPromise = lazyllhttp();
llhttpPromise.catch();
let currentParser = null;
let currentBufferRef = null;
let currentBufferSize = 0;
let currentBufferPtr = null;
const TIMEOUT_HEADERS = 1;
const TIMEOUT_BODY = 2;
const TIMEOUT_IDLE = 3;
var Parser = class {
	constructor(client$1, socket, { exports }) {
		assert$b(Number.isFinite(client$1[kMaxHeadersSize$1]) && client$1[kMaxHeadersSize$1] > 0);
		this.llhttp = exports;
		this.ptr = this.llhttp.llhttp_alloc(constants$2.TYPE.RESPONSE);
		this.client = client$1;
		this.socket = socket;
		this.timeout = null;
		this.timeoutValue = null;
		this.timeoutType = null;
		this.statusCode = null;
		this.statusText = "";
		this.upgrade = false;
		this.headers = [];
		this.headersSize = 0;
		this.headersMaxSize = client$1[kMaxHeadersSize$1];
		this.shouldKeepAlive = false;
		this.paused = false;
		this.resume = this.resume.bind(this);
		this.bytesRead = 0;
		this.keepAlive = "";
		this.contentLength = "";
		this.connection = "";
		this.maxResponseSize = client$1[kMaxResponseSize$1];
	}
	setTimeout(value, type) {
		this.timeoutType = type;
		if (value !== this.timeoutValue) {
			timers.clearTimeout(this.timeout);
			if (value) {
				this.timeout = timers.setTimeout(onParserTimeout, value, this);
				if (this.timeout.unref) this.timeout.unref();
			} else this.timeout = null;
			this.timeoutValue = value;
		} else if (this.timeout) {
			if (this.timeout.refresh) this.timeout.refresh();
		}
	}
	resume() {
		if (this.socket.destroyed || !this.paused) return;
		assert$b(this.ptr != null);
		assert$b(currentParser == null);
		this.llhttp.llhttp_resume(this.ptr);
		assert$b(this.timeoutType === TIMEOUT_BODY);
		if (this.timeout) {
			if (this.timeout.refresh) this.timeout.refresh();
		}
		this.paused = false;
		this.execute(this.socket.read() || EMPTY_BUF);
		this.readMore();
	}
	readMore() {
		while (!this.paused && this.ptr) {
			const chunk = this.socket.read();
			if (chunk === null) break;
			this.execute(chunk);
		}
	}
	execute(data) {
		assert$b(this.ptr != null);
		assert$b(currentParser == null);
		assert$b(!this.paused);
		const { socket, llhttp } = this;
		if (data.length > currentBufferSize) {
			if (currentBufferPtr) llhttp.free(currentBufferPtr);
			currentBufferSize = Math.ceil(data.length / 4096) * 4096;
			currentBufferPtr = llhttp.malloc(currentBufferSize);
		}
		new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
		try {
			let ret;
			try {
				currentBufferRef = data;
				currentParser = this;
				ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
			} catch (err) {
				throw err;
			} finally {
				currentParser = null;
				currentBufferRef = null;
			}
			const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
			if (ret === constants$2.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));
else if (ret === constants$2.ERROR.PAUSED) {
				this.paused = true;
				socket.unshift(data.slice(offset));
			} else if (ret !== constants$2.ERROR.OK) {
				const ptr = llhttp.llhttp_get_error_reason(this.ptr);
				let message = "";
				if (ptr) {
					const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
					message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
				}
				throw new HTTPParserError(message, constants$2.ERROR[ret], data.slice(offset));
			}
		} catch (err) {
			util$j.destroy(socket, err);
		}
	}
	destroy() {
		assert$b(this.ptr != null);
		assert$b(currentParser == null);
		this.llhttp.llhttp_free(this.ptr);
		this.ptr = null;
		timers.clearTimeout(this.timeout);
		this.timeout = null;
		this.timeoutValue = null;
		this.timeoutType = null;
		this.paused = false;
	}
	onStatus(buf) {
		this.statusText = buf.toString();
	}
	onMessageBegin() {
		const { socket, client: client$1 } = this;
		if (socket.destroyed) return -1;
		const request$4 = client$1[kQueue$3][client$1[kRunningIdx$2]];
		if (!request$4) return -1;
		request$4.onResponseStarted();
	}
	onHeaderField(buf) {
		const len = this.headers.length;
		if ((len & 1) === 0) this.headers.push(buf);
else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
		this.trackHeader(buf.length);
	}
	onHeaderValue(buf) {
		let len = this.headers.length;
		if ((len & 1) === 1) {
			this.headers.push(buf);
			len += 1;
		} else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
		const key = this.headers[len - 2];
		if (key.length === 10) {
			const headerName = util$j.bufferToLowerCasedHeaderName(key);
			if (headerName === "keep-alive") this.keepAlive += buf.toString();
else if (headerName === "connection") this.connection += buf.toString();
		} else if (key.length === 14 && util$j.bufferToLowerCasedHeaderName(key) === "content-length") this.contentLength += buf.toString();
		this.trackHeader(buf.length);
	}
	trackHeader(len) {
		this.headersSize += len;
		if (this.headersSize >= this.headersMaxSize) util$j.destroy(this.socket, new HeadersOverflowError());
	}
	onUpgrade(head) {
		const { upgrade: upgrade$2, client: client$1, socket, headers: headers$1, statusCode } = this;
		assert$b(upgrade$2);
		const request$4 = client$1[kQueue$3][client$1[kRunningIdx$2]];
		assert$b(request$4);
		assert$b(!socket.destroyed);
		assert$b(socket === client$1[kSocket$1]);
		assert$b(!this.paused);
		assert$b(request$4.upgrade || request$4.method === "CONNECT");
		this.statusCode = null;
		this.statusText = "";
		this.shouldKeepAlive = null;
		assert$b(this.headers.length % 2 === 0);
		this.headers = [];
		this.headersSize = 0;
		socket.unshift(head);
		socket[kParser].destroy();
		socket[kParser] = null;
		socket[kClient$3] = null;
		socket[kError$2] = null;
		removeAllListeners(socket);
		client$1[kSocket$1] = null;
		client$1[kHTTPContext$1] = null;
		client$1[kQueue$3][client$1[kRunningIdx$2]++] = null;
		client$1.emit("disconnect", client$1[kUrl$5], [client$1], new InformationalError$2("upgrade"));
		try {
			request$4.onUpgrade(statusCode, headers$1, socket);
		} catch (err) {
			util$j.destroy(socket, err);
		}
		client$1[kResume$3]();
	}
	onHeadersComplete(statusCode, upgrade$2, shouldKeepAlive) {
		const { client: client$1, socket, headers: headers$1, statusText } = this;
		if (socket.destroyed) return -1;
		const request$4 = client$1[kQueue$3][client$1[kRunningIdx$2]];
		if (!request$4) return -1;
		assert$b(!this.upgrade);
		assert$b(this.statusCode < 200);
		if (statusCode === 100) {
			util$j.destroy(socket, new SocketError$3("bad response", util$j.getSocketInfo(socket)));
			return -1;
		}
		if (upgrade$2 && !request$4.upgrade) {
			util$j.destroy(socket, new SocketError$3("bad upgrade", util$j.getSocketInfo(socket)));
			return -1;
		}
		assert$b.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
		this.statusCode = statusCode;
		this.shouldKeepAlive = shouldKeepAlive || request$4.method === "HEAD" && !socket[kReset$1] && this.connection.toLowerCase() === "keep-alive";
		if (this.statusCode >= 200) {
			const bodyTimeout = request$4.bodyTimeout != null ? request$4.bodyTimeout : client$1[kBodyTimeout$1];
			this.setTimeout(bodyTimeout, TIMEOUT_BODY);
		} else if (this.timeout) {
			if (this.timeout.refresh) this.timeout.refresh();
		}
		if (request$4.method === "CONNECT") {
			assert$b(client$1[kRunning$5] === 1);
			this.upgrade = true;
			return 2;
		}
		if (upgrade$2) {
			assert$b(client$1[kRunning$5] === 1);
			this.upgrade = true;
			return 2;
		}
		assert$b(this.headers.length % 2 === 0);
		this.headers = [];
		this.headersSize = 0;
		if (this.shouldKeepAlive && client$1[kPipelining$1]) {
			const keepAliveTimeout = this.keepAlive ? util$j.parseKeepAliveTimeout(this.keepAlive) : null;
			if (keepAliveTimeout != null) {
				const timeout = Math.min(keepAliveTimeout - client$1[kKeepAliveTimeoutThreshold$1], client$1[kKeepAliveMaxTimeout$1]);
				if (timeout <= 0) socket[kReset$1] = true;
else client$1[kKeepAliveTimeoutValue$1] = timeout;
			} else client$1[kKeepAliveTimeoutValue$1] = client$1[kKeepAliveDefaultTimeout$1];
		} else socket[kReset$1] = true;
		const pause = request$4.onHeaders(statusCode, headers$1, this.resume, statusText) === false;
		if (request$4.aborted) return -1;
		if (request$4.method === "HEAD") return 1;
		if (statusCode < 200) return 1;
		if (socket[kBlocking]) {
			socket[kBlocking] = false;
			client$1[kResume$3]();
		}
		return pause ? constants$2.ERROR.PAUSED : 0;
	}
	onBody(buf) {
		const { client: client$1, socket, statusCode, maxResponseSize } = this;
		if (socket.destroyed) return -1;
		const request$4 = client$1[kQueue$3][client$1[kRunningIdx$2]];
		assert$b(request$4);
		assert$b.strictEqual(this.timeoutType, TIMEOUT_BODY);
		if (this.timeout) {
			if (this.timeout.refresh) this.timeout.refresh();
		}
		assert$b(statusCode >= 200);
		if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
			util$j.destroy(socket, new ResponseExceededMaxSizeError());
			return -1;
		}
		this.bytesRead += buf.length;
		if (request$4.onData(buf) === false) return constants$2.ERROR.PAUSED;
	}
	onMessageComplete() {
		const { client: client$1, socket, statusCode, upgrade: upgrade$2, headers: headers$1, contentLength, bytesRead, shouldKeepAlive } = this;
		if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
		if (upgrade$2) return;
		const request$4 = client$1[kQueue$3][client$1[kRunningIdx$2]];
		assert$b(request$4);
		assert$b(statusCode >= 100);
		this.statusCode = null;
		this.statusText = "";
		this.bytesRead = 0;
		this.contentLength = "";
		this.keepAlive = "";
		this.connection = "";
		assert$b(this.headers.length % 2 === 0);
		this.headers = [];
		this.headersSize = 0;
		if (statusCode < 200) return;
		if (request$4.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
			util$j.destroy(socket, new ResponseContentLengthMismatchError());
			return -1;
		}
		request$4.onComplete(headers$1);
		client$1[kQueue$3][client$1[kRunningIdx$2]++] = null;
		if (socket[kWriting]) {
			assert$b.strictEqual(client$1[kRunning$5], 0);
			util$j.destroy(socket, new InformationalError$2("reset"));
			return constants$2.ERROR.PAUSED;
		} else if (!shouldKeepAlive) {
			util$j.destroy(socket, new InformationalError$2("reset"));
			return constants$2.ERROR.PAUSED;
		} else if (socket[kReset$1] && client$1[kRunning$5] === 0) {
			util$j.destroy(socket, new InformationalError$2("reset"));
			return constants$2.ERROR.PAUSED;
		} else if (client$1[kPipelining$1] == null || client$1[kPipelining$1] === 1) setImmediate(() => client$1[kResume$3]());
else client$1[kResume$3]();
	}
};
function onParserTimeout(parser) {
	const { socket, timeoutType, client: client$1 } = parser;
	if (timeoutType === TIMEOUT_HEADERS) {
		if (!socket[kWriting] || socket.writableNeedDrain || client$1[kRunning$5] > 1) {
			assert$b(!parser.paused, "cannot be paused while waiting for headers");
			util$j.destroy(socket, new HeadersTimeoutError());
		}
	} else if (timeoutType === TIMEOUT_BODY) {
		if (!parser.paused) util$j.destroy(socket, new BodyTimeoutError());
	} else if (timeoutType === TIMEOUT_IDLE) {
		assert$b(client$1[kRunning$5] === 0 && client$1[kKeepAliveTimeoutValue$1]);
		util$j.destroy(socket, new InformationalError$2("socket idle timeout"));
	}
}
async function connectH1$1(client$1, socket) {
	client$1[kSocket$1] = socket;
	if (!llhttpInstance) {
		llhttpInstance = await llhttpPromise;
		llhttpPromise = null;
	}
	socket[kNoRef] = false;
	socket[kWriting] = false;
	socket[kReset$1] = false;
	socket[kBlocking] = false;
	socket[kParser] = new Parser(client$1, socket, llhttpInstance);
	addListener(socket, "error", function(err) {
		const parser = this[kParser];
		assert$b(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
			parser.onMessageComplete();
			return;
		}
		this[kError$2] = err;
		this[kClient$3][kOnError$2](err);
	});
	addListener(socket, "readable", function() {
		const parser = this[kParser];
		if (parser) parser.readMore();
	});
	addListener(socket, "end", function() {
		const parser = this[kParser];
		if (parser.statusCode && !parser.shouldKeepAlive) {
			parser.onMessageComplete();
			return;
		}
		util$j.destroy(this, new SocketError$3("other side closed", util$j.getSocketInfo(this)));
	});
	addListener(socket, "close", function() {
		const client$2 = this[kClient$3];
		const parser = this[kParser];
		if (parser) {
			if (!this[kError$2] && parser.statusCode && !parser.shouldKeepAlive) parser.onMessageComplete();
			this[kParser].destroy();
			this[kParser] = null;
		}
		const err = this[kError$2] || new SocketError$3("closed", util$j.getSocketInfo(this));
		client$2[kSocket$1] = null;
		client$2[kHTTPContext$1] = null;
		if (client$2.destroyed) {
			assert$b(client$2[kPending$4] === 0);
			const requests = client$2[kQueue$3].splice(client$2[kRunningIdx$2]);
			for (let i = 0; i < requests.length; i++) {
				const request$4 = requests[i];
				util$j.errorRequest(client$2, request$4, err);
			}
		} else if (client$2[kRunning$5] > 0 && err.code !== "UND_ERR_INFO") {
			const request$4 = client$2[kQueue$3][client$2[kRunningIdx$2]];
			client$2[kQueue$3][client$2[kRunningIdx$2]++] = null;
			util$j.errorRequest(client$2, request$4, err);
		}
		client$2[kPendingIdx$2] = client$2[kRunningIdx$2];
		assert$b(client$2[kRunning$5] === 0);
		client$2.emit("disconnect", client$2[kUrl$5], [client$2], err);
		client$2[kResume$3]();
	});
	let closed = false;
	socket.on("close", () => {
		closed = true;
	});
	return {
		version: "h1",
		defaultPipelining: 1,
		write(...args) {
			return writeH1(client$1, ...args);
		},
		resume() {
			resumeH1(client$1);
		},
		destroy(err, callback) {
			if (closed) queueMicrotask(callback);
else socket.destroy(err).on("close", callback);
		},
		get destroyed() {
			return socket.destroyed;
		},
		busy(request$4) {
			if (socket[kWriting] || socket[kReset$1] || socket[kBlocking]) return true;
			if (request$4) {
				if (client$1[kRunning$5] > 0 && !request$4.idempotent) return true;
				if (client$1[kRunning$5] > 0 && (request$4.upgrade || request$4.method === "CONNECT")) return true;
				if (client$1[kRunning$5] > 0 && util$j.bodyLength(request$4.body) !== 0 && (util$j.isStream(request$4.body) || util$j.isAsyncIterable(request$4.body) || util$j.isFormDataLike(request$4.body))) return true;
			}
			return false;
		}
	};
}
function resumeH1(client$1) {
	const socket = client$1[kSocket$1];
	if (socket && !socket.destroyed) {
		if (client$1[kSize$4] === 0) {
			if (!socket[kNoRef] && socket.unref) {
				socket.unref();
				socket[kNoRef] = true;
			}
		} else if (socket[kNoRef] && socket.ref) {
			socket.ref();
			socket[kNoRef] = false;
		}
		if (client$1[kSize$4] === 0) {
			if (socket[kParser].timeoutType !== TIMEOUT_IDLE) socket[kParser].setTimeout(client$1[kKeepAliveTimeoutValue$1], TIMEOUT_IDLE);
		} else if (client$1[kRunning$5] > 0 && socket[kParser].statusCode < 200) {
			if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
				const request$4 = client$1[kQueue$3][client$1[kRunningIdx$2]];
				const headersTimeout = request$4.headersTimeout != null ? request$4.headersTimeout : client$1[kHeadersTimeout$1];
				socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
			}
		}
	}
}
function shouldSendContentLength$1(method) {
	return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
}
function writeH1(client$1, request$4) {
	const { method, path: path$1, host, upgrade: upgrade$2, blocking, reset } = request$4;
	let { body: body$1, headers: headers$1, contentLength } = request$4;
	const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
	if (util$j.isFormDataLike(body$1)) {
		if (!extractBody) extractBody = requireBody().extractBody;
		const [bodyStream, contentType] = extractBody(body$1);
		if (request$4.contentType == null) headers$1.push("content-type", contentType);
		body$1 = bodyStream.stream;
		contentLength = bodyStream.length;
	} else if (util$j.isBlobLike(body$1) && request$4.contentType == null && body$1.type) headers$1.push("content-type", body$1.type);
	if (body$1 && typeof body$1.read === "function") body$1.read(0);
	const bodyLength$1 = util$j.bodyLength(body$1);
	contentLength = bodyLength$1 ?? contentLength;
	if (contentLength === null) contentLength = request$4.contentLength;
	if (contentLength === 0 && !expectsPayload) contentLength = null;
	if (shouldSendContentLength$1(method) && contentLength > 0 && request$4.contentLength !== null && request$4.contentLength !== contentLength) {
		if (client$1[kStrictContentLength$2]) {
			util$j.errorRequest(client$1, request$4, new RequestContentLengthMismatchError$1());
			return false;
		}
		process.emitWarning(new RequestContentLengthMismatchError$1());
	}
	const socket = client$1[kSocket$1];
	const abort$1 = (err) => {
		if (request$4.aborted || request$4.completed) return;
		util$j.errorRequest(client$1, request$4, err || new RequestAbortedError$7());
		util$j.destroy(body$1);
		util$j.destroy(socket, new InformationalError$2("aborted"));
	};
	try {
		request$4.onConnect(abort$1);
	} catch (err) {
		util$j.errorRequest(client$1, request$4, err);
	}
	if (request$4.aborted) return false;
	if (method === "HEAD") socket[kReset$1] = true;
	if (upgrade$2 || method === "CONNECT") socket[kReset$1] = true;
	if (reset != null) socket[kReset$1] = reset;
	if (client$1[kMaxRequests$1] && socket[kCounter$1]++ >= client$1[kMaxRequests$1]) socket[kReset$1] = true;
	if (blocking) socket[kBlocking] = true;
	let header = `${method} ${path$1} HTTP/1.1\r\n`;
	if (typeof host === "string") header += `host: ${host}\r\n`;
else header += client$1[kHostHeader$1];
	if (upgrade$2) header += `connection: upgrade\r\nupgrade: ${upgrade$2}\r\n`;
else if (client$1[kPipelining$1] && !socket[kReset$1]) header += "connection: keep-alive\r\n";
else header += "connection: close\r\n";
	if (Array.isArray(headers$1)) for (let n = 0; n < headers$1.length; n += 2) {
		const key = headers$1[n + 0];
		const val = headers$1[n + 1];
		if (Array.isArray(val)) for (let i = 0; i < val.length; i++) header += `${key}: ${val[i]}\r\n`;
else header += `${key}: ${val}\r\n`;
	}
	if (channels$1.sendHeaders.hasSubscribers) channels$1.sendHeaders.publish({
		request: request$4,
		headers: header,
		socket
	});
	if (!body$1 || bodyLength$1 === 0) writeBuffer$1(abort$1, null, client$1, request$4, socket, contentLength, header, expectsPayload);
else if (util$j.isBuffer(body$1)) writeBuffer$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload);
else if (util$j.isBlobLike(body$1)) if (typeof body$1.stream === "function") writeIterable$1(abort$1, body$1.stream(), client$1, request$4, socket, contentLength, header, expectsPayload);
else writeBlob$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload);
else if (util$j.isStream(body$1)) writeStream$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload);
else if (util$j.isIterable(body$1)) writeIterable$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload);
else assert$b(false);
	return true;
}
function writeStream$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload) {
	assert$b(contentLength !== 0 || client$1[kRunning$5] === 0, "stream body cannot be pipelined");
	let finished$1 = false;
	const writer = new AsyncWriter({
		abort: abort$1,
		socket,
		request: request$4,
		contentLength,
		client: client$1,
		expectsPayload,
		header
	});
	const onData = function(chunk) {
		if (finished$1) return;
		try {
			if (!writer.write(chunk) && this.pause) this.pause();
		} catch (err) {
			util$j.destroy(this, err);
		}
	};
	const onDrain = function() {
		if (finished$1) return;
		if (body$1.resume) body$1.resume();
	};
	const onClose = function() {
		queueMicrotask(() => {
			body$1.removeListener("error", onFinished);
		});
		if (!finished$1) {
			const err = new RequestAbortedError$7();
			queueMicrotask(() => onFinished(err));
		}
	};
	const onFinished = function(err) {
		if (finished$1) return;
		finished$1 = true;
		assert$b(socket.destroyed || socket[kWriting] && client$1[kRunning$5] <= 1);
		socket.off("drain", onDrain).off("error", onFinished);
		body$1.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
		if (!err) try {
			writer.end();
		} catch (er) {
			err = er;
		}
		writer.destroy(err);
		if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) util$j.destroy(body$1, err);
else util$j.destroy(body$1);
	};
	body$1.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
	if (body$1.resume) body$1.resume();
	socket.on("drain", onDrain).on("error", onFinished);
	if (body$1.errorEmitted ?? body$1.errored) setImmediate(() => onFinished(body$1.errored));
else if (body$1.endEmitted ?? body$1.readableEnded) setImmediate(() => onFinished(null));
	if (body$1.closeEmitted ?? body$1.closed) setImmediate(onClose);
}
function writeBuffer$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload) {
	try {
		if (!body$1) if (contentLength === 0) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
else {
			assert$b(contentLength === null, "no body must not have content length");
			socket.write(`${header}\r\n`, "latin1");
		}
else if (util$j.isBuffer(body$1)) {
			assert$b(contentLength === body$1.byteLength, "buffer body must have content length");
			socket.cork();
			socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			socket.write(body$1);
			socket.uncork();
			request$4.onBodySent(body$1);
			if (!expectsPayload) socket[kReset$1] = true;
		}
		request$4.onRequestSent();
		client$1[kResume$3]();
	} catch (err) {
		abort$1(err);
	}
}
async function writeBlob$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload) {
	assert$b(contentLength === body$1.size, "blob body must have content length");
	try {
		if (contentLength != null && contentLength !== body$1.size) throw new RequestContentLengthMismatchError$1();
		const buffer = Buffer.from(await body$1.arrayBuffer());
		socket.cork();
		socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
		socket.write(buffer);
		socket.uncork();
		request$4.onBodySent(buffer);
		request$4.onRequestSent();
		if (!expectsPayload) socket[kReset$1] = true;
		client$1[kResume$3]();
	} catch (err) {
		abort$1(err);
	}
}
async function writeIterable$1(abort$1, body$1, client$1, request$4, socket, contentLength, header, expectsPayload) {
	assert$b(contentLength !== 0 || client$1[kRunning$5] === 0, "iterator body cannot be pipelined");
	let callback = null;
	function onDrain() {
		if (callback) {
			const cb = callback;
			callback = null;
			cb();
		}
	}
	const waitForDrain = () => new Promise((resolve, reject) => {
		assert$b(callback === null);
		if (socket[kError$2]) reject(socket[kError$2]);
else callback = resolve;
	});
	socket.on("close", onDrain).on("drain", onDrain);
	const writer = new AsyncWriter({
		abort: abort$1,
		socket,
		request: request$4,
		contentLength,
		client: client$1,
		expectsPayload,
		header
	});
	try {
		for await (const chunk of body$1) {
			if (socket[kError$2]) throw socket[kError$2];
			if (!writer.write(chunk)) await waitForDrain();
		}
		writer.end();
	} catch (err) {
		writer.destroy(err);
	} finally {
		socket.off("close", onDrain).off("drain", onDrain);
	}
}
var AsyncWriter = class {
	constructor({ abort: abort$1, socket, request: request$4, contentLength, client: client$1, expectsPayload, header }) {
		this.socket = socket;
		this.request = request$4;
		this.contentLength = contentLength;
		this.client = client$1;
		this.bytesWritten = 0;
		this.expectsPayload = expectsPayload;
		this.header = header;
		this.abort = abort$1;
		socket[kWriting] = true;
	}
	write(chunk) {
		const { socket, request: request$4, contentLength, client: client$1, bytesWritten, expectsPayload, header } = this;
		if (socket[kError$2]) throw socket[kError$2];
		if (socket.destroyed) return false;
		const len = Buffer.byteLength(chunk);
		if (!len) return true;
		if (contentLength !== null && bytesWritten + len > contentLength) {
			if (client$1[kStrictContentLength$2]) throw new RequestContentLengthMismatchError$1();
			process.emitWarning(new RequestContentLengthMismatchError$1());
		}
		socket.cork();
		if (bytesWritten === 0) {
			if (!expectsPayload) socket[kReset$1] = true;
			if (contentLength === null) socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
		}
		if (contentLength === null) socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
		this.bytesWritten += len;
		const ret = socket.write(chunk);
		socket.uncork();
		request$4.onBodySent(chunk);
		if (!ret) {
			if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
				if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
			}
		}
		return ret;
	}
	end() {
		const { socket, contentLength, client: client$1, bytesWritten, expectsPayload, header, request: request$4 } = this;
		request$4.onRequestSent();
		socket[kWriting] = false;
		if (socket[kError$2]) throw socket[kError$2];
		if (socket.destroyed) return;
		if (bytesWritten === 0) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
else socket.write(`${header}\r\n`, "latin1");
else if (contentLength === null) socket.write("\r\n0\r\n\r\n", "latin1");
		if (contentLength !== null && bytesWritten !== contentLength) if (client$1[kStrictContentLength$2]) throw new RequestContentLengthMismatchError$1();
else process.emitWarning(new RequestContentLengthMismatchError$1());
		if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
			if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
		}
		client$1[kResume$3]();
	}
	destroy(err) {
		const { socket, client: client$1, abort: abort$1 } = this;
		socket[kWriting] = false;
		if (err) {
			assert$b(client$1[kRunning$5] <= 1, "pipeline should only contain this request");
			abort$1(err);
		}
	}
};
var clientH1 = connectH1$1;
const assert$a = require$$0;
const { pipeline: pipeline$2 } = stream;
const util$i = util$n;
const { RequestContentLengthMismatchError, RequestAbortedError: RequestAbortedError$6, SocketError: SocketError$2, InformationalError: InformationalError$1 } = errors$1;
const { kUrl: kUrl$4, kReset, kClient: kClient$2, kRunning: kRunning$4, kPending: kPending$3, kQueue: kQueue$2, kPendingIdx: kPendingIdx$1, kRunningIdx: kRunningIdx$1, kError: kError$1, kSocket, kStrictContentLength: kStrictContentLength$1, kOnError: kOnError$1, kMaxConcurrentStreams: kMaxConcurrentStreams$1, kHTTP2Session, kResume: kResume$2 } = symbols$4;
const kOpenStreams = Symbol("open streams");
let h2ExperimentalWarned = false;
/** @type {import('http2')} */
let http2;
try {
	http2 = __require("node:http2");
} catch {
	http2 = { constants: {} };
}
const { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
function parseH2Headers(headers$1) {
	const result = [];
	for (const [name, value] of Object.entries(headers$1)) if (Array.isArray(value)) for (const subvalue of value) result.push(Buffer.from(name), Buffer.from(subvalue));
else result.push(Buffer.from(name), Buffer.from(value));
	return result;
}
async function connectH2$1(client$1, socket) {
	client$1[kSocket] = socket;
	if (!h2ExperimentalWarned) {
		h2ExperimentalWarned = true;
		process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" });
	}
	const session = http2.connect(client$1[kUrl$4], {
		createConnection: () => socket,
		peerMaxConcurrentStreams: client$1[kMaxConcurrentStreams$1]
	});
	session[kOpenStreams] = 0;
	session[kClient$2] = client$1;
	session[kSocket] = socket;
	util$i.addListener(session, "error", onHttp2SessionError);
	util$i.addListener(session, "frameError", onHttp2FrameError);
	util$i.addListener(session, "end", onHttp2SessionEnd);
	util$i.addListener(session, "goaway", onHTTP2GoAway);
	util$i.addListener(session, "close", function() {
		const { [kClient$2]: client$2 } = this;
		const { [kSocket]: socket$1 } = client$2;
		const err = this[kSocket][kError$1] || this[kError$1] || new SocketError$2("closed", util$i.getSocketInfo(socket$1));
		client$2[kHTTP2Session] = null;
		if (client$2.destroyed) {
			assert$a(client$2[kPending$3] === 0);
			const requests = client$2[kQueue$2].splice(client$2[kRunningIdx$1]);
			for (let i = 0; i < requests.length; i++) {
				const request$4 = requests[i];
				util$i.errorRequest(client$2, request$4, err);
			}
		}
	});
	session.unref();
	client$1[kHTTP2Session] = session;
	socket[kHTTP2Session] = session;
	util$i.addListener(socket, "error", function(err) {
		assert$a(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		this[kError$1] = err;
		this[kClient$2][kOnError$1](err);
	});
	util$i.addListener(socket, "end", function() {
		util$i.destroy(this, new SocketError$2("other side closed", util$i.getSocketInfo(this)));
	});
	util$i.addListener(socket, "close", function() {
		const err = this[kError$1] || new SocketError$2("closed", util$i.getSocketInfo(this));
		client$1[kSocket] = null;
		if (this[kHTTP2Session] != null) this[kHTTP2Session].destroy(err);
		client$1[kPendingIdx$1] = client$1[kRunningIdx$1];
		assert$a(client$1[kRunning$4] === 0);
		client$1.emit("disconnect", client$1[kUrl$4], [client$1], err);
		client$1[kResume$2]();
	});
	let closed = false;
	socket.on("close", () => {
		closed = true;
	});
	return {
		version: "h2",
		defaultPipelining: Infinity,
		write(...args) {
			writeH2(client$1, ...args);
		},
		resume() {},
		destroy(err, callback) {
			if (closed) queueMicrotask(callback);
else socket.destroy(err).on("close", callback);
		},
		get destroyed() {
			return socket.destroyed;
		},
		busy() {
			return false;
		}
	};
}
function onHttp2SessionError(err) {
	assert$a(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
	this[kSocket][kError$1] = err;
	this[kClient$2][kOnError$1](err);
}
function onHttp2FrameError(type, code, id) {
	if (id === 0) {
		const err = new InformationalError$1(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
		this[kSocket][kError$1] = err;
		this[kClient$2][kOnError$1](err);
	}
}
function onHttp2SessionEnd() {
	const err = new SocketError$2("other side closed", util$i.getSocketInfo(this[kSocket]));
	this.destroy(err);
	util$i.destroy(this[kSocket], err);
}
/**
* This is the root cause of #3011
* We need to handle GOAWAY frames properly, and trigger the session close
* along with the socket right away
*/
function onHTTP2GoAway(code) {
	const err = new RequestAbortedError$6(`HTTP/2: "GOAWAY" frame received with code ${code}`);
	this[kSocket][kError$1] = err;
	this[kClient$2][kOnError$1](err);
	this.unref();
	util$i.destroy(this[kSocket], err);
}
function shouldSendContentLength(method) {
	return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
}
function writeH2(client$1, request$4) {
	const session = client$1[kHTTP2Session];
	const { body: body$1, method, path: path$1, host, upgrade: upgrade$2, expectContinue, signal, headers: reqHeaders } = request$4;
	if (upgrade$2) {
		util$i.errorRequest(client$1, request$4, new Error("Upgrade not supported for H2"));
		return false;
	}
	if (request$4.aborted) return false;
	const headers$1 = {};
	for (let n = 0; n < reqHeaders.length; n += 2) {
		const key = reqHeaders[n + 0];
		const val = reqHeaders[n + 1];
		if (Array.isArray(val)) for (let i = 0; i < val.length; i++) if (headers$1[key]) headers$1[key] += `,${val[i]}`;
else headers$1[key] = val[i];
else headers$1[key] = val;
	}
	/** @type {import('node:http2').ClientHttp2Stream} */
	let stream$4;
	const { hostname, port } = client$1[kUrl$4];
	headers$1[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
	headers$1[HTTP2_HEADER_METHOD] = method;
	const abort$1 = (err) => {
		if (request$4.aborted || request$4.completed) return;
		err = err || new RequestAbortedError$6();
		util$i.errorRequest(client$1, request$4, err);
		if (stream$4 != null) util$i.destroy(stream$4, err);
		util$i.destroy(body$1, err);
	};
	try {
		request$4.onConnect(abort$1);
	} catch (err) {
		util$i.errorRequest(client$1, request$4, err);
	}
	if (method === "CONNECT") {
		session.ref();
		stream$4 = session.request(headers$1, {
			endStream: false,
			signal
		});
		if (stream$4.id && !stream$4.pending) {
			request$4.onUpgrade(null, null, stream$4);
			++session[kOpenStreams];
		} else stream$4.once("ready", () => {
			request$4.onUpgrade(null, null, stream$4);
			++session[kOpenStreams];
		});
		stream$4.once("close", () => {
			session[kOpenStreams] -= 1;
			if (session[kOpenStreams] === 0) session.unref();
		});
		return true;
	}
	headers$1[HTTP2_HEADER_PATH] = path$1;
	headers$1[HTTP2_HEADER_SCHEME] = "https";
	const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
	if (body$1 && typeof body$1.read === "function") body$1.read(0);
	let contentLength = util$i.bodyLength(body$1);
	if (contentLength == null) contentLength = request$4.contentLength;
	if (contentLength === 0 || !expectsPayload) contentLength = null;
	if (shouldSendContentLength(method) && contentLength > 0 && request$4.contentLength != null && request$4.contentLength !== contentLength) {
		if (client$1[kStrictContentLength$1]) {
			util$i.errorRequest(client$1, request$4, new RequestContentLengthMismatchError());
			return false;
		}
		process.emitWarning(new RequestContentLengthMismatchError());
	}
	if (contentLength != null) {
		assert$a(body$1, "no body must not have content length");
		headers$1[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
	}
	session.ref();
	const shouldEndStream = method === "GET" || method === "HEAD" || body$1 === null;
	if (expectContinue) {
		headers$1[HTTP2_HEADER_EXPECT] = "100-continue";
		stream$4 = session.request(headers$1, {
			endStream: shouldEndStream,
			signal
		});
		stream$4.once("continue", writeBodyH2);
	} else {
		stream$4 = session.request(headers$1, {
			endStream: shouldEndStream,
			signal
		});
		writeBodyH2();
	}
	++session[kOpenStreams];
	stream$4.once("response", (headers$2) => {
		const { [HTTP2_HEADER_STATUS]: statusCode,...realHeaders } = headers$2;
		request$4.onResponseStarted();
		if (request$4.aborted) {
			const err = new RequestAbortedError$6();
			util$i.errorRequest(client$1, request$4, err);
			util$i.destroy(stream$4, err);
			return;
		}
		if (request$4.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream$4.resume.bind(stream$4), "") === false) stream$4.pause();
		stream$4.on("data", (chunk) => {
			if (request$4.onData(chunk) === false) stream$4.pause();
		});
	});
	stream$4.once("end", () => {
		if (stream$4.state?.state == null || stream$4.state.state < 6) {
			request$4.onComplete([]);
			return;
		}
		if (session[kOpenStreams] === 0) session.unref();
		abort$1(new InformationalError$1("HTTP/2: stream half-closed (remote)"));
	});
	stream$4.once("close", () => {
		session[kOpenStreams] -= 1;
		if (session[kOpenStreams] === 0) session.unref();
	});
	stream$4.once("error", function(err) {
		abort$1(err);
	});
	stream$4.once("frameError", (type, code) => {
		abort$1(new InformationalError$1(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
	});
	return true;
	function writeBodyH2() {
		if (!body$1 || contentLength === 0) writeBuffer(abort$1, stream$4, null, client$1, request$4, client$1[kSocket], contentLength, expectsPayload);
else if (util$i.isBuffer(body$1)) writeBuffer(abort$1, stream$4, body$1, client$1, request$4, client$1[kSocket], contentLength, expectsPayload);
else if (util$i.isBlobLike(body$1)) if (typeof body$1.stream === "function") writeIterable(abort$1, stream$4, body$1.stream(), client$1, request$4, client$1[kSocket], contentLength, expectsPayload);
else writeBlob(abort$1, stream$4, body$1, client$1, request$4, client$1[kSocket], contentLength, expectsPayload);
else if (util$i.isStream(body$1)) writeStream(abort$1, client$1[kSocket], expectsPayload, stream$4, body$1, client$1, request$4, contentLength);
else if (util$i.isIterable(body$1)) writeIterable(abort$1, stream$4, body$1, client$1, request$4, client$1[kSocket], contentLength, expectsPayload);
else assert$a(false);
	}
}
function writeBuffer(abort$1, h2stream, body$1, client$1, request$4, socket, contentLength, expectsPayload) {
	try {
		if (body$1 != null && util$i.isBuffer(body$1)) {
			assert$a(contentLength === body$1.byteLength, "buffer body must have content length");
			h2stream.cork();
			h2stream.write(body$1);
			h2stream.uncork();
			h2stream.end();
			request$4.onBodySent(body$1);
		}
		if (!expectsPayload) socket[kReset] = true;
		request$4.onRequestSent();
		client$1[kResume$2]();
	} catch (error) {
		abort$1(error);
	}
}
function writeStream(abort$1, socket, expectsPayload, h2stream, body$1, client$1, request$4, contentLength) {
	assert$a(contentLength !== 0 || client$1[kRunning$4] === 0, "stream body cannot be pipelined");
	const pipe = pipeline$2(body$1, h2stream, (err) => {
		if (err) {
			util$i.destroy(pipe, err);
			abort$1(err);
		} else {
			util$i.removeAllListeners(pipe);
			request$4.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
			client$1[kResume$2]();
		}
	});
	util$i.addListener(pipe, "data", onPipeData);
	function onPipeData(chunk) {
		request$4.onBodySent(chunk);
	}
}
async function writeBlob(abort$1, h2stream, body$1, client$1, request$4, socket, contentLength, expectsPayload) {
	assert$a(contentLength === body$1.size, "blob body must have content length");
	try {
		if (contentLength != null && contentLength !== body$1.size) throw new RequestContentLengthMismatchError();
		const buffer = Buffer.from(await body$1.arrayBuffer());
		h2stream.cork();
		h2stream.write(buffer);
		h2stream.uncork();
		h2stream.end();
		request$4.onBodySent(buffer);
		request$4.onRequestSent();
		if (!expectsPayload) socket[kReset] = true;
		client$1[kResume$2]();
	} catch (err) {
		abort$1(err);
	}
}
async function writeIterable(abort$1, h2stream, body$1, client$1, request$4, socket, contentLength, expectsPayload) {
	assert$a(contentLength !== 0 || client$1[kRunning$4] === 0, "iterator body cannot be pipelined");
	let callback = null;
	function onDrain() {
		if (callback) {
			const cb = callback;
			callback = null;
			cb();
		}
	}
	const waitForDrain = () => new Promise((resolve, reject) => {
		assert$a(callback === null);
		if (socket[kError$1]) reject(socket[kError$1]);
else callback = resolve;
	});
	h2stream.on("close", onDrain).on("drain", onDrain);
	try {
		for await (const chunk of body$1) {
			if (socket[kError$1]) throw socket[kError$1];
			const res = h2stream.write(chunk);
			request$4.onBodySent(chunk);
			if (!res) await waitForDrain();
		}
		h2stream.end();
		request$4.onRequestSent();
		if (!expectsPayload) socket[kReset] = true;
		client$1[kResume$2]();
	} catch (err) {
		abort$1(err);
	} finally {
		h2stream.off("close", onDrain).off("drain", onDrain);
	}
}
var clientH2 = connectH2$1;
const util$h = util$n;
const { kBodyUsed } = symbols$4;
const assert$9 = require$$0;
const { InvalidArgumentError: InvalidArgumentError$i } = errors$1;
const EE = require$$8;
const redirectableStatusCodes = [
	300,
	301,
	302,
	303,
	307,
	308
];
const kBody$1 = Symbol("body");
var BodyAsyncIterable = class {
	constructor(body$1) {
		this[kBody$1] = body$1;
		this[kBodyUsed] = false;
	}
	async *[Symbol.asyncIterator]() {
		assert$9(!this[kBodyUsed], "disturbed");
		this[kBodyUsed] = true;
		yield* this[kBody$1];
	}
};
let RedirectHandler$3 = class RedirectHandler$4 {
	constructor(dispatch, maxRedirections, opts, handler) {
		if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$i("maxRedirections must be a positive number");
		util$h.validateHandler(handler, opts.method, opts.upgrade);
		this.dispatch = dispatch;
		this.location = null;
		this.abort = null;
		this.opts = {
			...opts,
			maxRedirections: 0
		};
		this.maxRedirections = maxRedirections;
		this.handler = handler;
		this.history = [];
		this.redirectionLimitReached = false;
		if (util$h.isStream(this.opts.body)) {
			if (util$h.bodyLength(this.opts.body) === 0) this.opts.body.on("data", function() {
				assert$9(false);
			});
			if (typeof this.opts.body.readableDidRead !== "boolean") {
				this.opts.body[kBodyUsed] = false;
				EE.prototype.on.call(this.opts.body, "data", function() {
					this[kBodyUsed] = true;
				});
			}
		} else if (this.opts.body && typeof this.opts.body.pipeTo === "function") this.opts.body = new BodyAsyncIterable(this.opts.body);
else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util$h.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
	}
	onConnect(abort$1) {
		this.abort = abort$1;
		this.handler.onConnect(abort$1, { history: this.history });
	}
	onUpgrade(statusCode, headers$1, socket) {
		this.handler.onUpgrade(statusCode, headers$1, socket);
	}
	onError(error) {
		this.handler.onError(error);
	}
	onHeaders(statusCode, headers$1, resume$1, statusText) {
		this.location = this.history.length >= this.maxRedirections || util$h.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers$1);
		if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
			if (this.request) this.request.abort(new Error("max redirects"));
			this.redirectionLimitReached = true;
			this.abort(new Error("max redirects"));
			return;
		}
		if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
		if (!this.location) return this.handler.onHeaders(statusCode, headers$1, resume$1, statusText);
		const { origin, pathname, search } = util$h.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
		const path$1 = search ? `${pathname}${search}` : pathname;
		this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
		this.opts.path = path$1;
		this.opts.origin = origin;
		this.opts.maxRedirections = 0;
		this.opts.query = null;
		if (statusCode === 303 && this.opts.method !== "HEAD") {
			this.opts.method = "GET";
			this.opts.body = null;
		}
	}
	onData(chunk) {
		if (this.location);
else return this.handler.onData(chunk);
	}
	onComplete(trailers) {
		if (this.location) {
			this.location = null;
			this.abort = null;
			this.dispatch(this.opts, this);
		} else this.handler.onComplete(trailers);
	}
	onBodySent(chunk) {
		if (this.handler.onBodySent) this.handler.onBodySent(chunk);
	}
};
function parseLocation(statusCode, headers$1) {
	if (redirectableStatusCodes.indexOf(statusCode) === -1) return null;
	for (let i = 0; i < headers$1.length; i += 2) if (headers$1[i].length === 8 && util$h.headerNameToString(headers$1[i]) === "location") return headers$1[i + 1];
}
function shouldRemoveHeader(header, removeContent, unknownOrigin) {
	if (header.length === 4) return util$h.headerNameToString(header) === "host";
	if (removeContent && util$h.headerNameToString(header).startsWith("content-")) return true;
	if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
		const name = util$h.headerNameToString(header);
		return name === "authorization" || name === "cookie" || name === "proxy-authorization";
	}
	return false;
}
function cleanRequestHeaders(headers$1, removeContent, unknownOrigin) {
	const ret = [];
	if (Array.isArray(headers$1)) {
		for (let i = 0; i < headers$1.length; i += 2) if (!shouldRemoveHeader(headers$1[i], removeContent, unknownOrigin)) ret.push(headers$1[i], headers$1[i + 1]);
	} else if (headers$1 && typeof headers$1 === "object") {
		for (const key of Object.keys(headers$1)) if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers$1[key]);
	} else assert$9(headers$1 == null, "headers must be an object or an array");
	return ret;
}
var redirectHandler = RedirectHandler$3;
const RedirectHandler$2 = redirectHandler;
function createRedirectInterceptor$3({ maxRedirections: defaultMaxRedirections }) {
	return (dispatch) => {
		return function Intercept(opts, handler) {
			const { maxRedirections = defaultMaxRedirections } = opts;
			if (!maxRedirections) return dispatch(opts, handler);
			const redirectHandler$1 = new RedirectHandler$2(dispatch, maxRedirections, opts, handler);
			opts = {
				...opts,
				maxRedirections: 0
			};
			return dispatch(opts, redirectHandler$1);
		};
	};
}
var redirectInterceptor = createRedirectInterceptor$3;
const assert$8 = require$$0;
const net = require$$4;
const http = require$$2;
const util$g = util$n;
const { channels } = diagnostics;
const Request$1 = request$3;
const DispatcherBase$4 = dispatcherBase;
const { InvalidArgumentError: InvalidArgumentError$h, InformationalError, ClientDestroyedError } = errors$1;
const buildConnector$3 = connect$3;
const { kUrl: kUrl$3, kServerName, kClient: kClient$1, kBusy: kBusy$1, kConnect, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$3, kQueue: kQueue$1, kConnected: kConnected$4, kConnecting, kNeedDrain: kNeedDrain$3, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$6, kDestroy: kDestroy$4, kDispatch: kDispatch$3, kInterceptors: kInterceptors$4, kLocalAddress, kMaxResponseSize, kOnError, kHTTPContext, kMaxConcurrentStreams, kResume: kResume$1 } = symbols$4;
const connectH1 = clientH1;
const connectH2 = clientH2;
let deprecatedInterceptorWarned = false;
const kClosedResolve$1 = Symbol("kClosedResolve");
function getPipelining(client$1) {
	return client$1[kPipelining] ?? client$1[kHTTPContext]?.defaultPipelining ?? 1;
}
/**
* @type {import('../../types/client.js').default}
*/
let Client$4 = class Client$5 extends DispatcherBase$4 {
	/**
	*
	* @param {string|URL} url
	* @param {import('../../types/client.js').Client.Options} options
	*/
	constructor(url$1, { interceptors: interceptors$1, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls: tls$1, strictContentLength, maxCachedSessions, maxRedirections, connect: connect$4, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, maxConcurrentStreams, allowH2 } = {}) {
		super();
		if (keepAlive !== undefined) throw new InvalidArgumentError$h("unsupported keepAlive, use pipelining=0 instead");
		if (socketTimeout !== undefined) throw new InvalidArgumentError$h("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
		if (requestTimeout !== undefined) throw new InvalidArgumentError$h("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
		if (idleTimeout !== undefined) throw new InvalidArgumentError$h("unsupported idleTimeout, use keepAliveTimeout instead");
		if (maxKeepAliveTimeout !== undefined) throw new InvalidArgumentError$h("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
		if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError$h("invalid maxHeaderSize");
		if (socketPath != null && typeof socketPath !== "string") throw new InvalidArgumentError$h("invalid socketPath");
		if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError$h("invalid connectTimeout");
		if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError$h("invalid keepAliveTimeout");
		if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError$h("invalid keepAliveMaxTimeout");
		if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError$h("invalid keepAliveTimeoutThreshold");
		if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$h("headersTimeout must be a positive integer or zero");
		if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$h("bodyTimeout must be a positive integer or zero");
		if (connect$4 != null && typeof connect$4 !== "function" && typeof connect$4 !== "object") throw new InvalidArgumentError$h("connect must be a function or an object");
		if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$h("maxRedirections must be a positive number");
		if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError$h("maxRequestsPerClient must be a positive number");
		if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) throw new InvalidArgumentError$h("localAddress must be valid string IP address");
		if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError$h("maxResponseSize must be a positive number");
		if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError$h("autoSelectFamilyAttemptTimeout must be a positive number");
		if (allowH2 != null && typeof allowH2 !== "boolean") throw new InvalidArgumentError$h("allowH2 must be a valid boolean value");
		if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) throw new InvalidArgumentError$h("maxConcurrentStreams must be a positive integer, greater than 0");
		if (typeof connect$4 !== "function") connect$4 = buildConnector$3({
			...tls$1,
			maxCachedSessions,
			allowH2,
			socketPath,
			timeout: connectTimeout,
			...autoSelectFamily ? {
				autoSelectFamily,
				autoSelectFamilyAttemptTimeout
			} : undefined,
			...connect$4
		});
		if (interceptors$1?.Client && Array.isArray(interceptors$1.Client)) {
			this[kInterceptors$4] = interceptors$1.Client;
			if (!deprecatedInterceptorWarned) {
				deprecatedInterceptorWarned = true;
				process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", { code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED" });
			}
		} else this[kInterceptors$4] = [createRedirectInterceptor$2({ maxRedirections })];
		this[kUrl$3] = util$g.parseOrigin(url$1);
		this[kConnector] = connect$4;
		this[kPipelining] = pipelining != null ? pipelining : 1;
		this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
		this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
		this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
		this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
		this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
		this[kServerName] = null;
		this[kLocalAddress] = localAddress != null ? localAddress : null;
		this[kResuming] = 0;
		this[kNeedDrain$3] = 0;
		this[kHostHeader] = `host: ${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}\r\n`;
		this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
		this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
		this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
		this[kMaxRedirections$1] = maxRedirections;
		this[kMaxRequests] = maxRequestsPerClient;
		this[kClosedResolve$1] = null;
		this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
		this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
		this[kHTTPContext] = null;
		this[kQueue$1] = [];
		this[kRunningIdx] = 0;
		this[kPendingIdx] = 0;
		this[kResume$1] = (sync) => resume(this, sync);
		this[kOnError] = (err) => onError(this, err);
	}
	get pipelining() {
		return this[kPipelining];
	}
	set pipelining(value) {
		this[kPipelining] = value;
		this[kResume$1](true);
	}
	get [kPending$2]() {
		return this[kQueue$1].length - this[kPendingIdx];
	}
	get [kRunning$3]() {
		return this[kPendingIdx] - this[kRunningIdx];
	}
	get [kSize$3]() {
		return this[kQueue$1].length - this[kRunningIdx];
	}
	get [kConnected$4]() {
		return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
	}
	get [kBusy$1]() {
		return Boolean(this[kHTTPContext]?.busy(null) || this[kSize$3] >= (getPipelining(this) || 1) || this[kPending$2] > 0);
	}
	[kConnect](cb) {
		connect$2(this);
		this.once("connect", cb);
	}
	[kDispatch$3](opts, handler) {
		const origin = opts.origin || this[kUrl$3].origin;
		const request$4 = new Request$1(origin, opts, handler);
		this[kQueue$1].push(request$4);
		if (this[kResuming]);
else if (util$g.bodyLength(request$4.body) == null && util$g.isIterable(request$4.body)) {
			this[kResuming] = 1;
			queueMicrotask(() => resume(this));
		} else this[kResume$1](true);
		if (this[kResuming] && this[kNeedDrain$3] !== 2 && this[kBusy$1]) this[kNeedDrain$3] = 2;
		return this[kNeedDrain$3] < 2;
	}
	async [kClose$6]() {
		return new Promise((resolve) => {
			if (this[kSize$3]) this[kClosedResolve$1] = resolve;
else resolve(null);
		});
	}
	async [kDestroy$4](err) {
		return new Promise((resolve) => {
			const requests = this[kQueue$1].splice(this[kPendingIdx]);
			for (let i = 0; i < requests.length; i++) {
				const request$4 = requests[i];
				util$g.errorRequest(this, request$4, err);
			}
			const callback = () => {
				if (this[kClosedResolve$1]) {
					this[kClosedResolve$1]();
					this[kClosedResolve$1] = null;
				}
				resolve(null);
			};
			if (this[kHTTPContext]) {
				this[kHTTPContext].destroy(err, callback);
				this[kHTTPContext] = null;
			} else queueMicrotask(callback);
			this[kResume$1]();
		});
	}
};
const createRedirectInterceptor$2 = redirectInterceptor;
function onError(client$1, err) {
	if (client$1[kRunning$3] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
		assert$8(client$1[kPendingIdx] === client$1[kRunningIdx]);
		const requests = client$1[kQueue$1].splice(client$1[kRunningIdx]);
		for (let i = 0; i < requests.length; i++) {
			const request$4 = requests[i];
			util$g.errorRequest(client$1, request$4, err);
		}
		assert$8(client$1[kSize$3] === 0);
	}
}
async function connect$2(client$1) {
	assert$8(!client$1[kConnecting]);
	assert$8(!client$1[kHTTPContext]);
	let { host, hostname, protocol, port } = client$1[kUrl$3];
	if (hostname[0] === "[") {
		const idx = hostname.indexOf("]");
		assert$8(idx !== -1);
		const ip = hostname.substring(1, idx);
		assert$8(net.isIP(ip));
		hostname = ip;
	}
	client$1[kConnecting] = true;
	if (channels.beforeConnect.hasSubscribers) channels.beforeConnect.publish({
		connectParams: {
			host,
			hostname,
			protocol,
			port,
			version: client$1[kHTTPContext]?.version,
			servername: client$1[kServerName],
			localAddress: client$1[kLocalAddress]
		},
		connector: client$1[kConnector]
	});
	try {
		const socket = await new Promise((resolve, reject) => {
			client$1[kConnector]({
				host,
				hostname,
				protocol,
				port,
				servername: client$1[kServerName],
				localAddress: client$1[kLocalAddress]
			}, (err, socket$1) => {
				if (err) reject(err);
else resolve(socket$1);
			});
		});
		if (client$1.destroyed) {
			util$g.destroy(socket.on("error", () => {}), new ClientDestroyedError());
			return;
		}
		assert$8(socket);
		try {
			client$1[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client$1, socket) : await connectH1(client$1, socket);
		} catch (err) {
			socket.destroy().on("error", () => {});
			throw err;
		}
		client$1[kConnecting] = false;
		socket[kCounter] = 0;
		socket[kMaxRequests] = client$1[kMaxRequests];
		socket[kClient$1] = client$1;
		socket[kError] = null;
		if (channels.connected.hasSubscribers) channels.connected.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port,
				version: client$1[kHTTPContext]?.version,
				servername: client$1[kServerName],
				localAddress: client$1[kLocalAddress]
			},
			connector: client$1[kConnector],
			socket
		});
		client$1.emit("connect", client$1[kUrl$3], [client$1]);
	} catch (err) {
		if (client$1.destroyed) return;
		client$1[kConnecting] = false;
		if (channels.connectError.hasSubscribers) channels.connectError.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port,
				version: client$1[kHTTPContext]?.version,
				servername: client$1[kServerName],
				localAddress: client$1[kLocalAddress]
			},
			connector: client$1[kConnector],
			error: err
		});
		if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
			assert$8(client$1[kRunning$3] === 0);
			while (client$1[kPending$2] > 0 && client$1[kQueue$1][client$1[kPendingIdx]].servername === client$1[kServerName]) {
				const request$4 = client$1[kQueue$1][client$1[kPendingIdx]++];
				util$g.errorRequest(client$1, request$4, err);
			}
		} else onError(client$1, err);
		client$1.emit("connectionError", client$1[kUrl$3], [client$1], err);
	}
	client$1[kResume$1]();
}
function emitDrain(client$1) {
	client$1[kNeedDrain$3] = 0;
	client$1.emit("drain", client$1[kUrl$3], [client$1]);
}
function resume(client$1, sync) {
	if (client$1[kResuming] === 2) return;
	client$1[kResuming] = 2;
	_resume(client$1, sync);
	client$1[kResuming] = 0;
	if (client$1[kRunningIdx] > 256) {
		client$1[kQueue$1].splice(0, client$1[kRunningIdx]);
		client$1[kPendingIdx] -= client$1[kRunningIdx];
		client$1[kRunningIdx] = 0;
	}
}
function _resume(client$1, sync) {
	while (true) {
		if (client$1.destroyed) {
			assert$8(client$1[kPending$2] === 0);
			return;
		}
		if (client$1[kClosedResolve$1] && !client$1[kSize$3]) {
			client$1[kClosedResolve$1]();
			client$1[kClosedResolve$1] = null;
			return;
		}
		if (client$1[kHTTPContext]) client$1[kHTTPContext].resume();
		if (client$1[kBusy$1]) client$1[kNeedDrain$3] = 2;
else if (client$1[kNeedDrain$3] === 2) {
			if (sync) {
				client$1[kNeedDrain$3] = 1;
				queueMicrotask(() => emitDrain(client$1));
			} else emitDrain(client$1);
			continue;
		}
		if (client$1[kPending$2] === 0) return;
		if (client$1[kRunning$3] >= (getPipelining(client$1) || 1)) return;
		const request$4 = client$1[kQueue$1][client$1[kPendingIdx]];
		if (client$1[kUrl$3].protocol === "https:" && client$1[kServerName] !== request$4.servername) {
			if (client$1[kRunning$3] > 0) return;
			client$1[kServerName] = request$4.servername;
			client$1[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
				client$1[kHTTPContext] = null;
				resume(client$1);
			});
		}
		if (client$1[kConnecting]) return;
		if (!client$1[kHTTPContext]) {
			connect$2(client$1);
			return;
		}
		if (client$1[kHTTPContext].destroyed) return;
		if (client$1[kHTTPContext].busy(request$4)) return;
		if (!request$4.aborted && client$1[kHTTPContext].write(request$4)) client$1[kPendingIdx]++;
else client$1[kQueue$1].splice(client$1[kPendingIdx], 1);
	}
}
var client = Client$4;
const kSize$2 = 2048;
const kMask = kSize$2 - 1;
var FixedCircularBuffer = class {
	constructor() {
		this.bottom = 0;
		this.top = 0;
		this.list = new Array(kSize$2);
		this.next = null;
	}
	isEmpty() {
		return this.top === this.bottom;
	}
	isFull() {
		return (this.top + 1 & kMask) === this.bottom;
	}
	push(data) {
		this.list[this.top] = data;
		this.top = this.top + 1 & kMask;
	}
	shift() {
		const nextItem = this.list[this.bottom];
		if (nextItem === undefined) return null;
		this.list[this.bottom] = undefined;
		this.bottom = this.bottom + 1 & kMask;
		return nextItem;
	}
};
var fixedQueue = class FixedQueue$1 {
	constructor() {
		this.head = this.tail = new FixedCircularBuffer();
	}
	isEmpty() {
		return this.head.isEmpty();
	}
	push(data) {
		if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
		this.head.push(data);
	}
	shift() {
		const tail = this.tail;
		const next = tail.shift();
		if (tail.isEmpty() && tail.next !== null) this.tail = tail.next;
		return next;
	}
};
const { kFree: kFree$1, kConnected: kConnected$3, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$1 } = symbols$4;
const kPool = Symbol("pool");
let PoolStats$1 = class PoolStats$2 {
	constructor(pool$1) {
		this[kPool] = pool$1;
	}
	get connected() {
		return this[kPool][kConnected$3];
	}
	get free() {
		return this[kPool][kFree$1];
	}
	get pending() {
		return this[kPool][kPending$1];
	}
	get queued() {
		return this[kPool][kQueued$1];
	}
	get running() {
		return this[kPool][kRunning$2];
	}
	get size() {
		return this[kPool][kSize$1];
	}
};
var poolStats = PoolStats$1;
const DispatcherBase$3 = dispatcherBase;
const FixedQueue = fixedQueue;
const { kConnected: kConnected$2, kSize, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$2, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2 } = symbols$4;
const PoolStats = poolStats;
const kClients$4 = Symbol("clients");
const kNeedDrain$2 = Symbol("needDrain");
const kQueue = Symbol("queue");
const kClosedResolve = Symbol("closed resolve");
const kOnDrain$1 = Symbol("onDrain");
const kOnConnect$1 = Symbol("onConnect");
const kOnDisconnect$1 = Symbol("onDisconnect");
const kOnConnectionError$1 = Symbol("onConnectionError");
const kGetDispatcher$2 = Symbol("get dispatcher");
const kAddClient$2 = Symbol("add client");
const kRemoveClient$1 = Symbol("remove client");
const kStats = Symbol("stats");
let PoolBase$2 = class PoolBase$3 extends DispatcherBase$3 {
	constructor() {
		super();
		this[kQueue] = new FixedQueue();
		this[kClients$4] = [];
		this[kQueued] = 0;
		const pool$1 = this;
		this[kOnDrain$1] = function onDrain(origin, targets) {
			const queue = pool$1[kQueue];
			let needDrain = false;
			while (!needDrain) {
				const item = queue.shift();
				if (!item) break;
				pool$1[kQueued]--;
				needDrain = !this.dispatch(item.opts, item.handler);
			}
			this[kNeedDrain$2] = needDrain;
			if (!this[kNeedDrain$2] && pool$1[kNeedDrain$2]) {
				pool$1[kNeedDrain$2] = false;
				pool$1.emit("drain", origin, [pool$1, ...targets]);
			}
			if (pool$1[kClosedResolve] && queue.isEmpty()) Promise.all(pool$1[kClients$4].map((c) => c.close())).then(pool$1[kClosedResolve]);
		};
		this[kOnConnect$1] = (origin, targets) => {
			pool$1.emit("connect", origin, [pool$1, ...targets]);
		};
		this[kOnDisconnect$1] = (origin, targets, err) => {
			pool$1.emit("disconnect", origin, [pool$1, ...targets], err);
		};
		this[kOnConnectionError$1] = (origin, targets, err) => {
			pool$1.emit("connectionError", origin, [pool$1, ...targets], err);
		};
		this[kStats] = new PoolStats(this);
	}
	get [kBusy]() {
		return this[kNeedDrain$2];
	}
	get [kConnected$2]() {
		return this[kClients$4].filter((client$1) => client$1[kConnected$2]).length;
	}
	get [kFree]() {
		return this[kClients$4].filter((client$1) => client$1[kConnected$2] && !client$1[kNeedDrain$2]).length;
	}
	get [kPending]() {
		let ret = this[kQueued];
		for (const { [kPending]: pending } of this[kClients$4]) ret += pending;
		return ret;
	}
	get [kRunning$1]() {
		let ret = 0;
		for (const { [kRunning$1]: running } of this[kClients$4]) ret += running;
		return ret;
	}
	get [kSize]() {
		let ret = this[kQueued];
		for (const { [kSize]: size } of this[kClients$4]) ret += size;
		return ret;
	}
	get stats() {
		return this[kStats];
	}
	async [kClose$5]() {
		if (this[kQueue].isEmpty()) return Promise.all(this[kClients$4].map((c) => c.close()));
else return new Promise((resolve) => {
			this[kClosedResolve] = resolve;
		});
	}
	async [kDestroy$3](err) {
		while (true) {
			const item = this[kQueue].shift();
			if (!item) break;
			item.handler.onError(err);
		}
		return Promise.all(this[kClients$4].map((c) => c.destroy(err)));
	}
	[kDispatch$2](opts, handler) {
		const dispatcher$1 = this[kGetDispatcher$2]();
		if (!dispatcher$1) {
			this[kNeedDrain$2] = true;
			this[kQueue].push({
				opts,
				handler
			});
			this[kQueued]++;
		} else if (!dispatcher$1.dispatch(opts, handler)) {
			dispatcher$1[kNeedDrain$2] = true;
			this[kNeedDrain$2] = !this[kGetDispatcher$2]();
		}
		return !this[kNeedDrain$2];
	}
	[kAddClient$2](client$1) {
		client$1.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]);
		this[kClients$4].push(client$1);
		if (this[kNeedDrain$2]) queueMicrotask(() => {
			if (this[kNeedDrain$2]) this[kOnDrain$1](client$1[kUrl$2], [this, client$1]);
		});
		return this;
	}
	[kRemoveClient$1](client$1) {
		client$1.close(() => {
			const idx = this[kClients$4].indexOf(client$1);
			if (idx !== -1) this[kClients$4].splice(idx, 1);
		});
		this[kNeedDrain$2] = this[kClients$4].some((dispatcher$1) => !dispatcher$1[kNeedDrain$2] && dispatcher$1.closed !== true && dispatcher$1.destroyed !== true);
	}
};
var poolBase = {
	PoolBase: PoolBase$2,
	kClients: kClients$4,
	kNeedDrain: kNeedDrain$2,
	kAddClient: kAddClient$2,
	kRemoveClient: kRemoveClient$1,
	kGetDispatcher: kGetDispatcher$2
};
const { PoolBase: PoolBase$1, kClients: kClients$3, kNeedDrain: kNeedDrain$1, kAddClient: kAddClient$1, kGetDispatcher: kGetDispatcher$1 } = poolBase;
const Client$3 = client;
const { InvalidArgumentError: InvalidArgumentError$g } = errors$1;
const util$f = util$n;
const { kUrl: kUrl$1, kInterceptors: kInterceptors$3 } = symbols$4;
const buildConnector$2 = connect$3;
const kOptions$3 = Symbol("options");
const kConnections = Symbol("connections");
const kFactory$3 = Symbol("factory");
function defaultFactory$3(origin, opts) {
	return new Client$3(origin, opts);
}
let Pool$5 = class Pool$6 extends PoolBase$1 {
	constructor(origin, { connections, factory = defaultFactory$3, connect: connect$4, connectTimeout, tls: tls$1, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2,...options } = {}) {
		super();
		if (connections != null && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError$g("invalid connections");
		if (typeof factory !== "function") throw new InvalidArgumentError$g("factory must be a function.");
		if (connect$4 != null && typeof connect$4 !== "function" && typeof connect$4 !== "object") throw new InvalidArgumentError$g("connect must be a function or an object");
		if (typeof connect$4 !== "function") connect$4 = buildConnector$2({
			...tls$1,
			maxCachedSessions,
			allowH2,
			socketPath,
			timeout: connectTimeout,
			...autoSelectFamily ? {
				autoSelectFamily,
				autoSelectFamilyAttemptTimeout
			} : undefined,
			...connect$4
		});
		this[kInterceptors$3] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
		this[kConnections] = connections || null;
		this[kUrl$1] = util$f.parseOrigin(origin);
		this[kOptions$3] = {
			...util$f.deepClone(options),
			connect: connect$4,
			allowH2
		};
		this[kOptions$3].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
		this[kFactory$3] = factory;
	}
	[kGetDispatcher$1]() {
		for (const client$1 of this[kClients$3]) if (!client$1[kNeedDrain$1]) return client$1;
		if (!this[kConnections] || this[kClients$3].length < this[kConnections]) {
			const dispatcher$1 = this[kFactory$3](this[kUrl$1], this[kOptions$3]);
			this[kAddClient$1](dispatcher$1);
			return dispatcher$1;
		}
	}
};
var pool = Pool$5;
const { BalancedPoolMissingUpstreamError, InvalidArgumentError: InvalidArgumentError$f } = errors$1;
const { PoolBase, kClients: kClients$2, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = poolBase;
const Pool$4 = pool;
const { kUrl, kInterceptors: kInterceptors$2 } = symbols$4;
const { parseOrigin } = util$n;
const kFactory$2 = Symbol("factory");
const kOptions$2 = Symbol("options");
const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
const kCurrentWeight = Symbol("kCurrentWeight");
const kIndex = Symbol("kIndex");
const kWeight = Symbol("kWeight");
const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
const kErrorPenalty = Symbol("kErrorPenalty");
function getGreatestCommonDivisor(a, b) {
	if (b === 0) return a;
	return getGreatestCommonDivisor(b, a % b);
}
function defaultFactory$2(origin, opts) {
	return new Pool$4(origin, opts);
}
let BalancedPool$1 = class BalancedPool$2 extends PoolBase {
	constructor(upstreams = [], { factory = defaultFactory$2,...opts } = {}) {
		super();
		this[kOptions$2] = opts;
		this[kIndex] = -1;
		this[kCurrentWeight] = 0;
		this[kMaxWeightPerServer] = this[kOptions$2].maxWeightPerServer || 100;
		this[kErrorPenalty] = this[kOptions$2].errorPenalty || 15;
		if (!Array.isArray(upstreams)) upstreams = [upstreams];
		if (typeof factory !== "function") throw new InvalidArgumentError$f("factory must be a function.");
		this[kInterceptors$2] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
		this[kFactory$2] = factory;
		for (const upstream of upstreams) this.addUpstream(upstream);
		this._updateBalancedPoolStats();
	}
	addUpstream(upstream) {
		const upstreamOrigin = parseOrigin(upstream).origin;
		if (this[kClients$2].find((pool$2) => pool$2[kUrl].origin === upstreamOrigin && pool$2.closed !== true && pool$2.destroyed !== true)) return this;
		const pool$1 = this[kFactory$2](upstreamOrigin, Object.assign({}, this[kOptions$2]));
		this[kAddClient](pool$1);
		pool$1.on("connect", () => {
			pool$1[kWeight] = Math.min(this[kMaxWeightPerServer], pool$1[kWeight] + this[kErrorPenalty]);
		});
		pool$1.on("connectionError", () => {
			pool$1[kWeight] = Math.max(1, pool$1[kWeight] - this[kErrorPenalty]);
			this._updateBalancedPoolStats();
		});
		pool$1.on("disconnect", (...args) => {
			const err = args[2];
			if (err && err.code === "UND_ERR_SOCKET") {
				pool$1[kWeight] = Math.max(1, pool$1[kWeight] - this[kErrorPenalty]);
				this._updateBalancedPoolStats();
			}
		});
		for (const client$1 of this[kClients$2]) client$1[kWeight] = this[kMaxWeightPerServer];
		this._updateBalancedPoolStats();
		return this;
	}
	_updateBalancedPoolStats() {
		this[kGreatestCommonDivisor] = this[kClients$2].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
	}
	removeUpstream(upstream) {
		const upstreamOrigin = parseOrigin(upstream).origin;
		const pool$1 = this[kClients$2].find((pool$2) => pool$2[kUrl].origin === upstreamOrigin && pool$2.closed !== true && pool$2.destroyed !== true);
		if (pool$1) this[kRemoveClient](pool$1);
		return this;
	}
	get upstreams() {
		return this[kClients$2].filter((dispatcher$1) => dispatcher$1.closed !== true && dispatcher$1.destroyed !== true).map((p) => p[kUrl].origin);
	}
	[kGetDispatcher]() {
		if (this[kClients$2].length === 0) throw new BalancedPoolMissingUpstreamError();
		const dispatcher$1 = this[kClients$2].find((dispatcher$2) => !dispatcher$2[kNeedDrain] && dispatcher$2.closed !== true && dispatcher$2.destroyed !== true);
		if (!dispatcher$1) return;
		const allClientsBusy = this[kClients$2].map((pool$1) => pool$1[kNeedDrain]).reduce((a, b) => a && b, true);
		if (allClientsBusy) return;
		let counter = 0;
		let maxWeightIndex = this[kClients$2].findIndex((pool$1) => !pool$1[kNeedDrain]);
		while (counter++ < this[kClients$2].length) {
			this[kIndex] = (this[kIndex] + 1) % this[kClients$2].length;
			const pool$1 = this[kClients$2][this[kIndex]];
			if (pool$1[kWeight] > this[kClients$2][maxWeightIndex][kWeight] && !pool$1[kNeedDrain]) maxWeightIndex = this[kIndex];
			if (this[kIndex] === 0) {
				this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
				if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
			}
			if (pool$1[kWeight] >= this[kCurrentWeight] && !pool$1[kNeedDrain]) return pool$1;
		}
		this[kCurrentWeight] = this[kClients$2][maxWeightIndex][kWeight];
		this[kIndex] = maxWeightIndex;
		return this[kClients$2][maxWeightIndex];
	}
};
var balancedPool = BalancedPool$1;
const { InvalidArgumentError: InvalidArgumentError$e } = errors$1;
const { kClients: kClients$1, kRunning, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1, kInterceptors: kInterceptors$1 } = symbols$4;
const DispatcherBase$2 = dispatcherBase;
const Pool$3 = pool;
const Client$2 = client;
const util$e = util$n;
const createRedirectInterceptor$1 = redirectInterceptor;
const kOnConnect = Symbol("onConnect");
const kOnDisconnect = Symbol("onDisconnect");
const kOnConnectionError = Symbol("onConnectionError");
const kMaxRedirections = Symbol("maxRedirections");
const kOnDrain = Symbol("onDrain");
const kFactory$1 = Symbol("factory");
const kOptions$1 = Symbol("options");
function defaultFactory$1(origin, opts) {
	return opts && opts.connections === 1 ? new Client$2(origin, opts) : new Pool$3(origin, opts);
}
let Agent$5 = class Agent$6 extends DispatcherBase$2 {
	constructor({ factory = defaultFactory$1, maxRedirections = 0, connect: connect$4,...options } = {}) {
		super();
		if (typeof factory !== "function") throw new InvalidArgumentError$e("factory must be a function.");
		if (connect$4 != null && typeof connect$4 !== "function" && typeof connect$4 !== "object") throw new InvalidArgumentError$e("connect must be a function or an object");
		if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError$e("maxRedirections must be a positive number");
		if (connect$4 && typeof connect$4 !== "function") connect$4 = { ...connect$4 };
		this[kInterceptors$1] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor$1({ maxRedirections })];
		this[kOptions$1] = {
			...util$e.deepClone(options),
			connect: connect$4
		};
		this[kOptions$1].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
		this[kMaxRedirections] = maxRedirections;
		this[kFactory$1] = factory;
		this[kClients$1] = new Map();
		this[kOnDrain] = (origin, targets) => {
			this.emit("drain", origin, [this, ...targets]);
		};
		this[kOnConnect] = (origin, targets) => {
			this.emit("connect", origin, [this, ...targets]);
		};
		this[kOnDisconnect] = (origin, targets, err) => {
			this.emit("disconnect", origin, [this, ...targets], err);
		};
		this[kOnConnectionError] = (origin, targets, err) => {
			this.emit("connectionError", origin, [this, ...targets], err);
		};
	}
	get [kRunning]() {
		let ret = 0;
		for (const client$1 of this[kClients$1].values()) ret += client$1[kRunning];
		return ret;
	}
	[kDispatch$1](opts, handler) {
		let key;
		if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) key = String(opts.origin);
else throw new InvalidArgumentError$e("opts.origin must be a non-empty string or URL.");
		let dispatcher$1 = this[kClients$1].get(key);
		if (!dispatcher$1) {
			dispatcher$1 = this[kFactory$1](opts.origin, this[kOptions$1]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
			this[kClients$1].set(key, dispatcher$1);
		}
		return dispatcher$1.dispatch(opts, handler);
	}
	async [kClose$4]() {
		const closePromises = [];
		for (const client$1 of this[kClients$1].values()) closePromises.push(client$1.close());
		this[kClients$1].clear();
		await Promise.all(closePromises);
	}
	async [kDestroy$2](err) {
		const destroyPromises = [];
		for (const client$1 of this[kClients$1].values()) destroyPromises.push(client$1.destroy(err));
		this[kClients$1].clear();
		await Promise.all(destroyPromises);
	}
};
var agent$1 = Agent$5;
const { kProxy, kClose: kClose$3, kDestroy: kDestroy$1, kInterceptors } = symbols$4;
const { URL: URL$1 } = url;
const Agent$4 = agent$1;
const Pool$2 = pool;
const DispatcherBase$1 = dispatcherBase;
const { InvalidArgumentError: InvalidArgumentError$d, RequestAbortedError: RequestAbortedError$5, SecureProxyConnectionError } = errors$1;
const buildConnector$1 = connect$3;
const kAgent$1 = Symbol("proxy agent");
const kClient = Symbol("proxy client");
const kProxyHeaders = Symbol("proxy headers");
const kRequestTls = Symbol("request tls settings");
const kProxyTls = Symbol("proxy tls settings");
const kConnectEndpoint = Symbol("connect endpoint function");
function defaultProtocolPort(protocol) {
	return protocol === "https:" ? 443 : 80;
}
function defaultFactory(origin, opts) {
	return new Pool$2(origin, opts);
}
let ProxyAgent$2 = class ProxyAgent$3 extends DispatcherBase$1 {
	constructor(opts) {
		super();
		if (!opts || typeof opts === "object" && !(opts instanceof URL$1) && !opts.uri) throw new InvalidArgumentError$d("Proxy uri is mandatory");
		const { clientFactory = defaultFactory } = opts;
		if (typeof clientFactory !== "function") throw new InvalidArgumentError$d("Proxy opts.clientFactory must be a function.");
		const url$1 = this.#getUrl(opts);
		const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url$1;
		this[kProxy] = {
			uri: href,
			protocol
		};
		this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
		this[kRequestTls] = opts.requestTls;
		this[kProxyTls] = opts.proxyTls;
		this[kProxyHeaders] = opts.headers || {};
		if (opts.auth && opts.token) throw new InvalidArgumentError$d("opts.auth cannot be used in combination with opts.token");
else if (opts.auth) this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
else if (opts.token) this[kProxyHeaders]["proxy-authorization"] = opts.token;
else if (username && password) this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
		const connect$4 = buildConnector$1({ ...opts.proxyTls });
		this[kConnectEndpoint] = buildConnector$1({ ...opts.requestTls });
		this[kClient] = clientFactory(url$1, { connect: connect$4 });
		this[kAgent$1] = new Agent$4({
			...opts,
			connect: async (opts$1, callback) => {
				let requestedPath = opts$1.host;
				if (!opts$1.port) requestedPath += `:${defaultProtocolPort(opts$1.protocol)}`;
				try {
					const { socket, statusCode } = await this[kClient].connect({
						origin,
						port,
						path: requestedPath,
						signal: opts$1.signal,
						headers: {
							...this[kProxyHeaders],
							host: opts$1.host
						},
						servername: this[kProxyTls]?.servername || proxyHostname
					});
					if (statusCode !== 200) {
						socket.on("error", () => {}).destroy();
						callback(new RequestAbortedError$5(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
					}
					if (opts$1.protocol !== "https:") {
						callback(null, socket);
						return;
					}
					let servername;
					if (this[kRequestTls]) servername = this[kRequestTls].servername;
else servername = opts$1.servername;
					this[kConnectEndpoint]({
						...opts$1,
						servername,
						httpSocket: socket
					}, callback);
				} catch (err) {
					if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") callback(new SecureProxyConnectionError(err));
else callback(err);
				}
			}
		});
	}
	dispatch(opts, handler) {
		const headers$1 = buildHeaders(opts.headers);
		throwIfProxyAuthIsSent(headers$1);
		if (headers$1 && !("host" in headers$1) && !("Host" in headers$1)) {
			const { host } = new URL$1(opts.origin);
			headers$1.host = host;
		}
		return this[kAgent$1].dispatch({
			...opts,
			headers: headers$1
		}, handler);
	}
	/**
	* @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
	* @returns {URL}
	*/
	#getUrl(opts) {
		if (typeof opts === "string") return new URL$1(opts);
else if (opts instanceof URL$1) return opts;
else return new URL$1(opts.uri);
	}
	async [kClose$3]() {
		await this[kAgent$1].close();
		await this[kClient].close();
	}
	async [kDestroy$1]() {
		await this[kAgent$1].destroy();
		await this[kClient].destroy();
	}
};
/**
* @param {string[] | Record<string, string>} headers
* @returns {Record<string, string>}
*/
function buildHeaders(headers$1) {
	if (Array.isArray(headers$1)) {
		/** @type {Record<string, string>} */
		const headersPair = {};
		for (let i = 0; i < headers$1.length; i += 2) headersPair[headers$1[i]] = headers$1[i + 1];
		return headersPair;
	}
	return headers$1;
}
/**
* @param {Record<string, string>} headers
*
* Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
* Nevertheless, it was changed and to avoid a security vulnerability by end users
* this check was created.
* It should be removed in the next major version for performance reasons
*/
function throwIfProxyAuthIsSent(headers$1) {
	const existProxyAuth = headers$1 && Object.keys(headers$1).find((key) => key.toLowerCase() === "proxy-authorization");
	if (existProxyAuth) throw new InvalidArgumentError$d("Proxy-Authorization should be sent in ProxyAgent constructor");
}
var proxyAgent = ProxyAgent$2;
const DispatcherBase = dispatcherBase;
const { kClose: kClose$2, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = symbols$4;
const ProxyAgent$1 = proxyAgent;
const Agent$3 = agent$1;
const DEFAULT_PORTS = {
	"http:": 80,
	"https:": 443
};
let experimentalWarned = false;
let EnvHttpProxyAgent$1 = class EnvHttpProxyAgent$2 extends DispatcherBase {
	#noProxyValue = null;
	#noProxyEntries = null;
	#opts = null;
	constructor(opts = {}) {
		super();
		this.#opts = opts;
		if (!experimentalWarned) {
			experimentalWarned = true;
			process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", { code: "UNDICI-EHPA" });
		}
		const { httpProxy, httpsProxy, noProxy,...agentOpts } = opts;
		this[kNoProxyAgent] = new Agent$3(agentOpts);
		const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
		if (HTTP_PROXY) this[kHttpProxyAgent] = new ProxyAgent$1({
			...agentOpts,
			uri: HTTP_PROXY
		});
else this[kHttpProxyAgent] = this[kNoProxyAgent];
		const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
		if (HTTPS_PROXY) this[kHttpsProxyAgent] = new ProxyAgent$1({
			...agentOpts,
			uri: HTTPS_PROXY
		});
else this[kHttpsProxyAgent] = this[kHttpProxyAgent];
		this.#parseNoProxy();
	}
	[kDispatch](opts, handler) {
		const url$1 = new URL(opts.origin);
		const agent$2 = this.#getProxyAgentForUrl(url$1);
		return agent$2.dispatch(opts, handler);
	}
	async [kClose$2]() {
		await this[kNoProxyAgent].close();
		if (!this[kHttpProxyAgent][kClosed]) await this[kHttpProxyAgent].close();
		if (!this[kHttpsProxyAgent][kClosed]) await this[kHttpsProxyAgent].close();
	}
	async [kDestroy](err) {
		await this[kNoProxyAgent].destroy(err);
		if (!this[kHttpProxyAgent][kDestroyed]) await this[kHttpProxyAgent].destroy(err);
		if (!this[kHttpsProxyAgent][kDestroyed]) await this[kHttpsProxyAgent].destroy(err);
	}
	#getProxyAgentForUrl(url$1) {
		let { protocol, host: hostname, port } = url$1;
		hostname = hostname.replace(/:\d*$/, "").toLowerCase();
		port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
		if (!this.#shouldProxy(hostname, port)) return this[kNoProxyAgent];
		if (protocol === "https:") return this[kHttpsProxyAgent];
		return this[kHttpProxyAgent];
	}
	#shouldProxy(hostname, port) {
		if (this.#noProxyChanged) this.#parseNoProxy();
		if (this.#noProxyEntries.length === 0) return true;
		if (this.#noProxyValue === "*") return false;
		for (let i = 0; i < this.#noProxyEntries.length; i++) {
			const entry = this.#noProxyEntries[i];
			if (entry.port && entry.port !== port) continue;
			if (!/^[.*]/.test(entry.hostname)) {
				if (hostname === entry.hostname) return false;
			} else if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) return false;
		}
		return true;
	}
	#parseNoProxy() {
		const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
		const noProxySplit = noProxyValue.split(/[,\s]/);
		const noProxyEntries = [];
		for (let i = 0; i < noProxySplit.length; i++) {
			const entry = noProxySplit[i];
			if (!entry) continue;
			const parsed = entry.match(/^(.+):(\d+)$/);
			noProxyEntries.push({
				hostname: (parsed ? parsed[1] : entry).toLowerCase(),
				port: parsed ? Number.parseInt(parsed[2], 10) : 0
			});
		}
		this.#noProxyValue = noProxyValue;
		this.#noProxyEntries = noProxyEntries;
	}
	get #noProxyChanged() {
		if (this.#opts.noProxy !== undefined) return false;
		return this.#noProxyValue !== this.#noProxyEnv;
	}
	get #noProxyEnv() {
		return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
	}
};
var envHttpProxyAgent = EnvHttpProxyAgent$1;
const assert$7 = require$$0;
const { kRetryHandlerDefaultRetry } = symbols$4;
const { RequestRetryError } = errors$1;
const { isDisturbed, parseHeaders, parseRangeHeader, wrapRequestBody } = util$n;
function calculateRetryAfterHeader(retryAfter) {
	const current = Date.now();
	return new Date(retryAfter).getTime() - current;
}
let RetryHandler$3 = class RetryHandler$4 {
	constructor(opts, handlers) {
		const { retryOptions,...dispatchOpts } = opts;
		const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
		this.dispatch = handlers.dispatch;
		this.handler = handlers.handler;
		this.opts = {
			...dispatchOpts,
			body: wrapRequestBody(opts.body)
		};
		this.abort = null;
		this.aborted = false;
		this.retryOpts = {
			retry: retryFn ?? RetryHandler$4[kRetryHandlerDefaultRetry],
			retryAfter: retryAfter ?? true,
			maxTimeout: maxTimeout ?? 3e4,
			minTimeout: minTimeout ?? 500,
			timeoutFactor: timeoutFactor ?? 2,
			maxRetries: maxRetries ?? 5,
			methods: methods ?? [
				"GET",
				"HEAD",
				"OPTIONS",
				"PUT",
				"DELETE",
				"TRACE"
			],
			statusCodes: statusCodes ?? [
				500,
				502,
				503,
				504,
				429
			],
			errorCodes: errorCodes ?? [
				"ECONNRESET",
				"ECONNREFUSED",
				"ENOTFOUND",
				"ENETDOWN",
				"ENETUNREACH",
				"EHOSTDOWN",
				"EHOSTUNREACH",
				"EPIPE",
				"UND_ERR_SOCKET"
			]
		};
		this.retryCount = 0;
		this.retryCountCheckpoint = 0;
		this.start = 0;
		this.end = null;
		this.etag = null;
		this.resume = null;
		this.handler.onConnect((reason) => {
			this.aborted = true;
			if (this.abort) this.abort(reason);
else this.reason = reason;
		});
	}
	onRequestSent() {
		if (this.handler.onRequestSent) this.handler.onRequestSent();
	}
	onUpgrade(statusCode, headers$1, socket) {
		if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers$1, socket);
	}
	onConnect(abort$1) {
		if (this.aborted) abort$1(this.reason);
else this.abort = abort$1;
	}
	onBodySent(chunk) {
		if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
	}
	static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
		const { statusCode, code, headers: headers$1 } = err;
		const { method, retryOptions } = opts;
		const { maxRetries, minTimeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
		const { counter } = state;
		if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
			cb(err);
			return;
		}
		if (Array.isArray(methods) && !methods.includes(method)) {
			cb(err);
			return;
		}
		if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
			cb(err);
			return;
		}
		if (counter > maxRetries) {
			cb(err);
			return;
		}
		let retryAfterHeader = headers$1?.["retry-after"];
		if (retryAfterHeader) {
			retryAfterHeader = Number(retryAfterHeader);
			retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
		}
		const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
		setTimeout(() => cb(null), retryTimeout);
	}
	onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
		const headers$1 = parseHeaders(rawHeaders);
		this.retryCount += 1;
		if (statusCode >= 300) if (this.retryOpts.statusCodes.includes(statusCode) === false) return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
else {
			this.abort(new RequestRetryError("Request failed", statusCode, {
				headers: headers$1,
				data: { count: this.retryCount }
			}));
			return false;
		}
		if (this.resume != null) {
			this.resume = null;
			if (statusCode !== 206) return true;
			const contentRange = parseRangeHeader(headers$1["content-range"]);
			if (!contentRange) {
				this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
					headers: headers$1,
					data: { count: this.retryCount }
				}));
				return false;
			}
			if (this.etag != null && this.etag !== headers$1.etag) {
				this.abort(new RequestRetryError("ETag mismatch", statusCode, {
					headers: headers$1,
					data: { count: this.retryCount }
				}));
				return false;
			}
			const { start, size, end = size } = contentRange;
			assert$7(this.start === start, "content-range mismatch");
			assert$7(this.end == null || this.end === end, "content-range mismatch");
			this.resume = resume$1;
			return true;
		}
		if (this.end == null) {
			if (statusCode === 206) {
				const range = parseRangeHeader(headers$1["content-range"]);
				if (range == null) return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
				const { start, size, end = size } = range;
				assert$7(start != null && Number.isFinite(start), "content-range mismatch");
				assert$7(end != null && Number.isFinite(end), "invalid content-length");
				this.start = start;
				this.end = end;
			}
			if (this.end == null) {
				const contentLength = headers$1["content-length"];
				this.end = contentLength != null ? Number(contentLength) : null;
			}
			assert$7(Number.isFinite(this.start));
			assert$7(this.end == null || Number.isFinite(this.end), "invalid content-length");
			this.resume = resume$1;
			this.etag = headers$1.etag != null ? headers$1.etag : null;
			if (this.etag != null && this.etag.startsWith("W/")) this.etag = null;
			return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
		}
		const err = new RequestRetryError("Request failed", statusCode, {
			headers: headers$1,
			data: { count: this.retryCount }
		});
		this.abort(err);
		return false;
	}
	onData(chunk) {
		this.start += chunk.length;
		return this.handler.onData(chunk);
	}
	onComplete(rawTrailers) {
		this.retryCount = 0;
		return this.handler.onComplete(rawTrailers);
	}
	onError(err) {
		if (this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
		if (this.retryCount - this.retryCountCheckpoint > 0) this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
else this.retryCount += 1;
		this.retryOpts.retry(err, {
			state: { counter: this.retryCount },
			opts: {
				retryOptions: this.retryOpts,
				...this.opts
			}
		}, onRetry.bind(this));
		function onRetry(err$1) {
			if (err$1 != null || this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err$1);
			if (this.start !== 0) {
				const headers$1 = { range: `bytes=${this.start}-${this.end ?? ""}` };
				if (this.etag != null) headers$1["if-match"] = this.etag;
				this.opts = {
					...this.opts,
					headers: {
						...this.opts.headers,
						...headers$1
					}
				};
			}
			try {
				this.retryCountCheckpoint = this.retryCount;
				this.dispatch(this.opts, this);
			} catch (err$2) {
				this.handler.onError(err$2);
			}
		}
	}
};
var retryHandler = RetryHandler$3;
const Dispatcher$2 = dispatcher;
const RetryHandler$2 = retryHandler;
let RetryAgent$1 = class RetryAgent$2 extends Dispatcher$2 {
	#agent = null;
	#options = null;
	constructor(agent$2, options = {}) {
		super(options);
		this.#agent = agent$2;
		this.#options = options;
	}
	dispatch(opts, handler) {
		const retry$1 = new RetryHandler$2({
			...opts,
			retryOptions: this.#options
		}, {
			dispatch: this.#agent.dispatch.bind(this.#agent),
			handler
		});
		return this.#agent.dispatch(opts, retry$1);
	}
	close() {
		return this.#agent.close();
	}
	destroy() {
		return this.#agent.destroy();
	}
};
var retryAgent = RetryAgent$1;
var api$1 = {};
var apiRequest = { exports: {} };
const assert$6 = require$$0;
const { Readable: Readable$2 } = stream;
const { RequestAbortedError: RequestAbortedError$4, NotSupportedError, InvalidArgumentError: InvalidArgumentError$c, AbortError } = errors$1;
const util$d = util$n;
const { ReadableStreamFrom } = util$n;
const kConsume = Symbol("kConsume");
const kReading = Symbol("kReading");
const kBody = Symbol("kBody");
const kAbort = Symbol("kAbort");
const kContentType = Symbol("kContentType");
const kContentLength$1 = Symbol("kContentLength");
const noop = () => {};
var BodyReadable = class extends Readable$2 {
	constructor({ resume: resume$1, abort: abort$1, contentType = "", contentLength, highWaterMark = 65536 }) {
		super({
			autoDestroy: true,
			read: resume$1,
			highWaterMark
		});
		this._readableState.dataEmitted = false;
		this[kAbort] = abort$1;
		this[kConsume] = null;
		this[kBody] = null;
		this[kContentType] = contentType;
		this[kContentLength$1] = contentLength;
		this[kReading] = false;
	}
	destroy(err) {
		if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$4();
		if (err) this[kAbort]();
		return super.destroy(err);
	}
	_destroy(err, callback) {
		if (!this[kReading]) setImmediate(() => {
			callback(err);
		});
else callback(err);
	}
	on(ev, ...args) {
		if (ev === "data" || ev === "readable") this[kReading] = true;
		return super.on(ev, ...args);
	}
	addListener(ev, ...args) {
		return this.on(ev, ...args);
	}
	off(ev, ...args) {
		const ret = super.off(ev, ...args);
		if (ev === "data" || ev === "readable") this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
		return ret;
	}
	removeListener(ev, ...args) {
		return this.off(ev, ...args);
	}
	push(chunk) {
		if (this[kConsume] && chunk !== null) {
			consumePush(this[kConsume], chunk);
			return this[kReading] ? super.push(chunk) : true;
		}
		return super.push(chunk);
	}
	async text() {
		return consume(this, "text");
	}
	async json() {
		return consume(this, "json");
	}
	async blob() {
		return consume(this, "blob");
	}
	async arrayBuffer() {
		return consume(this, "arrayBuffer");
	}
	async formData() {
		throw new NotSupportedError();
	}
	get bodyUsed() {
		return util$d.isDisturbed(this);
	}
	get body() {
		if (!this[kBody]) {
			this[kBody] = ReadableStreamFrom(this);
			if (this[kConsume]) {
				this[kBody].getReader();
				assert$6(this[kBody].locked);
			}
		}
		return this[kBody];
	}
	async dump(opts) {
		let limit = Number.isFinite(opts?.limit) ? opts.limit : 131072;
		const signal = opts?.signal;
		if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) throw new InvalidArgumentError$c("signal must be an AbortSignal");
		signal?.throwIfAborted();
		if (this._readableState.closeEmitted) return null;
		return await new Promise((resolve, reject) => {
			if (this[kContentLength$1] > limit) this.destroy(new AbortError());
			const onAbort = () => {
				this.destroy(signal.reason ?? new AbortError());
			};
			signal?.addEventListener("abort", onAbort);
			this.on("close", function() {
				signal?.removeEventListener("abort", onAbort);
				if (signal?.aborted) reject(signal.reason ?? new AbortError());
else resolve(null);
			}).on("error", noop).on("data", function(chunk) {
				limit -= chunk.length;
				if (limit <= 0) this.destroy();
			}).resume();
		});
	}
};
function isLocked(self$1) {
	return self$1[kBody] && self$1[kBody].locked === true || self$1[kConsume];
}
function isUnusable(self$1) {
	return util$d.isDisturbed(self$1) || isLocked(self$1);
}
async function consume(stream$4, type) {
	assert$6(!stream$4[kConsume]);
	return new Promise((resolve, reject) => {
		if (isUnusable(stream$4)) {
			const rState = stream$4._readableState;
			if (rState.destroyed && rState.closeEmitted === false) stream$4.on("error", (err) => {
				reject(err);
			}).on("close", () => {
				reject(new TypeError("unusable"));
			});
else reject(rState.errored ?? new TypeError("unusable"));
		} else queueMicrotask(() => {
			stream$4[kConsume] = {
				type,
				stream: stream$4,
				resolve,
				reject,
				length: 0,
				body: []
			};
			stream$4.on("error", function(err) {
				consumeFinish(this[kConsume], err);
			}).on("close", function() {
				if (this[kConsume].body !== null) consumeFinish(this[kConsume], new RequestAbortedError$4());
			});
			consumeStart(stream$4[kConsume]);
		});
	});
}
function consumeStart(consume$1) {
	if (consume$1.body === null) return;
	const { _readableState: state } = consume$1.stream;
	if (state.bufferIndex) {
		const start = state.bufferIndex;
		const end = state.buffer.length;
		for (let n = start; n < end; n++) consumePush(consume$1, state.buffer[n]);
	} else for (const chunk of state.buffer) consumePush(consume$1, chunk);
	if (state.endEmitted) consumeEnd(this[kConsume]);
else consume$1.stream.on("end", function() {
		consumeEnd(this[kConsume]);
	});
	consume$1.stream.resume();
	while (consume$1.stream.read() != null);
}
/**
* @param {Buffer[]} chunks
* @param {number} length
*/
function chunksDecode$1(chunks, length) {
	if (chunks.length === 0 || length === 0) return "";
	const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
	const bufferLength = buffer.length;
	const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
	return buffer.utf8Slice(start, bufferLength);
}
function consumeEnd(consume$1) {
	const { type, body: body$1, resolve, stream: stream$4, length } = consume$1;
	try {
		if (type === "text") resolve(chunksDecode$1(body$1, length));
else if (type === "json") resolve(JSON.parse(chunksDecode$1(body$1, length)));
else if (type === "arrayBuffer") {
			const dst = new Uint8Array(length);
			let pos = 0;
			for (const buf of body$1) {
				dst.set(buf, pos);
				pos += buf.byteLength;
			}
			resolve(dst.buffer);
		} else if (type === "blob") resolve(new Blob(body$1, { type: stream$4[kContentType] }));
		consumeFinish(consume$1);
	} catch (err) {
		stream$4.destroy(err);
	}
}
function consumePush(consume$1, chunk) {
	consume$1.length += chunk.length;
	consume$1.body.push(chunk);
}
function consumeFinish(consume$1, err) {
	if (consume$1.body === null) return;
	if (err) consume$1.reject(err);
else consume$1.resolve();
	consume$1.type = null;
	consume$1.stream = null;
	consume$1.resolve = null;
	consume$1.reject = null;
	consume$1.length = 0;
	consume$1.body = null;
}
var readable = {
	Readable: BodyReadable,
	chunksDecode: chunksDecode$1
};
const assert$5 = require$$0;
const { ResponseStatusCodeError } = errors$1;
const { chunksDecode } = readable;
const CHUNK_LIMIT = 131072;
async function getResolveErrorBodyCallback$2({ callback, body: body$1, contentType, statusCode, statusMessage, headers: headers$1 }) {
	assert$5(body$1);
	let chunks = [];
	let length = 0;
	try {
		for await (const chunk of body$1) {
			chunks.push(chunk);
			length += chunk.length;
			if (length > CHUNK_LIMIT) {
				chunks = [];
				length = 0;
				break;
			}
		}
	} catch {
		chunks = [];
		length = 0;
	}
	const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`;
	if (statusCode === 204 || !contentType || !length) {
		queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers$1)));
		return;
	}
	const stackTraceLimit = Error.stackTraceLimit;
	Error.stackTraceLimit = 0;
	let payload;
	try {
		if (isContentTypeApplicationJson(contentType)) payload = JSON.parse(chunksDecode(chunks, length));
else if (isContentTypeText(contentType)) payload = chunksDecode(chunks, length);
	} catch {} finally {
		Error.stackTraceLimit = stackTraceLimit;
	}
	queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers$1, payload)));
}
const isContentTypeApplicationJson = (contentType) => {
	return contentType.length > 15 && contentType[11] === "/" && contentType[0] === "a" && contentType[1] === "p" && contentType[2] === "p" && contentType[3] === "l" && contentType[4] === "i" && contentType[5] === "c" && contentType[6] === "a" && contentType[7] === "t" && contentType[8] === "i" && contentType[9] === "o" && contentType[10] === "n" && contentType[12] === "j" && contentType[13] === "s" && contentType[14] === "o" && contentType[15] === "n";
};
const isContentTypeText = (contentType) => {
	return contentType.length > 4 && contentType[4] === "/" && contentType[0] === "t" && contentType[1] === "e" && contentType[2] === "x" && contentType[3] === "t";
};
var util$c = {
	getResolveErrorBodyCallback: getResolveErrorBodyCallback$2,
	isContentTypeApplicationJson,
	isContentTypeText
};
const assert$4 = require$$0;
const { Readable: Readable$1 } = readable;
const { InvalidArgumentError: InvalidArgumentError$b, RequestAbortedError: RequestAbortedError$3 } = errors$1;
const util$b = util$n;
const { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = util$c;
const { AsyncResource: AsyncResource$4 } = require$$5$1;
var RequestHandler = class extends AsyncResource$4 {
	constructor(opts, callback) {
		if (!opts || typeof opts !== "object") throw new InvalidArgumentError$b("invalid opts");
		const { signal, method, opaque, body: body$1, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
		try {
			if (typeof callback !== "function") throw new InvalidArgumentError$b("invalid callback");
			if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) throw new InvalidArgumentError$b("invalid highWaterMark");
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$b("signal must be an EventEmitter or EventTarget");
			if (method === "CONNECT") throw new InvalidArgumentError$b("invalid method");
			if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$b("invalid onInfo callback");
			super("UNDICI_REQUEST");
		} catch (err) {
			if (util$b.isStream(body$1)) util$b.destroy(body$1.on("error", util$b.nop), err);
			throw err;
		}
		this.method = method;
		this.responseHeaders = responseHeaders || null;
		this.opaque = opaque || null;
		this.callback = callback;
		this.res = null;
		this.abort = null;
		this.body = body$1;
		this.trailers = {};
		this.context = null;
		this.onInfo = onInfo || null;
		this.throwOnError = throwOnError;
		this.highWaterMark = highWaterMark;
		this.signal = signal;
		this.reason = null;
		this.removeAbortListener = null;
		if (util$b.isStream(body$1)) body$1.on("error", (err) => {
			this.onError(err);
		});
		if (this.signal) if (this.signal.aborted) this.reason = this.signal.reason ?? new RequestAbortedError$3();
else this.removeAbortListener = util$b.addAbortListener(this.signal, () => {
			this.reason = this.signal.reason ?? new RequestAbortedError$3();
			if (this.res) util$b.destroy(this.res, this.reason);
else if (this.abort) this.abort(this.reason);
			if (this.removeAbortListener) {
				this.res?.off("close", this.removeAbortListener);
				this.removeAbortListener();
				this.removeAbortListener = null;
			}
		});
	}
	onConnect(abort$1, context) {
		if (this.reason) {
			abort$1(this.reason);
			return;
		}
		assert$4(this.callback);
		this.abort = abort$1;
		this.context = context;
	}
	onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
		const { callback, opaque, abort: abort$1, context, responseHeaders, highWaterMark } = this;
		const headers$1 = responseHeaders === "raw" ? util$b.parseRawHeaders(rawHeaders) : util$b.parseHeaders(rawHeaders);
		if (statusCode < 200) {
			if (this.onInfo) this.onInfo({
				statusCode,
				headers: headers$1
			});
			return;
		}
		const parsedHeaders = responseHeaders === "raw" ? util$b.parseHeaders(rawHeaders) : headers$1;
		const contentType = parsedHeaders["content-type"];
		const contentLength = parsedHeaders["content-length"];
		const res = new Readable$1({
			resume: resume$1,
			abort: abort$1,
			contentType,
			contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
			highWaterMark
		});
		if (this.removeAbortListener) res.on("close", this.removeAbortListener);
		this.callback = null;
		this.res = res;
		if (callback !== null) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback$1, null, {
			callback,
			body: res,
			contentType,
			statusCode,
			statusMessage,
			headers: headers$1
		});
else this.runInAsyncScope(callback, null, null, {
			statusCode,
			headers: headers$1,
			trailers: this.trailers,
			opaque,
			body: res,
			context
		});
	}
	onData(chunk) {
		return this.res.push(chunk);
	}
	onComplete(trailers) {
		util$b.parseHeaders(trailers, this.trailers);
		this.res.push(null);
	}
	onError(err) {
		const { res, callback, body: body$1, opaque } = this;
		if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
		if (res) {
			this.res = null;
			queueMicrotask(() => {
				util$b.destroy(res, err);
			});
		}
		if (body$1) {
			this.body = null;
			util$b.destroy(body$1, err);
		}
		if (this.removeAbortListener) {
			res?.off("close", this.removeAbortListener);
			this.removeAbortListener();
			this.removeAbortListener = null;
		}
	}
};
function request$2(opts, callback) {
	if (callback === undefined) return new Promise((resolve, reject) => {
		request$2.call(this, opts, (err, data) => {
			return err ? reject(err) : resolve(data);
		});
	});
	try {
		this.dispatch(opts, new RequestHandler(opts, callback));
	} catch (err) {
		if (typeof callback !== "function") throw err;
		const opaque = opts?.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
apiRequest.exports = request$2;
apiRequest.exports.RequestHandler = RequestHandler;
var apiRequestExports = apiRequest.exports;
const { addAbortListener } = util$n;
const { RequestAbortedError: RequestAbortedError$2 } = errors$1;
const kListener = Symbol("kListener");
const kSignal = Symbol("kSignal");
function abort(self$1) {
	if (self$1.abort) self$1.abort(self$1[kSignal]?.reason);
else self$1.reason = self$1[kSignal]?.reason ?? new RequestAbortedError$2();
	removeSignal$4(self$1);
}
function addSignal$4(self$1, signal) {
	self$1.reason = null;
	self$1[kSignal] = null;
	self$1[kListener] = null;
	if (!signal) return;
	if (signal.aborted) {
		abort(self$1);
		return;
	}
	self$1[kSignal] = signal;
	self$1[kListener] = () => {
		abort(self$1);
	};
	addAbortListener(self$1[kSignal], self$1[kListener]);
}
function removeSignal$4(self$1) {
	if (!self$1[kSignal]) return;
	if ("removeEventListener" in self$1[kSignal]) self$1[kSignal].removeEventListener("abort", self$1[kListener]);
else self$1[kSignal].removeListener("abort", self$1[kListener]);
	self$1[kSignal] = null;
	self$1[kListener] = null;
}
var abortSignal = {
	addSignal: addSignal$4,
	removeSignal: removeSignal$4
};
const assert$3 = require$$0;
const { finished, PassThrough: PassThrough$1 } = stream;
const { InvalidArgumentError: InvalidArgumentError$a, InvalidReturnValueError: InvalidReturnValueError$1 } = errors$1;
const util$a = util$n;
const { getResolveErrorBodyCallback } = util$c;
const { AsyncResource: AsyncResource$3 } = require$$5$1;
const { addSignal: addSignal$3, removeSignal: removeSignal$3 } = abortSignal;
var StreamHandler = class extends AsyncResource$3 {
	constructor(opts, factory, callback) {
		if (!opts || typeof opts !== "object") throw new InvalidArgumentError$a("invalid opts");
		const { signal, method, opaque, body: body$1, onInfo, responseHeaders, throwOnError } = opts;
		try {
			if (typeof callback !== "function") throw new InvalidArgumentError$a("invalid callback");
			if (typeof factory !== "function") throw new InvalidArgumentError$a("invalid factory");
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$a("signal must be an EventEmitter or EventTarget");
			if (method === "CONNECT") throw new InvalidArgumentError$a("invalid method");
			if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$a("invalid onInfo callback");
			super("UNDICI_STREAM");
		} catch (err) {
			if (util$a.isStream(body$1)) util$a.destroy(body$1.on("error", util$a.nop), err);
			throw err;
		}
		this.responseHeaders = responseHeaders || null;
		this.opaque = opaque || null;
		this.factory = factory;
		this.callback = callback;
		this.res = null;
		this.abort = null;
		this.context = null;
		this.trailers = null;
		this.body = body$1;
		this.onInfo = onInfo || null;
		this.throwOnError = throwOnError || false;
		if (util$a.isStream(body$1)) body$1.on("error", (err) => {
			this.onError(err);
		});
		addSignal$3(this, signal);
	}
	onConnect(abort$1, context) {
		if (this.reason) {
			abort$1(this.reason);
			return;
		}
		assert$3(this.callback);
		this.abort = abort$1;
		this.context = context;
	}
	onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
		const { factory, opaque, context, callback, responseHeaders } = this;
		const headers$1 = responseHeaders === "raw" ? util$a.parseRawHeaders(rawHeaders) : util$a.parseHeaders(rawHeaders);
		if (statusCode < 200) {
			if (this.onInfo) this.onInfo({
				statusCode,
				headers: headers$1
			});
			return;
		}
		this.factory = null;
		let res;
		if (this.throwOnError && statusCode >= 400) {
			const parsedHeaders = responseHeaders === "raw" ? util$a.parseHeaders(rawHeaders) : headers$1;
			const contentType = parsedHeaders["content-type"];
			res = new PassThrough$1();
			this.callback = null;
			this.runInAsyncScope(getResolveErrorBodyCallback, null, {
				callback,
				body: res,
				contentType,
				statusCode,
				statusMessage,
				headers: headers$1
			});
		} else {
			if (factory === null) return;
			res = this.runInAsyncScope(factory, null, {
				statusCode,
				headers: headers$1,
				opaque,
				context
			});
			if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") throw new InvalidReturnValueError$1("expected Writable");
			finished(res, { readable: false }, (err) => {
				const { callback: callback$1, res: res$1, opaque: opaque$1, trailers, abort: abort$1 } = this;
				this.res = null;
				if (err || !res$1.readable) util$a.destroy(res$1, err);
				this.callback = null;
				this.runInAsyncScope(callback$1, null, err || null, {
					opaque: opaque$1,
					trailers
				});
				if (err) abort$1();
			});
		}
		res.on("drain", resume$1);
		this.res = res;
		const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState?.needDrain;
		return needDrain !== true;
	}
	onData(chunk) {
		const { res } = this;
		return res ? res.write(chunk) : true;
	}
	onComplete(trailers) {
		const { res } = this;
		removeSignal$3(this);
		if (!res) return;
		this.trailers = util$a.parseHeaders(trailers);
		res.end();
	}
	onError(err) {
		const { res, callback, opaque, body: body$1 } = this;
		removeSignal$3(this);
		this.factory = null;
		if (res) {
			this.res = null;
			util$a.destroy(res, err);
		} else if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
		if (body$1) {
			this.body = null;
			util$a.destroy(body$1, err);
		}
	}
};
function stream$1(opts, factory, callback) {
	if (callback === undefined) return new Promise((resolve, reject) => {
		stream$1.call(this, opts, factory, (err, data) => {
			return err ? reject(err) : resolve(data);
		});
	});
	try {
		this.dispatch(opts, new StreamHandler(opts, factory, callback));
	} catch (err) {
		if (typeof callback !== "function") throw err;
		const opaque = opts?.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
var apiStream = stream$1;
const { Readable, Duplex, PassThrough } = stream;
const { InvalidArgumentError: InvalidArgumentError$9, InvalidReturnValueError, RequestAbortedError: RequestAbortedError$1 } = errors$1;
const util$9 = util$n;
const { AsyncResource: AsyncResource$2 } = require$$5$1;
const { addSignal: addSignal$2, removeSignal: removeSignal$2 } = abortSignal;
const assert$2 = require$$0;
const kResume = Symbol("resume");
var PipelineRequest = class extends Readable {
	constructor() {
		super({ autoDestroy: true });
		this[kResume] = null;
	}
	_read() {
		const { [kResume]: resume$1 } = this;
		if (resume$1) {
			this[kResume] = null;
			resume$1();
		}
	}
	_destroy(err, callback) {
		this._read();
		callback(err);
	}
};
var PipelineResponse = class extends Readable {
	constructor(resume$1) {
		super({ autoDestroy: true });
		this[kResume] = resume$1;
	}
	_read() {
		this[kResume]();
	}
	_destroy(err, callback) {
		if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$1();
		callback(err);
	}
};
var PipelineHandler = class extends AsyncResource$2 {
	constructor(opts, handler) {
		if (!opts || typeof opts !== "object") throw new InvalidArgumentError$9("invalid opts");
		if (typeof handler !== "function") throw new InvalidArgumentError$9("invalid handler");
		const { signal, method, opaque, onInfo, responseHeaders } = opts;
		if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
		if (method === "CONNECT") throw new InvalidArgumentError$9("invalid method");
		if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$9("invalid onInfo callback");
		super("UNDICI_PIPELINE");
		this.opaque = opaque || null;
		this.responseHeaders = responseHeaders || null;
		this.handler = handler;
		this.abort = null;
		this.context = null;
		this.onInfo = onInfo || null;
		this.req = new PipelineRequest().on("error", util$9.nop);
		this.ret = new Duplex({
			readableObjectMode: opts.objectMode,
			autoDestroy: true,
			read: () => {
				const { body: body$1 } = this;
				if (body$1?.resume) body$1.resume();
			},
			write: (chunk, encoding$1, callback) => {
				const { req } = this;
				if (req.push(chunk, encoding$1) || req._readableState.destroyed) callback();
else req[kResume] = callback;
			},
			destroy: (err, callback) => {
				const { body: body$1, req, res, ret, abort: abort$1 } = this;
				if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError$1();
				if (abort$1 && err) abort$1();
				util$9.destroy(body$1, err);
				util$9.destroy(req, err);
				util$9.destroy(res, err);
				removeSignal$2(this);
				callback(err);
			}
		}).on("prefinish", () => {
			const { req } = this;
			req.push(null);
		});
		this.res = null;
		addSignal$2(this, signal);
	}
	onConnect(abort$1, context) {
		const { ret, res } = this;
		if (this.reason) {
			abort$1(this.reason);
			return;
		}
		assert$2(!res, "pipeline cannot be retried");
		assert$2(!ret.destroyed);
		this.abort = abort$1;
		this.context = context;
	}
	onHeaders(statusCode, rawHeaders, resume$1) {
		const { opaque, handler, context } = this;
		if (statusCode < 200) {
			if (this.onInfo) {
				const headers$1 = this.responseHeaders === "raw" ? util$9.parseRawHeaders(rawHeaders) : util$9.parseHeaders(rawHeaders);
				this.onInfo({
					statusCode,
					headers: headers$1
				});
			}
			return;
		}
		this.res = new PipelineResponse(resume$1);
		let body$1;
		try {
			this.handler = null;
			const headers$1 = this.responseHeaders === "raw" ? util$9.parseRawHeaders(rawHeaders) : util$9.parseHeaders(rawHeaders);
			body$1 = this.runInAsyncScope(handler, null, {
				statusCode,
				headers: headers$1,
				opaque,
				body: this.res,
				context
			});
		} catch (err) {
			this.res.on("error", util$9.nop);
			throw err;
		}
		if (!body$1 || typeof body$1.on !== "function") throw new InvalidReturnValueError("expected Readable");
		body$1.on("data", (chunk) => {
			const { ret, body: body$2 } = this;
			if (!ret.push(chunk) && body$2.pause) body$2.pause();
		}).on("error", (err) => {
			const { ret } = this;
			util$9.destroy(ret, err);
		}).on("end", () => {
			const { ret } = this;
			ret.push(null);
		}).on("close", () => {
			const { ret } = this;
			if (!ret._readableState.ended) util$9.destroy(ret, new RequestAbortedError$1());
		});
		this.body = body$1;
	}
	onData(chunk) {
		const { res } = this;
		return res.push(chunk);
	}
	onComplete(trailers) {
		const { res } = this;
		res.push(null);
	}
	onError(err) {
		const { ret } = this;
		this.handler = null;
		util$9.destroy(ret, err);
	}
};
function pipeline$1(opts, handler) {
	try {
		const pipelineHandler = new PipelineHandler(opts, handler);
		this.dispatch({
			...opts,
			body: pipelineHandler.req
		}, pipelineHandler);
		return pipelineHandler.ret;
	} catch (err) {
		return new PassThrough().destroy(err);
	}
}
var apiPipeline = pipeline$1;
const { InvalidArgumentError: InvalidArgumentError$8, SocketError: SocketError$1 } = errors$1;
const { AsyncResource: AsyncResource$1 } = require$$5$1;
const util$8 = util$n;
const { addSignal: addSignal$1, removeSignal: removeSignal$1 } = abortSignal;
const assert$1 = require$$0;
var UpgradeHandler = class extends AsyncResource$1 {
	constructor(opts, callback) {
		if (!opts || typeof opts !== "object") throw new InvalidArgumentError$8("invalid opts");
		if (typeof callback !== "function") throw new InvalidArgumentError$8("invalid callback");
		const { signal, opaque, responseHeaders } = opts;
		if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
		super("UNDICI_UPGRADE");
		this.responseHeaders = responseHeaders || null;
		this.opaque = opaque || null;
		this.callback = callback;
		this.abort = null;
		this.context = null;
		addSignal$1(this, signal);
	}
	onConnect(abort$1, context) {
		if (this.reason) {
			abort$1(this.reason);
			return;
		}
		assert$1(this.callback);
		this.abort = abort$1;
		this.context = null;
	}
	onHeaders() {
		throw new SocketError$1("bad upgrade", null);
	}
	onUpgrade(statusCode, rawHeaders, socket) {
		const { callback, opaque, context } = this;
		assert$1.strictEqual(statusCode, 101);
		removeSignal$1(this);
		this.callback = null;
		const headers$1 = this.responseHeaders === "raw" ? util$8.parseRawHeaders(rawHeaders) : util$8.parseHeaders(rawHeaders);
		this.runInAsyncScope(callback, null, null, {
			headers: headers$1,
			socket,
			opaque,
			context
		});
	}
	onError(err) {
		const { callback, opaque } = this;
		removeSignal$1(this);
		if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
	}
};
function upgrade$1(opts, callback) {
	if (callback === undefined) return new Promise((resolve, reject) => {
		upgrade$1.call(this, opts, (err, data) => {
			return err ? reject(err) : resolve(data);
		});
	});
	try {
		const upgradeHandler = new UpgradeHandler(opts, callback);
		this.dispatch({
			...opts,
			method: opts.method || "GET",
			upgrade: opts.protocol || "Websocket"
		}, upgradeHandler);
	} catch (err) {
		if (typeof callback !== "function") throw err;
		const opaque = opts?.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
var apiUpgrade = upgrade$1;
const assert = require$$0;
const { AsyncResource } = require$$5$1;
const { InvalidArgumentError: InvalidArgumentError$7, SocketError } = errors$1;
const util$7 = util$n;
const { addSignal, removeSignal } = abortSignal;
var ConnectHandler = class extends AsyncResource {
	constructor(opts, callback) {
		if (!opts || typeof opts !== "object") throw new InvalidArgumentError$7("invalid opts");
		if (typeof callback !== "function") throw new InvalidArgumentError$7("invalid callback");
		const { signal, opaque, responseHeaders } = opts;
		if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$7("signal must be an EventEmitter or EventTarget");
		super("UNDICI_CONNECT");
		this.opaque = opaque || null;
		this.responseHeaders = responseHeaders || null;
		this.callback = callback;
		this.abort = null;
		addSignal(this, signal);
	}
	onConnect(abort$1, context) {
		if (this.reason) {
			abort$1(this.reason);
			return;
		}
		assert(this.callback);
		this.abort = abort$1;
		this.context = context;
	}
	onHeaders() {
		throw new SocketError("bad connect", null);
	}
	onUpgrade(statusCode, rawHeaders, socket) {
		const { callback, opaque, context } = this;
		removeSignal(this);
		this.callback = null;
		let headers$1 = rawHeaders;
		if (headers$1 != null) headers$1 = this.responseHeaders === "raw" ? util$7.parseRawHeaders(rawHeaders) : util$7.parseHeaders(rawHeaders);
		this.runInAsyncScope(callback, null, null, {
			statusCode,
			headers: headers$1,
			socket,
			opaque,
			context
		});
	}
	onError(err) {
		const { callback, opaque } = this;
		removeSignal(this);
		if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
	}
};
function connect$1(opts, callback) {
	if (callback === undefined) return new Promise((resolve, reject) => {
		connect$1.call(this, opts, (err, data) => {
			return err ? reject(err) : resolve(data);
		});
	});
	try {
		const connectHandler = new ConnectHandler(opts, callback);
		this.dispatch({
			...opts,
			method: "CONNECT"
		}, connectHandler);
	} catch (err) {
		if (typeof callback !== "function") throw err;
		const opaque = opts?.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
var apiConnect = connect$1;
api$1.request = apiRequestExports;
api$1.stream = apiStream;
api$1.pipeline = apiPipeline;
api$1.upgrade = apiUpgrade;
api$1.connect = apiConnect;
const { UndiciError: UndiciError$1 } = errors$1;
let MockNotMatchedError$1 = class MockNotMatchedError$2 extends UndiciError$1 {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, MockNotMatchedError$2);
		this.name = "MockNotMatchedError";
		this.message = message || "The request does not match any registered mock dispatches";
		this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
	}
};
var mockErrors$1 = { MockNotMatchedError: MockNotMatchedError$1 };
var mockSymbols = {
	kAgent: Symbol("agent"),
	kOptions: Symbol("options"),
	kFactory: Symbol("factory"),
	kDispatches: Symbol("dispatches"),
	kDispatchKey: Symbol("dispatch key"),
	kDefaultHeaders: Symbol("default headers"),
	kDefaultTrailers: Symbol("default trailers"),
	kContentLength: Symbol("content length"),
	kMockAgent: Symbol("mock agent"),
	kMockAgentSet: Symbol("mock agent set"),
	kMockAgentGet: Symbol("mock agent get"),
	kMockDispatch: Symbol("mock dispatch"),
	kClose: Symbol("close"),
	kOriginalClose: Symbol("original agent close"),
	kOrigin: Symbol("origin"),
	kIsMockActive: Symbol("is mock active"),
	kNetConnect: Symbol("net connect"),
	kGetNetConnect: Symbol("get net connect"),
	kConnected: Symbol("connected")
};
const { MockNotMatchedError } = mockErrors$1;
const { kDispatches: kDispatches$4, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect: kGetNetConnect$1 } = mockSymbols;
const { buildURL: buildURL$1 } = util$n;
const { STATUS_CODES } = require$$2;
const { types: { isPromise } } = require$$0$3;
function matchValue$1(match, value) {
	if (typeof match === "string") return match === value;
	if (match instanceof RegExp) return match.test(value);
	if (typeof match === "function") return match(value) === true;
	return false;
}
function lowerCaseEntries(headers$1) {
	return Object.fromEntries(Object.entries(headers$1).map(([headerName, headerValue]) => {
		return [headerName.toLocaleLowerCase(), headerValue];
	}));
}
/**
* @param {import('../../index').Headers|string[]|Record<string, string>} headers
* @param {string} key
*/
function getHeaderByName(headers$1, key) {
	if (Array.isArray(headers$1)) {
		for (let i = 0; i < headers$1.length; i += 2) if (headers$1[i].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers$1[i + 1];
		return undefined;
	} else if (typeof headers$1.get === "function") return headers$1.get(key);
else return lowerCaseEntries(headers$1)[key.toLocaleLowerCase()];
}
/** @param {string[]} headers */
function buildHeadersFromArray(headers$1) {
	const clone = headers$1.slice();
	const entries = [];
	for (let index = 0; index < clone.length; index += 2) entries.push([clone[index], clone[index + 1]]);
	return Object.fromEntries(entries);
}
function matchHeaders(mockDispatch$1, headers$1) {
	if (typeof mockDispatch$1.headers === "function") {
		if (Array.isArray(headers$1)) headers$1 = buildHeadersFromArray(headers$1);
		return mockDispatch$1.headers(headers$1 ? lowerCaseEntries(headers$1) : {});
	}
	if (typeof mockDispatch$1.headers === "undefined") return true;
	if (typeof headers$1 !== "object" || typeof mockDispatch$1.headers !== "object") return false;
	for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch$1.headers)) {
		const headerValue = getHeaderByName(headers$1, matchHeaderName);
		if (!matchValue$1(matchHeaderValue, headerValue)) return false;
	}
	return true;
}
function safeUrl(path$1) {
	if (typeof path$1 !== "string") return path$1;
	const pathSegments = path$1.split("?");
	if (pathSegments.length !== 2) return path$1;
	const qp = new URLSearchParams(pathSegments.pop());
	qp.sort();
	return [...pathSegments, qp.toString()].join("?");
}
function matchKey(mockDispatch$1, { path: path$1, method, body: body$1, headers: headers$1 }) {
	const pathMatch = matchValue$1(mockDispatch$1.path, path$1);
	const methodMatch = matchValue$1(mockDispatch$1.method, method);
	const bodyMatch = typeof mockDispatch$1.body !== "undefined" ? matchValue$1(mockDispatch$1.body, body$1) : true;
	const headersMatch = matchHeaders(mockDispatch$1, headers$1);
	return pathMatch && methodMatch && bodyMatch && headersMatch;
}
function getResponseData$1(data) {
	if (Buffer.isBuffer(data)) return data;
else if (typeof data === "object") return JSON.stringify(data);
else return data.toString();
}
function getMockDispatch(mockDispatches, key) {
	const basePath = key.query ? buildURL$1(key.path, key.query) : key.path;
	const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
	let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path$1 }) => matchValue$1(safeUrl(path$1), resolvedPath));
	if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
	matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue$1(method, key.method));
	if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
	matchedMockDispatches = matchedMockDispatches.filter(({ body: body$1 }) => typeof body$1 !== "undefined" ? matchValue$1(body$1, key.body) : true);
	if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
	matchedMockDispatches = matchedMockDispatches.filter((mockDispatch$1) => matchHeaders(mockDispatch$1, key.headers));
	if (matchedMockDispatches.length === 0) {
		const headers$1 = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
		throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers$1}' on path '${resolvedPath}'`);
	}
	return matchedMockDispatches[0];
}
function addMockDispatch$1(mockDispatches, key, data) {
	const baseData = {
		timesInvoked: 0,
		times: 1,
		persist: false,
		consumed: false
	};
	const replyData = typeof data === "function" ? { callback: data } : { ...data };
	const newMockDispatch = {
		...baseData,
		...key,
		pending: true,
		data: {
			error: null,
			...replyData
		}
	};
	mockDispatches.push(newMockDispatch);
	return newMockDispatch;
}
function deleteMockDispatch(mockDispatches, key) {
	const index = mockDispatches.findIndex((dispatch) => {
		if (!dispatch.consumed) return false;
		return matchKey(dispatch, key);
	});
	if (index !== -1) mockDispatches.splice(index, 1);
}
function buildKey$1(opts) {
	const { path: path$1, method, body: body$1, headers: headers$1, query } = opts;
	return {
		path: path$1,
		method,
		body: body$1,
		headers: headers$1,
		query
	};
}
function generateKeyValues(data) {
	const keys = Object.keys(data);
	const result = [];
	for (let i = 0; i < keys.length; ++i) {
		const key = keys[i];
		const value = data[key];
		const name = Buffer.from(`${key}`);
		if (Array.isArray(value)) for (let j = 0; j < value.length; ++j) result.push(name, Buffer.from(`${value[j]}`));
else result.push(name, Buffer.from(`${value}`));
	}
	return result;
}
/**
* @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
* @param {number} statusCode
*/
function getStatusText(statusCode) {
	return STATUS_CODES[statusCode] || "unknown";
}
async function getResponse(body$1) {
	const buffers = [];
	for await (const data of body$1) buffers.push(data);
	return Buffer.concat(buffers).toString("utf8");
}
/**
* Mock dispatch function used to simulate undici dispatches
*/
function mockDispatch(opts, handler) {
	const key = buildKey$1(opts);
	const mockDispatch$1 = getMockDispatch(this[kDispatches$4], key);
	mockDispatch$1.timesInvoked++;
	if (mockDispatch$1.data.callback) mockDispatch$1.data = {
		...mockDispatch$1.data,
		...mockDispatch$1.data.callback(opts)
	};
	const { data: { statusCode, data, headers: headers$1, trailers, error }, delay, persist } = mockDispatch$1;
	const { timesInvoked, times } = mockDispatch$1;
	mockDispatch$1.consumed = !persist && timesInvoked >= times;
	mockDispatch$1.pending = timesInvoked < times;
	if (error !== null) {
		deleteMockDispatch(this[kDispatches$4], key);
		handler.onError(error);
		return true;
	}
	if (typeof delay === "number" && delay > 0) setTimeout(() => {
		handleReply(this[kDispatches$4]);
	}, delay);
else handleReply(this[kDispatches$4]);
	function handleReply(mockDispatches, _data = data) {
		const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
		const body$1 = typeof _data === "function" ? _data({
			...opts,
			headers: optsHeaders
		}) : _data;
		if (isPromise(body$1)) {
			body$1.then((newData) => handleReply(mockDispatches, newData));
			return;
		}
		const responseData = getResponseData$1(body$1);
		const responseHeaders = generateKeyValues(headers$1);
		const responseTrailers = generateKeyValues(trailers);
		handler.onConnect?.((err) => handler.onError(err), null);
		handler.onHeaders?.(statusCode, responseHeaders, resume$1, getStatusText(statusCode));
		handler.onData?.(Buffer.from(responseData));
		handler.onComplete?.(responseTrailers);
		deleteMockDispatch(mockDispatches, key);
	}
	function resume$1() {}
	return true;
}
function buildMockDispatch$2() {
	const agent$2 = this[kMockAgent$2];
	const origin = this[kOrigin$2];
	const originalDispatch = this[kOriginalDispatch$2];
	return function dispatch(opts, handler) {
		if (agent$2.isMockActive) try {
			mockDispatch.call(this, opts, handler);
		} catch (error) {
			if (error instanceof MockNotMatchedError) {
				const netConnect = agent$2[kGetNetConnect$1]();
				if (netConnect === false) throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
				if (checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler);
else throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
			} else throw error;
		}
else originalDispatch.call(this, opts, handler);
	};
}
function checkNetConnect(netConnect, origin) {
	const url$1 = new URL(origin);
	if (netConnect === true) return true;
else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue$1(matcher, url$1.host))) return true;
	return false;
}
function buildMockOptions$1(opts) {
	if (opts) {
		const { agent: agent$2,...mockOptions } = opts;
		return mockOptions;
	}
}
var mockUtils = {
	getResponseData: getResponseData$1,
	getMockDispatch,
	addMockDispatch: addMockDispatch$1,
	deleteMockDispatch,
	buildKey: buildKey$1,
	generateKeyValues,
	matchValue: matchValue$1,
	getResponse,
	getStatusText,
	mockDispatch,
	buildMockDispatch: buildMockDispatch$2,
	checkNetConnect,
	buildMockOptions: buildMockOptions$1,
	getHeaderByName,
	buildHeadersFromArray
};
var mockInterceptor = {};
const { getResponseData, buildKey, addMockDispatch } = mockUtils;
const { kDispatches: kDispatches$3, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = mockSymbols;
const { InvalidArgumentError: InvalidArgumentError$6 } = errors$1;
const { buildURL } = util$n;
var MockScope = class {
	constructor(mockDispatch$1) {
		this[kMockDispatch] = mockDispatch$1;
	}
	/**
	* Delay a reply by a set amount in ms.
	*/
	delay(waitInMs) {
		if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError$6("waitInMs must be a valid integer > 0");
		this[kMockDispatch].delay = waitInMs;
		return this;
	}
	/**
	* For a defined reply, never mark as consumed.
	*/
	persist() {
		this[kMockDispatch].persist = true;
		return this;
	}
	/**
	* Allow one to define a reply for a set amount of matching requests.
	*/
	times(repeatTimes) {
		if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError$6("repeatTimes must be a valid integer > 0");
		this[kMockDispatch].times = repeatTimes;
		return this;
	}
};
/**
* Defines an interceptor for a Mock
*/
let MockInterceptor$2 = class MockInterceptor$3 {
	constructor(opts, mockDispatches) {
		if (typeof opts !== "object") throw new InvalidArgumentError$6("opts must be an object");
		if (typeof opts.path === "undefined") throw new InvalidArgumentError$6("opts.path must be defined");
		if (typeof opts.method === "undefined") opts.method = "GET";
		if (typeof opts.path === "string") if (opts.query) opts.path = buildURL(opts.path, opts.query);
else {
			const parsedURL = new URL(opts.path, "data://");
			opts.path = parsedURL.pathname + parsedURL.search;
		}
		if (typeof opts.method === "string") opts.method = opts.method.toUpperCase();
		this[kDispatchKey] = buildKey(opts);
		this[kDispatches$3] = mockDispatches;
		this[kDefaultHeaders] = {};
		this[kDefaultTrailers] = {};
		this[kContentLength] = false;
	}
	createMockScopeDispatchData({ statusCode, data, responseOptions }) {
		const responseData = getResponseData(data);
		const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
		const headers$1 = {
			...this[kDefaultHeaders],
			...contentLength,
			...responseOptions.headers
		};
		const trailers = {
			...this[kDefaultTrailers],
			...responseOptions.trailers
		};
		return {
			statusCode,
			data,
			headers: headers$1,
			trailers
		};
	}
	validateReplyParameters(replyParameters) {
		if (typeof replyParameters.statusCode === "undefined") throw new InvalidArgumentError$6("statusCode must be defined");
		if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) throw new InvalidArgumentError$6("responseOptions must be an object");
	}
	/**
	* Mock an undici request with a defined reply.
	*/
	reply(replyOptionsCallbackOrStatusCode) {
		if (typeof replyOptionsCallbackOrStatusCode === "function") {
			const wrappedDefaultsCallback = (opts) => {
				const resolvedData = replyOptionsCallbackOrStatusCode(opts);
				if (typeof resolvedData !== "object" || resolvedData === null) throw new InvalidArgumentError$6("reply options callback must return an object");
				const replyParameters$1 = {
					data: "",
					responseOptions: {},
					...resolvedData
				};
				this.validateReplyParameters(replyParameters$1);
				return { ...this.createMockScopeDispatchData(replyParameters$1) };
			};
			const newMockDispatch$1 = addMockDispatch(this[kDispatches$3], this[kDispatchKey], wrappedDefaultsCallback);
			return new MockScope(newMockDispatch$1);
		}
		const replyParameters = {
			statusCode: replyOptionsCallbackOrStatusCode,
			data: arguments[1] === undefined ? "" : arguments[1],
			responseOptions: arguments[2] === undefined ? {} : arguments[2]
		};
		this.validateReplyParameters(replyParameters);
		const dispatchData = this.createMockScopeDispatchData(replyParameters);
		const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], dispatchData);
		return new MockScope(newMockDispatch);
	}
	/**
	* Mock an undici request with a defined error.
	*/
	replyWithError(error) {
		if (typeof error === "undefined") throw new InvalidArgumentError$6("error must be defined");
		const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], { error });
		return new MockScope(newMockDispatch);
	}
	/**
	* Set default reply headers on the interceptor for subsequent replies
	*/
	defaultReplyHeaders(headers$1) {
		if (typeof headers$1 === "undefined") throw new InvalidArgumentError$6("headers must be defined");
		this[kDefaultHeaders] = headers$1;
		return this;
	}
	/**
	* Set default reply trailers on the interceptor for subsequent replies
	*/
	defaultReplyTrailers(trailers) {
		if (typeof trailers === "undefined") throw new InvalidArgumentError$6("trailers must be defined");
		this[kDefaultTrailers] = trailers;
		return this;
	}
	/**
	* Set reply content length header for replies on the interceptor
	*/
	replyContentLength() {
		this[kContentLength] = true;
		return this;
	}
};
mockInterceptor.MockInterceptor = MockInterceptor$2;
mockInterceptor.MockScope = MockScope;
const { promisify: promisify$1 } = require$$0$3;
const Client$1 = client;
const { buildMockDispatch: buildMockDispatch$1 } = mockUtils;
const { kDispatches: kDispatches$2, kMockAgent: kMockAgent$1, kClose: kClose$1, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = mockSymbols;
const { MockInterceptor: MockInterceptor$1 } = mockInterceptor;
const Symbols$1 = symbols$4;
const { InvalidArgumentError: InvalidArgumentError$5 } = errors$1;
/**
* MockClient provides an API that extends the Client to influence the mockDispatches.
*/
let MockClient$2 = class MockClient$3 extends Client$1 {
	constructor(origin, opts) {
		super(origin, opts);
		if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$5("Argument opts.agent must implement Agent");
		this[kMockAgent$1] = opts.agent;
		this[kOrigin$1] = origin;
		this[kDispatches$2] = [];
		this[kConnected$1] = 1;
		this[kOriginalDispatch$1] = this.dispatch;
		this[kOriginalClose$1] = this.close.bind(this);
		this.dispatch = buildMockDispatch$1.call(this);
		this.close = this[kClose$1];
	}
	get [Symbols$1.kConnected]() {
		return this[kConnected$1];
	}
	/**
	* Sets up the base interceptor for mocking replies from undici.
	*/
	intercept(opts) {
		return new MockInterceptor$1(opts, this[kDispatches$2]);
	}
	async [kClose$1]() {
		await promisify$1(this[kOriginalClose$1])();
		this[kConnected$1] = 0;
		this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
	}
};
var mockClient = MockClient$2;
const { promisify } = require$$0$3;
const Pool$1 = pool;
const { buildMockDispatch } = mockUtils;
const { kDispatches: kDispatches$1, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = mockSymbols;
const { MockInterceptor } = mockInterceptor;
const Symbols = symbols$4;
const { InvalidArgumentError: InvalidArgumentError$4 } = errors$1;
/**
* MockPool provides an API that extends the Pool to influence the mockDispatches.
*/
let MockPool$2 = class MockPool$3 extends Pool$1 {
	constructor(origin, opts) {
		super(origin, opts);
		if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$4("Argument opts.agent must implement Agent");
		this[kMockAgent] = opts.agent;
		this[kOrigin] = origin;
		this[kDispatches$1] = [];
		this[kConnected] = 1;
		this[kOriginalDispatch] = this.dispatch;
		this[kOriginalClose] = this.close.bind(this);
		this.dispatch = buildMockDispatch.call(this);
		this.close = this[kClose];
	}
	get [Symbols.kConnected]() {
		return this[kConnected];
	}
	/**
	* Sets up the base interceptor for mocking replies from undici.
	*/
	intercept(opts) {
		return new MockInterceptor(opts, this[kDispatches$1]);
	}
	async [kClose]() {
		await promisify(this[kOriginalClose])();
		this[kConnected] = 0;
		this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
	}
};
var mockPool = MockPool$2;
const singulars = {
	pronoun: "it",
	is: "is",
	was: "was",
	this: "this"
};
const plurals = {
	pronoun: "they",
	is: "are",
	was: "were",
	this: "these"
};
var pluralizer = class Pluralizer$1 {
	constructor(singular, plural) {
		this.singular = singular;
		this.plural = plural;
	}
	pluralize(count) {
		const one = count === 1;
		const keys = one ? singulars : plurals;
		const noun = one ? this.singular : this.plural;
		return {
			...keys,
			count,
			noun
		};
	}
};
const { Transform } = stream;
const { Console } = require$$1$2;
const PERSISTENT = process.versions.icu ? "✅" : "Y ";
const NOT_PERSISTENT = process.versions.icu ? "❌" : "N ";
/**
* Gets the output of `console.table(…)` as a string.
*/
var pendingInterceptorsFormatter = class PendingInterceptorsFormatter$1 {
	constructor({ disableColors } = {}) {
		this.transform = new Transform({ transform(chunk, _enc, cb) {
			cb(null, chunk);
		} });
		this.logger = new Console({
			stdout: this.transform,
			inspectOptions: { colors: !disableColors && !process.env.CI }
		});
	}
	format(pendingInterceptors) {
		const withPrettyHeaders = pendingInterceptors.map(({ method, path: path$1, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
			Method: method,
			Origin: origin,
			Path: path$1,
			"Status code": statusCode,
			Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
			Invocations: timesInvoked,
			Remaining: persist ? Infinity : times - timesInvoked
		}));
		this.logger.table(withPrettyHeaders);
		return this.transform.read().toString();
	}
};
const { kClients } = symbols$4;
const Agent$2 = agent$1;
const { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = mockSymbols;
const MockClient$1 = mockClient;
const MockPool$1 = mockPool;
const { matchValue, buildMockOptions } = mockUtils;
const { InvalidArgumentError: InvalidArgumentError$3, UndiciError } = errors$1;
const Dispatcher$1 = dispatcher;
const Pluralizer = pluralizer;
const PendingInterceptorsFormatter = pendingInterceptorsFormatter;
let MockAgent$1 = class MockAgent$2 extends Dispatcher$1 {
	constructor(opts) {
		super(opts);
		this[kNetConnect] = true;
		this[kIsMockActive] = true;
		if (opts?.agent && typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$3("Argument opts.agent must implement Agent");
		const agent$2 = opts?.agent ? opts.agent : new Agent$2(opts);
		this[kAgent] = agent$2;
		this[kClients] = agent$2[kClients];
		this[kOptions] = buildMockOptions(opts);
	}
	get(origin) {
		let dispatcher$1 = this[kMockAgentGet](origin);
		if (!dispatcher$1) {
			dispatcher$1 = this[kFactory](origin);
			this[kMockAgentSet](origin, dispatcher$1);
		}
		return dispatcher$1;
	}
	dispatch(opts, handler) {
		this.get(opts.origin);
		return this[kAgent].dispatch(opts, handler);
	}
	async close() {
		await this[kAgent].close();
		this[kClients].clear();
	}
	deactivate() {
		this[kIsMockActive] = false;
	}
	activate() {
		this[kIsMockActive] = true;
	}
	enableNetConnect(matcher) {
		if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
else this[kNetConnect] = [matcher];
else if (typeof matcher === "undefined") this[kNetConnect] = true;
else throw new InvalidArgumentError$3("Unsupported matcher. Must be one of String|Function|RegExp.");
	}
	disableNetConnect() {
		this[kNetConnect] = false;
	}
	get isMockActive() {
		return this[kIsMockActive];
	}
	[kMockAgentSet](origin, dispatcher$1) {
		this[kClients].set(origin, dispatcher$1);
	}
	[kFactory](origin) {
		const mockOptions = Object.assign({ agent: this }, this[kOptions]);
		return this[kOptions] && this[kOptions].connections === 1 ? new MockClient$1(origin, mockOptions) : new MockPool$1(origin, mockOptions);
	}
	[kMockAgentGet](origin) {
		const client$1 = this[kClients].get(origin);
		if (client$1) return client$1;
		if (typeof origin !== "string") {
			const dispatcher$1 = this[kFactory]("http://localhost:9999");
			this[kMockAgentSet](origin, dispatcher$1);
			return dispatcher$1;
		}
		for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
			const dispatcher$1 = this[kFactory](origin);
			this[kMockAgentSet](origin, dispatcher$1);
			dispatcher$1[kDispatches] = nonExplicitDispatcher[kDispatches];
			return dispatcher$1;
		}
	}
	[kGetNetConnect]() {
		return this[kNetConnect];
	}
	pendingInterceptors() {
		const mockAgentClients = this[kClients];
		return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches].map((dispatch) => ({
			...dispatch,
			origin
		}))).filter(({ pending }) => pending);
	}
	assertNoPendingInterceptors({ pendingInterceptorsFormatter: pendingInterceptorsFormatter$1 = new PendingInterceptorsFormatter() } = {}) {
		const pending = this.pendingInterceptors();
		if (pending.length === 0) return;
		const pluralizer$1 = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
		throw new UndiciError(`
${pluralizer$1.count} ${pluralizer$1.noun} ${pluralizer$1.is} pending:

${pendingInterceptorsFormatter$1.format(pending)}
`.trim());
	}
};
var mockAgent = MockAgent$1;
const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
const { InvalidArgumentError: InvalidArgumentError$2 } = errors$1;
const Agent$1 = agent$1;
if (getGlobalDispatcher$1() === undefined) setGlobalDispatcher$1(new Agent$1());
function setGlobalDispatcher$1(agent$2) {
	if (!agent$2 || typeof agent$2.dispatch !== "function") throw new InvalidArgumentError$2("Argument agent must implement Agent");
	Object.defineProperty(globalThis, globalDispatcher, {
		value: agent$2,
		writable: true,
		enumerable: false,
		configurable: false
	});
}
function getGlobalDispatcher$1() {
	return globalThis[globalDispatcher];
}
var global$1 = {
	setGlobalDispatcher: setGlobalDispatcher$1,
	getGlobalDispatcher: getGlobalDispatcher$1
};
var decoratorHandler = class DecoratorHandler$2 {
	#handler;
	constructor(handler) {
		if (typeof handler !== "object" || handler === null) throw new TypeError("handler must be an object");
		this.#handler = handler;
	}
	onConnect(...args) {
		return this.#handler.onConnect?.(...args);
	}
	onError(...args) {
		return this.#handler.onError?.(...args);
	}
	onUpgrade(...args) {
		return this.#handler.onUpgrade?.(...args);
	}
	onResponseStarted(...args) {
		return this.#handler.onResponseStarted?.(...args);
	}
	onHeaders(...args) {
		return this.#handler.onHeaders?.(...args);
	}
	onData(...args) {
		return this.#handler.onData?.(...args);
	}
	onComplete(...args) {
		return this.#handler.onComplete?.(...args);
	}
	onBodySent(...args) {
		return this.#handler.onBodySent?.(...args);
	}
};
const RedirectHandler$1 = redirectHandler;
var redirect = (opts) => {
	const globalMaxRedirections = opts?.maxRedirections;
	return (dispatch) => {
		return function redirectInterceptor$1(opts$1, handler) {
			const { maxRedirections = globalMaxRedirections,...baseOpts } = opts$1;
			if (!maxRedirections) return dispatch(opts$1, handler);
			const redirectHandler$1 = new RedirectHandler$1(dispatch, maxRedirections, opts$1, handler);
			return dispatch(baseOpts, redirectHandler$1);
		};
	};
};
const RetryHandler$1 = retryHandler;
var retry = (globalOpts) => {
	return (dispatch) => {
		return function retryInterceptor(opts, handler) {
			return dispatch(opts, new RetryHandler$1({
				...opts,
				retryOptions: {
					...globalOpts,
					...opts.retryOptions
				}
			}, {
				handler,
				dispatch
			}));
		};
	};
};
const util$6 = util$n;
const { InvalidArgumentError: InvalidArgumentError$1, RequestAbortedError } = errors$1;
const DecoratorHandler$1 = decoratorHandler;
var DumpHandler = class extends DecoratorHandler$1 {
	#maxSize = 1048576;
	#abort = null;
	#dumped = false;
	#aborted = false;
	#size = 0;
	#reason = null;
	#handler = null;
	constructor({ maxSize }, handler) {
		super(handler);
		if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) throw new InvalidArgumentError$1("maxSize must be a number greater than 0");
		this.#maxSize = maxSize ?? this.#maxSize;
		this.#handler = handler;
	}
	onConnect(abort$1) {
		this.#abort = abort$1;
		this.#handler.onConnect(this.#customAbort.bind(this));
	}
	#customAbort(reason) {
		this.#aborted = true;
		this.#reason = reason;
	}
	onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
		const headers$1 = util$6.parseHeaders(rawHeaders);
		const contentLength = headers$1["content-length"];
		if (contentLength != null && contentLength > this.#maxSize) throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${this.#maxSize})`);
		if (this.#aborted) return true;
		return this.#handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
	}
	onError(err) {
		if (this.#dumped) return;
		err = this.#reason ?? err;
		this.#handler.onError(err);
	}
	onData(chunk) {
		this.#size = this.#size + chunk.length;
		if (this.#size >= this.#maxSize) {
			this.#dumped = true;
			if (this.#aborted) this.#handler.onError(this.#reason);
else this.#handler.onComplete([]);
		}
		return true;
	}
	onComplete(trailers) {
		if (this.#dumped) return;
		if (this.#aborted) {
			this.#handler.onError(this.reason);
			return;
		}
		this.#handler.onComplete(trailers);
	}
};
function createDumpInterceptor({ maxSize: defaultMaxSize } = { maxSize: 1048576 }) {
	return (dispatch) => {
		return function Intercept(opts, handler) {
			const { dumpMaxSize = defaultMaxSize } = opts;
			const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize }, handler);
			return dispatch(opts, dumpHandler);
		};
	};
}
var dump = createDumpInterceptor;
var headers;
var hasRequiredHeaders;
function requireHeaders() {
	if (hasRequiredHeaders) return headers;
	hasRequiredHeaders = 1;
	const { kConstruct: kConstruct$1 } = symbols$4;
	const { kEnumerableProperty: kEnumerableProperty$1 } = util$n;
	const { iteratorMixin, isValidHeaderName, isValidHeaderValue: isValidHeaderValue$2 } = requireUtil$5();
	const { webidl } = requireWebidl();
	const assert$10 = require$$0;
	const util$10 = require$$0$3;
	const kHeadersMap = Symbol("headers map");
	const kHeadersSortedMap = Symbol("headers map sorted");
	/**
	* @param {number} code
	*/
	function isHTTPWhiteSpaceCharCode(code) {
		return code === 10 || code === 13 || code === 9 || code === 32;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	* @param {string} potentialValue
	*/
	function headerValueNormalize(potentialValue) {
		let i = 0;
		let j = potentialValue.length;
		while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
		while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
		return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
	}
	function fill(headers$1, object) {
		if (Array.isArray(object)) for (let i = 0; i < object.length; ++i) {
			const header = object[i];
			if (header.length !== 2) throw webidl.errors.exception({
				header: "Headers constructor",
				message: `expected name/value pair to be length 2, found ${header.length}.`
			});
			appendHeader(headers$1, header[0], header[1]);
		}
else if (typeof object === "object" && object !== null) {
			const keys = Object.keys(object);
			for (let i = 0; i < keys.length; ++i) appendHeader(headers$1, keys[i], object[keys[i]]);
		} else throw webidl.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-headers-append
	*/
	function appendHeader(headers$1, name, value) {
		value = headerValueNormalize(value);
		if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
			prefix: "Headers.append",
			value: name,
			type: "header name"
		});
else if (!isValidHeaderValue$2(value)) throw webidl.errors.invalidArgument({
			prefix: "Headers.append",
			value,
			type: "header value"
		});
		if (getHeadersGuard(headers$1) === "immutable") throw new TypeError("immutable");
		return getHeadersList(headers$1).append(name, value, false);
	}
	function compareHeaderName(a, b) {
		return a[0] < b[0] ? -1 : 1;
	}
	class HeadersList {
		/** @type {[string, string][]|null} */
		cookies = null;
		constructor(init) {
			if (init instanceof HeadersList) {
				this[kHeadersMap] = new Map(init[kHeadersMap]);
				this[kHeadersSortedMap] = init[kHeadersSortedMap];
				this.cookies = init.cookies === null ? null : [...init.cookies];
			} else {
				this[kHeadersMap] = new Map(init);
				this[kHeadersSortedMap] = null;
			}
		}
		/**
		* @see https://fetch.spec.whatwg.org/#header-list-contains
		* @param {string} name
		* @param {boolean} isLowerCase
		*/
		contains(name, isLowerCase) {
			return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
		}
		clear() {
			this[kHeadersMap].clear();
			this[kHeadersSortedMap] = null;
			this.cookies = null;
		}
		/**
		* @see https://fetch.spec.whatwg.org/#concept-header-list-append
		* @param {string} name
		* @param {string} value
		* @param {boolean} isLowerCase
		*/
		append(name, value, isLowerCase) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = isLowerCase ? name : name.toLowerCase();
			const exists = this[kHeadersMap].get(lowercaseName);
			if (exists) {
				const delimiter = lowercaseName === "cookie" ? "; " : ", ";
				this[kHeadersMap].set(lowercaseName, {
					name: exists.name,
					value: `${exists.value}${delimiter}${value}`
				});
			} else this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
			if (lowercaseName === "set-cookie") (this.cookies ??= []).push(value);
		}
		/**
		* @see https://fetch.spec.whatwg.org/#concept-header-list-set
		* @param {string} name
		* @param {string} value
		* @param {boolean} isLowerCase
		*/
		set(name, value, isLowerCase) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = isLowerCase ? name : name.toLowerCase();
			if (lowercaseName === "set-cookie") this.cookies = [value];
			this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
		}
		/**
		* @see https://fetch.spec.whatwg.org/#concept-header-list-delete
		* @param {string} name
		* @param {boolean} isLowerCase
		*/
		delete(name, isLowerCase) {
			this[kHeadersSortedMap] = null;
			if (!isLowerCase) name = name.toLowerCase();
			if (name === "set-cookie") this.cookies = null;
			this[kHeadersMap].delete(name);
		}
		/**
		* @see https://fetch.spec.whatwg.org/#concept-header-list-get
		* @param {string} name
		* @param {boolean} isLowerCase
		* @returns {string | null}
		*/
		get(name, isLowerCase) {
			return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
		}
		*[Symbol.iterator]() {
			for (const { 0: name, 1: { value } } of this[kHeadersMap]) yield [name, value];
		}
		get entries() {
			const headers$1 = {};
			if (this[kHeadersMap].size !== 0) for (const { name, value } of this[kHeadersMap].values()) headers$1[name] = value;
			return headers$1;
		}
		rawValues() {
			return this[kHeadersMap].values();
		}
		get entriesList() {
			const headers$1 = [];
			if (this[kHeadersMap].size !== 0) for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) if (lowerName === "set-cookie") for (const cookie of this.cookies) headers$1.push([name, cookie]);
else headers$1.push([name, value]);
			return headers$1;
		}
		toSortedArray() {
			const size = this[kHeadersMap].size;
			const array = new Array(size);
			if (size <= 32) {
				if (size === 0) return array;
				const iterator = this[kHeadersMap][Symbol.iterator]();
				const firstValue = iterator.next().value;
				array[0] = [firstValue[0], firstValue[1].value];
				assert$10(firstValue[1].value !== null);
				for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
					value = iterator.next().value;
					x = array[i] = [value[0], value[1].value];
					assert$10(x[1] !== null);
					left = 0;
					right = i;
					while (left < right) {
						pivot = left + (right - left >> 1);
						if (array[pivot][0] <= x[0]) left = pivot + 1;
else right = pivot;
					}
					if (i !== pivot) {
						j = i;
						while (j > left) array[j] = array[--j];
						array[left] = x;
					}
				}
				if (!iterator.next().done) throw new TypeError("Unreachable");
				return array;
			} else {
				let i = 0;
				for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
					array[i++] = [name, value];
					assert$10(value !== null);
				}
				return array.sort(compareHeaderName);
			}
		}
	}
	class Headers$2 {
		#guard;
		#headersList;
		constructor(init = undefined) {
			if (init === kConstruct$1) return;
			this.#headersList = new HeadersList();
			this.#guard = "none";
			if (init !== undefined) {
				init = webidl.converters.HeadersInit(init, "Headers contructor", "init");
				fill(this, init);
			}
		}
		append(name, value) {
			webidl.brandCheck(this, Headers$2);
			webidl.argumentLengthCheck(arguments, 2, "Headers.append");
			const prefix = "Headers.append";
			name = webidl.converters.ByteString(name, prefix, "name");
			value = webidl.converters.ByteString(value, prefix, "value");
			return appendHeader(this, name, value);
		}
		delete(name) {
			webidl.brandCheck(this, Headers$2);
			webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
			const prefix = "Headers.delete";
			name = webidl.converters.ByteString(name, prefix, "name");
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix: "Headers.delete",
				value: name,
				type: "header name"
			});
			if (this.#guard === "immutable") throw new TypeError("immutable");
			if (!this.#headersList.contains(name, false)) return;
			this.#headersList.delete(name, false);
		}
		get(name) {
			webidl.brandCheck(this, Headers$2);
			webidl.argumentLengthCheck(arguments, 1, "Headers.get");
			const prefix = "Headers.get";
			name = webidl.converters.ByteString(name, prefix, "name");
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix,
				value: name,
				type: "header name"
			});
			return this.#headersList.get(name, false);
		}
		has(name) {
			webidl.brandCheck(this, Headers$2);
			webidl.argumentLengthCheck(arguments, 1, "Headers.has");
			const prefix = "Headers.has";
			name = webidl.converters.ByteString(name, prefix, "name");
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix,
				value: name,
				type: "header name"
			});
			return this.#headersList.contains(name, false);
		}
		set(name, value) {
			webidl.brandCheck(this, Headers$2);
			webidl.argumentLengthCheck(arguments, 2, "Headers.set");
			const prefix = "Headers.set";
			name = webidl.converters.ByteString(name, prefix, "name");
			value = webidl.converters.ByteString(value, prefix, "value");
			value = headerValueNormalize(value);
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix,
				value: name,
				type: "header name"
			});
else if (!isValidHeaderValue$2(value)) throw webidl.errors.invalidArgument({
				prefix,
				value,
				type: "header value"
			});
			if (this.#guard === "immutable") throw new TypeError("immutable");
			this.#headersList.set(name, value, false);
		}
		getSetCookie() {
			webidl.brandCheck(this, Headers$2);
			const list = this.#headersList.cookies;
			if (list) return [...list];
			return [];
		}
		get [kHeadersSortedMap]() {
			if (this.#headersList[kHeadersSortedMap]) return this.#headersList[kHeadersSortedMap];
			const headers$1 = [];
			const names = this.#headersList.toSortedArray();
			const cookies$1 = this.#headersList.cookies;
			if (cookies$1 === null || cookies$1.length === 1) return this.#headersList[kHeadersSortedMap] = names;
			for (let i = 0; i < names.length; ++i) {
				const { 0: name, 1: value } = names[i];
				if (name === "set-cookie") for (let j = 0; j < cookies$1.length; ++j) headers$1.push([name, cookies$1[j]]);
else headers$1.push([name, value]);
			}
			return this.#headersList[kHeadersSortedMap] = headers$1;
		}
		[util$10.inspect.custom](depth, options) {
			options.depth ??= depth;
			return `Headers ${util$10.formatWithOptions(options, this.#headersList.entries)}`;
		}
		static getHeadersGuard(o) {
			return o.#guard;
		}
		static setHeadersGuard(o, guard) {
			o.#guard = guard;
		}
		static getHeadersList(o) {
			return o.#headersList;
		}
		static setHeadersList(o, list) {
			o.#headersList = list;
		}
	}
	const { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers$2;
	Reflect.deleteProperty(Headers$2, "getHeadersGuard");
	Reflect.deleteProperty(Headers$2, "setHeadersGuard");
	Reflect.deleteProperty(Headers$2, "getHeadersList");
	Reflect.deleteProperty(Headers$2, "setHeadersList");
	iteratorMixin("Headers", Headers$2, kHeadersSortedMap, 0, 1);
	Object.defineProperties(Headers$2.prototype, {
		append: kEnumerableProperty$1,
		delete: kEnumerableProperty$1,
		get: kEnumerableProperty$1,
		has: kEnumerableProperty$1,
		set: kEnumerableProperty$1,
		getSetCookie: kEnumerableProperty$1,
		[Symbol.toStringTag]: {
			value: "Headers",
			configurable: true
		},
		[util$10.inspect.custom]: { enumerable: false }
	});
	webidl.converters.HeadersInit = function(V, prefix, argument) {
		if (webidl.util.Type(V) === "Object") {
			const iterator = Reflect.get(V, Symbol.iterator);
			if (!util$10.types.isProxy(V) && iterator === Headers$2.prototype.entries) try {
				return getHeadersList(V).entriesList;
			} catch {}
			if (typeof iterator === "function") return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
			return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
		}
		throw webidl.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	};
	headers = {
		fill,
		compareHeaderName,
		Headers: Headers$2,
		HeadersList,
		getHeadersGuard,
		setHeadersGuard,
		setHeadersList,
		getHeadersList
	};
	return headers;
}
var response;
var hasRequiredResponse;
function requireResponse() {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;
	const { Headers: Headers$2, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = requireHeaders();
	const { extractBody: extractBody$1, cloneBody, mixinBody } = requireBody();
	const util$10 = util$n;
	const nodeUtil$1 = require$$0$3;
	const { kEnumerableProperty: kEnumerableProperty$1 } = util$10;
	const { isValidReasonPhrase, isCancelled, isAborted, isBlobLike: isBlobLike$2, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode, environmentSettingsObject: relevantRealm } = requireUtil$5();
	const { redirectStatusSet, nullBodyStatus } = requireConstants$2();
	const { kState, kHeaders } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { FormData: FormData$1 } = requireFormdata();
	const { URLSerializer } = requireDataUrl();
	const { kConstruct: kConstruct$1 } = symbols$4;
	const assert$10 = require$$0;
	const { types } = require$$0$3;
	const { isDisturbed: isDisturbed$2, isErrored: isErrored$1 } = stream;
	const textEncoder = new TextEncoder("utf-8");
	const hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
	let registry;
	if (hasFinalizationRegistry) registry = new FinalizationRegistry((stream$4) => {
		if (!stream$4.locked && !isDisturbed$2(stream$4) && !isErrored$1(stream$4)) stream$4.cancel("Response object has been garbage collected").catch(noop$1);
	});
	function noop$1() {}
	class Response$2 {
		static error() {
			const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
			return responseObject;
		}
		static json(data, init = {}) {
			webidl.argumentLengthCheck(arguments, 1, "Response.json");
			if (init !== null) init = webidl.converters.ResponseInit(init);
			const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
			const body$1 = extractBody$1(bytes);
			const responseObject = fromInnerResponse(makeResponse({}), "response");
			initializeResponse(responseObject, init, {
				body: body$1[0],
				type: "application/json"
			});
			return responseObject;
		}
		static redirect(url$1, status = 302) {
			webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
			url$1 = webidl.converters.USVString(url$1);
			status = webidl.converters["unsigned short"](status);
			let parsedURL;
			try {
				parsedURL = new URL(url$1, relevantRealm.settingsObject.baseUrl);
			} catch (err) {
				throw new TypeError(`Failed to parse URL from ${url$1}`, { cause: err });
			}
			if (!redirectStatusSet.has(status)) throw new RangeError(`Invalid status code ${status}`);
			const responseObject = fromInnerResponse(makeResponse({}), "immutable");
			responseObject[kState].status = status;
			const value = isomorphicEncode(URLSerializer(parsedURL));
			responseObject[kState].headersList.append("location", value, true);
			return responseObject;
		}
		constructor(body$1 = null, init = {}) {
			if (body$1 === kConstruct$1) return;
			if (body$1 !== null) body$1 = webidl.converters.BodyInit(body$1);
			init = webidl.converters.ResponseInit(init);
			this[kState] = makeResponse({});
			this[kHeaders] = new Headers$2(kConstruct$1);
			setHeadersGuard(this[kHeaders], "response");
			setHeadersList(this[kHeaders], this[kState].headersList);
			let bodyWithType = null;
			if (body$1 != null) {
				const [extractedBody, type] = extractBody$1(body$1);
				bodyWithType = {
					body: extractedBody,
					type
				};
			}
			initializeResponse(this, init, bodyWithType);
		}
		get type() {
			webidl.brandCheck(this, Response$2);
			return this[kState].type;
		}
		get url() {
			webidl.brandCheck(this, Response$2);
			const urlList = this[kState].urlList;
			const url$1 = urlList[urlList.length - 1] ?? null;
			if (url$1 === null) return "";
			return URLSerializer(url$1, true);
		}
		get redirected() {
			webidl.brandCheck(this, Response$2);
			return this[kState].urlList.length > 1;
		}
		get status() {
			webidl.brandCheck(this, Response$2);
			return this[kState].status;
		}
		get ok() {
			webidl.brandCheck(this, Response$2);
			return this[kState].status >= 200 && this[kState].status <= 299;
		}
		get statusText() {
			webidl.brandCheck(this, Response$2);
			return this[kState].statusText;
		}
		get headers() {
			webidl.brandCheck(this, Response$2);
			return this[kHeaders];
		}
		get body() {
			webidl.brandCheck(this, Response$2);
			return this[kState].body ? this[kState].body.stream : null;
		}
		get bodyUsed() {
			webidl.brandCheck(this, Response$2);
			return !!this[kState].body && util$10.isDisturbed(this[kState].body.stream);
		}
		clone() {
			webidl.brandCheck(this, Response$2);
			if (this.bodyUsed || this.body?.locked) throw webidl.errors.exception({
				header: "Response.clone",
				message: "Body has already been consumed."
			});
			const clonedResponse = cloneResponse(this[kState]);
			return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
		}
		[nodeUtil$1.inspect.custom](depth, options) {
			if (options.depth === null) options.depth = 2;
			options.colors ??= true;
			const properties = {
				status: this.status,
				statusText: this.statusText,
				headers: this.headers,
				body: this.body,
				bodyUsed: this.bodyUsed,
				ok: this.ok,
				redirected: this.redirected,
				type: this.type,
				url: this.url
			};
			return `Response ${nodeUtil$1.formatWithOptions(options, properties)}`;
		}
	}
	mixinBody(Response$2);
	Object.defineProperties(Response$2.prototype, {
		type: kEnumerableProperty$1,
		url: kEnumerableProperty$1,
		status: kEnumerableProperty$1,
		ok: kEnumerableProperty$1,
		redirected: kEnumerableProperty$1,
		statusText: kEnumerableProperty$1,
		headers: kEnumerableProperty$1,
		clone: kEnumerableProperty$1,
		body: kEnumerableProperty$1,
		bodyUsed: kEnumerableProperty$1,
		[Symbol.toStringTag]: {
			value: "Response",
			configurable: true
		}
	});
	Object.defineProperties(Response$2, {
		json: kEnumerableProperty$1,
		redirect: kEnumerableProperty$1,
		error: kEnumerableProperty$1
	});
	function cloneResponse(response$1) {
		if (response$1.internalResponse) return filterResponse(cloneResponse(response$1.internalResponse), response$1.type);
		const newResponse = makeResponse({
			...response$1,
			body: null
		});
		if (response$1.body != null) newResponse.body = cloneBody(response$1.body);
		return newResponse;
	}
	function makeResponse(init) {
		return {
			aborted: false,
			rangeRequested: false,
			timingAllowPassed: false,
			requestIncludesCredentials: false,
			type: "default",
			status: 200,
			timingInfo: null,
			cacheState: "",
			statusText: "",
			...init,
			headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),
			urlList: init?.urlList ? [...init.urlList] : []
		};
	}
	function makeNetworkError(reason) {
		const isError = isErrorLike(reason);
		return makeResponse({
			type: "error",
			status: 0,
			error: isError ? reason : new Error(reason ? String(reason) : reason),
			aborted: reason && reason.name === "AbortError"
		});
	}
	function isNetworkError(response$1) {
		return response$1.type === "error" && response$1.status === 0;
	}
	function makeFilteredResponse(response$1, state) {
		state = {
			internalResponse: response$1,
			...state
		};
		return new Proxy(response$1, {
			get(target, p) {
				return p in state ? state[p] : target[p];
			},
			set(target, p, value) {
				assert$10(!(p in state));
				target[p] = value;
				return true;
			}
		});
	}
	function filterResponse(response$1, type) {
		if (type === "basic") return makeFilteredResponse(response$1, {
			type: "basic",
			headersList: response$1.headersList
		});
else if (type === "cors") return makeFilteredResponse(response$1, {
			type: "cors",
			headersList: response$1.headersList
		});
else if (type === "opaque") return makeFilteredResponse(response$1, {
			type: "opaque",
			urlList: Object.freeze([]),
			status: 0,
			statusText: "",
			body: null
		});
else if (type === "opaqueredirect") return makeFilteredResponse(response$1, {
			type: "opaqueredirect",
			status: 0,
			statusText: "",
			headersList: [],
			body: null
		});
else assert$10(false);
	}
	function makeAppropriateNetworkError(fetchParams, err = null) {
		assert$10(isCancelled(fetchParams));
		return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
	}
	function initializeResponse(response$1, init, body$1) {
		if (init.status !== null && (init.status < 200 || init.status > 599)) throw new RangeError("init[\"status\"] must be in the range of 200 to 599, inclusive.");
		if ("statusText" in init && init.statusText != null) {
			if (!isValidReasonPhrase(String(init.statusText))) throw new TypeError("Invalid statusText");
		}
		if ("status" in init && init.status != null) response$1[kState].status = init.status;
		if ("statusText" in init && init.statusText != null) response$1[kState].statusText = init.statusText;
		if ("headers" in init && init.headers != null) fill(response$1[kHeaders], init.headers);
		if (body$1) {
			if (nullBodyStatus.includes(response$1.status)) throw webidl.errors.exception({
				header: "Response constructor",
				message: `Invalid response status code ${response$1.status}`
			});
			response$1[kState].body = body$1.body;
			if (body$1.type != null && !response$1[kState].headersList.contains("content-type", true)) response$1[kState].headersList.append("content-type", body$1.type, true);
		}
	}
	/**
	* @see https://fetch.spec.whatwg.org/#response-create
	* @param {any} innerResponse
	* @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard
	* @returns {Response}
	*/
	function fromInnerResponse(innerResponse, guard) {
		const response$1 = new Response$2(kConstruct$1);
		response$1[kState] = innerResponse;
		response$1[kHeaders] = new Headers$2(kConstruct$1);
		setHeadersList(response$1[kHeaders], innerResponse.headersList);
		setHeadersGuard(response$1[kHeaders], guard);
		if (hasFinalizationRegistry && innerResponse.body?.stream) registry.register(response$1, innerResponse.body.stream);
		return response$1;
	}
	webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
	webidl.converters.FormData = webidl.interfaceConverter(FormData$1);
	webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
	webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
		if (typeof V === "string") return webidl.converters.USVString(V, prefix, name);
		if (isBlobLike$2(V)) return webidl.converters.Blob(V, prefix, name, { strict: false });
		if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) return webidl.converters.BufferSource(V, prefix, name);
		if (util$10.isFormDataLike(V)) return webidl.converters.FormData(V, prefix, name, { strict: false });
		if (V instanceof URLSearchParams) return webidl.converters.URLSearchParams(V, prefix, name);
		return webidl.converters.DOMString(V, prefix, name);
	};
	webidl.converters.BodyInit = function(V, prefix, argument) {
		if (V instanceof ReadableStream) return webidl.converters.ReadableStream(V, prefix, argument);
		if (V?.[Symbol.asyncIterator]) return V;
		return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
	};
	webidl.converters.ResponseInit = webidl.dictionaryConverter([
		{
			key: "status",
			converter: webidl.converters["unsigned short"],
			defaultValue: () => 200
		},
		{
			key: "statusText",
			converter: webidl.converters.ByteString,
			defaultValue: () => ""
		},
		{
			key: "headers",
			converter: webidl.converters.HeadersInit
		}
	]);
	response = {
		isNetworkError,
		makeNetworkError,
		makeResponse,
		makeAppropriateNetworkError,
		filterResponse,
		Response: Response$2,
		cloneResponse,
		fromInnerResponse
	};
	return response;
}
var dispatcherWeakref;
var hasRequiredDispatcherWeakref;
function requireDispatcherWeakref() {
	if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
	hasRequiredDispatcherWeakref = 1;
	const { kConnected: kConnected$5, kSize: kSize$5 } = symbols$4;
	class CompatWeakRef {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value[kConnected$5] === 0 && this.value[kSize$5] === 0 ? undefined : this.value;
		}
	}
	class CompatFinalizer {
		constructor(finalizer) {
			this.finalizer = finalizer;
		}
		register(dispatcher$1, key) {
			if (dispatcher$1.on) dispatcher$1.on("disconnect", () => {
				if (dispatcher$1[kConnected$5] === 0 && dispatcher$1[kSize$5] === 0) this.finalizer(key);
			});
		}
		unregister(key) {}
	}
	dispatcherWeakref = function() {
		if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
			process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
			return {
				WeakRef: CompatWeakRef,
				FinalizationRegistry: CompatFinalizer
			};
		}
		return {
			WeakRef,
			FinalizationRegistry
		};
	};
	return dispatcherWeakref;
}
var request$1;
var hasRequiredRequest;
function requireRequest() {
	if (hasRequiredRequest) return request$1;
	hasRequiredRequest = 1;
	const { extractBody: extractBody$1, mixinBody, cloneBody } = requireBody();
	const { Headers: Headers$2, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = requireHeaders();
	const { FinalizationRegistry: FinalizationRegistry$1 } = requireDispatcherWeakref()();
	const util$10 = util$n;
	const nodeUtil$1 = require$$0$3;
	const { isValidHTTPToken: isValidHTTPToken$2, sameOrigin, environmentSettingsObject } = requireUtil$5();
	const { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = requireConstants$2();
	const { kEnumerableProperty: kEnumerableProperty$1, normalizedMethodRecordsBase: normalizedMethodRecordsBase$1, normalizedMethodRecords: normalizedMethodRecords$2 } = util$10;
	const { kHeaders, kSignal: kSignal$1, kState, kDispatcher } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { URLSerializer } = requireDataUrl();
	const { kConstruct: kConstruct$1 } = symbols$4;
	const assert$10 = require$$0;
	const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require$$8;
	const kAbortController = Symbol("abortController");
	const requestFinalizer = new FinalizationRegistry$1(({ signal, abort: abort$1 }) => {
		signal.removeEventListener("abort", abort$1);
	});
	const dependentControllerMap = new WeakMap();
	function buildAbort(acRef) {
		return abort$1;
		function abort$1() {
			const ac = acRef.deref();
			if (ac !== undefined) {
				requestFinalizer.unregister(abort$1);
				this.removeEventListener("abort", abort$1);
				ac.abort(this.reason);
				const controllerList = dependentControllerMap.get(ac.signal);
				if (controllerList !== undefined) {
					if (controllerList.size !== 0) {
						for (const ref of controllerList) {
							const ctrl = ref.deref();
							if (ctrl !== undefined) ctrl.abort(this.reason);
						}
						controllerList.clear();
					}
					dependentControllerMap.delete(ac.signal);
				}
			}
		}
	}
	let patchMethodWarning = false;
	class Request$3 {
		constructor(input, init = {}) {
			if (input === kConstruct$1) return;
			const prefix = "Request constructor";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			input = webidl.converters.RequestInfo(input, prefix, "input");
			init = webidl.converters.RequestInit(init, prefix, "init");
			let request$4 = null;
			let fallbackMode = null;
			const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
			let signal = null;
			if (typeof input === "string") {
				this[kDispatcher] = init.dispatcher;
				let parsedURL;
				try {
					parsedURL = new URL(input, baseUrl);
				} catch (err) {
					throw new TypeError("Failed to parse URL from " + input, { cause: err });
				}
				if (parsedURL.username || parsedURL.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
				request$4 = makeRequest({ urlList: [parsedURL] });
				fallbackMode = "cors";
			} else {
				this[kDispatcher] = init.dispatcher || input[kDispatcher];
				assert$10(input instanceof Request$3);
				request$4 = input[kState];
				signal = input[kSignal$1];
			}
			const origin = environmentSettingsObject.settingsObject.origin;
			let window$1 = "client";
			if (request$4.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request$4.window, origin)) window$1 = request$4.window;
			if (init.window != null) throw new TypeError(`'window' option '${window$1}' must be null`);
			if ("window" in init) window$1 = "no-window";
			request$4 = makeRequest({
				method: request$4.method,
				headersList: request$4.headersList,
				unsafeRequest: request$4.unsafeRequest,
				client: environmentSettingsObject.settingsObject,
				window: window$1,
				priority: request$4.priority,
				origin: request$4.origin,
				referrer: request$4.referrer,
				referrerPolicy: request$4.referrerPolicy,
				mode: request$4.mode,
				credentials: request$4.credentials,
				cache: request$4.cache,
				redirect: request$4.redirect,
				integrity: request$4.integrity,
				keepalive: request$4.keepalive,
				reloadNavigation: request$4.reloadNavigation,
				historyNavigation: request$4.historyNavigation,
				urlList: [...request$4.urlList]
			});
			const initHasKey = Object.keys(init).length !== 0;
			if (initHasKey) {
				if (request$4.mode === "navigate") request$4.mode = "same-origin";
				request$4.reloadNavigation = false;
				request$4.historyNavigation = false;
				request$4.origin = "client";
				request$4.referrer = "client";
				request$4.referrerPolicy = "";
				request$4.url = request$4.urlList[request$4.urlList.length - 1];
				request$4.urlList = [request$4.url];
			}
			if (init.referrer !== undefined) {
				const referrer = init.referrer;
				if (referrer === "") request$4.referrer = "no-referrer";
else {
					let parsedReferrer;
					try {
						parsedReferrer = new URL(referrer, baseUrl);
					} catch (err) {
						throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
					}
					if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) request$4.referrer = "client";
else request$4.referrer = parsedReferrer;
				}
			}
			if (init.referrerPolicy !== undefined) request$4.referrerPolicy = init.referrerPolicy;
			let mode;
			if (init.mode !== undefined) mode = init.mode;
else mode = fallbackMode;
			if (mode === "navigate") throw webidl.errors.exception({
				header: "Request constructor",
				message: "invalid request mode navigate."
			});
			if (mode != null) request$4.mode = mode;
			if (init.credentials !== undefined) request$4.credentials = init.credentials;
			if (init.cache !== undefined) request$4.cache = init.cache;
			if (request$4.cache === "only-if-cached" && request$4.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
			if (init.redirect !== undefined) request$4.redirect = init.redirect;
			if (init.integrity != null) request$4.integrity = String(init.integrity);
			if (init.keepalive !== undefined) request$4.keepalive = Boolean(init.keepalive);
			if (init.method !== undefined) {
				let method = init.method;
				const mayBeNormalized = normalizedMethodRecords$2[method];
				if (mayBeNormalized !== undefined) request$4.method = mayBeNormalized;
else {
					if (!isValidHTTPToken$2(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
					const upperCase = method.toUpperCase();
					if (forbiddenMethodsSet.has(upperCase)) throw new TypeError(`'${method}' HTTP method is unsupported.`);
					method = normalizedMethodRecordsBase$1[upperCase] ?? method;
					request$4.method = method;
				}
				if (!patchMethodWarning && request$4.method === "patch") {
					process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", { code: "UNDICI-FETCH-patch" });
					patchMethodWarning = true;
				}
			}
			if (init.signal !== undefined) signal = init.signal;
			this[kState] = request$4;
			const ac = new AbortController();
			this[kSignal$1] = ac.signal;
			if (signal != null) {
				if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
				if (signal.aborted) ac.abort(signal.reason);
else {
					this[kAbortController] = ac;
					const acRef = new WeakRef(ac);
					const abort$1 = buildAbort(acRef);
					try {
						if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners(1500, signal);
else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) setMaxListeners(1500, signal);
					} catch {}
					util$10.addAbortListener(signal, abort$1);
					requestFinalizer.register(ac, {
						signal,
						abort: abort$1
					}, abort$1);
				}
			}
			this[kHeaders] = new Headers$2(kConstruct$1);
			setHeadersList(this[kHeaders], request$4.headersList);
			setHeadersGuard(this[kHeaders], "request");
			if (mode === "no-cors") {
				if (!corsSafeListedMethodsSet.has(request$4.method)) throw new TypeError(`'${request$4.method} is unsupported in no-cors mode.`);
				setHeadersGuard(this[kHeaders], "request-no-cors");
			}
			if (initHasKey) {
				/** @type {HeadersList} */
				const headersList = getHeadersList(this[kHeaders]);
				const headers$1 = init.headers !== undefined ? init.headers : new HeadersList(headersList);
				headersList.clear();
				if (headers$1 instanceof HeadersList) {
					for (const { name, value } of headers$1.rawValues()) headersList.append(name, value, false);
					headersList.cookies = headers$1.cookies;
				} else fillHeaders(this[kHeaders], headers$1);
			}
			const inputBody = input instanceof Request$3 ? input[kState].body : null;
			if ((init.body != null || inputBody != null) && (request$4.method === "GET" || request$4.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
			let initBody = null;
			if (init.body != null) {
				const [extractedBody, contentType] = extractBody$1(init.body, request$4.keepalive);
				initBody = extractedBody;
				if (contentType && !getHeadersList(this[kHeaders]).contains("content-type", true)) this[kHeaders].append("content-type", contentType);
			}
			const inputOrInitBody = initBody ?? inputBody;
			if (inputOrInitBody != null && inputOrInitBody.source == null) {
				if (initBody != null && init.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
				if (request$4.mode !== "same-origin" && request$4.mode !== "cors") throw new TypeError("If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"");
				request$4.useCORSPreflightFlag = true;
			}
			let finalBody = inputOrInitBody;
			if (initBody == null && inputBody != null) {
				if (util$10.isDisturbed(inputBody.stream) || inputBody.stream.locked) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
				const identityTransform = new TransformStream();
				inputBody.stream.pipeThrough(identityTransform);
				finalBody = {
					source: inputBody.source,
					length: inputBody.length,
					stream: identityTransform.readable
				};
			}
			this[kState].body = finalBody;
		}
		get method() {
			webidl.brandCheck(this, Request$3);
			return this[kState].method;
		}
		get url() {
			webidl.brandCheck(this, Request$3);
			return URLSerializer(this[kState].url);
		}
		get headers() {
			webidl.brandCheck(this, Request$3);
			return this[kHeaders];
		}
		get destination() {
			webidl.brandCheck(this, Request$3);
			return this[kState].destination;
		}
		get referrer() {
			webidl.brandCheck(this, Request$3);
			if (this[kState].referrer === "no-referrer") return "";
			if (this[kState].referrer === "client") return "about:client";
			return this[kState].referrer.toString();
		}
		get referrerPolicy() {
			webidl.brandCheck(this, Request$3);
			return this[kState].referrerPolicy;
		}
		get mode() {
			webidl.brandCheck(this, Request$3);
			return this[kState].mode;
		}
		get credentials() {
			return this[kState].credentials;
		}
		get cache() {
			webidl.brandCheck(this, Request$3);
			return this[kState].cache;
		}
		get redirect() {
			webidl.brandCheck(this, Request$3);
			return this[kState].redirect;
		}
		get integrity() {
			webidl.brandCheck(this, Request$3);
			return this[kState].integrity;
		}
		get keepalive() {
			webidl.brandCheck(this, Request$3);
			return this[kState].keepalive;
		}
		get isReloadNavigation() {
			webidl.brandCheck(this, Request$3);
			return this[kState].reloadNavigation;
		}
		get isHistoryNavigation() {
			webidl.brandCheck(this, Request$3);
			return this[kState].historyNavigation;
		}
		get signal() {
			webidl.brandCheck(this, Request$3);
			return this[kSignal$1];
		}
		get body() {
			webidl.brandCheck(this, Request$3);
			return this[kState].body ? this[kState].body.stream : null;
		}
		get bodyUsed() {
			webidl.brandCheck(this, Request$3);
			return !!this[kState].body && util$10.isDisturbed(this[kState].body.stream);
		}
		get duplex() {
			webidl.brandCheck(this, Request$3);
			return "half";
		}
		clone() {
			webidl.brandCheck(this, Request$3);
			if (this.bodyUsed || this.body?.locked) throw new TypeError("unusable");
			const clonedRequest = cloneRequest(this[kState]);
			const ac = new AbortController();
			if (this.signal.aborted) ac.abort(this.signal.reason);
else {
				let list = dependentControllerMap.get(this.signal);
				if (list === undefined) {
					list = new Set();
					dependentControllerMap.set(this.signal, list);
				}
				const acRef = new WeakRef(ac);
				list.add(acRef);
				util$10.addAbortListener(ac.signal, buildAbort(acRef));
			}
			return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
		}
		[nodeUtil$1.inspect.custom](depth, options) {
			if (options.depth === null) options.depth = 2;
			options.colors ??= true;
			const properties = {
				method: this.method,
				url: this.url,
				headers: this.headers,
				destination: this.destination,
				referrer: this.referrer,
				referrerPolicy: this.referrerPolicy,
				mode: this.mode,
				credentials: this.credentials,
				cache: this.cache,
				redirect: this.redirect,
				integrity: this.integrity,
				keepalive: this.keepalive,
				isReloadNavigation: this.isReloadNavigation,
				isHistoryNavigation: this.isHistoryNavigation,
				signal: this.signal
			};
			return `Request ${nodeUtil$1.formatWithOptions(options, properties)}`;
		}
	}
	mixinBody(Request$3);
	function makeRequest(init) {
		return {
			method: init.method ?? "GET",
			localURLsOnly: init.localURLsOnly ?? false,
			unsafeRequest: init.unsafeRequest ?? false,
			body: init.body ?? null,
			client: init.client ?? null,
			reservedClient: init.reservedClient ?? null,
			replacesClientId: init.replacesClientId ?? "",
			window: init.window ?? "client",
			keepalive: init.keepalive ?? false,
			serviceWorkers: init.serviceWorkers ?? "all",
			initiator: init.initiator ?? "",
			destination: init.destination ?? "",
			priority: init.priority ?? null,
			origin: init.origin ?? "client",
			policyContainer: init.policyContainer ?? "client",
			referrer: init.referrer ?? "client",
			referrerPolicy: init.referrerPolicy ?? "",
			mode: init.mode ?? "no-cors",
			useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
			credentials: init.credentials ?? "same-origin",
			useCredentials: init.useCredentials ?? false,
			cache: init.cache ?? "default",
			redirect: init.redirect ?? "follow",
			integrity: init.integrity ?? "",
			cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
			parserMetadata: init.parserMetadata ?? "",
			reloadNavigation: init.reloadNavigation ?? false,
			historyNavigation: init.historyNavigation ?? false,
			userActivation: init.userActivation ?? false,
			taintedOrigin: init.taintedOrigin ?? false,
			redirectCount: init.redirectCount ?? 0,
			responseTainting: init.responseTainting ?? "basic",
			preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
			done: init.done ?? false,
			timingAllowFailed: init.timingAllowFailed ?? false,
			urlList: init.urlList,
			url: init.urlList[0],
			headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
		};
	}
	function cloneRequest(request$4) {
		const newRequest = makeRequest({
			...request$4,
			body: null
		});
		if (request$4.body != null) newRequest.body = cloneBody(request$4.body);
		return newRequest;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#request-create
	* @param {any} innerRequest
	* @param {AbortSignal} signal
	* @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard
	* @returns {Request}
	*/
	function fromInnerRequest(innerRequest, signal, guard) {
		const request$4 = new Request$3(kConstruct$1);
		request$4[kState] = innerRequest;
		request$4[kSignal$1] = signal;
		request$4[kHeaders] = new Headers$2(kConstruct$1);
		setHeadersList(request$4[kHeaders], innerRequest.headersList);
		setHeadersGuard(request$4[kHeaders], guard);
		return request$4;
	}
	Object.defineProperties(Request$3.prototype, {
		method: kEnumerableProperty$1,
		url: kEnumerableProperty$1,
		headers: kEnumerableProperty$1,
		redirect: kEnumerableProperty$1,
		clone: kEnumerableProperty$1,
		signal: kEnumerableProperty$1,
		duplex: kEnumerableProperty$1,
		destination: kEnumerableProperty$1,
		body: kEnumerableProperty$1,
		bodyUsed: kEnumerableProperty$1,
		isHistoryNavigation: kEnumerableProperty$1,
		isReloadNavigation: kEnumerableProperty$1,
		keepalive: kEnumerableProperty$1,
		integrity: kEnumerableProperty$1,
		cache: kEnumerableProperty$1,
		credentials: kEnumerableProperty$1,
		attribute: kEnumerableProperty$1,
		referrerPolicy: kEnumerableProperty$1,
		referrer: kEnumerableProperty$1,
		mode: kEnumerableProperty$1,
		[Symbol.toStringTag]: {
			value: "Request",
			configurable: true
		}
	});
	webidl.converters.Request = webidl.interfaceConverter(Request$3);
	webidl.converters.RequestInfo = function(V, prefix, argument) {
		if (typeof V === "string") return webidl.converters.USVString(V, prefix, argument);
		if (V instanceof Request$3) return webidl.converters.Request(V, prefix, argument);
		return webidl.converters.USVString(V, prefix, argument);
	};
	webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
	webidl.converters.RequestInit = webidl.dictionaryConverter([
		{
			key: "method",
			converter: webidl.converters.ByteString
		},
		{
			key: "headers",
			converter: webidl.converters.HeadersInit
		},
		{
			key: "body",
			converter: webidl.nullableConverter(webidl.converters.BodyInit)
		},
		{
			key: "referrer",
			converter: webidl.converters.USVString
		},
		{
			key: "referrerPolicy",
			converter: webidl.converters.DOMString,
			allowedValues: referrerPolicy
		},
		{
			key: "mode",
			converter: webidl.converters.DOMString,
			allowedValues: requestMode
		},
		{
			key: "credentials",
			converter: webidl.converters.DOMString,
			allowedValues: requestCredentials
		},
		{
			key: "cache",
			converter: webidl.converters.DOMString,
			allowedValues: requestCache
		},
		{
			key: "redirect",
			converter: webidl.converters.DOMString,
			allowedValues: requestRedirect
		},
		{
			key: "integrity",
			converter: webidl.converters.DOMString
		},
		{
			key: "keepalive",
			converter: webidl.converters.boolean
		},
		{
			key: "signal",
			converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, "RequestInit", "signal", { strict: false }))
		},
		{
			key: "window",
			converter: webidl.converters.any
		},
		{
			key: "duplex",
			converter: webidl.converters.DOMString,
			allowedValues: requestDuplex
		},
		{
			key: "dispatcher",
			converter: webidl.converters.any
		}
	]);
	request$1 = {
		Request: Request$3,
		makeRequest,
		fromInnerRequest,
		cloneRequest
	};
	return request$1;
}
var fetch_1;
var hasRequiredFetch;
function requireFetch() {
	if (hasRequiredFetch) return fetch_1;
	hasRequiredFetch = 1;
	const { makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse, fromInnerResponse } = requireResponse();
	const { HeadersList } = requireHeaders();
	const { Request: Request$3, cloneRequest } = requireRequest();
	const zlib = require$$1;
	const { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike: isBlobLike$2, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme, clampAndCoarsenConnectionTimingInfo, simpleRangeHeaderValue, buildContentRange, createInflate, extractMimeType } = requireUtil$5();
	const { kState, kDispatcher } = requireSymbols$3();
	const assert$10 = require$$0;
	const { safelyExtractBody, extractBody: extractBody$1 } = requireBody();
	const { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet } = requireConstants$2();
	const EE$2 = require$$8;
	const { Readable: Readable$3, pipeline: pipeline$3, finished: finished$1 } = stream;
	const { addAbortListener: addAbortListener$2, isErrored: isErrored$1, isReadable: isReadable$1, bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName$1 } = util$n;
	const { dataURLProcessor, serializeAMimeType: serializeAMimeType$1, minimizeSupportedMimeType } = requireDataUrl();
	const { getGlobalDispatcher: getGlobalDispatcher$2 } = global$1;
	const { webidl } = requireWebidl();
	const { STATUS_CODES: STATUS_CODES$1 } = require$$2;
	const GET_OR_HEAD = ["GET", "HEAD"];
	const defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	class Fetch extends EE$2 {
		constructor(dispatcher$1) {
			super();
			this.dispatcher = dispatcher$1;
			this.connection = null;
			this.dump = false;
			this.state = "ongoing";
		}
		terminate(reason) {
			if (this.state !== "ongoing") return;
			this.state = "terminated";
			this.connection?.destroy(reason);
			this.emit("terminated", reason);
		}
		abort(error) {
			if (this.state !== "ongoing") return;
			this.state = "aborted";
			if (!error) error = new DOMException("The operation was aborted.", "AbortError");
			this.serializedAbortReason = error;
			this.connection?.destroy(error);
			this.emit("terminated", error);
		}
	}
	function handleFetchDone(response$1) {
		finalizeAndReportTiming(response$1, "fetch");
	}
	function fetch$1(input, init = undefined) {
		webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
		let p = createDeferredPromise();
		let requestObject;
		try {
			requestObject = new Request$3(input, init);
		} catch (e) {
			p.reject(e);
			return p.promise;
		}
		const request$4 = requestObject[kState];
		if (requestObject.signal.aborted) {
			abortFetch(p, request$4, null, requestObject.signal.reason);
			return p.promise;
		}
		const globalObject = request$4.client.globalObject;
		if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") request$4.serviceWorkers = "none";
		let responseObject = null;
		let locallyAborted = false;
		let controller = null;
		addAbortListener$2(requestObject.signal, () => {
			locallyAborted = true;
			assert$10(controller != null);
			controller.abort(requestObject.signal.reason);
			const realResponse = responseObject?.deref();
			abortFetch(p, request$4, realResponse, requestObject.signal.reason);
		});
		const processResponse = (response$1) => {
			if (locallyAborted) return;
			if (response$1.aborted) {
				abortFetch(p, request$4, responseObject, controller.serializedAbortReason);
				return;
			}
			if (response$1.type === "error") {
				p.reject(new TypeError("fetch failed", { cause: response$1.error }));
				return;
			}
			responseObject = new WeakRef(fromInnerResponse(response$1, "immutable"));
			p.resolve(responseObject.deref());
			p = null;
		};
		controller = fetching({
			request: request$4,
			processResponseEndOfBody: handleFetchDone,
			processResponse,
			dispatcher: requestObject[kDispatcher]
		});
		return p.promise;
	}
	function finalizeAndReportTiming(response$1, initiatorType = "other") {
		if (response$1.type === "error" && response$1.aborted) return;
		if (!response$1.urlList?.length) return;
		const originalURL = response$1.urlList[0];
		let timingInfo = response$1.timingInfo;
		let cacheState = response$1.cacheState;
		if (!urlIsHttpHttpsScheme(originalURL)) return;
		if (timingInfo === null) return;
		if (!response$1.timingAllowPassed) {
			timingInfo = createOpaqueTimingInfo({ startTime: timingInfo.startTime });
			cacheState = "";
		}
		timingInfo.endTime = coarsenedSharedCurrentTime();
		response$1.timingInfo = timingInfo;
		markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);
	}
	const markResourceTiming = performance.markResourceTiming;
	function abortFetch(p, request$4, responseObject, error) {
		if (p) p.reject(error);
		if (request$4.body != null && isReadable$1(request$4.body?.stream)) request$4.body.stream.cancel(error).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
		if (responseObject == null) return;
		const response$1 = responseObject[kState];
		if (response$1.body != null && isReadable$1(response$1.body?.stream)) response$1.body.stream.cancel(error).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
	}
	function fetching({ request: request$4, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher: dispatcher$1 = getGlobalDispatcher$2() }) {
		assert$10(dispatcher$1);
		let taskDestination = null;
		let crossOriginIsolatedCapability = false;
		if (request$4.client != null) {
			taskDestination = request$4.client.globalObject;
			crossOriginIsolatedCapability = request$4.client.crossOriginIsolatedCapability;
		}
		const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
		const timingInfo = createOpaqueTimingInfo({ startTime: currentTime });
		const fetchParams = {
			controller: new Fetch(dispatcher$1),
			request: request$4,
			timingInfo,
			processRequestBodyChunkLength,
			processRequestEndOfBody,
			processResponse,
			processResponseConsumeBody,
			processResponseEndOfBody,
			taskDestination,
			crossOriginIsolatedCapability
		};
		assert$10(!request$4.body || request$4.body.stream);
		if (request$4.window === "client") request$4.window = request$4.client?.globalObject?.constructor?.name === "Window" ? request$4.client : "no-window";
		if (request$4.origin === "client") request$4.origin = request$4.client.origin;
		if (request$4.policyContainer === "client") if (request$4.client != null) request$4.policyContainer = clonePolicyContainer(request$4.client.policyContainer);
else request$4.policyContainer = makePolicyContainer();
		if (!request$4.headersList.contains("accept", true)) {
			const value = "*/*";
			request$4.headersList.append("accept", value, true);
		}
		if (!request$4.headersList.contains("accept-language", true)) request$4.headersList.append("accept-language", "*", true);
		if (request$4.priority === null);
		if (subresourceSet.has(request$4.destination));
		mainFetch(fetchParams).catch((err) => {
			fetchParams.controller.terminate(err);
		});
		return fetchParams.controller;
	}
	async function mainFetch(fetchParams, recursive = false) {
		const request$4 = fetchParams.request;
		let response$1 = null;
		if (request$4.localURLsOnly && !urlIsLocal(requestCurrentURL(request$4))) response$1 = makeNetworkError("local URLs only");
		tryUpgradeRequestToAPotentiallyTrustworthyURL(request$4);
		if (requestBadPort(request$4) === "blocked") response$1 = makeNetworkError("bad port");
		if (request$4.referrerPolicy === "") request$4.referrerPolicy = request$4.policyContainer.referrerPolicy;
		if (request$4.referrer !== "no-referrer") request$4.referrer = determineRequestsReferrer(request$4);
		if (response$1 === null) response$1 = await (async () => {
			const currentURL = requestCurrentURL(request$4);
			if (sameOrigin(currentURL, request$4.url) && request$4.responseTainting === "basic" || currentURL.protocol === "data:" || request$4.mode === "navigate" || request$4.mode === "websocket") {
				request$4.responseTainting = "basic";
				return await schemeFetch(fetchParams);
			}
			if (request$4.mode === "same-origin") return makeNetworkError("request mode cannot be \"same-origin\"");
			if (request$4.mode === "no-cors") {
				if (request$4.redirect !== "follow") return makeNetworkError("redirect mode cannot be \"follow\" for \"no-cors\" request");
				request$4.responseTainting = "opaque";
				return await schemeFetch(fetchParams);
			}
			if (!urlIsHttpHttpsScheme(requestCurrentURL(request$4))) return makeNetworkError("URL scheme must be a HTTP(S) scheme");
			request$4.responseTainting = "cors";
			return await httpFetch(fetchParams);
		})();
		if (recursive) return response$1;
		if (response$1.status !== 0 && !response$1.internalResponse) {
			if (request$4.responseTainting === "cors");
			if (request$4.responseTainting === "basic") response$1 = filterResponse(response$1, "basic");
else if (request$4.responseTainting === "cors") response$1 = filterResponse(response$1, "cors");
else if (request$4.responseTainting === "opaque") response$1 = filterResponse(response$1, "opaque");
else assert$10(false);
		}
		let internalResponse = response$1.status === 0 ? response$1 : response$1.internalResponse;
		if (internalResponse.urlList.length === 0) internalResponse.urlList.push(...request$4.urlList);
		if (!request$4.timingAllowFailed) response$1.timingAllowPassed = true;
		if (response$1.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request$4.headers.contains("range", true)) response$1 = internalResponse = makeNetworkError();
		if (response$1.status !== 0 && (request$4.method === "HEAD" || request$4.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
			internalResponse.body = null;
			fetchParams.controller.dump = true;
		}
		if (request$4.integrity) {
			const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
			if (request$4.responseTainting === "opaque" || response$1.body == null) {
				processBodyError(response$1.error);
				return;
			}
			const processBody = (bytes) => {
				if (!bytesMatch(bytes, request$4.integrity)) {
					processBodyError("integrity mismatch");
					return;
				}
				response$1.body = safelyExtractBody(bytes)[0];
				fetchFinale(fetchParams, response$1);
			};
			await fullyReadBody(response$1.body, processBody, processBodyError);
		} else fetchFinale(fetchParams, response$1);
	}
	function schemeFetch(fetchParams) {
		if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
		const { request: request$4 } = fetchParams;
		const { protocol: scheme } = requestCurrentURL(request$4);
		switch (scheme) {
			case "about:": return Promise.resolve(makeNetworkError("about scheme is not supported"));
			case "blob:": {
				if (!resolveObjectURL) resolveObjectURL = require$$0$2.resolveObjectURL;
				const blobURLEntry = requestCurrentURL(request$4);
				if (blobURLEntry.search.length !== 0) return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
				const blob = resolveObjectURL(blobURLEntry.toString());
				if (request$4.method !== "GET" || !isBlobLike$2(blob)) return Promise.resolve(makeNetworkError("invalid method"));
				const response$1 = makeResponse();
				const fullLength = blob.size;
				const serializedFullLength = isomorphicEncode(`${fullLength}`);
				const type = blob.type;
				if (!request$4.headersList.contains("range", true)) {
					const bodyWithType = extractBody$1(blob);
					response$1.statusText = "OK";
					response$1.body = bodyWithType[0];
					response$1.headersList.set("content-length", serializedFullLength, true);
					response$1.headersList.set("content-type", type, true);
				} else {
					response$1.rangeRequested = true;
					const rangeHeader = request$4.headersList.get("range", true);
					const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
					if (rangeValue === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
					let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
					if (rangeStart === null) {
						rangeStart = fullLength - rangeEnd;
						rangeEnd = rangeStart + rangeEnd - 1;
					} else {
						if (rangeStart >= fullLength) return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
						if (rangeEnd === null || rangeEnd >= fullLength) rangeEnd = fullLength - 1;
					}
					const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
					const slicedBodyWithType = extractBody$1(slicedBlob);
					response$1.body = slicedBodyWithType[0];
					const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
					const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
					response$1.status = 206;
					response$1.statusText = "Partial Content";
					response$1.headersList.set("content-length", serializedSlicedLength, true);
					response$1.headersList.set("content-type", type, true);
					response$1.headersList.set("content-range", contentRange, true);
				}
				return Promise.resolve(response$1);
			}
			case "data:": {
				const currentURL = requestCurrentURL(request$4);
				const dataURLStruct = dataURLProcessor(currentURL);
				if (dataURLStruct === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
				const mimeType = serializeAMimeType$1(dataURLStruct.mimeType);
				return Promise.resolve(makeResponse({
					statusText: "OK",
					headersList: [["content-type", {
						name: "Content-Type",
						value: mimeType
					}]],
					body: safelyExtractBody(dataURLStruct.body)[0]
				}));
			}
			case "file:": return Promise.resolve(makeNetworkError("not implemented... yet..."));
			case "http:":
			case "https:": return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
			default: return Promise.resolve(makeNetworkError("unknown scheme"));
		}
	}
	function finalizeResponse(fetchParams, response$1) {
		fetchParams.request.done = true;
		if (fetchParams.processResponseDone != null) queueMicrotask(() => fetchParams.processResponseDone(response$1));
	}
	function fetchFinale(fetchParams, response$1) {
		let timingInfo = fetchParams.timingInfo;
		const processResponseEndOfBody = () => {
			const unsafeEndTime = Date.now();
			if (fetchParams.request.destination === "document") fetchParams.controller.fullTimingInfo = timingInfo;
			fetchParams.controller.reportTimingSteps = () => {
				if (fetchParams.request.url.protocol !== "https:") return;
				timingInfo.endTime = unsafeEndTime;
				let cacheState = response$1.cacheState;
				const bodyInfo = response$1.bodyInfo;
				if (!response$1.timingAllowPassed) {
					timingInfo = createOpaqueTimingInfo(timingInfo);
					cacheState = "";
				}
				let responseStatus = 0;
				if (fetchParams.request.mode !== "navigator" || !response$1.hasCrossOriginRedirects) {
					responseStatus = response$1.status;
					const mimeType = extractMimeType(response$1.headersList);
					if (mimeType !== "failure") bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
				}
				if (fetchParams.request.initiatorType != null) markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
			};
			const processResponseEndOfBodyTask = () => {
				fetchParams.request.done = true;
				if (fetchParams.processResponseEndOfBody != null) queueMicrotask(() => fetchParams.processResponseEndOfBody(response$1));
				if (fetchParams.request.initiatorType != null) fetchParams.controller.reportTimingSteps();
			};
			queueMicrotask(() => processResponseEndOfBodyTask());
		};
		if (fetchParams.processResponse != null) queueMicrotask(() => {
			fetchParams.processResponse(response$1);
			fetchParams.processResponse = null;
		});
		const internalResponse = response$1.type === "error" ? response$1 : response$1.internalResponse ?? response$1;
		if (internalResponse.body == null) processResponseEndOfBody();
else finished$1(internalResponse.body.stream, () => {
			processResponseEndOfBody();
		});
	}
	async function httpFetch(fetchParams) {
		const request$4 = fetchParams.request;
		let response$1 = null;
		let actualResponse = null;
		const timingInfo = fetchParams.timingInfo;
		if (request$4.serviceWorkers === "all");
		if (response$1 === null) {
			if (request$4.redirect === "follow") request$4.serviceWorkers = "none";
			actualResponse = response$1 = await httpNetworkOrCacheFetch(fetchParams);
			if (request$4.responseTainting === "cors" && corsCheck(request$4, response$1) === "failure") return makeNetworkError("cors failure");
			if (TAOCheck(request$4, response$1) === "failure") request$4.timingAllowFailed = true;
		}
		if ((request$4.responseTainting === "opaque" || response$1.type === "opaque") && crossOriginResourcePolicyCheck(request$4.origin, request$4.client, request$4.destination, actualResponse) === "blocked") return makeNetworkError("blocked");
		if (redirectStatusSet.has(actualResponse.status)) {
			if (request$4.redirect !== "manual") fetchParams.controller.connection.destroy(undefined, false);
			if (request$4.redirect === "error") response$1 = makeNetworkError("unexpected redirect");
else if (request$4.redirect === "manual") response$1 = actualResponse;
else if (request$4.redirect === "follow") response$1 = await httpRedirectFetch(fetchParams, response$1);
else assert$10(false);
		}
		response$1.timingInfo = timingInfo;
		return response$1;
	}
	function httpRedirectFetch(fetchParams, response$1) {
		const request$4 = fetchParams.request;
		const actualResponse = response$1.internalResponse ? response$1.internalResponse : response$1;
		let locationURL;
		try {
			locationURL = responseLocationURL(actualResponse, requestCurrentURL(request$4).hash);
			if (locationURL == null) return response$1;
		} catch (err) {
			return Promise.resolve(makeNetworkError(err));
		}
		if (!urlIsHttpHttpsScheme(locationURL)) return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
		if (request$4.redirectCount === 20) return Promise.resolve(makeNetworkError("redirect count exceeded"));
		request$4.redirectCount += 1;
		if (request$4.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request$4, locationURL)) return Promise.resolve(makeNetworkError("cross origin not allowed for request mode \"cors\""));
		if (request$4.responseTainting === "cors" && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError("URL cannot contain credentials for request mode \"cors\""));
		if (actualResponse.status !== 303 && request$4.body != null && request$4.body.source == null) return Promise.resolve(makeNetworkError());
		if ([301, 302].includes(actualResponse.status) && request$4.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request$4.method)) {
			request$4.method = "GET";
			request$4.body = null;
			for (const headerName of requestBodyHeader) request$4.headersList.delete(headerName);
		}
		if (!sameOrigin(requestCurrentURL(request$4), locationURL)) {
			request$4.headersList.delete("authorization", true);
			request$4.headersList.delete("proxy-authorization", true);
			request$4.headersList.delete("cookie", true);
			request$4.headersList.delete("host", true);
		}
		if (request$4.body != null) {
			assert$10(request$4.body.source != null);
			request$4.body = safelyExtractBody(request$4.body.source)[0];
		}
		const timingInfo = fetchParams.timingInfo;
		timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
		if (timingInfo.redirectStartTime === 0) timingInfo.redirectStartTime = timingInfo.startTime;
		request$4.urlList.push(locationURL);
		setRequestReferrerPolicyOnRedirect(request$4, actualResponse);
		return mainFetch(fetchParams, true);
	}
	async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
		const request$4 = fetchParams.request;
		let httpFetchParams = null;
		let httpRequest = null;
		let response$1 = null;
		if (request$4.window === "no-window" && request$4.redirect === "error") {
			httpFetchParams = fetchParams;
			httpRequest = request$4;
		} else {
			httpRequest = cloneRequest(request$4);
			httpFetchParams = { ...fetchParams };
			httpFetchParams.request = httpRequest;
		}
		const includeCredentials = request$4.credentials === "include" || request$4.credentials === "same-origin" && request$4.responseTainting === "basic";
		const contentLength = httpRequest.body ? httpRequest.body.length : null;
		let contentLengthHeaderValue = null;
		if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) contentLengthHeaderValue = "0";
		if (contentLength != null) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
		if (contentLengthHeaderValue != null) httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
		if (contentLength != null && httpRequest.keepalive);
		if (httpRequest.referrer instanceof URL) httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
		appendRequestOriginHeader(httpRequest);
		appendFetchMetadata(httpRequest);
		if (!httpRequest.headersList.contains("user-agent", true)) httpRequest.headersList.append("user-agent", defaultUserAgent);
		if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) httpRequest.cache = "no-store";
		if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) httpRequest.headersList.append("cache-control", "max-age=0", true);
		if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
			if (!httpRequest.headersList.contains("pragma", true)) httpRequest.headersList.append("pragma", "no-cache", true);
			if (!httpRequest.headersList.contains("cache-control", true)) httpRequest.headersList.append("cache-control", "no-cache", true);
		}
		if (httpRequest.headersList.contains("range", true)) httpRequest.headersList.append("accept-encoding", "identity", true);
		if (!httpRequest.headersList.contains("accept-encoding", true)) if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
else httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
		httpRequest.headersList.delete("host", true);
		httpRequest.cache = "no-store";
		if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload");
		if (response$1 == null) {
			if (httpRequest.cache === "only-if-cached") return makeNetworkError("only if cached");
			const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
			if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399);
			if (response$1 == null) response$1 = forwardResponse;
		}
		response$1.urlList = [...httpRequest.urlList];
		if (httpRequest.headersList.contains("range", true)) response$1.rangeRequested = true;
		response$1.requestIncludesCredentials = includeCredentials;
		if (response$1.status === 407) {
			if (request$4.window === "no-window") return makeNetworkError();
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			return makeNetworkError("proxy authentication required");
		}
		if (response$1.status === 421 && !isNewConnectionFetch && (request$4.body == null || request$4.body.source != null)) {
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			fetchParams.controller.connection.destroy();
			response$1 = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
		}
		return response$1;
	}
	async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
		assert$10(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
		fetchParams.controller.connection = {
			abort: null,
			destroyed: false,
			destroy(err, abort$1 = true) {
				if (!this.destroyed) {
					this.destroyed = true;
					if (abort$1) this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
				}
			}
		};
		const request$4 = fetchParams.request;
		let response$1 = null;
		const timingInfo = fetchParams.timingInfo;
		request$4.cache = "no-store";
		if (request$4.mode === "websocket");
		let requestBody = null;
		if (request$4.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(() => fetchParams.processRequestEndOfBody());
else if (request$4.body != null) {
			const processBodyChunk = async function* (bytes) {
				if (isCancelled(fetchParams)) return;
				yield bytes;
				fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
			};
			const processEndOfBody = () => {
				if (isCancelled(fetchParams)) return;
				if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
			};
			const processBodyError = (e) => {
				if (isCancelled(fetchParams)) return;
				if (e.name === "AbortError") fetchParams.controller.abort();
else fetchParams.controller.terminate(e);
			};
			requestBody = async function* () {
				try {
					for await (const bytes of request$4.body.stream) yield* processBodyChunk(bytes);
					processEndOfBody();
				} catch (err) {
					processBodyError(err);
				}
			}();
		}
		try {
			const { body: body$1, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
			if (socket) response$1 = makeResponse({
				status,
				statusText,
				headersList,
				socket
			});
else {
				const iterator = body$1[Symbol.asyncIterator]();
				fetchParams.controller.next = () => iterator.next();
				response$1 = makeResponse({
					status,
					statusText,
					headersList
				});
			}
		} catch (err) {
			if (err.name === "AbortError") {
				fetchParams.controller.connection.destroy();
				return makeAppropriateNetworkError(fetchParams, err);
			}
			return makeNetworkError(err);
		}
		const pullAlgorithm = async () => {
			await fetchParams.controller.resume();
		};
		const cancelAlgorithm = (reason) => {
			if (!isCancelled(fetchParams)) fetchParams.controller.abort(reason);
		};
		const stream$4 = new ReadableStream({
			async start(controller) {
				fetchParams.controller.controller = controller;
			},
			async pull(controller) {
				await pullAlgorithm();
			},
			async cancel(reason) {
				await cancelAlgorithm(reason);
			},
			type: "bytes"
		});
		response$1.body = {
			stream: stream$4,
			source: null,
			length: null
		};
		fetchParams.controller.onAborted = onAborted;
		fetchParams.controller.on("terminated", onAborted);
		fetchParams.controller.resume = async () => {
			while (true) {
				let bytes;
				let isFailure;
				try {
					const { done, value } = await fetchParams.controller.next();
					if (isAborted(fetchParams)) break;
					bytes = done ? undefined : value;
				} catch (err) {
					if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = undefined;
else {
						bytes = err;
						isFailure = true;
					}
				}
				if (bytes === undefined) {
					readableStreamClose(fetchParams.controller.controller);
					finalizeResponse(fetchParams, response$1);
					return;
				}
				timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
				if (isFailure) {
					fetchParams.controller.terminate(bytes);
					return;
				}
				const buffer = new Uint8Array(bytes);
				if (buffer.byteLength) fetchParams.controller.controller.enqueue(buffer);
				if (isErrored$1(stream$4)) {
					fetchParams.controller.terminate();
					return;
				}
				if (fetchParams.controller.controller.desiredSize <= 0) return;
			}
		};
		function onAborted(reason) {
			if (isAborted(fetchParams)) {
				response$1.aborted = true;
				if (isReadable$1(stream$4)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
			} else if (isReadable$1(stream$4)) fetchParams.controller.controller.error(new TypeError("terminated", { cause: isErrorLike(reason) ? reason : undefined }));
			fetchParams.controller.connection.destroy();
		}
		return response$1;
		function dispatch({ body: body$1 }) {
			const url$1 = requestCurrentURL(request$4);
			/** @type {import('../..').Agent} */
			const agent$2 = fetchParams.controller.dispatcher;
			return new Promise((resolve, reject) => agent$2.dispatch({
				path: url$1.pathname + url$1.search,
				origin: url$1.origin,
				method: request$4.method,
				body: agent$2.isMockActive ? request$4.body && (request$4.body.source || request$4.body.stream) : body$1,
				headers: request$4.headersList.entries,
				maxRedirections: 0,
				upgrade: request$4.mode === "websocket" ? "websocket" : undefined
			}, {
				body: null,
				abort: null,
				onConnect(abort$1) {
					const { connection: connection$1 } = fetchParams.controller;
					timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
					if (connection$1.destroyed) abort$1(new DOMException("The operation was aborted.", "AbortError"));
else {
						fetchParams.controller.on("terminated", abort$1);
						this.abort = connection$1.abort = abort$1;
					}
					timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
				},
				onResponseStarted() {
					timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
				},
				onHeaders(status, rawHeaders, resume$1, statusText) {
					if (status < 200) return;
					/** @type {string[]} */
					let codings = [];
					let location = "";
					const headersList = new HeadersList();
					for (let i = 0; i < rawHeaders.length; i += 2) headersList.append(bufferToLowerCasedHeaderName$1(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
					const contentEncoding = headersList.get("content-encoding", true);
					if (contentEncoding) codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
					location = headersList.get("location", true);
					this.body = new Readable$3({ read: resume$1 });
					const decoders = [];
					const willFollow = location && request$4.redirect === "follow" && redirectStatusSet.has(status);
					if (codings.length !== 0 && request$4.method !== "HEAD" && request$4.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) for (let i = 0; i < codings.length; ++i) {
						const coding = codings[i];
						if (coding === "x-gzip" || coding === "gzip") decoders.push(zlib.createGunzip({
							flush: zlib.constants.Z_SYNC_FLUSH,
							finishFlush: zlib.constants.Z_SYNC_FLUSH
						}));
else if (coding === "deflate") decoders.push(createInflate());
else if (coding === "br") decoders.push(zlib.createBrotliDecompress());
else {
							decoders.length = 0;
							break;
						}
					}
					resolve({
						status,
						statusText,
						headersList,
						body: decoders.length ? pipeline$3(this.body, ...decoders, () => {}) : this.body.on("error", () => {})
					});
					return true;
				},
				onData(chunk) {
					if (fetchParams.controller.dump) return;
					const bytes = chunk;
					timingInfo.encodedBodySize += bytes.byteLength;
					return this.body.push(bytes);
				},
				onComplete() {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					if (fetchParams.controller.onAborted) fetchParams.controller.off("terminated", fetchParams.controller.onAborted);
					fetchParams.controller.ended = true;
					this.body.push(null);
				},
				onError(error) {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					this.body?.destroy(error);
					fetchParams.controller.terminate(error);
					reject(error);
				},
				onUpgrade(status, rawHeaders, socket) {
					if (status !== 101) return;
					const headersList = new HeadersList();
					for (let i = 0; i < rawHeaders.length; i += 2) headersList.append(bufferToLowerCasedHeaderName$1(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
					resolve({
						status,
						statusText: STATUS_CODES$1[status],
						headersList,
						socket
					});
					return true;
				}
			}));
		}
	}
	fetch_1 = {
		fetch: fetch$1,
		Fetch,
		fetching,
		finalizeAndReportTiming
	};
	return fetch_1;
}
var symbols$2;
var hasRequiredSymbols$2;
function requireSymbols$2() {
	if (hasRequiredSymbols$2) return symbols$2;
	hasRequiredSymbols$2 = 1;
	symbols$2 = {
		kState: Symbol("FileReader state"),
		kResult: Symbol("FileReader result"),
		kError: Symbol("FileReader error"),
		kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
		kEvents: Symbol("FileReader events"),
		kAborted: Symbol("FileReader aborted")
	};
	return symbols$2;
}
var progressevent;
var hasRequiredProgressevent;
function requireProgressevent() {
	if (hasRequiredProgressevent) return progressevent;
	hasRequiredProgressevent = 1;
	const { webidl } = requireWebidl();
	const kState = Symbol("ProgressEvent state");
	/**
	* @see https://xhr.spec.whatwg.org/#progressevent
	*/
	class ProgressEvent extends Event {
		constructor(type, eventInitDict = {}) {
			type = webidl.converters.DOMString(type, "ProgressEvent constructor", "type");
			eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
			super(type, eventInitDict);
			this[kState] = {
				lengthComputable: eventInitDict.lengthComputable,
				loaded: eventInitDict.loaded,
				total: eventInitDict.total
			};
		}
		get lengthComputable() {
			webidl.brandCheck(this, ProgressEvent);
			return this[kState].lengthComputable;
		}
		get loaded() {
			webidl.brandCheck(this, ProgressEvent);
			return this[kState].loaded;
		}
		get total() {
			webidl.brandCheck(this, ProgressEvent);
			return this[kState].total;
		}
	}
	webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
		{
			key: "lengthComputable",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "loaded",
			converter: webidl.converters["unsigned long long"],
			defaultValue: () => 0
		},
		{
			key: "total",
			converter: webidl.converters["unsigned long long"],
			defaultValue: () => 0
		},
		{
			key: "bubbles",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "cancelable",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "composed",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		}
	]);
	progressevent = { ProgressEvent };
	return progressevent;
}
var encoding;
var hasRequiredEncoding;
function requireEncoding() {
	if (hasRequiredEncoding) return encoding;
	hasRequiredEncoding = 1;
	/**
	* @see https://encoding.spec.whatwg.org/#concept-encoding-get
	* @param {string|undefined} label
	*/
	function getEncoding(label) {
		if (!label) return "failure";
		switch (label.trim().toLowerCase()) {
			case "unicode-1-1-utf-8":
			case "unicode11utf8":
			case "unicode20utf8":
			case "utf-8":
			case "utf8":
			case "x-unicode20utf8": return "UTF-8";
			case "866":
			case "cp866":
			case "csibm866":
			case "ibm866": return "IBM866";
			case "csisolatin2":
			case "iso-8859-2":
			case "iso-ir-101":
			case "iso8859-2":
			case "iso88592":
			case "iso_8859-2":
			case "iso_8859-2:1987":
			case "l2":
			case "latin2": return "ISO-8859-2";
			case "csisolatin3":
			case "iso-8859-3":
			case "iso-ir-109":
			case "iso8859-3":
			case "iso88593":
			case "iso_8859-3":
			case "iso_8859-3:1988":
			case "l3":
			case "latin3": return "ISO-8859-3";
			case "csisolatin4":
			case "iso-8859-4":
			case "iso-ir-110":
			case "iso8859-4":
			case "iso88594":
			case "iso_8859-4":
			case "iso_8859-4:1988":
			case "l4":
			case "latin4": return "ISO-8859-4";
			case "csisolatincyrillic":
			case "cyrillic":
			case "iso-8859-5":
			case "iso-ir-144":
			case "iso8859-5":
			case "iso88595":
			case "iso_8859-5":
			case "iso_8859-5:1988": return "ISO-8859-5";
			case "arabic":
			case "asmo-708":
			case "csiso88596e":
			case "csiso88596i":
			case "csisolatinarabic":
			case "ecma-114":
			case "iso-8859-6":
			case "iso-8859-6-e":
			case "iso-8859-6-i":
			case "iso-ir-127":
			case "iso8859-6":
			case "iso88596":
			case "iso_8859-6":
			case "iso_8859-6:1987": return "ISO-8859-6";
			case "csisolatingreek":
			case "ecma-118":
			case "elot_928":
			case "greek":
			case "greek8":
			case "iso-8859-7":
			case "iso-ir-126":
			case "iso8859-7":
			case "iso88597":
			case "iso_8859-7":
			case "iso_8859-7:1987":
			case "sun_eu_greek": return "ISO-8859-7";
			case "csiso88598e":
			case "csisolatinhebrew":
			case "hebrew":
			case "iso-8859-8":
			case "iso-8859-8-e":
			case "iso-ir-138":
			case "iso8859-8":
			case "iso88598":
			case "iso_8859-8":
			case "iso_8859-8:1988":
			case "visual": return "ISO-8859-8";
			case "csiso88598i":
			case "iso-8859-8-i":
			case "logical": return "ISO-8859-8-I";
			case "csisolatin6":
			case "iso-8859-10":
			case "iso-ir-157":
			case "iso8859-10":
			case "iso885910":
			case "l6":
			case "latin6": return "ISO-8859-10";
			case "iso-8859-13":
			case "iso8859-13":
			case "iso885913": return "ISO-8859-13";
			case "iso-8859-14":
			case "iso8859-14":
			case "iso885914": return "ISO-8859-14";
			case "csisolatin9":
			case "iso-8859-15":
			case "iso8859-15":
			case "iso885915":
			case "iso_8859-15":
			case "l9": return "ISO-8859-15";
			case "iso-8859-16": return "ISO-8859-16";
			case "cskoi8r":
			case "koi":
			case "koi8":
			case "koi8-r":
			case "koi8_r": return "KOI8-R";
			case "koi8-ru":
			case "koi8-u": return "KOI8-U";
			case "csmacintosh":
			case "mac":
			case "macintosh":
			case "x-mac-roman": return "macintosh";
			case "iso-8859-11":
			case "iso8859-11":
			case "iso885911":
			case "tis-620":
			case "windows-874": return "windows-874";
			case "cp1250":
			case "windows-1250":
			case "x-cp1250": return "windows-1250";
			case "cp1251":
			case "windows-1251":
			case "x-cp1251": return "windows-1251";
			case "ansi_x3.4-1968":
			case "ascii":
			case "cp1252":
			case "cp819":
			case "csisolatin1":
			case "ibm819":
			case "iso-8859-1":
			case "iso-ir-100":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "iso_8859-1:1987":
			case "l1":
			case "latin1":
			case "us-ascii":
			case "windows-1252":
			case "x-cp1252": return "windows-1252";
			case "cp1253":
			case "windows-1253":
			case "x-cp1253": return "windows-1253";
			case "cp1254":
			case "csisolatin5":
			case "iso-8859-9":
			case "iso-ir-148":
			case "iso8859-9":
			case "iso88599":
			case "iso_8859-9":
			case "iso_8859-9:1989":
			case "l5":
			case "latin5":
			case "windows-1254":
			case "x-cp1254": return "windows-1254";
			case "cp1255":
			case "windows-1255":
			case "x-cp1255": return "windows-1255";
			case "cp1256":
			case "windows-1256":
			case "x-cp1256": return "windows-1256";
			case "cp1257":
			case "windows-1257":
			case "x-cp1257": return "windows-1257";
			case "cp1258":
			case "windows-1258":
			case "x-cp1258": return "windows-1258";
			case "x-mac-cyrillic":
			case "x-mac-ukrainian": return "x-mac-cyrillic";
			case "chinese":
			case "csgb2312":
			case "csiso58gb231280":
			case "gb2312":
			case "gb_2312":
			case "gb_2312-80":
			case "gbk":
			case "iso-ir-58":
			case "x-gbk": return "GBK";
			case "gb18030": return "gb18030";
			case "big5":
			case "big5-hkscs":
			case "cn-big5":
			case "csbig5":
			case "x-x-big5": return "Big5";
			case "cseucpkdfmtjapanese":
			case "euc-jp":
			case "x-euc-jp": return "EUC-JP";
			case "csiso2022jp":
			case "iso-2022-jp": return "ISO-2022-JP";
			case "csshiftjis":
			case "ms932":
			case "ms_kanji":
			case "shift-jis":
			case "shift_jis":
			case "sjis":
			case "windows-31j":
			case "x-sjis": return "Shift_JIS";
			case "cseuckr":
			case "csksc56011987":
			case "euc-kr":
			case "iso-ir-149":
			case "korean":
			case "ks_c_5601-1987":
			case "ks_c_5601-1989":
			case "ksc5601":
			case "ksc_5601":
			case "windows-949": return "EUC-KR";
			case "csiso2022kr":
			case "hz-gb-2312":
			case "iso-2022-cn":
			case "iso-2022-cn-ext":
			case "iso-2022-kr":
			case "replacement": return "replacement";
			case "unicodefffe":
			case "utf-16be": return "UTF-16BE";
			case "csunicode":
			case "iso-10646-ucs-2":
			case "ucs-2":
			case "unicode":
			case "unicodefeff":
			case "utf-16":
			case "utf-16le": return "UTF-16LE";
			case "x-user-defined": return "x-user-defined";
			default: return "failure";
		}
	}
	encoding = { getEncoding };
	return encoding;
}
var util$5;
var hasRequiredUtil$4;
function requireUtil$4() {
	if (hasRequiredUtil$4) return util$5;
	hasRequiredUtil$4 = 1;
	const { kState, kError: kError$3, kResult, kAborted, kLastProgressEventFired } = requireSymbols$2();
	const { ProgressEvent } = requireProgressevent();
	const { getEncoding } = requireEncoding();
	const { serializeAMimeType: serializeAMimeType$1, parseMIMEType: parseMIMEType$1 } = requireDataUrl();
	const { types } = require$$0$3;
	const { StringDecoder } = require$$5$2;
	const { btoa } = require$$0$2;
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	/**
	* @see https://w3c.github.io/FileAPI/#readOperation
	* @param {import('./filereader').FileReader} fr
	* @param {import('buffer').Blob} blob
	* @param {string} type
	* @param {string?} encodingName
	*/
	function readOperation(fr, blob, type, encodingName) {
		if (fr[kState] === "loading") throw new DOMException("Invalid state", "InvalidStateError");
		fr[kState] = "loading";
		fr[kResult] = null;
		fr[kError$3] = null;
		/** @type {import('stream/web').ReadableStream} */
		const stream$4 = blob.stream();
		const reader = stream$4.getReader();
		/** @type {Uint8Array[]} */
		const bytes = [];
		let chunkPromise = reader.read();
		let isFirstChunk = true;
		(async () => {
			while (!fr[kAborted]) try {
				const { done, value } = await chunkPromise;
				if (isFirstChunk && !fr[kAborted]) queueMicrotask(() => {
					fireAProgressEvent("loadstart", fr);
				});
				isFirstChunk = false;
				if (!done && types.isUint8Array(value)) {
					bytes.push(value);
					if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
						fr[kLastProgressEventFired] = Date.now();
						queueMicrotask(() => {
							fireAProgressEvent("progress", fr);
						});
					}
					chunkPromise = reader.read();
				} else if (done) {
					queueMicrotask(() => {
						fr[kState] = "done";
						try {
							const result = packageData(bytes, type, blob.type, encodingName);
							if (fr[kAborted]) return;
							fr[kResult] = result;
							fireAProgressEvent("load", fr);
						} catch (error) {
							fr[kError$3] = error;
							fireAProgressEvent("error", fr);
						}
						if (fr[kState] !== "loading") fireAProgressEvent("loadend", fr);
					});
					break;
				}
			} catch (error) {
				if (fr[kAborted]) return;
				queueMicrotask(() => {
					fr[kState] = "done";
					fr[kError$3] = error;
					fireAProgressEvent("error", fr);
					if (fr[kState] !== "loading") fireAProgressEvent("loadend", fr);
				});
				break;
			}
		})();
	}
	/**
	* @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e The name of the event
	* @param {import('./filereader').FileReader} reader
	*/
	function fireAProgressEvent(e, reader) {
		const event = new ProgressEvent(e, {
			bubbles: false,
			cancelable: false
		});
		reader.dispatchEvent(event);
	}
	/**
	* @see https://w3c.github.io/FileAPI/#blob-package-data
	* @param {Uint8Array[]} bytes
	* @param {string} type
	* @param {string?} mimeType
	* @param {string?} encodingName
	*/
	function packageData(bytes, type, mimeType, encodingName) {
		switch (type) {
			case "DataURL": {
				let dataURL = "data:";
				const parsed = parseMIMEType$1(mimeType || "application/octet-stream");
				if (parsed !== "failure") dataURL += serializeAMimeType$1(parsed);
				dataURL += ";base64,";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) dataURL += btoa(decoder.write(chunk));
				dataURL += btoa(decoder.end());
				return dataURL;
			}
			case "Text": {
				let encoding$1 = "failure";
				if (encodingName) encoding$1 = getEncoding(encodingName);
				if (encoding$1 === "failure" && mimeType) {
					const type$1 = parseMIMEType$1(mimeType);
					if (type$1 !== "failure") encoding$1 = getEncoding(type$1.parameters.get("charset"));
				}
				if (encoding$1 === "failure") encoding$1 = "UTF-8";
				return decode(bytes, encoding$1);
			}
			case "ArrayBuffer": {
				const sequence = combineByteSequences(bytes);
				return sequence.buffer;
			}
			case "BinaryString": {
				let binaryString = "";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) binaryString += decoder.write(chunk);
				binaryString += decoder.end();
				return binaryString;
			}
		}
	}
	/**
	* @see https://encoding.spec.whatwg.org/#decode
	* @param {Uint8Array[]} ioQueue
	* @param {string} encoding
	*/
	function decode(ioQueue, encoding$1) {
		const bytes = combineByteSequences(ioQueue);
		const BOMEncoding = BOMSniffing(bytes);
		let slice = 0;
		if (BOMEncoding !== null) {
			encoding$1 = BOMEncoding;
			slice = BOMEncoding === "UTF-8" ? 3 : 2;
		}
		const sliced = bytes.slice(slice);
		return new TextDecoder(encoding$1).decode(sliced);
	}
	/**
	* @see https://encoding.spec.whatwg.org/#bom-sniff
	* @param {Uint8Array} ioQueue
	*/
	function BOMSniffing(ioQueue) {
		const [a, b, c] = ioQueue;
		if (a === 239 && b === 187 && c === 191) return "UTF-8";
else if (a === 254 && b === 255) return "UTF-16BE";
else if (a === 255 && b === 254) return "UTF-16LE";
		return null;
	}
	/**
	* @param {Uint8Array[]} sequences
	*/
	function combineByteSequences(sequences) {
		const size = sequences.reduce((a, b) => {
			return a + b.byteLength;
		}, 0);
		let offset = 0;
		return sequences.reduce((a, b) => {
			a.set(b, offset);
			offset += b.byteLength;
			return a;
		}, new Uint8Array(size));
	}
	util$5 = {
		staticPropertyDescriptors,
		readOperation,
		fireAProgressEvent
	};
	return util$5;
}
var filereader;
var hasRequiredFilereader;
function requireFilereader() {
	if (hasRequiredFilereader) return filereader;
	hasRequiredFilereader = 1;
	const { staticPropertyDescriptors, readOperation, fireAProgressEvent } = requireUtil$4();
	const { kState, kError: kError$3, kResult, kEvents, kAborted } = requireSymbols$2();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty: kEnumerableProperty$1 } = util$n;
	class FileReader$1 extends EventTarget {
		constructor() {
			super();
			this[kState] = "empty";
			this[kResult] = null;
			this[kError$3] = null;
			this[kEvents] = {
				loadend: null,
				error: null,
				abort: null,
				load: null,
				progress: null,
				loadstart: null
			};
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
		* @param {import('buffer').Blob} blob
		*/
		readAsArrayBuffer(blob) {
			webidl.brandCheck(this, FileReader$1);
			webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer");
			blob = webidl.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "ArrayBuffer");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsBinaryString
		* @param {import('buffer').Blob} blob
		*/
		readAsBinaryString(blob) {
			webidl.brandCheck(this, FileReader$1);
			webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString");
			blob = webidl.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "BinaryString");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsDataText
		* @param {import('buffer').Blob} blob
		* @param {string?} encoding
		*/
		readAsText(blob, encoding$1 = undefined) {
			webidl.brandCheck(this, FileReader$1);
			webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsText");
			blob = webidl.converters.Blob(blob, { strict: false });
			if (encoding$1 !== undefined) encoding$1 = webidl.converters.DOMString(encoding$1, "FileReader.readAsText", "encoding");
			readOperation(this, blob, "Text", encoding$1);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
		* @param {import('buffer').Blob} blob
		*/
		readAsDataURL(blob) {
			webidl.brandCheck(this, FileReader$1);
			webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL");
			blob = webidl.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "DataURL");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-abort
		*/
		abort() {
			if (this[kState] === "empty" || this[kState] === "done") {
				this[kResult] = null;
				return;
			}
			if (this[kState] === "loading") {
				this[kState] = "done";
				this[kResult] = null;
			}
			this[kAborted] = true;
			fireAProgressEvent("abort", this);
			if (this[kState] !== "loading") fireAProgressEvent("loadend", this);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
		*/
		get readyState() {
			webidl.brandCheck(this, FileReader$1);
			switch (this[kState]) {
				case "empty": return this.EMPTY;
				case "loading": return this.LOADING;
				case "done": return this.DONE;
			}
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-result
		*/
		get result() {
			webidl.brandCheck(this, FileReader$1);
			return this[kResult];
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-error
		*/
		get error() {
			webidl.brandCheck(this, FileReader$1);
			return this[kError$3];
		}
		get onloadend() {
			webidl.brandCheck(this, FileReader$1);
			return this[kEvents].loadend;
		}
		set onloadend(fn) {
			webidl.brandCheck(this, FileReader$1);
			if (this[kEvents].loadend) this.removeEventListener("loadend", this[kEvents].loadend);
			if (typeof fn === "function") {
				this[kEvents].loadend = fn;
				this.addEventListener("loadend", fn);
			} else this[kEvents].loadend = null;
		}
		get onerror() {
			webidl.brandCheck(this, FileReader$1);
			return this[kEvents].error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, FileReader$1);
			if (this[kEvents].error) this.removeEventListener("error", this[kEvents].error);
			if (typeof fn === "function") {
				this[kEvents].error = fn;
				this.addEventListener("error", fn);
			} else this[kEvents].error = null;
		}
		get onloadstart() {
			webidl.brandCheck(this, FileReader$1);
			return this[kEvents].loadstart;
		}
		set onloadstart(fn) {
			webidl.brandCheck(this, FileReader$1);
			if (this[kEvents].loadstart) this.removeEventListener("loadstart", this[kEvents].loadstart);
			if (typeof fn === "function") {
				this[kEvents].loadstart = fn;
				this.addEventListener("loadstart", fn);
			} else this[kEvents].loadstart = null;
		}
		get onprogress() {
			webidl.brandCheck(this, FileReader$1);
			return this[kEvents].progress;
		}
		set onprogress(fn) {
			webidl.brandCheck(this, FileReader$1);
			if (this[kEvents].progress) this.removeEventListener("progress", this[kEvents].progress);
			if (typeof fn === "function") {
				this[kEvents].progress = fn;
				this.addEventListener("progress", fn);
			} else this[kEvents].progress = null;
		}
		get onload() {
			webidl.brandCheck(this, FileReader$1);
			return this[kEvents].load;
		}
		set onload(fn) {
			webidl.brandCheck(this, FileReader$1);
			if (this[kEvents].load) this.removeEventListener("load", this[kEvents].load);
			if (typeof fn === "function") {
				this[kEvents].load = fn;
				this.addEventListener("load", fn);
			} else this[kEvents].load = null;
		}
		get onabort() {
			webidl.brandCheck(this, FileReader$1);
			return this[kEvents].abort;
		}
		set onabort(fn) {
			webidl.brandCheck(this, FileReader$1);
			if (this[kEvents].abort) this.removeEventListener("abort", this[kEvents].abort);
			if (typeof fn === "function") {
				this[kEvents].abort = fn;
				this.addEventListener("abort", fn);
			} else this[kEvents].abort = null;
		}
	}
	FileReader$1.EMPTY = FileReader$1.prototype.EMPTY = 0;
	FileReader$1.LOADING = FileReader$1.prototype.LOADING = 1;
	FileReader$1.DONE = FileReader$1.prototype.DONE = 2;
	Object.defineProperties(FileReader$1.prototype, {
		EMPTY: staticPropertyDescriptors,
		LOADING: staticPropertyDescriptors,
		DONE: staticPropertyDescriptors,
		readAsArrayBuffer: kEnumerableProperty$1,
		readAsBinaryString: kEnumerableProperty$1,
		readAsText: kEnumerableProperty$1,
		readAsDataURL: kEnumerableProperty$1,
		abort: kEnumerableProperty$1,
		readyState: kEnumerableProperty$1,
		result: kEnumerableProperty$1,
		error: kEnumerableProperty$1,
		onloadstart: kEnumerableProperty$1,
		onprogress: kEnumerableProperty$1,
		onload: kEnumerableProperty$1,
		onabort: kEnumerableProperty$1,
		onerror: kEnumerableProperty$1,
		onloadend: kEnumerableProperty$1,
		[Symbol.toStringTag]: {
			value: "FileReader",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(FileReader$1, {
		EMPTY: staticPropertyDescriptors,
		LOADING: staticPropertyDescriptors,
		DONE: staticPropertyDescriptors
	});
	filereader = { FileReader: FileReader$1 };
	return filereader;
}
var symbols$1;
var hasRequiredSymbols$1;
function requireSymbols$1() {
	if (hasRequiredSymbols$1) return symbols$1;
	hasRequiredSymbols$1 = 1;
	symbols$1 = { kConstruct: symbols$4.kConstruct };
	return symbols$1;
}
var util$4;
var hasRequiredUtil$3;
function requireUtil$3() {
	if (hasRequiredUtil$3) return util$4;
	hasRequiredUtil$3 = 1;
	const assert$10 = require$$0;
	const { URLSerializer } = requireDataUrl();
	const { isValidHeaderName } = requireUtil$5();
	/**
	* @see https://url.spec.whatwg.org/#concept-url-equals
	* @param {URL} A
	* @param {URL} B
	* @param {boolean | undefined} excludeFragment
	* @returns {boolean}
	*/
	function urlEquals(A, B, excludeFragment = false) {
		const serializedA = URLSerializer(A, excludeFragment);
		const serializedB = URLSerializer(B, excludeFragment);
		return serializedA === serializedB;
	}
	/**
	* @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	* @param {string} header
	*/
	function getFieldValues(header) {
		assert$10(header !== null);
		const values = [];
		for (let value of header.split(",")) {
			value = value.trim();
			if (isValidHeaderName(value)) values.push(value);
		}
		return values;
	}
	util$4 = {
		urlEquals,
		getFieldValues
	};
	return util$4;
}
var cache;
var hasRequiredCache;
function requireCache() {
	if (hasRequiredCache) return cache;
	hasRequiredCache = 1;
	const { kConstruct: kConstruct$1 } = requireSymbols$1();
	const { urlEquals, getFieldValues } = requireUtil$3();
	const { kEnumerableProperty: kEnumerableProperty$1, isDisturbed: isDisturbed$2 } = util$n;
	const { webidl } = requireWebidl();
	const { Response: Response$2, cloneResponse, fromInnerResponse } = requireResponse();
	const { Request: Request$3, fromInnerRequest } = requireRequest();
	const { kState } = requireSymbols$3();
	const { fetching } = requireFetch();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = requireUtil$5();
	const assert$10 = require$$0;
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	* @typedef {Object} CacheBatchOperation
	* @property {'delete' | 'put'} type
	* @property {any} request
	* @property {any} response
	* @property {import('../../types/cache').CacheQueryOptions} options
	*/
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	* @typedef {[any, any][]} requestResponseList
	*/
	class Cache {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
		* @type {requestResponseList}
		*/
		#relevantRequestResponseList;
		constructor() {
			if (arguments[0] !== kConstruct$1) webidl.illegalConstructor();
			this.#relevantRequestResponseList = arguments[1];
		}
		async match(request$4, options = {}) {
			webidl.brandCheck(this, Cache);
			const prefix = "Cache.match";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			request$4 = webidl.converters.RequestInfo(request$4, prefix, "request");
			options = webidl.converters.CacheQueryOptions(options, prefix, "options");
			const p = this.#internalMatchAll(request$4, options, 1);
			if (p.length === 0) return;
			return p[0];
		}
		async matchAll(request$4 = undefined, options = {}) {
			webidl.brandCheck(this, Cache);
			const prefix = "Cache.matchAll";
			if (request$4 !== undefined) request$4 = webidl.converters.RequestInfo(request$4, prefix, "request");
			options = webidl.converters.CacheQueryOptions(options, prefix, "options");
			return this.#internalMatchAll(request$4, options);
		}
		async add(request$4) {
			webidl.brandCheck(this, Cache);
			const prefix = "Cache.add";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			request$4 = webidl.converters.RequestInfo(request$4, prefix, "request");
			const requests = [request$4];
			const responseArrayPromise = this.addAll(requests);
			return await responseArrayPromise;
		}
		async addAll(requests) {
			webidl.brandCheck(this, Cache);
			const prefix = "Cache.addAll";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			const responsePromises = [];
			const requestList = [];
			for (let request$4 of requests) {
				if (request$4 === undefined) throw webidl.errors.conversionFailed({
					prefix,
					argument: "Argument 1",
					types: ["undefined is not allowed"]
				});
				request$4 = webidl.converters.RequestInfo(request$4);
				if (typeof request$4 === "string") continue;
				const r = request$4[kState];
				if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") throw webidl.errors.exception({
					header: prefix,
					message: "Expected http/s scheme when method is not GET."
				});
			}
			/** @type {ReturnType<typeof fetching>[]} */
			const fetchControllers = [];
			for (const request$4 of requests) {
				const r = new Request$3(request$4)[kState];
				if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
					header: prefix,
					message: "Expected http/s scheme."
				});
				r.initiator = "fetch";
				r.destination = "subresource";
				requestList.push(r);
				const responsePromise = createDeferredPromise();
				fetchControllers.push(fetching({
					request: r,
					processResponse(response$1) {
						if (response$1.type === "error" || response$1.status === 206 || response$1.status < 200 || response$1.status > 299) responsePromise.reject(webidl.errors.exception({
							header: "Cache.addAll",
							message: "Received an invalid status code or the request failed."
						}));
else if (response$1.headersList.contains("vary")) {
							const fieldValues = getFieldValues(response$1.headersList.get("vary"));
							for (const fieldValue of fieldValues) if (fieldValue === "*") {
								responsePromise.reject(webidl.errors.exception({
									header: "Cache.addAll",
									message: "invalid vary field value"
								}));
								for (const controller of fetchControllers) controller.abort();
								return;
							}
						}
					},
					processResponseEndOfBody(response$1) {
						if (response$1.aborted) {
							responsePromise.reject(new DOMException("aborted", "AbortError"));
							return;
						}
						responsePromise.resolve(response$1);
					}
				}));
				responsePromises.push(responsePromise.promise);
			}
			const p = Promise.all(responsePromises);
			const responses = await p;
			const operations = [];
			let index = 0;
			for (const response$1 of responses) {
				/** @type {CacheBatchOperation} */
				const operation = {
					type: "put",
					request: requestList[index],
					response: response$1
				};
				operations.push(operation);
				index++;
			}
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(undefined);
else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async put(request$4, response$1) {
			webidl.brandCheck(this, Cache);
			const prefix = "Cache.put";
			webidl.argumentLengthCheck(arguments, 2, prefix);
			request$4 = webidl.converters.RequestInfo(request$4, prefix, "request");
			response$1 = webidl.converters.Response(response$1, prefix, "response");
			let innerRequest = null;
			if (request$4 instanceof Request$3) innerRequest = request$4[kState];
else innerRequest = new Request$3(request$4)[kState];
			if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") throw webidl.errors.exception({
				header: prefix,
				message: "Expected an http/s scheme when method is not GET"
			});
			const innerResponse = response$1[kState];
			if (innerResponse.status === 206) throw webidl.errors.exception({
				header: prefix,
				message: "Got 206 status"
			});
			if (innerResponse.headersList.contains("vary")) {
				const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
				for (const fieldValue of fieldValues) if (fieldValue === "*") throw webidl.errors.exception({
					header: prefix,
					message: "Got * vary field value"
				});
			}
			if (innerResponse.body && (isDisturbed$2(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl.errors.exception({
				header: prefix,
				message: "Response body is locked or disturbed"
			});
			const clonedResponse = cloneResponse(innerResponse);
			const bodyReadPromise = createDeferredPromise();
			if (innerResponse.body != null) {
				const stream$4 = innerResponse.body.stream;
				const reader = stream$4.getReader();
				readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
			} else bodyReadPromise.resolve(undefined);
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "put",
				request: innerRequest,
				response: clonedResponse
			};
			operations.push(operation);
			const bytes = await bodyReadPromise.promise;
			if (clonedResponse.body != null) clonedResponse.body.source = bytes;
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve();
else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async delete(request$4, options = {}) {
			webidl.brandCheck(this, Cache);
			const prefix = "Cache.delete";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			request$4 = webidl.converters.RequestInfo(request$4, prefix, "request");
			options = webidl.converters.CacheQueryOptions(options, prefix, "options");
			/**
			* @type {Request}
			*/
			let r = null;
			if (request$4 instanceof Request$3) {
				r = request$4[kState];
				if (r.method !== "GET" && !options.ignoreMethod) return false;
			} else {
				assert$10(typeof request$4 === "string");
				r = new Request$3(request$4)[kState];
			}
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "delete",
				request: r,
				options
			};
			operations.push(operation);
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			let requestResponses;
			try {
				requestResponses = this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(!!requestResponses?.length);
else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
		* @param {any} request
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @returns {Promise<readonly Request[]>}
		*/
		async keys(request$4 = undefined, options = {}) {
			webidl.brandCheck(this, Cache);
			const prefix = "Cache.keys";
			if (request$4 !== undefined) request$4 = webidl.converters.RequestInfo(request$4, prefix, "request");
			options = webidl.converters.CacheQueryOptions(options, prefix, "options");
			let r = null;
			if (request$4 !== undefined) {
				if (request$4 instanceof Request$3) {
					r = request$4[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$4 === "string") r = new Request$3(request$4)[kState];
			}
			const promise = createDeferredPromise();
			const requests = [];
			if (request$4 === undefined) for (const requestResponse of this.#relevantRequestResponseList) requests.push(requestResponse[0]);
else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) requests.push(requestResponse[0]);
			}
			queueMicrotask(() => {
				const requestList = [];
				for (const request$5 of requests) {
					const requestObject = fromInnerRequest(request$5, new AbortController().signal, "immutable");
					requestList.push(requestObject);
				}
				promise.resolve(Object.freeze(requestList));
			});
			return promise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
		* @param {CacheBatchOperation[]} operations
		* @returns {requestResponseList}
		*/
		#batchCacheOperations(operations) {
			const cache$1 = this.#relevantRequestResponseList;
			const backupCache = [...cache$1];
			const addedItems = [];
			const resultList = [];
			try {
				for (const operation of operations) {
					if (operation.type !== "delete" && operation.type !== "put") throw webidl.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "operation type does not match \"delete\" or \"put\""
					});
					if (operation.type === "delete" && operation.response != null) throw webidl.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "delete operation should not have an associated response"
					});
					if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException("???", "InvalidStateError");
					let requestResponses;
					if (operation.type === "delete") {
						requestResponses = this.#queryCache(operation.request, operation.options);
						if (requestResponses.length === 0) return [];
						for (const requestResponse of requestResponses) {
							const idx = cache$1.indexOf(requestResponse);
							assert$10(idx !== -1);
							cache$1.splice(idx, 1);
						}
					} else if (operation.type === "put") {
						if (operation.response == null) throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "put operation should have an associated response"
						});
						const r = operation.request;
						if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "expected http or https scheme"
						});
						if (r.method !== "GET") throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "not get method"
						});
						if (operation.options != null) throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "options must not be defined"
						});
						requestResponses = this.#queryCache(operation.request);
						for (const requestResponse of requestResponses) {
							const idx = cache$1.indexOf(requestResponse);
							assert$10(idx !== -1);
							cache$1.splice(idx, 1);
						}
						cache$1.push([operation.request, operation.response]);
						addedItems.push([operation.request, operation.response]);
					}
					resultList.push([operation.request, operation.response]);
				}
				return resultList;
			} catch (e) {
				this.#relevantRequestResponseList.length = 0;
				this.#relevantRequestResponseList = backupCache;
				throw e;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#query-cache
		* @param {any} requestQuery
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @param {requestResponseList} targetStorage
		* @returns {requestResponseList}
		*/
		#queryCache(requestQuery, options, targetStorage) {
			/** @type {requestResponseList} */
			const resultList = [];
			const storage = targetStorage ?? this.#relevantRequestResponseList;
			for (const requestResponse of storage) {
				const [cachedRequest, cachedResponse] = requestResponse;
				if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
			}
			return resultList;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
		* @param {any} requestQuery
		* @param {any} request
		* @param {any | null} response
		* @param {import('../../types/cache').CacheQueryOptions | undefined} options
		* @returns {boolean}
		*/
		#requestMatchesCachedItem(requestQuery, request$4, response$1 = null, options) {
			const queryURL = new URL(requestQuery.url);
			const cachedURL = new URL(request$4.url);
			if (options?.ignoreSearch) {
				cachedURL.search = "";
				queryURL.search = "";
			}
			if (!urlEquals(queryURL, cachedURL, true)) return false;
			if (response$1 == null || options?.ignoreVary || !response$1.headersList.contains("vary")) return true;
			const fieldValues = getFieldValues(response$1.headersList.get("vary"));
			for (const fieldValue of fieldValues) {
				if (fieldValue === "*") return false;
				const requestValue = request$4.headersList.get(fieldValue);
				const queryValue = requestQuery.headersList.get(fieldValue);
				if (requestValue !== queryValue) return false;
			}
			return true;
		}
		#internalMatchAll(request$4, options, maxResponses = Infinity) {
			let r = null;
			if (request$4 !== undefined) {
				if (request$4 instanceof Request$3) {
					r = request$4[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$4 === "string") r = new Request$3(request$4)[kState];
			}
			const responses = [];
			if (request$4 === undefined) for (const requestResponse of this.#relevantRequestResponseList) responses.push(requestResponse[1]);
else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) responses.push(requestResponse[1]);
			}
			const responseList = [];
			for (const response$1 of responses) {
				const responseObject = fromInnerResponse(response$1, "immutable");
				responseList.push(responseObject.clone());
				if (responseList.length >= maxResponses) break;
			}
			return Object.freeze(responseList);
		}
	}
	Object.defineProperties(Cache.prototype, {
		[Symbol.toStringTag]: {
			value: "Cache",
			configurable: true
		},
		match: kEnumerableProperty$1,
		matchAll: kEnumerableProperty$1,
		add: kEnumerableProperty$1,
		addAll: kEnumerableProperty$1,
		put: kEnumerableProperty$1,
		delete: kEnumerableProperty$1,
		keys: kEnumerableProperty$1
	});
	const cacheQueryOptionConverters = [
		{
			key: "ignoreSearch",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "ignoreMethod",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "ignoreVary",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		}
	];
	webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
	webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([...cacheQueryOptionConverters, {
		key: "cacheName",
		converter: webidl.converters.DOMString
	}]);
	webidl.converters.Response = webidl.interfaceConverter(Response$2);
	webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
	cache = { Cache };
	return cache;
}
var cachestorage;
var hasRequiredCachestorage;
function requireCachestorage() {
	if (hasRequiredCachestorage) return cachestorage;
	hasRequiredCachestorage = 1;
	const { kConstruct: kConstruct$1 } = requireSymbols$1();
	const { Cache } = requireCache();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty: kEnumerableProperty$1 } = util$n;
	class CacheStorage$1 {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
		* @type {Map<string, import('./cache').requestResponseList}
		*/
		#caches = new Map();
		constructor() {
			if (arguments[0] !== kConstruct$1) webidl.illegalConstructor();
		}
		async match(request$4, options = {}) {
			webidl.brandCheck(this, CacheStorage$1);
			webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
			request$4 = webidl.converters.RequestInfo(request$4);
			options = webidl.converters.MultiCacheQueryOptions(options);
			if (options.cacheName != null) {
				if (this.#caches.has(options.cacheName)) {
					const cacheList = this.#caches.get(options.cacheName);
					const cache$1 = new Cache(kConstruct$1, cacheList);
					return await cache$1.match(request$4, options);
				}
			} else for (const cacheList of this.#caches.values()) {
				const cache$1 = new Cache(kConstruct$1, cacheList);
				const response$1 = await cache$1.match(request$4, options);
				if (response$1 !== undefined) return response$1;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-has
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async has(cacheName) {
			webidl.brandCheck(this, CacheStorage$1);
			const prefix = "CacheStorage.has";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
			return this.#caches.has(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
		* @param {string} cacheName
		* @returns {Promise<Cache>}
		*/
		async open(cacheName) {
			webidl.brandCheck(this, CacheStorage$1);
			const prefix = "CacheStorage.open";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
			if (this.#caches.has(cacheName)) {
				const cache$2 = this.#caches.get(cacheName);
				return new Cache(kConstruct$1, cache$2);
			}
			const cache$1 = [];
			this.#caches.set(cacheName, cache$1);
			return new Cache(kConstruct$1, cache$1);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async delete(cacheName) {
			webidl.brandCheck(this, CacheStorage$1);
			const prefix = "CacheStorage.delete";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
			return this.#caches.delete(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
		* @returns {Promise<string[]>}
		*/
		async keys() {
			webidl.brandCheck(this, CacheStorage$1);
			const keys = this.#caches.keys();
			return [...keys];
		}
	}
	Object.defineProperties(CacheStorage$1.prototype, {
		[Symbol.toStringTag]: {
			value: "CacheStorage",
			configurable: true
		},
		match: kEnumerableProperty$1,
		has: kEnumerableProperty$1,
		open: kEnumerableProperty$1,
		delete: kEnumerableProperty$1,
		keys: kEnumerableProperty$1
	});
	cachestorage = { CacheStorage: CacheStorage$1 };
	return cachestorage;
}
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;
	const maxAttributeValueSize = 1024;
	const maxNameValuePairSize = 4096;
	constants$1 = {
		maxAttributeValueSize,
		maxNameValuePairSize
	};
	return constants$1;
}
var util$3;
var hasRequiredUtil$2;
function requireUtil$2() {
	if (hasRequiredUtil$2) return util$3;
	hasRequiredUtil$2 = 1;
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	function isCTLExcludingHtab(value) {
		for (let i = 0; i < value.length; ++i) {
			const code = value.charCodeAt(i);
			if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) return true;
		}
		return false;
	}
	/**
	CHAR           = <any US-ASCII character (octets 0 - 127)>
	token          = 1*<any CHAR except CTLs or separators>
	separators     = "(" | ")" | "<" | ">" | "@"
	| "," | ";" | ":" | "\" | <">
	| "/" | "[" | "]" | "?" | "="
	| "{" | "}" | SP | HT
	* @param {string} name
	*/
	function validateCookieName(name) {
		for (let i = 0; i < name.length; ++i) {
			const code = name.charCodeAt(i);
			if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 60 || code === 62 || code === 64 || code === 44 || code === 59 || code === 58 || code === 92 || code === 47 || code === 91 || code === 93 || code === 63 || code === 61 || code === 123 || code === 125) throw new Error("Invalid cookie name");
		}
	}
	/**
	cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	; US-ASCII characters excluding CTLs,
	; whitespace DQUOTE, comma, semicolon,
	; and backslash
	* @param {string} value
	*/
	function validateCookieValue(value) {
		let len = value.length;
		let i = 0;
		if (value[0] === "\"") {
			if (len === 1 || value[len - 1] !== "\"") throw new Error("Invalid cookie value");
			--len;
			++i;
		}
		while (i < len) {
			const code = value.charCodeAt(i++);
			if (code < 33 || code > 126 || code === 34 || code === 44 || code === 59 || code === 92) throw new Error("Invalid cookie value");
		}
	}
	/**
	* path-value        = <any CHAR except CTLs or ";">
	* @param {string} path
	*/
	function validateCookiePath(path$1) {
		for (let i = 0; i < path$1.length; ++i) {
			const code = path$1.charCodeAt(i);
			if (code < 32 || code === 127 || code === 59) throw new Error("Invalid cookie path");
		}
	}
	/**
	* I have no idea why these values aren't allowed to be honest,
	* but Deno tests these. - Khafra
	* @param {string} domain
	*/
	function validateCookieDomain(domain) {
		if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) throw new Error("Invalid cookie domain");
	}
	const IMFDays = [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	];
	const IMFMonths = [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	];
	const IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
	/**
	* @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	* @param {number|Date} date
	IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	; fixed length/zone/capitalization subset of the format
	; see Section 3.3 of [RFC5322]
	
	day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	/ %x54.75.65 ; "Tue", case-sensitive
	/ %x57.65.64 ; "Wed", case-sensitive
	/ %x54.68.75 ; "Thu", case-sensitive
	/ %x46.72.69 ; "Fri", case-sensitive
	/ %x53.61.74 ; "Sat", case-sensitive
	/ %x53.75.6E ; "Sun", case-sensitive
	date1        = day SP month SP year
	; e.g., 02 Jun 1982
	
	day          = 2DIGIT
	month        = %x4A.61.6E ; "Jan", case-sensitive
	/ %x46.65.62 ; "Feb", case-sensitive
	/ %x4D.61.72 ; "Mar", case-sensitive
	/ %x41.70.72 ; "Apr", case-sensitive
	/ %x4D.61.79 ; "May", case-sensitive
	/ %x4A.75.6E ; "Jun", case-sensitive
	/ %x4A.75.6C ; "Jul", case-sensitive
	/ %x41.75.67 ; "Aug", case-sensitive
	/ %x53.65.70 ; "Sep", case-sensitive
	/ %x4F.63.74 ; "Oct", case-sensitive
	/ %x4E.6F.76 ; "Nov", case-sensitive
	/ %x44.65.63 ; "Dec", case-sensitive
	year         = 4DIGIT
	
	GMT          = %x47.4D.54 ; "GMT", case-sensitive
	
	time-of-day  = hour ":" minute ":" second
	; 00:00:00 - 23:59:60 (leap second)
	
	hour         = 2DIGIT
	minute       = 2DIGIT
	second       = 2DIGIT
	*/
	function toIMFDate(date) {
		if (typeof date === "number") date = new Date(date);
		return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
	}
	/**
	max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	; In practice, both expires-av and max-age-av
	; are limited to dates representable by the
	; user agent.
	* @param {number} maxAge
	*/
	function validateCookieMaxAge(maxAge) {
		if (maxAge < 0) throw new Error("Invalid cookie max-age");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	* @param {import('./index').Cookie} cookie
	*/
	function stringify$1(cookie) {
		if (cookie.name.length === 0) return null;
		validateCookieName(cookie.name);
		validateCookieValue(cookie.value);
		const out = [`${cookie.name}=${cookie.value}`];
		if (cookie.name.startsWith("__Secure-")) cookie.secure = true;
		if (cookie.name.startsWith("__Host-")) {
			cookie.secure = true;
			cookie.domain = null;
			cookie.path = "/";
		}
		if (cookie.secure) out.push("Secure");
		if (cookie.httpOnly) out.push("HttpOnly");
		if (typeof cookie.maxAge === "number") {
			validateCookieMaxAge(cookie.maxAge);
			out.push(`Max-Age=${cookie.maxAge}`);
		}
		if (cookie.domain) {
			validateCookieDomain(cookie.domain);
			out.push(`Domain=${cookie.domain}`);
		}
		if (cookie.path) {
			validateCookiePath(cookie.path);
			out.push(`Path=${cookie.path}`);
		}
		if (cookie.expires && cookie.expires.toString() !== "Invalid Date") out.push(`Expires=${toIMFDate(cookie.expires)}`);
		if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
		for (const part of cookie.unparsed) {
			if (!part.includes("=")) throw new Error("Invalid unparsed");
			const [key, ...value] = part.split("=");
			out.push(`${key.trim()}=${value.join("=")}`);
		}
		return out.join("; ");
	}
	util$3 = {
		isCTLExcludingHtab,
		validateCookieName,
		validateCookiePath,
		validateCookieValue,
		toIMFDate,
		stringify: stringify$1
	};
	return util$3;
}
var parse;
var hasRequiredParse;
function requireParse() {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;
	const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$1();
	const { isCTLExcludingHtab } = requireUtil$2();
	const { collectASequenceOfCodePointsFast } = requireDataUrl();
	const assert$10 = require$$0;
	/**
	* @description Parses the field-value attributes of a set-cookie header string.
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} header
	* @returns if the header is invalid, null will be returned
	*/
	function parseSetCookie(header) {
		if (isCTLExcludingHtab(header)) return null;
		let nameValuePair = "";
		let unparsedAttributes = "";
		let name = "";
		let value = "";
		if (header.includes(";")) {
			const position = { position: 0 };
			nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
			unparsedAttributes = header.slice(position.position);
		} else nameValuePair = header;
		if (!nameValuePair.includes("=")) value = nameValuePair;
else {
			const position = { position: 0 };
			name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
			value = nameValuePair.slice(position.position + 1);
		}
		name = name.trim();
		value = value.trim();
		if (name.length + value.length > maxNameValuePairSize) return null;
		return {
			name,
			value,
			...parseUnparsedAttributes(unparsedAttributes)
		};
	}
	/**
	* Parses the remaining attributes of a set-cookie header
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} unparsedAttributes
	* @param {[Object.<string, unknown>]={}} cookieAttributeList
	*/
	function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
		if (unparsedAttributes.length === 0) return cookieAttributeList;
		assert$10(unparsedAttributes[0] === ";");
		unparsedAttributes = unparsedAttributes.slice(1);
		let cookieAv = "";
		if (unparsedAttributes.includes(";")) {
			cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
			unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
		} else {
			cookieAv = unparsedAttributes;
			unparsedAttributes = "";
		}
		let attributeName = "";
		let attributeValue = "";
		if (cookieAv.includes("=")) {
			const position = { position: 0 };
			attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
			attributeValue = cookieAv.slice(position.position + 1);
		} else attributeName = cookieAv;
		attributeName = attributeName.trim();
		attributeValue = attributeValue.trim();
		if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
		const attributeNameLowercase = attributeName.toLowerCase();
		if (attributeNameLowercase === "expires") {
			const expiryTime = new Date(attributeValue);
			cookieAttributeList.expires = expiryTime;
		} else if (attributeNameLowercase === "max-age") {
			const charCode = attributeValue.charCodeAt(0);
			if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			const deltaSeconds = Number(attributeValue);
			cookieAttributeList.maxAge = deltaSeconds;
		} else if (attributeNameLowercase === "domain") {
			let cookieDomain = attributeValue;
			if (cookieDomain[0] === ".") cookieDomain = cookieDomain.slice(1);
			cookieDomain = cookieDomain.toLowerCase();
			cookieAttributeList.domain = cookieDomain;
		} else if (attributeNameLowercase === "path") {
			let cookiePath = "";
			if (attributeValue.length === 0 || attributeValue[0] !== "/") cookiePath = "/";
else cookiePath = attributeValue;
			cookieAttributeList.path = cookiePath;
		} else if (attributeNameLowercase === "secure") cookieAttributeList.secure = true;
else if (attributeNameLowercase === "httponly") cookieAttributeList.httpOnly = true;
else if (attributeNameLowercase === "samesite") {
			let enforcement = "Default";
			const attributeValueLowercase = attributeValue.toLowerCase();
			if (attributeValueLowercase.includes("none")) enforcement = "None";
			if (attributeValueLowercase.includes("strict")) enforcement = "Strict";
			if (attributeValueLowercase.includes("lax")) enforcement = "Lax";
			cookieAttributeList.sameSite = enforcement;
		} else {
			cookieAttributeList.unparsed ??= [];
			cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
		}
		return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
	}
	parse = {
		parseSetCookie,
		parseUnparsedAttributes
	};
	return parse;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;
	const { parseSetCookie } = requireParse();
	const { stringify: stringify$1 } = requireUtil$2();
	const { webidl } = requireWebidl();
	const { Headers: Headers$2 } = requireHeaders();
	/**
	* @typedef {Object} Cookie
	* @property {string} name
	* @property {string} value
	* @property {Date|number|undefined} expires
	* @property {number|undefined} maxAge
	* @property {string|undefined} domain
	* @property {string|undefined} path
	* @property {boolean|undefined} secure
	* @property {boolean|undefined} httpOnly
	* @property {'Strict'|'Lax'|'None'} sameSite
	* @property {string[]} unparsed
	*/
	/**
	* @param {Headers} headers
	* @returns {Record<string, string>}
	*/
	function getCookies$1(headers$1) {
		webidl.argumentLengthCheck(arguments, 1, "getCookies");
		webidl.brandCheck(headers$1, Headers$2, { strict: false });
		const cookie = headers$1.get("cookie");
		const out = {};
		if (!cookie) return out;
		for (const piece of cookie.split(";")) {
			const [name, ...value] = piece.split("=");
			out[name.trim()] = value.join("=");
		}
		return out;
	}
	/**
	* @param {Headers} headers
	* @param {string} name
	* @param {{ path?: string, domain?: string }|undefined} attributes
	* @returns {void}
	*/
	function deleteCookie$1(headers$1, name, attributes) {
		webidl.brandCheck(headers$1, Headers$2, { strict: false });
		const prefix = "deleteCookie";
		webidl.argumentLengthCheck(arguments, 2, prefix);
		name = webidl.converters.DOMString(name, prefix, "name");
		attributes = webidl.converters.DeleteCookieAttributes(attributes);
		setCookie$1(headers$1, {
			name,
			value: "",
			expires: new Date(0),
			...attributes
		});
	}
	/**
	* @param {Headers} headers
	* @returns {Cookie[]}
	*/
	function getSetCookies$1(headers$1) {
		webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
		webidl.brandCheck(headers$1, Headers$2, { strict: false });
		const cookies$1 = headers$1.getSetCookie();
		if (!cookies$1) return [];
		return cookies$1.map((pair) => parseSetCookie(pair));
	}
	/**
	* @param {Headers} headers
	* @param {Cookie} cookie
	* @returns {void}
	*/
	function setCookie$1(headers$1, cookie) {
		webidl.argumentLengthCheck(arguments, 2, "setCookie");
		webidl.brandCheck(headers$1, Headers$2, { strict: false });
		cookie = webidl.converters.Cookie(cookie);
		const str = stringify$1(cookie);
		if (str) headers$1.append("Set-Cookie", str);
	}
	webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([{
		converter: webidl.nullableConverter(webidl.converters.DOMString),
		key: "path",
		defaultValue: () => null
	}, {
		converter: webidl.nullableConverter(webidl.converters.DOMString),
		key: "domain",
		defaultValue: () => null
	}]);
	webidl.converters.Cookie = webidl.dictionaryConverter([
		{
			converter: webidl.converters.DOMString,
			key: "name"
		},
		{
			converter: webidl.converters.DOMString,
			key: "value"
		},
		{
			converter: webidl.nullableConverter((value) => {
				if (typeof value === "number") return webidl.converters["unsigned long long"](value);
				return new Date(value);
			}),
			key: "expires",
			defaultValue: () => null
		},
		{
			converter: webidl.nullableConverter(webidl.converters["long long"]),
			key: "maxAge",
			defaultValue: () => null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.DOMString),
			key: "domain",
			defaultValue: () => null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.DOMString),
			key: "path",
			defaultValue: () => null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.boolean),
			key: "secure",
			defaultValue: () => null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.boolean),
			key: "httpOnly",
			defaultValue: () => null
		},
		{
			converter: webidl.converters.USVString,
			key: "sameSite",
			allowedValues: [
				"Strict",
				"Lax",
				"None"
			]
		},
		{
			converter: webidl.sequenceConverter(webidl.converters.DOMString),
			key: "unparsed",
			defaultValue: () => new Array(0)
		}
	]);
	cookies = {
		getCookies: getCookies$1,
		deleteCookie: deleteCookie$1,
		getSetCookies: getSetCookies$1,
		setCookie: setCookie$1
	};
	return cookies;
}
var events;
var hasRequiredEvents;
function requireEvents() {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;
	const { webidl } = requireWebidl();
	const { kEnumerableProperty: kEnumerableProperty$1 } = util$n;
	const { kConstruct: kConstruct$1 } = symbols$4;
	const { MessagePort } = require$$3;
	/**
	* @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	*/
	class MessageEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			if (type === kConstruct$1) {
				super(arguments[1], arguments[2]);
				return;
			}
			const prefix = "MessageEvent constructor";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			type = webidl.converters.DOMString(type, prefix, "type");
			eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get data() {
			webidl.brandCheck(this, MessageEvent$1);
			return this.#eventInit.data;
		}
		get origin() {
			webidl.brandCheck(this, MessageEvent$1);
			return this.#eventInit.origin;
		}
		get lastEventId() {
			webidl.brandCheck(this, MessageEvent$1);
			return this.#eventInit.lastEventId;
		}
		get source() {
			webidl.brandCheck(this, MessageEvent$1);
			return this.#eventInit.source;
		}
		get ports() {
			webidl.brandCheck(this, MessageEvent$1);
			if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
			return this.#eventInit.ports;
		}
		initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
			webidl.brandCheck(this, MessageEvent$1);
			webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
			return new MessageEvent$1(type, {
				bubbles,
				cancelable,
				data,
				origin,
				lastEventId,
				source,
				ports
			});
		}
		static createFastMessageEvent(type, init) {
			const messageEvent = new MessageEvent$1(kConstruct$1, type, init);
			messageEvent.#eventInit = init;
			messageEvent.#eventInit.data ??= null;
			messageEvent.#eventInit.origin ??= "";
			messageEvent.#eventInit.lastEventId ??= "";
			messageEvent.#eventInit.source ??= null;
			messageEvent.#eventInit.ports ??= [];
			return messageEvent;
		}
	}
	const { createFastMessageEvent } = MessageEvent$1;
	delete MessageEvent$1.createFastMessageEvent;
	/**
	* @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	*/
	class CloseEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			const prefix = "CloseEvent constructor";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			type = webidl.converters.DOMString(type, prefix, "type");
			eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get wasClean() {
			webidl.brandCheck(this, CloseEvent$1);
			return this.#eventInit.wasClean;
		}
		get code() {
			webidl.brandCheck(this, CloseEvent$1);
			return this.#eventInit.code;
		}
		get reason() {
			webidl.brandCheck(this, CloseEvent$1);
			return this.#eventInit.reason;
		}
	}
	class ErrorEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict) {
			const prefix = "ErrorEvent constructor";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			super(type, eventInitDict);
			type = webidl.converters.DOMString(type, prefix, "type");
			eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
			this.#eventInit = eventInitDict;
		}
		get message() {
			webidl.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.message;
		}
		get filename() {
			webidl.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.filename;
		}
		get lineno() {
			webidl.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.lineno;
		}
		get colno() {
			webidl.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.colno;
		}
		get error() {
			webidl.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.error;
		}
	}
	Object.defineProperties(MessageEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "MessageEvent",
			configurable: true
		},
		data: kEnumerableProperty$1,
		origin: kEnumerableProperty$1,
		lastEventId: kEnumerableProperty$1,
		source: kEnumerableProperty$1,
		ports: kEnumerableProperty$1,
		initMessageEvent: kEnumerableProperty$1
	});
	Object.defineProperties(CloseEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "CloseEvent",
			configurable: true
		},
		reason: kEnumerableProperty$1,
		code: kEnumerableProperty$1,
		wasClean: kEnumerableProperty$1
	});
	Object.defineProperties(ErrorEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "ErrorEvent",
			configurable: true
		},
		message: kEnumerableProperty$1,
		filename: kEnumerableProperty$1,
		lineno: kEnumerableProperty$1,
		colno: kEnumerableProperty$1,
		error: kEnumerableProperty$1
	});
	webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
	webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
	const eventInit = [
		{
			key: "bubbles",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "cancelable",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "composed",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		}
	];
	webidl.converters.MessageEventInit = webidl.dictionaryConverter([
		...eventInit,
		{
			key: "data",
			converter: webidl.converters.any,
			defaultValue: () => null
		},
		{
			key: "origin",
			converter: webidl.converters.USVString,
			defaultValue: () => ""
		},
		{
			key: "lastEventId",
			converter: webidl.converters.DOMString,
			defaultValue: () => ""
		},
		{
			key: "source",
			converter: webidl.nullableConverter(webidl.converters.MessagePort),
			defaultValue: () => null
		},
		{
			key: "ports",
			converter: webidl.converters["sequence<MessagePort>"],
			defaultValue: () => new Array(0)
		}
	]);
	webidl.converters.CloseEventInit = webidl.dictionaryConverter([
		...eventInit,
		{
			key: "wasClean",
			converter: webidl.converters.boolean,
			defaultValue: () => false
		},
		{
			key: "code",
			converter: webidl.converters["unsigned short"],
			defaultValue: () => 0
		},
		{
			key: "reason",
			converter: webidl.converters.USVString,
			defaultValue: () => ""
		}
	]);
	webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
		...eventInit,
		{
			key: "message",
			converter: webidl.converters.DOMString,
			defaultValue: () => ""
		},
		{
			key: "filename",
			converter: webidl.converters.USVString,
			defaultValue: () => ""
		},
		{
			key: "lineno",
			converter: webidl.converters["unsigned long"],
			defaultValue: () => 0
		},
		{
			key: "colno",
			converter: webidl.converters["unsigned long"],
			defaultValue: () => 0
		},
		{
			key: "error",
			converter: webidl.converters.any
		}
	]);
	events = {
		MessageEvent: MessageEvent$1,
		CloseEvent: CloseEvent$1,
		ErrorEvent: ErrorEvent$1,
		createFastMessageEvent
	};
	return events;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	const uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	const states = {
		CONNECTING: 0,
		OPEN: 1,
		CLOSING: 2,
		CLOSED: 3
	};
	const sentCloseFrameState = {
		NOT_SENT: 0,
		PROCESSING: 1,
		SENT: 2
	};
	const opcodes = {
		CONTINUATION: 0,
		TEXT: 1,
		BINARY: 2,
		CLOSE: 8,
		PING: 9,
		PONG: 10
	};
	const maxUnsigned16Bit = 65535;
	const parserStates = {
		INFO: 0,
		PAYLOADLENGTH_16: 2,
		PAYLOADLENGTH_64: 3,
		READ_DATA: 4
	};
	const emptyBuffer = Buffer.allocUnsafe(0);
	const sendHints = {
		string: 1,
		typedArray: 2,
		arrayBuffer: 3,
		blob: 4
	};
	constants = {
		uid,
		sentCloseFrameState,
		staticPropertyDescriptors,
		states,
		opcodes,
		maxUnsigned16Bit,
		parserStates,
		emptyBuffer,
		sendHints
	};
	return constants;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;
	symbols = {
		kWebSocketURL: Symbol("url"),
		kReadyState: Symbol("ready state"),
		kController: Symbol("controller"),
		kResponse: Symbol("response"),
		kBinaryType: Symbol("binary type"),
		kSentClose: Symbol("sent close"),
		kReceivedClose: Symbol("received close"),
		kByteParser: Symbol("byte parser")
	};
	return symbols;
}
var util$2;
var hasRequiredUtil$1;
function requireUtil$1() {
	if (hasRequiredUtil$1) return util$2;
	hasRequiredUtil$1 = 1;
	const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = requireSymbols();
	const { states, opcodes } = requireConstants();
	const { ErrorEvent: ErrorEvent$1, createFastMessageEvent } = requireEvents();
	const { isUtf8 } = require$$0$2;
	const { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = requireDataUrl();
	/**
	* @param {import('./websocket').WebSocket} ws
	* @returns {boolean}
	*/
	function isConnecting(ws) {
		return ws[kReadyState] === states.CONNECTING;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @returns {boolean}
	*/
	function isEstablished(ws) {
		return ws[kReadyState] === states.OPEN;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @returns {boolean}
	*/
	function isClosing(ws) {
		return ws[kReadyState] === states.CLOSING;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @returns {boolean}
	*/
	function isClosed(ws) {
		return ws[kReadyState] === states.CLOSED;
	}
	/**
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e
	* @param {EventTarget} target
	* @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory
	* @param {EventInit | undefined} eventInitDict
	*/
	function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
		const event = eventFactory(e, eventInitDict);
		target.dispatchEvent(event);
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @param {import('./websocket').WebSocket} ws
	* @param {number} type Opcode
	* @param {Buffer} data application data
	*/
	function websocketMessageReceived(ws, type, data) {
		if (ws[kReadyState] !== states.OPEN) return;
		let dataForEvent;
		if (type === opcodes.TEXT) try {
			dataForEvent = utf8Decode(data);
		} catch {
			failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
			return;
		}
else if (type === opcodes.BINARY) if (ws[kBinaryType] === "blob") dataForEvent = new Blob([data]);
else dataForEvent = toArrayBuffer(data);
		fireEvent("message", ws, createFastMessageEvent, {
			origin: ws[kWebSocketURL].origin,
			data: dataForEvent
		});
	}
	function toArrayBuffer(buffer) {
		if (buffer.byteLength === buffer.buffer.byteLength) return buffer.buffer;
		return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455
	* @see https://datatracker.ietf.org/doc/html/rfc2616
	* @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	* @param {string} protocol
	*/
	function isValidSubprotocol(protocol) {
		if (protocol.length === 0) return false;
		for (let i = 0; i < protocol.length; ++i) {
			const code = protocol.charCodeAt(i);
			if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code === 58 || code === 59 || code === 60 || code === 61 || code === 62 || code === 63 || code === 64 || code === 91 || code === 92 || code === 93 || code === 123 || code === 125) return false;
		}
		return true;
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	* @param {number} code
	*/
	function isValidStatusCode(code) {
		if (code >= 1e3 && code < 1015) return code !== 1004 && code !== 1005 && code !== 1006;
		return code >= 3e3 && code <= 4999;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @param {string|undefined} reason
	*/
	function failWebsocketConnection(ws, reason) {
		const { [kController]: controller, [kResponse]: response$1 } = ws;
		controller.abort();
		if (response$1?.socket && !response$1.socket.destroyed) response$1.socket.destroy();
		if (reason) fireEvent("error", ws, (type, init) => new ErrorEvent$1(type, init), {
			error: new Error(reason),
			message: reason
		});
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5
	* @param {number} opcode
	*/
	function isControlFrame(opcode) {
		return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
	}
	function isContinuationFrame(opcode) {
		return opcode === opcodes.CONTINUATION;
	}
	function isTextBinaryFrame(opcode) {
		return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
	}
	function isValidOpcode(opcode) {
		return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
	}
	/**
	* Parses a Sec-WebSocket-Extensions header value.
	* @param {string} extensions
	* @returns {Map<string, string>}
	*/
	function parseExtensions(extensions) {
		const position = { position: 0 };
		const extensionList = new Map();
		while (position.position < extensions.length) {
			const pair = collectASequenceOfCodePointsFast(";", extensions, position);
			const [name, value = ""] = pair.split("=");
			extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));
			position.position++;
		}
		return extensionList;
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2
	* @description "client-max-window-bits = 1*DIGIT"
	* @param {string} value
	*/
	function isValidClientWindowBits(value) {
		for (let i = 0; i < value.length; i++) {
			const byte = value.charCodeAt(i);
			if (byte < 48 || byte > 57) return false;
		}
		return true;
	}
	const hasIntl = typeof process.versions.icu === "string";
	const fatalDecoder = hasIntl ? new TextDecoder("utf-8", { fatal: true }) : undefined;
	/**
	* Converts a Buffer to utf-8, even on platforms without icu.
	* @param {Buffer} buffer
	*/
	const utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {
		if (isUtf8(buffer)) return buffer.toString("utf-8");
		throw new TypeError("Invalid utf-8 received.");
	};
	util$2 = {
		isConnecting,
		isEstablished,
		isClosing,
		isClosed,
		fireEvent,
		isValidSubprotocol,
		isValidStatusCode,
		failWebsocketConnection,
		websocketMessageReceived,
		utf8Decode,
		isControlFrame,
		isContinuationFrame,
		isTextBinaryFrame,
		isValidOpcode,
		parseExtensions,
		isValidClientWindowBits
	};
	return util$2;
}
var frame;
var hasRequiredFrame;
function requireFrame() {
	if (hasRequiredFrame) return frame;
	hasRequiredFrame = 1;
	const { maxUnsigned16Bit } = requireConstants();
	const BUFFER_SIZE = 16386;
	/** @type {import('crypto')} */
	let crypto;
	let buffer = null;
	let bufIdx = BUFFER_SIZE;
	try {
		crypto = __require("node:crypto");
	} catch {
		crypto = { randomFillSync: function randomFillSync(buffer$1, _offset, _size) {
			for (let i = 0; i < buffer$1.length; ++i) buffer$1[i] = Math.random() * 255 | 0;
			return buffer$1;
		} };
	}
	function generateMask() {
		if (bufIdx === BUFFER_SIZE) {
			bufIdx = 0;
			crypto.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);
		}
		return [
			buffer[bufIdx++],
			buffer[bufIdx++],
			buffer[bufIdx++],
			buffer[bufIdx++]
		];
	}
	class WebsocketFrameSend {
		/**
		* @param {Buffer|undefined} data
		*/
		constructor(data) {
			this.frameData = data;
		}
		createFrame(opcode) {
			const frameData = this.frameData;
			const maskKey = generateMask();
			const bodyLength$1 = frameData?.byteLength ?? 0;
			/** @type {number} */
			let payloadLength = bodyLength$1;
			let offset = 6;
			if (bodyLength$1 > maxUnsigned16Bit) {
				offset += 8;
				payloadLength = 127;
			} else if (bodyLength$1 > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const buffer$1 = Buffer.allocUnsafe(bodyLength$1 + offset);
			buffer$1[0] = buffer$1[1] = 0;
			buffer$1[0] |= 128;
			buffer$1[0] = (buffer$1[0] & 240) + opcode;
			/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
			buffer$1[offset - 4] = maskKey[0];
			buffer$1[offset - 3] = maskKey[1];
			buffer$1[offset - 2] = maskKey[2];
			buffer$1[offset - 1] = maskKey[3];
			buffer$1[1] = payloadLength;
			if (payloadLength === 126) buffer$1.writeUInt16BE(bodyLength$1, 2);
else if (payloadLength === 127) {
				buffer$1[2] = buffer$1[3] = 0;
				buffer$1.writeUIntBE(bodyLength$1, 4, 6);
			}
			buffer$1[1] |= 128;
			for (let i = 0; i < bodyLength$1; ++i) buffer$1[offset + i] = frameData[i] ^ maskKey[i & 3];
			return buffer$1;
		}
	}
	frame = { WebsocketFrameSend };
	return frame;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
	if (hasRequiredConnection) return connection;
	hasRequiredConnection = 1;
	const { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = requireConstants();
	const { kReadyState, kSentClose, kByteParser, kReceivedClose, kResponse } = requireSymbols();
	const { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = requireUtil$1();
	const { channels: channels$4 } = diagnostics;
	const { CloseEvent: CloseEvent$1 } = requireEvents();
	const { makeRequest } = requireRequest();
	const { fetching } = requireFetch();
	const { Headers: Headers$2, getHeadersList } = requireHeaders();
	const { getDecodeSplit } = requireUtil$5();
	const { WebsocketFrameSend } = requireFrame();
	/** @type {import('crypto')} */
	let crypto;
	try {
		crypto = __require("node:crypto");
	} catch {}
	/**
	* @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	* @param {URL} url
	* @param {string|string[]} protocols
	* @param {import('./websocket').WebSocket} ws
	* @param {(response: any, extensions: string[] | undefined) => void} onEstablish
	* @param {Partial<import('../../types/websocket').WebSocketInit>} options
	*/
	function establishWebSocketConnection(url$1, protocols, client$1, ws, onEstablish, options) {
		const requestURL = url$1;
		requestURL.protocol = url$1.protocol === "ws:" ? "http:" : "https:";
		const request$4 = makeRequest({
			urlList: [requestURL],
			client: client$1,
			serviceWorkers: "none",
			referrer: "no-referrer",
			mode: "websocket",
			credentials: "include",
			cache: "no-store",
			redirect: "error"
		});
		if (options.headers) {
			const headersList = getHeadersList(new Headers$2(options.headers));
			request$4.headersList = headersList;
		}
		const keyValue = crypto.randomBytes(16).toString("base64");
		request$4.headersList.append("sec-websocket-key", keyValue);
		request$4.headersList.append("sec-websocket-version", "13");
		for (const protocol of protocols) request$4.headersList.append("sec-websocket-protocol", protocol);
		const permessageDeflate$1 = "permessage-deflate; client_max_window_bits";
		request$4.headersList.append("sec-websocket-extensions", permessageDeflate$1);
		const controller = fetching({
			request: request$4,
			useParallelQueue: true,
			dispatcher: options.dispatcher,
			processResponse(response$1) {
				if (response$1.type === "error" || response$1.status !== 101) {
					failWebsocketConnection(ws, "Received network error or non-101 status code.");
					return;
				}
				if (protocols.length !== 0 && !response$1.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection(ws, "Server did not respond with sent protocols.");
					return;
				}
				if (response$1.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
					failWebsocketConnection(ws, "Server did not set Upgrade header to \"websocket\".");
					return;
				}
				if (response$1.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
					failWebsocketConnection(ws, "Server did not set Connection header to \"upgrade\".");
					return;
				}
				const secWSAccept = response$1.headersList.get("Sec-WebSocket-Accept");
				const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
				if (secWSAccept !== digest) {
					failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
					return;
				}
				const secExtension = response$1.headersList.get("Sec-WebSocket-Extensions");
				let extensions;
				if (secExtension !== null) {
					extensions = parseExtensions(secExtension);
					if (!extensions.has("permessage-deflate")) {
						failWebsocketConnection(ws, "Sec-WebSocket-Extensions header does not match.");
						return;
					}
				}
				const secProtocol = response$1.headersList.get("Sec-WebSocket-Protocol");
				if (secProtocol !== null) {
					const requestProtocols = getDecodeSplit("sec-websocket-protocol", request$4.headersList);
					if (!requestProtocols.includes(secProtocol)) {
						failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
						return;
					}
				}
				response$1.socket.on("data", onSocketData);
				response$1.socket.on("close", onSocketClose);
				response$1.socket.on("error", onSocketError);
				if (channels$4.open.hasSubscribers) channels$4.open.publish({
					address: response$1.socket.address(),
					protocol: secProtocol,
					extensions: secExtension
				});
				onEstablish(response$1, extensions);
			}
		});
		return controller;
	}
	function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
		if (isClosing(ws) || isClosed(ws));
else if (!isEstablished(ws)) {
			failWebsocketConnection(ws, "Connection was closed before it was established.");
			ws[kReadyState] = states.CLOSING;
		} else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
			ws[kSentClose] = sentCloseFrameState.PROCESSING;
			const frame$1 = new WebsocketFrameSend();
			if (code !== undefined && reason === undefined) {
				frame$1.frameData = Buffer.allocUnsafe(2);
				frame$1.frameData.writeUInt16BE(code, 0);
			} else if (code !== undefined && reason !== undefined) {
				frame$1.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
				frame$1.frameData.writeUInt16BE(code, 0);
				frame$1.frameData.write(reason, 2, "utf-8");
			} else frame$1.frameData = emptyBuffer;
			/** @type {import('stream').Duplex} */
			const socket = ws[kResponse].socket;
			socket.write(frame$1.createFrame(opcodes.CLOSE));
			ws[kSentClose] = sentCloseFrameState.SENT;
			ws[kReadyState] = states.CLOSING;
		} else ws[kReadyState] = states.CLOSING;
	}
	/**
	* @param {Buffer} chunk
	*/
	function onSocketData(chunk) {
		if (!this.ws[kByteParser].write(chunk)) this.pause();
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	*/
	function onSocketClose() {
		const { ws } = this;
		const { [kResponse]: response$1 } = ws;
		response$1.socket.off("data", onSocketData);
		response$1.socket.off("close", onSocketClose);
		response$1.socket.off("error", onSocketError);
		const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];
		let code = 1005;
		let reason = "";
		const result = ws[kByteParser].closingInfo;
		if (result && !result.error) {
			code = result.code ?? 1005;
			reason = result.reason;
		} else if (!ws[kReceivedClose]) code = 1006;
		ws[kReadyState] = states.CLOSED;
		fireEvent("close", ws, (type, init) => new CloseEvent$1(type, init), {
			wasClean,
			code,
			reason
		});
		if (channels$4.close.hasSubscribers) channels$4.close.publish({
			websocket: ws,
			code,
			reason
		});
	}
	function onSocketError(error) {
		const { ws } = this;
		ws[kReadyState] = states.CLOSING;
		if (channels$4.socketError.hasSubscribers) channels$4.socketError.publish(error);
		this.destroy();
	}
	connection = {
		establishWebSocketConnection,
		closeWebSocketConnection
	};
	return connection;
}
var permessageDeflate;
var hasRequiredPermessageDeflate;
function requirePermessageDeflate() {
	if (hasRequiredPermessageDeflate) return permessageDeflate;
	hasRequiredPermessageDeflate = 1;
	const { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require$$1;
	const { isValidClientWindowBits } = requireUtil$1();
	const tail = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kBuffer = Symbol("kBuffer");
	const kLength = Symbol("kLength");
	class PerMessageDeflate {
		/** @type {import('node:zlib').InflateRaw} */
		#inflate;
		#options = {};
		constructor(extensions) {
			this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
			this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
		}
		decompress(chunk, fin, callback) {
			if (!this.#inflate) {
				let windowBits = Z_DEFAULT_WINDOWBITS;
				if (this.#options.serverMaxWindowBits) {
					if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
						callback(new Error("Invalid server_max_window_bits"));
						return;
					}
					windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
				}
				this.#inflate = createInflateRaw({ windowBits });
				this.#inflate[kBuffer] = [];
				this.#inflate[kLength] = 0;
				this.#inflate.on("data", (data) => {
					this.#inflate[kBuffer].push(data);
					this.#inflate[kLength] += data.length;
				});
				this.#inflate.on("error", (err) => {
					this.#inflate = null;
					callback(err);
				});
			}
			this.#inflate.write(chunk);
			if (fin) this.#inflate.write(tail);
			this.#inflate.flush(() => {
				const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
				this.#inflate[kBuffer].length = 0;
				this.#inflate[kLength] = 0;
				callback(null, full);
			});
		}
	}
	permessageDeflate = { PerMessageDeflate };
	return permessageDeflate;
}
var receiver;
var hasRequiredReceiver;
function requireReceiver() {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;
	const { Writable } = stream;
	const assert$10 = require$$0;
	const { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = requireConstants();
	const { kReadyState, kSentClose, kResponse, kReceivedClose } = requireSymbols();
	const { channels: channels$4 } = diagnostics;
	const { isValidStatusCode, isValidOpcode, failWebsocketConnection, websocketMessageReceived, utf8Decode, isControlFrame, isTextBinaryFrame, isContinuationFrame } = requireUtil$1();
	const { WebsocketFrameSend } = requireFrame();
	const { closeWebSocketConnection } = requireConnection();
	const { PerMessageDeflate } = requirePermessageDeflate();
	class ByteParser extends Writable {
		#buffers = [];
		#byteOffset = 0;
		#loop = false;
		#state = parserStates.INFO;
		#info = {};
		#fragments = [];
		/** @type {Map<string, PerMessageDeflate>} */
		#extensions;
		constructor(ws, extensions) {
			super();
			this.ws = ws;
			this.#extensions = extensions == null ? new Map() : extensions;
			if (this.#extensions.has("permessage-deflate")) this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
		}
		/**
		* @param {Buffer} chunk
		* @param {() => void} callback
		*/
		_write(chunk, _, callback) {
			this.#buffers.push(chunk);
			this.#byteOffset += chunk.length;
			this.#loop = true;
			this.run(callback);
		}
		/**
		* Runs whenever a new chunk is received.
		* Callback is called whenever there are no more chunks buffering,
		* or not enough bytes are buffered to parse.
		*/
		run(callback) {
			while (this.#loop) if (this.#state === parserStates.INFO) {
				if (this.#byteOffset < 2) return callback();
				const buffer = this.consume(2);
				const fin = (buffer[0] & 128) !== 0;
				const opcode = buffer[0] & 15;
				const masked = (buffer[1] & 128) === 128;
				const fragmented = !fin && opcode !== opcodes.CONTINUATION;
				const payloadLength = buffer[1] & 127;
				const rsv1 = buffer[0] & 64;
				const rsv2 = buffer[0] & 32;
				const rsv3 = buffer[0] & 16;
				if (!isValidOpcode(opcode)) {
					failWebsocketConnection(this.ws, "Invalid opcode received");
					return callback();
				}
				if (masked) {
					failWebsocketConnection(this.ws, "Frame cannot be masked");
					return callback();
				}
				if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
					failWebsocketConnection(this.ws, "Expected RSV1 to be clear.");
					return;
				}
				if (rsv2 !== 0 || rsv3 !== 0) {
					failWebsocketConnection(this.ws, "RSV1, RSV2, RSV3 must be clear");
					return;
				}
				if (fragmented && !isTextBinaryFrame(opcode)) {
					failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
					return;
				}
				if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
					failWebsocketConnection(this.ws, "Expected continuation frame");
					return;
				}
				if (this.#info.fragmented && fragmented) {
					failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
					return;
				}
				if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
					failWebsocketConnection(this.ws, "Control frame either too large or fragmented");
					return;
				}
				if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
					failWebsocketConnection(this.ws, "Unexpected continuation frame");
					return;
				}
				if (payloadLength <= 125) {
					this.#info.payloadLength = payloadLength;
					this.#state = parserStates.READ_DATA;
				} else if (payloadLength === 126) this.#state = parserStates.PAYLOADLENGTH_16;
else if (payloadLength === 127) this.#state = parserStates.PAYLOADLENGTH_64;
				if (isTextBinaryFrame(opcode)) {
					this.#info.binaryType = opcode;
					this.#info.compressed = rsv1 !== 0;
				}
				this.#info.opcode = opcode;
				this.#info.masked = masked;
				this.#info.fin = fin;
				this.#info.fragmented = fragmented;
			} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
				if (this.#byteOffset < 2) return callback();
				const buffer = this.consume(2);
				this.#info.payloadLength = buffer.readUInt16BE(0);
				this.#state = parserStates.READ_DATA;
			} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
				if (this.#byteOffset < 8) return callback();
				const buffer = this.consume(8);
				const upper = buffer.readUInt32BE(0);
				if (upper > 2147483647) {
					failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
					return;
				}
				const lower = buffer.readUInt32BE(4);
				this.#info.payloadLength = (upper << 8) + lower;
				this.#state = parserStates.READ_DATA;
			} else if (this.#state === parserStates.READ_DATA) {
				if (this.#byteOffset < this.#info.payloadLength) return callback();
				const body$1 = this.consume(this.#info.payloadLength);
				if (isControlFrame(this.#info.opcode)) {
					this.#loop = this.parseControlFrame(body$1);
					this.#state = parserStates.INFO;
				} else if (!this.#info.compressed) {
					this.#fragments.push(body$1);
					if (!this.#info.fragmented && this.#info.fin) {
						const fullMessage = Buffer.concat(this.#fragments);
						websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);
						this.#fragments.length = 0;
					}
					this.#state = parserStates.INFO;
				} else {
					this.#extensions.get("permessage-deflate").decompress(body$1, this.#info.fin, (error, data) => {
						if (error) {
							closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);
							return;
						}
						this.#fragments.push(data);
						if (!this.#info.fin) {
							this.#state = parserStates.INFO;
							this.#loop = true;
							this.run(callback);
							return;
						}
						websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));
						this.#loop = true;
						this.#state = parserStates.INFO;
						this.#fragments.length = 0;
						this.run(callback);
					});
					this.#loop = false;
					break;
				}
			}
		}
		/**
		* Take n bytes from the buffered Buffers
		* @param {number} n
		* @returns {Buffer}
		*/
		consume(n) {
			if (n > this.#byteOffset) throw new Error("Called consume() before buffers satiated.");
else if (n === 0) return emptyBuffer;
			if (this.#buffers[0].length === n) {
				this.#byteOffset -= this.#buffers[0].length;
				return this.#buffers.shift();
			}
			const buffer = Buffer.allocUnsafe(n);
			let offset = 0;
			while (offset !== n) {
				const next = this.#buffers[0];
				const { length } = next;
				if (length + offset === n) {
					buffer.set(this.#buffers.shift(), offset);
					break;
				} else if (length + offset > n) {
					buffer.set(next.subarray(0, n - offset), offset);
					this.#buffers[0] = next.subarray(n - offset);
					break;
				} else {
					buffer.set(this.#buffers.shift(), offset);
					offset += next.length;
				}
			}
			this.#byteOffset -= n;
			return buffer;
		}
		parseCloseBody(data) {
			assert$10(data.length !== 1);
			/** @type {number|undefined} */
			let code;
			if (data.length >= 2) code = data.readUInt16BE(0);
			if (code !== undefined && !isValidStatusCode(code)) return {
				code: 1002,
				reason: "Invalid status code",
				error: true
			};
			/** @type {Buffer} */
			let reason = data.subarray(2);
			if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) reason = reason.subarray(3);
			try {
				reason = utf8Decode(reason);
			} catch {
				return {
					code: 1007,
					reason: "Invalid UTF-8",
					error: true
				};
			}
			return {
				code,
				reason,
				error: false
			};
		}
		/**
		* Parses control frames.
		* @param {Buffer} body
		*/
		parseControlFrame(body$1) {
			const { opcode, payloadLength } = this.#info;
			if (opcode === opcodes.CLOSE) {
				if (payloadLength === 1) {
					failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
					return false;
				}
				this.#info.closeInfo = this.parseCloseBody(body$1);
				if (this.#info.closeInfo.error) {
					const { code, reason } = this.#info.closeInfo;
					closeWebSocketConnection(this.ws, code, reason, reason.length);
					failWebsocketConnection(this.ws, reason);
					return false;
				}
				if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
					let body$2 = emptyBuffer;
					if (this.#info.closeInfo.code) {
						body$2 = Buffer.allocUnsafe(2);
						body$2.writeUInt16BE(this.#info.closeInfo.code, 0);
					}
					const closeFrame = new WebsocketFrameSend(body$2);
					this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
						if (!err) this.ws[kSentClose] = sentCloseFrameState.SENT;
					});
				}
				this.ws[kReadyState] = states.CLOSING;
				this.ws[kReceivedClose] = true;
				return false;
			} else if (opcode === opcodes.PING) {
				if (!this.ws[kReceivedClose]) {
					const frame$1 = new WebsocketFrameSend(body$1);
					this.ws[kResponse].socket.write(frame$1.createFrame(opcodes.PONG));
					if (channels$4.ping.hasSubscribers) channels$4.ping.publish({ payload: body$1 });
				}
			} else if (opcode === opcodes.PONG) {
				if (channels$4.pong.hasSubscribers) channels$4.pong.publish({ payload: body$1 });
			}
			return true;
		}
		get closingInfo() {
			return this.#info.closeInfo;
		}
	}
	receiver = { ByteParser };
	return receiver;
}
var sender;
var hasRequiredSender;
function requireSender() {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;
	const { WebsocketFrameSend } = requireFrame();
	const { opcodes, sendHints } = requireConstants();
	const FixedQueue$1 = fixedQueue;
	/** @type {typeof Uint8Array} */
	const FastBuffer$1 = Buffer[Symbol.species];
	/**
	* @typedef {object} SendQueueNode
	* @property {Promise<void> | null} promise
	* @property {((...args: any[]) => any)} callback
	* @property {Buffer | null} frame
	*/
	class SendQueue {
		/**
		* @type {FixedQueue}
		*/
		#queue = new FixedQueue$1();
		/**
		* @type {boolean}
		*/
		#running = false;
		/** @type {import('node:net').Socket} */
		#socket;
		constructor(socket) {
			this.#socket = socket;
		}
		add(item, cb, hint) {
			if (hint !== sendHints.blob) {
				const frame$1 = createFrame(item, hint);
				if (!this.#running) this.#socket.write(frame$1, cb);
else {
					/** @type {SendQueueNode} */
					const node$1 = {
						promise: null,
						callback: cb,
						frame: frame$1
					};
					this.#queue.push(node$1);
				}
				return;
			}
			/** @type {SendQueueNode} */
			const node = {
				promise: item.arrayBuffer().then((ab) => {
					node.promise = null;
					node.frame = createFrame(ab, hint);
				}),
				callback: cb,
				frame: null
			};
			this.#queue.push(node);
			if (!this.#running) this.#run();
		}
		async #run() {
			this.#running = true;
			const queue = this.#queue;
			while (!queue.isEmpty()) {
				const node = queue.shift();
				if (node.promise !== null) await node.promise;
				this.#socket.write(node.frame, node.callback);
				node.callback = node.frame = null;
			}
			this.#running = false;
		}
	}
	function createFrame(data, hint) {
		return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);
	}
	function toBuffer(data, hint) {
		switch (hint) {
			case sendHints.string: return Buffer.from(data);
			case sendHints.arrayBuffer:
			case sendHints.blob: return new FastBuffer$1(data);
			case sendHints.typedArray: return new FastBuffer$1(data.buffer, data.byteOffset, data.byteLength);
		}
	}
	sender = { SendQueue };
	return sender;
}
var websocket;
var hasRequiredWebsocket;
function requireWebsocket() {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;
	const { webidl } = requireWebidl();
	const { URLSerializer } = requireDataUrl();
	const { environmentSettingsObject } = requireUtil$5();
	const { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = requireConstants();
	const { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = requireSymbols();
	const { isConnecting, isEstablished, isClosing, isValidSubprotocol, fireEvent } = requireUtil$1();
	const { establishWebSocketConnection, closeWebSocketConnection } = requireConnection();
	const { ByteParser } = requireReceiver();
	const { kEnumerableProperty: kEnumerableProperty$1, isBlobLike: isBlobLike$2 } = util$n;
	const { getGlobalDispatcher: getGlobalDispatcher$2 } = global$1;
	const { types } = require$$0$3;
	const { ErrorEvent: ErrorEvent$1, CloseEvent: CloseEvent$1 } = requireEvents();
	const { SendQueue } = requireSender();
	class WebSocket$1 extends EventTarget {
		#events = {
			open: null,
			error: null,
			close: null,
			message: null
		};
		#bufferedAmount = 0;
		#protocol = "";
		#extensions = "";
		/** @type {SendQueue} */
		#sendQueue;
		/**
		* @param {string} url
		* @param {string|string[]} protocols
		*/
		constructor(url$1, protocols = []) {
			super();
			const prefix = "WebSocket constructor";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
			url$1 = webidl.converters.USVString(url$1, prefix, "url");
			protocols = options.protocols;
			const baseURL = environmentSettingsObject.settingsObject.baseUrl;
			let urlRecord;
			try {
				urlRecord = new URL(url$1, baseURL);
			} catch (e) {
				throw new DOMException(e, "SyntaxError");
			}
			if (urlRecord.protocol === "http:") urlRecord.protocol = "ws:";
else if (urlRecord.protocol === "https:") urlRecord.protocol = "wss:";
			if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
			if (urlRecord.hash || urlRecord.href.endsWith("#")) throw new DOMException("Got fragment", "SyntaxError");
			if (typeof protocols === "string") protocols = [protocols];
			if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			this[kWebSocketURL] = new URL(urlRecord.href);
			const client$1 = environmentSettingsObject.settingsObject;
			this[kController] = establishWebSocketConnection(urlRecord, protocols, client$1, this, (response$1, extensions) => this.#onConnectionEstablished(response$1, extensions), options);
			this[kReadyState] = WebSocket$1.CONNECTING;
			this[kSentClose] = sentCloseFrameState.NOT_SENT;
			this[kBinaryType] = "blob";
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-close
		* @param {number|undefined} code
		* @param {string|undefined} reason
		*/
		close(code = undefined, reason = undefined) {
			webidl.brandCheck(this, WebSocket$1);
			const prefix = "WebSocket.close";
			if (code !== undefined) code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
			if (reason !== undefined) reason = webidl.converters.USVString(reason, prefix, "reason");
			if (code !== undefined) {
				if (code !== 1e3 && (code < 3e3 || code > 4999)) throw new DOMException("invalid code", "InvalidAccessError");
			}
			let reasonByteLength = 0;
			if (reason !== undefined) {
				reasonByteLength = Buffer.byteLength(reason);
				if (reasonByteLength > 123) throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
			}
			closeWebSocketConnection(this, code, reason, reasonByteLength);
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-send
		* @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
		*/
		send(data) {
			webidl.brandCheck(this, WebSocket$1);
			const prefix = "WebSocket.send";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			data = webidl.converters.WebSocketSendData(data, prefix, "data");
			if (isConnecting(this)) throw new DOMException("Sent before connected.", "InvalidStateError");
			if (!isEstablished(this) || isClosing(this)) return;
			if (typeof data === "string") {
				const length = Buffer.byteLength(data);
				this.#bufferedAmount += length;
				this.#sendQueue.add(data, () => {
					this.#bufferedAmount -= length;
				}, sendHints.string);
			} else if (types.isArrayBuffer(data)) {
				this.#bufferedAmount += data.byteLength;
				this.#sendQueue.add(data, () => {
					this.#bufferedAmount -= data.byteLength;
				}, sendHints.arrayBuffer);
			} else if (ArrayBuffer.isView(data)) {
				this.#bufferedAmount += data.byteLength;
				this.#sendQueue.add(data, () => {
					this.#bufferedAmount -= data.byteLength;
				}, sendHints.typedArray);
			} else if (isBlobLike$2(data)) {
				this.#bufferedAmount += data.size;
				this.#sendQueue.add(data, () => {
					this.#bufferedAmount -= data.size;
				}, sendHints.blob);
			}
		}
		get readyState() {
			webidl.brandCheck(this, WebSocket$1);
			return this[kReadyState];
		}
		get bufferedAmount() {
			webidl.brandCheck(this, WebSocket$1);
			return this.#bufferedAmount;
		}
		get url() {
			webidl.brandCheck(this, WebSocket$1);
			return URLSerializer(this[kWebSocketURL]);
		}
		get extensions() {
			webidl.brandCheck(this, WebSocket$1);
			return this.#extensions;
		}
		get protocol() {
			webidl.brandCheck(this, WebSocket$1);
			return this.#protocol;
		}
		get onopen() {
			webidl.brandCheck(this, WebSocket$1);
			return this.#events.open;
		}
		set onopen(fn) {
			webidl.brandCheck(this, WebSocket$1);
			if (this.#events.open) this.removeEventListener("open", this.#events.open);
			if (typeof fn === "function") {
				this.#events.open = fn;
				this.addEventListener("open", fn);
			} else this.#events.open = null;
		}
		get onerror() {
			webidl.brandCheck(this, WebSocket$1);
			return this.#events.error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, WebSocket$1);
			if (this.#events.error) this.removeEventListener("error", this.#events.error);
			if (typeof fn === "function") {
				this.#events.error = fn;
				this.addEventListener("error", fn);
			} else this.#events.error = null;
		}
		get onclose() {
			webidl.brandCheck(this, WebSocket$1);
			return this.#events.close;
		}
		set onclose(fn) {
			webidl.brandCheck(this, WebSocket$1);
			if (this.#events.close) this.removeEventListener("close", this.#events.close);
			if (typeof fn === "function") {
				this.#events.close = fn;
				this.addEventListener("close", fn);
			} else this.#events.close = null;
		}
		get onmessage() {
			webidl.brandCheck(this, WebSocket$1);
			return this.#events.message;
		}
		set onmessage(fn) {
			webidl.brandCheck(this, WebSocket$1);
			if (this.#events.message) this.removeEventListener("message", this.#events.message);
			if (typeof fn === "function") {
				this.#events.message = fn;
				this.addEventListener("message", fn);
			} else this.#events.message = null;
		}
		get binaryType() {
			webidl.brandCheck(this, WebSocket$1);
			return this[kBinaryType];
		}
		set binaryType(type) {
			webidl.brandCheck(this, WebSocket$1);
			if (type !== "blob" && type !== "arraybuffer") this[kBinaryType] = "blob";
else this[kBinaryType] = type;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
		*/
		#onConnectionEstablished(response$1, parsedExtensions) {
			this[kResponse] = response$1;
			const parser = new ByteParser(this, parsedExtensions);
			parser.on("drain", onParserDrain);
			parser.on("error", onParserError.bind(this));
			response$1.socket.ws = this;
			this[kByteParser] = parser;
			this.#sendQueue = new SendQueue(response$1.socket);
			this[kReadyState] = states.OPEN;
			const extensions = response$1.headersList.get("sec-websocket-extensions");
			if (extensions !== null) this.#extensions = extensions;
			const protocol = response$1.headersList.get("sec-websocket-protocol");
			if (protocol !== null) this.#protocol = protocol;
			fireEvent("open", this);
		}
	}
	WebSocket$1.CONNECTING = WebSocket$1.prototype.CONNECTING = states.CONNECTING;
	WebSocket$1.OPEN = WebSocket$1.prototype.OPEN = states.OPEN;
	WebSocket$1.CLOSING = WebSocket$1.prototype.CLOSING = states.CLOSING;
	WebSocket$1.CLOSED = WebSocket$1.prototype.CLOSED = states.CLOSED;
	Object.defineProperties(WebSocket$1.prototype, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors,
		url: kEnumerableProperty$1,
		readyState: kEnumerableProperty$1,
		bufferedAmount: kEnumerableProperty$1,
		onopen: kEnumerableProperty$1,
		onerror: kEnumerableProperty$1,
		onclose: kEnumerableProperty$1,
		close: kEnumerableProperty$1,
		onmessage: kEnumerableProperty$1,
		binaryType: kEnumerableProperty$1,
		send: kEnumerableProperty$1,
		extensions: kEnumerableProperty$1,
		protocol: kEnumerableProperty$1,
		[Symbol.toStringTag]: {
			value: "WebSocket",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(WebSocket$1, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors
	});
	webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
	webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
		if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) return webidl.converters["sequence<DOMString>"](V);
		return webidl.converters.DOMString(V, prefix, argument);
	};
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
		{
			key: "protocols",
			converter: webidl.converters["DOMString or sequence<DOMString>"],
			defaultValue: () => new Array(0)
		},
		{
			key: "dispatcher",
			converter: webidl.converters.any,
			defaultValue: () => getGlobalDispatcher$2()
		},
		{
			key: "headers",
			converter: webidl.nullableConverter(webidl.converters.HeadersInit)
		}
	]);
	webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
		if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
		return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
	};
	webidl.converters.WebSocketSendData = function(V) {
		if (webidl.util.Type(V) === "Object") {
			if (isBlobLike$2(V)) return webidl.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) return webidl.converters.BufferSource(V);
		}
		return webidl.converters.USVString(V);
	};
	function onParserDrain() {
		this.ws[kResponse].socket.resume();
	}
	function onParserError(err) {
		let message;
		let code;
		if (err instanceof CloseEvent$1) {
			message = err.reason;
			code = err.code;
		} else message = err.message;
		fireEvent("error", this, () => new ErrorEvent$1("error", {
			error: err,
			message
		}));
		closeWebSocketConnection(this, code);
	}
	websocket = { WebSocket: WebSocket$1 };
	return websocket;
}
var util$1;
var hasRequiredUtil;
function requireUtil() {
	if (hasRequiredUtil) return util$1;
	hasRequiredUtil = 1;
	/**
	* Checks if the given value is a valid LastEventId.
	* @param {string} value
	* @returns {boolean}
	*/
	function isValidLastEventId(value) {
		return value.indexOf("\0") === -1;
	}
	/**
	* Checks if the given value is a base 10 digit.
	* @param {string} value
	* @returns {boolean}
	*/
	function isASCIINumber(value) {
		if (value.length === 0) return false;
		for (let i = 0; i < value.length; i++) if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
		return true;
	}
	function delay(ms) {
		return new Promise((resolve) => {
			setTimeout(resolve, ms).unref();
		});
	}
	util$1 = {
		isValidLastEventId,
		isASCIINumber,
		delay
	};
	return util$1;
}
var eventsourceStream;
var hasRequiredEventsourceStream;
function requireEventsourceStream() {
	if (hasRequiredEventsourceStream) return eventsourceStream;
	hasRequiredEventsourceStream = 1;
	const { Transform: Transform$1 } = stream;
	const { isASCIINumber, isValidLastEventId } = requireUtil();
	/**
	* @type {number[]} BOM
	*/
	const BOM = [
		239,
		187,
		191
	];
	/**
	* @type {10} LF
	*/
	const LF = 10;
	/**
	* @type {13} CR
	*/
	const CR = 13;
	/**
	* @type {58} COLON
	*/
	const COLON = 58;
	/**
	* @type {32} SPACE
	*/
	const SPACE = 32;
	/**
	* @typedef {object} EventSourceStreamEvent
	* @type {object}
	* @property {string} [event] The event type.
	* @property {string} [data] The data of the message.
	* @property {string} [id] A unique ID for the event.
	* @property {string} [retry] The reconnection time, in milliseconds.
	*/
	/**
	* @typedef eventSourceSettings
	* @type {object}
	* @property {string} lastEventId The last event ID received from the server.
	* @property {string} origin The origin of the event source.
	* @property {number} reconnectionTime The reconnection time, in milliseconds.
	*/
	class EventSourceStream extends Transform$1 {
		/**
		* @type {eventSourceSettings}
		*/
		state = null;
		/**
		* Leading byte-order-mark check.
		* @type {boolean}
		*/
		checkBOM = true;
		/**
		* @type {boolean}
		*/
		crlfCheck = false;
		/**
		* @type {boolean}
		*/
		eventEndCheck = false;
		/**
		* @type {Buffer}
		*/
		buffer = null;
		pos = 0;
		event = {
			data: undefined,
			event: undefined,
			id: undefined,
			retry: undefined
		};
		/**
		* @param {object} options
		* @param {eventSourceSettings} options.eventSourceSettings
		* @param {Function} [options.push]
		*/
		constructor(options = {}) {
			options.readableObjectMode = true;
			super(options);
			this.state = options.eventSourceSettings || {};
			if (options.push) this.push = options.push;
		}
		/**
		* @param {Buffer} chunk
		* @param {string} _encoding
		* @param {Function} callback
		* @returns {void}
		*/
		_transform(chunk, _encoding, callback) {
			if (chunk.length === 0) {
				callback();
				return;
			}
			if (this.buffer) this.buffer = Buffer.concat([this.buffer, chunk]);
else this.buffer = chunk;
			if (this.checkBOM) switch (this.buffer.length) {
				case 1:
					if (this.buffer[0] === BOM[0]) {
						callback();
						return;
					}
					this.checkBOM = false;
					callback();
					return;
				case 2:
					if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
						callback();
						return;
					}
					this.checkBOM = false;
					break;
				case 3:
					if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
						this.buffer = Buffer.alloc(0);
						this.checkBOM = false;
						callback();
						return;
					}
					this.checkBOM = false;
					break;
				default:
					if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) this.buffer = this.buffer.subarray(3);
					this.checkBOM = false;
					break;
			}
			while (this.pos < this.buffer.length) {
				if (this.eventEndCheck) {
					if (this.crlfCheck) {
						if (this.buffer[this.pos] === LF) {
							this.buffer = this.buffer.subarray(this.pos + 1);
							this.pos = 0;
							this.crlfCheck = false;
							continue;
						}
						this.crlfCheck = false;
					}
					if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
						if (this.buffer[this.pos] === CR) this.crlfCheck = true;
						this.buffer = this.buffer.subarray(this.pos + 1);
						this.pos = 0;
						if (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) this.processEvent(this.event);
						this.clearEvent();
						continue;
					}
					this.eventEndCheck = false;
					continue;
				}
				if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
					if (this.buffer[this.pos] === CR) this.crlfCheck = true;
					this.parseLine(this.buffer.subarray(0, this.pos), this.event);
					this.buffer = this.buffer.subarray(this.pos + 1);
					this.pos = 0;
					this.eventEndCheck = true;
					continue;
				}
				this.pos++;
			}
			callback();
		}
		/**
		* @param {Buffer} line
		* @param {EventStreamEvent} event
		*/
		parseLine(line, event) {
			if (line.length === 0) return;
			const colonPosition = line.indexOf(COLON);
			if (colonPosition === 0) return;
			let field = "";
			let value = "";
			if (colonPosition !== -1) {
				field = line.subarray(0, colonPosition).toString("utf8");
				let valueStart = colonPosition + 1;
				if (line[valueStart] === SPACE) ++valueStart;
				value = line.subarray(valueStart).toString("utf8");
			} else {
				field = line.toString("utf8");
				value = "";
			}
			switch (field) {
				case "data":
					if (event[field] === undefined) event[field] = value;
else event[field] += `\n${value}`;
					break;
				case "retry":
					if (isASCIINumber(value)) event[field] = value;
					break;
				case "id":
					if (isValidLastEventId(value)) event[field] = value;
					break;
				case "event":
					if (value.length > 0) event[field] = value;
					break;
			}
		}
		/**
		* @param {EventSourceStreamEvent} event
		*/
		processEvent(event) {
			if (event.retry && isASCIINumber(event.retry)) this.state.reconnectionTime = parseInt(event.retry, 10);
			if (event.id && isValidLastEventId(event.id)) this.state.lastEventId = event.id;
			if (event.data !== undefined) this.push({
				type: event.event || "message",
				options: {
					data: event.data,
					lastEventId: this.state.lastEventId,
					origin: this.state.origin
				}
			});
		}
		clearEvent() {
			this.event = {
				data: undefined,
				event: undefined,
				id: undefined,
				retry: undefined
			};
		}
	}
	eventsourceStream = { EventSourceStream };
	return eventsourceStream;
}
var eventsource;
var hasRequiredEventsource;
function requireEventsource() {
	if (hasRequiredEventsource) return eventsource;
	hasRequiredEventsource = 1;
	const { pipeline: pipeline$3 } = stream;
	const { fetching } = requireFetch();
	const { makeRequest } = requireRequest();
	const { webidl } = requireWebidl();
	const { EventSourceStream } = requireEventsourceStream();
	const { parseMIMEType: parseMIMEType$1 } = requireDataUrl();
	const { createFastMessageEvent } = requireEvents();
	const { isNetworkError } = requireResponse();
	const { delay } = requireUtil();
	const { kEnumerableProperty: kEnumerableProperty$1 } = util$n;
	const { environmentSettingsObject } = requireUtil$5();
	let experimentalWarned$1 = false;
	/**
	* A reconnection time, in milliseconds. This must initially be an implementation-defined value,
	* probably in the region of a few seconds.
	*
	* In Comparison:
	* - Chrome uses 3000ms.
	* - Deno uses 5000ms.
	*
	* @type {3000}
	*/
	const defaultReconnectionTime = 3e3;
	/**
	* The readyState attribute represents the state of the connection.
	* @enum
	* @readonly
	* @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev
	*/
	/**
	* The connection has not yet been established, or it was closed and the user
	* agent is reconnecting.
	* @type {0}
	*/
	const CONNECTING = 0;
	/**
	* The user agent has an open connection and is dispatching events as it
	* receives them.
	* @type {1}
	*/
	const OPEN = 1;
	/**
	* The connection is not open, and the user agent is not trying to reconnect.
	* @type {2}
	*/
	const CLOSED = 2;
	/**
	* Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".
	* @type {'anonymous'}
	*/
	const ANONYMOUS = "anonymous";
	/**
	* Requests for the element will have their mode set to "cors" and their credentials mode set to "include".
	* @type {'use-credentials'}
	*/
	const USE_CREDENTIALS = "use-credentials";
	/**
	* The EventSource interface is used to receive server-sent events. It
	* connects to a server over HTTP and receives events in text/event-stream
	* format without closing the connection.
	* @extends {EventTarget}
	* @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events
	* @api public
	*/
	class EventSource$1 extends EventTarget {
		#events = {
			open: null,
			error: null,
			message: null
		};
		#url = null;
		#withCredentials = false;
		#readyState = CONNECTING;
		#request = null;
		#controller = null;
		#dispatcher;
		/**
		* @type {import('./eventsource-stream').eventSourceSettings}
		*/
		#state;
		/**
		* Creates a new EventSource object.
		* @param {string} url
		* @param {EventSourceInit} [eventSourceInitDict]
		* @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
		*/
		constructor(url$1, eventSourceInitDict = {}) {
			super();
			const prefix = "EventSource constructor";
			webidl.argumentLengthCheck(arguments, 1, prefix);
			if (!experimentalWarned$1) {
				experimentalWarned$1 = true;
				process.emitWarning("EventSource is experimental, expect them to change at any time.", { code: "UNDICI-ES" });
			}
			url$1 = webidl.converters.USVString(url$1, prefix, "url");
			eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
			this.#dispatcher = eventSourceInitDict.dispatcher;
			this.#state = {
				lastEventId: "",
				reconnectionTime: defaultReconnectionTime
			};
			const settings = environmentSettingsObject;
			let urlRecord;
			try {
				urlRecord = new URL(url$1, settings.settingsObject.baseUrl);
				this.#state.origin = urlRecord.origin;
			} catch (e) {
				throw new DOMException(e, "SyntaxError");
			}
			this.#url = urlRecord.href;
			let corsAttributeState = ANONYMOUS;
			if (eventSourceInitDict.withCredentials) {
				corsAttributeState = USE_CREDENTIALS;
				this.#withCredentials = true;
			}
			const initRequest = {
				redirect: "follow",
				keepalive: true,
				mode: "cors",
				credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
				referrer: "no-referrer"
			};
			initRequest.client = environmentSettingsObject.settingsObject;
			initRequest.headersList = [["accept", {
				name: "accept",
				value: "text/event-stream"
			}]];
			initRequest.cache = "no-store";
			initRequest.initiator = "other";
			initRequest.urlList = [new URL(this.#url)];
			this.#request = makeRequest(initRequest);
			this.#connect();
		}
		/**
		* Returns the state of this EventSource object's connection. It can have the
		* values described below.
		* @returns {0|1|2}
		* @readonly
		*/
		get readyState() {
			return this.#readyState;
		}
		/**
		* Returns the URL providing the event stream.
		* @readonly
		* @returns {string}
		*/
		get url() {
			return this.#url;
		}
		/**
		* Returns a boolean indicating whether the EventSource object was
		* instantiated with CORS credentials set (true), or not (false, the default).
		*/
		get withCredentials() {
			return this.#withCredentials;
		}
		#connect() {
			if (this.#readyState === CLOSED) return;
			this.#readyState = CONNECTING;
			const fetchParams = {
				request: this.#request,
				dispatcher: this.#dispatcher
			};
			const processEventSourceEndOfBody = (response$1) => {
				if (isNetworkError(response$1)) {
					this.dispatchEvent(new Event("error"));
					this.close();
				}
				this.#reconnect();
			};
			fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
			fetchParams.processResponse = (response$1) => {
				if (isNetworkError(response$1)) if (response$1.aborted) {
					this.close();
					this.dispatchEvent(new Event("error"));
					return;
				} else {
					this.#reconnect();
					return;
				}
				const contentType = response$1.headersList.get("content-type", true);
				const mimeType = contentType !== null ? parseMIMEType$1(contentType) : "failure";
				const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
				if (response$1.status !== 200 || contentTypeValid === false) {
					this.close();
					this.dispatchEvent(new Event("error"));
					return;
				}
				this.#readyState = OPEN;
				this.dispatchEvent(new Event("open"));
				this.#state.origin = response$1.urlList[response$1.urlList.length - 1].origin;
				const eventSourceStream = new EventSourceStream({
					eventSourceSettings: this.#state,
					push: (event) => {
						this.dispatchEvent(createFastMessageEvent(event.type, event.options));
					}
				});
				pipeline$3(response$1.body.stream, eventSourceStream, (error) => {
					if (error?.aborted === false) {
						this.close();
						this.dispatchEvent(new Event("error"));
					}
				});
			};
			this.#controller = fetching(fetchParams);
		}
		/**
		* @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
		* @returns {Promise<void>}
		*/
		async #reconnect() {
			if (this.#readyState === CLOSED) return;
			this.#readyState = CONNECTING;
			this.dispatchEvent(new Event("error"));
			await delay(this.#state.reconnectionTime);
			if (this.#readyState !== CONNECTING) return;
			if (this.#state.lastEventId.length) this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
			this.#connect();
		}
		/**
		* Closes the connection, if any, and sets the readyState attribute to
		* CLOSED.
		*/
		close() {
			webidl.brandCheck(this, EventSource$1);
			if (this.#readyState === CLOSED) return;
			this.#readyState = CLOSED;
			this.#controller.abort();
			this.#request = null;
		}
		get onopen() {
			return this.#events.open;
		}
		set onopen(fn) {
			if (this.#events.open) this.removeEventListener("open", this.#events.open);
			if (typeof fn === "function") {
				this.#events.open = fn;
				this.addEventListener("open", fn);
			} else this.#events.open = null;
		}
		get onmessage() {
			return this.#events.message;
		}
		set onmessage(fn) {
			if (this.#events.message) this.removeEventListener("message", this.#events.message);
			if (typeof fn === "function") {
				this.#events.message = fn;
				this.addEventListener("message", fn);
			} else this.#events.message = null;
		}
		get onerror() {
			return this.#events.error;
		}
		set onerror(fn) {
			if (this.#events.error) this.removeEventListener("error", this.#events.error);
			if (typeof fn === "function") {
				this.#events.error = fn;
				this.addEventListener("error", fn);
			} else this.#events.error = null;
		}
	}
	const constantsPropertyDescriptors = {
		CONNECTING: {
			__proto__: null,
			configurable: false,
			enumerable: true,
			value: CONNECTING,
			writable: false
		},
		OPEN: {
			__proto__: null,
			configurable: false,
			enumerable: true,
			value: OPEN,
			writable: false
		},
		CLOSED: {
			__proto__: null,
			configurable: false,
			enumerable: true,
			value: CLOSED,
			writable: false
		}
	};
	Object.defineProperties(EventSource$1, constantsPropertyDescriptors);
	Object.defineProperties(EventSource$1.prototype, constantsPropertyDescriptors);
	Object.defineProperties(EventSource$1.prototype, {
		close: kEnumerableProperty$1,
		onerror: kEnumerableProperty$1,
		onmessage: kEnumerableProperty$1,
		onopen: kEnumerableProperty$1,
		readyState: kEnumerableProperty$1,
		url: kEnumerableProperty$1,
		withCredentials: kEnumerableProperty$1
	});
	webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([{
		key: "withCredentials",
		converter: webidl.converters.boolean,
		defaultValue: () => false
	}, {
		key: "dispatcher",
		converter: webidl.converters.any
	}]);
	eventsource = {
		EventSource: EventSource$1,
		defaultReconnectionTime
	};
	return eventsource;
}
const Client = client;
const Dispatcher = dispatcher;
const Pool = pool;
const BalancedPool = balancedPool;
const Agent = agent$1;
const ProxyAgent = proxyAgent;
const EnvHttpProxyAgent = envHttpProxyAgent;
const RetryAgent = retryAgent;
const errors = errors$1;
const util = util$n;
const { InvalidArgumentError } = errors;
const api = api$1;
const buildConnector = connect$3;
const MockClient = mockClient;
const MockAgent = mockAgent;
const MockPool = mockPool;
const mockErrors = mockErrors$1;
const RetryHandler = retryHandler;
const { getGlobalDispatcher, setGlobalDispatcher } = global$1;
const DecoratorHandler = decoratorHandler;
const RedirectHandler = redirectHandler;
const createRedirectInterceptor = redirectInterceptor;
Object.assign(Dispatcher.prototype, api);
var Dispatcher_1 = undici.Dispatcher = Dispatcher;
var Client_1 = undici.Client = Client;
var Pool_1 = undici.Pool = Pool;
var BalancedPool_1 = undici.BalancedPool = BalancedPool;
var Agent_1 = undici.Agent = Agent;
var ProxyAgent_1 = undici.ProxyAgent = ProxyAgent;
var EnvHttpProxyAgent_1 = undici.EnvHttpProxyAgent = EnvHttpProxyAgent;
var RetryAgent_1 = undici.RetryAgent = RetryAgent;
var RetryHandler_1 = undici.RetryHandler = RetryHandler;
var DecoratorHandler_1 = undici.DecoratorHandler = DecoratorHandler;
var RedirectHandler_1 = undici.RedirectHandler = RedirectHandler;
var createRedirectInterceptor_1 = undici.createRedirectInterceptor = createRedirectInterceptor;
var interceptors = undici.interceptors = {
	redirect,
	retry,
	dump
};
var buildConnector_1 = undici.buildConnector = buildConnector;
var errors_1 = undici.errors = errors;
var util_1 = undici.util = {
	parseHeaders: util.parseHeaders,
	headerNameToString: util.headerNameToString
};
function makeDispatcher(fn) {
	return (url$1, opts, handler) => {
		if (typeof opts === "function") {
			handler = opts;
			opts = null;
		}
		if (!url$1 || typeof url$1 !== "string" && typeof url$1 !== "object" && !(url$1 instanceof URL)) throw new InvalidArgumentError("invalid url");
		if (opts != null && typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
		if (opts && opts.path != null) {
			if (typeof opts.path !== "string") throw new InvalidArgumentError("invalid opts.path");
			let path$1 = opts.path;
			if (!opts.path.startsWith("/")) path$1 = `/${path$1}`;
			url$1 = new URL(util.parseOrigin(url$1).origin + path$1);
		} else {
			if (!opts) opts = typeof url$1 === "object" ? url$1 : {};
			url$1 = util.parseURL(url$1);
		}
		const { agent: agent$2, dispatcher: dispatcher$1 = getGlobalDispatcher() } = opts;
		if (agent$2) throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
		return fn.call(dispatcher$1, {
			...opts,
			origin: url$1.origin,
			path: url$1.search ? `${url$1.pathname}${url$1.search}` : url$1.pathname,
			method: opts.method || (opts.body ? "PUT" : "GET")
		}, handler);
	};
}
var setGlobalDispatcher_1 = undici.setGlobalDispatcher = setGlobalDispatcher;
var getGlobalDispatcher_1 = undici.getGlobalDispatcher = getGlobalDispatcher;
const fetchImpl = requireFetch().fetch;
var fetch = undici.fetch = async function fetch$1(init, options = undefined) {
	try {
		return await fetchImpl(init, options);
	} catch (err) {
		if (err && typeof err === "object") Error.captureStackTrace(err);
		throw err;
	}
};
var Headers$1 = undici.Headers = requireHeaders().Headers;
var Response$1 = undici.Response = requireResponse().Response;
var Request = undici.Request = requireRequest().Request;
var FormData = undici.FormData = requireFormdata().FormData;
var File = undici.File = globalThis.File ?? require$$0$2.File;
var FileReader = undici.FileReader = requireFilereader().FileReader;
const { setGlobalOrigin, getGlobalOrigin } = requireGlobal();
var setGlobalOrigin_1 = undici.setGlobalOrigin = setGlobalOrigin;
var getGlobalOrigin_1 = undici.getGlobalOrigin = getGlobalOrigin;
const { CacheStorage } = requireCachestorage();
const { kConstruct } = requireSymbols$1();
var caches = undici.caches = new CacheStorage(kConstruct);
const { deleteCookie, getCookies, getSetCookies, setCookie } = requireCookies();
var deleteCookie_1 = undici.deleteCookie = deleteCookie;
var getCookies_1 = undici.getCookies = getCookies;
var getSetCookies_1 = undici.getSetCookies = getSetCookies;
var setCookie_1 = undici.setCookie = setCookie;
const { parseMIMEType, serializeAMimeType } = requireDataUrl();
var parseMIMEType_1 = undici.parseMIMEType = parseMIMEType;
var serializeAMimeType_1 = undici.serializeAMimeType = serializeAMimeType;
const { CloseEvent, ErrorEvent, MessageEvent } = requireEvents();
var WebSocket = undici.WebSocket = requireWebsocket().WebSocket;
var CloseEvent_1 = undici.CloseEvent = CloseEvent;
var ErrorEvent_1 = undici.ErrorEvent = ErrorEvent;
var MessageEvent_1 = undici.MessageEvent = MessageEvent;
var request = undici.request = makeDispatcher(api.request);
var stream$3 = undici.stream = makeDispatcher(api.stream);
var pipeline = undici.pipeline = makeDispatcher(api.pipeline);
var connect = undici.connect = makeDispatcher(api.connect);
var upgrade = undici.upgrade = makeDispatcher(api.upgrade);
var MockClient_1 = undici.MockClient = MockClient;
var MockPool_1 = undici.MockPool = MockPool;
var MockAgent_1 = undici.MockAgent = MockAgent;
var mockErrors_1 = undici.mockErrors = mockErrors;
const { EventSource } = requireEventsource();
var EventSource_1 = undici.EventSource = EventSource;

//#endregion
//#region ../src/common/desktop/net/NetAgent.ts
/** How long the socket should stay open without any data sent over it. See IDLE_TIMEOUT_MS in tutadb. */
const SOCKET_IDLE_TIMEOUT_MS = 301e3;
/** Timeout between reading data. */
const READ_TIMEOUT_MS = 2e4;
const agent = new Agent_1({
	connections: 3,
	keepAliveTimeout: SOCKET_IDLE_TIMEOUT_MS,
	bodyTimeout: READ_TIMEOUT_MS,
	headersTimeout: READ_TIMEOUT_MS,
	connectTimeout: READ_TIMEOUT_MS,
	autoSelectFamily: true
});
const customFetch = async (target, init) => {
	if (init?.body != null) init.duplex = "half";
	return await fetch(target, {
		...init ?? {},
		dispatcher: agent
	});
};
function convertHeaders(headers$1) {
	const result = {};
	headers$1.forEach((val, key) => result[key] = val);
	return result;
}
function toGlobalResponse(response$1) {
	return response$1;
}

//#endregion
//#region ../src/common/desktop/net/ProtocolProxy.ts
const TAG = "[ProtocolProxy]";
const ASSET_PROTOCOL = "asset";
function handleProtocols(session, assetDir) {
	doHandleProtocols(session, assetDir, customFetch, path, fs);
}
function doHandleProtocols(session, assetDir, fetchImpl$1, pathModule, fsModule) {
	if (!interceptProtocol("http", session, fetchImpl$1)) throw new Error("could not intercept http protocol");
	if (!interceptProtocol("https", session, fetchImpl$1)) throw new Error("could not intercept https protocol");
	if (!handleAssetProtocol(session, assetDir, pathModule, fsModule)) throw new Error("could not register asset protocol");
}
/**
* intercept and proxy all requests for a protocol coming from a session. OPTIONS requests will be
* answered immediately without actually calling the server.
* @param session the session to intercept requests for
* @param protocol http and https use different modules, so we need to intercept them separately.
* @param fetchImpl an implementation of the fetch API (Request) => Promise<Response>
*/
function interceptProtocol(protocol, session, fetchImpl$1) {
	if (session.protocol.isProtocolHandled(protocol)) return true;
	session.protocol.handle(protocol, async (request$4) => {
		const { method, url: url$1, headers: globalHeaders } = request$4;
		const startTime = Date.now();
		if (!url$1.startsWith(protocol)) return new Response(null, { status: 400 });
else if (method == "OPTIONS") {
			log.debug(TAG, "intercepted options request, returning canned response");
			return optionsResponse();
		} else try {
			const options = {
				method,
				keepalive: true
			};
			const body$1 = await request$4.arrayBuffer();
			if (body$1.byteLength > 0) {
				globalHeaders.set("Content-Length", String(body$1.byteLength));
				options.body = body$1;
				options.duplex = "half";
			}
			options.headers = convertHeaders(globalHeaders);
			const response$1 = await fetchImpl$1(url$1, options);
			return toGlobalResponse(response$1);
		} catch (e) {
			const parsedUrl = new URL(url$1);
			const noQueryUrl = `${parsedUrl.protocol}//${parsedUrl.host}${parsedUrl.pathname}`;
			log.debug(TAG, `error for ${method} ${noQueryUrl}:`);
			log.debug(TAG, e);
			log.debug(TAG, JSON.stringify(errorToObj(e)));
			log.debug(TAG, `failed after ${Date.now() - startTime}ms`);
			return Response.error();
		}
	});
	return session.protocol.isProtocolHandled(protocol);
}
/**
* assign a custom handler the asset protocol scheme on the session if it has not been done yet.
* the handler will handle all relative requests for resources and ensures that only
*/
function handleAssetProtocol(session, assetDir, pathModule, fsModule) {
	if (session.protocol.isProtocolHandled(ASSET_PROTOCOL)) return true;
	session.protocol.handle(ASSET_PROTOCOL, async (request$4) => {
		const fail = (msg) => {
			log.debug(TAG, msg);
			return new Response(null, { status: 404 });
		};
		const url$1 = new URL(request$4.url);
		if (url$1.protocol.slice(0, -1) !== ASSET_PROTOCOL) return fail(`passed non-asset url to asset handler: ${url$1}`);
else if (url$1.hostname !== "app" || !url$1.pathname.startsWith("/")) return fail(`Invalid asset:// URL: ${request$4.url}`);
else {
			const filePath = pathModule.resolve(assetDir, url$1.pathname.substring(1));
			if (!filePath.startsWith(assetDir)) return fail(`Invalid asset URL ${request$4.url} w/ pathname ${url$1.pathname} got resolved to ${filePath})`);
else try {
				return fileFetch(filePath, fsModule);
			} catch (e) {
				return fail(`failed to read asset at ${request$4.url}: ${e.message}`);
			}
		}
	});
	return session.protocol.isProtocolHandled(ASSET_PROTOCOL);
}
const optionsResponse = lazyMemoized(() => {
	const headers$1 = new Headers();
	headers$1.set("Access-Control-Allow-Origin", "*");
	headers$1.set("Access-Control-Allow-Methods", "POST, GET, PUT, DELETE");
	headers$1.set("Access-Control-Allow-Headers", "*");
	return new Response(null, {
		status: 200,
		headers: headers$1
	});
});
async function fileFetch(filePath, fsModule) {
	const content = await fsModule.promises.readFile(filePath);
	const headers$1 = new Headers({
		"Content-Length": String(content.byteLength),
		"Content-Type": await getMimeTypeForFile(filePath)
	});
	return new Response(content, {
		status: 200,
		headers: headers$1
	});
}

//#endregion
export { doHandleProtocols, handleProtocols };
//# sourceMappingURL=ProtocolProxy-D3mwaAa4.js.map