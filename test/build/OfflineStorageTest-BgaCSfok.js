
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { getDayShifted, getFirstOrThrow, getTypeId, lastThrow, mapNullable, pMap } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import "./ClientDetector-D0v6Vqu6.js";
import { MailSetKind } from "./TutanotaConstants-3bwAESYA.js";
import "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import { GENERATED_MAX_ID, GENERATED_MIN_ID, Type, constructMailSetEntryId, elementIdPart, generatedIdToTimestamp, getElementId, listIdPart, timestampToGeneratedId } from "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import { BodyTypeRef, FileTypeRef, MailBagTypeRef, MailBoxTypeRef, MailDetailsBlobTypeRef, MailDetailsTypeRef, MailFolderTypeRef, MailSetEntryTypeRef, MailTypeRef, createMailFolderRef } from "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import { UserTypeRef } from "./TypeRefs-BP1jvX9p.js";
import { resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./SetupMultipleError-B6uY8P-x.js";
import "./dist-DcZ1Y4qd.js";
import "./EntityUpdateUtils-B5iTKMk4.js";
import "./ErrorHandler-DbW1lJbv.js";
import "./EventQueue-c-5UmjJa.js";
import { OfflineStorage, customTypeEncoders, encode, ensureBase64Ext, expandId } from "./EntityRestClient--6dT7ZRF.js";
import "./MessageDispatcher-wJwFhXWv.js";
import { untagSqlObject } from "./SqlValue-CkGu32Qd.js";
import { sql } from "./Sql-C9YhYNym.js";
import "./IndexTables-C5S9WDY9.js";
import "./IndexUtils-K27esrGs.js";
import "./better-sqlite3-BmG0PAc2.js";
import { DesktopSqlCipher } from "./DesktopSqlCipher-BloqMDJx.js";
import { InterWindowEventFacadeSendDispatcher } from "./InterWindowEventFacadeSendDispatcher-BTmViZah.js";
import "./FolderSystem-DLrUB8MO.js";
import "./MailChecks-PhVUoR7f.js";
import "./IndexerCore-CrLYpsA5.js";
import "./StandardMigrations-7xZlHwBq.js";
import { OfflineStorageMigrator } from "./OfflineStorageMigrator-CQqO_-Qy.js";
import { MailOfflineCleaner } from "./MailOfflineCleaner-BHMPStjr.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { verify } from "./dist-BY49f75m.js";
import { createTestEntity } from "./TestUtils-f_4UhLVE.js";
import * as fs$1 from "node:fs";

//#region tests/api/worker/offline/OfflineStorageTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
function incrementId(id, ms) {
	const timestamp = generatedIdToTimestamp(id);
	return timestampToGeneratedId(timestamp + ms);
}
var IdGenerator = class {
	constructor(currentId) {
		this.currentId = currentId;
	}
	getNext(incrementByMs = 6e4) {
		this.currentId = incrementId(this.currentId, incrementByMs);
		return this.currentId;
	}
};
function encode$1(thing) {
	return encode(thing, { typeEncoders: customTypeEncoders });
}
const nativePath = __NODE_GYP_better_sqlite3;
const database = "./testdatabase.sqlite";
const offlineDatabaseTestKey = Uint8Array.from([
	3957386659,
	354339016,
	3786337319,
	3366334248
]);
dist_default.spec("OfflineStorageDb", function() {
	const now = new Date("2022-01-01 00:00:00 UTC");
	const timeRangeDays = 10;
	const userId = "userId";
	const databaseKey = new Uint8Array([
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7
	]);
	/** get an id based on a timestamp that is {@param days} days away from the time range cutoff */
	const offsetId = (days) => timestampToGeneratedId(getDayShifted(now, 0 - timeRangeDays + days).getTime());
	const cutoffId = offsetId(0);
	let dbFacade;
	let dateProviderMock;
	let storage;
	let migratorMock;
	let offlineStorageCleanerMock;
	let interWindowEventSenderMock;
	dist_default.beforeEach(async function() {
		dbFacade = new DesktopSqlCipher(nativePath, database, false);
		dateProviderMock = (0, import_testdouble.object)();
		migratorMock = (0, import_testdouble.instance)(OfflineStorageMigrator);
		interWindowEventSenderMock = (0, import_testdouble.instance)(InterWindowEventFacadeSendDispatcher);
		offlineStorageCleanerMock = new MailOfflineCleaner();
		(0, import_testdouble.when)(dateProviderMock.now()).thenReturn(now.getTime());
		storage = new OfflineStorage(dbFacade, interWindowEventSenderMock, dateProviderMock, migratorMock, offlineStorageCleanerMock);
	});
	dist_default.afterEach(async function() {
		await dbFacade.closeDb();
		await fs$1.promises.unlink(database);
	});
	dist_default.spec("Unit test", function() {
		async function insertEntity(entity) {
			const typeModel = await resolveTypeReference(entity._type);
			const type = getTypeId(entity._type);
			let preparedQuery;
			switch (typeModel.type) {
				case Type.Element.valueOf():
					preparedQuery = sql`insert into element_entities
										values (${type}, ${entity._id}, ${entity._ownerGroup}, ${encode$1(entity)})`;
					break;
				case Type.ListElement.valueOf(): {
					const [listId, elementId] = entity._id;
					preparedQuery = sql`INSERT INTO list_entities
										VALUES (${type}, ${listId}, ${elementId}, ${entity._ownerGroup}, ${encode$1(entity)})`;
					break;
				}
				case Type.BlobElement.valueOf(): {
					const [archiveId, blobElementId] = entity._id;
					preparedQuery = sql`INSERT INTO blob_element_entities
										VALUES (${type}, ${archiveId}, ${blobElementId}, ${entity._ownerGroup}, ${encode$1(entity)})`;
					break;
				}
				default: throw new Error("must be a persistent type");
			}
			await dbFacade.run(preparedQuery.query, preparedQuery.params);
		}
		async function insertRange(type, listId, lower, upper) {
			const { query, params } = sql`INSERT INTO ranges
										  VALUES (${getTypeId(type)}, ${listId}, ${lower}, ${upper})`;
			await dbFacade.run(query, params);
		}
		async function getAllIdsForType(typeRef) {
			const typeModel = await resolveTypeReference(typeRef);
			let preparedQuery;
			switch (typeModel.type) {
				case Type.Element.valueOf():
					preparedQuery = sql`select *
										from element_entities
										where type = ${getTypeId(typeRef)}`;
					break;
				case Type.ListElement.valueOf():
					preparedQuery = sql`select *
										from list_entities
										where type = ${getTypeId(typeRef)}`;
					break;
				case Type.BlobElement.valueOf():
					preparedQuery = sql`select *
										from blob_element_entities
										where type = ${getTypeId(typeRef)}`;
					break;
				default: throw new Error("must be a persistent type");
			}
			return (await dbFacade.all(preparedQuery.query, preparedQuery.params)).map((r) => r.elementId.value);
		}
		dist_default("migrations are run", async function() {
			await storage.init({
				userId,
				databaseKey,
				timeRangeDays,
				forceNewDatabase: false
			});
			verify(migratorMock.migrate(storage, dbFacade));
		});
		dist_default.spec("Offline storage round trip", function() {
			dist_default.spec("ElementType", function() {
				dist_default("deleteAllOfType", async function() {
					const userId$1 = "id1";
					const storableUser = createTestEntity(UserTypeRef, { _id: userId$1 });
					await storage.init({
						userId: userId$1,
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					let user = await storage.get(UserTypeRef, null, userId$1);
					dist_default(user).equals(null);
					await storage.put(storableUser);
					user = await storage.get(UserTypeRef, null, userId$1);
					dist_default(user._id).equals(storableUser._id);
					await storage.deleteAllOfType(UserTypeRef);
					user = await storage.get(UserTypeRef, null, userId$1);
					dist_default(user).equals(null);
				});
			});
			dist_default.spec("ListElementType generatedId", function() {
				dist_default("deleteAllOfType", async function() {
					const listId = "listId1";
					const elementId = "id1";
					const storableMail = createTestEntity(MailTypeRef, { _id: [listId, elementId] });
					await storage.init({
						userId: elementId,
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					let mail = await storage.get(MailTypeRef, listId, elementId);
					dist_default(mail).equals(null);
					await storage.put(storableMail);
					await storage.setNewRangeForList(MailTypeRef, listId, elementId, elementId);
					mail = await storage.get(MailTypeRef, listId, elementId);
					dist_default(mail._id).deepEquals(storableMail._id);
					const rangeBefore = await storage.getRangeForList(MailTypeRef, listId);
					dist_default(rangeBefore).deepEquals({
						upper: elementId,
						lower: elementId
					});
					await storage.deleteAllOfType(MailTypeRef);
					mail = await storage.get(MailTypeRef, listId, elementId);
					dist_default(mail).equals(null);
					const rangeAfter = await storage.getRangeForList(MailTypeRef, listId);
					dist_default(rangeAfter).equals(null);
				});
				dist_default("deleteWholeList", async function() {
					const listOne = "listId1";
					const listTwo = "listId2";
					await storage.init({
						userId: "user",
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					const listOneMailOne = createTestEntity(MailTypeRef, { _id: [listOne, "id1"] });
					const listOneMailTwo = createTestEntity(MailTypeRef, { _id: [listOne, "id2"] });
					const listTwoMail = createTestEntity(MailTypeRef, { _id: [listTwo, "id3"] });
					await storage.put(listOneMailOne);
					await storage.put(listOneMailTwo);
					await storage.put(listTwoMail);
					await storage.setNewRangeForList(MailTypeRef, listOne, "id1", "id2");
					await storage.setNewRangeForList(MailTypeRef, listTwo, "id3", "id3");
					await storage.deleteWholeList(MailTypeRef, listOne);
					const mailsInListOne = await storage.getWholeList(MailTypeRef, listOne);
					const mailsInListTwo = await storage.getWholeList(MailTypeRef, listTwo);
					const rangeListOne = await storage.getRangeForList(MailTypeRef, listOne);
					const rangeListTwo = await storage.getRangeForList(MailTypeRef, listTwo);
					dist_default(mailsInListOne).deepEquals([]);
					dist_default(mailsInListTwo).deepEquals([listTwoMail]);
					dist_default(rangeListOne).equals(null);
					dist_default(rangeListTwo).deepEquals({
						lower: "id3",
						upper: "id3"
					});
				});
				dist_default("provideMultiple", async function() {
					const listId = "listId1";
					const elementId1 = "id1";
					const elementId2 = "id2";
					const storableMail1 = createTestEntity(MailTypeRef, { _id: [listId, elementId1] });
					const storableMail2 = createTestEntity(MailTypeRef, { _id: [listId, elementId2] });
					await storage.init({
						userId: elementId1,
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					let mails = await storage.provideMultiple(MailTypeRef, listId, [elementId1]);
					dist_default(mails).deepEquals([]);
					await storage.put(storableMail1);
					mails = await storage.provideMultiple(MailTypeRef, listId, [elementId1, elementId2]);
					dist_default(mails).deepEquals([storableMail1]);
					await storage.put(storableMail2);
					mails = await storage.provideMultiple(MailTypeRef, listId, [elementId1, elementId2]);
					dist_default(mails).deepEquals([storableMail1, storableMail2]);
				});
			});
			dist_default.spec("ListElementType customId", function() {
				dist_default("deleteAllOfType", async function() {
					const listId = "listId1";
					const elementId = constructMailSetEntryId(new Date(), "mailId");
					const storableMailSetEntry = createTestEntity(MailSetEntryTypeRef, { _id: [listId, elementId] });
					await storage.init({
						userId: elementId,
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					let mailSetEntry = await storage.get(MailSetEntryTypeRef, listId, elementId);
					dist_default(mailSetEntry).equals(null);
					await storage.put(storableMailSetEntry);
					await storage.setNewRangeForList(MailSetEntryTypeRef, listId, elementId, elementId);
					mailSetEntry = await storage.get(MailSetEntryTypeRef, listId, elementId);
					dist_default(mailSetEntry._id).deepEquals(storableMailSetEntry._id);
					const rangeBefore = await storage.getRangeForList(MailSetEntryTypeRef, listId);
					dist_default(rangeBefore).deepEquals({
						upper: elementId,
						lower: elementId
					});
					await storage.deleteAllOfType(MailSetEntryTypeRef);
					mailSetEntry = await storage.get(MailSetEntryTypeRef, listId, elementId);
					dist_default(mailSetEntry).equals(null);
					const rangeAfter = await storage.getRangeForList(MailSetEntryTypeRef, listId);
					dist_default(rangeAfter).equals(null);
				});
				dist_default("provideMultiple", async function() {
					const listId = "listId1";
					const elementId1 = constructMailSetEntryId(new Date(1724675875113), "mailId1");
					const elementId2 = constructMailSetEntryId(new Date(1724675899978), "mailId2");
					const storableMailSetEntry1 = createTestEntity(MailSetEntryTypeRef, { _id: [listId, elementId1] });
					const storableMailSetEntry2 = createTestEntity(MailSetEntryTypeRef, { _id: [listId, elementId2] });
					await storage.init({
						userId: elementId1,
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					let mails = await storage.provideMultiple(MailSetEntryTypeRef, listId, [elementId1]);
					dist_default(mails).deepEquals([]);
					await storage.put(storableMailSetEntry1);
					mails = await storage.provideMultiple(MailSetEntryTypeRef, listId, [elementId1, elementId2]);
					dist_default(mails).deepEquals([storableMailSetEntry1]);
					await storage.put(storableMailSetEntry2);
					mails = await storage.provideMultiple(MailSetEntryTypeRef, listId, [elementId1, elementId2]);
					dist_default(mails).deepEquals([storableMailSetEntry1, storableMailSetEntry2]);
				});
			});
			dist_default.spec("BlobElementType", function() {
				dist_default("put, get and delete", async function() {
					const archiveId = "archiveId";
					const blobElementId = "id1";
					const storableMailDetails = createTestEntity(MailDetailsBlobTypeRef, {
						_id: [archiveId, blobElementId],
						details: createTestEntity(MailDetailsTypeRef)
					});
					await storage.init({
						userId,
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					let mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
					dist_default(mailDetailsBlob).equals(null);
					await storage.put(storableMailDetails);
					mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
					mailDetailsBlob.details._type = MailDetailsTypeRef;
					dist_default(mailDetailsBlob).deepEquals(storableMailDetails);
					await storage.deleteIfExists(MailDetailsBlobTypeRef, archiveId, blobElementId);
					mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
					dist_default(mailDetailsBlob).equals(null);
				});
				dist_default("put, get and deleteAllOwnedBy", async function() {
					const archiveId = "archiveId";
					const blobElementId = "id1";
					const _ownerGroup = "ownerGroup";
					const storableMailDetails = createTestEntity(MailDetailsBlobTypeRef, {
						_id: [archiveId, blobElementId],
						_ownerGroup,
						details: createTestEntity(MailDetailsTypeRef)
					});
					await storage.init({
						userId,
						databaseKey,
						timeRangeDays,
						forceNewDatabase: false
					});
					await storage.put(storableMailDetails);
					await storage.deleteAllOwnedBy(_ownerGroup);
					const mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
					dist_default(mailDetailsBlob).equals(null);
				});
			});
		});
		dist_default.spec("Clearing excluded data for MailSet mailbox", function() {
			const spamFolderId = "spamFolder";
			const trashFolderId = "trashFolder";
			const spamListId = "spamList";
			const trashListId = "trashList";
			const spamMailSetEntriesId = "spamMailSetEntriesId";
			const trashMailSetEntriesId = "trashMailSetEntriesId";
			const mailListId = "listId";
			dist_default.beforeEach(async function() {
				await storage.init({
					userId,
					databaseKey,
					timeRangeDays,
					forceNewDatabase: false
				});
				await insertEntity(createTestEntity(MailBoxTypeRef, {
					_id: "mailboxId",
					currentMailBag: createTestEntity(MailBagTypeRef, {
						_id: "mailBagId",
						mails: mailListId
					}),
					folders: createMailFolderRef({ folders: "mailFolderList" })
				}));
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", spamFolderId],
					mails: spamListId,
					entries: spamMailSetEntriesId,
					folderType: MailSetKind.SPAM
				}));
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", trashFolderId],
					mails: trashListId,
					entries: trashMailSetEntriesId,
					folderType: MailSetKind.TRASH
				}));
			});
			dist_default("ranges before timeRangeDays will be deleted", async function() {
				const upperBeforeTimeRangeDays = offsetId(-1);
				const lowerBeforeTimeRangeDays = offsetId(-2);
				const upperDate = getDayShifted(now, 0 - timeRangeDays - 1);
				const lowerDate = getDayShifted(now, 0 - timeRangeDays - 2);
				const mailSetEntryTypeModel = await resolveTypeReference(MailSetEntryTypeRef);
				const lowerMailSetEntryIdBeforeTimeRangeDays = ensureBase64Ext(mailSetEntryTypeModel, constructMailSetEntryId(lowerDate, GENERATED_MIN_ID));
				const upperMailSetEntryIdBeforeTimeRangeDays = ensureBase64Ext(mailSetEntryTypeModel, constructMailSetEntryId(upperDate, GENERATED_MAX_ID));
				const mailId = [mailListId, "anything"];
				const mailSetEntryId = ["mailSetEntriesListId", constructMailSetEntryId(upperDate, elementIdPart(mailId))];
				const mailDetailsBlobId = ["mailDetailsList", "mailDetailsBlobId"];
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "mailFolderId"],
					mails: mailListId,
					entries: listIdPart(mailSetEntryId)
				}));
				await insertEntity(createTestEntity(MailSetEntryTypeRef, {
					_id: mailSetEntryId,
					mail: mailId
				}));
				await insertEntity(createTestEntity(MailTypeRef, {
					_id: mailId,
					mailDetails: mailDetailsBlobId,
					sets: [mailSetEntryId]
				}));
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: mailDetailsBlobId,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await insertRange(MailSetEntryTypeRef, listIdPart(mailSetEntryId), lowerMailSetEntryIdBeforeTimeRangeDays, upperMailSetEntryIdBeforeTimeRangeDays);
				await insertRange(MailTypeRef, mailListId, lowerBeforeTimeRangeDays, upperBeforeTimeRangeDays);
				await storage.clearExcludedData(timeRangeDays, userId);
				const allRanges = await dbFacade.all("SELECT * FROM ranges", []);
				dist_default(allRanges).deepEquals([]);
				const allMails = await getAllIdsForType(MailTypeRef);
				dist_default(allMails).deepEquals([]);
				const allMailSetEntries = await getAllIdsForType(MailSetEntryTypeRef);
				dist_default(allMailSetEntries).deepEquals([]);
				const allBlobDetails = await getAllIdsForType(MailDetailsBlobTypeRef);
				dist_default(allBlobDetails).deepEquals([]);
			});
		});
		dist_default.spec("Clearing excluded data for Non-MailSet mailbox", function() {
			const spamFolderId = "spamFolder";
			const trashFolderId = "trashFolder";
			const spamListId = "spamList";
			const trashListId = "trashList";
			const listId = "listId";
			const mailType = getTypeId(MailTypeRef);
			dist_default.beforeEach(async function() {
				await storage.init({
					userId,
					databaseKey,
					timeRangeDays,
					forceNewDatabase: false
				});
				await insertEntity(createTestEntity(MailBoxTypeRef, {
					_id: "mailboxId",
					currentMailBag: null,
					folders: createMailFolderRef({ folders: "mailFolderList" })
				}));
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", spamFolderId],
					mails: spamListId,
					folderType: MailSetKind.SPAM
				}));
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", trashFolderId],
					mails: trashListId,
					folderType: MailSetKind.TRASH
				}));
			});
			dist_default("ranges before timeRangeDays will be deleted", async function() {
				const upperBeforeTimeRangeDays = offsetId(-1);
				const lowerBeforeTimeRangeDays = offsetId(-2);
				const mailDetailsBlobId = ["mailDetailsList", "mailDetailsBlobId"];
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "mailFolderId"],
					mails: listId
				}));
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: mailDetailsBlobId,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await insertEntity(createTestEntity(MailTypeRef, {
					_id: [listId, "anything"],
					mailDetails: mailDetailsBlobId
				}));
				await insertRange(MailTypeRef, listId, lowerBeforeTimeRangeDays, upperBeforeTimeRangeDays);
				await storage.clearExcludedData(timeRangeDays, userId);
				const allRanges = await dbFacade.all("SELECT * FROM ranges", []);
				dist_default(allRanges).deepEquals([]);
				const allMails = await getAllIdsForType(MailTypeRef);
				dist_default(allMails).deepEquals([]);
				const allBlobDetails = await getAllIdsForType(MailDetailsBlobTypeRef);
				dist_default(allBlobDetails).deepEquals([]);
			});
			dist_default("modified ranges will be shrunk", async function() {
				const upper = offsetId(2);
				const lower = offsetId(-2);
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "mailFolderId"],
					folderType: MailSetKind.INBOX,
					mails: listId
				}));
				await insertRange(MailTypeRef, listId, lower, upper);
				await storage.clearExcludedData(timeRangeDays, userId);
				const newRange = await dbFacade.get("select * from ranges", []);
				dist_default(mapNullable(newRange, untagSqlObject)).deepEquals({
					type: mailType,
					listId,
					lower: cutoffId,
					upper
				});
			});
			dist_default("unmodified ranges will not be deleted or shrunk", async function() {
				const upper = offsetId(2);
				const lower = offsetId(1);
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "mailFolderId"],
					mails: listId
				}));
				await insertRange(MailTypeRef, listId, lower, upper);
				await storage.clearExcludedData(timeRangeDays, userId);
				const newRange = await dbFacade.get("select * from ranges", []);
				dist_default(mapNullable(newRange, untagSqlObject)).deepEquals({
					type: mailType,
					listId,
					lower,
					upper
				});
			});
			dist_default("complete ranges won't be lost if entities are all newer than cutoff", async function() {
				const upper = offsetId(2);
				const lower = GENERATED_MIN_ID;
				const mail = createTestEntity(MailTypeRef, { _id: [listId, offsetId(1)] });
				const mailFolder = createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "folderId"],
					mails: listId
				});
				await insertEntity(mailFolder);
				await insertEntity(mail);
				await insertRange(MailTypeRef, listId, lower, upper);
				await storage.clearExcludedData(timeRangeDays, userId);
				const newRange = await dbFacade.get("select * from ranges", []);
				dist_default(mapNullable(newRange, untagSqlObject)).deepEquals({
					type: mailType,
					listId,
					lower,
					upper
				});
				const allFolderIds = await getAllIdsForType(MailFolderTypeRef);
				dist_default(allFolderIds).deepEquals([
					"folderId",
					spamFolderId,
					trashFolderId
				]);
				const allMailIds = await getAllIdsForType(MailTypeRef);
				dist_default(allMailIds).deepEquals([getElementId(mail)]);
			});
			dist_default("trash and spam descendants are cleared", async function() {
				const spamDetailsId = ["detailsListId", "spamDetailsId"];
				const trashDetailsId = ["detailsListId", "trashDetailsId"];
				const trashSubfolderDetailsId = ["detailsListId", "trashSubFolderDetailsId"];
				const trashSubfolderId = "trashSubfolderId";
				const trashSubfolderListId = "trashSubfolderListId";
				const spamMailId = offsetId(2);
				const spamMail = createTestEntity(MailTypeRef, {
					_id: [spamListId, spamMailId],
					mailDetails: spamDetailsId
				});
				const trashMailId = offsetId(2);
				const trashMail = createTestEntity(MailTypeRef, {
					_id: [trashListId, trashMailId],
					mailDetails: trashDetailsId
				});
				const trashSubfolderMailId = offsetId(2);
				const trashSubfolderMail = createTestEntity(MailTypeRef, {
					_id: [trashSubfolderListId, trashSubfolderMailId],
					mailDetails: trashSubfolderDetailsId
				});
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", trashSubfolderId],
					parentFolder: ["mailFolderList", trashFolderId],
					mails: trashSubfolderListId,
					folderType: MailSetKind.CUSTOM
				}));
				await insertEntity(spamMail);
				await insertEntity(trashMail);
				await insertEntity(trashSubfolderMail);
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: spamDetailsId,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: trashDetailsId,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: trashSubfolderDetailsId,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await storage.clearExcludedData(timeRangeDays, userId);
				const allEntities = await dbFacade.all("select * from list_entities", []);
				dist_default(allEntities.map((r) => r.elementId.value)).deepEquals([
					spamFolderId,
					trashFolderId,
					trashSubfolderId
				]);
				dist_default(await getAllIdsForType(MailFolderTypeRef)).deepEquals([
					spamFolderId,
					trashFolderId,
					trashSubfolderId
				]);
				dist_default(await getAllIdsForType(MailTypeRef)).deepEquals([]);
				dist_default(await getAllIdsForType(MailDetailsBlobTypeRef)).deepEquals([]);
			});
			dist_default("trash and spam are cleared", async function() {
				const spamDetailsId = ["detailsListId", "spamDetailsId"];
				const trashDetailsId = ["detailsListId", "trashDetailsId"];
				const spamMailId = offsetId(2);
				const trashMailId = offsetId(2);
				const spamMail = createTestEntity(MailTypeRef, {
					_id: [spamListId, spamMailId],
					mailDetails: spamDetailsId
				});
				const trashMail = createTestEntity(MailTypeRef, {
					_id: [trashListId, trashMailId],
					mailDetails: trashDetailsId
				});
				await storage.init({
					userId,
					databaseKey,
					timeRangeDays,
					forceNewDatabase: false
				});
				await insertEntity(spamMail);
				await insertEntity(trashMail);
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: spamDetailsId,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: trashDetailsId,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await storage.clearExcludedData(timeRangeDays, userId);
				const allEntities = await dbFacade.all("select * from list_entities", []);
				dist_default(allEntities.map((r) => r.elementId.value)).deepEquals([spamFolderId, trashFolderId]);
				dist_default(await getAllIdsForType(MailFolderTypeRef)).deepEquals([spamFolderId, trashFolderId]);
				dist_default(await getAllIdsForType(MailTypeRef)).deepEquals([]);
				dist_default(await getAllIdsForType(MailDetailsBlobTypeRef)).deepEquals([]);
			});
			dist_default("normal folder is partially cleared", async function() {
				const beforeMailDetailsId = ["detailsListId", "beforeDetailsId"];
				const afterMailDetailsId = ["detailsListId", "afterDetailsId"];
				const inboxMailList = "inboxMailList";
				const mailBefore = createTestEntity(MailTypeRef, {
					_id: [inboxMailList, offsetId(-2)],
					mailDetails: beforeMailDetailsId
				});
				const mailAfter = createTestEntity(MailTypeRef, {
					_id: [inboxMailList, offsetId(2)],
					mailDetails: afterMailDetailsId
				});
				const beforeMailDetails = createTestEntity(MailDetailsBlobTypeRef, {
					_id: beforeMailDetailsId,
					details: createTestEntity(MailDetailsTypeRef)
				});
				const afterMailDetails = createTestEntity(MailDetailsBlobTypeRef, {
					_id: afterMailDetailsId,
					details: createTestEntity(MailDetailsTypeRef)
				});
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "folderId"],
					mails: inboxMailList,
					folderType: MailSetKind.INBOX
				}));
				await insertEntity(mailBefore);
				await insertEntity(mailAfter);
				await insertEntity(beforeMailDetails);
				await insertEntity(afterMailDetails);
				await storage.clearExcludedData(timeRangeDays, userId);
				const allMailIds = await getAllIdsForType(MailTypeRef);
				dist_default(allMailIds).deepEquals([getElementId(mailAfter)]);
				const allMailDetailsIds = await getAllIdsForType(MailDetailsBlobTypeRef);
				dist_default(allMailDetailsIds).deepEquals([getElementId(afterMailDetails)]);
			});
			dist_default("normal folder is completely cleared", async function() {
				const mailDetailsId1 = ["detailsListId", "mailDetailsId1"];
				const mailDetailsId2 = ["detailsListId", "mailDetailsId2"];
				const inboxMailList = "inboxMailList";
				const mail1 = createTestEntity(MailTypeRef, {
					_id: [inboxMailList, offsetId(-2)],
					mailDetails: mailDetailsId1
				});
				const mail2 = createTestEntity(MailTypeRef, {
					_id: [inboxMailList, offsetId(-3)],
					mailDetails: mailDetailsId2
				});
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "folderId"],
					mails: inboxMailList,
					folderType: MailSetKind.INBOX
				}));
				await insertEntity(mail1);
				await insertEntity(mail2);
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: mailDetailsId1,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, {
					_id: mailDetailsId2,
					details: createTestEntity(MailDetailsTypeRef)
				}));
				await storage.clearExcludedData(timeRangeDays, userId);
				dist_default(await getAllIdsForType(MailTypeRef)).deepEquals([]);
				dist_default(await getAllIdsForType(MailDetailsBlobTypeRef)).deepEquals([]);
			});
			dist_default("when mail is deleted, attachment is also deleted", async function() {
				const inboxMailList = "inboxMailList";
				const beforeMailDetailsId = ["detailsListId", "beforeDetailsId"];
				const afterMailDetailsId = ["detailsListId", "afterDetailsId"];
				const fileListId = "fileListId";
				const fileBefore = createTestEntity(FileTypeRef, { _id: [fileListId, "fileBefore"] });
				const fileAfter = createTestEntity(FileTypeRef, { _id: [fileListId, "fileAfter"] });
				const mailBefore = createTestEntity(MailTypeRef, {
					_id: [inboxMailList, offsetId(-2)],
					mailDetails: beforeMailDetailsId,
					attachments: [fileBefore._id]
				});
				const mailAfter = createTestEntity(MailTypeRef, {
					_id: [inboxMailList, offsetId(2)],
					mailDetails: afterMailDetailsId,
					attachments: [fileAfter._id]
				});
				await insertEntity(createTestEntity(MailFolderTypeRef, {
					_id: ["mailFolderList", "folderId"],
					mails: inboxMailList,
					folderType: MailSetKind.INBOX
				}));
				await insertEntity(mailBefore);
				await insertEntity(mailAfter);
				await insertEntity(fileBefore);
				await insertEntity(fileAfter);
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, { _id: beforeMailDetailsId }));
				await insertEntity(createTestEntity(MailDetailsBlobTypeRef, { _id: afterMailDetailsId }));
				await storage.clearExcludedData(timeRangeDays, userId);
				dist_default(await getAllIdsForType(MailTypeRef)).deepEquals([getElementId(mailAfter)]);
				dist_default(await getAllIdsForType(FileTypeRef)).deepEquals([getElementId(fileAfter)]);
			});
		});
	});
	dist_default.spec("Integration test", function() {
		function createMailList(numMails, listId, idGenerator, getSubject, getBody) {
			const mails = [];
			const mailDetailsBlobs = [];
			for (let i = 0; i < numMails; ++i) {
				const mailId = idGenerator.getNext();
				const mailDetailsId = idGenerator.getNext();
				mails.push(createTestEntity(MailTypeRef, {
					_id: [listId, mailId],
					subject: getSubject(i),
					mailDetails: ["detailsListId", mailDetailsId]
				}));
				mailDetailsBlobs.push(createTestEntity(MailDetailsBlobTypeRef, {
					_id: ["detailsListId", mailDetailsId],
					details: createTestEntity(MailDetailsTypeRef, {
						_id: mailDetailsId,
						body: createTestEntity(BodyTypeRef, { text: getBody(i) })
					})
				}));
			}
			return {
				mails,
				mailDetailsBlobs
			};
		}
		dist_default("cleanup works as expected", async function() {
			const oldIds = new IdGenerator(offsetId(-5));
			const newIds = new IdGenerator(offsetId(5));
			const userMailbox = createTestEntity(MailBoxTypeRef, {
				_id: "mailboxId",
				currentMailBag: null,
				folders: createMailFolderRef({ folders: "mailFolderList" })
			});
			const inboxListId = oldIds.getNext();
			const inboxFolder = createTestEntity(MailFolderTypeRef, {
				_id: ["mailFolderList", oldIds.getNext()],
				mails: inboxListId,
				folderType: MailSetKind.INBOX
			});
			const { mails: oldInboxMails, mailDetailsBlobs: oldInboxMailDetailsBlobs } = createMailList(3, inboxListId, oldIds, (i) => `old subject ${i}`, (i) => `old body ${i}`);
			const { mails: newInboxMails, mailDetailsBlobs: newInboxMailDetailsBlobs } = createMailList(3, inboxListId, newIds, (i) => `new subject ${i}`, (i) => `new body ${i}`);
			const trashListId = oldIds.getNext();
			const trashFolder = createTestEntity(MailFolderTypeRef, {
				_id: ["mailFolderList", oldIds.getNext()],
				mails: trashListId,
				folderType: MailSetKind.TRASH
			});
			const { mails: trashMails, mailDetailsBlobs: trashMailDetailsBlobs } = createMailList(3, trashListId, newIds, (i) => `trash subject ${i}`, (i) => `trash body ${i}`);
			const spamListId = oldIds.getNext();
			const spamFolder = createTestEntity(MailFolderTypeRef, {
				_id: ["mailFolderList", oldIds.getNext()],
				mails: spamListId,
				folderType: MailSetKind.SPAM
			});
			const everyEntity = [
				userMailbox,
				inboxFolder,
				trashFolder,
				spamFolder,
				...oldInboxMails,
				...oldInboxMailDetailsBlobs,
				...newInboxMails,
				...newInboxMailDetailsBlobs,
				...trashMails,
				...trashMailDetailsBlobs
			];
			await storage.init({
				userId,
				databaseKey: offlineDatabaseTestKey,
				timeRangeDays,
				forceNewDatabase: false
			});
			for (let entity of everyEntity) await storage.put(entity);
			await storage.setNewRangeForList(MailTypeRef, inboxListId, getFirstOrThrow(oldInboxMails)._id[1], lastThrow(newInboxMails)._id[1]);
			await storage.setNewRangeForList(MailTypeRef, trashListId, getFirstOrThrow(trashMails)._id[1], lastThrow(trashMails)._id[1]);
			await storage.clearExcludedData(timeRangeDays, userId);
			const assertContents = async ({ _id, _type }, expected, msg) => {
				const { listId, elementId } = expandId(_id);
				return dist_default(await storage.get(_type, listId, elementId)).deepEquals(expected)(msg);
			};
			await pMap(oldInboxMails, (mail) => assertContents(mail, null, `old mail ${mail._id} was deleted`));
			await pMap(oldInboxMailDetailsBlobs, (body) => assertContents(body, null, `old mailBody ${body._id} was deleted`));
			await pMap(newInboxMails, (mail) => assertContents(mail, mail, `new mail ${mail._id} was not deleted`));
			await pMap(newInboxMailDetailsBlobs, (body) => assertContents(body, body, `new mailBody ${body._id} was not deleted`));
			await pMap(trashMails, (mail) => assertContents(mail, null, `trash mail ${mail._id} was deleted`));
			await pMap(trashMailDetailsBlobs, (body) => assertContents(body, null, `trash mailBody ${body._id} was deleted`));
			await assertContents(inboxFolder, inboxFolder, `inbox folder was not deleted`);
			await assertContents(trashFolder, trashFolder, `trash folder was not deleted`);
			dist_default(await storage.getRangeForList(MailTypeRef, inboxListId)).deepEquals({
				lower: cutoffId,
				upper: lastThrow(newInboxMails)._id[1]
			})("lower range for inbox was set to cutoff");
			dist_default(await storage.getRangeForList(MailTypeRef, trashListId)).equals(null)("range for trash was deleted");
		});
	});
});

//#endregion
export { offlineDatabaseTestKey };
//# sourceMappingURL=OfflineStorageTest-BgaCSfok.js.map