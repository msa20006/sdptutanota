
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { DAY_IN_MILLIS, assertNotNull, downcast, flatMap, getFromMap, groupBy, groupByAndMap, groupByAndMapUniquely, isNotNull, neverNull, ofClass, pMap, stringToUtf8Uint8Array } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertWorkerOrNode } from "./Env-D5xGlXfw.js";
import { GroupType, OperationType } from "./TutanotaConstants-3bwAESYA.js";
import { ConnectionError, NotAuthorizedError, NotFoundError, PayloadTooLargeError } from "./RestError-D17JEBMr.js";
import { isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { ImportError } from "./ImportError-CIXw37Kv.js";
import { elementIdPart, getLetId, getListId, isSameId, listIdPart, uint8arrayToCustomId } from "./EntityUtils-RQxXZlcV.js";
import { geEventElementMaxId, getEventElementMinId } from "./CommonCalendarUtils-DKaO7v1K.js";
import { CalendarEventTypeRef, CalendarEventUidIndexTypeRef, CalendarGroupRootTypeRef, createCalendarDeleteData } from "./TypeRefs-CR3TLWn0.js";
import { AlarmServicePostTypeRef, PushIdentifierTypeRef, UserAlarmInfoTypeRef, createAlarmInfo, createAlarmNotification, createAlarmServicePost, createCalendarEventRef, createDateWrapper, createNotificationSessionKey, createRepeatRule, createUserAlarmInfo } from "./TypeRefs-BP1jvX9p.js";
import { addDaysForEventInstance, addDaysForRecurringEvent, generateCalendarInstancesInRange, isClientOnlyCalendar } from "./CalendarUtils-C6jeYrj9.js";
import { resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import { EntityClient, loadMultipleFromLists } from "./EntityClient-B0RSdk2i.js";
import { SetupMultipleError } from "./SetupMultipleError-B6uY8P-x.js";
import { aes256RandomKey, encryptKey, sha256Hash } from "./dist-DcZ1Y4qd.js";
import { AlarmService } from "./Services-CZFE0084.js";
import { CalendarService } from "./Services-DCx-CeM7.js";

//#region ../src/common/api/worker/facades/lazy/CalendarFacade.ts
assertWorkerOrNode();
var CalendarFacade = class {
	cachingEntityClient;
	constructor(userFacade, groupManagementFacade, entityRestCache, noncachingEntityClient, nativePushFacade, operationProgressTracker, instanceMapper, serviceExecutor, cryptoFacade, infoMessageHandler) {
		this.userFacade = userFacade;
		this.groupManagementFacade = groupManagementFacade;
		this.entityRestCache = entityRestCache;
		this.noncachingEntityClient = noncachingEntityClient;
		this.nativePushFacade = nativePushFacade;
		this.operationProgressTracker = operationProgressTracker;
		this.instanceMapper = instanceMapper;
		this.serviceExecutor = serviceExecutor;
		this.cryptoFacade = cryptoFacade;
		this.infoMessageHandler = infoMessageHandler;
		this.cachingEntityClient = new EntityClient(this.entityRestCache);
	}
	async saveImportedCalendarEvents(eventWrappers, operationId) {
		return this.saveCalendarEvents(eventWrappers, (percent) => this.operationProgressTracker.onProgress(operationId, percent));
	}
	/**
	* extend or one month of the given daysToEvents map
	*
	* @param month only update events that intersect days in this month
	* @param calendarInfos update events contained in these calendars
	* @param daysToEvents the old version of the map
	* @param zone the time zone to consider the event times under
	* @returns a new daysToEventsMap where the given month is updated.
	*/
	async updateEventMap(month, calendarInfos, daysToEvents, zone) {
		const startId = getEventElementMinId(month.start - DAY_IN_MILLIS);
		const endId = geEventElementMaxId(month.end + DAY_IN_MILLIS);
		const calendars = [];
		for (const { groupRoot } of calendarInfos.values()) {
			const [shortEventsResult, longEventsResult] = await Promise.all([this.cachingEntityClient.loadReverseRangeBetween(CalendarEventTypeRef, groupRoot.shortEvents, endId, startId, 200), this.cachingEntityClient.loadAll(CalendarEventTypeRef, groupRoot.longEvents)]);
			calendars.push({
				short: shortEventsResult.elements,
				long: longEventsResult
			});
		}
		const newEvents = new Map(Array.from(daysToEvents.entries()).map(([day, events]) => [day, events.slice()]));
		for (const calendar of calendars) {
			this.generateEventOccurences(newEvents, calendar.short, month, zone, true);
			this.generateEventOccurences(newEvents, calendar.long, month, zone, false);
		}
		return newEvents;
	}
	generateEventOccurences(eventMap, events, range, zone, overwriteRange) {
		for (const e of events) {
			const generationRange = overwriteRange ? {
				...range,
				end: e.endTime.getTime()
			} : range;
			if (e.repeatRule) addDaysForRecurringEvent(eventMap, e, generationRange, zone);
else addDaysForEventInstance(eventMap, e, generationRange, zone);
		}
	}
	/**
	* We try to create as many events as possible and only throw the error at the end.
	* If alarmNotifications are created for an event that will later fail to be created we ignore them.
	* This function does not perform any checks on the event so it should only be called internally when
	* we can be sure that those checks have already been performed.
	* @param eventsWrapper the events and alarmNotifications to be created.
	* @param onProgress
	*/
	async saveCalendarEvents(eventsWrapper, onProgress) {
		let currentProgress = 10;
		await onProgress(currentProgress);
		for (const { event } of eventsWrapper) event.hashedUid = hashUid(assertNotNull(event.uid, "tried to save calendar event without uid."));
		const user = this.userFacade.getLoggedInUser();
		const numEvents = eventsWrapper.length;
		let eventsWithAlarms;
		try {
			eventsWithAlarms = await this.saveMultipleAlarms(user, eventsWrapper);
		} catch (e) {
			if (e instanceof SetupMultipleError) {
				console.log("Saving alarms failed.", e);
				throw new ImportError(e.errors[0], "Could not save alarms.", numEvents);
			}
			throw e;
		}
		for (const { event, alarmInfoIds } of eventsWithAlarms) event.alarmInfos = alarmInfoIds;
		currentProgress = 33;
		await onProgress(currentProgress);
		const eventsWithAlarmsByEventListId = groupBy(eventsWithAlarms, (eventWrapper) => getListId(eventWrapper.event));
		let collectedAlarmNotifications = [];
		const size = eventsWithAlarmsByEventListId.size;
		let failed = 0;
		let errors = [];
		for (const [listId, eventsWithAlarmsOfOneList] of eventsWithAlarmsByEventListId) {
			let successfulEvents = eventsWithAlarmsOfOneList;
			await this.cachingEntityClient.setupMultipleEntities(listId, eventsWithAlarmsOfOneList.map((e) => e.event)).catch(ofClass(SetupMultipleError, (e) => {
				failed += e.failedInstances.length;
				errors = errors.concat(e.errors);
				console.log(e.errors);
				successfulEvents = eventsWithAlarmsOfOneList.filter(({ event }) => !e.failedInstances.includes(event));
			}));
			const allAlarmNotificationsOfListId = successfulEvents.map((event) => event.alarmNotifications).flat();
			collectedAlarmNotifications = collectedAlarmNotifications.concat(allAlarmNotificationsOfListId);
			currentProgress += Math.floor(56 / size);
			await onProgress(currentProgress);
		}
		const pushIdentifierList = await this.cachingEntityClient.loadAll(PushIdentifierTypeRef, neverNull(this.userFacade.getLoggedInUser().pushIdentifierList).list);
		if (collectedAlarmNotifications.length > 0 && pushIdentifierList.length > 0) await this.sendAlarmNotifications(collectedAlarmNotifications, pushIdentifierList);
		await onProgress(100);
		if (failed !== 0) if (errors.some(isOfflineError)) throw new ConnectionError("Connection lost while saving events");
else {
			console.log("Could not save events. Number of failed imports: ", failed);
			throw new ImportError(errors[0], "Could not save events.", failed);
		}
	}
	async saveCalendarEvent(event, alarmInfos, oldEvent) {
		if (event._id == null) throw new Error("No id set on the event");
		if (event._ownerGroup == null) throw new Error("No _ownerGroup is set on the event");
		if (event.uid == null) throw new Error("no uid set on the event");
		event.hashedUid = hashUid(event.uid);
		if (oldEvent) await this.cachingEntityClient.erase(oldEvent).catch(ofClass(NotFoundError, () => console.log("could not delete old event when saving new one")));
		return await this.saveCalendarEvents([{
			event,
			alarms: alarmInfos
		}], () => Promise.resolve());
	}
	async updateCalendarEvent(event, newAlarms, existingEvent) {
		event._id = existingEvent._id;
		event._ownerEncSessionKey = existingEvent._ownerEncSessionKey;
		event._ownerKeyVersion = existingEvent._ownerKeyVersion;
		event._permissions = existingEvent._permissions;
		if (existingEvent.uid == null) throw new Error("no uid set on the existing event");
		event.uid = existingEvent.uid;
		event.hashedUid = hashUid(existingEvent.uid);
		const user = this.userFacade.getLoggedInUser();
		const userAlarmIdsWithAlarmNotificationsPerEvent = await this.saveMultipleAlarms(user, [{
			event,
			alarms: newAlarms
		}]);
		const { alarmInfoIds, alarmNotifications } = userAlarmIdsWithAlarmNotificationsPerEvent[0];
		const userAlarmInfoListId = neverNull(user.alarmInfoList).alarms;
		event.alarmInfos = existingEvent.alarmInfos.filter((a) => !isSameId(listIdPart(a), userAlarmInfoListId)).concat(alarmInfoIds);
		await this.cachingEntityClient.update(event);
		if (alarmNotifications.length > 0) {
			const pushIdentifierList = await this.cachingEntityClient.loadAll(PushIdentifierTypeRef, neverNull(this.userFacade.getLoggedInUser().pushIdentifierList).list);
			await this.sendAlarmNotifications(alarmNotifications, pushIdentifierList);
		}
	}
	/**
	* get all the calendar event instances in the given time range that are generated by the given progenitor Ids
	*/
	async reifyCalendarSearchResult(start, end, results) {
		const filteredEvents = results.filter(([calendarId, eventId]) => !isClientOnlyCalendar(calendarId));
		const progenitors = await loadMultipleFromLists(CalendarEventTypeRef, this.cachingEntityClient, filteredEvents);
		const range = {
			start,
			end
		};
		return generateCalendarInstancesInRange(progenitors, range);
	}
	async addCalendar(name) {
		return await this.groupManagementFacade.createCalendar(name);
	}
	async deleteCalendar(groupRootId) {
		await this.serviceExecutor.delete(CalendarService, createCalendarDeleteData({ groupRootId }));
	}
	async scheduleAlarmsForNewDevice(pushIdentifier) {
		const user = this.userFacade.getLoggedInUser();
		const eventsWithAlarmInfos = await this.loadAlarmEvents();
		const alarmNotifications = flatMap(eventsWithAlarmInfos, ({ event, userAlarmInfos }) => userAlarmInfos.map((userAlarmInfo) => createAlarmNotificationForEvent(event, userAlarmInfo.alarmInfo, user._id)));
		const notificationKey = aes256RandomKey();
		await this.encryptNotificationKeyForDevices(notificationKey, alarmNotifications, [pushIdentifier]);
		const requestEntity = createAlarmServicePost({ alarmNotifications });
		const AlarmServicePostTypeModel = await resolveTypeReference(AlarmServicePostTypeRef);
		const encEntity = await this.instanceMapper.encryptAndMapToLiteral(AlarmServicePostTypeModel, requestEntity, notificationKey);
		const encryptedAlarms = downcast(encEntity).alarmNotifications;
		await this.nativePushFacade.scheduleAlarms(encryptedAlarms);
	}
	/**
	* Load all events that have an alarm assigned.
	* @return: Map from concatenated ListId of an event to list of UserAlarmInfos for that event
	*/
	async loadAlarmEvents() {
		const alarmInfoList = this.userFacade.getLoggedInUser().alarmInfoList;
		if (!alarmInfoList) {
			console.warn("No alarmInfo list on user");
			return [];
		}
		const userAlarmInfos = await this.cachingEntityClient.loadAll(UserAlarmInfoTypeRef, alarmInfoList.alarms);
		const listIdToElementIds = groupByAndMapUniquely(userAlarmInfos, (userAlarmInfo) => userAlarmInfo.alarmInfo.calendarRef.listId, (userAlarmInfo) => userAlarmInfo.alarmInfo.calendarRef.elementId);
		const eventIdToAlarmInfos = groupBy(userAlarmInfos, (userAlarmInfo) => getEventIdFromUserAlarmInfo(userAlarmInfo).join(""));
		const calendarEvents = await pMap(listIdToElementIds.entries(), ([listId, elementIds]) => {
			return this.cachingEntityClient.loadMultiple(CalendarEventTypeRef, listId, Array.from(elementIds)).catch((error) => {
				if (error instanceof NotAuthorizedError) {
					console.warn("NotAuthorized when downloading alarm events", error);
					return [];
				}
				throw error;
			});
		});
		return calendarEvents.flat().map((event) => {
			return {
				event,
				userAlarmInfos: getFromMap(eventIdToAlarmInfos, getLetId(event).join(""), () => [])
			};
		});
	}
	/**
	* Queries the events using the uid index. The index is stored per calendar, so we have to go through all calendars
	* to find the matching events. We currently only need this for calendar event updates and for that we don't want to
	* look into shared calendars.
	*
	* @returns {CalendarEventUidIndexEntry}
	*/
	async getEventsByUid(uid, cacheMode = CachingMode.Cached) {
		const { memberships } = this.userFacade.getLoggedInUser();
		const entityClient = this.getEntityClient(cacheMode);
		for (const membership of memberships) {
			if (membership.groupType !== GroupType.Calendar) continue;
			try {
				const groupRoot = await this.cachingEntityClient.load(CalendarGroupRootTypeRef, membership.group);
				if (groupRoot.index == null) continue;
				const indexEntry = await entityClient.load(CalendarEventUidIndexTypeRef, [groupRoot.index.list, uint8arrayToCustomId(hashUid(uid))]);
				const progenitor = await loadProgenitorFromIndexEntry(entityClient, indexEntry);
				const alteredInstances = await loadAlteredInstancesFromIndexEntry(entityClient, indexEntry);
				return {
					progenitor,
					alteredInstances,
					ownerGroup: assertNotNull(indexEntry._ownerGroup, "ownergroup on index entry was null!")
				};
			} catch (e) {
				if (e instanceof NotFoundError || e instanceof NotAuthorizedError) continue;
				throw e;
			}
		}
		return null;
	}
	async sendAlarmNotifications(alarmNotifications, pushIdentifierList) {
		const notificationSessionKey = aes256RandomKey();
		return this.encryptNotificationKeyForDevices(notificationSessionKey, alarmNotifications, pushIdentifierList).then(async () => {
			const requestEntity = createAlarmServicePost({ alarmNotifications });
			try {
				await this.serviceExecutor.post(AlarmService, requestEntity, { sessionKey: notificationSessionKey });
			} catch (e) {
				if (e instanceof PayloadTooLargeError) return this.infoMessageHandler.onInfoMessage({
					translationKey: "calendarAlarmsTooBigError_msg",
					args: {}
				});
else throw e;
			}
		});
	}
	async encryptNotificationKeyForDevices(notificationSessionKey, alarmNotifications, pushIdentifierList) {
		const maybeEncSessionKeys = await pMap(pushIdentifierList, async (identifier) => {
			const pushIdentifierSk = await this.cryptoFacade.resolveSessionKeyForInstance(identifier);
			if (pushIdentifierSk) {
				const pushIdentifierSessionEncSessionKey = encryptKey(pushIdentifierSk, notificationSessionKey);
				return {
					identifierId: identifier._id,
					pushIdentifierSessionEncSessionKey
				};
			} else return null;
		});
		const encSessionKeys = maybeEncSessionKeys.filter(isNotNull);
		for (let notification of alarmNotifications) notification.notificationSessionKeys = encSessionKeys.map((esk) => {
			return createNotificationSessionKey({
				pushIdentifier: esk.identifierId,
				pushIdentifierSessionEncSessionKey: esk.pushIdentifierSessionEncSessionKey
			});
		});
	}
	async saveMultipleAlarms(user, eventsWrapper) {
		const userAlarmInfosAndNotificationsPerEvent = [];
		const userAlarmInfoListId = neverNull(user.alarmInfoList).alarms;
		const ownerGroup = user.userGroup.group;
		for (const { event, alarms } of eventsWrapper) {
			const userAlarmInfoAndNotification = [];
			const calendarRef = createCalendarEventRef({
				listId: listIdPart(event._id),
				elementId: elementIdPart(event._id)
			});
			for (const alarmInfo of alarms) {
				const userAlarmInfo = createUserAlarmInfo({
					_ownerGroup: ownerGroup,
					alarmInfo: createAlarmInfo({
						alarmIdentifier: alarmInfo.alarmIdentifier,
						trigger: alarmInfo.trigger,
						calendarRef
					})
				});
				const alarmNotification = createAlarmNotificationForEvent(event, userAlarmInfo.alarmInfo, user._id);
				userAlarmInfoAndNotification.push({
					alarm: userAlarmInfo,
					alarmNotification
				});
			}
			userAlarmInfosAndNotificationsPerEvent.push({
				event,
				userAlarmInfoAndNotification
			});
		}
		const allAlarms = userAlarmInfosAndNotificationsPerEvent.flatMap(({ userAlarmInfoAndNotification }) => userAlarmInfoAndNotification.map(({ alarm }) => alarm));
		const alarmIds = await this.cachingEntityClient.setupMultipleEntities(userAlarmInfoListId, allAlarms);
		let currentIndex = 0;
		return userAlarmInfosAndNotificationsPerEvent.map(({ event, userAlarmInfoAndNotification }) => {
			return {
				event,
				alarmInfoIds: userAlarmInfoAndNotification.map(() => [userAlarmInfoListId, alarmIds[currentIndex++]]),
				alarmNotifications: userAlarmInfoAndNotification.map(({ alarmNotification }) => alarmNotification)
			};
		});
	}
	getEntityClient(cacheMode) {
		if (cacheMode === CachingMode.Cached) return this.cachingEntityClient;
else return this.noncachingEntityClient;
	}
};
function createAlarmNotificationForEvent(event, alarmInfo, userId) {
	return createAlarmNotification({
		alarmInfo: createAlarmInfoForAlarmInfo(alarmInfo),
		repeatRule: event.repeatRule && createRepeatRuleForCalendarRepeatRule(event.repeatRule),
		notificationSessionKeys: [],
		operation: OperationType.CREATE,
		summary: event.summary,
		eventStart: event.startTime,
		eventEnd: event.endTime,
		user: userId
	});
}
function createAlarmInfoForAlarmInfo(alarmInfo) {
	const calendarRef = createCalendarEventRef({
		elementId: alarmInfo.calendarRef.elementId,
		listId: alarmInfo.calendarRef.listId
	});
	return createAlarmInfo({
		alarmIdentifier: alarmInfo.alarmIdentifier,
		trigger: alarmInfo.trigger,
		calendarRef
	});
}
function createRepeatRuleForCalendarRepeatRule(calendarRepeatRule) {
	return createRepeatRule({
		endType: calendarRepeatRule.endType,
		endValue: calendarRepeatRule.endValue,
		frequency: calendarRepeatRule.frequency,
		interval: calendarRepeatRule.interval,
		timeZone: calendarRepeatRule.timeZone,
		excludedDates: calendarRepeatRule.excludedDates.map(({ date }) => createDateWrapper({ date })),
		advancedRules: calendarRepeatRule.advancedRules
	});
}
function getEventIdFromUserAlarmInfo(userAlarmInfo) {
	return [userAlarmInfo.alarmInfo.calendarRef.listId, userAlarmInfo.alarmInfo.calendarRef.elementId];
}
/** to make lookup on the encrypted event uid possible, we hash it and use that value as a key. */
function hashUid(uid) {
	return sha256Hash(stringToUtf8Uint8Array(uid));
}
function sortByRecurrenceId(arr) {
	arr.sort((a, b) => a.recurrenceId.getTime() < b.recurrenceId.getTime() ? -1 : 1);
}
async function loadAlteredInstancesFromIndexEntry(entityClient, indexEntry) {
	if (indexEntry.alteredInstances.length === 0) return [];
	const indexedEventIds = groupByAndMap(indexEntry.alteredInstances, (e) => listIdPart(e), (e) => elementIdPart(e));
	const isAlteredInstance = (e) => e.recurrenceId != null && e.uid != null;
	const indexedEvents = await loadMultipleFromLists(CalendarEventTypeRef, entityClient, indexEntry.alteredInstances);
	const alteredInstances = indexedEvents.filter(isAlteredInstance);
	if (indexedEvents.length > alteredInstances.length) console.warn("there were altered instances indexed that do not have a recurrence Id or uid!");
	sortByRecurrenceId(alteredInstances);
	return alteredInstances;
}
async function loadProgenitorFromIndexEntry(entityClient, indexEntry) {
	if (indexEntry.progenitor == null) return null;
	const loadedProgenitor = await entityClient.load(CalendarEventTypeRef, indexEntry.progenitor);
	if (loadedProgenitor.recurrenceId != null) throw new ProgrammingError(`loaded progenitor has a recurrence Id! ${loadedProgenitor.recurrenceId.toISOString()}`);
	assertNotNull(loadedProgenitor.uid, "loaded progenitor has no UID");
	return loadedProgenitor;
}
let CachingMode = function(CachingMode$1) {
	CachingMode$1[CachingMode$1["Cached"] = 0] = "Cached";
	CachingMode$1[CachingMode$1["Bypass"] = 1] = "Bypass";
	return CachingMode$1;
}({});

//#endregion
export { CachingMode, CalendarFacade, sortByRecurrenceId };
//# sourceMappingURL=CalendarFacade-CaovxyFN.js.map