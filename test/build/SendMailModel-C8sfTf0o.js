
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { LazyLoaded, assertNotNull, cleanMatch, deduplicate, defer, downcast, findAndRemove, getFromMap, neverNull, noOp, ofClass, pMap, remove, typedValues } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertMainOrNode } from "./Env-D5xGlXfw.js";
import { getAvailableLanguageCode, getSubstitutedLanguageCode, lang, languages } from "./LanguageViewModel-BNC5ekpO.js";
import { ApprovalStatus, ConversationType, MAX_ATTACHMENT_SIZE, MailMethod, OperationType, ReplyType } from "./TutanotaConstants-3bwAESYA.js";
import { AccessBlockedError, LockedError, NotAuthorizedError, NotFoundError, PayloadTooLargeError, PreconditionFailedError, TooManyRequestsError } from "./RestError-D17JEBMr.js";
import { FileNotFoundError, RecipientNotResolvedError } from "./ErrorUtils-o1-v67Dd.js";
import { RecipientsNotFoundError } from "./RecipientsNotFoundError-D8oGE7A_.js";
import { MailBodyTooLargeError } from "./MailBodyTooLargeError-C2i0rX_0.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { isSameId, stringToCustomId } from "./EntityUtils-RQxXZlcV.js";
import { cleanMailAddress, findRecipientWithAddress } from "./CommonCalendarUtils-DKaO7v1K.js";
import { ContactTypeRef, ConversationEntryTypeRef, FileTypeRef, MailTypeRef, MailboxPropertiesTypeRef } from "./TypeRefs-CR3TLWn0.js";
import { CustomerPropertiesTypeRef } from "./TypeRefs-BP1jvX9p.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { isMailAddress } from "./FormatValidator-2BBermUe.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import { RecipientField, checkAttachmentSize, getDefaultSender, getTemplateLanguages, isUserEmail } from "./SharedMailUtils-AmFaSJP6.js";
import { PASSWORD_MIN_SECURE_VALUE, getPasswordStrengthForUser, isSecurePassword } from "./PasswordUtils-C4jlV9GF.js";
import { RecipientType } from "./Recipient-BFxhfecW.js";
import { getContactDisplayName } from "./ContactUtils-Bbon2oOk.js";
import { ResolveMode } from "./RecipientsModel-DxwXuUvL.js";
import { createApprovalMail } from "./Services-CupYet_j.js";
import { checkApprovalStatus } from "./LoginViewModel-BX-8ry63.js";
import { cloneInlineImages, revokeInlineImages } from "./inlineImagesUtils-BekMwI7k.js";
import { getMailBodyText } from "./CommonMailUtils-DNufl6ib.js";

//#region ../src/common/misc/MailboxPropertiesUtils.ts
function getSenderName(mailboxProperties, senderAddress) {
	return mailboxProperties.mailAddressProperties.find((a) => a.mailAddress === senderAddress)?.senderName ?? null;
}

//#endregion
//#region ../src/common/mailFunctionality/SendMailModel.ts
var import_stream = __toESM(require_stream(), 1);
assertMainOrNode();
const TOO_MANY_VISIBLE_RECIPIENTS = 10;
var SendMailModel = class {
	initialized = null;
	onMailChanged = (0, import_stream.default)(null);
	onRecipientDeleted = (0, import_stream.default)(null);
	onBeforeSend = noOp;
	loadedInlineImages = new Map();
	draft = null;
	conversationType = ConversationType.NEW;
	subject = "";
	body = "";
	recipients = new Map();
	senderAddress;
	confidential;
	attachments = [];
	replyTos = [];
	previousMessageId = null;
	previousMail = null;
	selectedNotificationLanguage;
	availableNotificationTemplateLanguages = [];
	mailChangedAt = 0;
	mailSavedAt = 1;
	passwords = new Map();
	currentSavePromise = null;
	doSaveAgain = false;
	recipientsResolved = new LazyLoaded(async () => {});
	/**
	* creates a new empty draft message. calling an init method will fill in all the blank data
	*/
	constructor(mailFacade, entity, logins, mailboxModel, contactModel, eventController, mailboxDetails, recipientsModel, dateProvider, mailboxProperties, needNewDraft) {
		this.mailFacade = mailFacade;
		this.entity = entity;
		this.logins = logins;
		this.mailboxModel = mailboxModel;
		this.contactModel = contactModel;
		this.eventController = eventController;
		this.mailboxDetails = mailboxDetails;
		this.recipientsModel = recipientsModel;
		this.dateProvider = dateProvider;
		this.mailboxProperties = mailboxProperties;
		this.needNewDraft = needNewDraft;
		const userProps = logins.getUserController().props;
		this.senderAddress = this.getDefaultSender();
		this.confidential = !userProps.defaultUnconfidential;
		this.selectedNotificationLanguage = getAvailableLanguageCode(userProps.notificationMailLanguage || lang.code);
		this.updateAvailableNotificationTemplateLanguages();
		this.eventController.addEntityListener(this.entityEventReceived);
	}
	entityEventReceived = async (updates) => {
		for (const update of updates) await this.handleEntityEvent(update);
	};
	/**
	* Sort list of all languages alphabetically
	* then we see if the user has custom notification templates
	* in which case we replace the list with just the templates that the user has specified
	*/
	async updateAvailableNotificationTemplateLanguages() {
		this.availableNotificationTemplateLanguages = languages.slice().sort((a, b) => lang.get(a.textId).localeCompare(lang.get(b.textId)));
		const filteredLanguages = await getTemplateLanguages(this.availableNotificationTemplateLanguages, this.entity, this.logins);
		if (filteredLanguages.length > 0) {
			const languageCodes = filteredLanguages.map((l) => l.code);
			this.selectedNotificationLanguage = getSubstitutedLanguageCode(this.logins.getUserController().props.notificationMailLanguage || lang.code, languageCodes) || languageCodes[0];
			this.availableNotificationTemplateLanguages = filteredLanguages;
		}
	}
	user() {
		return this.logins.getUserController();
	}
	isSharedMailbox() {
		return !this.mailboxDetails.mailGroup.user;
	}
	getPreviousMail() {
		return this.previousMail;
	}
	getConversationType() {
		return this.conversationType;
	}
	setPassword(mailAddress, password) {
		this.onMailChanged(null);
		this.passwords.set(mailAddress, password);
	}
	getPassword(mailAddress) {
		return this.passwords.get(mailAddress) || "";
	}
	getSubject() {
		return this.subject;
	}
	setSubject(subject) {
		this.markAsChangedIfNecessary(subject !== this.subject);
		this.subject = subject;
	}
	getBody() {
		return this.body;
	}
	setBody(body) {
		this.markAsChangedIfNecessary(this.body !== body);
		this.body = body;
	}
	/**
	* set the mail address used to send the mail.
	* @param senderAddress the mail address that will show up lowercased in the sender field of the sent mail.
	*/
	setSender(senderAddress) {
		senderAddress = cleanMailAddress(senderAddress);
		this.markAsChangedIfNecessary(this.senderAddress !== senderAddress);
		this.senderAddress = senderAddress;
	}
	getSender() {
		return this.senderAddress;
	}
	/**
	* Returns the strength indicator for the recipients password
	* @returns value between 0 and 100
	*/
	getPasswordStrength(recipient) {
		return getPasswordStrengthForUser(this.getPassword(recipient.address), recipient, this.mailboxDetails, this.logins);
	}
	hasMailChanged() {
		return this.mailChangedAt > this.mailSavedAt;
	}
	/**
	* update the changed state of the mail.
	* will only be reset when saving.
	*/
	markAsChangedIfNecessary(hasChanged) {
		if (!hasChanged) return;
		this.mailChangedAt = this.dateProvider.now();
		this.onMailChanged(null);
	}
	/**
	*
	* @param recipients
	* @param subject
	* @param bodyText
	* @param attachments
	* @param confidential
	* @param senderMailAddress
	* @param initialChangedState
	* @returns {Promise<SendMailModel>}
	*/
	initWithTemplate(recipients, subject, bodyText, attachments, confidential, senderMailAddress, initialChangedState) {
		this.startInit();
		return this.init({
			conversationType: ConversationType.NEW,
			subject,
			bodyText,
			recipients,
			attachments,
			confidential: confidential ?? null,
			senderMailAddress,
			initialChangedState: initialChangedState ?? null
		});
	}
	async initAsResponse(args, inlineImages) {
		this.startInit();
		const { previousMail, conversationType, senderMailAddress, recipients, attachments, subject, bodyText, replyTos } = args;
		let previousMessageId = null;
		await this.entity.load(ConversationEntryTypeRef, previousMail.conversationEntry).then((ce) => {
			previousMessageId = ce.messageId;
		}).catch(ofClass(NotFoundError, (e) => {
			console.log("could not load conversation entry", e);
		}));
		this.loadedInlineImages = cloneInlineImages(inlineImages);
		return this.init({
			conversationType,
			subject,
			bodyText,
			recipients,
			senderMailAddress,
			confidential: previousMail.confidential,
			attachments,
			replyTos,
			previousMail,
			previousMessageId,
			initialChangedState: false
		});
	}
	async initWithDraft(draft, draftDetails, attachments, inlineImages) {
		this.startInit();
		let previousMessageId = null;
		let previousMail = null;
		const conversationEntry = await this.entity.load(ConversationEntryTypeRef, draft.conversationEntry);
		const conversationType = downcast(conversationEntry.conversationType);
		if (conversationEntry.previous) try {
			const previousEntry = await this.entity.load(ConversationEntryTypeRef, conversationEntry.previous);
			previousMessageId = previousEntry.messageId;
			if (previousEntry.mail) previousMail = await this.entity.load(MailTypeRef, previousEntry.mail);
		} catch (e) {
			if (e instanceof NotFoundError) {} else throw e;
		}
		this.loadedInlineImages = cloneInlineImages(inlineImages);
		const { confidential, sender, subject } = draft;
		const { toRecipients, ccRecipients, bccRecipients } = draftDetails.recipients;
		const recipients = {
			to: toRecipients,
			cc: ccRecipients,
			bcc: bccRecipients
		};
		const bodyText = getMailBodyText(draftDetails.body);
		return this.init({
			conversationType,
			subject,
			bodyText,
			recipients,
			draft,
			senderMailAddress: sender.address,
			confidential,
			attachments,
			replyTos: draftDetails.replyTos,
			previousMail,
			previousMessageId,
			initialChangedState: false
		});
	}
	startInit() {
		if (this.initialized) throw new ProgrammingError("trying to initialize SendMailModel twice");
		this.initialized = defer();
	}
	async init({ conversationType, subject, bodyText, draft, recipients, senderMailAddress, confidential, attachments, replyTos, previousMail, previousMessageId, initialChangedState }) {
		this.conversationType = conversationType;
		this.subject = subject;
		this.body = bodyText;
		this.draft = draft || null;
		let to;
		let cc;
		let bcc;
		if (recipients instanceof Array) {
			to = recipients;
			cc = [];
			bcc = [];
		} else {
			to = recipients.to ?? [];
			cc = recipients.cc ?? [];
			bcc = recipients.bcc ?? [];
		}
		this.recipientsResolved = new LazyLoaded(async () => {
			await Promise.all([
				recipientsFilter(to).map((r) => this.insertRecipient(RecipientField.TO, r)),
				recipientsFilter(cc).map((r) => this.insertRecipient(RecipientField.CC, r)),
				recipientsFilter(bcc).map((r) => this.insertRecipient(RecipientField.BCC, r))
			]);
		});
		this.recipientsResolved.getAsync();
		this.senderAddress = senderMailAddress?.toLowerCase() || this.getDefaultSender();
		this.confidential = confidential ?? !this.user().props.defaultUnconfidential;
		this.attachments = [];
		if (attachments) this.attachFiles(attachments);
		this.replyTos = recipientsFilter(replyTos ?? []).map((recipient) => this.recipientsModel.resolve(recipient, ResolveMode.Eager));
		this.previousMail = previousMail || null;
		this.previousMessageId = previousMessageId || null;
		this.mailChangedAt = this.dateProvider.now();
		if (initialChangedState) {
			this.onMailChanged(null);
			this.mailSavedAt = this.mailChangedAt - 1;
		} else this.mailSavedAt = this.mailChangedAt + 1;
		assertNotNull(this.initialized, "somehow got to the end of init without startInit called").resolve();
		return this;
	}
	getDefaultSender() {
		return getDefaultSender(this.logins, this.mailboxDetails);
	}
	getRecipientList(type) {
		return getFromMap(this.recipients, type, () => []);
	}
	toRecipients() {
		return this.getRecipientList(RecipientField.TO);
	}
	toRecipientsResolved() {
		return Promise.all(this.toRecipients().map((recipient) => recipient.resolved()));
	}
	ccRecipients() {
		return this.getRecipientList(RecipientField.CC);
	}
	ccRecipientsResolved() {
		return Promise.all(this.ccRecipients().map((recipient) => recipient.resolved()));
	}
	bccRecipients() {
		return this.getRecipientList(RecipientField.BCC);
	}
	bccRecipientsResolved() {
		return Promise.all(this.bccRecipients().map((recipient) => recipient.resolved()));
	}
	replyTosResolved() {
		return Promise.all(this.replyTos.map((r) => r.resolved()));
	}
	/**
	* add a recipient to the recipient list without updating the saved state of the draft.
	* if the recipient is already inserted, it will wait for it to resolve before returning.
	*
	* @returns whether the list was actually changed.
	*/
	async insertRecipient(fieldType, { address, name, type, contact }, resolveMode = ResolveMode.Eager) {
		let recipient = findRecipientWithAddress(this.getRecipientList(fieldType), address);
		if (!recipient) {
			recipient = this.recipientsModel.resolve({
				address,
				name,
				type,
				contact
			}, resolveMode);
			this.getRecipientList(fieldType).push(recipient);
			recipient.resolved().then(({ address: address$1, contact: contact$1 }) => {
				if (!this.passwords.has(address$1) && contact$1 != null) this.setPassword(address$1, contact$1.presharedPassword ?? "");
else this.onMailChanged(null);
			});
			await recipient.resolved();
			return true;
		}
		await recipient.resolved();
		return false;
	}
	/**
	* Add a new recipient, this method resolves when the recipient resolves.
	* will notify of a changed draft state after the recipient was inserted
	*/
	async addRecipient(fieldType, partialRecipient, resolveMode = ResolveMode.Eager) {
		const wasAdded = await this.insertRecipient(fieldType, partialRecipient, resolveMode);
		this.markAsChangedIfNecessary(wasAdded);
	}
	getRecipient(type, address) {
		return findRecipientWithAddress(this.getRecipientList(type), address);
	}
	removeRecipientByAddress(address, type, notify = true) {
		const recipient = findRecipientWithAddress(this.getRecipientList(type), address);
		if (recipient) this.removeRecipient(recipient, type, notify);
	}
	/**
	* remove recipient from the recipient list
	* @return true if the recipient was removed
	*/
	removeRecipient(recipient, type, notify = true) {
		const recipients = this.recipients.get(type) ?? [];
		const cleanRecipientAddress = cleanMailAddress(recipient.address);
		const didRemove = findAndRemove(recipients, (r) => cleanMailAddress(r.address) === cleanRecipientAddress);
		this.markAsChangedIfNecessary(didRemove);
		if (didRemove && notify) this.onRecipientDeleted({
			field: type,
			recipient
		});
		return didRemove;
	}
	dispose() {
		this.eventController.removeEntityListener(this.entityEventReceived);
		revokeInlineImages(this.loadedInlineImages);
	}
	/**
	* @throws UserError in the case that any files were too big to attach. Small enough files will still have been attached
	*/
	getAttachments() {
		return this.attachments;
	}
	/** @throws UserError in case files are too big to add */
	attachFiles(files) {
		let sizeLeft = MAX_ATTACHMENT_SIZE - this.attachments.reduce((total, file) => total + Number(file.size), 0);
		const sizeCheckResult = checkAttachmentSize(files, sizeLeft);
		this.attachments.push(...sizeCheckResult.attachableFiles);
		this.markAsChangedIfNecessary(sizeCheckResult.attachableFiles.length > 0);
		if (sizeCheckResult.tooBigFiles.length > 0) throw new UserError(lang.makeTranslation("tooBigAttachment_msg", lang.get("tooBigAttachment_msg") + "\n" + sizeCheckResult.tooBigFiles.join("\n")));
	}
	removeAttachment(file) {
		this.markAsChangedIfNecessary(remove(this.attachments, file));
	}
	getSenderName() {
		return getSenderName(this.mailboxProperties, this.senderAddress) ?? "";
	}
	getDraft() {
		return this.draft;
	}
	async updateDraft(body, attachments, draft) {
		return this.mailFacade.updateDraft({
			subject: this.getSubject(),
			body,
			senderMailAddress: this.senderAddress,
			senderName: this.getSenderName(),
			toRecipients: await this.toRecipientsResolved(),
			ccRecipients: await this.ccRecipientsResolved(),
			bccRecipients: await this.bccRecipientsResolved(),
			attachments,
			confidential: this.isConfidential(),
			draft
		}).catch(ofClass(LockedError, (e) => {
			console.log("updateDraft: operation is still active", e);
			throw new UserError("operationStillActive_msg");
		})).catch(ofClass(NotFoundError, (e) => {
			console.log("draft has been deleted, creating new one");
			return this.createDraft(body, attachments, downcast(draft.method));
		}));
	}
	async createDraft(body, attachments, mailMethod) {
		return this.mailFacade.createDraft({
			subject: this.getSubject(),
			bodyText: body,
			senderMailAddress: this.senderAddress,
			senderName: this.getSenderName(),
			toRecipients: await this.toRecipientsResolved(),
			ccRecipients: await this.ccRecipientsResolved(),
			bccRecipients: await this.bccRecipientsResolved(),
			conversationType: this.conversationType,
			previousMessageId: this.previousMessageId,
			attachments,
			confidential: this.isConfidential(),
			replyTos: await this.replyTosResolved(),
			method: mailMethod
		});
	}
	isConfidential() {
		return this.confidential || !this.containsExternalRecipients();
	}
	isConfidentialExternal() {
		return this.confidential && this.containsExternalRecipients();
	}
	setConfidential(confidential) {
		this.markAsChangedIfNecessary(this.confidential !== confidential);
		this.confidential = confidential;
	}
	containsExternalRecipients() {
		return this.allRecipients().some((r) => r.type === RecipientType.EXTERNAL);
	}
	getExternalRecipients() {
		return this.allRecipients().filter((r) => r.type === RecipientType.EXTERNAL);
	}
	/**
	* @reject {RecipientsNotFoundError}
	* @reject {TooManyRequestsError}
	* @reject {AccessBlockedError}
	* @reject {FileNotFoundError}
	* @reject {PreconditionFailedError}
	* @reject {LockedError}
	* @reject {UserError}
	* @param mailMethod
	* @param getConfirmation: A callback to get user confirmation
	* @param waitHandler: A callback to allow UI blocking while the mail is being sent. it seems like wrapping the send call in showProgressDialog causes the confirmation dialogs not to be shown. We should fix this, but this works for now
	* @param tooManyRequestsError
	* @return true if the send was completed, false if it was aborted (by getConfirmation returning false
	*/
	async send(mailMethod, getConfirmation = (_) => Promise.resolve(true), waitHandler = (_, p) => p, tooManyRequestsError = "tooManyMails_msg") {
		this.onBeforeSend();
		if (this.allRecipients().length === 1 && this.allRecipients()[0].address.toLowerCase().trim() === "approval@tutao.de") {
			await this.sendApprovalMail(this.getBody());
			return true;
		}
		if (this.toRecipients().length === 0 && this.ccRecipients().length === 0 && this.bccRecipients().length === 0) throw new UserError("noRecipients_msg");
		const numVisibleRecipients = this.toRecipients().length + this.ccRecipients().length;
		if (numVisibleRecipients >= TOO_MANY_VISIBLE_RECIPIENTS && !await getConfirmation("manyRecipients_msg")) return false;
		if (this.getSubject().length === 0 && !await getConfirmation("noSubject_msg")) return false;
		const asyncSend = async () => {
			const recipients = await this.waitForResolvedRecipients();
			if (this.isConfidentialExternal() && this.getExternalRecipients().some((r) => !this.getPassword(r.address))) throw new UserError("noPreSharedPassword_msg");
			if (this.isConfidentialExternal() && this.hasInsecurePasswords() && !await getConfirmation("presharedPasswordNotStrongEnough_msg")) return false;
			await this.saveDraft(true, mailMethod);
			await this.updateContacts(recipients);
			await this.mailFacade.sendDraft(assertNotNull(this.draft, "draft was null?"), recipients, this.selectedNotificationLanguage);
			await this.updatePreviousMail();
			await this.updateExternalLanguage();
			return true;
		};
		return waitHandler(this.isConfidential() ? "sending_msg" : "sendingUnencrypted_msg", asyncSend()).catch(ofClass(LockedError, () => {
			throw new UserError("operationStillActive_msg");
		})).catch(ofClass(RecipientNotResolvedError, () => {
			throw new UserError("tooManyAttempts_msg");
		})).catch(ofClass(RecipientsNotFoundError, (e) => {
			if (mailMethod === MailMethod.ICAL_CANCEL) throw e;
else {
				let invalidRecipients = e.message;
				throw new UserError(lang.makeTranslation("error_msg", lang.get("tutanotaAddressDoesNotExist_msg") + " " + lang.get("invalidRecipients_msg") + "\n" + invalidRecipients));
			}
		})).catch(ofClass(TooManyRequestsError, () => {
			throw new UserError(tooManyRequestsError);
		})).catch(ofClass(AccessBlockedError, (e) => {
			return checkApprovalStatus(this.logins, true, ApprovalStatus.SPAM_SENDER).then(() => {
				console.log("could not send mail (blocked access)", e);
				return false;
			});
		})).catch(ofClass(FileNotFoundError, () => {
			throw new UserError("couldNotAttachFile_msg");
		})).catch(ofClass(PreconditionFailedError, () => {
			throw new UserError("operationStillActive_msg");
		}));
	}
	/**
	* Whether any of the external recipients have an insecure password.
	* We don't consider empty passwords, because an empty password will disallow and encrypted email from sending, whereas an insecure password
	* can still be used
	* @returns {boolean}
	*/
	hasInsecurePasswords() {
		const minimalPasswordStrength = this.allRecipients().filter((r) => this.getPassword(r.address) !== "").reduce((min, recipient) => Math.min(min, this.getPasswordStrength(recipient)), PASSWORD_MIN_SECURE_VALUE);
		return !isSecurePassword(minimalPasswordStrength);
	}
	saveDraft(saveAttachments, mailMethod) {
		if (this.currentSavePromise == null) this.currentSavePromise = Promise.resolve().then(async () => {
			try {
				await this.doSaveDraft(saveAttachments, mailMethod);
			} finally {
				this.currentSavePromise = null;
			}
			if (this.hasMailChanged() && this.doSaveAgain) {
				this.doSaveAgain = false;
				await this.saveDraft(saveAttachments, mailMethod);
			}
		});
else this.doSaveAgain = true;
		return this.currentSavePromise;
	}
	/**
	* Saves the draft.
	* @param saveAttachments True if also the attachments shall be saved, false otherwise.
	* @param mailMethod
	* @returns {Promise} When finished.
	* @throws FileNotFoundError when one of the attachments could not be opened
	* @throws PreconditionFailedError when the draft is locked
	*/
	async doSaveDraft(saveAttachments, mailMethod) {
		if (this.initialized == null) throw new ProgrammingError("init for SendMailModel was not called");
		await this.initialized;
		try {
			const attachments = saveAttachments ? this.attachments : null;
			const { htmlSanitizer } = await import("./HtmlSanitizer-DJqF9m1z.js");
			const unsanitized_body = this.getBody();
			const body = htmlSanitizer.sanitizeHTML(unsanitized_body, {
				blockExternalContent: false,
				allowRelativeLinks: true,
				usePlaceholderForInlineImages: false
			}).html;
			this.draft = this.draft == null || await this.needNewDraft(this.draft) ? await this.createDraft(body, attachments, mailMethod) : await this.updateDraft(body, attachments, this.draft);
			const attachmentIds = await this.mailFacade.getAttachmentIds(this.draft);
			const newAttachments = await pMap(attachmentIds, (fileId) => this.entity.load(FileTypeRef, fileId), { concurrency: 5 });
			this.attachments = [];
			this.attachFiles(newAttachments);
			this.mailSavedAt = this.dateProvider.now();
		} catch (e) {
			if (e instanceof PayloadTooLargeError) throw new UserError("requestTooLarge_msg");
else if (e instanceof MailBodyTooLargeError) throw new UserError("mailBodyTooLarge_msg");
else if (e instanceof FileNotFoundError) throw new UserError("couldNotAttachFile_msg");
else if (e instanceof PreconditionFailedError) throw new UserError("operationStillActive_msg");
else throw e;
		}
	}
	sendApprovalMail(body) {
		const listId = "---------c--";
		const m = createApprovalMail({
			_id: [listId, stringToCustomId(this.senderAddress)],
			_ownerGroup: this.user().user.userGroup.group,
			text: `Subject: ${this.getSubject()}<br>${body}`,
			date: null,
			range: null,
			customer: null
		});
		return this.entity.setup(listId, m).catch(ofClass(NotAuthorizedError, (e) => console.log("not authorized for approval message")));
	}
	getAvailableNotificationTemplateLanguages() {
		return this.availableNotificationTemplateLanguages;
	}
	getSelectedNotificationLanguageCode() {
		return this.selectedNotificationLanguage;
	}
	setSelectedNotificationLanguageCode(code) {
		this.markAsChangedIfNecessary(this.selectedNotificationLanguage !== code);
		this.selectedNotificationLanguage = code;
		this.markAsChangedIfNecessary(true);
	}
	updateExternalLanguage() {
		let props = this.user().props;
		if (props.notificationMailLanguage !== this.selectedNotificationLanguage) {
			props.notificationMailLanguage = this.selectedNotificationLanguage;
			this.entity.update(props);
		}
	}
	updatePreviousMail() {
		if (this.previousMail) {
			if (this.previousMail.replyType === ReplyType.NONE && this.conversationType === ConversationType.REPLY) this.previousMail.replyType = ReplyType.REPLY;
else if (this.previousMail.replyType === ReplyType.NONE && this.conversationType === ConversationType.FORWARD) this.previousMail.replyType = ReplyType.FORWARD;
else if (this.previousMail.replyType === ReplyType.FORWARD && this.conversationType === ConversationType.REPLY) this.previousMail.replyType = ReplyType.REPLY_FORWARD;
else if (this.previousMail.replyType === ReplyType.REPLY && this.conversationType === ConversationType.FORWARD) this.previousMail.replyType = ReplyType.REPLY_FORWARD;
else return Promise.resolve();
			return this.entity.update(this.previousMail).catch(ofClass(NotFoundError, noOp));
		} else return Promise.resolve();
	}
	/**
	* If contacts have had their passwords changed, we update them before sending
	*/
	async updateContacts(resolvedRecipients) {
		for (const { address, contact, type } of resolvedRecipients) {
			if (contact == null) continue;
			const isExternalAndConfidential = type === RecipientType.EXTERNAL && this.isConfidential();
			if (!contact._id && (!this.user().props.noAutomaticContacts || isExternalAndConfidential)) {
				if (isExternalAndConfidential) contact.presharedPassword = this.getPassword(address).trim();
				const listId = await this.contactModel.getContactListId();
				await this.entity.setup(listId, contact);
			} else if (contact._id && isExternalAndConfidential && contact.presharedPassword !== this.getPassword(address).trim()) {
				contact.presharedPassword = this.getPassword(address).trim();
				await this.entity.update(contact);
			}
		}
	}
	allRecipients() {
		return this.toRecipients().concat(this.ccRecipients()).concat(this.bccRecipients());
	}
	/**
	* Makes sure the recipient type and contact are resolved.
	*/
	async waitForResolvedRecipients() {
		await this.recipientsResolved.getAsync();
		return Promise.all(this.allRecipients().map((recipient) => recipient.resolved())).catch(ofClass(TooManyRequestsError, () => {
			throw new RecipientNotResolvedError("");
		}));
	}
	async handleEntityEvent(update) {
		const { operation, instanceId, instanceListId } = update;
		let contactId = [neverNull(instanceListId), instanceId];
		let changed = false;
		if (isUpdateForTypeRef(ContactTypeRef, update)) {
			await this.recipientsResolved.getAsync();
			if (operation === OperationType.UPDATE) this.entity.load(ContactTypeRef, contactId).then((contact) => {
				for (const fieldType of typedValues(RecipientField)) {
					const matching = this.getRecipientList(fieldType).filter((recipient) => recipient.contact && isSameId(recipient.contact._id, contact._id));
					for (const recipient of matching) if (!contact.mailAddresses.some((ma) => cleanMatch(ma.address, recipient.address))) changed = changed || this.removeRecipient(recipient, fieldType, true);
else {
						recipient.setName(getContactDisplayName(contact));
						recipient.setContact(contact);
						changed = true;
					}
				}
			});
else if (operation === OperationType.DELETE) for (const fieldType of typedValues(RecipientField)) {
				const recipients = this.getRecipientList(fieldType);
				const toDelete = recipients.filter((recipient) => recipient.contact && isSameId(recipient.contact._id, contactId) || false);
				for (const r of toDelete) changed = changed || this.removeRecipient(r, fieldType, true);
			}
			this.markAsChangedIfNecessary(true);
		} else if (isUpdateForTypeRef(CustomerPropertiesTypeRef, update)) this.updateAvailableNotificationTemplateLanguages();
else if (isUpdateForTypeRef(MailboxPropertiesTypeRef, update) && operation === OperationType.UPDATE) this.mailboxProperties = await this.entity.load(MailboxPropertiesTypeRef, update.instanceId);
		this.markAsChangedIfNecessary(changed);
		return Promise.resolve();
	}
	setOnBeforeSendFunction(fun) {
		this.onBeforeSend = fun;
	}
	isUserPreviousSender() {
		if (!this.previousMail) return false;
		return isUserEmail(this.logins, this.mailboxDetails, this.previousMail.sender.address);
	}
};
/**
* deduplicate a list of recipients for insertion in any of the recipient fields
* recipients are considered equal when their cleanMailAddress() is the same
* returns the recipients with their original mail address
*
* unhandled edge case: it's possible to lose recipients that should be kept when
* * the mail contains several recipients that have the same clean address (Bob@e.de and bob@e.de)
* * the e.de mail server considers these distinct
* * we hit "reply all"
*
*/
function recipientsFilter(recipientList) {
	const cleanedList = recipientList.filter((r) => isMailAddress(r.address, false)).map((a) => ({
		recipient: a,
		cleaned: cleanMailAddress(a.address)
	}));
	return deduplicate(cleanedList, (a, b) => a.cleaned === b.cleaned).map((a) => a.recipient);
}

//#endregion
export { SendMailModel, TOO_MANY_VISIBLE_RECIPIENTS };
//# sourceMappingURL=SendMailModel-C8sfTf0o.js.map