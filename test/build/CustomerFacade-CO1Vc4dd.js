
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, neverNull, noOp, ofClass, stringToUtf8Uint8Array, uint8ArrayToBase64, uint8ArrayToHex } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertWorkerOrNode } from "./Env-D5xGlXfw.js";
import { AccountType, BookingItemFeatureType, Const, CounterType, CryptoProtocolVersion, GroupType } from "./TutanotaConstants-3bwAESYA.js";
import { getByAbbreviation } from "./CountryList-DkVQtcTj.js";
import { LockedError } from "./RestError-D17JEBMr.js";
import "./CryptoError-PqdvQky4.js";
import "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import { createCustomerAccountCreateData } from "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import { AccountingInfoTypeRef, CustomerInfoTypeRef, CustomerServerPropertiesTypeRef, CustomerTypeRef, createBrandingDomainData, createBrandingDomainDeleteData, createCreateCustomerServerPropertiesData, createCustomDomainData, createEmailSenderListElement, createInvoiceDataGetIn, createMembershipAddData, createMembershipRemoveData, createPaymentDataServicePutData } from "./TypeRefs-BP1jvX9p.js";
import { aes256RandomKey, bitArrayToUint8Array, hexToRsaPublicKey, sha256Hash, uint8ArrayToBitArray } from "./dist-DcZ1Y4qd.js";
import { BrandingDomainService, CreateCustomerServerProperties, CustomDomainService, InvoiceDataService, MembershipService, PaymentDataService, SystemKeysService } from "./Services-CZFE0084.js";
import { CustomerAccountService } from "./Services-DCx-CeM7.js";
import { getWhitelabelDomainInfo } from "./CustomerUtils-DmaZpb7Y.js";
import { encryptKeyWithVersionedKey } from "./CryptoWrapper-BTtEczdP.js";
import { formatNameAndAddress } from "./CommonFormatter-DiwVeRKZ.js";

//#region ../src/common/api/worker/facades/lazy/CustomerFacade.ts
assertWorkerOrNode();
var CustomerFacade = class {
	constructor(userFacade, groupManagement, userManagement, counters, rsa, entityClient, serviceExecutor, bookingFacade, cryptoFacade, operationProgressTracker, pdfWriter, pqFacade, keyLoaderFacade, recoverCodeFacade, asymmetricCryptoFacade) {
		this.userFacade = userFacade;
		this.groupManagement = groupManagement;
		this.userManagement = userManagement;
		this.counters = counters;
		this.rsa = rsa;
		this.entityClient = entityClient;
		this.serviceExecutor = serviceExecutor;
		this.bookingFacade = bookingFacade;
		this.cryptoFacade = cryptoFacade;
		this.operationProgressTracker = operationProgressTracker;
		this.pdfWriter = pdfWriter;
		this.pqFacade = pqFacade;
		this.keyLoaderFacade = keyLoaderFacade;
		this.recoverCodeFacade = recoverCodeFacade;
		this.asymmetricCryptoFacade = asymmetricCryptoFacade;
	}
	async getDomainValidationRecord(domainName) {
		const customer = this.getCustomerId();
		const baseString = domainName.trim().toLowerCase() + customer;
		const hash = sha256Hash(stringToUtf8Uint8Array(baseString)).slice(0, 16);
		return "t-verify=" + uint8ArrayToHex(hash);
	}
	addDomain(domainName) {
		const data = createCustomDomainData({
			domain: domainName.trim().toLowerCase(),
			catchAllMailGroup: null
		});
		return this.serviceExecutor.post(CustomDomainService, data);
	}
	async removeDomain(domainName) {
		const data = createCustomDomainData({
			domain: domainName.trim().toLowerCase(),
			catchAllMailGroup: null
		});
		await this.serviceExecutor.delete(CustomDomainService, data);
	}
	async setCatchAllGroup(domainName, mailGroupId) {
		const data = createCustomDomainData({
			domain: domainName.trim().toLowerCase(),
			catchAllMailGroup: mailGroupId
		});
		await this.serviceExecutor.put(CustomDomainService, data);
	}
	async orderWhitelabelCertificate(domainName) {
		const customerId = this.getCustomerId();
		const customer = await this.entityClient.load(CustomerTypeRef, customerId);
		const customerInfo = await this.entityClient.load(CustomerInfoTypeRef, customer.customerInfo);
		let existingBrandingDomain = getWhitelabelDomainInfo(customerInfo, domainName);
		let sessionKey = aes256RandomKey();
		const keyData = await this.serviceExecutor.get(SystemKeysService, null);
		const pubRsaKey = keyData.systemAdminPubRsaKey;
		const pubEccKey = keyData.systemAdminPubEccKey;
		const pubKyberKey = keyData.systemAdminPubKyberKey;
		const systemAdminPubKeys = {
			object: {
				pubEccKey,
				pubKyberKey,
				pubRsaKey
			},
			version: Number(keyData.systemAdminPubKeyVersion)
		};
		const { pubEncSymKeyBytes, cryptoProtocolVersion } = await this.asymmetricCryptoFacade.asymEncryptSymKey(sessionKey, systemAdminPubKeys, this.userFacade.getUserGroupId());
		const data = createBrandingDomainData({
			domain: domainName,
			systemAdminPubEncSessionKey: pubEncSymKeyBytes,
			systemAdminPubKeyVersion: String(systemAdminPubKeys.version),
			systemAdminPublicProtocolVersion: cryptoProtocolVersion,
			sessionEncPemPrivateKey: null,
			sessionEncPemCertificateChain: null
		});
		if (existingBrandingDomain) await this.serviceExecutor.put(BrandingDomainService, data);
else await this.serviceExecutor.post(BrandingDomainService, data);
	}
	getCustomerId() {
		return assertNotNull(this.userFacade.getLoggedInUser().customer);
	}
	async deleteCertificate(domainName) {
		const data = createBrandingDomainDeleteData({ domain: domainName });
		await this.serviceExecutor.delete(BrandingDomainService, data);
	}
	/**
	* Reads the used storage of a customer in bytes.
	* @return The amount of used storage in byte.
	*/
	async readUsedCustomerStorage(customerId) {
		const customerCounters = await this.counters.readAllCustomerCounterValues(CounterType.UserStorageLegacy, customerId);
		return customerCounters.reduce((sum, counterValue) => sum + Number(counterValue.value), 0);
	}
	/**
	* Reads the available storage capacity of a customer in bytes.
	* @return The amount of available storage capacity in byte.
	*/
	readAvailableCustomerStorage(customerId) {
		return this.entityClient.load(CustomerTypeRef, customerId).then((customer) => {
			return this.entityClient.load(CustomerInfoTypeRef, customer.customerInfo).then((customerInfo) => {
				let includedStorage = Number(customerInfo.includedStorageCapacity);
				let promotionStorage = Number(customerInfo.promotionStorageCapacity);
				let availableStorage = Math.max(includedStorage, promotionStorage);
				let bookedStorage = 0;
				if (customer.type === AccountType.PAID) return this.bookingFacade.getCurrentPrice().then((price) => {
					let currentStorageItem = this.bookingFacade.getPriceItem(price.currentPriceNextPeriod, BookingItemFeatureType.Storage);
					if (currentStorageItem != null) bookedStorage = Number(currentStorageItem.count);
					availableStorage = Math.max(bookedStorage, availableStorage);
					return availableStorage * Const.MEMORY_GB_FACTOR;
				});
else return availableStorage * Const.MEMORY_GB_FACTOR;
			});
		});
	}
	async loadCustomerServerProperties() {
		const customer = await this.entityClient.load(CustomerTypeRef, this.getCustomerId());
		let cspId;
		if (customer.serverProperties) cspId = customer.serverProperties;
else {
			const sessionKey = aes256RandomKey();
			const adminGroupId = this.userFacade.getGroupId(GroupType.Admin);
			const adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
			const adminGroupEncSessionKey = encryptKeyWithVersionedKey(adminGroupKey, sessionKey);
			const data = createCreateCustomerServerPropertiesData({
				adminGroupEncSessionKey: adminGroupEncSessionKey.key,
				adminGroupKeyVersion: adminGroupEncSessionKey.encryptingKeyVersion.toString()
			});
			const returnData = await this.serviceExecutor.post(CreateCustomerServerProperties, data);
			cspId = returnData.id;
		}
		return this.entityClient.load(CustomerServerPropertiesTypeRef, cspId);
	}
	addSpamRule(field, type, value) {
		return this.loadCustomerServerProperties().then((props) => {
			value = value.toLowerCase().trim();
			let newListEntry = createEmailSenderListElement({
				value,
				hashedValue: uint8ArrayToBase64(sha256Hash(stringToUtf8Uint8Array(value))),
				type,
				field
			});
			props.emailSenderList.push(newListEntry);
			return this.entityClient.update(props).catch(ofClass(LockedError, noOp));
		});
	}
	editSpamRule(spamRule) {
		return this.loadCustomerServerProperties().then((props) => {
			spamRule.value = spamRule.value.toLowerCase().trim();
			const index = props.emailSenderList.findIndex((item) => spamRule._id === item._id);
			if (index === -1) throw new Error("spam rule does not exist " + JSON.stringify(spamRule));
			props.emailSenderList[index] = spamRule;
			return this.entityClient.update(props).catch(ofClass(LockedError, noOp));
		});
	}
	async generateSignupKeys(operationId) {
		const key1 = await this.pqFacade.generateKeyPairs();
		await this.operationProgressTracker.onProgress(operationId, 33);
		const key2 = await this.pqFacade.generateKeyPairs();
		await this.operationProgressTracker.onProgress(operationId, 66);
		const key3 = await this.pqFacade.generateKeyPairs();
		await this.operationProgressTracker.onProgress(operationId, 100);
		return [
			key1,
			key2,
			key3
		];
	}
	async signup(keyPairs, accountType, authToken, mailAddress, password, registrationCode, currentLanguage, app) {
		const userGroupKey = {
			object: aes256RandomKey(),
			version: 0
		};
		const adminGroupKey = {
			object: aes256RandomKey(),
			version: 0
		};
		const customerGroupKey = {
			object: aes256RandomKey(),
			version: 0
		};
		const userGroupInfoSessionKey = aes256RandomKey();
		const adminGroupInfoSessionKey = aes256RandomKey();
		const customerGroupInfoSessionKey = aes256RandomKey();
		const accountingInfoSessionKey = aes256RandomKey();
		const customerServerPropertiesSessionKey = aes256RandomKey();
		const keyData = await this.serviceExecutor.get(SystemKeysService, null);
		const pubRsaKey = keyData.systemAdminPubRsaKey;
		const pubEccKey = keyData.systemAdminPubEccKey;
		const pubKyberKey = keyData.systemAdminPubKyberKey;
		let systemAdminPubEncAccountingInfoSessionKey;
		let systemAdminPublicProtocolVersion;
		if (pubRsaKey) {
			const rsaPublicKey = hexToRsaPublicKey(uint8ArrayToHex(pubRsaKey));
			const systemAdminPubEncAccountingInfoSessionKeyBytes = await this.rsa.encrypt(rsaPublicKey, bitArrayToUint8Array(accountingInfoSessionKey));
			systemAdminPubEncAccountingInfoSessionKey = {
				key: systemAdminPubEncAccountingInfoSessionKeyBytes,
				encryptingKeyVersion: Number(keyData.systemAdminPubKeyVersion)
			};
			systemAdminPublicProtocolVersion = CryptoProtocolVersion.RSA;
		} else throw new ProgrammingError("system admin having pq key pair is not supported");
		const userGroupData = this.groupManagement.generateInternalGroupData(keyPairs[0], userGroupKey.object, userGroupInfoSessionKey, null, adminGroupKey, customerGroupKey);
		const adminGroupData = this.groupManagement.generateInternalGroupData(keyPairs[1], adminGroupKey.object, adminGroupInfoSessionKey, null, adminGroupKey, customerGroupKey);
		const customerGroupData = this.groupManagement.generateInternalGroupData(keyPairs[2], customerGroupKey.object, customerGroupInfoSessionKey, null, adminGroupKey, customerGroupKey);
		const recoverData = this.recoverCodeFacade.generateRecoveryCode(userGroupKey);
		const userEncAdminGroupKey = encryptKeyWithVersionedKey(userGroupKey, adminGroupKey.object);
		const adminEncAccountingInfoSessionKey = encryptKeyWithVersionedKey(adminGroupKey, accountingInfoSessionKey);
		const adminEncCustomerServerPropertiesSessionKey = encryptKeyWithVersionedKey(adminGroupKey, customerServerPropertiesSessionKey);
		const data = createCustomerAccountCreateData({
			authToken,
			date: Const.CURRENT_DATE,
			lang: currentLanguage,
			code: registrationCode,
			userData: await this.userManagement.generateUserAccountData(userGroupKey, userGroupInfoSessionKey, customerGroupKey, mailAddress, password, "", recoverData),
			userEncAdminGroupKey: userEncAdminGroupKey.key,
			userGroupData,
			adminGroupData,
			customerGroupData,
			adminEncAccountingInfoSessionKey: adminEncAccountingInfoSessionKey.key,
			systemAdminPubEncAccountingInfoSessionKey: systemAdminPubEncAccountingInfoSessionKey.key,
			systemAdminPubKeyVersion: String(systemAdminPubEncAccountingInfoSessionKey.encryptingKeyVersion),
			systemAdminPublicProtocolVersion,
			adminEncCustomerServerPropertiesSessionKey: adminEncCustomerServerPropertiesSessionKey.key,
			userEncAccountGroupKey: new Uint8Array(0),
			accountGroupKeyVersion: "0",
			app
		});
		await this.serviceExecutor.post(CustomerAccountService, data);
		return recoverData.hexCode;
	}
	async switchFreeToPremiumGroup() {
		try {
			const keyData = await this.serviceExecutor.get(SystemKeysService, null);
			await this.switchAccountGroup(neverNull(keyData.freeGroup), neverNull(keyData.premiumGroup), {
				object: uint8ArrayToBitArray(keyData.premiumGroupKey),
				version: Number(keyData.premiumGroupKeyVersion)
			});
		} catch (e) {
			e.message = e.message + " error switching free to premium group";
			console.log(e);
			throw e;
		}
	}
	async switchPremiumToFreeGroup() {
		try {
			const keyData = await this.serviceExecutor.get(SystemKeysService, null);
			await this.switchAccountGroup(neverNull(keyData.premiumGroup), neverNull(keyData.freeGroup), {
				object: uint8ArrayToBitArray(keyData.freeGroupKey),
				version: Number(keyData.freeGroupKeyVersion)
			});
		} catch (e) {
			e.message = e.message + " error switching premium to free group";
			console.log(e);
			throw e;
		}
	}
	async updatePaymentData(paymentInterval, invoiceData, paymentData, confirmedInvoiceCountry) {
		let customer = await this.entityClient.load(CustomerTypeRef, assertNotNull(this.userFacade.getLoggedInUser().customer));
		let customerInfo = await this.entityClient.load(CustomerInfoTypeRef, customer.customerInfo);
		let accountingInfo = await this.entityClient.load(AccountingInfoTypeRef, customerInfo.accountingInfo);
		let accountingInfoSessionKey = await this.cryptoFacade.resolveSessionKeyForInstance(accountingInfo);
		const service = createPaymentDataServicePutData({
			paymentInterval: paymentInterval.toString(),
			invoiceName: "",
			invoiceAddress: invoiceData.invoiceAddress,
			invoiceCountry: invoiceData.country ? invoiceData.country.a : "",
			invoiceVatIdNo: invoiceData.vatNumber ? invoiceData.vatNumber : "",
			paymentMethod: paymentData ? paymentData.paymentMethod : accountingInfo.paymentMethod ? accountingInfo.paymentMethod : "",
			paymentMethodInfo: null,
			paymentToken: null,
			creditCard: paymentData && paymentData.creditCardData ? paymentData.creditCardData : null,
			confirmedCountry: confirmedInvoiceCountry ? confirmedInvoiceCountry.a : null
		});
		return this.serviceExecutor.put(PaymentDataService, service, { sessionKey: accountingInfoSessionKey ?? undefined });
	}
	/**
	* Convenience function to change the payment interval for the current subscription
	* @param accountingInfo accounting info
	* @param newPaymentInterval new payment interval
	*/
	async changePaymentInterval(accountingInfo, newPaymentInterval) {
		const invoiceCountry = neverNull(getByAbbreviation(neverNull(accountingInfo.invoiceCountry)));
		return this.updatePaymentData(newPaymentInterval, {
			invoiceAddress: formatNameAndAddress(accountingInfo.invoiceName, accountingInfo.invoiceAddress),
			country: invoiceCountry,
			vatNumber: accountingInfo.invoiceVatIdNo
		}, null, invoiceCountry);
	}
	async generatePdfInvoice(invoiceNumber) {
		const invoiceData = await this.serviceExecutor.get(InvoiceDataService, createInvoiceDataGetIn({ invoiceNumber }));
		const writer = await this.pdfWriter();
		const { PdfInvoiceGenerator } = await import("./PdfInvoiceGenerator-BXIzPxXT.js");
		const pdfGenerator = new PdfInvoiceGenerator(writer, invoiceData, invoiceNumber, this.getCustomerId());
		const pdfFile = await pdfGenerator.generate();
		return {
			_type: "DataFile",
			name: String(invoiceNumber) + ".pdf",
			mimeType: "application/pdf",
			data: pdfFile,
			size: pdfFile.byteLength,
			id: undefined
		};
	}
	async generateXRechnungInvoice(invoiceNumber) {
		const customer = await this.entityClient.load(CustomerTypeRef, assertNotNull(this.userFacade.getUser()?.customer));
		const customerInfo = await this.entityClient.load(CustomerInfoTypeRef, customer.customerInfo);
		const invoiceData = await this.serviceExecutor.get(InvoiceDataService, createInvoiceDataGetIn({ invoiceNumber }));
		const { XRechnungInvoiceGenerator } = await import("./XRechnungInvoiceGenerator-ByhG9sbh.js");
		const xRechnungGenerator = new XRechnungInvoiceGenerator(invoiceData, invoiceNumber, this.getCustomerId(), customerInfo.registrationMailAddress);
		const xRechnungFile = xRechnungGenerator.generate();
		return {
			_type: "DataFile",
			name: String(invoiceNumber) + ".xml",
			mimeType: "application/xml",
			data: xRechnungFile,
			size: xRechnungFile.byteLength,
			id: undefined
		};
	}
	async loadAccountingInfo() {
		const customer = await this.entityClient.load(CustomerTypeRef, assertNotNull(this.userFacade.getUser()?.customer));
		const customerInfo = await this.entityClient.load(CustomerInfoTypeRef, customer.customerInfo);
		return this.entityClient.load(AccountingInfoTypeRef, customerInfo.accountingInfo);
	}
	async switchAccountGroup(oldGroup, newGroup, newGroupKey) {
		const loggedInUser = this.userFacade.getLoggedInUser();
		const symEncGKey = encryptKeyWithVersionedKey(this.userFacade.getCurrentUserGroupKey(), newGroupKey.object);
		const membershipAddData = createMembershipAddData({
			user: loggedInUser._id,
			group: newGroup,
			symEncGKey: symEncGKey.key,
			groupKeyVersion: newGroupKey.version.toString(),
			symKeyVersion: symEncGKey.encryptingKeyVersion.toString()
		});
		await this.serviceExecutor.post(MembershipService, membershipAddData);
		const membershipRemoveData = createMembershipRemoveData({
			user: loggedInUser._id,
			group: oldGroup
		});
		return this.serviceExecutor.delete(MembershipService, membershipRemoveData);
	}
};

//#endregion
export { CustomerFacade };
//# sourceMappingURL=CustomerFacade-CO1Vc4dd.js.map