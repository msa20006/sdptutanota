{"version":3,"file":"CredentialsProvider-HbB_U0ec.js","names":["credentialsFacade: NativeCredentialsFacade","sqliteCipherFacade: SqlCipherFacade | null","interWindowEventSender: InterWindowEventFacadeSendDispatcher | null","credentials: UnencryptedCredentials","credentials: CredentialsInfo","encryptedPassword: string","encryptedPassphraseKey: Uint8Array","newEncryptedCredentials: PersistedCredentials","userId: Id","opts: { deleteOfflineDb: boolean }","encryptionMode: CredentialEncryptionMode","reason: Error | string"],"sources":["../../src/common/misc/credentials/CredentialsProvider.ts"],"sourcesContent":["import type { CredentialEncryptionMode } from \"./CredentialEncryptionMode.js\"\nimport { InterWindowEventFacadeSendDispatcher } from \"../../native/common/generatedipc/InterWindowEventFacadeSendDispatcher.js\"\nimport { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { CredentialsInfo } from \"../../native/common/generatedipc/CredentialsInfo.js\"\nimport { CredentialType } from \"./CredentialType.js\"\nimport { PersistedCredentials } from \"../../native/common/generatedipc/PersistedCredentials.js\"\nimport { NativeCredentialsFacade } from \"../../native/common/generatedipc/NativeCredentialsFacade\"\nimport { UnencryptedCredentials } from \"../../native/common/generatedipc/UnencryptedCredentials.js\"\nimport { isAdminClient, isBrowser } from \"../../api/common/Env.js\"\n\n/**\n * Main entry point to interact with credentials, i.e. storing and retrieving credentials from/to persistence.\n */\nexport class CredentialsProvider {\n\tconstructor(\n\t\tprivate readonly credentialsFacade: NativeCredentialsFacade,\n\t\tprivate readonly sqliteCipherFacade: SqlCipherFacade | null,\n\t\tprivate readonly interWindowEventSender: InterWindowEventFacadeSendDispatcher | null,\n\t) {}\n\n\t/**\n\t * Stores credentials. If credentials already exist for login, they will be overwritten.\n\t */\n\tasync store(credentials: UnencryptedCredentials): Promise<void> {\n\t\treturn this.credentialsFacade.store(credentials)\n\t}\n\n\t/**\n\t * Change the encrypted password for the stored credentials.\n\t */\n\tasync replacePassword(credentials: CredentialsInfo, encryptedPassword: string, encryptedPassphraseKey: Uint8Array): Promise<void> {\n\t\tconst encryptedCredentials = await this.getCredentialsByUserId(credentials.userId)\n\t\tif (encryptedCredentials == null) {\n\t\t\tthrow new Error(`Trying to replace password for credentials but credentials are not persisted: ${credentials.userId}`)\n\t\t}\n\t\t// Encrypted password is encrypted with the session key and is the same for encrypted and decrypted credentials, no additional logic is needed.\n\t\tconst newEncryptedCredentials: PersistedCredentials = {\n\t\t\t...encryptedCredentials,\n\t\t\tencryptedPassword,\n\t\t\tencryptedPassphraseKey,\n\t\t}\n\t\tawait this.credentialsFacade.storeEncrypted(newEncryptedCredentials)\n\t}\n\n\tasync getCredentialsInfoByUserId(userId: Id): Promise<CredentialsInfo | null> {\n\t\treturn (await this.getCredentialsByUserId(userId))?.credentialInfo ?? null\n\t}\n\n\tasync getAllInternalCredentials(): Promise<readonly PersistedCredentials[]> {\n\t\treturn this.credentialsFacade.loadAll()\n\t}\n\n\tprivate async getCredentialsByUserId(userId: Id): Promise<PersistedCredentials | null> {\n\t\tconst allCredentials = await this.credentialsFacade.loadAll()\n\t\treturn allCredentials.find((credential) => credential.credentialInfo.userId === userId) ?? null\n\t}\n\n\t/**\n\t * Returns the full credentials for the userId passed in.\n\t * @param userId\n\t */\n\tasync getDecryptedCredentialsByUserId(userId: Id): Promise<UnencryptedCredentials | null> {\n\t\treturn this.credentialsFacade.loadByUserId(userId)\n\t}\n\n\t/**\n\t * Returns the stored credentials infos of all internal users, i.e. users that have a \"real\" tutanota account and not the ones that\n\t * have a secure external mailbox. The returned array will be sorted by login.\n\t */\n\tasync getInternalCredentialsInfos(): Promise<ReadonlyArray<CredentialsInfo>> {\n\t\tconst allCredentials = await this.credentialsFacade.loadAll()\n\t\treturn allCredentials\n\t\t\t.filter((credential) => credential.credentialInfo.type === CredentialType.Internal)\n\t\t\t.map((credential) => credential.credentialInfo)\n\t\t\t.sort((a, b) => a.login.localeCompare(b.login))\n\t}\n\n\t/**\n\t * Deletes stored credentials with specified userId.\n\t * No-op if credentials are not there.\n\t * @param opts.deleteOfflineDb whether to delete offline database. Will delete by default.\n\t */\n\tasync deleteByUserId(userId: Id, opts: { deleteOfflineDb: boolean } = { deleteOfflineDb: true }): Promise<void> {\n\t\tawait this.interWindowEventSender?.localUserDataInvalidated(userId)\n\t\tif (opts.deleteOfflineDb) {\n\t\t\tawait this.sqliteCipherFacade?.deleteDb(userId)\n\t\t}\n\t\tawait this.credentialsFacade.deleteByUserId(userId)\n\t}\n\n\t/**\n\t * Sets the credentials encryption mode, i.e. how the intermediate key used for encrypting credentials is protected.\n\t * @param encryptionMode\n\t * @throws KeyPermanentlyInvalidatedError\n\t * @throws CredentialAuthenticationError\n\t */\n\tasync setCredentialEncryptionMode(encryptionMode: CredentialEncryptionMode): Promise<void> {\n\t\tawait this.credentialsFacade.setCredentialEncryptionMode(encryptionMode)\n\t\tthis.interWindowEventSender?.reloadDeviceConfig()\n\t}\n\n\t/**\n\t * Returns the credentials encryption mode, i.e. how the intermediate key used for encrypting credentials is protected.\n\t */\n\tgetCredentialEncryptionMode(): Promise<CredentialEncryptionMode | null> {\n\t\treturn this.credentialsFacade.getCredentialEncryptionMode()\n\t}\n\n\t/**\n\t * Returns all credentials encryption modes that are supported by the device.\n\t */\n\tasync getSupportedEncryptionModes(): Promise<ReadonlyArray<CredentialEncryptionMode>> {\n\t\treturn await this.credentialsFacade.getSupportedEncryptionModes()\n\t}\n\n\t/**\n\t * Removes all stored credentials as well as any settings associated with credentials encryption.\n\t */\n\tasync clearCredentials(reason: Error | string): Promise<void> {\n\t\tconsole.warn(\"clearing all stored credentials:\", reason)\n\t\tawait this.credentialsFacade.clear()\n\t}\n}\n\nexport function usingKeychainAuthenticationWithOptions(): boolean {\n\treturn !isBrowser() && !isAdminClient()\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAaa,sBAAN,MAA0B;CAChC,YACkBA,mBACAC,oBACAC,wBAChB;EA6GF,KAhHkB;EAgHjB,KA/GiB;EA+GhB,KA9GgB;CACd;;;;CAKJ,MAAM,MAAMC,aAAoD;AAC/D,SAAO,KAAK,kBAAkB,MAAM,YAAY;CAChD;;;;CAKD,MAAM,gBAAgBC,aAA8BC,mBAA2BC,wBAAmD;EACjI,MAAM,uBAAuB,MAAM,KAAK,uBAAuB,YAAY,OAAO;AAClF,MAAI,wBAAwB,KAC3B,OAAM,IAAI,OAAO,gFAAgF,YAAY,OAAO;EAGrH,MAAMC,0BAAgD;GACrD,GAAG;GACH;GACA;EACA;AACD,QAAM,KAAK,kBAAkB,eAAe,wBAAwB;CACpE;CAED,MAAM,2BAA2BC,QAA6C;AAC7E,UAAQ,MAAM,KAAK,uBAAuB,OAAO,GAAG,kBAAkB;CACtE;CAED,MAAM,4BAAsE;AAC3E,SAAO,KAAK,kBAAkB,SAAS;CACvC;CAED,MAAc,uBAAuBA,QAAkD;EACtF,MAAM,iBAAiB,MAAM,KAAK,kBAAkB,SAAS;AAC7D,SAAO,eAAe,KAAK,CAAC,eAAe,WAAW,eAAe,WAAW,OAAO,IAAI;CAC3F;;;;;CAMD,MAAM,gCAAgCA,QAAoD;AACzF,SAAO,KAAK,kBAAkB,aAAa,OAAO;CAClD;;;;;CAMD,MAAM,8BAAuE;EAC5E,MAAM,iBAAiB,MAAM,KAAK,kBAAkB,SAAS;AAC7D,SAAO,eACL,OAAO,CAAC,eAAe,WAAW,eAAe,SAAS,eAAe,SAAS,CAClF,IAAI,CAAC,eAAe,WAAW,eAAe,CAC9C,KAAK,CAAC,GAAG,MAAM,EAAE,MAAM,cAAc,EAAE,MAAM,CAAC;CAChD;;;;;;CAOD,MAAM,eAAeA,QAAYC,OAAqC,EAAE,iBAAiB,KAAM,GAAiB;AAC/G,QAAM,KAAK,wBAAwB,yBAAyB,OAAO;AACnE,MAAI,KAAK,gBACR,OAAM,KAAK,oBAAoB,SAAS,OAAO;AAEhD,QAAM,KAAK,kBAAkB,eAAe,OAAO;CACnD;;;;;;;CAQD,MAAM,4BAA4BC,gBAAyD;AAC1F,QAAM,KAAK,kBAAkB,4BAA4B,eAAe;AACxE,OAAK,wBAAwB,oBAAoB;CACjD;;;;CAKD,8BAAwE;AACvE,SAAO,KAAK,kBAAkB,6BAA6B;CAC3D;;;;CAKD,MAAM,8BAAgF;AACrF,SAAO,MAAM,KAAK,kBAAkB,6BAA6B;CACjE;;;;CAKD,MAAM,iBAAiBC,QAAuC;AAC7D,UAAQ,KAAK,oCAAoC,OAAO;AACxD,QAAM,KAAK,kBAAkB,OAAO;CACpC;AACD;AAEM,SAAS,yCAAkD;AACjE,SAAQ,WAAW,KAAK,eAAe;AACvC"}