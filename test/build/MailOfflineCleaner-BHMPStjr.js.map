{"version":3,"file":"MailOfflineCleaner-BHMPStjr.js","names":["offlineStorage: OfflineStorage","timeRangeDays: number | null","userId: Id","now: number","listId: Id","cutoffId: Id","mailsToDelete: IdTuple[]","attachmentsToDelete: IdTuple[]","mailDetailsBlobToDelete: IdTuple[]","mailDetailsDraftToDelete: IdTuple[]","listId","entriesListId: Id","cutoffTimestamp: number","mailSetEntriesToDelete: IdTuple[]"],"sources":["../../src/mail-app/workerUtils/offline/MailOfflineCleaner.ts"],"sourcesContent":["import { UserTypeRef } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { AccountType, OFFLINE_STORAGE_DEFAULT_TIME_RANGE_DAYS } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { assertNotNull, DAY_IN_MILLIS, groupByAndMap } from \"@tutao/tutanota-utils\"\nimport {\n\tconstructMailSetEntryId,\n\tDEFAULT_MAILSET_ENTRY_CUSTOM_CUTOFF_TIMESTAMP,\n\telementIdPart,\n\tfirstBiggerThanSecond,\n\tGENERATED_MAX_ID,\n\tgetElementId,\n\tlistIdPart,\n\ttimestampToGeneratedId,\n} from \"../../../common/api/common/utils/EntityUtils.js\"\nimport {\n\tFileTypeRef,\n\tMailBoxTypeRef,\n\tMailDetailsBlobTypeRef,\n\tMailDetailsDraftTypeRef,\n\tMailFolderTypeRef,\n\tMailSetEntryTypeRef,\n\tMailTypeRef,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { FolderSystem } from \"../../../common/api/common/mail/FolderSystem.js\"\nimport { OfflineStorage, OfflineStorageCleaner } from \"../../../common/api/worker/offline/OfflineStorage.js\"\nimport { isDraft, isSpamOrTrashFolder } from \"../../mail/model/MailChecks.js\"\n\nexport class MailOfflineCleaner implements OfflineStorageCleaner {\n\tasync cleanOfflineDb(offlineStorage: OfflineStorage, timeRangeDays: number | null, userId: Id, now: number): Promise<void> {\n\t\tconst user = await offlineStorage.get(UserTypeRef, null, userId)\n\n\t\t// Free users always have default time range regardless of what is stored\n\t\tconst isFreeUser = user?.accountType === AccountType.FREE\n\t\tconst timeRange = isFreeUser || timeRangeDays == null ? OFFLINE_STORAGE_DEFAULT_TIME_RANGE_DAYS : timeRangeDays\n\t\tconst daysSinceDayAfterEpoch = now / DAY_IN_MILLIS - 1\n\t\tconst timeRangeMillisSafe = Math.min(daysSinceDayAfterEpoch, timeRange) * DAY_IN_MILLIS\n\t\t// from May 15th 2109 onward, exceeding daysSinceDayAfterEpoch in the time range setting will\n\t\t// lead to an overflow in our 42 bit timestamp in the id.\n\t\tconst cutoffTimestamp = now - timeRangeMillisSafe\n\n\t\tconst mailBoxes = await offlineStorage.getElementsOfType(MailBoxTypeRef)\n\t\tconst cutoffId = timestampToGeneratedId(cutoffTimestamp)\n\t\tfor (const mailBox of mailBoxes) {\n\t\t\tconst isMailsetMigrated = mailBox.currentMailBag != null\n\t\t\tconst folders = await offlineStorage.getWholeList(MailFolderTypeRef, mailBox.folders!.folders)\n\t\t\tif (isMailsetMigrated) {\n\t\t\t\t// deleting mailsetentries first to make sure that once we start deleting mail\n\t\t\t\t// we don't have any entries that reference that mail\n\t\t\t\tconst folderSystem = new FolderSystem(folders)\n\t\t\t\tfor (const mailSet of folders) {\n\t\t\t\t\tif (isSpamOrTrashFolder(folderSystem, mailSet)) {\n\t\t\t\t\t\tawait this.deleteMailSetEntries(offlineStorage, mailSet.entries, DEFAULT_MAILSET_ENTRY_CUSTOM_CUTOFF_TIMESTAMP)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this.deleteMailSetEntries(offlineStorage, mailSet.entries, cutoffTimestamp)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst mailListIds = [mailBox.currentMailBag!, ...mailBox.archivedMailBags].map((mailbag) => mailbag.mails)\n\t\t\t\tfor (const mailListId of mailListIds) {\n\t\t\t\t\tawait this.deleteMailListLegacy(offlineStorage, mailListId, cutoffId)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst folderSystem = new FolderSystem(folders)\n\t\t\t\tfor (const folder of folders) {\n\t\t\t\t\tif (isSpamOrTrashFolder(folderSystem, folder)) {\n\t\t\t\t\t\tawait this.deleteMailListLegacy(offlineStorage, folder.mails, GENERATED_MAX_ID)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this.deleteMailListLegacy(offlineStorage, folder.mails, cutoffId)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This method deletes mails from {@param listId} what are older than {@param cutoffId} as well as associated data.\n\t *\n\t * it's considered legacy because once we start importing mail into mail bags, maintaining mail list ranges doesn't make\n\t * sense anymore - mail order in a list is arbitrary at that point.\n\t *\n\t * For each mail we delete the mail, its body, headers, all references mail set entries and all referenced attachments.\n\t *\n\t * When we delete the Files, we also delete the whole range for the user's File list. We need to delete the whole\n\t * range because we only have one file list per mailbox, so if we delete something from the middle of it, the range\n\t * will no longer be valid. (this is future proofing, because as of now there is not going to be a Range set for the\n\t * File list anyway, since we currently do not do range requests for Files.\n\t *\n\t * \tWe do not delete ConversationEntries because:\n\t * \t1. They are in the same list for the whole conversation so we can't adjust the range\n\t * \t2. We might need them in the future for showing the whole thread\n\t */\n\tprivate async deleteMailListLegacy(offlineStorage: OfflineStorage, listId: Id, cutoffId: Id): Promise<void> {\n\t\t// We lock access to the \"ranges\" db here in order to prevent race conditions when accessing the \"ranges\" database.\n\t\tawait offlineStorage.lockRangesDbAccess(listId)\n\t\ttry {\n\t\t\t// This must be done before deleting mails to know what the new range has to be\n\t\t\tawait offlineStorage.updateRangeForListAndDeleteObsoleteData(MailTypeRef, listId, cutoffId)\n\t\t} finally {\n\t\t\t// We unlock access to the \"ranges\" db here. We lock it in order to prevent race conditions when accessing the \"ranges\" database.\n\t\t\tawait offlineStorage.unlockRangesDbAccess(listId)\n\t\t}\n\n\t\tconst mailsToDelete: IdTuple[] = []\n\t\tconst attachmentsToDelete: IdTuple[] = []\n\t\tconst mailDetailsBlobToDelete: IdTuple[] = []\n\t\tconst mailDetailsDraftToDelete: IdTuple[] = []\n\n\t\tconst mails = await offlineStorage.getWholeList(MailTypeRef, listId)\n\t\tfor (let mail of mails) {\n\t\t\tif (firstBiggerThanSecond(cutoffId, getElementId(mail))) {\n\t\t\t\tmailsToDelete.push(mail._id)\n\t\t\t\tfor (const id of mail.attachments) {\n\t\t\t\t\tattachmentsToDelete.push(id)\n\t\t\t\t}\n\n\t\t\t\tif (isDraft(mail)) {\n\t\t\t\t\tconst mailDetailsId = assertNotNull(mail.mailDetailsDraft)\n\t\t\t\t\tmailDetailsDraftToDelete.push(mailDetailsId)\n\t\t\t\t} else {\n\t\t\t\t\t// mailDetailsBlob\n\t\t\t\t\tconst mailDetailsId = assertNotNull(mail.mailDetails)\n\t\t\t\t\tmailDetailsBlobToDelete.push(mailDetailsId)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let [listId, elementIds] of groupByAndMap(mailDetailsBlobToDelete, listIdPart, elementIdPart).entries()) {\n\t\t\tawait offlineStorage.deleteIn(MailDetailsBlobTypeRef, listId, elementIds)\n\t\t}\n\t\tfor (let [listId, elementIds] of groupByAndMap(mailDetailsDraftToDelete, listIdPart, elementIdPart).entries()) {\n\t\t\tawait offlineStorage.deleteIn(MailDetailsDraftTypeRef, listId, elementIds)\n\t\t}\n\t\tfor (let [listId, elementIds] of groupByAndMap(attachmentsToDelete, listIdPart, elementIdPart).entries()) {\n\t\t\tawait offlineStorage.deleteIn(FileTypeRef, listId, elementIds)\n\t\t\tawait offlineStorage.deleteRange(FileTypeRef, listId)\n\t\t}\n\n\t\tawait offlineStorage.deleteIn(MailTypeRef, listId, mailsToDelete.map(elementIdPart))\n\t}\n\n\t/**\n\t * delete all mail set entries of a mail set that reference some mail with a receivedDate older than\n\t * cutoffTimestamp. this doesn't clean up mails or their associated data because we could be breaking the\n\t * offline list range invariant by deleting data from the middle of a mail range. cleaning up mails is done\n\t * the legacy way currently even for mailset users.\n\t */\n\tprivate async deleteMailSetEntries(offlineStorage: OfflineStorage, entriesListId: Id, cutoffTimestamp: number) {\n\t\tconst cutoffId = constructMailSetEntryId(new Date(cutoffTimestamp), GENERATED_MAX_ID)\n\t\tawait offlineStorage.lockRangesDbAccess(entriesListId)\n\t\ttry {\n\t\t\tawait offlineStorage.updateRangeForListAndDeleteObsoleteData(MailSetEntryTypeRef, entriesListId, cutoffId)\n\t\t} finally {\n\t\t\t// We unlock access to the \"ranges\" db here. We lock it in order to prevent race conditions when accessing the \"ranges\" database.\n\t\t\tawait offlineStorage.unlockRangesDbAccess(entriesListId)\n\t\t}\n\n\t\tconst mailSetEntriesToDelete: IdTuple[] = []\n\t\tconst mailSetEntries = await offlineStorage.getWholeList(MailSetEntryTypeRef, entriesListId)\n\t\tfor (let mailSetEntry of mailSetEntries) {\n\t\t\tif (firstBiggerThanSecond(cutoffId, getElementId(mailSetEntry))) {\n\t\t\t\tmailSetEntriesToDelete.push(mailSetEntry._id)\n\t\t\t}\n\t\t}\n\t\tawait offlineStorage.deleteIn(MailSetEntryTypeRef, entriesListId, mailSetEntriesToDelete.map(elementIdPart))\n\t}\n}\n"],"mappings":"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"}