{"version":3,"file":"PerWindowSqlCipherFacade-BbbZxclZ.js","names":["refCounter: OfflineDbRefCounter","userId: string","dbKey: Uint8Array","query: string","params: ReadonlyArray<TaggedSqlValue>","listId: Id"],"sources":["../../src/common/desktop/db/PerWindowSqlCipherFacade.ts"],"sourcesContent":["import { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { TaggedSqlValue } from \"../../api/worker/offline/SqlValue.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\nimport { log } from \"../DesktopLog.js\"\nimport { OfflineDbClosedError } from \"../../api/common/error/OfflineDbClosedError.js\"\nimport { OfflineDbRefCounter } from \"./OfflineDbRefCounter.js\"\n\nconst TAG = \"[PerWindowSqlCipherFacade]\"\n\nexport interface OfflineDbFactory {\n\tcreate(userid: string, key: Uint8Array, retry?: boolean): Promise<SqlCipherFacade>\n\n\tdelete(userId: string): Promise<void>\n}\n\n/** class that holds the offlinedb reference for a single window. does not get recreated after logout.\n *\n * this works closely with the OfflineDbReferenceCounter to make sure that there's only one database connection\n * open for a given userId / database file.\n *\n * to ensure database integrity, there's also the locking of list ranges, which must be released before\n * dereferencing the database connection.\n * since the reference counter currently has no way of associating locks or references with windows,\n * this association is tracked in this class.\n *  */\nexport class PerWindowSqlCipherFacade implements SqlCipherFacade {\n\t/**\n\t * information about our db reference: which user it belongs to, the db itself, the currently held locks.\n\t * if this is not present, we hold no locks, are not waiting on locks and hold no db reference.\n\t * */\n\tprivate state: {\n\t\tuserId: string\n\t\tdb: Promise<SqlCipherFacade>\n\t\t/** the list of listIdRange locks that this window currently holds or is trying to acquire */\n\t\tlocks: Set<string>\n\t} | null = null\n\n\tconstructor(private readonly refCounter: OfflineDbRefCounter) {}\n\n\tasync openDb(userId: string, dbKey: Uint8Array): Promise<void> {\n\t\tlog.debug(TAG, \"open db for\", userId)\n\t\tif (this.state != null) {\n\t\t\tif (this.state.userId != userId) {\n\t\t\t\tthrow new ProgrammingError(`Already opened database for user ${this.state.userId} when trying to open db for ${userId}!`)\n\t\t\t} else {\n\t\t\t\tconsole.warn(`trying to open already opened db for ${userId}!`)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tthis.state = {\n\t\t\tuserId,\n\t\t\tdb: this.refCounter.getOrCreateDb(userId, dbKey),\n\t\t\tlocks: new Set(),\n\t\t}\n\t}\n\n\tasync closeDb(): Promise<void> {\n\t\tlog.debug(TAG, \"close db for\", this.state?.userId)\n\t\tif (this.state == null) return\n\n\t\t// if this method is called, we certainly don't want anything\n\t\t// to do anymore with this db connection.\n\t\t// so set the state to null before actually calling disposeDb()\n\t\t// otherwise, an error might prevent us from resetting the state.\n\t\tconst { userId, locks } = this.state\n\t\tthis.state = null\n\t\t// we can just unlock the locks now because there will not be coming any writes anymore\n\t\tfor (const lockedList of locks) {\n\t\t\tconsole.log(TAG, \"unlocking list before dereffing db\", lockedList)\n\t\t\tawait this.refCounter.unlockRangesDbAccess(userId, lockedList)\n\t\t}\n\t\ttry {\n\t\t\tawait this.refCounter.disposeDb(userId)\n\t\t} catch (e) {\n\t\t\t// we may or may not have released our reference, we'll just hope for the best.\n\t\t\tlog.debug(`failed to dispose offline Db for user ${userId}`, e)\n\t\t}\n\t}\n\n\tasync deleteDb(userId: string): Promise<void> {\n\t\tawait this.refCounter.deleteDb(userId)\n\t}\n\n\tasync get(query: string, params: ReadonlyArray<TaggedSqlValue>): Promise<Record<string, TaggedSqlValue> | null> {\n\t\treturn (await this.db()).get(query, params)\n\t}\n\n\tasync all(query: string, params: ReadonlyArray<TaggedSqlValue>): Promise<ReadonlyArray<Record<string, TaggedSqlValue>>> {\n\t\treturn (await this.db()).all(query, params)\n\t}\n\n\tasync run(query: string, params: ReadonlyArray<TaggedSqlValue>): Promise<void> {\n\t\treturn (await this.db()).run(query, params)\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" db when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId)\n\t * @param listId the mail list that we want to lock\n\t */\n\tasync lockRangesDbAccess(listId: Id): Promise<void> {\n\t\tif (this.state == null) return\n\t\tconst { userId, locks } = this.state\n\t\tif (locks.has(listId)) {\n\t\t\tconsole.log(TAG, \"tried to acquire lock twice!\")\n\t\t\treturn\n\t\t}\n\t\t/*\n\t\t * it's possible that we're waiting for a lock and then the window gets closed or reloads due to logout,\n\t\t * causing us to release our DB ref.\n\t\t * if the lock is then released by whoever holds it, we would acquire it but never release it.\n\t\t */\n\t\tawait this.refCounter.lockRangesDbAccess(userId, listId)\n\t\tlocks.add(listId)\n\t\tif (this.state == null) {\n\t\t\tconsole.log(TAG, \"ref was released while we were waiting for lock, unlocking.\")\n\t\t\tawait this.refCounter.unlockRangesDbAccess(userId, listId)\n\t\t\tlocks.delete(listId)\n\t\t}\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(listId)\"\n\t * @param listId the mail list that we want to unlock\n\t */\n\tasync unlockRangesDbAccess(listId: Id): Promise<void> {\n\t\tif (this.state == null) return\n\t\tconst { userId, locks } = this.state\n\t\tif (!locks.has(listId)) {\n\t\t\tconsole.log(TAG, \"tried to release lock that was not acquired!\")\n\t\t\treturn\n\t\t}\n\t\tlocks.delete(listId)\n\t\tawait this.refCounter.unlockRangesDbAccess(userId, listId)\n\t}\n\n\tprivate async db(): Promise<SqlCipherFacade> {\n\t\tif (this.state == null) {\n\t\t\tthrow new OfflineDbClosedError()\n\t\t}\n\t\treturn await this.state.db\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,MAAM,MAAM;IAkBC,2BAAN,MAA0D;;;;;CAKhE,AAAQ,QAKG;CAEX,YAA6BA,YAAiC;EA0G9D,KA1G6B;CAAmC;CAEhE,MAAM,OAAOC,QAAgBC,OAAkC;AAC9D,MAAI,MAAM,KAAK,eAAe,OAAO;AACrC,MAAI,KAAK,SAAS,KACjB,KAAI,KAAK,MAAM,UAAU,OACxB,OAAM,IAAI,kBAAkB,mCAAmC,KAAK,MAAM,OAAO,8BAA8B,OAAO;KAChH;AACN,WAAQ,MAAM,uCAAuC,OAAO,GAAG;AAC/D;EACA;AAEF,OAAK,QAAQ;GACZ;GACA,IAAI,KAAK,WAAW,cAAc,QAAQ,MAAM;GAChD,OAAO,IAAI;EACX;CACD;CAED,MAAM,UAAyB;AAC9B,MAAI,MAAM,KAAK,gBAAgB,KAAK,OAAO,OAAO;AAClD,MAAI,KAAK,SAAS,KAAM;EAMxB,MAAM,EAAE,QAAQ,OAAO,GAAG,KAAK;AAC/B,OAAK,QAAQ;AAEb,OAAK,MAAM,cAAc,OAAO;AAC/B,WAAQ,IAAI,KAAK,sCAAsC,WAAW;AAClE,SAAM,KAAK,WAAW,qBAAqB,QAAQ,WAAW;EAC9D;AACD,MAAI;AACH,SAAM,KAAK,WAAW,UAAU,OAAO;EACvC,SAAQ,GAAG;AAEX,OAAI,OAAO,wCAAwC,OAAO,GAAG,EAAE;EAC/D;CACD;CAED,MAAM,SAASD,QAA+B;AAC7C,QAAM,KAAK,WAAW,SAAS,OAAO;CACtC;CAED,MAAM,IAAIE,OAAeC,QAAuF;AAC/G,SAAO,CAAC,MAAM,KAAK,IAAI,EAAE,IAAI,OAAO,OAAO;CAC3C;CAED,MAAM,IAAID,OAAeC,QAA+F;AACvH,SAAO,CAAC,MAAM,KAAK,IAAI,EAAE,IAAI,OAAO,OAAO;CAC3C;CAED,MAAM,IAAID,OAAeC,QAAsD;AAC9E,SAAO,CAAC,MAAM,KAAK,IAAI,EAAE,IAAI,OAAO,OAAO;CAC3C;;;;;;CAOD,MAAM,mBAAmBC,QAA2B;AACnD,MAAI,KAAK,SAAS,KAAM;EACxB,MAAM,EAAE,QAAQ,OAAO,GAAG,KAAK;AAC/B,MAAI,MAAM,IAAI,OAAO,EAAE;AACtB,WAAQ,IAAI,KAAK,+BAA+B;AAChD;EACA;AAMD,QAAM,KAAK,WAAW,mBAAmB,QAAQ,OAAO;AACxD,QAAM,IAAI,OAAO;AACjB,MAAI,KAAK,SAAS,MAAM;AACvB,WAAQ,IAAI,KAAK,8DAA8D;AAC/E,SAAM,KAAK,WAAW,qBAAqB,QAAQ,OAAO;AAC1D,SAAM,OAAO,OAAO;EACpB;CACD;;;;;CAMD,MAAM,qBAAqBA,QAA2B;AACrD,MAAI,KAAK,SAAS,KAAM;EACxB,MAAM,EAAE,QAAQ,OAAO,GAAG,KAAK;AAC/B,OAAK,MAAM,IAAI,OAAO,EAAE;AACvB,WAAQ,IAAI,KAAK,+CAA+C;AAChE;EACA;AACD,QAAM,OAAO,OAAO;AACpB,QAAM,KAAK,WAAW,qBAAqB,QAAQ,OAAO;CAC1D;CAED,MAAc,KAA+B;AAC5C,MAAI,KAAK,SAAS,KACjB,OAAM,IAAI;AAEX,SAAO,MAAM,KAAK,MAAM;CACxB;AACD"}