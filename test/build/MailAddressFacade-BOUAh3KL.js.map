{"version":3,"file":"MailAddressFacade-BOUAh3KL.js","names":["userFacade: UserFacade","groupManagement: GroupManagementFacade","serviceExecutor: IServiceExecutor","nonCachingEntityClient: EntityClient","userGroupId: Id","mailAddress: string","mailAddresses: string[]","targetGroupId: Id","alias: string","restore: boolean","mailGroupId: Id","viaUser?: Id","senderName: string","viaUser: Id","version: number","mailboxProperties: MailboxProperties","userId: Id","groupId: Id","mailboxGroupRoot: MailboxGroupRoot","groupKey: VersionedKey"],"sources":["../../src/common/api/worker/facades/lazy/MailAddressFacade.ts"],"sourcesContent":["import type { GroupInfo, MailAddressAliasServiceReturn, MailAddressAvailability } from \"../../../entities/sys/TypeRefs.js\"\nimport {\n\tcreateDomainMailAddressAvailabilityData,\n\tcreateMailAddressAliasGetIn,\n\tcreateMailAddressAliasServiceData,\n\tcreateMailAddressAliasServiceDataDelete,\n\tcreateMultipleMailAddressAvailabilityData,\n\tcreateStringWrapper,\n\tGroupInfoTypeRef,\n\tGroupTypeRef,\n\tUserTypeRef,\n} from \"../../../entities/sys/TypeRefs.js\"\nimport { DomainMailAddressAvailabilityService, MailAddressAliasService, MultipleMailAddressAvailabilityService } from \"../../../entities/sys/Services.js\"\nimport { assertWorkerOrNode } from \"../../../common/Env.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { UserFacade } from \"../UserFacade.js\"\nimport { EntityClient } from \"../../../common/EntityClient.js\"\nimport {\n\tcreateMailAddressProperties,\n\tcreateMailboxProperties,\n\tMailboxGroupRoot,\n\tMailboxGroupRootTypeRef,\n\tMailboxProperties,\n\tMailboxPropertiesTypeRef,\n} from \"../../../entities/tutanota/TypeRefs.js\"\nimport { assertNotNull, findAndRemove, getFirstOrThrow, ofClass } from \"@tutao/tutanota-utils\"\nimport { getEnabledMailAddressesForGroupInfo } from \"../../../common/utils/GroupUtils.js\"\nimport { PreconditionFailedError } from \"../../../common/error/RestError.js\"\nimport { ProgrammingError } from \"../../../common/error/ProgrammingError.js\"\nimport { GroupManagementFacade } from \"./GroupManagementFacade.js\"\n\nimport { VersionedKey } from \"../../crypto/CryptoWrapper.js\"\n\nassertWorkerOrNode()\n\nexport class MailAddressFacade {\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly groupManagement: GroupManagementFacade,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly nonCachingEntityClient: EntityClient,\n\t) {}\n\n\t/**\n\t * For legacy accounts the given userGroupId is ignored since the alias counters are for the customer\n\t */\n\tgetAliasCounters(userGroupId: Id): Promise<MailAddressAliasServiceReturn> {\n\t\tconst data = createMailAddressAliasGetIn({ targetGroup: userGroupId })\n\t\treturn this.serviceExecutor.get(MailAddressAliasService, data)\n\t}\n\n\tisMailAddressAvailable(mailAddress: string): Promise<boolean> {\n\t\tif (this.userFacade.isFullyLoggedIn()) {\n\t\t\tconst data = createDomainMailAddressAvailabilityData({ mailAddress })\n\t\t\treturn this.serviceExecutor.get(DomainMailAddressAvailabilityService, data).then((result) => result.available)\n\t\t} else {\n\t\t\treturn this.areMailAddressesAvailable([mailAddress]).then((result) => getFirstOrThrow(result).available)\n\t\t}\n\t}\n\n\tasync areMailAddressesAvailable(mailAddresses: string[]): Promise<MailAddressAvailability[]> {\n\t\tconst data = createMultipleMailAddressAvailabilityData({\n\t\t\tmailAddresses: mailAddresses.map((mailAddress) => createStringWrapper({ value: mailAddress })),\n\t\t})\n\t\tconst result = await this.serviceExecutor.get(MultipleMailAddressAvailabilityService, data)\n\t\treturn result.availabilities\n\t}\n\n\t/**\n\t * Add an {@param alias} to {@param targetGroupId}.\n\t * {@param targetGroupId} is *not* a Mail group, it is currently only a user group.\n\t *\n\t * Can only be done by an admin.\n\t */\n\tasync addMailAlias(targetGroupId: Id, alias: string): Promise<void> {\n\t\tconst data = createMailAddressAliasServiceData({\n\t\t\tgroup: targetGroupId,\n\t\t\tmailAddress: alias,\n\t\t})\n\t\tawait this.serviceExecutor.post(MailAddressAliasService, data)\n\t}\n\n\t/**\n\t * Enable/disable an {@param alias} on {@param targetGroupId}.\n\t * {@param targetGroupId} is *not* a Mail group, it is currently only a user group.\n\t *\n\t * {@param restore} means whether the alias will be enabled or disabled.\n\t *\n\t * Can only be done by an admin.\n\t */\n\tasync setMailAliasStatus(targetGroupId: Id, alias: string, restore: boolean): Promise<void> {\n\t\tconst deleteData = createMailAddressAliasServiceDataDelete({\n\t\t\tmailAddress: alias,\n\t\t\trestore,\n\t\t\tgroup: targetGroupId,\n\t\t})\n\t\tawait this.serviceExecutor.delete(MailAddressAliasService, deleteData)\n\t}\n\n\t/**\n\t * Get mailAddress to senderName mappings for mail group that the specified user is a member of.\n\t * if no user is given, the operation is attempted as an admin of the given group.\n\t * */\n\tasync getSenderNames(mailGroupId: Id, viaUser?: Id): Promise<Map<string, string>> {\n\t\tconst mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser)\n\t\treturn this.collectSenderNames(mailboxProperties)\n\t}\n\n\t/**\n\t * Set mailAddress to senderName mapping for mail group that the specified user is a member of.\n\t * if no user is specified, the operation will be attempted as an admin of the given group.\n\t * */\n\tasync setSenderName(mailGroupId: Id, mailAddress: string, senderName: string, viaUser?: Id): Promise<Map<string, string>> {\n\t\tconst mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser)\n\t\tlet mailAddressProperty = mailboxProperties.mailAddressProperties.find((p) => p.mailAddress === mailAddress)\n\t\tif (mailAddressProperty == null) {\n\t\t\tmailAddressProperty = createMailAddressProperties({\n\t\t\t\tmailAddress,\n\t\t\t\tsenderName: \"\",\n\t\t\t})\n\t\t\tmailboxProperties.mailAddressProperties.push(mailAddressProperty)\n\t\t}\n\t\tmailAddressProperty.senderName = senderName\n\t\tconst updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser)\n\t\treturn this.collectSenderNames(updatedProperties)\n\t}\n\n\t/**\n\t * remove the sender name of the given mail address.\n\t * If no user is given, the operation will be attempted as an admin of the group.\n\t */\n\tasync removeSenderName(mailGroupId: Id, mailAddress: string, viaUser: Id): Promise<Map<string, string>> {\n\t\tconst mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser)\n\t\tfindAndRemove(mailboxProperties.mailAddressProperties, (p) => p.mailAddress === mailAddress)\n\t\tconst updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser)\n\t\treturn this.collectSenderNames(updatedProperties)\n\t}\n\n\tprivate async getOrCreateMailboxProperties(mailGroupId: Id, viaUser?: Id): Promise<MailboxProperties> {\n\t\t// Using non-caching entityClient because we are not a member of the user's mail group, and we won't receive updates for it\n\t\tconst mailboxGroupRoot = await this.nonCachingEntityClient.load(MailboxGroupRootTypeRef, mailGroupId)\n\n\t\tif (mailboxGroupRoot.mailboxProperties == null) {\n\t\t\tconst currentGroupKey = viaUser\n\t\t\t\t? await this.groupManagement.getCurrentGroupKeyViaUser(mailGroupId, viaUser)\n\t\t\t\t: await this.groupManagement.getCurrentGroupKeyViaAdminEncGKey(mailGroupId)\n\t\t\tmailboxGroupRoot.mailboxProperties = await this.createMailboxProperties(mailboxGroupRoot, currentGroupKey)\n\t\t}\n\n\t\tconst groupKeyProvider = async (version: number) =>\n\t\t\tviaUser\n\t\t\t\t? await this.groupManagement.getGroupKeyViaUser(mailGroupId, version, viaUser)\n\t\t\t\t: await this.groupManagement.getGroupKeyViaAdminEncGKey(mailGroupId, version)\n\t\tconst mailboxProperties = await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxGroupRoot.mailboxProperties, {\n\t\t\townerKeyProvider: groupKeyProvider,\n\t\t})\n\n\t\treturn mailboxProperties.mailAddressProperties.length === 0 ? this.mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) : mailboxProperties\n\t}\n\n\t/**\n\t * set the legacy sender name (groupInfo.name) of the group on all assigned mail addresses.\n\t * if no user is given, the operation will be attempted as an admin of the group of the given mailboxProperties.\n\t * */\n\tprivate async mailboxPropertiesWithLegacySenderName(mailboxProperties: MailboxProperties, viaUser?: Id): Promise<MailboxProperties> {\n\t\tconst groupInfo = viaUser ? await this.loadUserGroupInfo(viaUser) : await this.loadMailGroupInfo(mailboxProperties._ownerGroup!)\n\t\tconst legacySenderName = groupInfo.name\n\t\tconst mailAddresses = getEnabledMailAddressesForGroupInfo(groupInfo)\n\t\tfor (const mailAddress of mailAddresses) {\n\t\t\tmailboxProperties.mailAddressProperties.push(\n\t\t\t\tcreateMailAddressProperties({\n\t\t\t\t\tmailAddress,\n\t\t\t\t\tsenderName: legacySenderName,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t\treturn this.updateMailboxProperties(mailboxProperties, viaUser)\n\t}\n\n\tprivate async loadUserGroupInfo(userId: Id): Promise<GroupInfo> {\n\t\tconst user = await this.nonCachingEntityClient.load(UserTypeRef, userId)\n\t\treturn await this.nonCachingEntityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo)\n\t}\n\n\tprivate async loadMailGroupInfo(groupId: Id): Promise<GroupInfo> {\n\t\tconst group = await this.nonCachingEntityClient.load(GroupTypeRef, groupId)\n\t\treturn await this.nonCachingEntityClient.load(GroupInfoTypeRef, group.groupInfo)\n\t}\n\n\tprivate async createMailboxProperties(mailboxGroupRoot: MailboxGroupRoot, groupKey: VersionedKey): Promise<Id> {\n\t\tconst _ownerGroup = mailboxGroupRoot._ownerGroup\n\t\tconst mailboxProperties = createMailboxProperties({\n\t\t\t...(_ownerGroup != null ? { _ownerGroup } : null), // only set it if it is not null\n\t\t\treportMovedMails: \"\",\n\t\t\tmailAddressProperties: [],\n\t\t})\n\t\t// Using non-caching entityClient because we are not a member of the user's mail group and we won't receive updates for it\n\t\treturn this.nonCachingEntityClient.setup(null, mailboxProperties, undefined, { ownerKey: groupKey }).catch(\n\t\t\tofClass(PreconditionFailedError, (e) => {\n\t\t\t\t// in admin case it is much harder to run into it because we use non-caching entityClient but it is still possible\n\t\t\t\tif (e.data && e.data.startsWith(\"exists:\")) {\n\t\t\t\t\tconst existingId = e.data.substring(\"exists:\".length)\n\t\t\t\t\tconsole.log(\"mailboxProperties already exists\", existingId)\n\t\t\t\t\treturn existingId\n\t\t\t\t} else {\n\t\t\t\t\tthrow new ProgrammingError(`Could not create mailboxProperties, precondition: ${e.data}`)\n\t\t\t\t}\n\t\t\t}),\n\t\t)\n\t}\n\n\tprivate async updateMailboxProperties(mailboxProperties: MailboxProperties, viaUser?: Id): Promise<MailboxProperties> {\n\t\tconst groupKeyProvider = async (version: number) =>\n\t\t\tviaUser\n\t\t\t\t? await this.groupManagement.getGroupKeyViaUser(assertNotNull(mailboxProperties._ownerGroup), version, viaUser)\n\t\t\t\t: await this.groupManagement.getGroupKeyViaAdminEncGKey(assertNotNull(mailboxProperties._ownerGroup), version)\n\t\tawait this.nonCachingEntityClient.update(mailboxProperties, { ownerKeyProvider: groupKeyProvider })\n\t\treturn await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxProperties._id, { ownerKeyProvider: groupKeyProvider })\n\t}\n\n\tprivate async collectSenderNames(mailboxProperties: MailboxProperties): Promise<Map<string, string>> {\n\t\tconst result = new Map<string, string>()\n\t\tfor (const data of mailboxProperties.mailAddressProperties) {\n\t\t\tresult.set(data.mailAddress, data.senderName)\n\t\t}\n\t\treturn result\n\t}\n}\n"],"mappings":"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"}