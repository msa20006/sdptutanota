{"version":3,"file":"IndexUtils-K27esrGs.js","names":["row: Uint8Array","cb: (block: Uint8Array, start: number, end: number, iteration: number) => void","ranges: Array<[number, number]>","source: Uint8Array[]","destination?: Uint8Array","target: Uint8Array","entityData: Uint8Array","offset: number","value: number","source: Uint8Array","data: Uint8Array[]","numbers: Array<number>","number: number","binaryNumbers: Uint8Array","numbers: number[]","key: Aes256Key","indexKey: string","dbIv: Uint8Array","encIndexKey: Uint8Array","entry: SearchIndexEntry","encryptedInstanceId: Uint8Array","entry: EncryptedSearchIndexEntry","metaData: SearchIndexMetaDataRow","encryptedMeta: SearchIndexMetaDataDbRow","rows: SearchIndexMetadataEntry[]","tutanotaTypeModels","model: TypeModel","typeRef: TypeRef<any>","user: User","typeInfo: TypeInfo","html: string | null","entry: Uint8Array","left: SearchIndexMetadataEntry","right: SearchIndexMetadataEntry","prefix: string","names: string[]","name: string"],"sources":["../../src/common/api/worker/search/SearchIndexEncoding.ts","../../src/common/api/worker/search/IndexUtils.ts"],"sourcesContent":["/**\n * @fileoverview SearchIndexEncoding: binary encoding for certain search index columns\n *\n * <b>Purpose</b>\n *\n * We use it primarily because storing data in many tiny {@code Uint8Array}'s is very inefficient,\n * mostly GC wise. Not only many objects create GC pressure by themselves, but they also consume\n * much more memory because each element has a lot of pointers.\n * Besides that, this encoding can encode certain thing with very little space. E.g. let's say\n * you want to encode object like {@code {app: 1, type: 10234}}. You could convert it to JSON,\n * then convert to to binary and then save it. EcmaScript strings use 2 bytes per character.\n * That means that JSON \"{app:1,type:10234}\" (18 chars) would use 18*2=36 bytes.\n * With this binary encoding we would encode it as just two numbers, first one in one byte,\n * second one we would use three bytes (one for length of the number and two for the\n * actual number, more on format below) so in total 1+3=4 bytes.\n *\n * <b>Format</b>\n *\n * We encode two types of data: numbers and binary blocks.\n * For numbers we use the following encoding:\n * - If the number fits into 7 bits (smaller than 127), then the first byte represents the number\n * - If it doesn't fit, then the highest bit of the byte is set. The rest of the bits signify\n * the number of following bytes which encode the number.\n *\n * Example:\n * <pre>\n * number | bytes\n * ––––––––––––––––\n * 3      | [0000 0011]\n * 127    | [0111 1111]\n * 128    | [1000 0001] [1000 0000]\n * 10234  | [1000 0002] [0010 0111][1111 1010]\n * </pre>\n *\n * For binary blocks we use similar principle. First we encode length of the binary data\n * in the number format described above (as number of used bytes). After that we write binary data.\n * <pre>[length of first block][binary block] [length of second block] [binary block] ... [length of n block][binary block]</pre>\n *\n * Example:\n * <pre>\n * Storing 2 bytes [0xFF, 0xFF]\n *\n * length of binary data | data\n * -------------------------------------------------------------------\n * [0000 0010]             [0xFF, 0xFF]\n *\n * Storing 500 bytes [0xFF, 0xFF,.., 0xFF]\n *\n * length of length | length of binary data | data\n * -------------------------------------------------------------------\n * [1000 0010]       [0000 0001] [1111 0100] [0xFF, 0xFF,.., 0xFF]\n * </pre>\n *\n * <b>Interface</b>\n * In many functions we pass offset instead of passing a subarray. We do this to allocate less objects\n * ({@code Uint8Array}'s are quite expensive).\n */\n\n/**\n * Invoke {@param cb} for each binary block in a {@param row}.\n * Callback parameters:\n * block: found block (without length prefix, only actual data)\n * start: start of the total block, including prefix\n * end: end of the block (this index is not included in the data)\n * iteration: number of the current block.\n * @returns {number} Total number of found blocks\n */\nexport function iterateBinaryBlocks(row: Uint8Array, cb: (block: Uint8Array, start: number, end: number, iteration: number) => void): number {\n\tlet offset = 0\n\tlet iterations = 0\n\n\twhile (offset < row.length) {\n\t\tconst block = decodeBinaryBlock(row, offset)\n\t\tconst start = offset\n\t\toffset = block.byteOffset + block.length\n\t\tcb(block, start, offset, iterations++)\n\t}\n\n\treturn iterations\n}\n\n/**\n * Remove specified {@param ranges} from the {@param row}.\n * In each range start is included, end is excluded (like in {@link iterateBinaryBlocks}.\n * Ranges should be ordered in ascending order and non-overlapping.\n * It is intended to be used with {@link iterateBinaryBlocks}.\n * @returns {Uint8Array} row with ranges removes and length reduced\n */\nexport function removeBinaryBlockRanges(row: Uint8Array, ranges: Array<[number, number]>): Uint8Array {\n\tlet reducedLength = 0\n\n\tfor (let i = ranges.length - 1; i >= 0; i--) {\n\t\tconst [start, end] = ranges[i]\n\t\trow.copyWithin(start, end)\n\t\treducedLength += end - start\n\t}\n\n\treturn row.subarray(0, row.length - reducedLength)\n}\n\n/**\n * Encode all blocks from {@param source} and append into the {@param destination} (if present) or\n * into a new buffer.\n * @returns {Uint8Array} Resulting buffer\n */\nexport function appendBinaryBlocks(source: Uint8Array[], destination?: Uint8Array): Uint8Array {\n\tconst neededSpace = calculateNeededSpace(source)\n\tlet target: Uint8Array\n\tlet offset\n\n\tif (destination) {\n\t\toffset = destination.length\n\t\ttarget = new Uint8Array(destination.length + neededSpace)\n\t\t// Copy from destination to target\n\t\ttarget.set(destination)\n\t} else {\n\t\ttarget = new Uint8Array(neededSpace)\n\t\toffset = 0\n\t}\n\n\tfor (let i = 0; i < source.length; i++) {\n\t\toffset += encodeBinaryBlock(source[i], target, offset)\n\t}\n\n\treturn target\n}\n\n/**\n * Encode (length and data itself) and write {@param entityData} into {@param target} at specified {@param offset}.\n * target must have enough space to fit encoded data (incl. length prefix). {@see calculateNeededSpace}.\n * @returns {number} New offset after the written block\n */\nexport function encodeBinaryBlock(entityData: Uint8Array, target: Uint8Array, offset: number): number {\n\t// Encode length as number (either as one byte or as length of length and length itself)\n\tconst lengthOfPrefix = encodeNumberBlock(entityData.length, target, offset)\n\ttarget.set(entityData, offset + lengthOfPrefix)\n\treturn lengthOfPrefix + entityData.length\n}\n\n/**\n * Encode number either in compact format (single byte) or in multiple bytes (length of number &\n * number itself). Maximum number which fits is 2^127 (it's large).\n * Target should have enough space {@see calculateNeededSpaceForNumber}.\n * @param value the number to encode\n * @param target where to put encoded number\n * @param offset where to put encoded number\n * @returns {number} offset after the encoded number\n */\nexport function encodeNumberBlock(value: number, target: Uint8Array, offset: number): number {\n\t// If value is less than 127 (7 bits), just write it as is\n\tif (value <= 0x7f) {\n\t\ttarget[offset] = value\n\t\treturn 1\n\t} else {\n\t\t// If number doesn't fit into seven bits, then first write it's length into this 7 bits\n\t\t// and then the number itself.\n\t\t// How many bytes we need to store the number\n\t\tconst length = numberOfBytes(value)\n\t\tlet remainingValue = value\n\t\t// Set highest bit to 1\n\t\ttarget[offset] = length | 0x80\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst bytePosition = offset + length - i\n\n\t\t\t// If what's left doesn't fit into this byte, split it\n\t\t\tif (remainingValue > 0xff) {\n\t\t\t\t// like shifting right by 8 but without overflows\n\t\t\t\ttarget[bytePosition] = remainingValue % 256\n\t\t\t\tremainingValue = Math.floor(remainingValue / 256)\n\t\t\t} else {\n\t\t\t\t// if it does fit, write it\n\t\t\t\ttarget[bytePosition] = remainingValue\n\t\t\t}\n\t\t}\n\n\t\t// One bit for length\n\t\treturn length + 1\n\t}\n}\n\n/**\n * Read end decode binary block. Returned block shares buffer with {@param source}.\n * @param source Where to read data from\n * @param offset At which offset to read data from\n * @returns {Uint8Array} Decoded data (without length prefix)\n */\nexport function decodeBinaryBlock(source: Uint8Array, offset: number): Uint8Array {\n\tlet blockLength = decodeNumberBlock(source, offset)\n\tlet numberLength = calculateNeededSpaceForNumber(blockLength)\n\treturn source.subarray(offset + numberLength, offset + numberLength + blockLength)\n}\n\n/**\n * Read and decode number block. We don't return the length of the encoded number to\n * not allocate anything. Check {@code source[0]} or use\n * {@link calculateNeededSpaceForNumber}.\n * @param source Where to read number from\n * @param offset At which offset to read number\n * @returns {number} Decoded number\n */\nexport function decodeNumberBlock(source: Uint8Array, offset: number): number {\n\t// Check the first bit. If it's 1, it's a long number, if it's not it's\n\t// a short one.\n\tconst markerBit = source[offset] & 0x80\n\n\tif (markerBit === 0x80) {\n\t\t// Clear the first bit to get the length of number\n\t\tconst numberLength = source[offset] & 0x7f\n\t\tlet value = 0\n\n\t\tfor (let i = 0; i < numberLength; i++) {\n\t\t\t// Like shifting left but without overflows\n\t\t\tvalue = value * 256\n\t\t\tvalue += source[offset + i + 1]\n\t\t}\n\n\t\treturn value\n\t} else {\n\t\t// Just return the number\n\t\treturn source[offset]\n\t}\n}\n\n/**\n * Precalculate how much space do we need to write encoded blocks of {@param data}.\n * @returns {number} Number of bytes which we need to write encoded data.\n */\nexport function calculateNeededSpace(data: Uint8Array[]): number {\n\treturn data.reduce((acc, entry) => {\n\t\t// Prefix is just a length of data in bytes (in short or a long form)\n\t\tlet lengthOfPrefix = calculateNeededSpaceForNumber(entry.length)\n\t\treturn acc + entry.length + lengthOfPrefix\n\t}, 0)\n}\n\n/**\n * Find out how many bytes do we need to encode {@param value}\n */\nexport function calculateNeededSpaceForNumber(value: number): number {\n\t// If it's small, it fits into one byte\n\t// otherwise it's number of bytes to represent the number plus length\n\treturn value <= 0x7f ? 1 : numberOfBytes(value) + 1\n}\n\nexport function calculateNeededSpaceForNumbers(numbers: Array<number>): number {\n\treturn numbers.reduce((acc, n) => acc + calculateNeededSpaceForNumber(n), 0)\n}\n\n/**\n * Number of bytes needed to encode the number\n */\nexport function numberOfBytes(number: number): number {\n\treturn Math.ceil(Math.log2(number + 1) / 8)\n}\n\n/**\n * Read array of encoded numbers. Assumes that they're in the end of the {@param binaryNumbers}!\n * @param binaryNumbers Block with numbers encoded\n * @param offset At which offset to read numbers\n * @returns {Array<number>} Numbers which have been read\n */\nexport function decodeNumbers(binaryNumbers: Uint8Array, offset: number = 0): number[] {\n\tconst numbers: number[] = []\n\n\twhile (offset < binaryNumbers.length) {\n\t\tconst number = decodeNumberBlock(binaryNumbers, offset)\n\t\tnumbers.push(number)\n\t\toffset += calculateNeededSpaceForNumber(number)\n\t}\n\n\treturn numbers\n}\n\n/**\n * Encode array of numbers. Doesn't write how many numbers there are.\n * @param numbers Numbers to encode\n * @param target Where to write them\n * @param offset At which offset they should be written\n */\nexport function encodeNumbers(numbers: number[], target: Uint8Array, offset: number = 0): void {\n\tfor (const number of numbers) {\n\t\toffset += encodeNumberBlock(number, target, offset)\n\t}\n}\n","import { Base64, concat, stringToUtf8Uint8Array, TypeRef, uint8ArrayToBase64, utf8Uint8ArrayToString } from \"@tutao/tutanota-utils\"\nimport type {\n\tDecryptedSearchIndexEntry,\n\tEncryptedSearchIndexEntry,\n\tIndexUpdate,\n\tSearchIndexEntry,\n\tSearchIndexMetaDataDbRow,\n\tSearchIndexMetadataEntry,\n\tSearchIndexMetaDataRow,\n} from \"./SearchTypes\"\nimport { GroupType } from \"../../common/TutanotaConstants\"\nimport { calculateNeededSpaceForNumber, calculateNeededSpaceForNumbers, decodeNumberBlock, decodeNumbers, encodeNumbers } from \"./SearchIndexEncoding\"\nimport { typeModels as tutanotaTypeModels } from \"../../entities/tutanota/TypeModels\"\nimport type { GroupMembership, User } from \"../../entities/sys/TypeRefs.js\"\nimport type { TypeModel } from \"../../common/EntityTypes\"\nimport { isTest } from \"../../common/Env\"\nimport { aes256EncryptSearchIndexEntry, Aes256Key, unauthenticatedAesDecrypt } from \"@tutao/tutanota-crypto\"\n\nexport function encryptIndexKeyBase64(key: Aes256Key, indexKey: string, dbIv: Uint8Array): Base64 {\n\treturn uint8ArrayToBase64(encryptIndexKeyUint8Array(key, indexKey, dbIv))\n}\n\nexport function encryptIndexKeyUint8Array(key: Aes256Key, indexKey: string, dbIv: Uint8Array): Uint8Array {\n\treturn aes256EncryptSearchIndexEntry(key, stringToUtf8Uint8Array(indexKey), dbIv, true).slice(dbIv.length)\n}\n\nexport function decryptIndexKey(key: Aes256Key, encIndexKey: Uint8Array, dbIv: Uint8Array): string {\n\treturn utf8Uint8ArrayToString(unauthenticatedAesDecrypt(key, concat(dbIv, encIndexKey), true))\n}\n\nexport function encryptSearchIndexEntry(key: Aes256Key, entry: SearchIndexEntry, encryptedInstanceId: Uint8Array): EncryptedSearchIndexEntry {\n\tlet searchIndexEntryNumberValues = [entry.attribute].concat(entry.positions)\n\tconst neededSpace = calculateNeededSpaceForNumbers(searchIndexEntryNumberValues)\n\tconst block = new Uint8Array(neededSpace)\n\tencodeNumbers(searchIndexEntryNumberValues, block, 0)\n\tconst encData = aes256EncryptSearchIndexEntry(key, block)\n\tconst resultArray = new Uint8Array(encryptedInstanceId.length + encData.length)\n\tresultArray.set(encryptedInstanceId)\n\tresultArray.set(encData, 16)\n\treturn resultArray\n}\n\nexport function decryptSearchIndexEntry(key: Aes256Key, entry: EncryptedSearchIndexEntry, dbIv: Uint8Array): DecryptedSearchIndexEntry {\n\tconst encId = getIdFromEncSearchIndexEntry(entry)\n\tlet id = decryptIndexKey(key, encId, dbIv)\n\tconst data = unauthenticatedAesDecrypt(key, entry.subarray(16), true)\n\tlet offset = 0\n\tconst attribute = decodeNumberBlock(data, offset)\n\toffset += calculateNeededSpaceForNumber(attribute)\n\tconst positions = decodeNumbers(data, offset)\n\treturn {\n\t\tid: id,\n\t\tencId,\n\t\tattribute,\n\t\tpositions,\n\t}\n}\n\nconst metaEntryFieldsNumber = 5\n\nexport function encryptMetaData(key: Aes256Key, metaData: SearchIndexMetaDataRow): SearchIndexMetaDataDbRow {\n\tconst numbers = new Array(metaData.rows.length * metaEntryFieldsNumber)\n\n\tfor (let i = 0; i < metaData.rows.length; i++) {\n\t\tconst entry = metaData.rows[i]\n\t\tconst offset = i * metaEntryFieldsNumber\n\t\tnumbers[offset] = entry.app\n\t\tnumbers[offset + 1] = entry.type\n\t\tnumbers[offset + 2] = entry.key\n\t\tnumbers[offset + 3] = entry.size\n\t\tnumbers[offset + 4] = entry.oldestElementTimestamp\n\t}\n\n\tconst numberBlock = new Uint8Array(calculateNeededSpaceForNumbers(numbers))\n\tencodeNumbers(numbers, numberBlock)\n\tconst encryptedRows = aes256EncryptSearchIndexEntry(key, numberBlock)\n\treturn {\n\t\tid: metaData.id,\n\t\tword: metaData.word,\n\t\trows: encryptedRows,\n\t}\n}\n\nexport function decryptMetaData(key: Aes256Key, encryptedMeta: SearchIndexMetaDataDbRow): SearchIndexMetaDataRow {\n\t// Initially we write empty data block there. In this case we can't get IV from it and decrypt it\n\tif (encryptedMeta.rows.length === 0) {\n\t\treturn {\n\t\t\tid: encryptedMeta.id,\n\t\t\tword: encryptedMeta.word,\n\t\t\trows: [],\n\t\t}\n\t}\n\n\tconst numbersBlock = unauthenticatedAesDecrypt(key, encryptedMeta.rows, true)\n\tconst numbers = decodeNumbers(numbersBlock)\n\tconst rows: SearchIndexMetadataEntry[] = []\n\n\tfor (let i = 0; i < numbers.length; i += metaEntryFieldsNumber) {\n\t\trows.push({\n\t\t\tapp: numbers[i],\n\t\t\ttype: numbers[i + 1],\n\t\t\tkey: numbers[i + 2],\n\t\t\tsize: numbers[i + 3],\n\t\t\toldestElementTimestamp: numbers[i + 4],\n\t\t})\n\t}\n\n\treturn {\n\t\tid: encryptedMeta.id,\n\t\tword: encryptedMeta.word,\n\t\trows,\n\t}\n}\n\nexport type TypeInfo = {\n\tappId: number\n\ttypeId: number\n\tattributeIds: number[]\n}\nconst typeInfos = {\n\ttutanota: {\n\t\tMail: {\n\t\t\tappId: 1,\n\t\t\ttypeId: tutanotaTypeModels.Mail.id,\n\t\t\tattributeIds: getAttributeIds(tutanotaTypeModels.Mail),\n\t\t},\n\t\tContact: {\n\t\t\tappId: 1,\n\t\t\ttypeId: tutanotaTypeModels.Contact.id,\n\t\t\tattributeIds: getAttributeIds(tutanotaTypeModels.Contact),\n\t\t},\n\t},\n}\n\nexport function getAttributeIds(model: TypeModel) {\n\treturn Object.keys(model.values)\n\t\t.map((name) => model.values[name].id)\n\t\t.concat(Object.keys(model.associations).map((name) => model.associations[name].id))\n}\n\nexport function typeRefToTypeInfo(typeRef: TypeRef<any>): TypeInfo {\n\t// @ts-ignore\n\tconst app = typeInfos[typeRef.app]\n\n\tif (!app) {\n\t\tthrow new Error(\"No TypeInfo for app: \" + app)\n\t}\n\n\tconst typeInfo = app[typeRef.type]\n\n\tif (!typeInfo) {\n\t\tthrow new Error(`No TypeInfo for TypeRef ${typeRef.app} : ${typeRef.type}`)\n\t}\n\n\treturn typeInfo\n}\n\nexport function userIsGlobalAdmin(user: User): boolean {\n\treturn user.memberships.some((m) => m.groupType === GroupType.Admin)\n}\n\nexport function filterIndexMemberships(user: User): GroupMembership[] {\n\treturn user.memberships.filter(\n\t\t(m) => m.groupType === GroupType.Mail || m.groupType === GroupType.Contact || m.groupType === GroupType.Customer || m.groupType === GroupType.Admin,\n\t)\n}\n\nexport function filterMailMemberships(user: User): GroupMembership[] {\n\treturn user.memberships.filter((m) => m.groupType === GroupType.Mail)\n}\n\nexport function _createNewIndexUpdate(typeInfo: TypeInfo): IndexUpdate {\n\treturn {\n\t\ttypeInfo,\n\t\tcreate: {\n\t\t\tencInstanceIdToElementData: new Map(),\n\t\t\tindexMap: new Map(),\n\t\t},\n\t\tmove: [],\n\t\tdelete: {\n\t\t\tsearchMetaRowToEncInstanceIds: new Map(),\n\t\t\tencInstanceIds: [],\n\t\t},\n\t}\n}\n\nexport function htmlToText(html: string | null): string {\n\tif (html == null) return \"\"\n\tlet text = html.replace(/<[^>]*>?/gm, \" \")\n\treturn text.replace(/&[#0-9a-zA-Z]+;/g, (match) => {\n\t\tlet replacement\n\n\t\tif (match.startsWith(\"&#\")) {\n\t\t\tlet charCode = Number(match.substring(2, match.length - 1)) // remove &# and ;\n\n\t\t\tif (!isNaN(charCode)) {\n\t\t\t\treplacement = String.fromCharCode(charCode)\n\t\t\t}\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\treplacement = HTML_ENTITIES[match]\n\t\t}\n\n\t\treturn replacement ? replacement : match\n\t})\n}\n\nconst HTML_ENTITIES = {\n\t\"&nbsp;\": \" \",\n\t\"&amp;\": \"&\",\n\t\"&lt;\": \"<\",\n\t\"&gt;\": \">\",\n\t\"&Agrave;\": \"À\",\n\t\"&Aacute;\": \"Á\",\n\t\"&Acirc;\": \"Â\",\n\t\"&Atilde;\": \"Ã\",\n\t\"&Auml;\": \"Ä\",\n\t\"&Aring;\": \"Å\",\n\t\"&AElig;\": \"Æ\",\n\t\"&Ccedil;\": \"Ç\",\n\t\"&Egrave;\": \"È\",\n\t\"&Eacute;\": \"É\",\n\t\"&Ecirc;\": \"Ê\",\n\t\"&Euml;\": \"Ë\",\n\t\"&Igrave;\": \"Ì\",\n\t\"&Iacute;\": \"Í\",\n\t\"&Icirc;\": \"Î\",\n\t\"&Iuml;\": \"Ï\",\n\t\"&ETH;\": \"Ð\",\n\t\"&Ntilde;\": \"Ñ\",\n\t\"&Ograve;\": \"Ò\",\n\t\"&Oacute;\": \"Ó\",\n\t\"&Ocirc;\": \"Ô\",\n\t\"&Otilde;\": \"Õ\",\n\t\"&Ouml;\": \"Ö\",\n\t\"&Oslash;\": \"Ø\",\n\t\"&Ugrave;\": \"Ù\",\n\t\"&Uacute;\": \"Ú\",\n\t\"&Ucirc;\": \"Û\",\n\t\"&Uuml;\": \"Ü\",\n\t\"&Yacute;\": \"Ý\",\n\t\"&THORN;\": \"Þ\",\n\t\"&szlig;\": \"ß\",\n\t\"&agrave;\": \"à\",\n\t\"&aacute;\": \"á\",\n\t\"&acirc;\": \"â\",\n\t\"&atilde;\": \"ã\",\n\t\"&auml;\": \"ä\",\n\t\"&aring;\": \"å\",\n\t\"&aelig;\": \"æ\",\n\t\"&ccedil;\": \"ç\",\n\t\"&egrave;\": \"è\",\n\t\"&eacute;\": \"é\",\n\t\"&ecirc;\": \"ê\",\n\t\"&euml;\": \"ë\",\n\t\"&igrave;\": \"ì\",\n\t\"&iacute;\": \"í\",\n\t\"&icirc;\": \"î\",\n\t\"&iuml;\": \"ï\",\n\t\"&eth;\": \"ð\",\n\t\"&ntilde;\": \"ñ\",\n\t\"&ograve;\": \"ò\",\n\t\"&oacute;\": \"ó\",\n\t\"&ocirc;\": \"ô\",\n\t\"&otilde;\": \"õ\",\n\t\"&ouml;\": \"ö\",\n\t\"&oslash;\": \"ø\",\n\t\"&ugrave;\": \"ù\",\n\t\"&uacute;\": \"ú\",\n\t\"&ucirc;\": \"û\",\n\t\"&uuml;\": \"ü\",\n\t\"&yacute;\": \"ý\",\n\t\"&thorn;\": \"þ\",\n\t\"&yuml;\": \"ÿ\",\n\t\"&Alpha;\": \"Α\",\n\t\"&Beta;\": \"Β\",\n\t\"&Gamma;\": \"Γ\",\n\t\"&Delta;\": \"Δ\",\n\t\"&Epsilon;\": \"Ε\",\n\t\"&Zeta;\": \"Ζ\",\n\t\"&Eta;\": \"Η\",\n\t\"&Theta;\": \"Θ\",\n\t\"&Iota;\": \"Ι\",\n\t\"&Kappa;\": \"Κ\",\n\t\"&Lambda;\": \"Λ\",\n\t\"&Mu;\": \"Μ\",\n\t\"&Nu;\": \"Ν\",\n\t\"&Xi;\": \"Ξ\",\n\t\"&Omicron;\": \"Ο\",\n\t\"&Pi;\": \"Π\",\n\t\"&Rho;\": \"Ρ\",\n\t\"&Sigma;\": \"Σ\",\n\t\"&Tau;\": \"Τ\",\n\t\"&Upsilon;\": \"Υ\",\n\t\"&Phi;\": \"Φ\",\n\t\"&Chi;\": \"Χ\",\n\t\"&Psi;\": \"Ψ\",\n\t\"&Omega;\": \"Ω\",\n\t\"&alpha;\": \"α\",\n\t\"&beta;\": \"β\",\n\t\"&gamma;\": \"γ\",\n\t\"&delta;\": \"δ\",\n\t\"&epsilon;\": \"ε\",\n\t\"&zeta;\": \"ζ\",\n\t\"&eta;\": \"η\",\n\t\"&theta;\": \"θ\",\n\t\"&iota;\": \"ι\",\n\t\"&kappa;\": \"κ\",\n\t\"&lambda;\": \"λ\",\n\t\"&mu;\": \"μ\",\n\t\"&nu;\": \"ν\",\n\t\"&xi;\": \"ξ\",\n\t\"&omicron;\": \"ο\",\n\t\"&pi;\": \"π\",\n\t\"&rho;\": \"ρ\",\n\t\"&sigmaf;\": \"ς\",\n\t\"&sigma;\": \"σ\",\n\t\"&tau;\": \"τ\",\n\t\"&upsilon;\": \"υ\",\n\t\"&phi;\": \"φ\",\n\t\"&chi;\": \"χ\",\n\t\"&psi;\": \"ψ\",\n\t\"&omega;\": \"ω\",\n\t\"&thetasym;\": \"ϑ\",\n\t\"&upsih;\": \"ϒ\",\n\t\"&piv;\": \"ϖ\",\n}\n\nexport function getPerformanceTimestamp(): number {\n\treturn typeof performance === \"undefined\" ? Date.now() : performance.now() // performance is not available in Safari 10 worker scope\n}\n\nexport function getIdFromEncSearchIndexEntry(entry: Uint8Array): Uint8Array {\n\treturn entry.subarray(0, 16)\n}\n\nexport function compareMetaEntriesOldest(left: SearchIndexMetadataEntry, right: SearchIndexMetadataEntry): number {\n\treturn left.oldestElementTimestamp - right.oldestElementTimestamp\n}\n\nexport function printMeasure(prefix: string, names: string[]) {\n\tif (!shouldMeasure()) return\n\n\tfor (let name of names) {\n\t\ttry {\n\t\t\tperformance.clearMeasures(name)\n\t\t\tperformance.clearMarks(name + \"-end\")\n\t\t\tperformance.clearMarks(name + \"-start\")\n\t\t} catch (e) {\n\t\t\t/* empty */\n\t\t}\n\t}\n}\n\nexport function markStart(name: string) {\n\tif (shouldMeasure()) performance.mark(name + \"-start\")\n}\n\nexport function markEnd(name: string) {\n\tif (!shouldMeasure()) return\n\n\ttry {\n\t\tperformance.mark(name + \"-end\")\n\t\tperformance.measure(name, name + \"-start\", name + \"-end\")\n\t} catch (e) {\n\t\t/* empty */\n\t}\n}\n\nexport function shouldMeasure(): boolean {\n\treturn !env.dist && !isTest()\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEO,SAAS,oBAAoBA,KAAiBC,IAAwF;CAC5I,IAAI,SAAS;CACb,IAAI,aAAa;AAEjB,QAAO,SAAS,IAAI,QAAQ;EAC3B,MAAM,QAAQ,kBAAkB,KAAK,OAAO;EAC5C,MAAM,QAAQ;AACd,WAAS,MAAM,aAAa,MAAM;AAClC,KAAG,OAAO,OAAO,QAAQ,aAAa;CACtC;AAED,QAAO;AACP;AASM,SAAS,wBAAwBD,KAAiBE,QAA6C;CACrG,IAAI,gBAAgB;AAEpB,MAAK,IAAI,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;EAC5C,MAAM,CAAC,OAAO,IAAI,GAAG,OAAO;AAC5B,MAAI,WAAW,OAAO,IAAI;AAC1B,mBAAiB,MAAM;CACvB;AAED,QAAO,IAAI,SAAS,GAAG,IAAI,SAAS,cAAc;AAClD;AAOM,SAAS,mBAAmBC,QAAsBC,aAAsC;CAC9F,MAAM,cAAc,qBAAqB,OAAO;CAChD,IAAIC;CACJ,IAAI;AAEJ,KAAI,aAAa;AAChB,WAAS,YAAY;AACrB,WAAS,IAAI,WAAW,YAAY,SAAS;AAE7C,SAAO,IAAI,YAAY;CACvB,OAAM;AACN,WAAS,IAAI,WAAW;AACxB,WAAS;CACT;AAED,MAAK,IAAI,IAAI,GAAG,IAAI,OAAO,QAAQ,IAClC,WAAU,kBAAkB,OAAO,IAAI,QAAQ,OAAO;AAGvD,QAAO;AACP;AAOM,SAAS,kBAAkBC,YAAwBD,QAAoBE,QAAwB;CAErG,MAAM,iBAAiB,kBAAkB,WAAW,QAAQ,QAAQ,OAAO;AAC3E,QAAO,IAAI,YAAY,SAAS,eAAe;AAC/C,QAAO,iBAAiB,WAAW;AACnC;AAWM,SAAS,kBAAkBC,OAAeH,QAAoBE,QAAwB;AAE5F,KAAI,SAAS,KAAM;AAClB,SAAO,UAAU;AACjB,SAAO;CACP,OAAM;EAIN,MAAM,SAAS,cAAc,MAAM;EACnC,IAAI,iBAAiB;AAErB,SAAO,UAAU,SAAS;AAE1B,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;GAChC,MAAM,eAAe,SAAS,SAAS;AAGvC,OAAI,iBAAiB,KAAM;AAE1B,WAAO,gBAAgB,iBAAiB;AACxC,qBAAiB,KAAK,MAAM,iBAAiB,IAAI;GACjD,MAEA,QAAO,gBAAgB;EAExB;AAGD,SAAO,SAAS;CAChB;AACD;AAQM,SAAS,kBAAkBE,QAAoBF,QAA4B;CACjF,IAAI,cAAc,kBAAkB,QAAQ,OAAO;CACnD,IAAI,eAAe,8BAA8B,YAAY;AAC7D,QAAO,OAAO,SAAS,SAAS,cAAc,SAAS,eAAe,YAAY;AAClF;AAUM,SAAS,kBAAkBE,QAAoBF,QAAwB;CAG7E,MAAM,YAAY,OAAO,UAAU;AAEnC,KAAI,cAAc,KAAM;EAEvB,MAAM,eAAe,OAAO,UAAU;EACtC,IAAI,QAAQ;AAEZ,OAAK,IAAI,IAAI,GAAG,IAAI,cAAc,KAAK;AAEtC,WAAQ,QAAQ;AAChB,YAAS,OAAO,SAAS,IAAI;EAC7B;AAED,SAAO;CACP,MAEA,QAAO,OAAO;AAEf;AAMM,SAAS,qBAAqBG,MAA4B;AAChE,QAAO,KAAK,OAAO,CAAC,KAAK,UAAU;EAElC,IAAI,iBAAiB,8BAA8B,MAAM,OAAO;AAChE,SAAO,MAAM,MAAM,SAAS;CAC5B,GAAE,EAAE;AACL;AAKM,SAAS,8BAA8BF,OAAuB;AAGpE,QAAO,SAAS,MAAO,IAAI,cAAc,MAAM,GAAG;AAClD;AAEM,SAAS,+BAA+BG,SAAgC;AAC9E,QAAO,QAAQ,OAAO,CAAC,KAAK,MAAM,MAAM,8BAA8B,EAAE,EAAE,EAAE;AAC5E;AAKM,SAAS,cAAcC,QAAwB;AACrD,QAAO,KAAK,KAAK,KAAK,KAAK,SAAS,EAAE,GAAG,EAAE;AAC3C;AAQM,SAAS,cAAcC,eAA2BN,SAAiB,GAAa;CACtF,MAAMO,UAAoB,CAAE;AAE5B,QAAO,SAAS,cAAc,QAAQ;EACrC,MAAM,SAAS,kBAAkB,eAAe,OAAO;AACvD,UAAQ,KAAK,OAAO;AACpB,YAAU,8BAA8B,OAAO;CAC/C;AAED,QAAO;AACP;AAQM,SAAS,cAAcA,SAAmBT,QAAoBE,SAAiB,GAAS;AAC9F,MAAK,MAAM,UAAU,QACpB,WAAU,kBAAkB,QAAQ,QAAQ,OAAO;AAEpD;;;;AC1QM,SAAS,sBAAsBQ,KAAgBC,UAAkBC,MAA0B;AACjG,QAAO,mBAAmB,0BAA0B,KAAK,UAAU,KAAK,CAAC;AACzE;AAEM,SAAS,0BAA0BF,KAAgBC,UAAkBC,MAA8B;AACzG,QAAO,8BAA8B,KAAK,uBAAuB,SAAS,EAAE,MAAM,KAAK,CAAC,MAAM,KAAK,OAAO;AAC1G;AAEM,SAAS,gBAAgBF,KAAgBG,aAAyBD,MAA0B;AAClG,QAAO,uBAAuB,0BAA0B,KAAK,OAAO,MAAM,YAAY,EAAE,KAAK,CAAC;AAC9F;AAEM,SAAS,wBAAwBF,KAAgBI,OAAyBC,qBAA4D;CAC5I,IAAI,+BAA+B,CAAC,MAAM,SAAU,EAAC,OAAO,MAAM,UAAU;CAC5E,MAAM,cAAc,+BAA+B,6BAA6B;CAChF,MAAM,QAAQ,IAAI,WAAW;AAC7B,eAAc,8BAA8B,OAAO,EAAE;CACrD,MAAM,UAAU,8BAA8B,KAAK,MAAM;CACzD,MAAM,cAAc,IAAI,WAAW,oBAAoB,SAAS,QAAQ;AACxE,aAAY,IAAI,oBAAoB;AACpC,aAAY,IAAI,SAAS,GAAG;AAC5B,QAAO;AACP;AAEM,SAAS,wBAAwBL,KAAgBM,OAAkCJ,MAA6C;CACtI,MAAM,QAAQ,6BAA6B,MAAM;CACjD,IAAI,KAAK,gBAAgB,KAAK,OAAO,KAAK;CAC1C,MAAM,OAAO,0BAA0B,KAAK,MAAM,SAAS,GAAG,EAAE,KAAK;CACrE,IAAI,SAAS;CACb,MAAM,YAAY,kBAAkB,MAAM,OAAO;AACjD,WAAU,8BAA8B,UAAU;CAClD,MAAM,YAAY,cAAc,MAAM,OAAO;AAC7C,QAAO;EACF;EACJ;EACA;EACA;CACA;AACD;AAED,MAAM,wBAAwB;AAEvB,SAAS,gBAAgBF,KAAgBO,UAA4D;CAC3G,MAAM,UAAU,IAAI,MAAM,SAAS,KAAK,SAAS;AAEjD,MAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,QAAQ,KAAK;EAC9C,MAAM,QAAQ,SAAS,KAAK;EAC5B,MAAM,SAAS,IAAI;AACnB,UAAQ,UAAU,MAAM;AACxB,UAAQ,SAAS,KAAK,MAAM;AAC5B,UAAQ,SAAS,KAAK,MAAM;AAC5B,UAAQ,SAAS,KAAK,MAAM;AAC5B,UAAQ,SAAS,KAAK,MAAM;CAC5B;CAED,MAAM,cAAc,IAAI,WAAW,+BAA+B,QAAQ;AAC1E,eAAc,SAAS,YAAY;CACnC,MAAM,gBAAgB,8BAA8B,KAAK,YAAY;AACrE,QAAO;EACN,IAAI,SAAS;EACb,MAAM,SAAS;EACf,MAAM;CACN;AACD;AAEM,SAAS,gBAAgBP,KAAgBQ,eAAiE;AAEhH,KAAI,cAAc,KAAK,WAAW,EACjC,QAAO;EACN,IAAI,cAAc;EAClB,MAAM,cAAc;EACpB,MAAM,CAAE;CACR;CAGF,MAAM,eAAe,0BAA0B,KAAK,cAAc,MAAM,KAAK;CAC7E,MAAM,UAAU,cAAc,aAAa;CAC3C,MAAMC,OAAmC,CAAE;AAE3C,MAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK,sBACxC,MAAK,KAAK;EACT,KAAK,QAAQ;EACb,MAAM,QAAQ,IAAI;EAClB,KAAK,QAAQ,IAAI;EACjB,MAAM,QAAQ,IAAI;EAClB,wBAAwB,QAAQ,IAAI;CACpC,EAAC;AAGH,QAAO;EACN,IAAI,cAAc;EAClB,MAAM,cAAc;EACpB;CACA;AACD;AAOD,MAAM,YAAY,EACjB,UAAU;CACT,MAAM;EACL,OAAO;EACP,QAAQC,WAAmB,KAAK;EAChC,cAAc,gBAAgBA,WAAmB,KAAK;CACtD;CACD,SAAS;EACR,OAAO;EACP,QAAQA,WAAmB,QAAQ;EACnC,cAAc,gBAAgBA,WAAmB,QAAQ;CACzD;AACD,EACD;AAEM,SAAS,gBAAgBC,OAAkB;AACjD,QAAO,OAAO,KAAK,MAAM,OAAO,CAC9B,IAAI,CAAC,SAAS,MAAM,OAAO,MAAM,GAAG,CACpC,OAAO,OAAO,KAAK,MAAM,aAAa,CAAC,IAAI,CAAC,SAAS,MAAM,aAAa,MAAM,GAAG,CAAC;AACpF;AAEM,SAAS,kBAAkBC,SAAiC;CAElE,MAAM,MAAM,UAAU,QAAQ;AAE9B,MAAK,IACJ,OAAM,IAAI,MAAM,0BAA0B;CAG3C,MAAM,WAAW,IAAI,QAAQ;AAE7B,MAAK,SACJ,OAAM,IAAI,OAAO,0BAA0B,QAAQ,IAAI,KAAK,QAAQ,KAAK;AAG1E,QAAO;AACP;AAEM,SAAS,kBAAkBC,MAAqB;AACtD,QAAO,KAAK,YAAY,KAAK,CAAC,MAAM,EAAE,cAAc,UAAU,MAAM;AACpE;AAEM,SAAS,uBAAuBA,MAA+B;AACrE,QAAO,KAAK,YAAY,OACvB,CAAC,MAAM,EAAE,cAAc,UAAU,QAAQ,EAAE,cAAc,UAAU,WAAW,EAAE,cAAc,UAAU,YAAY,EAAE,cAAc,UAAU,MAC9I;AACD;AAEM,SAAS,sBAAsBA,MAA+B;AACpE,QAAO,KAAK,YAAY,OAAO,CAAC,MAAM,EAAE,cAAc,UAAU,KAAK;AACrE;AAEM,SAAS,sBAAsBC,UAAiC;AACtE,QAAO;EACN;EACA,QAAQ;GACP,4BAA4B,IAAI;GAChC,UAAU,IAAI;EACd;EACD,MAAM,CAAE;EACR,QAAQ;GACP,+BAA+B,IAAI;GACnC,gBAAgB,CAAE;EAClB;CACD;AACD;AAEM,SAAS,WAAWC,MAA6B;AACvD,KAAI,QAAQ,KAAM,QAAO;CACzB,IAAI,OAAO,KAAK,QAAQ,cAAc,IAAI;AAC1C,QAAO,KAAK,QAAQ,oBAAoB,CAAC,UAAU;EAClD,IAAI;AAEJ,MAAI,MAAM,WAAW,KAAK,EAAE;GAC3B,IAAI,WAAW,OAAO,MAAM,UAAU,GAAG,MAAM,SAAS,EAAE,CAAC;AAE3D,QAAK,MAAM,SAAS,CACnB,eAAc,OAAO,aAAa,SAAS;EAE5C,MAEA,eAAc,cAAc;AAG7B,SAAO,cAAc,cAAc;CACnC,EAAC;AACF;AAED,MAAM,gBAAgB;CACrB,UAAU;CACV,SAAS;CACT,QAAQ;CACR,QAAQ;CACR,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,YAAY;CACZ,UAAU;CACV,WAAW;CACX,WAAW;CACX,YAAY;CACZ,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,UAAU;CACV,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,UAAU;CACV,SAAS;CACT,YAAY;CACZ,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,YAAY;CACZ,UAAU;CACV,YAAY;CACZ,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,UAAU;CACV,YAAY;CACZ,WAAW;CACX,WAAW;CACX,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,YAAY;CACZ,UAAU;CACV,WAAW;CACX,WAAW;CACX,YAAY;CACZ,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,UAAU;CACV,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,UAAU;CACV,SAAS;CACT,YAAY;CACZ,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,YAAY;CACZ,UAAU;CACV,YAAY;CACZ,YAAY;CACZ,YAAY;CACZ,WAAW;CACX,UAAU;CACV,YAAY;CACZ,WAAW;CACX,UAAU;CACV,WAAW;CACX,UAAU;CACV,WAAW;CACX,WAAW;CACX,aAAa;CACb,UAAU;CACV,SAAS;CACT,WAAW;CACX,UAAU;CACV,WAAW;CACX,YAAY;CACZ,QAAQ;CACR,QAAQ;CACR,QAAQ;CACR,aAAa;CACb,QAAQ;CACR,SAAS;CACT,WAAW;CACX,SAAS;CACT,aAAa;CACb,SAAS;CACT,SAAS;CACT,SAAS;CACT,WAAW;CACX,WAAW;CACX,UAAU;CACV,WAAW;CACX,WAAW;CACX,aAAa;CACb,UAAU;CACV,SAAS;CACT,WAAW;CACX,UAAU;CACV,WAAW;CACX,YAAY;CACZ,QAAQ;CACR,QAAQ;CACR,QAAQ;CACR,aAAa;CACb,QAAQ;CACR,SAAS;CACT,YAAY;CACZ,WAAW;CACX,SAAS;CACT,aAAa;CACb,SAAS;CACT,SAAS;CACT,SAAS;CACT,WAAW;CACX,cAAc;CACd,WAAW;CACX,SAAS;AACT;AAEM,SAAS,0BAAkC;AACjD,eAAc,gBAAgB,cAAc,KAAK,KAAK,GAAG,YAAY,KAAK;AAC1E;AAEM,SAAS,6BAA6BC,OAA+B;AAC3E,QAAO,MAAM,SAAS,GAAG,GAAG;AAC5B;AAEM,SAAS,yBAAyBC,MAAgCC,OAAyC;AACjH,QAAO,KAAK,yBAAyB,MAAM;AAC3C;AAEM,SAAS,aAAaC,QAAgBC,OAAiB;AAC7D,MAAK,eAAe,CAAE;AAEtB,MAAK,IAAI,QAAQ,MAChB,KAAI;AACH,cAAY,cAAc,KAAK;AAC/B,cAAY,WAAW,OAAO,OAAO;AACrC,cAAY,WAAW,OAAO,SAAS;CACvC,SAAQ,GAAG,CAEX;AAEF;AAEM,SAAS,UAAUC,MAAc;AACvC,KAAI,eAAe,CAAE,aAAY,KAAK,OAAO,SAAS;AACtD;AAEM,SAAS,QAAQA,MAAc;AACrC,MAAK,eAAe,CAAE;AAEtB,KAAI;AACH,cAAY,KAAK,OAAO,OAAO;AAC/B,cAAY,QAAQ,MAAM,OAAO,UAAU,OAAO,OAAO;CACzD,SAAQ,GAAG,CAEX;AACD;AAEM,SAAS,gBAAyB;AACxC,SAAQ,IAAI,SAAS,QAAQ;AAC7B"}