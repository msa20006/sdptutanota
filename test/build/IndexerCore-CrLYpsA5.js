
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { PromisableWrapper, TypeRef, arrayHash, byteLength, defer, findLastIndex, getFromMap, groupByAndMap, lastThrow, mergeMaps, neverNull, noOp, promiseMapCompat, tokenize, uint8ArrayToBase64 } from "./dist-CJHwsXKY.js";
import { TutanotaError } from "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { elementIdPart, firstBiggerThanSecond, generatedIdToTimestamp, listIdPart } from "./EntityUtils-RQxXZlcV.js";
import { aes256EncryptSearchIndexEntry, unauthenticatedAesDecrypt } from "./dist-DcZ1Y4qd.js";
import { ElementDataOS, GroupDataOS, MetaDataOS, SearchIndexMetaDataOS, SearchIndexOS, SearchIndexWordsIndex } from "./IndexTables-C5S9WDY9.js";
import { appendBinaryBlocks, calculateNeededSpaceForNumbers, compareMetaEntriesOldest, decodeNumbers, decryptIndexKey, decryptMetaData, encodeNumbers, encryptIndexKeyBase64, encryptIndexKeyUint8Array, encryptMetaData, encryptSearchIndexEntry, getIdFromEncSearchIndexEntry, getPerformanceTimestamp, iterateBinaryBlocks, removeBinaryBlockRanges, typeRefToTypeInfo } from "./IndexUtils-K27esrGs.js";

//#region ../src/common/api/common/error/InvalidDatabaseStateError.ts
var InvalidDatabaseStateError = class extends TutanotaError {
	constructor(message) {
		super("InvalidDatabaseStateError", message);
	}
};

//#endregion
//#region ../src/mail-app/workerUtils/index/IndexerCore.ts
const SEARCH_INDEX_ROW_LENGTH = 1e3;
var IndexerCore = class {
	queue;
	db;
	_isStopped;
	_promiseMapCompat;
	_needsExplicitIds;
	_explicitIdStart;
	_currentWriteOperation = null;
	_stats;
	constructor(db, queue, browserData) {
		this.queue = queue;
		this.db = db;
		this._isStopped = false;
		this._promiseMapCompat = promiseMapCompat(browserData.needsMicrotaskHack);
		this._needsExplicitIds = browserData.needsExplicitIDBIds;
		this._explicitIdStart = Date.now();
		this.resetStats();
	}
	/****************************************** Preparing the update ***********************************************/
	/**
	* Converts an instances into a map from words to a list of SearchIndexEntries.
	*/
	createIndexEntriesForAttributes(instance, attributes) {
		let indexEntries = attributes.map((attributeHandler) => {
			if (typeof attributeHandler.value !== "function") throw new ProgrammingError("Value for attributeHandler is not a function: " + JSON.stringify(attributeHandler.attribute));
			let value = attributeHandler.value();
			let tokens = tokenize(value);
			this._stats.indexedBytes += byteLength(value);
			let attributeKeyToIndexMap = new Map();
			for (let index = 0; index < tokens.length; index++) {
				let token = tokens[index];
				if (!attributeKeyToIndexMap.has(token)) attributeKeyToIndexMap.set(token, {
					id: instance._id instanceof Array ? instance._id[1] : instance._id,
					attribute: attributeHandler.attribute.id,
					positions: [index]
				});
else neverNull(attributeKeyToIndexMap.get(token)).positions.push(index);
			}
			return attributeKeyToIndexMap;
		});
		return mergeMaps(indexEntries);
	}
	/**
	* Encrypt search index entries created by {@link createIndexEntriesForAttributes} and put them into the {@param indexUpdate}.
	* @param id of the instance
	* @param ownerGroup of the instance
	* @param keyToIndexEntries map from search index keys (words which you can search for) to index entries
	* @param indexUpdate IndexUpdate for which {@code create} fields will be populated
	*/
	encryptSearchIndexEntries(id, ownerGroup, keyToIndexEntries, indexUpdate) {
		const encryptionTimeStart = getPerformanceTimestamp();
		const listId = listIdPart(id);
		const encInstanceId = encryptIndexKeyUint8Array(this.db.key, elementIdPart(id), this.db.iv);
		const encInstanceIdB64 = uint8ArrayToBase64(encInstanceId);
		const elementIdTimestamp = generatedIdToTimestamp(elementIdPart(id));
		const encWordsB64 = [];
		for (const [indexKey, value] of keyToIndexEntries.entries()) {
			const encWordB64 = encryptIndexKeyBase64(this.db.key, indexKey, this.db.iv);
			encWordsB64.push(encWordB64);
			const encIndexEntries = getFromMap(indexUpdate.create.indexMap, encWordB64, () => []);
			for (const indexEntry of value) encIndexEntries.push({
				entry: encryptSearchIndexEntry(this.db.key, indexEntry, encInstanceId),
				timestamp: elementIdTimestamp
			});
		}
		indexUpdate.create.encInstanceIdToElementData.set(encInstanceIdB64, {
			listId,
			encWordsB64,
			ownerGroup
		});
		this._stats.encryptionTime += getPerformanceTimestamp() - encryptionTimeStart;
	}
	/**
	* Process delete event before applying to the index.
	*/
	async _processDeleted(event, indexUpdate) {
		const encInstanceIdPlain = encryptIndexKeyUint8Array(this.db.key, event.instanceId, this.db.iv);
		const encInstanceIdB64 = uint8ArrayToBase64(encInstanceIdPlain);
		const { appId, typeId } = typeRefToTypeInfo(new TypeRef(event.application, event.type));
		const transaction = await this.db.dbFacade.createTransaction(true, [ElementDataOS]);
		const elementData = await transaction.get(ElementDataOS, encInstanceIdB64);
		if (!elementData) return;
		const metaDataRowKeysBinary = unauthenticatedAesDecrypt(this.db.key, elementData[1], true);
		const metaDataRowKeys = decodeNumbers(metaDataRowKeysBinary);
		for (const metaDataRowKey of metaDataRowKeys) {
			const ids = getFromMap(indexUpdate.delete.searchMetaRowToEncInstanceIds, metaDataRowKey, () => []);
			ids.push({
				encInstanceId: encInstanceIdPlain,
				appId,
				typeId,
				timestamp: generatedIdToTimestamp(event.instanceId)
			});
		}
		indexUpdate.delete.encInstanceIds.push(encInstanceIdB64);
	}
	/********************************************* Manipulating the state ***********************************************/
	stopProcessing() {
		this._isStopped = true;
		this.queue.clear();
	}
	isStoppedProcessing() {
		return this._isStopped;
	}
	startProcessing() {
		this._isStopped = false;
	}
	addBatchesToQueue(batches) {
		if (!this._isStopped) this.queue.addBatches(batches);
	}
	/*********************************************** Writing index update ***********************************************/
	/**
	* Apply populated {@param indexUpdate} to the database.
	*/
	writeIndexUpdate(dataPerGroup, indexUpdate) {
		return this._writeIndexUpdate(indexUpdate, (t) => this._updateGroupDataIndexTimestamp(dataPerGroup, t));
	}
	writeIndexUpdateWithBatchId(groupId, batchId, indexUpdate) {
		return this._writeIndexUpdate(indexUpdate, (t) => this._updateGroupDataBatchId(groupId, batchId, t));
	}
	_writeIndexUpdate(indexUpdate, updateGroupData) {
		return this._executeOperation({
			transaction: null,
			transactionFactory: () => this.db.dbFacade.createTransaction(false, [
				SearchIndexOS,
				SearchIndexMetaDataOS,
				ElementDataOS,
				MetaDataOS,
				GroupDataOS
			]),
			operation: (transaction) => {
				let startTimeStorage = getPerformanceTimestamp();
				if (this._isStopped) return Promise.reject(new CancelledError("mail indexing cancelled"));
				return this._moveIndexedInstance(indexUpdate, transaction).thenOrApply(() => this._deleteIndexedInstance(indexUpdate, transaction)).thenOrApply(() => this._insertNewIndexEntries(indexUpdate, transaction)).thenOrApply((rowKeys) => rowKeys && this._insertNewElementData(indexUpdate, transaction, rowKeys)).thenOrApply(() => updateGroupData(transaction)).thenOrApply(() => {
					return transaction.wait().then(() => {
						this._stats.storageTime += getPerformanceTimestamp() - startTimeStorage;
					});
				}).thenOrApply(noOp, (e) => {
					try {
						if (!transaction.aborted) transaction.abort();
					} catch (e$1) {
						console.warn("abort has failed: ", e$1);
					}
					throw e;
				}).toPromise();
			},
			deferred: defer(),
			isAbortedForBackgroundMode: false
		});
	}
	_executeOperation(operation) {
		this._currentWriteOperation = operation;
		return operation.transactionFactory().then((transaction) => {
			operation.transaction = transaction;
			operation.operation(transaction).then((it) => {
				this._currentWriteOperation = null;
				operation.deferred.resolve();
				return it;
			}).catch((e) => {
				if (operation.isAbortedForBackgroundMode) console.log("transaction has been aborted because of background mode");
else {
					if (env.mode !== "Test") console.log("rejecting operation with error", e);
					operation.deferred.reject(e);
				}
			});
			return operation.deferred.promise;
		});
	}
	onVisibilityChanged(visible) {
		const operation = this._currentWriteOperation;
		if (!visible && operation && operation.transaction) {
			console.log("abort indexedDb transaction operation because background mode");
			try {
				neverNull(operation.transaction).abort();
			} catch (e) {
				console.log("Error when aborting on visibility change", e);
			}
			operation.isAbortedForBackgroundMode = true;
		}
		if (visible && operation) {
			console.log("restart indexedDb transaction operation after background mode");
			operation.isAbortedForBackgroundMode = false;
			this._executeOperation(operation);
		}
	}
	_moveIndexedInstance(indexUpdate, transaction) {
		this._cancelIfNeeded();
		if (indexUpdate.move.length === 0) return PromisableWrapper.from(undefined);
		const promise = Promise.all(indexUpdate.move.map((moveInstance) => {
			return transaction.get(ElementDataOS, moveInstance.encInstanceId).then((elementData) => {
				if (elementData) {
					elementData[0] = moveInstance.newListId;
					transaction.put(ElementDataOS, moveInstance.encInstanceId, elementData);
				}
			});
		})).then(noOp);
		return PromisableWrapper.from(promise);
	}
	/**
	* Apply "delete" updates to the database
	* @private
	*/
	_deleteIndexedInstance(indexUpdate, transaction) {
		this._cancelIfNeeded();
		if (indexUpdate.delete.searchMetaRowToEncInstanceIds.size === 0) return null;
		let deleteElementDataPromise = Promise.all(indexUpdate.delete.encInstanceIds.map((encInstanceId) => transaction.delete(ElementDataOS, encInstanceId)));
		return Promise.all(Array.from(indexUpdate.delete.searchMetaRowToEncInstanceIds).map(([metaRowKey, encInstanceIds]) => this._deleteSearchIndexEntries(transaction, metaRowKey, encInstanceIds))).then(() => deleteElementDataPromise).then(noOp);
	}
	/**
	* Remove all {@param instanceInfos} from the SearchIndex entries and metadata entreis specified by the {@param metaRowKey}.
	* @private
	*/
	_deleteSearchIndexEntries(transaction, metaRowKey, instanceInfos) {
		this._cancelIfNeeded();
		const encInstanceIdSet = new Set(instanceInfos.map((e) => arrayHash(e.encInstanceId)));
		return transaction.get(SearchIndexMetaDataOS, metaRowKey).then((encMetaDataRow) => {
			if (!encMetaDataRow) return;
			const metaDataRow = decryptMetaData(this.db.key, encMetaDataRow);
			const metaDataEntriesSet = new Set();
			for (const info of instanceInfos) {
				const entryIndex = this._findMetaDataEntryByTimestamp(metaDataRow, info.timestamp, info.appId, info.typeId);
				if (entryIndex === -1) console.warn("could not find MetaDataEntry, info:", info, "rows: ", metaDataRow.rows.map((r) => JSON.stringify(r)));
else metaDataEntriesSet.add(metaDataRow.rows[entryIndex]);
			}
			const updateSearchIndex = this._promiseMapCompat(Array.from(metaDataEntriesSet), (metaEntry) => {
				return transaction.get(SearchIndexOS, metaEntry.key).then((indexEntriesRow) => {
					if (!indexEntriesRow) return;
					const rangesToRemove = [];
					iterateBinaryBlocks(indexEntriesRow, (block, start, end) => {
						if (encInstanceIdSet.has(arrayHash(getIdFromEncSearchIndexEntry(block)))) rangesToRemove.push([start, end]);
					});
					if (rangesToRemove.length === 0) return;
else if (metaEntry.size === rangesToRemove.length) {
						metaEntry.size = 0;
						return transaction.delete(SearchIndexOS, metaEntry.key);
					} else {
						const trimmed = removeBinaryBlockRanges(indexEntriesRow, rangesToRemove);
						metaEntry.size -= rangesToRemove.length;
						return transaction.put(SearchIndexOS, metaEntry.key, trimmed);
					}
				});
			});
			return updateSearchIndex.thenOrApply(() => {
				metaDataRow.rows = metaDataRow.rows.filter((r) => r.size > 0);
				if (metaDataRow.rows.length === 0) return transaction.delete(SearchIndexMetaDataOS, metaDataRow.id);
else return transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(this.db.key, metaDataRow));
			}).value;
		});
	}
	_insertNewElementData(indexUpdate, transaction, encWordToMetaRow) {
		this._cancelIfNeeded();
		if (indexUpdate.create.encInstanceIdToElementData.size === 0) return null;
		let promises = [];
		for (const [b64EncInstanceId, elementDataSurrogate] of indexUpdate.create.encInstanceIdToElementData.entries()) {
			const metaRows = elementDataSurrogate.encWordsB64.map((w) => encWordToMetaRow[w]);
			const rowKeysBinary = new Uint8Array(calculateNeededSpaceForNumbers(metaRows));
			encodeNumbers(metaRows, rowKeysBinary);
			const encMetaRowKeys = aes256EncryptSearchIndexEntry(this.db.key, rowKeysBinary);
			promises.push(transaction.put(ElementDataOS, b64EncInstanceId, [
				elementDataSurrogate.listId,
				encMetaRowKeys,
				elementDataSurrogate.ownerGroup
			]));
		}
		return Promise.all(promises);
	}
	_insertNewIndexEntries(indexUpdate, transaction) {
		this._cancelIfNeeded();
		let keys = [...indexUpdate.create.indexMap.keys()];
		const encWordToMetaRow = {};
		const result = this._promiseMapCompat(keys, (encWordB64) => {
			const encryptedEntries = neverNull(indexUpdate.create.indexMap.get(encWordB64));
			return this._putEncryptedEntity(indexUpdate.typeInfo.appId, indexUpdate.typeInfo.typeId, transaction, encWordB64, encWordToMetaRow, encryptedEntries);
		}, { concurrency: 2 }).value;
		return result instanceof Promise ? result.then(() => encWordToMetaRow) : null;
	}
	_putEncryptedEntity(appId, typeId, transaction, encWordB64, encWordToMetaRow, encryptedEntries) {
		this._cancelIfNeeded();
		if (encryptedEntries.length <= 0) return null;
		return this._getOrCreateSearchIndexMeta(transaction, encWordB64).then((metaData) => {
			encryptedEntries.sort((a, b) => a.timestamp - b.timestamp);
			const writeResult = this._writeEntries(transaction, encryptedEntries, metaData, appId, typeId);
			return writeResult.thenOrApply(() => metaData).value;
		}).then((metaData) => {
			const columnSize = metaData.rows.reduce((result, metaDataEntry) => result + metaDataEntry.size, 0);
			this._stats.writeRequests += 1;
			this._stats.largestColumn = columnSize > this._stats.largestColumn ? columnSize : this._stats.largestColumn;
			this._stats.storedBytes += encryptedEntries.reduce((sum, e) => sum + e.entry.length, 0);
			encWordToMetaRow[encWordB64] = metaData.id;
			return transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(this.db.key, metaData));
		});
	}
	/**
	* Insert {@param entries} into the database for the corresponding {@param metaData}.
	* Metadata entries for each type are sorted from oldest to newest. Each metadata entry has oldest element timestamp. Timestamps of newer entries make a
	* time border for the newest. Timestamp for entry is considered fixed (unless it's the first entry).
	* The strategy is following:
	* First, try to find matching row by the oldest id of the entries we want to insert.
	* If we've found one, put everything that matches time frame of this row into it (it's bounded by the next row, if present). Put the rest into newer
	* rows.
	* If we didn't find one, we may try to extend the oldest row, because it's not bounded by the other row.
	* When we append something to the row, we check if its size would exceed {@link SEARCH_INDEX_ROW_LENGTH}. If it is, we do splitting,
	* {@see _appendIndexEntriesToRow}.
	* @private
	*/
	_writeEntries(transaction, entries, metaData, appId, typeId) {
		if (entries.length === 0) return PromisableWrapper.from(undefined);
		const oldestTimestamp = entries[0].timestamp;
		const indexOfMetaEntry = this._findMetaDataEntryByTimestamp(metaData, oldestTimestamp, appId, typeId);
		if (indexOfMetaEntry !== -1) {
			const nextEntry = this._nextEntryOfType(metaData, indexOfMetaEntry + 1, appId, typeId);
			if (!nextEntry) return this._appendIndexEntriesToRow(transaction, metaData, indexOfMetaEntry, entries);
else {
				const [toCurrentOne, toNextOnes] = this._splitByTimestamp(entries, nextEntry.oldestElementTimestamp);
				return this._appendIndexEntriesToRow(transaction, metaData, indexOfMetaEntry, toCurrentOne).thenOrApply(() => this._writeEntries(transaction, toNextOnes, metaData, appId, typeId));
			}
		} else {
			const firstEntry = this._nextEntryOfType(metaData, 0, appId, typeId);
			if (firstEntry) {
				const indexOfFirstEntry = metaData.rows.indexOf(firstEntry);
				const secondEntry = this._nextEntryOfType(metaData, indexOfFirstEntry + 1, appId, typeId);
				const [toFirstOne, toNextOnes] = secondEntry ? this._splitByTimestamp(entries, secondEntry.oldestElementTimestamp) : [entries, []];
				if (firstEntry.size + toFirstOne.length < SEARCH_INDEX_ROW_LENGTH) return this._appendIndexEntriesToRow(transaction, metaData, indexOfFirstEntry, toFirstOne).thenOrApply(() => this._writeEntries(transaction, toNextOnes, metaData, appId, typeId));
else {
					const [toNewOne, toCurrentOne] = this._splitByTimestamp(toFirstOne, firstEntry.oldestElementTimestamp);
					return PromisableWrapper.from(this._createNewRow(transaction, metaData, toNewOne, oldestTimestamp, appId, typeId)).thenOrApply(() => this._writeEntries(transaction, toCurrentOne.concat(toNextOnes), metaData, appId, typeId));
				}
			} else return this._createNewRow(transaction, metaData, entries, oldestTimestamp, appId, typeId);
		}
	}
	_nextEntryOfType(metaData, startIndex, appId, typeId) {
		for (let i = startIndex; i < metaData.rows.length; i++) if (metaData.rows[i].app === appId && metaData.rows[i].type === typeId) return metaData.rows[i];
		return null;
	}
	/**
	* Split {@param entries} (must be sorted!) into two arrays: before and after the timestamp.
	* @private
	*/
	_splitByTimestamp(entries, timestamp) {
		const indexOfSplit = entries.findIndex((entry) => entry.timestamp >= timestamp);
		if (indexOfSplit === -1) return [entries, []];
		const below = entries.slice(0, indexOfSplit);
		const above = entries.slice(indexOfSplit);
		return [below, above];
	}
	/**
	* Append {@param entries} to the row specified by the {@param metaEntryIndex}. If the row size exceeds {@link SEARCH_INDEX_ROW_LENGTH}, then
	* split it into two rows.
	* @private
	*/
	_appendIndexEntriesToRow(transaction, metaData, metaEntryIndex, entries) {
		if (entries.length === 0) return new PromisableWrapper(undefined);
		const metaEntry = metaData.rows[metaEntryIndex];
		if (metaEntry.size + entries.length > SEARCH_INDEX_ROW_LENGTH) return PromisableWrapper.from(transaction.get(SearchIndexOS, metaEntry.key).then((binaryBlock) => {
			if (!binaryBlock) throw new InvalidDatabaseStateError("non existing index row");
			const timestampToEntries = new Map();
			const existingIds = new Set();
			iterateBinaryBlocks(binaryBlock, (encSearchIndexEntry) => {
				const encId = getIdFromEncSearchIndexEntry(encSearchIndexEntry);
				existingIds.add(arrayHash(encId));
				const decId = decryptIndexKey(this.db.key, encId, this.db.iv);
				const timeStamp = generatedIdToTimestamp(decId);
				getFromMap(timestampToEntries, timeStamp, () => []).push(encSearchIndexEntry);
			});
			for (const { entry, timestamp } of entries) getFromMap(timestampToEntries, timestamp, () => []).push(entry);
			const isLastEntry = this._nextEntryOfType(metaData, metaEntryIndex + 1, metaEntry.app, metaEntry.type) == null;
			const rows = this._distributeEntities(timestampToEntries, isLastEntry);
			const [appendRow, newRows] = [rows[0], rows.slice(1)];
			const firstRowBinary = appendBinaryBlocks(appendRow.row);
			const requestPromises = [transaction.put(SearchIndexOS, metaEntry.key, firstRowBinary).then(() => {
				metaEntry.size = appendRow.row.length;
				metaEntry.oldestElementTimestamp = appendRow.oldestElementTimestamp;
				return metaEntry.key;
			}), this._promiseMapCompat(newRows, (row) => {
				const binaryRow = appendBinaryBlocks(row.row);
				return transaction.put(SearchIndexOS, null, binaryRow).then((newSearchIndexRowId) => {
					metaData.rows.push({
						key: newSearchIndexRowId,
						size: row.row.length,
						app: metaEntry.app,
						type: metaEntry.type,
						oldestElementTimestamp: row.oldestElementTimestamp
					});
				});
			}, { concurrency: 2 }).value];
			return Promise.all(requestPromises).then(() => {
				metaData.rows.sort(compareMetaEntriesOldest);
			});
		}));
else return PromisableWrapper.from(transaction.get(SearchIndexOS, metaEntry.key).then((indexEntriesRow) => {
			let safeRow = indexEntriesRow || new Uint8Array(0);
			const resultRow = appendBinaryBlocks(entries.map((e) => e.entry), safeRow);
			return transaction.put(SearchIndexOS, metaEntry.key, resultRow).then(() => {
				metaEntry.size += entries.length;
				metaEntry.oldestElementTimestamp = Math.min(entries[0].timestamp, metaEntry.oldestElementTimestamp);
			});
		}));
	}
	_distributeEntities(timestampToEntries, preferFirst) {
		const sortedTimestamps = Array.from(timestampToEntries.keys()).sort((l, r) => l - r);
		if (preferFirst) {
			const rows = [{
				row: [],
				oldestElementTimestamp: sortedTimestamps[0]
			}];
			for (const id of sortedTimestamps) {
				const encryptedEntries = neverNull(timestampToEntries.get(id));
				if (lastThrow(rows).row.length + encryptedEntries.length > SEARCH_INDEX_ROW_LENGTH) rows.push({
					row: [],
					oldestElementTimestamp: id
				});
				lastThrow(rows).row.push(...encryptedEntries);
			}
			return rows;
		} else {
			const rows = [{
				row: [],
				oldestElementTimestamp: Number.MAX_SAFE_INTEGER
			}];
			const reveresId = sortedTimestamps.slice().reverse();
			for (const id of reveresId) {
				const encryptedEntries = neverNull(timestampToEntries.get(id));
				if (rows[0].row.length + encryptedEntries.length > SEARCH_INDEX_ROW_LENGTH) rows.unshift({
					row: [],
					oldestElementTimestamp: id
				});
				rows[0].row.unshift(...encryptedEntries);
				rows[0].oldestElementTimestamp = Math.min(rows[0].oldestElementTimestamp, id);
			}
			return rows;
		}
	}
	_createNewRow(transaction, metaData, encryptedSearchIndexEntries, oldestTimestamp, appId, typeId) {
		const byTimestamp = groupByAndMap(encryptedSearchIndexEntries, (e) => e.timestamp, (e) => e.entry);
		const distributed = this._distributeEntities(byTimestamp, false);
		return this._promiseMapCompat(distributed, ({ row, oldestElementTimestamp }) => {
			const binaryRow = appendBinaryBlocks(row);
			return transaction.put(SearchIndexOS, null, binaryRow).then((newRowId) => {
				metaData.rows.push({
					key: newRowId,
					size: row.length,
					app: appId,
					type: typeId,
					oldestElementTimestamp
				});
			});
		}, { concurrency: 2 }).thenOrApply(() => {
			metaData.rows.sort(compareMetaEntriesOldest);
		});
	}
	_findMetaDataEntryByTimestamp(metaData, oldestTimestamp, appId, typeId) {
		return findLastIndex(metaData.rows, (r) => r.app === appId && r.type === typeId && r.oldestElementTimestamp <= oldestTimestamp);
	}
	_getOrCreateSearchIndexMeta(transaction, encWordBase64) {
		return transaction.get(SearchIndexMetaDataOS, encWordBase64, SearchIndexWordsIndex).then((metaData) => {
			if (metaData) return decryptMetaData(this.db.key, metaData);
else {
				const metaTemplate = {
					word: encWordBase64,
					rows: new Uint8Array(0)
				};
				if (this._needsExplicitIds) metaTemplate.id = this._explicitIdStart++;
				return transaction.put(SearchIndexMetaDataOS, null, metaTemplate).then((rowId) => {
					this._stats.words += 1;
					return {
						id: rowId,
						word: encWordBase64,
						rows: []
					};
				});
			}
		});
	}
	_updateGroupDataIndexTimestamp(dataPerGroup, transaction) {
		return this._promiseMapCompat(dataPerGroup, (data) => {
			const { groupId, indexTimestamp } = data;
			return transaction.get(GroupDataOS, groupId).then((groupData) => {
				if (!groupData) throw new InvalidDatabaseStateError("GroupData not available for group " + groupId);
				groupData.indexTimestamp = indexTimestamp;
				return transaction.put(GroupDataOS, groupId, groupData);
			});
		}).thenOrApply(() => {}).value;
	}
	_updateGroupDataBatchId(groupId, batchId, transaction) {
		return transaction.get(GroupDataOS, groupId).then((groupData) => {
			if (!groupData) throw new InvalidDatabaseStateError("GroupData not available for group " + groupId);
			if (groupData.lastBatchIds.length > 0 && groupData.lastBatchIds.indexOf(batchId) !== -1) {
				console.warn("Abort transaction on updating group data: concurrent access", groupId, batchId);
				transaction.abort();
			} else {
				let newIndex = groupData.lastBatchIds.findIndex((indexedBatchId) => firstBiggerThanSecond(batchId, indexedBatchId));
				if (newIndex !== -1) groupData.lastBatchIds.splice(newIndex, 0, batchId);
else groupData.lastBatchIds.push(batchId);
				if (groupData.lastBatchIds.length > 1e3) groupData.lastBatchIds = groupData.lastBatchIds.slice(0, 1e3);
				return transaction.put(GroupDataOS, groupId, groupData);
			}
		});
	}
	_cancelIfNeeded() {
		if (this._isStopped) throw new CancelledError("indexing cancelled");
	}
	resetStats() {
		this._stats = {
			indexingTime: 0,
			storageTime: 0,
			preparingTime: 0,
			mailcount: 0,
			storedBytes: 0,
			encryptionTime: 0,
			writeRequests: 0,
			largestColumn: 0,
			words: 0,
			indexedBytes: 0
		};
	}
	printStatus() {
		const totalTime = this._stats.storageTime + this._stats.preparingTime;
		const statsWithDownloading = Object.assign({}, this._stats, { downloadingTime: this._stats.preparingTime - this._stats.indexingTime - this._stats.encryptionTime });
		console.log(JSON.stringify(statsWithDownloading), "total time: ", totalTime);
	}
};

//#endregion
export { IndexerCore, InvalidDatabaseStateError };
//# sourceMappingURL=IndexerCore-CrLYpsA5.js.map