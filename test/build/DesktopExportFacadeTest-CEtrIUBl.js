
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __require, __toESM } from "./chunk-D_5_n1c4.js";
import { formatSortableDate } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { FileOpenError } from "./FileOpenError-C1_8yoXr.js";
import { ExportError, ExportErrorReason } from "./ExportError-DzgStBnl.js";
import { elementIdPart } from "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import "./TypeRefs-CR3TLWn0.js";
import { createDataFile } from "./DataFile-CY7uuk9j.js";
import { sanitizeFilename } from "./FileUtils-W-u2-gZz.js";
import { DesktopConfigKey } from "./ConfigKeys-B1UD5FwS.js";
import { generateExportFileName, mailToEmlFile } from "./emlUtils-afBEUvhM.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { fileExists } from "./PathUtils-DFfSo_TG.js";
import require$$0$1 from "fs";
import path from "node:path";
import require$$0 from "buffer";
import { promises } from "node:fs";
import require$$0$2 from "crypto";

//#region ../node_modules/@tutao/oxmsg/dist/index.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn) {
	var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}
function commonjsRequire(target) {
	throw new Error("Could not dynamically require \"" + target + "\". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.");
}
var long = createCommonjsModule(function(module) {
	/**
	
	* @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	
	* Released under the Apache License, Version 2.0
	
	* see: https://github.com/dcodeIO/long.js for details
	
	*/
	(function(global$1, factory) {
		if (typeof commonjsRequire === "function" && module && module["exports"]) module["exports"] = factory();
else (global$1["dcodeIO"] = global$1["dcodeIO"] || {})["Long"] = factory();
	})(commonjsGlobal, function() {
		/**
		
		* Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
		
		*  See the from* functions below for more convenient ways of constructing Longs.
		
		* @exports Long
		
		* @class A Long class for representing a 64 bit two's-complement integer value.
		
		* @param {number} low The low (signed) 32 bits of the long
		
		* @param {number} high The high (signed) 32 bits of the long
		
		* @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
		
		* @constructor
		
		*/
		function Long(low, high, unsigned) {
			/**
			
			* The low 32 bits as a signed value.
			
			* @type {number}
			
			*/
			this.low = low | 0;
			/**
			
			* The high 32 bits as a signed value.
			
			* @type {number}
			
			*/
			this.high = high | 0;
			/**
			
			* Whether unsigned or not.
			
			* @type {boolean}
			
			*/
			this.unsigned = !!unsigned;
		}
		/**
		
		* An indicator used to reliably determine if an object is a Long or not.
		
		* @type {boolean}
		
		* @const
		
		* @private
		
		*/
		Long.prototype.__isLong__;
		Object.defineProperty(Long.prototype, "__isLong__", {
			value: true,
			enumerable: false,
			configurable: false
		});
		/**
		
		* @function
		
		* @param {*} obj Object
		
		* @returns {boolean}
		
		* @inner
		
		*/
		function isLong(obj) {
			return (obj && obj["__isLong__"]) === true;
		}
		/**
		
		* Tests if the specified object is a Long.
		
		* @function
		
		* @param {*} obj Object
		
		* @returns {boolean}
		
		*/
		Long.isLong = isLong;
		/**
		
		* A cache of the Long representations of small integer values.
		
		* @type {!Object}
		
		* @inner
		
		*/
		var INT_CACHE = {};
		/**
		
		* A cache of the Long representations of small unsigned integer values.
		
		* @type {!Object}
		
		* @inner
		
		*/
		var UINT_CACHE = {};
		/**
		
		* @param {number} value
		
		* @param {boolean=} unsigned
		
		* @returns {!Long}
		
		* @inner
		
		*/
		function fromInt(value, unsigned) {
			var obj, cachedObj, cache;
			if (unsigned) {
				value >>>= 0;
				if (cache = 0 <= value && value < 256) {
					cachedObj = UINT_CACHE[value];
					if (cachedObj) return cachedObj;
				}
				obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
				if (cache) UINT_CACHE[value] = obj;
				return obj;
			} else {
				value |= 0;
				if (cache = -128 <= value && value < 128) {
					cachedObj = INT_CACHE[value];
					if (cachedObj) return cachedObj;
				}
				obj = fromBits(value, value < 0 ? -1 : 0, false);
				if (cache) INT_CACHE[value] = obj;
				return obj;
			}
		}
		/**
		
		* Returns a Long representing the given 32 bit integer value.
		
		* @function
		
		* @param {number} value The 32 bit integer in question
		
		* @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
		
		* @returns {!Long} The corresponding Long value
		
		*/
		Long.fromInt = fromInt;
		/**
		
		* @param {number} value
		
		* @param {boolean=} unsigned
		
		* @returns {!Long}
		
		* @inner
		
		*/
		function fromNumber(value, unsigned) {
			if (isNaN(value) || !isFinite(value)) return unsigned ? UZERO : ZERO;
			if (unsigned) {
				if (value < 0) return UZERO;
				if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
			} else {
				if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
				if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
			}
			if (value < 0) return fromNumber(-value, unsigned).neg();
			return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
		}
		/**
		
		* Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
		
		* @function
		
		* @param {number} value The number in question
		
		* @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
		
		* @returns {!Long} The corresponding Long value
		
		*/
		Long.fromNumber = fromNumber;
		/**
		
		* @param {number} lowBits
		
		* @param {number} highBits
		
		* @param {boolean=} unsigned
		
		* @returns {!Long}
		
		* @inner
		
		*/
		function fromBits(lowBits, highBits, unsigned) {
			return new Long(lowBits, highBits, unsigned);
		}
		/**
		
		* Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
		
		*  assumed to use 32 bits.
		
		* @function
		
		* @param {number} lowBits The low 32 bits
		
		* @param {number} highBits The high 32 bits
		
		* @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
		
		* @returns {!Long} The corresponding Long value
		
		*/
		Long.fromBits = fromBits;
		/**
		
		* @function
		
		* @param {number} base
		
		* @param {number} exponent
		
		* @returns {number}
		
		* @inner
		
		*/
		var pow_dbl = Math.pow;
		/**
		
		* @param {string} str
		
		* @param {(boolean|number)=} unsigned
		
		* @param {number=} radix
		
		* @returns {!Long}
		
		* @inner
		
		*/
		function fromString(str, unsigned, radix) {
			if (str.length === 0) throw Error("empty string");
			if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return ZERO;
			if (typeof unsigned === "number") radix = unsigned, unsigned = false;
else unsigned = !!unsigned;
			radix = radix || 10;
			if (radix < 2 || 36 < radix) throw RangeError("radix");
			var p;
			if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
else if (p === 0) return fromString(str.substring(1), unsigned, radix).neg();
			var radixToPower = fromNumber(pow_dbl(radix, 8));
			var result = ZERO;
			for (var i = 0; i < str.length; i += 8) {
				var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
				if (size < 8) {
					var power = fromNumber(pow_dbl(radix, size));
					result = result.mul(power).add(fromNumber(value));
				} else {
					result = result.mul(radixToPower);
					result = result.add(fromNumber(value));
				}
			}
			result.unsigned = unsigned;
			return result;
		}
		/**
		
		* Returns a Long representation of the given string, written using the specified radix.
		
		* @function
		
		* @param {string} str The textual representation of the Long
		
		* @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
		
		* @param {number=} radix The radix in which the text is written (2-36), defaults to 10
		
		* @returns {!Long} The corresponding Long value
		
		*/
		Long.fromString = fromString;
		/**
		
		* @function
		
		* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
		
		* @returns {!Long}
		
		* @inner
		
		*/
		function fromValue(val) {
			if (val instanceof Long) return val;
			if (typeof val === "number") return fromNumber(val);
			if (typeof val === "string") return fromString(val);
			return fromBits(val.low, val.high, val.unsigned);
		}
		/**
		
		* Converts the specified value to a Long.
		
		* @function
		
		* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
		
		* @returns {!Long}
		
		*/
		Long.fromValue = fromValue;
		/**
		
		* @type {number}
		
		* @const
		
		* @inner
		
		*/
		var TWO_PWR_16_DBL = 65536;
		/**
		
		* @type {number}
		
		* @const
		
		* @inner
		
		*/
		var TWO_PWR_24_DBL = 16777216;
		/**
		
		* @type {number}
		
		* @const
		
		* @inner
		
		*/
		var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
		/**
		
		* @type {number}
		
		* @const
		
		* @inner
		
		*/
		var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
		/**
		
		* @type {number}
		
		* @const
		
		* @inner
		
		*/
		var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
		/**
		
		* @type {!Long}
		
		* @const
		
		* @inner
		
		*/
		var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var ZERO = fromInt(0);
		/**
		
		* Signed zero.
		
		* @type {!Long}
		
		*/
		Long.ZERO = ZERO;
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var UZERO = fromInt(0, true);
		/**
		
		* Unsigned zero.
		
		* @type {!Long}
		
		*/
		Long.UZERO = UZERO;
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var ONE = fromInt(1);
		/**
		
		* Signed one.
		
		* @type {!Long}
		
		*/
		Long.ONE = ONE;
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var UONE = fromInt(1, true);
		/**
		
		* Unsigned one.
		
		* @type {!Long}
		
		*/
		Long.UONE = UONE;
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var NEG_ONE = fromInt(-1);
		/**
		
		* Signed negative one.
		
		* @type {!Long}
		
		*/
		Long.NEG_ONE = NEG_ONE;
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var MAX_VALUE = fromBits(-1, 2147483647, false);
		/**
		
		* Maximum signed value.
		
		* @type {!Long}
		
		*/
		Long.MAX_VALUE = MAX_VALUE;
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var MAX_UNSIGNED_VALUE = fromBits(-1, -1, true);
		/**
		
		* Maximum unsigned value.
		
		* @type {!Long}
		
		*/
		Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
		/**
		
		* @type {!Long}
		
		* @inner
		
		*/
		var MIN_VALUE = fromBits(0, -2147483648, false);
		/**
		
		* Minimum signed value.
		
		* @type {!Long}
		
		*/
		Long.MIN_VALUE = MIN_VALUE;
		/**
		
		* @alias Long.prototype
		
		* @inner
		
		*/
		var LongPrototype = Long.prototype;
		/**
		
		* Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
		
		* @returns {number}
		
		*/
		LongPrototype.toInt = function toInt() {
			return this.unsigned ? this.low >>> 0 : this.low;
		};
		/**
		
		* Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
		
		* @returns {number}
		
		*/
		LongPrototype.toNumber = function toNumber() {
			if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
			return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
		};
		/**
		
		* Converts the Long to a string written in the specified radix.
		
		* @param {number=} radix Radix (2-36), defaults to 10
		
		* @returns {string}
		
		* @override
		
		* @throws {RangeError} If `radix` is out of range
		
		*/
		LongPrototype.toString = function toString(radix) {
			radix = radix || 10;
			if (radix < 2 || 36 < radix) throw RangeError("radix");
			if (this.isZero()) return "0";
			if (this.isNegative()) if (this.eq(MIN_VALUE)) {
				var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
				return div.toString(radix) + rem1.toInt().toString(radix);
			} else return "-" + this.neg().toString(radix);
			var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
			var result = "";
			while (true) {
				var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
				rem = remDiv;
				if (rem.isZero()) return digits + result;
else {
					while (digits.length < 6) digits = "0" + digits;
					result = "" + digits + result;
				}
			}
		};
		/**
		
		* Gets the high 32 bits as a signed integer.
		
		* @returns {number} Signed high bits
		
		*/
		LongPrototype.getHighBits = function getHighBits() {
			return this.high;
		};
		/**
		
		* Gets the high 32 bits as an unsigned integer.
		
		* @returns {number} Unsigned high bits
		
		*/
		LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
			return this.high >>> 0;
		};
		/**
		
		* Gets the low 32 bits as a signed integer.
		
		* @returns {number} Signed low bits
		
		*/
		LongPrototype.getLowBits = function getLowBits() {
			return this.low;
		};
		/**
		
		* Gets the low 32 bits as an unsigned integer.
		
		* @returns {number} Unsigned low bits
		
		*/
		LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
			return this.low >>> 0;
		};
		/**
		
		* Gets the number of bits needed to represent the absolute value of this Long.
		
		* @returns {number}
		
		*/
		LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
			if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
			var val = this.high != 0 ? this.high : this.low;
			for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
			return this.high != 0 ? bit + 33 : bit + 1;
		};
		/**
		
		* Tests if this Long's value equals zero.
		
		* @returns {boolean}
		
		*/
		LongPrototype.isZero = function isZero() {
			return this.high === 0 && this.low === 0;
		};
		/**
		
		* Tests if this Long's value is negative.
		
		* @returns {boolean}
		
		*/
		LongPrototype.isNegative = function isNegative() {
			return !this.unsigned && this.high < 0;
		};
		/**
		
		* Tests if this Long's value is positive.
		
		* @returns {boolean}
		
		*/
		LongPrototype.isPositive = function isPositive() {
			return this.unsigned || this.high >= 0;
		};
		/**
		
		* Tests if this Long's value is odd.
		
		* @returns {boolean}
		
		*/
		LongPrototype.isOdd = function isOdd() {
			return (this.low & 1) === 1;
		};
		/**
		
		* Tests if this Long's value is even.
		
		* @returns {boolean}
		
		*/
		LongPrototype.isEven = function isEven() {
			return (this.low & 1) === 0;
		};
		/**
		
		* Tests if this Long's value equals the specified's.
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.equals = function equals(other) {
			if (!isLong(other)) other = fromValue(other);
			if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
			return this.high === other.high && this.low === other.low;
		};
		/**
		
		* Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
		
		* @function
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.eq = LongPrototype.equals;
		/**
		
		* Tests if this Long's value differs from the specified's.
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.notEquals = function notEquals(other) {
			return !this.eq(
				/* validates */
				other
);
		};
		/**
		
		* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		
		* @function
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.neq = LongPrototype.notEquals;
		/**
		
		* Tests if this Long's value is less than the specified's.
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.lessThan = function lessThan(other) {
			return this.comp(
				/* validates */
				other
) < 0;
		};
		/**
		
		* Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
		
		* @function
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.lt = LongPrototype.lessThan;
		/**
		
		* Tests if this Long's value is less than or equal the specified's.
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
			return this.comp(
				/* validates */
				other
) <= 0;
		};
		/**
		
		* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		
		* @function
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.lte = LongPrototype.lessThanOrEqual;
		/**
		
		* Tests if this Long's value is greater than the specified's.
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.greaterThan = function greaterThan(other) {
			return this.comp(
				/* validates */
				other
) > 0;
		};
		/**
		
		* Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
		
		* @function
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.gt = LongPrototype.greaterThan;
		/**
		
		* Tests if this Long's value is greater than or equal the specified's.
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
			return this.comp(
				/* validates */
				other
) >= 0;
		};
		/**
		
		* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		
		* @function
		
		* @param {!Long|number|string} other Other value
		
		* @returns {boolean}
		
		*/
		LongPrototype.gte = LongPrototype.greaterThanOrEqual;
		/**
		
		* Compares this Long's value with the specified's.
		
		* @param {!Long|number|string} other Other value
		
		* @returns {number} 0 if they are the same, 1 if the this is greater and -1
		
		*  if the given one is greater
		
		*/
		LongPrototype.compare = function compare(other) {
			if (!isLong(other)) other = fromValue(other);
			if (this.eq(other)) return 0;
			var thisNeg = this.isNegative(), otherNeg = other.isNegative();
			if (thisNeg && !otherNeg) return -1;
			if (!thisNeg && otherNeg) return 1;
			if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
			return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
		};
		/**
		
		* Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
		
		* @function
		
		* @param {!Long|number|string} other Other value
		
		* @returns {number} 0 if they are the same, 1 if the this is greater and -1
		
		*  if the given one is greater
		
		*/
		LongPrototype.comp = LongPrototype.compare;
		/**
		
		* Negates this Long's value.
		
		* @returns {!Long} Negated Long
		
		*/
		LongPrototype.negate = function negate() {
			if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
			return this.not().add(ONE);
		};
		/**
		
		* Negates this Long's value. This is an alias of {@link Long#negate}.
		
		* @function
		
		* @returns {!Long} Negated Long
		
		*/
		LongPrototype.neg = LongPrototype.negate;
		/**
		
		* Returns the sum of this and the specified Long.
		
		* @param {!Long|number|string} addend Addend
		
		* @returns {!Long} Sum
		
		*/
		LongPrototype.add = function add(addend) {
			if (!isLong(addend)) addend = fromValue(addend);
			var a48 = this.high >>> 16;
			var a32 = this.high & 65535;
			var a16 = this.low >>> 16;
			var a00 = this.low & 65535;
			var b48 = addend.high >>> 16;
			var b32 = addend.high & 65535;
			var b16 = addend.low >>> 16;
			var b00 = addend.low & 65535;
			var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
			c00 += a00 + b00;
			c16 += c00 >>> 16;
			c00 &= 65535;
			c16 += a16 + b16;
			c32 += c16 >>> 16;
			c16 &= 65535;
			c32 += a32 + b32;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c48 += a48 + b48;
			c48 &= 65535;
			return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		};
		/**
		
		* Returns the difference of this and the specified Long.
		
		* @param {!Long|number|string} subtrahend Subtrahend
		
		* @returns {!Long} Difference
		
		*/
		LongPrototype.subtract = function subtract(subtrahend) {
			if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
			return this.add(subtrahend.neg());
		};
		/**
		
		* Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
		
		* @function
		
		* @param {!Long|number|string} subtrahend Subtrahend
		
		* @returns {!Long} Difference
		
		*/
		LongPrototype.sub = LongPrototype.subtract;
		/**
		
		* Returns the product of this and the specified Long.
		
		* @param {!Long|number|string} multiplier Multiplier
		
		* @returns {!Long} Product
		
		*/
		LongPrototype.multiply = function multiply(multiplier) {
			if (this.isZero()) return ZERO;
			if (!isLong(multiplier)) multiplier = fromValue(multiplier);
			if (multiplier.isZero()) return ZERO;
			if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
			if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
			if (this.isNegative()) if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
else return this.neg().mul(multiplier).neg();
else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
			if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
			var a48 = this.high >>> 16;
			var a32 = this.high & 65535;
			var a16 = this.low >>> 16;
			var a00 = this.low & 65535;
			var b48 = multiplier.high >>> 16;
			var b32 = multiplier.high & 65535;
			var b16 = multiplier.low >>> 16;
			var b00 = multiplier.low & 65535;
			var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
			c00 += a00 * b00;
			c16 += c00 >>> 16;
			c00 &= 65535;
			c16 += a16 * b00;
			c32 += c16 >>> 16;
			c16 &= 65535;
			c16 += a00 * b16;
			c32 += c16 >>> 16;
			c16 &= 65535;
			c32 += a32 * b00;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c32 += a16 * b16;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c32 += a00 * b32;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
			c48 &= 65535;
			return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		};
		/**
		
		* Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
		
		* @function
		
		* @param {!Long|number|string} multiplier Multiplier
		
		* @returns {!Long} Product
		
		*/
		LongPrototype.mul = LongPrototype.multiply;
		/**
		
		* Returns this Long divided by the specified. The result is signed if this Long is signed or
		
		*  unsigned if this Long is unsigned.
		
		* @param {!Long|number|string} divisor Divisor
		
		* @returns {!Long} Quotient
		
		*/
		LongPrototype.divide = function divide(divisor) {
			if (!isLong(divisor)) divisor = fromValue(divisor);
			if (divisor.isZero()) throw Error("division by zero");
			if (this.isZero()) return this.unsigned ? UZERO : ZERO;
			var approx, rem, res;
			if (!this.unsigned) {
				if (this.eq(MIN_VALUE)) if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
else if (divisor.eq(MIN_VALUE)) return ONE;
else {
					var halfThis = this.shr(1);
					approx = halfThis.div(divisor).shl(1);
					if (approx.eq(ZERO)) return divisor.isNegative() ? ONE : NEG_ONE;
else {
						rem = this.sub(divisor.mul(approx));
						res = approx.add(rem.div(divisor));
						return res;
					}
				}
else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
				if (this.isNegative()) {
					if (divisor.isNegative()) return this.neg().div(divisor.neg());
					return this.neg().div(divisor).neg();
				} else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
				res = ZERO;
			} else {
				if (!divisor.unsigned) divisor = divisor.toUnsigned();
				if (divisor.gt(this)) return UZERO;
				if (divisor.gt(this.shru(1))) return UONE;
				res = UZERO;
			}
			rem = this;
			while (rem.gte(divisor)) {
				approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
				var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
				while (approxRem.isNegative() || approxRem.gt(rem)) {
					approx -= delta;
					approxRes = fromNumber(approx, this.unsigned);
					approxRem = approxRes.mul(divisor);
				}
				if (approxRes.isZero()) approxRes = ONE;
				res = res.add(approxRes);
				rem = rem.sub(approxRem);
			}
			return res;
		};
		/**
		
		* Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
		
		* @function
		
		* @param {!Long|number|string} divisor Divisor
		
		* @returns {!Long} Quotient
		
		*/
		LongPrototype.div = LongPrototype.divide;
		/**
		
		* Returns this Long modulo the specified.
		
		* @param {!Long|number|string} divisor Divisor
		
		* @returns {!Long} Remainder
		
		*/
		LongPrototype.modulo = function modulo(divisor) {
			if (!isLong(divisor)) divisor = fromValue(divisor);
			return this.sub(this.div(divisor).mul(divisor));
		};
		/**
		
		* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		
		* @function
		
		* @param {!Long|number|string} divisor Divisor
		
		* @returns {!Long} Remainder
		
		*/
		LongPrototype.mod = LongPrototype.modulo;
		/**
		
		* Returns the bitwise NOT of this Long.
		
		* @returns {!Long}
		
		*/
		LongPrototype.not = function not() {
			return fromBits(~this.low, ~this.high, this.unsigned);
		};
		/**
		
		* Returns the bitwise AND of this Long and the specified.
		
		* @param {!Long|number|string} other Other Long
		
		* @returns {!Long}
		
		*/
		LongPrototype.and = function and(other) {
			if (!isLong(other)) other = fromValue(other);
			return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
		};
		/**
		
		* Returns the bitwise OR of this Long and the specified.
		
		* @param {!Long|number|string} other Other Long
		
		* @returns {!Long}
		
		*/
		LongPrototype.or = function or(other) {
			if (!isLong(other)) other = fromValue(other);
			return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
		};
		/**
		
		* Returns the bitwise XOR of this Long and the given one.
		
		* @param {!Long|number|string} other Other Long
		
		* @returns {!Long}
		
		*/
		LongPrototype.xor = function xor(other) {
			if (!isLong(other)) other = fromValue(other);
			return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
		};
		/**
		
		* Returns this Long with bits shifted to the left by the given amount.
		
		* @param {number|!Long} numBits Number of bits
		
		* @returns {!Long} Shifted Long
		
		*/
		LongPrototype.shiftLeft = function shiftLeft(numBits) {
			if (isLong(numBits)) numBits = numBits.toInt();
			if ((numBits &= 63) === 0) return this;
else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
else return fromBits(0, this.low << numBits - 32, this.unsigned);
		};
		/**
		
		* Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
		
		* @function
		
		* @param {number|!Long} numBits Number of bits
		
		* @returns {!Long} Shifted Long
		
		*/
		LongPrototype.shl = LongPrototype.shiftLeft;
		/**
		
		* Returns this Long with bits arithmetically shifted to the right by the given amount.
		
		* @param {number|!Long} numBits Number of bits
		
		* @returns {!Long} Shifted Long
		
		*/
		LongPrototype.shiftRight = function shiftRight(numBits) {
			if (isLong(numBits)) numBits = numBits.toInt();
			if ((numBits &= 63) === 0) return this;
else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
		};
		/**
		
		* Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
		
		* @function
		
		* @param {number|!Long} numBits Number of bits
		
		* @returns {!Long} Shifted Long
		
		*/
		LongPrototype.shr = LongPrototype.shiftRight;
		/**
		
		* Returns this Long with bits logically shifted to the right by the given amount.
		
		* @param {number|!Long} numBits Number of bits
		
		* @returns {!Long} Shifted Long
		
		*/
		LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
			if (isLong(numBits)) numBits = numBits.toInt();
			numBits &= 63;
			if (numBits === 0) return this;
else {
				var high = this.high;
				if (numBits < 32) {
					var low = this.low;
					return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
				} else if (numBits === 32) return fromBits(high, 0, this.unsigned);
else return fromBits(high >>> numBits - 32, 0, this.unsigned);
			}
		};
		/**
		
		* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		
		* @function
		
		* @param {number|!Long} numBits Number of bits
		
		* @returns {!Long} Shifted Long
		
		*/
		LongPrototype.shru = LongPrototype.shiftRightUnsigned;
		/**
		
		* Converts this Long to signed.
		
		* @returns {!Long} Signed long
		
		*/
		LongPrototype.toSigned = function toSigned() {
			if (!this.unsigned) return this;
			return fromBits(this.low, this.high, false);
		};
		/**
		
		* Converts this Long to unsigned.
		
		* @returns {!Long} Unsigned long
		
		*/
		LongPrototype.toUnsigned = function toUnsigned() {
			if (this.unsigned) return this;
			return fromBits(this.low, this.high, true);
		};
		/**
		
		* Converts this Long to its byte representation.
		
		* @param {boolean=} le Whether little or big endian, defaults to big endian
		
		* @returns {!Array.<number>} Byte representation
		
		*/
		LongPrototype.toBytes = function(le) {
			return le ? this.toBytesLE() : this.toBytesBE();
		};
		/**
		
		* Converts this Long to its little endian byte representation.
		
		* @returns {!Array.<number>} Little endian byte representation
		
		*/
		LongPrototype.toBytesLE = function() {
			var hi = this.high, lo = this.low;
			return [
				lo & 255,
				lo >>> 8 & 255,
				lo >>> 16 & 255,
				lo >>> 24 & 255,
				hi & 255,
				hi >>> 8 & 255,
				hi >>> 16 & 255,
				hi >>> 24 & 255
			];
		};
		/**
		
		* Converts this Long to its big endian byte representation.
		
		* @returns {!Array.<number>} Big endian byte representation
		
		*/
		LongPrototype.toBytesBE = function() {
			var hi = this.high, lo = this.low;
			return [
				hi >>> 24 & 255,
				hi >>> 16 & 255,
				hi >>> 8 & 255,
				hi & 255,
				lo >>> 24 & 255,
				lo >>> 16 & 255,
				lo >>> 8 & 255,
				lo & 255
			];
		};
		return Long;
	});
});
/**

* @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>

* Backing buffer / Accessor: node Buffer

* Released under the Apache License, Version 2.0

* see: https://github.com/dcodeIO/bytebuffer.js for details

*/
var bytebufferNode = function() {
	var buffer = require$$0, Buffer$1 = buffer["Buffer"], Long = long, memcpy = null;
	try {
		memcpy = __require("memcpy");
	} catch (e) {}
	/**
	
	* Constructs a new ByteBuffer.
	
	* @class The swiss army knife for binary data in JavaScript.
	
	* @exports ByteBuffer
	
	* @constructor
	
	* @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_NOASSERT}.
	
	* @expose
	
	*/
	var ByteBuffer = function(capacity, littleEndian, noAssert) {
		if (typeof capacity === "undefined") capacity = ByteBuffer.DEFAULT_CAPACITY;
		if (typeof littleEndian === "undefined") littleEndian = ByteBuffer.DEFAULT_ENDIAN;
		if (typeof noAssert === "undefined") noAssert = ByteBuffer.DEFAULT_NOASSERT;
		if (!noAssert) {
			capacity = capacity | 0;
			if (capacity < 0) throw RangeError("Illegal capacity");
			littleEndian = !!littleEndian;
			noAssert = !!noAssert;
		}
		/**
		
		* Backing node Buffer.
		
		* @type {!Buffer}
		
		* @expose
		
		*/
		this.buffer = capacity === 0 ? EMPTY_BUFFER : new Buffer$1(capacity);
		/**
		
		* Absolute read/write offset.
		
		* @type {number}
		
		* @expose
		
		* @see ByteBuffer#flip
		
		* @see ByteBuffer#clear
		
		*/
		this.offset = 0;
		/**
		
		* Marked offset.
		
		* @type {number}
		
		* @expose
		
		* @see ByteBuffer#mark
		
		* @see ByteBuffer#reset
		
		*/
		this.markedOffset = -1;
		/**
		
		* Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
		
		* @type {number}
		
		* @expose
		
		* @see ByteBuffer#flip
		
		* @see ByteBuffer#clear
		
		*/
		this.limit = capacity;
		/**
		
		* Whether to use little endian byte order, defaults to `false` for big endian.
		
		* @type {boolean}
		
		* @expose
		
		*/
		this.littleEndian = littleEndian;
		/**
		
		* Whether to skip assertions of offsets and values, defaults to `false`.
		
		* @type {boolean}
		
		* @expose
		
		*/
		this.noAssert = noAssert;
	};
	/**
	
	* ByteBuffer version.
	
	* @type {string}
	
	* @const
	
	* @expose
	
	*/
	ByteBuffer.VERSION = "5.0.1";
	/**
	
	* Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
	
	* @type {boolean}
	
	* @const
	
	* @expose
	
	*/
	ByteBuffer.LITTLE_ENDIAN = true;
	/**
	
	* Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
	
	* @type {boolean}
	
	* @const
	
	* @expose
	
	*/
	ByteBuffer.BIG_ENDIAN = false;
	/**
	
	* Default initial capacity of `16`.
	
	* @type {number}
	
	* @expose
	
	*/
	ByteBuffer.DEFAULT_CAPACITY = 16;
	/**
	
	* Default endianess of `false` for big endian.
	
	* @type {boolean}
	
	* @expose
	
	*/
	ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;
	/**
	
	* Default no assertions flag of `false`.
	
	* @type {boolean}
	
	* @expose
	
	*/
	ByteBuffer.DEFAULT_NOASSERT = false;
	/**
	
	* A `Long` class for representing a 64-bit two's-complement integer value.
	
	* @type {!Long}
	
	* @const
	
	* @see https://npmjs.org/package/long
	
	* @expose
	
	*/
	ByteBuffer.Long = Long;
	/**
	
	* @alias ByteBuffer.prototype
	
	* @inner
	
	*/
	var ByteBufferPrototype = ByteBuffer.prototype;
	/**
	
	* An indicator used to reliably determine if an object is a ByteBuffer or not.
	
	* @type {boolean}
	
	* @const
	
	* @expose
	
	* @private
	
	*/
	ByteBufferPrototype.__isByteBuffer__;
	Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
		value: true,
		enumerable: false,
		configurable: false
	});
	/**
	
	* @type {!Buffer}
	
	* @inner
	
	*/
	var EMPTY_BUFFER = new Buffer$1(0);
	/**
	
	* String.fromCharCode reference for compile-time renaming.
	
	* @type {function(...number):string}
	
	* @inner
	
	*/
	var stringFromCharCode = String.fromCharCode;
	/**
	
	* Creates a source function for a string.
	
	* @param {string} s String to read from
	
	* @returns {function():number|null} Source function returning the next char code respectively `null` if there are
	
	*  no more characters left.
	
	* @throws {TypeError} If the argument is invalid
	
	* @inner
	
	*/
	function stringSource(s) {
		var i = 0;
		return function() {
			return i < s.length ? s.charCodeAt(i++) : null;
		};
	}
	/**
	
	* Creates a destination function for a string.
	
	* @returns {function(number=):undefined|string} Destination function successively called with the next char code.
	
	*  Returns the final string when called without arguments.
	
	* @inner
	
	*/
	function stringDestination() {
		var cs = [], ps = [];
		return function() {
			if (arguments.length === 0) return ps.join("") + stringFromCharCode.apply(String, cs);
			if (cs.length + arguments.length > 1024) ps.push(stringFromCharCode.apply(String, cs)), cs.length = 0;
			Array.prototype.push.apply(cs, arguments);
		};
	}
	/**
	
	* Gets the accessor type.
	
	* @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
	
	* @expose
	
	*/
	ByteBuffer.accessor = function() {
		return Buffer$1;
	};
	/**
	
	* Allocates a new ByteBuffer backed by a buffer of the specified capacity.
	
	* @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_NOASSERT}.
	
	* @returns {!ByteBuffer}
	
	* @expose
	
	*/
	ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
		return new ByteBuffer(capacity, littleEndian, noAssert);
	};
	/**
	
	* Concatenates multiple ByteBuffers into one.
	
	* @param {!Array.<!ByteBuffer|!Buffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
	
	* @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
	
	*  defaults to "utf8")
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
	
	*  to {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_NOASSERT}.
	
	* @returns {!ByteBuffer} Concatenated ByteBuffer
	
	* @expose
	
	*/
	ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
		if (typeof encoding === "boolean" || typeof encoding !== "string") {
			noAssert = littleEndian;
			littleEndian = encoding;
			encoding = undefined;
		}
		var capacity = 0;
		for (var i = 0, k = buffers.length, length; i < k; ++i) {
			if (!ByteBuffer.isByteBuffer(buffers[i])) buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
			length = buffers[i].limit - buffers[i].offset;
			if (length > 0) capacity += length;
		}
		if (capacity === 0) return new ByteBuffer(0, littleEndian, noAssert);
		var bb = new ByteBuffer(capacity, littleEndian, noAssert), bi;
		i = 0;
		while (i < k) {
			bi = buffers[i++];
			length = bi.limit - bi.offset;
			if (length <= 0) continue;
			bi.buffer.copy(bb.buffer, bb.offset, bi.offset, bi.limit);
			bb.offset += length;
		}
		bb.limit = bb.offset;
		bb.offset = 0;
		return bb;
	};
	/**
	
	* Tests if the specified type is a ByteBuffer.
	
	* @param {*} bb ByteBuffer to test
	
	* @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
	
	* @expose
	
	*/
	ByteBuffer.isByteBuffer = function(bb) {
		return (bb && bb["__isByteBuffer__"]) === true;
	};
	/**
	
	* Gets the backing buffer type.
	
	* @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
	
	* @expose
	
	*/
	ByteBuffer.type = function() {
		return Buffer$1;
	};
	/**
	
	* Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
	
	*  {@link ByteBuffer#limit} to the length of the wrapped data.
	
	* @param {!ByteBuffer|!Buffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
	
	* @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
	
	*  "utf8")
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_NOASSERT}.
	
	* @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
	
	* @expose
	
	*/
	ByteBuffer.wrap = function(buffer$1, encoding, littleEndian, noAssert) {
		if (typeof encoding !== "string") {
			noAssert = littleEndian;
			littleEndian = encoding;
			encoding = undefined;
		}
		if (typeof buffer$1 === "string") {
			if (typeof encoding === "undefined") encoding = "utf8";
			switch (encoding) {
				case "base64": return ByteBuffer.fromBase64(buffer$1, littleEndian);
				case "hex": return ByteBuffer.fromHex(buffer$1, littleEndian);
				case "binary": return ByteBuffer.fromBinary(buffer$1, littleEndian);
				case "utf8": return ByteBuffer.fromUTF8(buffer$1, littleEndian);
				case "debug": return ByteBuffer.fromDebug(buffer$1, littleEndian);
				default: throw Error("Unsupported encoding: " + encoding);
			}
		}
		if (buffer$1 === null || typeof buffer$1 !== "object") throw TypeError("Illegal buffer");
		var bb;
		if (ByteBuffer.isByteBuffer(buffer$1)) {
			bb = ByteBufferPrototype.clone.call(buffer$1);
			bb.markedOffset = -1;
			return bb;
		}
		var i = 0, k = 0, b;
		if (buffer$1 instanceof Uint8Array) {
			b = new Buffer$1(buffer$1.length);
			if (memcpy) memcpy(b, 0, buffer$1.buffer, buffer$1.byteOffset, buffer$1.byteOffset + buffer$1.length);
else for (i = 0, k = buffer$1.length; i < k; ++i) b[i] = buffer$1[i];
			buffer$1 = b;
		} else if (buffer$1 instanceof ArrayBuffer) {
			b = new Buffer$1(buffer$1.byteLength);
			if (memcpy) memcpy(b, 0, buffer$1, 0, buffer$1.byteLength);
else {
				buffer$1 = new Uint8Array(buffer$1);
				for (i = 0, k = buffer$1.length; i < k; ++i) b[i] = buffer$1[i];
			}
			buffer$1 = b;
		} else if (!(buffer$1 instanceof Buffer$1)) {
			if (Object.prototype.toString.call(buffer$1) !== "[object Array]") throw TypeError("Illegal buffer");
			buffer$1 = new Buffer$1(buffer$1);
		}
		bb = new ByteBuffer(0, littleEndian, noAssert);
		if (buffer$1.length > 0) {
			bb.buffer = buffer$1;
			bb.limit = buffer$1.length;
		}
		return bb;
	};
	/**
	
	* Writes the array as a bitset.
	
	* @param {Array<boolean>} value Array of booleans to write
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
	
	* @returns {!ByteBuffer}
	
	* @expose
	
	*/
	ByteBufferPrototype.writeBitSet = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (!(value instanceof Array)) throw TypeError("Illegal BitSet: Not an array");
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		var start = offset, bits = value.length, bytes = bits >> 3, bit = 0, k;
		offset += this.writeVarint32(bits, offset);
		while (bytes--) {
			k = !!value[bit++] & 1 | (!!value[bit++] & 1) << 1 | (!!value[bit++] & 1) << 2 | (!!value[bit++] & 1) << 3 | (!!value[bit++] & 1) << 4 | (!!value[bit++] & 1) << 5 | (!!value[bit++] & 1) << 6 | (!!value[bit++] & 1) << 7;
			this.writeByte(k, offset++);
		}
		if (bit < bits) {
			var m = 0;
			k = 0;
			while (bit < bits) k = k | (!!value[bit++] & 1) << m++;
			this.writeByte(k, offset++);
		}
		if (relative) {
			this.offset = offset;
			return this;
		}
		return offset - start;
	};
	/**
	
	* Reads a BitSet as an array of booleans.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
	
	* @returns {Array<boolean>
	
	* @expose
	
	*/
	ByteBufferPrototype.readBitSet = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		var ret = this.readVarint32(offset), bits = ret.value, bytes = bits >> 3, bit = 0, value = [], k;
		offset += ret.length;
		while (bytes--) {
			k = this.readByte(offset++);
			value[bit++] = !!(k & 1);
			value[bit++] = !!(k & 2);
			value[bit++] = !!(k & 4);
			value[bit++] = !!(k & 8);
			value[bit++] = !!(k & 16);
			value[bit++] = !!(k & 32);
			value[bit++] = !!(k & 64);
			value[bit++] = !!(k & 128);
		}
		if (bit < bits) {
			var m = 0;
			k = this.readByte(offset++);
			while (bit < bits) value[bit++] = !!(k >> m++ & 1);
		}
		if (relative) this.offset = offset;
		return value;
	};
	/**
	
	* Reads the specified number of bytes.
	
	* @param {number} length Number of bytes to read
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
	
	* @returns {!ByteBuffer}
	
	* @expose
	
	*/
	ByteBufferPrototype.readBytes = function(length, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + length > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + length + ") <= " + this.buffer.length);
		}
		var slice = this.slice(offset, offset + length);
		if (relative) this.offset += length;
		return slice;
	};
	/**
	
	* Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
	
	* @function
	
	* @param {!ByteBuffer|!Buffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its
	
	* offsets will be modified according to the performed read operation.
	
	* @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;
	/**
	
	* Writes an 8bit signed integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeInt8 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value |= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 1;
		var capacity0 = this.buffer.length;
		if (offset > capacity0) this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
		offset -= 1;
		this.buffer[offset] = value;
		if (relative) this.offset += 1;
		return this;
	};
	/**
	
	* Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
	
	* @function
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;
	/**
	
	* Reads an 8bit signed integer.
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readInt8 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 1 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.length);
		}
		var value = this.buffer[offset];
		if ((value & 128) === 128) value = -(255 - value + 1);
		if (relative) this.offset += 1;
		return value;
	};
	/**
	
	* Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
	
	* @function
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;
	/**
	
	* Writes an 8bit unsigned integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeUint8 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value >>>= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 1;
		var capacity1 = this.buffer.length;
		if (offset > capacity1) this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
		offset -= 1;
		this.buffer[offset] = value;
		if (relative) this.offset += 1;
		return this;
	};
	/**
	
	* Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
	
	* @function
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;
	/**
	
	* Reads an 8bit unsigned integer.
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readUint8 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 1 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.length);
		}
		var value = this.buffer[offset];
		if (relative) this.offset += 1;
		return value;
	};
	/**
	
	* Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
	
	* @function
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;
	/**
	
	* Writes a 16bit signed integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @throws {TypeError} If `offset` or `value` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.writeInt16 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value |= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 2;
		var capacity2 = this.buffer.length;
		if (offset > capacity2) this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
		offset -= 2;
		if (this.littleEndian) {
			this.buffer[offset + 1] = (value & 65280) >>> 8;
			this.buffer[offset] = value & 255;
		} else {
			this.buffer[offset] = (value & 65280) >>> 8;
			this.buffer[offset + 1] = value & 255;
		}
		if (relative) this.offset += 2;
		return this;
	};
	/**
	
	* Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
	
	* @function
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @throws {TypeError} If `offset` or `value` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;
	/**
	
	* Reads a 16bit signed integer.
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @returns {number} Value read
	
	* @throws {TypeError} If `offset` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.readInt16 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 2 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 2 + ") <= " + this.buffer.length);
		}
		var value = 0;
		if (this.littleEndian) {
			value = this.buffer[offset];
			value |= this.buffer[offset + 1] << 8;
		} else {
			value = this.buffer[offset] << 8;
			value |= this.buffer[offset + 1];
		}
		if ((value & 32768) === 32768) value = -(65535 - value + 1);
		if (relative) this.offset += 2;
		return value;
	};
	/**
	
	* Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
	
	* @function
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @returns {number} Value read
	
	* @throws {TypeError} If `offset` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;
	/**
	
	* Writes a 16bit unsigned integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @throws {TypeError} If `offset` or `value` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.writeUint16 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value >>>= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 2;
		var capacity3 = this.buffer.length;
		if (offset > capacity3) this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
		offset -= 2;
		if (this.littleEndian) {
			this.buffer[offset + 1] = (value & 65280) >>> 8;
			this.buffer[offset] = value & 255;
		} else {
			this.buffer[offset] = (value & 65280) >>> 8;
			this.buffer[offset + 1] = value & 255;
		}
		if (relative) this.offset += 2;
		return this;
	};
	/**
	
	* Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
	
	* @function
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @throws {TypeError} If `offset` or `value` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;
	/**
	
	* Reads a 16bit unsigned integer.
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @returns {number} Value read
	
	* @throws {TypeError} If `offset` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.readUint16 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 2 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 2 + ") <= " + this.buffer.length);
		}
		var value = 0;
		if (this.littleEndian) {
			value = this.buffer[offset];
			value |= this.buffer[offset + 1] << 8;
		} else {
			value = this.buffer[offset] << 8;
			value |= this.buffer[offset + 1];
		}
		if (relative) this.offset += 2;
		return value;
	};
	/**
	
	* Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
	
	* @function
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	
	* @returns {number} Value read
	
	* @throws {TypeError} If `offset` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;
	/**
	
	* Writes a 32bit signed integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @expose
	
	*/
	ByteBufferPrototype.writeInt32 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value |= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 4;
		var capacity4 = this.buffer.length;
		if (offset > capacity4) this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
		offset -= 4;
		if (this.littleEndian) {
			this.buffer[offset + 3] = value >>> 24 & 255;
			this.buffer[offset + 2] = value >>> 16 & 255;
			this.buffer[offset + 1] = value >>> 8 & 255;
			this.buffer[offset] = value & 255;
		} else {
			this.buffer[offset] = value >>> 24 & 255;
			this.buffer[offset + 1] = value >>> 16 & 255;
			this.buffer[offset + 2] = value >>> 8 & 255;
			this.buffer[offset + 3] = value & 255;
		}
		if (relative) this.offset += 4;
		return this;
	};
	/**
	
	* Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @expose
	
	*/
	ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;
	/**
	
	* Reads a 32bit signed integer.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readInt32 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 4 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.length);
		}
		var value = 0;
		if (this.littleEndian) {
			value = this.buffer[offset + 2] << 16;
			value |= this.buffer[offset + 1] << 8;
			value |= this.buffer[offset];
			value += this.buffer[offset + 3] << 24 >>> 0;
		} else {
			value = this.buffer[offset + 1] << 16;
			value |= this.buffer[offset + 2] << 8;
			value |= this.buffer[offset + 3];
			value += this.buffer[offset] << 24 >>> 0;
		}
		value |= 0;
		if (relative) this.offset += 4;
		return value;
	};
	/**
	
	* Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
	
	* @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;
	/**
	
	* Writes a 32bit unsigned integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @expose
	
	*/
	ByteBufferPrototype.writeUint32 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value >>>= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 4;
		var capacity5 = this.buffer.length;
		if (offset > capacity5) this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
		offset -= 4;
		if (this.littleEndian) {
			this.buffer[offset + 3] = value >>> 24 & 255;
			this.buffer[offset + 2] = value >>> 16 & 255;
			this.buffer[offset + 1] = value >>> 8 & 255;
			this.buffer[offset] = value & 255;
		} else {
			this.buffer[offset] = value >>> 24 & 255;
			this.buffer[offset + 1] = value >>> 16 & 255;
			this.buffer[offset + 2] = value >>> 8 & 255;
			this.buffer[offset + 3] = value & 255;
		}
		if (relative) this.offset += 4;
		return this;
	};
	/**
	
	* Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
	
	* @function
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @expose
	
	*/
	ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;
	/**
	
	* Reads a 32bit unsigned integer.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readUint32 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 4 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.length);
		}
		var value = 0;
		if (this.littleEndian) {
			value = this.buffer[offset + 2] << 16;
			value |= this.buffer[offset + 1] << 8;
			value |= this.buffer[offset];
			value += this.buffer[offset + 3] << 24 >>> 0;
		} else {
			value = this.buffer[offset + 1] << 16;
			value |= this.buffer[offset + 2] << 8;
			value |= this.buffer[offset + 3];
			value += this.buffer[offset] << 24 >>> 0;
		}
		if (relative) this.offset += 4;
		return value;
	};
	/**
	
	* Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
	
	* @function
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {number} Value read
	
	* @expose
	
	*/
	ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;
	if (Long) {
		/**
		
		* Writes a 64bit signed integer.
		
		* @param {number|!Long} value Value to write
		
		* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!ByteBuffer} this
		
		* @expose
		
		*/
		ByteBufferPrototype.writeInt64 = function(value, offset) {
			var relative = typeof offset === "undefined";
			if (relative) offset = this.offset;
			if (!this.noAssert) {
				if (typeof value === "number") value = Long.fromNumber(value);
else if (typeof value === "string") value = Long.fromString(value);
else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
				if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
				offset >>>= 0;
				if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
			}
			if (typeof value === "number") value = Long.fromNumber(value);
else if (typeof value === "string") value = Long.fromString(value);
			offset += 8;
			var capacity6 = this.buffer.length;
			if (offset > capacity6) this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
			offset -= 8;
			var lo = value.low, hi = value.high;
			if (this.littleEndian) {
				this.buffer[offset + 3] = lo >>> 24 & 255;
				this.buffer[offset + 2] = lo >>> 16 & 255;
				this.buffer[offset + 1] = lo >>> 8 & 255;
				this.buffer[offset] = lo & 255;
				offset += 4;
				this.buffer[offset + 3] = hi >>> 24 & 255;
				this.buffer[offset + 2] = hi >>> 16 & 255;
				this.buffer[offset + 1] = hi >>> 8 & 255;
				this.buffer[offset] = hi & 255;
			} else {
				this.buffer[offset] = hi >>> 24 & 255;
				this.buffer[offset + 1] = hi >>> 16 & 255;
				this.buffer[offset + 2] = hi >>> 8 & 255;
				this.buffer[offset + 3] = hi & 255;
				offset += 4;
				this.buffer[offset] = lo >>> 24 & 255;
				this.buffer[offset + 1] = lo >>> 16 & 255;
				this.buffer[offset + 2] = lo >>> 8 & 255;
				this.buffer[offset + 3] = lo & 255;
			}
			if (relative) this.offset += 8;
			return this;
		};
		/**
		
		* Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
		
		* @param {number|!Long} value Value to write
		
		* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!ByteBuffer} this
		
		* @expose
		
		*/
		ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;
		/**
		
		* Reads a 64bit signed integer.
		
		* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!Long}
		
		* @expose
		
		*/
		ByteBufferPrototype.readInt64 = function(offset) {
			var relative = typeof offset === "undefined";
			if (relative) offset = this.offset;
			if (!this.noAssert) {
				if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
				offset >>>= 0;
				if (offset < 0 || offset + 8 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.length);
			}
			var lo = 0, hi = 0;
			if (this.littleEndian) {
				lo = this.buffer[offset + 2] << 16;
				lo |= this.buffer[offset + 1] << 8;
				lo |= this.buffer[offset];
				lo += this.buffer[offset + 3] << 24 >>> 0;
				offset += 4;
				hi = this.buffer[offset + 2] << 16;
				hi |= this.buffer[offset + 1] << 8;
				hi |= this.buffer[offset];
				hi += this.buffer[offset + 3] << 24 >>> 0;
			} else {
				hi = this.buffer[offset + 1] << 16;
				hi |= this.buffer[offset + 2] << 8;
				hi |= this.buffer[offset + 3];
				hi += this.buffer[offset] << 24 >>> 0;
				offset += 4;
				lo = this.buffer[offset + 1] << 16;
				lo |= this.buffer[offset + 2] << 8;
				lo |= this.buffer[offset + 3];
				lo += this.buffer[offset] << 24 >>> 0;
			}
			var value = new Long(lo, hi, false);
			if (relative) this.offset += 8;
			return value;
		};
		/**
		
		* Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
		
		* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!Long}
		
		* @expose
		
		*/
		ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;
		/**
		
		* Writes a 64bit unsigned integer.
		
		* @param {number|!Long} value Value to write
		
		* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!ByteBuffer} this
		
		* @expose
		
		*/
		ByteBufferPrototype.writeUint64 = function(value, offset) {
			var relative = typeof offset === "undefined";
			if (relative) offset = this.offset;
			if (!this.noAssert) {
				if (typeof value === "number") value = Long.fromNumber(value);
else if (typeof value === "string") value = Long.fromString(value);
else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
				if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
				offset >>>= 0;
				if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
			}
			if (typeof value === "number") value = Long.fromNumber(value);
else if (typeof value === "string") value = Long.fromString(value);
			offset += 8;
			var capacity7 = this.buffer.length;
			if (offset > capacity7) this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
			offset -= 8;
			var lo = value.low, hi = value.high;
			if (this.littleEndian) {
				this.buffer[offset + 3] = lo >>> 24 & 255;
				this.buffer[offset + 2] = lo >>> 16 & 255;
				this.buffer[offset + 1] = lo >>> 8 & 255;
				this.buffer[offset] = lo & 255;
				offset += 4;
				this.buffer[offset + 3] = hi >>> 24 & 255;
				this.buffer[offset + 2] = hi >>> 16 & 255;
				this.buffer[offset + 1] = hi >>> 8 & 255;
				this.buffer[offset] = hi & 255;
			} else {
				this.buffer[offset] = hi >>> 24 & 255;
				this.buffer[offset + 1] = hi >>> 16 & 255;
				this.buffer[offset + 2] = hi >>> 8 & 255;
				this.buffer[offset + 3] = hi & 255;
				offset += 4;
				this.buffer[offset] = lo >>> 24 & 255;
				this.buffer[offset + 1] = lo >>> 16 & 255;
				this.buffer[offset + 2] = lo >>> 8 & 255;
				this.buffer[offset + 3] = lo & 255;
			}
			if (relative) this.offset += 8;
			return this;
		};
		/**
		
		* Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
		
		* @function
		
		* @param {number|!Long} value Value to write
		
		* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!ByteBuffer} this
		
		* @expose
		
		*/
		ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;
		/**
		
		* Reads a 64bit unsigned integer.
		
		* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!Long}
		
		* @expose
		
		*/
		ByteBufferPrototype.readUint64 = function(offset) {
			var relative = typeof offset === "undefined";
			if (relative) offset = this.offset;
			if (!this.noAssert) {
				if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
				offset >>>= 0;
				if (offset < 0 || offset + 8 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.length);
			}
			var lo = 0, hi = 0;
			if (this.littleEndian) {
				lo = this.buffer[offset + 2] << 16;
				lo |= this.buffer[offset + 1] << 8;
				lo |= this.buffer[offset];
				lo += this.buffer[offset + 3] << 24 >>> 0;
				offset += 4;
				hi = this.buffer[offset + 2] << 16;
				hi |= this.buffer[offset + 1] << 8;
				hi |= this.buffer[offset];
				hi += this.buffer[offset + 3] << 24 >>> 0;
			} else {
				hi = this.buffer[offset + 1] << 16;
				hi |= this.buffer[offset + 2] << 8;
				hi |= this.buffer[offset + 3];
				hi += this.buffer[offset] << 24 >>> 0;
				offset += 4;
				lo = this.buffer[offset + 1] << 16;
				lo |= this.buffer[offset + 2] << 8;
				lo |= this.buffer[offset + 3];
				lo += this.buffer[offset] << 24 >>> 0;
			}
			var value = new Long(lo, hi, true);
			if (relative) this.offset += 8;
			return value;
		};
		/**
		
		* Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
		
		* @function
		
		* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
		
		* @returns {!Long}
		
		* @expose
		
		*/
		ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;
	}
	/**
	
	* Writes a 32bit float.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeFloat32 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number") throw TypeError("Illegal value: " + value + " (not a number)");
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 4;
		var capacity8 = this.buffer.length;
		if (offset > capacity8) this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
		offset -= 4;
		this.littleEndian ? this.buffer.writeFloatLE(value, offset, true) : this.buffer.writeFloatBE(value, offset, true);
		if (relative) this.offset += 4;
		return this;
	};
	/**
	
	* Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
	
	* @function
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;
	/**
	
	* Reads a 32bit float.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {number}
	
	* @expose
	
	*/
	ByteBufferPrototype.readFloat32 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 4 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.length);
		}
		var value = this.littleEndian ? this.buffer.readFloatLE(offset, true) : this.buffer.readFloatBE(offset, true);
		if (relative) this.offset += 4;
		return value;
	};
	/**
	
	* Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
	
	* @function
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	
	* @returns {number}
	
	* @expose
	
	*/
	ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;
	/**
	
	* Writes a 64bit float.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeFloat64 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number") throw TypeError("Illegal value: " + value + " (not a number)");
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		offset += 8;
		var capacity9 = this.buffer.length;
		if (offset > capacity9) this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
		offset -= 8;
		this.littleEndian ? this.buffer.writeDoubleLE(value, offset, true) : this.buffer.writeDoubleBE(value, offset, true);
		if (relative) this.offset += 8;
		return this;
	};
	/**
	
	* Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
	
	* @function
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;
	/**
	
	* Reads a 64bit float.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	
	* @returns {number}
	
	* @expose
	
	*/
	ByteBufferPrototype.readFloat64 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 8 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.length);
		}
		var value = this.littleEndian ? this.buffer.readDoubleLE(offset, true) : this.buffer.readDoubleBE(offset, true);
		if (relative) this.offset += 8;
		return value;
	};
	/**
	
	* Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
	
	* @function
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	
	* @returns {number}
	
	* @expose
	
	*/
	ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;
	/**
	
	* Maximum number of bytes required to store a 32bit base 128 variable-length integer.
	
	* @type {number}
	
	* @const
	
	* @expose
	
	*/
	ByteBuffer.MAX_VARINT32_BYTES = 5;
	/**
	
	* Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
	
	* @param {number} value Value to encode
	
	* @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
	
	* @expose
	
	*/
	ByteBuffer.calculateVarint32 = function(value) {
		value = value >>> 0;
		if (value < 128) return 1;
else if (value < 16384) return 2;
else if (value < 2097152) return 3;
else if (value < 268435456) return 4;
else return 5;
	};
	/**
	
	* Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
	
	* @param {number} n Signed 32bit integer
	
	* @returns {number} Unsigned zigzag encoded 32bit integer
	
	* @expose
	
	*/
	ByteBuffer.zigZagEncode32 = function(n) {
		return ((n |= 0) << 1 ^ n >> 31) >>> 0;
	};
	/**
	
	* Decodes a zigzag encoded signed 32bit integer.
	
	* @param {number} n Unsigned zigzag encoded 32bit integer
	
	* @returns {number} Signed 32bit integer
	
	* @expose
	
	*/
	ByteBuffer.zigZagDecode32 = function(n) {
		return n >>> 1 ^ -(n & 1) | 0;
	};
	/**
	
	* Writes a 32bit base 128 variable-length integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
	
	* @expose
	
	*/
	ByteBufferPrototype.writeVarint32 = function(value, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value |= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		var size = ByteBuffer.calculateVarint32(value), b;
		offset += size;
		var capacity10 = this.buffer.length;
		if (offset > capacity10) this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
		offset -= size;
		value >>>= 0;
		while (value >= 128) {
			b = value & 127 | 128;
			this.buffer[offset++] = b;
			value >>>= 7;
		}
		this.buffer[offset++] = value;
		if (relative) {
			this.offset = offset;
			return this;
		}
		return size;
	};
	/**
	
	* Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
	
	* @param {number} value Value to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
	
	* @expose
	
	*/
	ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
		return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
	};
	/**
	
	* Reads a 32bit base 128 variable-length integer.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
	
	*  and the actual number of bytes read.
	
	* @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
	
	*  to fully decode the varint.
	
	* @expose
	
	*/
	ByteBufferPrototype.readVarint32 = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 1 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.length);
		}
		var c = 0, value = 0, b;
		do {
			if (!this.noAssert && offset > this.limit) {
				var err = Error("Truncated");
				err["truncated"] = true;
				throw err;
			}
			b = this.buffer[offset++];
			if (c < 5) value |= (b & 127) << 7 * c;
			++c;
		} while ((b & 128) !== 0);
		value |= 0;
		if (relative) {
			this.offset = offset;
			return value;
		}
		return {
			"value": value,
			"length": c
		};
	};
	/**
	
	* Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
	
	*  and the actual number of bytes read.
	
	* @throws {Error} If it's not a valid varint
	
	* @expose
	
	*/
	ByteBufferPrototype.readVarint32ZigZag = function(offset) {
		var val = this.readVarint32(offset);
		if (typeof val === "object") val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
else val = ByteBuffer.zigZagDecode32(val);
		return val;
	};
	if (Long) {
		/**
		
		* Maximum number of bytes required to store a 64bit base 128 variable-length integer.
		
		* @type {number}
		
		* @const
		
		* @expose
		
		*/
		ByteBuffer.MAX_VARINT64_BYTES = 10;
		/**
		
		* Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
		
		* @param {number|!Long} value Value to encode
		
		* @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
		
		* @expose
		
		*/
		ByteBuffer.calculateVarint64 = function(value) {
			if (typeof value === "number") value = Long.fromNumber(value);
else if (typeof value === "string") value = Long.fromString(value);
			var part0 = value.toInt() >>> 0, part1 = value.shiftRightUnsigned(28).toInt() >>> 0, part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
			if (part2 == 0) if (part1 == 0) if (part0 < 16384) return part0 < 128 ? 1 : 2;
else return part0 < 2097152 ? 3 : 4;
else if (part1 < 16384) return part1 < 128 ? 5 : 6;
else return part1 < 2097152 ? 7 : 8;
else return part2 < 128 ? 9 : 10;
		};
		/**
		
		* Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
		
		* @param {number|!Long} value Signed long
		
		* @returns {!Long} Unsigned zigzag encoded long
		
		* @expose
		
		*/
		ByteBuffer.zigZagEncode64 = function(value) {
			if (typeof value === "number") value = Long.fromNumber(value, false);
else if (typeof value === "string") value = Long.fromString(value, false);
else if (value.unsigned !== false) value = value.toSigned();
			return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
		};
		/**
		
		* Decodes a zigzag encoded signed 64bit integer.
		
		* @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
		
		* @returns {!Long} Signed long
		
		* @expose
		
		*/
		ByteBuffer.zigZagDecode64 = function(value) {
			if (typeof value === "number") value = Long.fromNumber(value, false);
else if (typeof value === "string") value = Long.fromString(value, false);
else if (value.unsigned !== false) value = value.toSigned();
			return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
		};
		/**
		
		* Writes a 64bit base 128 variable-length integer.
		
		* @param {number|Long} value Value to write
		
		* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
		
		*  written if omitted.
		
		* @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
		
		* @expose
		
		*/
		ByteBufferPrototype.writeVarint64 = function(value, offset) {
			var relative = typeof offset === "undefined";
			if (relative) offset = this.offset;
			if (!this.noAssert) {
				if (typeof value === "number") value = Long.fromNumber(value);
else if (typeof value === "string") value = Long.fromString(value);
else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
				if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
				offset >>>= 0;
				if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
			}
			if (typeof value === "number") value = Long.fromNumber(value, false);
else if (typeof value === "string") value = Long.fromString(value, false);
else if (value.unsigned !== false) value = value.toSigned();
			var size = ByteBuffer.calculateVarint64(value), part0 = value.toInt() >>> 0, part1 = value.shiftRightUnsigned(28).toInt() >>> 0, part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
			offset += size;
			var capacity11 = this.buffer.length;
			if (offset > capacity11) this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
			offset -= size;
			switch (size) {
				case 10: this.buffer[offset + 9] = part2 >>> 7 & 1;
				case 9: this.buffer[offset + 8] = size !== 9 ? part2 | 128 : part2 & 127;
				case 8: this.buffer[offset + 7] = size !== 8 ? part1 >>> 21 | 128 : part1 >>> 21 & 127;
				case 7: this.buffer[offset + 6] = size !== 7 ? part1 >>> 14 | 128 : part1 >>> 14 & 127;
				case 6: this.buffer[offset + 5] = size !== 6 ? part1 >>> 7 | 128 : part1 >>> 7 & 127;
				case 5: this.buffer[offset + 4] = size !== 5 ? part1 | 128 : part1 & 127;
				case 4: this.buffer[offset + 3] = size !== 4 ? part0 >>> 21 | 128 : part0 >>> 21 & 127;
				case 3: this.buffer[offset + 2] = size !== 3 ? part0 >>> 14 | 128 : part0 >>> 14 & 127;
				case 2: this.buffer[offset + 1] = size !== 2 ? part0 >>> 7 | 128 : part0 >>> 7 & 127;
				case 1: this.buffer[offset] = size !== 1 ? part0 | 128 : part0 & 127;
			}
			if (relative) {
				this.offset += size;
				return this;
			} else return size;
		};
		/**
		
		* Writes a zig-zag encoded 64bit base 128 variable-length integer.
		
		* @param {number|Long} value Value to write
		
		* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
		
		*  written if omitted.
		
		* @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
		
		* @expose
		
		*/
		ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
			return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
		};
		/**
		
		* Reads a 64bit base 128 variable-length integer. Requires Long.js.
		
		* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
		
		*  read if omitted.
		
		* @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
		
		*  the actual number of bytes read.
		
		* @throws {Error} If it's not a valid varint
		
		* @expose
		
		*/
		ByteBufferPrototype.readVarint64 = function(offset) {
			var relative = typeof offset === "undefined";
			if (relative) offset = this.offset;
			if (!this.noAssert) {
				if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
				offset >>>= 0;
				if (offset < 0 || offset + 1 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.length);
			}
			var start = offset, part0 = 0, part1 = 0, part2 = 0, b = 0;
			b = this.buffer[offset++];
			part0 = b & 127;
			if (b & 128) {
				b = this.buffer[offset++];
				part0 |= (b & 127) << 7;
				if (b & 128 || this.noAssert && typeof b === "undefined") {
					b = this.buffer[offset++];
					part0 |= (b & 127) << 14;
					if (b & 128 || this.noAssert && typeof b === "undefined") {
						b = this.buffer[offset++];
						part0 |= (b & 127) << 21;
						if (b & 128 || this.noAssert && typeof b === "undefined") {
							b = this.buffer[offset++];
							part1 = b & 127;
							if (b & 128 || this.noAssert && typeof b === "undefined") {
								b = this.buffer[offset++];
								part1 |= (b & 127) << 7;
								if (b & 128 || this.noAssert && typeof b === "undefined") {
									b = this.buffer[offset++];
									part1 |= (b & 127) << 14;
									if (b & 128 || this.noAssert && typeof b === "undefined") {
										b = this.buffer[offset++];
										part1 |= (b & 127) << 21;
										if (b & 128 || this.noAssert && typeof b === "undefined") {
											b = this.buffer[offset++];
											part2 = b & 127;
											if (b & 128 || this.noAssert && typeof b === "undefined") {
												b = this.buffer[offset++];
												part2 |= (b & 127) << 7;
												if (b & 128 || this.noAssert && typeof b === "undefined") throw Error("Buffer overrun");
											}
										}
									}
								}
							}
						}
					}
				}
			}
			var value = Long.fromBits(part0 | part1 << 28, part1 >>> 4 | part2 << 24, false);
			if (relative) {
				this.offset = offset;
				return value;
			} else return {
				"value": value,
				"length": offset - start
			};
		};
		/**
		
		* Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
		
		* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
		
		*  read if omitted.
		
		* @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
		
		*  the actual number of bytes read.
		
		* @throws {Error} If it's not a valid varint
		
		* @expose
		
		*/
		ByteBufferPrototype.readVarint64ZigZag = function(offset) {
			var val = this.readVarint64(offset);
			if (val && val["value"] instanceof Long) val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
else val = ByteBuffer.zigZagDecode64(val);
			return val;
		};
	}
	/**
	
	* Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
	
	*  characters itself.
	
	* @param {string} str String to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  contained in `str` + 1 if omitted.
	
	* @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
	
	* @expose
	
	*/
	ByteBufferPrototype.writeCString = function(str, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		var i, k = str.length;
		if (!this.noAssert) {
			if (typeof str !== "string") throw TypeError("Illegal str: Not a string");
			for (i = 0; i < k; ++i) if (str.charCodeAt(i) === 0) throw RangeError("Illegal str: Contains NULL-characters");
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		k = Buffer$1.byteLength(str, "utf8");
		offset += k + 1;
		var capacity12 = this.buffer.length;
		if (offset > capacity12) this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
		offset -= k + 1;
		offset += this.buffer.write(str, offset, k, "utf8");
		this.buffer[offset++] = 0;
		if (relative) {
			this.offset = offset;
			return this;
		}
		return k;
	};
	/**
	
	* Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
	
	*  itself.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  read if omitted.
	
	* @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	
	*  read and the actual number of bytes read.
	
	* @expose
	
	*/
	ByteBufferPrototype.readCString = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 1 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.length);
		}
		var start = offset, temp;
		do {
			if (offset >= this.buffer.length) throw RangeError("Index out of range: " + offset + " <= " + this.buffer.length);
			temp = this.buffer[offset++];
		} while (temp !== 0);
		var str = this.buffer.toString("utf8", start, offset - 1);
		if (relative) {
			this.offset = offset;
			return str;
		} else return {
			"string": str,
			"length": offset - start
		};
	};
	/**
	
	* Writes a length as uint32 prefixed UTF8 encoded string.
	
	* @param {string} str String to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
	
	* @expose
	
	* @see ByteBuffer#writeVarint32
	
	*/
	ByteBufferPrototype.writeIString = function(str, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof str !== "string") throw TypeError("Illegal str: Not a string");
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		var start = offset, k;
		k = Buffer$1.byteLength(str, "utf8");
		offset += 4 + k;
		var capacity13 = this.buffer.length;
		if (offset > capacity13) this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
		offset -= 4 + k;
		if (this.littleEndian) {
			this.buffer[offset + 3] = k >>> 24 & 255;
			this.buffer[offset + 2] = k >>> 16 & 255;
			this.buffer[offset + 1] = k >>> 8 & 255;
			this.buffer[offset] = k & 255;
		} else {
			this.buffer[offset] = k >>> 24 & 255;
			this.buffer[offset + 1] = k >>> 16 & 255;
			this.buffer[offset + 2] = k >>> 8 & 255;
			this.buffer[offset + 3] = k & 255;
		}
		offset += 4;
		offset += this.buffer.write(str, offset, k, "utf8");
		if (relative) {
			this.offset = offset;
			return this;
		}
		return offset - start;
	};
	/**
	
	* Reads a length as uint32 prefixed UTF8 encoded string.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  read if omitted.
	
	* @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	
	*  read and the actual number of bytes read.
	
	* @expose
	
	* @see ByteBuffer#readVarint32
	
	*/
	ByteBufferPrototype.readIString = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 4 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.length);
		}
		var start = offset;
		var len = this.readUint32(offset);
		var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
		offset += str["length"];
		if (relative) {
			this.offset = offset;
			return str["string"];
		} else return {
			"string": str["string"],
			"length": offset - start
		};
	};
	/**
	
	* Metrics representing number of UTF8 characters. Evaluates to `c`.
	
	* @type {string}
	
	* @const
	
	* @expose
	
	*/
	ByteBuffer.METRICS_CHARS = "c";
	/**
	
	* Metrics representing number of bytes. Evaluates to `b`.
	
	* @type {string}
	
	* @const
	
	* @expose
	
	*/
	ByteBuffer.METRICS_BYTES = "b";
	/**
	
	* Writes an UTF8 encoded string.
	
	* @param {string} str String to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
	
	* @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
	
	* @expose
	
	*/
	ByteBufferPrototype.writeUTF8String = function(str, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		var k;
		k = Buffer$1.byteLength(str, "utf8");
		offset += k;
		var capacity14 = this.buffer.length;
		if (offset > capacity14) this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
		offset -= k;
		offset += this.buffer.write(str, offset, k, "utf8");
		if (relative) {
			this.offset = offset;
			return this;
		}
		return k;
	};
	/**
	
	* Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
	
	* @function
	
	* @param {string} str String to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
	
	* @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
	
	* @expose
	
	*/
	ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;
	/**
	
	* Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
	
	*  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
	
	* @param {string} str String to calculate
	
	* @returns {number} Number of UTF8 characters
	
	* @expose
	
	*/
	ByteBuffer.calculateUTF8Chars = function(str) {
		return utfx.calculateUTF16asUTF8(stringSource(str))[0];
	};
	/**
	
	* Calculates the number of UTF8 bytes of a string.
	
	* @param {string} str String to calculate
	
	* @returns {number} Number of UTF8 bytes
	
	* @expose
	
	*/
	ByteBuffer.calculateUTF8Bytes = function(str) {
		if (typeof str !== "string") throw TypeError("Illegal argument: " + typeof str);
		return Buffer$1.byteLength(str, "utf8");
	};
	/**
	
	* Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
	
	* @function
	
	* @param {string} str String to calculate
	
	* @returns {number} Number of UTF8 bytes
	
	* @expose
	
	*/
	ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;
	/**
	
	* Reads an UTF8 encoded string.
	
	* @param {number} length Number of characters or bytes to read.
	
	* @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
	
	*  {@link ByteBuffer.METRICS_CHARS}.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  read if omitted.
	
	* @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	
	*  read and the actual number of bytes read.
	
	* @expose
	
	*/
	ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
		if (typeof metrics === "number") {
			offset = metrics;
			metrics = undefined;
		}
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (typeof metrics === "undefined") metrics = ByteBuffer.METRICS_CHARS;
		if (!this.noAssert) {
			if (typeof length !== "number" || length % 1 !== 0) throw TypeError("Illegal length: " + length + " (not an integer)");
			length |= 0;
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		var i = 0, start = offset, temp, sd;
		if (metrics === ByteBuffer.METRICS_CHARS) {
			sd = stringDestination();
			utfx.decodeUTF8(function() {
				return i < length && offset < this.limit ? this.buffer[offset++] : null;
			}.bind(this), function(cp) {
				++i;
				utfx.UTF8toUTF16(cp, sd);
			});
			if (i !== length) throw RangeError("Illegal range: Truncated data, " + i + " == " + length);
			if (relative) {
				this.offset = offset;
				return sd();
			} else return {
				"string": sd(),
				"length": offset - start
			};
		} else if (metrics === ByteBuffer.METRICS_BYTES) {
			if (!this.noAssert) {
				if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
				offset >>>= 0;
				if (offset < 0 || offset + length > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + length + ") <= " + this.buffer.length);
			}
			temp = this.buffer.toString("utf8", offset, offset + length);
			if (relative) {
				this.offset += length;
				return temp;
			} else return {
				"string": temp,
				"length": length
			};
		} else throw TypeError("Unsupported metrics: " + metrics);
	};
	/**
	
	* Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
	
	* @function
	
	* @param {number} length Number of characters or bytes to read
	
	* @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
	
	*  {@link ByteBuffer.METRICS_CHARS}.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  read if omitted.
	
	* @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	
	*  read and the actual number of bytes read.
	
	* @expose
	
	*/
	ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;
	/**
	
	* Writes a length as varint32 prefixed UTF8 encoded string.
	
	* @param {string} str String to write
	
	* @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
	
	* @expose
	
	* @see ByteBuffer#writeVarint32
	
	*/
	ByteBufferPrototype.writeVString = function(str, offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof str !== "string") throw TypeError("Illegal str: Not a string");
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		var start = offset, k, l;
		k = Buffer$1.byteLength(str, "utf8");
		l = ByteBuffer.calculateVarint32(k);
		offset += l + k;
		var capacity15 = this.buffer.length;
		if (offset > capacity15) this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
		offset -= l + k;
		offset += this.writeVarint32(k, offset);
		offset += this.buffer.write(str, offset, k, "utf8");
		if (relative) {
			this.offset = offset;
			return this;
		}
		return offset - start;
	};
	/**
	
	* Reads a length as varint32 prefixed UTF8 encoded string.
	
	* @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  read if omitted.
	
	* @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	
	*  read and the actual number of bytes read.
	
	* @expose
	
	* @see ByteBuffer#readVarint32
	
	*/
	ByteBufferPrototype.readVString = function(offset) {
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 1 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.length);
		}
		var start = offset;
		var len = this.readVarint32(offset);
		var str = this.readUTF8String(len["value"], ByteBuffer.METRICS_BYTES, offset += len["length"]);
		offset += str["length"];
		if (relative) {
			this.offset = offset;
			return str["string"];
		} else return {
			"string": str["string"],
			"length": offset - start
		};
	};
	/**
	
	* Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
	
	*  data's length.
	
	* @param {!ByteBuffer|!Buffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its
	
	* offsets will be modified according to the performed read operation.
	
	* @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
	
	* @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	* @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
	
	* @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
	
	*/
	ByteBufferPrototype.append = function(source, encoding, offset) {
		if (typeof encoding === "number" || typeof encoding !== "string") {
			offset = encoding;
			encoding = undefined;
		}
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding);
		var length = source.limit - source.offset;
		if (length <= 0) return this;
		offset += length;
		var capacity16 = this.buffer.length;
		if (offset > capacity16) this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
		offset -= length;
		source.buffer.copy(this.buffer, offset, source.offset, source.limit);
		source.offset += length;
		if (relative) this.offset += length;
		return this;
	};
	/**
	
	* Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
	
	specified offset up to the length of this ByteBuffer's data.
	
	* @param {!ByteBuffer} target Target ByteBuffer
	
	* @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  read if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	* @see ByteBuffer#append
	
	*/
	ByteBufferPrototype.appendTo = function(target, offset) {
		target.append(this, offset);
		return this;
	};
	/**
	
	* Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
	
	*  disable them if your code already makes sure that everything is valid.
	
	* @param {boolean} assert `true` to enable assertions, otherwise `false`
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.assert = function(assert) {
		this.noAssert = !assert;
		return this;
	};
	/**
	
	* Gets the capacity of this ByteBuffer's backing buffer.
	
	* @returns {number} Capacity of the backing buffer
	
	* @expose
	
	*/
	ByteBufferPrototype.capacity = function() {
		return this.buffer.length;
	};
	/**
	
	* Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
	
	*  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.clear = function() {
		this.offset = 0;
		this.limit = this.buffer.length;
		this.markedOffset = -1;
		return this;
	};
	/**
	
	* Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
	
	*  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
	
	* @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
	
	* @returns {!ByteBuffer} Cloned instance
	
	* @expose
	
	*/
	ByteBufferPrototype.clone = function(copy) {
		var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
		if (copy) {
			var buffer$1 = new Buffer$1(this.buffer.length);
			this.buffer.copy(buffer$1);
			bb.buffer = buffer$1;
		} else bb.buffer = this.buffer;
		bb.offset = this.offset;
		bb.markedOffset = this.markedOffset;
		bb.limit = this.limit;
		return bb;
	};
	/**
	
	* Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
	
	*  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
	
	*  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
	
	* @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
	
	* @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.compact = function(begin, end) {
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		if (!this.noAssert) {
			if (typeof begin !== "number" || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
			begin >>>= 0;
			if (typeof end !== "number" || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
			end >>>= 0;
			if (begin < 0 || begin > end || end > this.buffer.length) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.length);
		}
		if (begin === 0 && end === this.buffer.length) return this;
		var len = end - begin;
		if (len === 0) {
			this.buffer = EMPTY_BUFFER;
			if (this.markedOffset >= 0) this.markedOffset -= begin;
			this.offset = 0;
			this.limit = 0;
			return this;
		}
		var buffer$1 = new Buffer$1(len);
		this.buffer.copy(buffer$1, 0, begin, end);
		this.buffer = buffer$1;
		if (this.markedOffset >= 0) this.markedOffset -= begin;
		this.offset = 0;
		this.limit = len;
		return this;
	};
	/**
	
	* Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
	
	*  {@link ByteBuffer#limit}.
	
	* @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
	
	* @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
	
	* @returns {!ByteBuffer} Copy
	
	* @expose
	
	*/
	ByteBufferPrototype.copy = function(begin, end) {
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		if (!this.noAssert) {
			if (typeof begin !== "number" || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
			begin >>>= 0;
			if (typeof end !== "number" || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
			end >>>= 0;
			if (begin < 0 || begin > end || end > this.buffer.length) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.length);
		}
		if (begin === end) return new ByteBuffer(0, this.littleEndian, this.noAssert);
		var capacity = end - begin, bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
		bb.offset = 0;
		bb.limit = capacity;
		if (bb.markedOffset >= 0) bb.markedOffset -= begin;
		this.copyTo(bb, 0, begin, end);
		return bb;
	};
	/**
	
	* Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
	
	*  {@link ByteBuffer#limit}.
	
	* @param {!ByteBuffer} target Target ByteBuffer
	
	* @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
	
	*  by the number of bytes copied if omitted.
	
	* @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
	
	*  number of bytes copied if omitted.
	
	* @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
		var relative, targetRelative;
		if (!this.noAssert) {
			if (!ByteBuffer.isByteBuffer(target)) throw TypeError("Illegal target: Not a ByteBuffer");
		}
		targetOffset = (targetRelative = typeof targetOffset === "undefined") ? target.offset : targetOffset | 0;
		sourceOffset = (relative = typeof sourceOffset === "undefined") ? this.offset : sourceOffset | 0;
		sourceLimit = typeof sourceLimit === "undefined" ? this.limit : sourceLimit | 0;
		if (targetOffset < 0 || targetOffset > target.buffer.length) throw RangeError("Illegal target range: 0 <= " + targetOffset + " <= " + target.buffer.length);
		if (sourceOffset < 0 || sourceLimit > this.buffer.length) throw RangeError("Illegal source range: 0 <= " + sourceOffset + " <= " + this.buffer.length);
		var len = sourceLimit - sourceOffset;
		if (len === 0) return target;
		target.ensureCapacity(targetOffset + len);
		this.buffer.copy(target.buffer, targetOffset, sourceOffset, sourceLimit);
		if (relative) this.offset += len;
		if (targetRelative) target.offset += len;
		return this;
	};
	/**
	
	* Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
	
	*  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
	
	*  the required capacity will be used instead.
	
	* @param {number} capacity Required capacity
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.ensureCapacity = function(capacity) {
		var current = this.buffer.length;
		if (current < capacity) return this.resize((current *= 2) > capacity ? current : capacity);
		return this;
	};
	/**
	
	* Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
	
	*  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
	
	* @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
	
	* @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	
	*  written if omitted. defaults to {@link ByteBuffer#offset}.
	
	* @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	* @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
	
	*/
	ByteBufferPrototype.fill = function(value, begin, end) {
		var relative = typeof begin === "undefined";
		if (relative) begin = this.offset;
		if (typeof value === "string" && value.length > 0) value = value.charCodeAt(0);
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		if (!this.noAssert) {
			if (typeof value !== "number" || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
			value |= 0;
			if (typeof begin !== "number" || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
			begin >>>= 0;
			if (typeof end !== "number" || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
			end >>>= 0;
			if (begin < 0 || begin > end || end > this.buffer.length) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.length);
		}
		if (begin >= end) return this;
		this.buffer.fill(value, begin, end);
		begin = end;
		if (relative) this.offset = begin;
		return this;
	};
	/**
	
	* Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
	
	*  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.flip = function() {
		this.limit = this.offset;
		this.offset = 0;
		return this;
	};
	/**
	
	* Marks an offset on this ByteBuffer to be used later.
	
	* @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
	
	* @returns {!ByteBuffer} this
	
	* @throws {TypeError} If `offset` is not a valid number
	
	* @throws {RangeError} If `offset` is out of bounds
	
	* @see ByteBuffer#reset
	
	* @expose
	
	*/
	ByteBufferPrototype.mark = function(offset) {
		offset = typeof offset === "undefined" ? this.offset : offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		this.markedOffset = offset;
		return this;
	};
	/**
	
	* Sets the byte order.
	
	* @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.order = function(littleEndian) {
		if (!this.noAssert) {
			if (typeof littleEndian !== "boolean") throw TypeError("Illegal littleEndian: Not a boolean");
		}
		this.littleEndian = !!littleEndian;
		return this;
	};
	/**
	
	* Switches (to) little endian byte order.
	
	* @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.LE = function(littleEndian) {
		this.littleEndian = typeof littleEndian !== "undefined" ? !!littleEndian : true;
		return this;
	};
	/**
	
	* Switches (to) big endian byte order.
	
	* @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.BE = function(bigEndian) {
		this.littleEndian = typeof bigEndian !== "undefined" ? !bigEndian : false;
		return this;
	};
	/**
	
	* Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
	
	*  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
	
	*  will be resized and its contents moved accordingly.
	
	* @param {!ByteBuffer|string||!Buffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be modified
	
	*  according to the performed read operation.
	
	* @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
	
	* @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
	
	*  prepended if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	* @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
	
	* @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
	
	*/
	ByteBufferPrototype.prepend = function(source, encoding, offset) {
		if (typeof encoding === "number" || typeof encoding !== "string") {
			offset = encoding;
			encoding = undefined;
		}
		var relative = typeof offset === "undefined";
		if (relative) offset = this.offset;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
			offset >>>= 0;
			if (offset < 0 || offset + 0 > this.buffer.length) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.length);
		}
		if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding);
		var len = source.limit - source.offset;
		if (len <= 0) return this;
		var diff = len - offset;
		if (diff > 0) {
			var buffer$1 = new Buffer$1(this.buffer.length + diff);
			this.buffer.copy(buffer$1, len, offset, this.buffer.length);
			this.buffer = buffer$1;
			this.offset += diff;
			if (this.markedOffset >= 0) this.markedOffset += diff;
			this.limit += diff;
			offset += diff;
		}
		source.buffer.copy(this.buffer, offset - len, source.offset, source.limit);
		source.offset = source.limit;
		if (relative) this.offset -= len;
		return this;
	};
	/**
	
	* Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
	
	*  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
	
	*  will be resized and its contents moved accordingly.
	
	* @param {!ByteBuffer} target Target ByteBuffer
	
	* @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
	
	*  prepended if omitted.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	* @see ByteBuffer#prepend
	
	*/
	ByteBufferPrototype.prependTo = function(target, offset) {
		target.prepend(this, offset);
		return this;
	};
	/**
	
	* Prints debug information about this ByteBuffer's contents.
	
	* @param {function(string)=} out Output function to call, defaults to console.log
	
	* @expose
	
	*/
	ByteBufferPrototype.printDebug = function(out) {
		if (typeof out !== "function") out = console.log.bind(console);
		out(this.toString() + "\n" + "-------------------------------------------------------------------\n" + this.toDebug(
			/* columns */
			true
));
	};
	/**
	
	* Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
	
	*  {@link ByteBuffer#limit}, so this returns `limit - offset`.
	
	* @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
	
	* @expose
	
	*/
	ByteBufferPrototype.remaining = function() {
		return this.limit - this.offset;
	};
	/**
	
	* Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
	
	*  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
	
	*  marked, sets `offset = 0`.
	
	* @returns {!ByteBuffer} this
	
	* @see ByteBuffer#mark
	
	* @expose
	
	*/
	ByteBufferPrototype.reset = function() {
		if (this.markedOffset >= 0) {
			this.offset = this.markedOffset;
			this.markedOffset = -1;
		} else this.offset = 0;
		return this;
	};
	/**
	
	* Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
	
	*  large or larger.
	
	* @param {number} capacity Capacity required
	
	* @returns {!ByteBuffer} this
	
	* @throws {TypeError} If `capacity` is not a number
	
	* @throws {RangeError} If `capacity < 0`
	
	* @expose
	
	*/
	ByteBufferPrototype.resize = function(capacity) {
		if (!this.noAssert) {
			if (typeof capacity !== "number" || capacity % 1 !== 0) throw TypeError("Illegal capacity: " + capacity + " (not an integer)");
			capacity |= 0;
			if (capacity < 0) throw RangeError("Illegal capacity: 0 <= " + capacity);
		}
		if (this.buffer.length < capacity) {
			var buffer$1 = new Buffer$1(capacity);
			this.buffer.copy(buffer$1);
			this.buffer = buffer$1;
		}
		return this;
	};
	/**
	
	* Reverses this ByteBuffer's contents.
	
	* @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
	
	* @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.reverse = function(begin, end) {
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		if (!this.noAssert) {
			if (typeof begin !== "number" || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
			begin >>>= 0;
			if (typeof end !== "number" || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
			end >>>= 0;
			if (begin < 0 || begin > end || end > this.buffer.length) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.length);
		}
		if (begin === end) return this;
		Array.prototype.reverse.call(this.buffer.slice(begin, end));
		return this;
	};
	/**
	
	* Skips the next `length` bytes. This will just advance
	
	* @param {number} length Number of bytes to skip. May also be negative to move the offset back.
	
	* @returns {!ByteBuffer} this
	
	* @expose
	
	*/
	ByteBufferPrototype.skip = function(length) {
		if (!this.noAssert) {
			if (typeof length !== "number" || length % 1 !== 0) throw TypeError("Illegal length: " + length + " (not an integer)");
			length |= 0;
		}
		var offset = this.offset + length;
		if (!this.noAssert) {
			if (offset < 0 || offset > this.buffer.length) throw RangeError("Illegal length: 0 <= " + this.offset + " + " + length + " <= " + this.buffer.length);
		}
		this.offset = offset;
		return this;
	};
	/**
	
	* Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
	
	* @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
	
	* @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
	
	* @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
	
	* @expose
	
	*/
	ByteBufferPrototype.slice = function(begin, end) {
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		if (!this.noAssert) {
			if (typeof begin !== "number" || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
			begin >>>= 0;
			if (typeof end !== "number" || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
			end >>>= 0;
			if (begin < 0 || begin > end || end > this.buffer.length) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.length);
		}
		var bb = this.clone();
		bb.offset = begin;
		bb.limit = end;
		return bb;
	};
	/**
	
	* Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
	
	*  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
	
	* @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
	
	*  possible. Defaults to `false`
	
	* @returns {!Buffer} Contents as a Buffer
	
	* @expose
	
	*/
	ByteBufferPrototype.toBuffer = function(forceCopy) {
		var offset = this.offset, limit = this.limit;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: Not an integer");
			offset >>>= 0;
			if (typeof limit !== "number" || limit % 1 !== 0) throw TypeError("Illegal limit: Not an integer");
			limit >>>= 0;
			if (offset < 0 || offset > limit || limit > this.buffer.length) throw RangeError("Illegal range: 0 <= " + offset + " <= " + limit + " <= " + this.buffer.length);
		}
		if (forceCopy) {
			var buffer$1 = new Buffer$1(limit - offset);
			this.buffer.copy(buffer$1, 0, offset, limit);
			return buffer$1;
		} else if (offset === 0 && limit === this.buffer.length) return this.buffer;
else return this.buffer.slice(offset, limit);
	};
	/**
	
	* Returns a copy of the backing buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
	
	*  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
	
	* @returns {!ArrayBuffer} Contents as an ArrayBuffer
	
	*/
	ByteBufferPrototype.toArrayBuffer = function() {
		var offset = this.offset, limit = this.limit;
		if (!this.noAssert) {
			if (typeof offset !== "number" || offset % 1 !== 0) throw TypeError("Illegal offset: Not an integer");
			offset >>>= 0;
			if (typeof limit !== "number" || limit % 1 !== 0) throw TypeError("Illegal limit: Not an integer");
			limit >>>= 0;
			if (offset < 0 || offset > limit || limit > this.buffer.length) throw RangeError("Illegal range: 0 <= " + offset + " <= " + limit + " <= " + this.buffer.length);
		}
		var ab = new ArrayBuffer(limit - offset);
		if (memcpy) memcpy(ab, 0, this.buffer, offset, limit);
else {
			var dst = new Uint8Array(ab);
			for (var i = offset; i < limit; ++i) dst[i - offset] = this.buffer[i];
		}
		return ab;
	};
	/**
	
	* Converts the ByteBuffer's contents to a string.
	
	* @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
	
	*  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
	
	*  highlighted offsets.
	
	* @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
	
	* @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
	
	* @returns {string} String representation
	
	* @throws {Error} If `encoding` is invalid
	
	* @expose
	
	*/
	ByteBufferPrototype.toString = function(encoding, begin, end) {
		if (typeof encoding === "undefined") return "ByteBufferNB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";
		if (typeof encoding === "number") encoding = "utf8", begin = encoding, end = begin;
		switch (encoding) {
			case "utf8": return this.toUTF8(begin, end);
			case "base64": return this.toBase64(begin, end);
			case "hex": return this.toHex(begin, end);
			case "binary": return this.toBinary(begin, end);
			case "debug": return this.toDebug();
			case "columns": return this.toColumns();
			default: throw Error("Unsupported encoding: " + encoding);
		}
	};
	/**
	
	* Encodes this ByteBuffer's contents to a base64 encoded string.
	
	* @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
	
	* @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
	
	* @returns {string} Base64 encoded string
	
	* @throws {RangeError} If `begin` or `end` is out of bounds
	
	* @expose
	
	*/
	ByteBufferPrototype.toBase64 = function(begin, end) {
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		begin = begin | 0;
		end = end | 0;
		if (begin < 0 || end > this.capacity || begin > end) throw RangeError("begin, end");
		return this.buffer.toString("base64", begin, end);
	};
	/**
	
	* Decodes a base64 encoded string to a ByteBuffer.
	
	* @param {string} str String to decode
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @returns {!ByteBuffer} ByteBuffer
	
	* @expose
	
	*/
	ByteBuffer.fromBase64 = function(str, littleEndian) {
		return ByteBuffer.wrap(new Buffer$1(str, "base64"), littleEndian);
	};
	/**
	
	* Encodes a binary string to base64 like `window.btoa` does.
	
	* @param {string} str Binary string
	
	* @returns {string} Base64 encoded string
	
	* @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
	
	* @expose
	
	*/
	ByteBuffer.btoa = function(str) {
		return ByteBuffer.fromBinary(str).toBase64();
	};
	/**
	
	* Decodes a base64 encoded string to binary like `window.atob` does.
	
	* @param {string} b64 Base64 encoded string
	
	* @returns {string} Binary string
	
	* @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
	
	* @expose
	
	*/
	ByteBuffer.atob = function(b64) {
		return ByteBuffer.fromBase64(b64).toBinary();
	};
	/**
	
	* Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
	
	* @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
	
	* @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
	
	* @returns {string} Binary encoded string
	
	* @throws {RangeError} If `offset > limit`
	
	* @expose
	
	*/
	ByteBufferPrototype.toBinary = function(begin, end) {
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		begin |= 0;
		end |= 0;
		if (begin < 0 || end > this.capacity() || begin > end) throw RangeError("begin, end");
		return this.buffer.toString("binary", begin, end);
	};
	/**
	
	* Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
	
	* @param {string} str String to decode
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @returns {!ByteBuffer} ByteBuffer
	
	* @expose
	
	*/
	ByteBuffer.fromBinary = function(str, littleEndian) {
		return ByteBuffer.wrap(new Buffer$1(str, "binary"), littleEndian);
	};
	/**
	
	* Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
	
	* * `<` : offset,
	
	* * `'` : markedOffset,
	
	* * `>` : limit,
	
	* * `|` : offset and limit,
	
	* * `[` : offset and markedOffset,
	
	* * `]` : markedOffset and limit,
	
	* * `!` : offset, markedOffset and limit
	
	* @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
	
	* @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
	
	* @expose
	
	* @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
	
	* @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
	
	* @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
	
	* @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
	
	*/
	ByteBufferPrototype.toDebug = function(columns) {
		var i = -1, k = this.buffer.length, b, hex = "", asc = "", out = "";
		while (i < k) {
			if (i !== -1) {
				b = this.buffer[i];
				if (b < 16) hex += "0" + b.toString(16).toUpperCase();
else hex += b.toString(16).toUpperCase();
				if (columns) asc += b > 32 && b < 127 ? String.fromCharCode(b) : ".";
			}
			++i;
			if (columns) {
				if (i > 0 && i % 16 === 0 && i !== k) {
					while (hex.length < 51) hex += " ";
					out += hex + asc + "\n";
					hex = asc = "";
				}
			}
			if (i === this.offset && i === this.limit) hex += i === this.markedOffset ? "!" : "|";
else if (i === this.offset) hex += i === this.markedOffset ? "[" : "<";
else if (i === this.limit) hex += i === this.markedOffset ? "]" : ">";
else hex += i === this.markedOffset ? "'" : columns || i !== 0 && i !== k ? " " : "";
		}
		if (columns && hex !== " ") {
			while (hex.length < 51) hex += " ";
			out += hex + asc + "\n";
		}
		return columns ? out : hex;
	};
	/**
	
	* Decodes a hex encoded string with marked offsets to a ByteBuffer.
	
	* @param {string} str Debug string to decode (not be generated with `columns = true`)
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_NOASSERT}.
	
	* @returns {!ByteBuffer} ByteBuffer
	
	* @expose
	
	* @see ByteBuffer#toDebug
	
	*/
	ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
		var k = str.length, bb = new ByteBuffer((k + 1) / 3 | 0, littleEndian, noAssert);
		var i = 0, j = 0, ch, b, rs = false, ho = false, hm = false, hl = false, fail = false;
		while (i < k) {
			switch (ch = str.charAt(i++)) {
				case "!":
					if (!noAssert) {
						if (ho || hm || hl) {
							fail = true;
							break;
						}
						ho = hm = hl = true;
					}
					bb.offset = bb.markedOffset = bb.limit = j;
					rs = false;
					break;
				case "|":
					if (!noAssert) {
						if (ho || hl) {
							fail = true;
							break;
						}
						ho = hl = true;
					}
					bb.offset = bb.limit = j;
					rs = false;
					break;
				case "[":
					if (!noAssert) {
						if (ho || hm) {
							fail = true;
							break;
						}
						ho = hm = true;
					}
					bb.offset = bb.markedOffset = j;
					rs = false;
					break;
				case "<":
					if (!noAssert) {
						if (ho) {
							fail = true;
							break;
						}
						ho = true;
					}
					bb.offset = j;
					rs = false;
					break;
				case "]":
					if (!noAssert) {
						if (hl || hm) {
							fail = true;
							break;
						}
						hl = hm = true;
					}
					bb.limit = bb.markedOffset = j;
					rs = false;
					break;
				case ">":
					if (!noAssert) {
						if (hl) {
							fail = true;
							break;
						}
						hl = true;
					}
					bb.limit = j;
					rs = false;
					break;
				case "'":
					if (!noAssert) {
						if (hm) {
							fail = true;
							break;
						}
						hm = true;
					}
					bb.markedOffset = j;
					rs = false;
					break;
				case " ":
					rs = false;
					break;
				default:
					if (!noAssert) {
						if (rs) {
							fail = true;
							break;
						}
					}
					b = parseInt(ch + str.charAt(i++), 16);
					if (!noAssert) {
						if (isNaN(b) || b < 0 || b > 255) throw TypeError("Illegal str: Not a debug encoded string");
					}
					bb.buffer[j++] = b;
					rs = true;
			}
			if (fail) throw TypeError("Illegal str: Invalid symbol at " + i);
		}
		if (!noAssert) {
			if (!ho || !hl) throw TypeError("Illegal str: Missing offset or limit");
			if (j < bb.buffer.length) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + j + " < " + k);
		}
		return bb;
	};
	/**
	
	* Encodes this ByteBuffer's contents to a hex encoded string.
	
	* @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
	
	* @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
	
	* @returns {string} Hex encoded string
	
	* @expose
	
	*/
	ByteBufferPrototype.toHex = function(begin, end) {
		begin = typeof begin === "undefined" ? this.offset : begin;
		end = typeof end === "undefined" ? this.limit : end;
		if (!this.noAssert) {
			if (typeof begin !== "number" || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
			begin >>>= 0;
			if (typeof end !== "number" || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
			end >>>= 0;
			if (begin < 0 || begin > end || end > this.buffer.length) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.length);
		}
		return this.buffer.toString("hex", begin, end);
	};
	/**
	
	* Decodes a hex encoded string to a ByteBuffer.
	
	* @param {string} str String to decode
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_NOASSERT}.
	
	* @returns {!ByteBuffer} ByteBuffer
	
	* @expose
	
	*/
	ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
		if (!noAssert) {
			if (typeof str !== "string") throw TypeError("Illegal str: Not a string");
			if (str.length % 2 !== 0) throw TypeError("Illegal str: Length not a multiple of 2");
		}
		var bb = new ByteBuffer(0, littleEndian, true);
		bb.buffer = new Buffer$1(str, "hex");
		bb.limit = bb.buffer.length;
		return bb;
	};
	/**
	
	* utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
	
	* Released under the Apache License, Version 2.0
	
	* see: https://github.com/dcodeIO/utfx for details
	
	*/
	var utfx = function() {
		/**
		
		* utfx namespace.
		
		* @inner
		
		* @type {!Object.<string,*>}
		
		*/
		var utfx$1 = {};
		/**
		
		* Maximum valid code point.
		
		* @type {number}
		
		* @const
		
		*/
		utfx$1.MAX_CODEPOINT = 1114111;
		/**
		
		* Encodes UTF8 code points to UTF8 bytes.
		
		* @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
		
		*  respectively `null` if there are no more code points left or a single numeric code point.
		
		* @param {!function(number)} dst Bytes destination as a function successively called with the next byte
		
		*/
		utfx$1.encodeUTF8 = function(src, dst) {
			var cp = null;
			if (typeof src === "number") cp = src, src = function() {
				return null;
			};
			while (cp !== null || (cp = src()) !== null) {
				if (cp < 128) dst(cp & 127);
else if (cp < 2048) dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
else if (cp < 65536) dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
else dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
				cp = null;
			}
		};
		/**
		
		* Decodes UTF8 bytes to UTF8 code points.
		
		* @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
		
		*  are no more bytes left.
		
		* @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
		
		* @throws {RangeError} If a starting byte is invalid in UTF8
		
		* @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
		
		*  remaining bytes.
		
		*/
		utfx$1.decodeUTF8 = function(src, dst) {
			var a, b, c, d, fail = function(b$1) {
				b$1 = b$1.slice(0, b$1.indexOf(null));
				var err = Error(b$1.toString());
				err.name = "TruncatedError";
				err["bytes"] = b$1;
				throw err;
			};
			while ((a = src()) !== null) if ((a & 128) === 0) dst(a);
else if ((a & 224) === 192) (b = src()) === null && fail([a, b]), dst((a & 31) << 6 | b & 63);
else if ((a & 240) === 224) ((b = src()) === null || (c = src()) === null) && fail([
				a,
				b,
				c
			]), dst((a & 15) << 12 | (b & 63) << 6 | c & 63);
else if ((a & 248) === 240) ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([
				a,
				b,
				c,
				d
			]), dst((a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63);
else throw RangeError("Illegal starting byte: " + a);
		};
		/**
		
		* Converts UTF16 characters to UTF8 code points.
		
		* @param {!function():number|null} src Characters source as a function returning the next char code respectively
		
		*  `null` if there are no more characters left.
		
		* @param {!function(number)} dst Code points destination as a function successively called with each converted code
		
		*  point.
		
		*/
		utfx$1.UTF16toUTF8 = function(src, dst) {
			var c1, c2 = null;
			while (true) {
				if ((c1 = c2 !== null ? c2 : src()) === null) break;
				if (c1 >= 55296 && c1 <= 57343) {
					if ((c2 = src()) !== null) {
						if (c2 >= 56320 && c2 <= 57343) {
							dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
							c2 = null;
							continue;
						}
					}
				}
				dst(c1);
			}
			if (c2 !== null) dst(c2);
		};
		/**
		
		* Converts UTF8 code points to UTF16 characters.
		
		* @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
		
		*  respectively `null` if there are no more code points left or a single numeric code point.
		
		* @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
		
		* @throws {RangeError} If a code point is out of range
		
		*/
		utfx$1.UTF8toUTF16 = function(src, dst) {
			var cp = null;
			if (typeof src === "number") cp = src, src = function() {
				return null;
			};
			while (cp !== null || (cp = src()) !== null) {
				if (cp <= 65535) dst(cp);
else cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
				cp = null;
			}
		};
		/**
		
		* Converts and encodes UTF16 characters to UTF8 bytes.
		
		* @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
		
		*  if there are no more characters left.
		
		* @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
		
		*/
		utfx$1.encodeUTF16toUTF8 = function(src, dst) {
			utfx$1.UTF16toUTF8(src, function(cp) {
				utfx$1.encodeUTF8(cp, dst);
			});
		};
		/**
		
		* Decodes and converts UTF8 bytes to UTF16 characters.
		
		* @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
		
		*  are no more bytes left.
		
		* @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
		
		* @throws {RangeError} If a starting byte is invalid in UTF8
		
		* @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
		
		*/
		utfx$1.decodeUTF8toUTF16 = function(src, dst) {
			utfx$1.decodeUTF8(src, function(cp) {
				utfx$1.UTF8toUTF16(cp, dst);
			});
		};
		/**
		
		* Calculates the byte length of an UTF8 code point.
		
		* @param {number} cp UTF8 code point
		
		* @returns {number} Byte length
		
		*/
		utfx$1.calculateCodePoint = function(cp) {
			return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
		};
		/**
		
		* Calculates the number of UTF8 bytes required to store UTF8 code points.
		
		* @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
		
		*  `null` if there are no more code points left.
		
		* @returns {number} The number of UTF8 bytes required
		
		*/
		utfx$1.calculateUTF8 = function(src) {
			var cp, l = 0;
			while ((cp = src()) !== null) l += cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
			return l;
		};
		/**
		
		* Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
		
		* @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
		
		*  `null` if there are no more characters left.
		
		* @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
		
		*/
		utfx$1.calculateUTF16asUTF8 = function(src) {
			var n = 0, l = 0;
			utfx$1.UTF16toUTF8(src, function(cp) {
				++n;
				l += cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
			});
			return [n, l];
		};
		return utfx$1;
	}();
	/**
	
	* Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
	
	*  string.
	
	* @returns {string} Hex encoded string
	
	* @throws {RangeError} If `offset > limit`
	
	* @expose
	
	*/
	ByteBufferPrototype.toUTF8 = function(begin, end) {
		if (typeof begin === "undefined") begin = this.offset;
		if (typeof end === "undefined") end = this.limit;
		if (!this.noAssert) {
			if (typeof begin !== "number" || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
			begin >>>= 0;
			if (typeof end !== "number" || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
			end >>>= 0;
			if (begin < 0 || begin > end || end > this.buffer.length) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.length);
		}
		return this.buffer.toString("utf8", begin, end);
	};
	/**
	
	* Decodes an UTF8 encoded string to a ByteBuffer.
	
	* @param {string} str String to decode
	
	* @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_ENDIAN}.
	
	* @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	
	*  {@link ByteBuffer.DEFAULT_NOASSERT}.
	
	* @returns {!ByteBuffer} ByteBuffer
	
	* @expose
	
	*/
	ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
		if (!noAssert) {
			if (typeof str !== "string") throw TypeError("Illegal str: Not a string");
		}
		var bb = new ByteBuffer(0, littleEndian, noAssert);
		bb.buffer = new Buffer$1(str, "utf8");
		bb.limit = bb.buffer.length;
		return bb;
	};
	/**
	
	* node-memcpy. This is an optional binding dependency and may not be present.
	
	* @function
	
	* @param {!(Buffer|ArrayBuffer|Uint8Array)} target Destination
	
	* @param {number|!(Buffer|ArrayBuffer)} targetStart Destination start, defaults to 0.
	
	* @param {(!(Buffer|ArrayBuffer|Uint8Array)|number)=} source Source
	
	* @param {number=} sourceStart Source start, defaults to 0.
	
	* @param {number=} sourceEnd Source end, defaults to capacity.
	
	* @returns {number} Number of bytes copied
	
	* @throws {Error} If any index is out of bounds
	
	* @expose
	
	*/
	ByteBuffer.memcpy = memcpy;
	return ByteBuffer;
}();
var Locale;
(function(Locale$1) {
	Locale$1[Locale$1["zh_CHS"] = 4] = "zh_CHS";
	Locale$1[Locale$1["ar_SA"] = 1025] = "ar_SA";
	Locale$1[Locale$1["bg_BG"] = 1026] = "bg_BG";
	Locale$1[Locale$1["ca_ES"] = 1027] = "ca_ES";
	Locale$1[Locale$1["zh_TW"] = 1028] = "zh_TW";
	Locale$1[Locale$1["cs_CZ"] = 1029] = "cs_CZ";
	Locale$1[Locale$1["da_DK"] = 1030] = "da_DK";
	Locale$1[Locale$1["de_DE"] = 1031] = "de_DE";
	Locale$1[Locale$1["el_GR"] = 1032] = "el_GR";
	Locale$1[Locale$1["en_US"] = 1033] = "en_US";
	Locale$1[Locale$1["fi_FI"] = 1035] = "fi_FI";
	Locale$1[Locale$1["fr_FR"] = 1036] = "fr_FR";
	Locale$1[Locale$1["he_IL"] = 1037] = "he_IL";
	Locale$1[Locale$1["hu_HU"] = 1038] = "hu_HU";
	Locale$1[Locale$1["is_IS"] = 1039] = "is_IS";
	Locale$1[Locale$1["it_IT"] = 1040] = "it_IT";
	Locale$1[Locale$1["ja_JP"] = 1041] = "ja_JP";
	Locale$1[Locale$1["ko_KR"] = 1042] = "ko_KR";
	Locale$1[Locale$1["nl_NL"] = 1043] = "nl_NL";
	Locale$1[Locale$1["nb_NO"] = 1044] = "nb_NO";
	Locale$1[Locale$1["pl_PL"] = 1045] = "pl_PL";
	Locale$1[Locale$1["pt_BR"] = 1046] = "pt_BR";
	Locale$1[Locale$1["rm_CH"] = 1047] = "rm_CH";
	Locale$1[Locale$1["ro_RO"] = 1048] = "ro_RO";
	Locale$1[Locale$1["ru_RU"] = 1049] = "ru_RU";
	Locale$1[Locale$1["hr_HR"] = 1050] = "hr_HR";
	Locale$1[Locale$1["sk_SK"] = 1051] = "sk_SK";
	Locale$1[Locale$1["sq_AL"] = 1052] = "sq_AL";
	Locale$1[Locale$1["sv_SE"] = 1053] = "sv_SE";
	Locale$1[Locale$1["th_TH"] = 1054] = "th_TH";
	Locale$1[Locale$1["tr_TR"] = 1055] = "tr_TR";
	Locale$1[Locale$1["ur_PK"] = 1056] = "ur_PK";
	Locale$1[Locale$1["id_ID"] = 1057] = "id_ID";
	Locale$1[Locale$1["uk_UA"] = 1058] = "uk_UA";
	Locale$1[Locale$1["be_BY"] = 1059] = "be_BY";
	Locale$1[Locale$1["sl_SI"] = 1060] = "sl_SI";
	Locale$1[Locale$1["et_EE"] = 1061] = "et_EE";
	Locale$1[Locale$1["lv_LV"] = 1062] = "lv_LV";
	Locale$1[Locale$1["lt_LT"] = 1063] = "lt_LT";
	Locale$1[Locale$1["tg_TJ"] = 1064] = "tg_TJ";
	Locale$1[Locale$1["fa_IR"] = 1065] = "fa_IR";
	Locale$1[Locale$1["vi_VN"] = 1066] = "vi_VN";
	Locale$1[Locale$1["hy_AM"] = 1067] = "hy_AM";
	Locale$1[Locale$1["eu_ES"] = 1069] = "eu_ES";
	Locale$1[Locale$1["wen_DE"] = 1070] = "wen_DE";
	Locale$1[Locale$1["mk_MK"] = 1071] = "mk_MK";
	Locale$1[Locale$1["tn_ZA"] = 1074] = "tn_ZA";
	Locale$1[Locale$1["xh_ZA"] = 1076] = "xh_ZA";
	Locale$1[Locale$1["zu_ZA"] = 1077] = "zu_ZA";
	Locale$1[Locale$1["af_ZA"] = 1078] = "af_ZA";
	Locale$1[Locale$1["ka_GE"] = 1079] = "ka_GE";
	Locale$1[Locale$1["fo_FO"] = 1080] = "fo_FO";
	Locale$1[Locale$1["hi_IN"] = 1081] = "hi_IN";
	Locale$1[Locale$1["mt_MT"] = 1082] = "mt_MT";
	Locale$1[Locale$1["se_NO"] = 1083] = "se_NO";
	Locale$1[Locale$1["ms_MY"] = 1086] = "ms_MY";
	Locale$1[Locale$1["kk_KZ"] = 1087] = "kk_KZ";
	Locale$1[Locale$1["ky_KG"] = 1088] = "ky_KG";
	Locale$1[Locale$1["sw_KE"] = 1089] = "sw_KE";
	Locale$1[Locale$1["tk_TM"] = 1090] = "tk_TM";
	Locale$1[Locale$1["tt_RU"] = 1092] = "tt_RU";
	Locale$1[Locale$1["bn_IN"] = 1093] = "bn_IN";
	Locale$1[Locale$1["pa_IN"] = 1094] = "pa_IN";
	Locale$1[Locale$1["gu_IN"] = 1095] = "gu_IN";
	Locale$1[Locale$1["or_IN"] = 1096] = "or_IN";
	Locale$1[Locale$1["ta_IN"] = 1097] = "ta_IN";
	Locale$1[Locale$1["te_IN"] = 1098] = "te_IN";
	Locale$1[Locale$1["kn_IN"] = 1099] = "kn_IN";
	Locale$1[Locale$1["ml_IN"] = 1100] = "ml_IN";
	Locale$1[Locale$1["as_IN"] = 1101] = "as_IN";
	Locale$1[Locale$1["mr_IN"] = 1102] = "mr_IN";
	Locale$1[Locale$1["sa_IN"] = 1103] = "sa_IN";
	Locale$1[Locale$1["mn_MN"] = 1104] = "mn_MN";
	Locale$1[Locale$1["bo_CN"] = 1105] = "bo_CN";
	Locale$1[Locale$1["cy_GB"] = 1106] = "cy_GB";
	Locale$1[Locale$1["kh_KH"] = 1107] = "kh_KH";
	Locale$1[Locale$1["lo_LA"] = 1108] = "lo_LA";
	Locale$1[Locale$1["my_MM"] = 1109] = "my_MM";
	Locale$1[Locale$1["gl_ES"] = 1110] = "gl_ES";
	Locale$1[Locale$1["kok_IN"] = 1111] = "kok_IN";
	Locale$1[Locale$1["syr_SY"] = 1114] = "syr_SY";
	Locale$1[Locale$1["si_LK"] = 1115] = "si_LK";
	Locale$1[Locale$1["am_ET"] = 1118] = "am_ET";
	Locale$1[Locale$1["ne_NP"] = 1121] = "ne_NP";
	Locale$1[Locale$1["fy_NL"] = 1122] = "fy_NL";
	Locale$1[Locale$1["ps_AF"] = 1123] = "ps_AF";
	Locale$1[Locale$1["fil_PH"] = 1124] = "fil_PH";
	Locale$1[Locale$1["div_MV"] = 1125] = "div_MV";
	Locale$1[Locale$1["ha_NG"] = 1128] = "ha_NG";
	Locale$1[Locale$1["yo_NG"] = 1130] = "yo_NG";
	Locale$1[Locale$1["quz_BO"] = 1131] = "quz_BO";
	Locale$1[Locale$1["ns_ZA"] = 1132] = "ns_ZA";
	Locale$1[Locale$1["ba_RU"] = 1133] = "ba_RU";
	Locale$1[Locale$1["lb_LU"] = 1134] = "lb_LU";
	Locale$1[Locale$1["kl_GL"] = 1135] = "kl_GL";
	Locale$1[Locale$1["ii_CN"] = 1144] = "ii_CN";
	Locale$1[Locale$1["arn_CL"] = 1146] = "arn_CL";
	Locale$1[Locale$1["moh_CA"] = 1148] = "moh_CA";
	Locale$1[Locale$1["br_FR"] = 1150] = "br_FR";
	Locale$1[Locale$1["ug_CN"] = 1152] = "ug_CN";
	Locale$1[Locale$1["mi_NZ"] = 1153] = "mi_NZ";
	Locale$1[Locale$1["oc_FR"] = 1154] = "oc_FR";
	Locale$1[Locale$1["co_FR"] = 1155] = "co_FR";
	Locale$1[Locale$1["gsw_FR"] = 1156] = "gsw_FR";
	Locale$1[Locale$1["sah_RU"] = 1157] = "sah_RU";
	Locale$1[Locale$1["qut_GT"] = 1158] = "qut_GT";
	Locale$1[Locale$1["rw_RW"] = 1159] = "rw_RW";
	Locale$1[Locale$1["wo_SN"] = 1160] = "wo_SN";
	Locale$1[Locale$1["gbz_AF"] = 1164] = "gbz_AF";
	Locale$1[Locale$1["ar_IQ"] = 2049] = "ar_IQ";
	Locale$1[Locale$1["zh_CN"] = 2052] = "zh_CN";
	Locale$1[Locale$1["de_CH"] = 2055] = "de_CH";
	Locale$1[Locale$1["en_GB"] = 2057] = "en_GB";
	Locale$1[Locale$1["es_MX"] = 2058] = "es_MX";
	Locale$1[Locale$1["fr_BE"] = 2060] = "fr_BE";
	Locale$1[Locale$1["it_CH"] = 2064] = "it_CH";
	Locale$1[Locale$1["nl_BE"] = 2067] = "nl_BE";
	Locale$1[Locale$1["nn_NO"] = 2068] = "nn_NO";
	Locale$1[Locale$1["pt_PT"] = 2070] = "pt_PT";
	Locale$1[Locale$1["sv_FI"] = 2077] = "sv_FI";
	Locale$1[Locale$1["ur_IN"] = 2080] = "ur_IN";
	Locale$1[Locale$1["az_AZ"] = 2092] = "az_AZ";
	Locale$1[Locale$1["dsb_DE"] = 2094] = "dsb_DE";
	Locale$1[Locale$1["se_SE"] = 2107] = "se_SE";
	Locale$1[Locale$1["ga_IE"] = 2108] = "ga_IE";
	Locale$1[Locale$1["ms_BN"] = 2110] = "ms_BN";
	Locale$1[Locale$1["uz_UZ"] = 2115] = "uz_UZ";
	Locale$1[Locale$1["mn_CN"] = 2128] = "mn_CN";
	Locale$1[Locale$1["bo_BT"] = 2129] = "bo_BT";
	Locale$1[Locale$1["iu_CA"] = 2141] = "iu_CA";
	Locale$1[Locale$1["tmz_DZ"] = 2143] = "tmz_DZ";
	Locale$1[Locale$1["quz_EC"] = 2155] = "quz_EC";
	Locale$1[Locale$1["ar_EG"] = 3073] = "ar_EG";
	Locale$1[Locale$1["zh_HK"] = 3076] = "zh_HK";
	Locale$1[Locale$1["de_AT"] = 3079] = "de_AT";
	Locale$1[Locale$1["en_AU"] = 3081] = "en_AU";
	Locale$1[Locale$1["es_ES"] = 3082] = "es_ES";
	Locale$1[Locale$1["fr_CA"] = 3084] = "fr_CA";
	Locale$1[Locale$1["sr_SP"] = 3098] = "sr_SP";
	Locale$1[Locale$1["se_FI"] = 3131] = "se_FI";
	Locale$1[Locale$1["quz_PE"] = 3179] = "quz_PE";
	Locale$1[Locale$1["ar_LY"] = 4097] = "ar_LY";
	Locale$1[Locale$1["zh_SG"] = 4100] = "zh_SG";
	Locale$1[Locale$1["de_LU"] = 4103] = "de_LU";
	Locale$1[Locale$1["en_CA"] = 4105] = "en_CA";
	Locale$1[Locale$1["es_GT"] = 4106] = "es_GT";
	Locale$1[Locale$1["fr_CH"] = 4108] = "fr_CH";
	Locale$1[Locale$1["hr_BA"] = 4122] = "hr_BA";
	Locale$1[Locale$1["smj_NO"] = 4155] = "smj_NO";
	Locale$1[Locale$1["ar_DZ"] = 5121] = "ar_DZ";
	Locale$1[Locale$1["zh_MO"] = 5124] = "zh_MO";
	Locale$1[Locale$1["de_LI"] = 5127] = "de_LI";
	Locale$1[Locale$1["en_NZ"] = 5129] = "en_NZ";
	Locale$1[Locale$1["es_CR"] = 5130] = "es_CR";
	Locale$1[Locale$1["fr_LU"] = 5132] = "fr_LU";
	Locale$1[Locale$1["smj_SE"] = 5179] = "smj_SE";
	Locale$1[Locale$1["ar_MA"] = 6145] = "ar_MA";
	Locale$1[Locale$1["en_IE"] = 6153] = "en_IE";
	Locale$1[Locale$1["es_PA"] = 6154] = "es_PA";
	Locale$1[Locale$1["fr_MC"] = 6156] = "fr_MC";
	Locale$1[Locale$1["sma_NO"] = 6203] = "sma_NO";
	Locale$1[Locale$1["ar_TN"] = 7169] = "ar_TN";
	Locale$1[Locale$1["en_ZA"] = 7177] = "en_ZA";
	Locale$1[Locale$1["es_DO"] = 7178] = "es_DO";
	Locale$1[Locale$1["sr_BA"] = 7194] = "sr_BA";
	Locale$1[Locale$1["sma_SE"] = 7227] = "sma_SE";
	Locale$1[Locale$1["ar_OM"] = 8193] = "ar_OM";
	Locale$1[Locale$1["en_JA"] = 8201] = "en_JA";
	Locale$1[Locale$1["es_VE"] = 8202] = "es_VE";
	Locale$1[Locale$1["bs_BA"] = 8218] = "bs_BA";
	Locale$1[Locale$1["sms_FI"] = 8251] = "sms_FI";
	Locale$1[Locale$1["ar_YE"] = 9217] = "ar_YE";
	Locale$1[Locale$1["en_CB"] = 9225] = "en_CB";
	Locale$1[Locale$1["es_CO"] = 9226] = "es_CO";
	Locale$1[Locale$1["smn_FI"] = 9275] = "smn_FI";
	Locale$1[Locale$1["ar_SY"] = 10241] = "ar_SY";
	Locale$1[Locale$1["en_BZ"] = 10249] = "en_BZ";
	Locale$1[Locale$1["es_PE"] = 10250] = "es_PE";
	Locale$1[Locale$1["ar_JO"] = 11265] = "ar_JO";
	Locale$1[Locale$1["en_TT"] = 11273] = "en_TT";
	Locale$1[Locale$1["es_AR"] = 11274] = "es_AR";
	Locale$1[Locale$1["ar_LB"] = 12289] = "ar_LB";
	Locale$1[Locale$1["en_ZW"] = 12297] = "en_ZW";
	Locale$1[Locale$1["es_EC"] = 12298] = "es_EC";
	Locale$1[Locale$1["ar_KW"] = 13313] = "ar_KW";
	Locale$1[Locale$1["en_PH"] = 13321] = "en_PH";
	Locale$1[Locale$1["es_CL"] = 13322] = "es_CL";
	Locale$1[Locale$1["ar_AE"] = 14337] = "ar_AE";
	Locale$1[Locale$1["es_UR"] = 14346] = "es_UR";
	Locale$1[Locale$1["ar_BH"] = 15361] = "ar_BH";
	Locale$1[Locale$1["es_PY"] = 15370] = "es_PY";
	Locale$1[Locale$1["ar_QA"] = 16385] = "ar_QA";
	Locale$1[Locale$1["es_BO"] = 16394] = "es_BO";
	Locale$1[Locale$1["en_MY"] = 17417] = "en_MY";
	Locale$1[Locale$1["es_SV"] = 17418] = "es_SV";
	Locale$1[Locale$1["en_IN"] = 18441] = "en_IN";
	Locale$1[Locale$1["es_HN"] = 18442] = "es_HN";
	Locale$1[Locale$1["es_NI"] = 19466] = "es_NI";
	Locale$1[Locale$1["es_PR"] = 20490] = "es_PR";
	Locale$1[Locale$1["es_US"] = 21514] = "es_US";
	Locale$1[Locale$1["zh_CHT"] = 31748] = "zh_CHT";
})(Locale || (Locale = {}));
function Xp(n, p) {
	return n.toString(16).padStart(p, "0").toUpperCase();
}
function xp(n, p) {
	return n.toString(16).padStart(p, "0");
}
function x2(n) {
	return xp(n, 2);
}
/**
* get an uppercase hex string of a number zero-padded to 4 digits
* @param n {number} the number
* @returns {string} 4-digit uppercase hex representation of the number
*/
function X4(n) {
	return Xp(n, 4);
}
/**
* get an uppercase hex string of a number zero-padded to 8 digits
* @param n {number} the number
* @returns {string}
*/
function X8(n) {
	return Xp(n, 8);
}
function name(tag) {
	return "__substg1.0_" + X4(tag.id) + X4(tag.type);
}
/**
* convert UTF-8 Uint8Array to string
* @param array {Uint8Array}
* @returns {string}
*/
function utf8ArrayToString(array) {
	return new TextDecoder().decode(array);
}
/**
* convert string to UTF-8 Uint8Array
* @param str {string}
* @returns {Uint8Array}
*/
function stringToUtf8Array(str) {
	return new TextEncoder().encode(str);
}
/**
* convert string to UTF-16LE Uint8Array
* @param str {string}
* @returns {Uint8Array|Uint8Array}
*/
function stringToUtf16LeArray(str) {
	const u16 = Uint16Array.from(str.split("").map((c) => c.charCodeAt(0)));
	return new Uint8Array(u16.buffer, u16.byteOffset, u16.byteLength);
}
/**
* convert a string to a Uint8Array with terminating 0 byte
* @throws if the string contains characters not in the ANSI range (0-255)
* @param str
*/
function stringToAnsiArray(str) {
	const codes = str.split("").map((c) => c.charCodeAt(0));
	if (codes.findIndex((c) => c > 255) > -1) throw new Error("can't encode ansi string with char codes > 255!");
	codes.push(0);
	return Uint8Array.from(codes);
}
/**
* convert a file name to its DOS 8.3 version.
* @param fileName {string} a file name (not a path!)
*/
function fileNameToDosFileName(fileName) {
	const parts = fileName.split(".");
	let name$1, extension;
	if (parts.length < 2) {
		name$1 = parts[0];
		extension = null;
	} else {
		name$1 = parts.slice(0, -1).join("");
		extension = parts[parts.length - 1];
	}
	if (name$1 !== "") name$1 = (name$1.length > 8 ? name$1.substring(0, 6) + "~1" : name$1).toUpperCase();
	if (extension != null) name$1 += "." + (extension.length > 3 ? extension.substring(0, 3) : extension).toUpperCase();
	return name$1;
}
/**
* turn a ByteBuffer into a Uint8Array, using the current offset as a limit.
* buf.limit will change to buf.offset, and its buf.offset will be reset to 0.
* @param buf {ByteBuffer} the buffer to convert
* @returns {Uint8Array} a new Uint8Array containing the
*/
function byteBufferAsUint8Array(buf) {
	buf.limit = buf.offset;
	buf.offset = 0;
	return new Uint8Array(buf.toBuffer(true));
}
/**
* make an new byte buffer with the correct settings
* @param otherBuffer {ByteBuffer | ArrayBuffer | Uint8Array} other buffer to wrap into a ByteBuffer
* @param initCap {number?} initial capacity. ignored if otherBuffer is given.
*/
function makeByteBuffer(initCap, otherBuffer) {
	if (initCap != null && initCap < 0) throw new Error("initCap must be non-negative!");
	return otherBuffer == null ? new bytebufferNode(initCap || 1, bytebufferNode.LITTLE_ENDIAN) : bytebufferNode.wrap(otherBuffer, null, bytebufferNode.LITTLE_ENDIAN);
}
function getPathExtension(p) {
	if (!p.includes(".")) return "";
	const parts = p.split(".");
	return "." + parts[parts.length - 1];
}
function isNullOrEmpty(str) {
	return !str || str === "";
}
function isNullOrWhiteSpace(str) {
	return str == null || str.trim() === "";
}
function localeId() {
	return Locale[getLang()];
}
function getLang() {
	return "en_US";
}
/**
* get the upper and lower 32 bits from a 64bit int in a bignum
*/
function bigInt64ToParts(num) {
	const u64 = BigInt.asUintN(64, num);
	const lower = Number(u64 & 2n ** 32n - 1n);
	const upper = Number(u64 / 2n ** 32n & 2n ** 32n - 1n);
	return {
		lower,
		upper
	};
}
/**
* create a 64bit int in a bignum from two 32bit ints in numbers
* @param lower
* @param upper
*/
function bigInt64FromParts(lower, upper) {
	return BigInt.asUintN(64, BigInt(lower) + BigInt(upper) * 2n ** 32n);
}
/** https://stackoverflow.com/a/15550284
* Convert a Microsoft OADate to ECMAScript Date
* Treat all values as local.
* OADate = number of days since 30 dec 1899 as a double value
* @param {string|number} oaDate - OADate value
* @returns {Date}
*/
function oADateToDate(oaDate) {
	const days = Math.floor(oaDate);
	const ms = Math.abs((oaDate - days) * 864e5);
	return new Date(1899, 11, 30 + days, 0, 0, 0, ms);
}
const FT_TICKS_PER_MS = 10000n;
const FILE_TIME_ZERO = new Date(Date.parse("01 Jan 1601 00:00:00 UTC"));
function fileTimeToDate(fileTime) {
	return new Date(FILE_TIME_ZERO.getTime() + Number(fileTime / FT_TICKS_PER_MS));
}
function dateToFileTime(date) {
	const msSinceFileTimeEpoch = BigInt(date.getTime()) - BigInt(FILE_TIME_ZERO.getTime());
	const result = msSinceFileTimeEpoch * FT_TICKS_PER_MS;
	return result;
}
var cfb = createCommonjsModule(function(module) {
	var Base64 = function make_b64() {
		var map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		return {
			encode: function(input) {
				var o = "";
				var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
				for (var i = 0; i < input.length;) {
					c1 = input.charCodeAt(i++);
					e1 = c1 >> 2;
					c2 = input.charCodeAt(i++);
					e2 = (c1 & 3) << 4 | c2 >> 4;
					c3 = input.charCodeAt(i++);
					e3 = (c2 & 15) << 2 | c3 >> 6;
					e4 = c3 & 63;
					if (isNaN(c2)) e3 = e4 = 64;
else if (isNaN(c3)) e4 = 64;
					o += map.charAt(e1) + map.charAt(e2) + map.charAt(e3) + map.charAt(e4);
				}
				return o;
			},
			decode: function b64_decode(input) {
				var o = "";
				var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
				input = input.replace(/[^\w\+\/\=]/g, "");
				for (var i = 0; i < input.length;) {
					e1 = map.indexOf(input.charAt(i++));
					e2 = map.indexOf(input.charAt(i++));
					c1 = e1 << 2 | e2 >> 4;
					o += String.fromCharCode(c1);
					e3 = map.indexOf(input.charAt(i++));
					c2 = (e2 & 15) << 4 | e3 >> 2;
					if (e3 !== 64) o += String.fromCharCode(c2);
					e4 = map.indexOf(input.charAt(i++));
					c3 = (e3 & 3) << 6 | e4;
					if (e4 !== 64) o += String.fromCharCode(c3);
				}
				return o;
			}
		};
	}();
	var has_buf = typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && process.versions.node;
	var Buffer_from = function() {};
	if (typeof Buffer !== "undefined") {
		var nbfs = !Buffer.from;
		if (!nbfs) try {
			Buffer.from("foo", "utf8");
		} catch (e) {
			nbfs = true;
		}
		Buffer_from = nbfs ? function(buf, enc) {
			return enc ? new Buffer(buf, enc) : new Buffer(buf);
		} : Buffer.from.bind(Buffer);
		if (!Buffer.alloc) Buffer.alloc = function(n) {
			var b = new Buffer(n);
			b.fill(0);
			return b;
		};
		if (!Buffer.allocUnsafe) Buffer.allocUnsafe = function(n) {
			return new Buffer(n);
		};
	}
	function new_raw_buf(len) {
		return has_buf ? Buffer.alloc(len) : new Array(len);
	}
	function new_unsafe_buf(len) {
		return has_buf ? Buffer.allocUnsafe(len) : new Array(len);
	}
	var s2a = function s2a$1(s) {
		if (has_buf) return Buffer_from(s, "binary");
		return s.split("").map(function(x) {
			return x.charCodeAt(0) & 255;
		});
	};
	var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
	var __toBuffer = function(bufs) {
		var x = [];
		for (var i = 0; i < bufs[0].length; ++i) x.push.apply(x, bufs[0][i]);
		return x;
	};
	var ___toBuffer = __toBuffer;
	var __utf16le = function(b, s, e) {
		var ss = [];
		for (var i = s; i < e; i += 2) ss.push(String.fromCharCode(__readUInt16LE(b, i)));
		return ss.join("").replace(chr0, "");
	};
	var ___utf16le = __utf16le;
	var __hexlify = function(b, s, l) {
		var ss = [];
		for (var i = s; i < s + l; ++i) ss.push(("0" + b[i].toString(16)).slice(-2));
		return ss.join("");
	};
	var ___hexlify = __hexlify;
	var __bconcat = function(bufs) {
		if (Array.isArray(bufs[0])) return [].concat.apply([], bufs);
		var maxlen = 0, i = 0;
		for (i = 0; i < bufs.length; ++i) maxlen += bufs[i].length;
		var o = new Uint8Array(maxlen);
		for (i = 0, maxlen = 0; i < bufs.length; maxlen += bufs[i].length, ++i) o.set(bufs[i], maxlen);
		return o;
	};
	var bconcat = __bconcat;
	if (has_buf) {
		__utf16le = function(b, s, e) {
			if (!Buffer.isBuffer(b)) return ___utf16le(b, s, e);
			return b.toString("utf16le", s, e).replace(chr0, "");
		};
		__hexlify = function(b, s, l) {
			return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
		};
		__toBuffer = function(bufs) {
			return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs);
		};
		s2a = function(s) {
			return Buffer_from(s, "binary");
		};
		bconcat = function(bufs) {
			return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : __bconcat(bufs);
		};
	}
	var __readUInt8 = function(b, idx) {
		return b[idx];
	};
	var __readUInt16LE = function(b, idx) {
		return b[idx + 1] * 256 + b[idx];
	};
	var __readInt16LE = function(b, idx) {
		var u = b[idx + 1] * 256 + b[idx];
		return u < 32768 ? u : (65535 - u + 1) * -1;
	};
	var __readUInt32LE = function(b, idx) {
		return b[idx + 3] * 16777216 + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
	};
	var __readInt32LE = function(b, idx) {
		return (b[idx + 3] << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
	};
	function ReadShift(size, t) {
		var oI, oS, type = 0;
		switch (size) {
			case 1:
				oI = __readUInt8(this, this.l);
				break;
			case 2:
				oI = (t !== "i" ? __readUInt16LE : __readInt16LE)(this, this.l);
				break;
			case 4:
				oI = __readInt32LE(this, this.l);
				break;
			case 16:
				type = 2;
				oS = __hexlify(this, this.l, size);
		}
		this.l += size;
		if (type === 0) return oI;
		return oS;
	}
	var __writeUInt32LE = function(b, val, idx) {
		b[idx] = val & 255;
		b[idx + 1] = val >>> 8 & 255;
		b[idx + 2] = val >>> 16 & 255;
		b[idx + 3] = val >>> 24 & 255;
	};
	var __writeInt32LE = function(b, val, idx) {
		b[idx] = val & 255;
		b[idx + 1] = val >> 8 & 255;
		b[idx + 2] = val >> 16 & 255;
		b[idx + 3] = val >> 24 & 255;
	};
	function WriteShift(t, val, f) {
		var size = 0, i = 0;
		switch (f) {
			case "hex":
				for (; i < t; ++i) this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
				return this;
			case "utf16le":
				var end = this.l + t;
				for (i = 0; i < Math.min(val.length, t); ++i) {
					var cc = val.charCodeAt(i);
					this[this.l++] = cc & 255;
					this[this.l++] = cc >> 8;
				}
				while (this.l < end) this[this.l++] = 0;
				return this;
		}
		switch (t) {
			case 1:
				size = 1;
				this[this.l] = val & 255;
				break;
			case 2:
				size = 2;
				this[this.l] = val & 255;
				val >>>= 8;
				this[this.l + 1] = val & 255;
				break;
			case 4:
				size = 4;
				__writeUInt32LE(this, val, this.l);
				break;
			case -4:
				size = 4;
				__writeInt32LE(this, val, this.l);
				break;
		}
		this.l += size;
		return this;
	}
	function CheckField(hexstr, fld) {
		var m = __hexlify(this, this.l, hexstr.length >> 1);
		if (m !== hexstr) throw new Error(fld + "Expected " + hexstr + " saw " + m);
		this.l += hexstr.length >> 1;
	}
	function prep_blob(blob, pos) {
		blob.l = pos;
		blob.read_shift = ReadShift;
		blob.chk = CheckField;
		blob.write_shift = WriteShift;
	}
	function new_buf(sz) {
		var o = new_raw_buf(sz);
		prep_blob(o, 0);
		return o;
	}
	var CRC32;
	(function(factory) {
		factory(CRC32 = {});
	})(function(CRC32$1) {
		CRC32$1.version = "1.2.0";
		function signed_crc_table() {
			var c = 0, table = new Array(256);
			for (var n = 0; n != 256; ++n) {
				c = n;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				table[n] = c;
			}
			return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
		}
		var T = signed_crc_table();
		function crc32_bstr(bstr, seed) {
			var C = seed ^ -1, L = bstr.length - 1;
			for (var i = 0; i < L;) {
				C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
				C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
			}
			if (i === L) C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i)) & 255];
			return C ^ -1;
		}
		function crc32_buf(buf, seed) {
			if (buf.length > 1e4) return crc32_buf_8(buf, seed);
			var C = seed ^ -1, L = buf.length - 3;
			for (var i = 0; i < L;) {
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
			}
			while (i < L + 3) C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
			return C ^ -1;
		}
		function crc32_buf_8(buf, seed) {
			var C = seed ^ -1, L = buf.length - 7;
			for (var i = 0; i < L;) {
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
				C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
			}
			while (i < L + 7) C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
			return C ^ -1;
		}
		function crc32_str(str, seed) {
			var C = seed ^ -1;
			for (var i = 0, L = str.length, c, d; i < L;) {
				c = str.charCodeAt(i++);
				if (c < 128) C = C >>> 8 ^ T[(C ^ c) & 255];
else if (c < 2048) {
					C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 255];
					C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
				} else if (c >= 55296 && c < 57344) {
					c = (c & 1023) + 64;
					d = str.charCodeAt(i++) & 1023;
					C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 255];
					C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 255];
					C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
					C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 255];
				} else {
					C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 255];
					C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 255];
					C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
				}
			}
			return C ^ -1;
		}
		CRC32$1.table = T;
		CRC32$1.bstr = crc32_bstr;
		CRC32$1.buf = crc32_buf;
		CRC32$1.str = crc32_str;
	});
	var CFB = function _CFB() {
		var exports = {};
		exports.version = "1.2.1";
		function namecmp(l, r) {
			var L = l.split("/"), R = r.split("/");
			for (var i$1 = 0, c = 0, Z = Math.min(L.length, R.length); i$1 < Z; ++i$1) {
				if (c = L[i$1].length - R[i$1].length) return c;
				if (L[i$1] != R[i$1]) return L[i$1] < R[i$1] ? -1 : 1;
			}
			return L.length - R.length;
		}
		function dirname(p) {
			if (p.charAt(p.length - 1) == "/") return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
			var c = p.lastIndexOf("/");
			return c === -1 ? p : p.slice(0, c + 1);
		}
		function filename(p) {
			if (p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));
			var c = p.lastIndexOf("/");
			return c === -1 ? p : p.slice(c + 1);
		}
		function write_dos_date(buf, date) {
			if (typeof date === "string") date = new Date(date);
			var hms = date.getHours();
			hms = hms << 6 | date.getMinutes();
			hms = hms << 5 | date.getSeconds() >>> 1;
			buf.write_shift(2, hms);
			var ymd = date.getFullYear() - 1980;
			ymd = ymd << 4 | date.getMonth() + 1;
			ymd = ymd << 5 | date.getDate();
			buf.write_shift(2, ymd);
		}
		function parse_dos_date(buf) {
			var hms = buf.read_shift(2) & 65535;
			var ymd = buf.read_shift(2) & 65535;
			var val = new Date();
			var d = ymd & 31;
			ymd >>>= 5;
			var m = ymd & 15;
			ymd >>>= 4;
			val.setMilliseconds(0);
			val.setFullYear(ymd + 1980);
			val.setMonth(m - 1);
			val.setDate(d);
			var S = hms & 31;
			hms >>>= 5;
			var M = hms & 63;
			hms >>>= 6;
			val.setHours(hms);
			val.setMinutes(M);
			val.setSeconds(S << 1);
			return val;
		}
		function parse_extra_field(blob) {
			prep_blob(blob, 0);
			var o = {};
			var flags = 0;
			while (blob.l <= blob.length - 4) {
				var type = blob.read_shift(2);
				var sz = blob.read_shift(2), tgt = blob.l + sz;
				var p = {};
				switch (type) {
					case 21589:
						{
							flags = blob.read_shift(1);
							if (flags & 1) p.mtime = blob.read_shift(4);
							if (sz > 5) {
								if (flags & 2) p.atime = blob.read_shift(4);
								if (flags & 4) p.ctime = blob.read_shift(4);
							}
							if (p.mtime) p.mt = new Date(p.mtime * 1e3);
						}
						break;
				}
				blob.l = tgt;
				o[type] = p;
			}
			return o;
		}
		var fs$1;
		function get_fs() {
			return fs$1 || (fs$1 = require$$0$1);
		}
		function parse(file, options) {
			if (file[0] == 80 && file[1] == 75) return parse_zip(file, options);
			if ((file[0] | 32) == 109 && (file[1] | 32) == 105) return parse_mad(file, options);
			if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
			var mver = 3;
			var ssz = 512;
			var nmfs = 0;
			var difat_sec_cnt = 0;
			var dir_start = 0;
			var minifat_start = 0;
			var difat_start = 0;
			var fat_addrs = [];
			var blob = file.slice(0, 512);
			prep_blob(blob, 0);
			var mv = check_get_mver(blob);
			mver = mv[0];
			switch (mver) {
				case 3:
					ssz = 512;
					break;
				case 4:
					ssz = 4096;
					break;
				case 0: if (mv[1] == 0) return parse_zip(file, options);
				default: throw new Error("Major Version: Expected 3 or 4 saw " + mver);
			}
			if (ssz !== 512) {
				blob = file.slice(0, ssz);
				prep_blob(
					blob,
					28
					/* blob.l */
);
			}
			var header = file.slice(0, ssz);
			check_shifts(blob, mver);
			var dir_cnt = blob.read_shift(4, "i");
			if (mver === 3 && dir_cnt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
			blob.l += 4;
			dir_start = blob.read_shift(4, "i");
			blob.l += 4;
			blob.chk("00100000", "Mini Stream Cutoff Size: ");
			minifat_start = blob.read_shift(4, "i");
			nmfs = blob.read_shift(4, "i");
			difat_start = blob.read_shift(4, "i");
			difat_sec_cnt = blob.read_shift(4, "i");
			for (var q$1 = -1, j = 0; j < 109; ++j) {
				q$1 = blob.read_shift(4, "i");
				if (q$1 < 0) break;
				fat_addrs[j] = q$1;
			}
			/** Break the file up into sectors */
			var sectors = sectorify(file, ssz);
			sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
			/** Chains */
			var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
			sector_list[dir_start].name = "!Directory";
			if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
			sector_list[fat_addrs[0]].name = "!FAT";
			sector_list.fat_addrs = fat_addrs;
			sector_list.ssz = ssz;
			var files = {}, Paths = [], FileIndex = [], FullPaths = [];
			read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
			build_full_paths(FileIndex, FullPaths, Paths);
			Paths.shift();
			var o = {
				FileIndex,
				FullPaths
			};
			if (options && options.raw) o.raw = {
				header,
				sectors
			};
			return o;
		}
		function check_get_mver(blob) {
			if (blob[blob.l] == 80 && blob[blob.l + 1] == 75) return [0, 0];
			blob.chk(HEADER_SIGNATURE, "Header Signature: ");
			blob.l += 16;
			var mver = blob.read_shift(2, "u");
			return [blob.read_shift(2, "u"), mver];
		}
		function check_shifts(blob, mver) {
			var shift = 9;
			blob.l += 2;
			switch (shift = blob.read_shift(2)) {
				case 9:
					if (mver != 3) throw new Error("Sector Shift: Expected 9 saw " + shift);
					break;
				case 12:
					if (mver != 4) throw new Error("Sector Shift: Expected 12 saw " + shift);
					break;
				default: throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
			}
			blob.chk("0600", "Mini Sector Shift: ");
			blob.chk("000000000000", "Reserved: ");
		}
		/** Break the file up into sectors */
		function sectorify(file, ssz) {
			var nsectors = Math.ceil(file.length / ssz) - 1;
			var sectors = [];
			for (var i$1 = 1; i$1 < nsectors; ++i$1) sectors[i$1 - 1] = file.slice(i$1 * ssz, (i$1 + 1) * ssz);
			sectors[nsectors - 1] = file.slice(nsectors * ssz);
			return sectors;
		}
		function build_full_paths(FI, FP, Paths) {
			var i$1 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
			var dad = [], q$1 = [];
			for (; i$1 < pl; ++i$1) {
				dad[i$1] = q$1[i$1] = i$1;
				FP[i$1] = Paths[i$1];
			}
			for (; j < q$1.length; ++j) {
				i$1 = q$1[j];
				L = FI[i$1].L;
				R = FI[i$1].R;
				C = FI[i$1].C;
				if (dad[i$1] === i$1) {
					if (L !== -1 && dad[L] !== L) dad[i$1] = dad[L];
					if (R !== -1 && dad[R] !== R) dad[i$1] = dad[R];
				}
				if (C !== -1) dad[C] = i$1;
				if (L !== -1 && i$1 != dad[i$1]) {
					dad[L] = dad[i$1];
					if (q$1.lastIndexOf(L) < j) q$1.push(L);
				}
				if (R !== -1 && i$1 != dad[i$1]) {
					dad[R] = dad[i$1];
					if (q$1.lastIndexOf(R) < j) q$1.push(R);
				}
			}
			for (i$1 = 1; i$1 < pl; ++i$1) if (dad[i$1] === i$1) {
				if (R !== -1 && dad[R] !== R) dad[i$1] = dad[R];
else if (L !== -1 && dad[L] !== L) dad[i$1] = dad[L];
			}
			for (i$1 = 1; i$1 < pl; ++i$1) {
				if (FI[i$1].type === 0) continue;
				j = i$1;
				if (j != dad[j]) do {
					j = dad[j];
					FP[i$1] = FP[j] + "/" + FP[i$1];
				} while (j !== 0 && -1 !== dad[j] && j != dad[j]);
				dad[i$1] = -1;
			}
			FP[0] += "/";
			for (i$1 = 1; i$1 < pl; ++i$1) if (FI[i$1].type !== 2) FP[i$1] += "/";
		}
		function get_mfat_entry(entry, payload, mini) {
			var start = entry.start, size = entry.size;
			var o = [];
			var idx = start;
			while (mini && size > 0 && idx >= 0) {
				o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
				size -= MSSZ;
				idx = __readInt32LE(mini, idx * 4);
			}
			if (o.length === 0) return new_buf(0);
			return bconcat(o).slice(0, entry.size);
		}
		/** Chase down the rest of the DIFAT chain to build a comprehensive list
		DIFAT chains by storing the next sector number as the last 32 bits */
		function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
			var q$1 = ENDOFCHAIN;
			if (idx === ENDOFCHAIN) {
				if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
			} else if (idx !== -1) {
				var sector = sectors[idx], m = (ssz >>> 2) - 1;
				if (!sector) return;
				for (var i$1 = 0; i$1 < m; ++i$1) {
					if ((q$1 = __readInt32LE(sector, i$1 * 4)) === ENDOFCHAIN) break;
					fat_addrs.push(q$1);
				}
				sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
			}
		}
		/** Follow the linked list of sectors for a given starting point */
		function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
			var buf = [], buf_chain = [];
			if (!chkd) chkd = [];
			var modulus = ssz - 1, j = 0, jj = 0;
			for (j = start; j >= 0;) {
				chkd[j] = true;
				buf[buf.length] = j;
				buf_chain.push(sectors[j]);
				var addr = fat_addrs[Math.floor(j * 4 / ssz)];
				jj = j * 4 & modulus;
				if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
				if (!sectors[addr]) break;
				j = __readInt32LE(sectors[addr], jj);
			}
			return {
				nodes: buf,
				data: __toBuffer([buf_chain])
			};
		}
		/** Chase down the sector linked lists */
		function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
			var sl = sectors.length, sector_list = [];
			var chkd = [], buf = [], buf_chain = [];
			var modulus = ssz - 1, i$1 = 0, j = 0, k = 0, jj = 0;
			for (i$1 = 0; i$1 < sl; ++i$1) {
				buf = [];
				k = i$1 + dir_start;
				if (k >= sl) k -= sl;
				if (chkd[k]) continue;
				buf_chain = [];
				var seen = [];
				for (j = k; j >= 0;) {
					seen[j] = true;
					chkd[j] = true;
					buf[buf.length] = j;
					buf_chain.push(sectors[j]);
					var addr = fat_addrs[Math.floor(j * 4 / ssz)];
					jj = j * 4 & modulus;
					if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
					if (!sectors[addr]) break;
					j = __readInt32LE(sectors[addr], jj);
					if (seen[j]) break;
				}
				sector_list[k] = {
					nodes: buf,
					data: __toBuffer([buf_chain])
				};
			}
			return sector_list;
		}
		function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
			var minifat_store = 0, pl = Paths.length ? 2 : 0;
			var sector = sector_list[dir_start].data;
			var i$1 = 0, namelen = 0, name$1;
			for (; i$1 < sector.length; i$1 += 128) {
				var blob = sector.slice(i$1, i$1 + 128);
				prep_blob(blob, 64);
				namelen = blob.read_shift(2);
				name$1 = __utf16le(blob, 0, namelen - pl);
				Paths.push(name$1);
				var o = {
					name: name$1,
					type: blob.read_shift(1),
					color: blob.read_shift(1),
					L: blob.read_shift(4, "i"),
					R: blob.read_shift(4, "i"),
					C: blob.read_shift(4, "i"),
					clsid: blob.read_shift(16),
					state: blob.read_shift(4, "i"),
					start: 0,
					size: 0
				};
				var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
				if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);
				var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
				if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);
				o.start = blob.read_shift(4, "i");
				o.size = blob.read_shift(4, "i");
				if (o.size < 0 && o.start < 0) {
					o.size = o.type = 0;
					o.start = ENDOFCHAIN;
					o.name = "";
				}
				if (o.type === 5) {
					minifat_store = o.start;
					if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
				} else if (o.size >= 4096) {
					o.storage = "fat";
					if (sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
					sector_list[o.start].name = o.name;
					o.content = sector_list[o.start].data.slice(0, o.size);
				} else {
					o.storage = "minifat";
					if (o.size < 0) o.size = 0;
else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
				}
				if (o.content) prep_blob(o.content, 0);
				files[name$1] = o;
				FileIndex.push(o);
			}
		}
		function read_date(blob, offset) {
			return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
		}
		function read_file(filename$1, options) {
			get_fs();
			return parse(fs$1.readFileSync(filename$1), options);
		}
		function read(blob, options) {
			var type = options && options.type;
			if (!type) {
				if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
			}
			switch (type || "base64") {
				case "file": return read_file(blob, options);
				case "base64": return parse(s2a(Base64.decode(blob)), options);
				case "binary": return parse(s2a(blob), options);
			}
			return parse(blob, options);
		}
		function init_cfb(cfb$1, opts) {
			var o = opts || {}, root = o.root || "Root Entry";
			if (!cfb$1.FullPaths) cfb$1.FullPaths = [];
			if (!cfb$1.FileIndex) cfb$1.FileIndex = [];
			if (cfb$1.FullPaths.length !== cfb$1.FileIndex.length) throw new Error("inconsistent CFB structure");
			if (cfb$1.FullPaths.length === 0) {
				cfb$1.FullPaths[0] = root + "/";
				cfb$1.FileIndex[0] = {
					name: root,
					type: 5
				};
			}
			if (o.CLSID) cfb$1.FileIndex[0].clsid = o.CLSID;
			seed_cfb(cfb$1);
		}
		function seed_cfb(cfb$1) {
			var nm = "Sh33tJ5";
			if (CFB.find(cfb$1, "/" + nm)) return;
			var p = new_buf(4);
			p[0] = 55;
			p[1] = p[3] = 50;
			p[2] = 54;
			cfb$1.FileIndex.push({
				name: nm,
				type: 2,
				content: p,
				size: 4,
				L: 69,
				R: 69,
				C: 69
			});
			cfb$1.FullPaths.push(cfb$1.FullPaths[0] + nm);
			rebuild_cfb(cfb$1);
		}
		function rebuild_cfb(cfb$1, f) {
			init_cfb(cfb$1);
			var gc = false, s = false;
			for (var i$1 = cfb$1.FullPaths.length - 1; i$1 >= 0; --i$1) {
				var _file = cfb$1.FileIndex[i$1];
				switch (_file.type) {
					case 0:
						if (s) gc = true;
else {
							cfb$1.FileIndex.pop();
							cfb$1.FullPaths.pop();
						}
						break;
					case 1:
					case 2:
					case 5:
						s = true;
						if (isNaN(_file.R * _file.L * _file.C)) gc = true;
						if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
						break;
					default:
						gc = true;
						break;
				}
			}
			if (!gc && !f) return;
			var now = new Date(1987, 1, 19), j = 0;
			var fullPaths = Object.create ? Object.create(null) : {};
			var data = [];
			for (i$1 = 0; i$1 < cfb$1.FullPaths.length; ++i$1) {
				fullPaths[cfb$1.FullPaths[i$1]] = true;
				if (cfb$1.FileIndex[i$1].type === 0) continue;
				data.push([cfb$1.FullPaths[i$1], cfb$1.FileIndex[i$1]]);
			}
			for (i$1 = 0; i$1 < data.length; ++i$1) {
				var dad = dirname(data[i$1][0]);
				s = fullPaths[dad];
				if (!s) {
					data.push([dad, {
						name: filename(dad).replace("/", ""),
						type: 1,
						clsid: HEADER_CLSID,
						ct: now,
						mt: now,
						content: null
					}]);
					fullPaths[dad] = true;
				}
			}
			data.sort(function(x, y) {
				return namecmp(x[0], y[0]);
			});
			cfb$1.FullPaths = [];
			cfb$1.FileIndex = [];
			for (i$1 = 0; i$1 < data.length; ++i$1) {
				cfb$1.FullPaths[i$1] = data[i$1][0];
				cfb$1.FileIndex[i$1] = data[i$1][1];
			}
			for (i$1 = 0; i$1 < data.length; ++i$1) {
				var elt = cfb$1.FileIndex[i$1];
				var nm = cfb$1.FullPaths[i$1];
				elt.name = filename(nm).replace("/", "");
				elt.L = elt.R = elt.C = -(elt.color = 1);
				elt.size = elt.content ? elt.content.length : 0;
				elt.start = 0;
				elt.clsid = elt.clsid || HEADER_CLSID;
				if (i$1 === 0) {
					elt.C = data.length > 1 ? 1 : -1;
					elt.size = 0;
					elt.type = 5;
				} else if (nm.slice(-1) == "/") {
					for (j = i$1 + 1; j < data.length; ++j) if (dirname(cfb$1.FullPaths[j]) == nm) break;
					elt.C = j >= data.length ? -1 : j;
					for (j = i$1 + 1; j < data.length; ++j) if (dirname(cfb$1.FullPaths[j]) == dirname(nm)) break;
					elt.R = j >= data.length ? -1 : j;
					elt.type = 1;
				} else {
					if (dirname(cfb$1.FullPaths[i$1 + 1] || "") == dirname(nm)) elt.R = i$1 + 1;
					elt.type = 2;
				}
			}
		}
		function _write(cfb$1, options) {
			var _opts = options || {};
			if (_opts.fileType == "mad") return write_mad(cfb$1, _opts);
			rebuild_cfb(cfb$1);
			switch (_opts.fileType) {
				case "zip": return write_zip(cfb$1, _opts);
			}
			var L = function(cfb$2) {
				var mini_size = 0, fat_size = 0;
				for (var i$2 = 0; i$2 < cfb$2.FileIndex.length; ++i$2) {
					var file$1 = cfb$2.FileIndex[i$2];
					if (!file$1.content) continue;
					var flen$1 = file$1.content.length;
					if (flen$1 > 0) if (flen$1 < 4096) mini_size += flen$1 + 63 >> 6;
else fat_size += flen$1 + 511 >> 9;
				}
				var dir_cnt = cfb$2.FullPaths.length + 3 >> 2;
				var mini_cnt = mini_size + 7 >> 3;
				var mfat_cnt = mini_size + 127 >> 7;
				var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
				var fat_cnt = fat_base + 127 >> 7;
				var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
				while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
				var L$1 = [
					1,
					difat_cnt,
					fat_cnt,
					mfat_cnt,
					dir_cnt,
					fat_size,
					mini_size,
					0
				];
				cfb$2.FileIndex[0].size = mini_size << 6;
				L$1[7] = (cfb$2.FileIndex[0].start = L$1[0] + L$1[1] + L$1[2] + L$1[3] + L$1[4] + L$1[5]) + (L$1[6] + 7 >> 3);
				return L$1;
			}(cfb$1);
			var o = new_buf(L[7] << 9);
			var i$1 = 0, T = 0;
			{
				for (i$1 = 0; i$1 < 8; ++i$1) o.write_shift(1, HEADER_SIG[i$1]);
				for (i$1 = 0; i$1 < 8; ++i$1) o.write_shift(2, 0);
				o.write_shift(2, 62);
				o.write_shift(2, 3);
				o.write_shift(2, 65534);
				o.write_shift(2, 9);
				o.write_shift(2, 6);
				for (i$1 = 0; i$1 < 3; ++i$1) o.write_shift(2, 0);
				o.write_shift(4, 0);
				o.write_shift(4, L[2]);
				o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
				o.write_shift(4, 0);
				o.write_shift(4, 4096);
				o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
				o.write_shift(4, L[3]);
				o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
				o.write_shift(4, L[1]);
				for (i$1 = 0; i$1 < 109; ++i$1) o.write_shift(-4, i$1 < L[2] ? L[1] + i$1 : -1);
			}
			if (L[1]) for (T = 0; T < L[1]; ++T) {
				for (; i$1 < 236 + T * 127; ++i$1) o.write_shift(-4, i$1 < L[2] ? L[1] + i$1 : -1);
				o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
			}
			var chainit = function(w) {
				for (T += w; i$1 < T - 1; ++i$1) o.write_shift(-4, i$1 + 1);
				if (w) {
					++i$1;
					o.write_shift(-4, ENDOFCHAIN);
				}
			};
			T = i$1 = 0;
			for (T += L[1]; i$1 < T; ++i$1) o.write_shift(-4, consts.DIFSECT);
			for (T += L[2]; i$1 < T; ++i$1) o.write_shift(-4, consts.FATSECT);
			chainit(L[3]);
			chainit(L[4]);
			var j = 0, flen = 0;
			var file = cfb$1.FileIndex[0];
			for (; j < cfb$1.FileIndex.length; ++j) {
				file = cfb$1.FileIndex[j];
				if (!file.content) continue;
				flen = file.content.length;
				if (flen < 4096) continue;
				file.start = T;
				chainit(flen + 511 >> 9);
			}
			chainit(L[6] + 7 >> 3);
			while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
			T = i$1 = 0;
			for (j = 0; j < cfb$1.FileIndex.length; ++j) {
				file = cfb$1.FileIndex[j];
				if (!file.content) continue;
				flen = file.content.length;
				if (!flen || flen >= 4096) continue;
				file.start = T;
				chainit(flen + 63 >> 6);
			}
			while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
			for (i$1 = 0; i$1 < L[4] << 2; ++i$1) {
				var nm = cfb$1.FullPaths[i$1];
				if (!nm || nm.length === 0) {
					for (j = 0; j < 17; ++j) o.write_shift(4, 0);
					for (j = 0; j < 3; ++j) o.write_shift(4, -1);
					for (j = 0; j < 12; ++j) o.write_shift(4, 0);
					continue;
				}
				file = cfb$1.FileIndex[i$1];
				if (i$1 === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
				var _nm = i$1 === 0 && _opts.root || file.name;
				flen = 2 * (_nm.length + 1);
				o.write_shift(64, _nm, "utf16le");
				o.write_shift(2, flen);
				o.write_shift(1, file.type);
				o.write_shift(1, file.color);
				o.write_shift(-4, file.L);
				o.write_shift(-4, file.R);
				o.write_shift(-4, file.C);
				if (!file.clsid) for (j = 0; j < 4; ++j) o.write_shift(4, 0);
else o.write_shift(16, file.clsid, "hex");
				o.write_shift(4, file.state || 0);
				o.write_shift(4, 0);
				o.write_shift(4, 0);
				o.write_shift(4, 0);
				o.write_shift(4, 0);
				o.write_shift(4, file.start);
				o.write_shift(4, file.size);
				o.write_shift(4, 0);
			}
			for (i$1 = 1; i$1 < cfb$1.FileIndex.length; ++i$1) {
				file = cfb$1.FileIndex[i$1];
				if (file.size >= 4096) {
					o.l = file.start + 1 << 9;
					if (has_buf && Buffer.isBuffer(file.content)) {
						file.content.copy(o, o.l, 0, file.size);
						o.l += file.size + 511 & -512;
					} else {
						for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
						for (; j & 511; ++j) o.write_shift(1, 0);
					}
				}
			}
			for (i$1 = 1; i$1 < cfb$1.FileIndex.length; ++i$1) {
				file = cfb$1.FileIndex[i$1];
				if (file.size > 0 && file.size < 4096) if (has_buf && Buffer.isBuffer(file.content)) {
					file.content.copy(o, o.l, 0, file.size);
					o.l += file.size + 63 & -64;
				} else {
					for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
					for (; j & 63; ++j) o.write_shift(1, 0);
				}
			}
			if (has_buf) o.l = o.length;
else while (o.l < o.length) o.write_shift(1, 0);
			return o;
		}
		function find(cfb$1, path$1) {
			var UCFullPaths = cfb$1.FullPaths.map(function(x) {
				return x.toUpperCase();
			});
			var UCPaths = UCFullPaths.map(function(x) {
				var y = x.split("/");
				return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
			});
			var k = false;
			if (path$1.charCodeAt(0) === 47) {
				k = true;
				path$1 = UCFullPaths[0].slice(0, -1) + path$1;
			} else k = path$1.indexOf("/") !== -1;
			var UCPath = path$1.toUpperCase();
			var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
			if (w !== -1) return cfb$1.FileIndex[w];
			var m = !UCPath.match(chr1);
			UCPath = UCPath.replace(chr0, "");
			if (m) UCPath = UCPath.replace(chr1, "!");
			for (w = 0; w < UCFullPaths.length; ++w) {
				if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath) return cfb$1.FileIndex[w];
				if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath) return cfb$1.FileIndex[w];
			}
			return null;
		}
		/** CFB Constants */
		var MSSZ = 64;
		var ENDOFCHAIN = -2;
		var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
		var HEADER_SIG = [
			208,
			207,
			17,
			224,
			161,
			177,
			26,
			225
		];
		var HEADER_CLSID = "00000000000000000000000000000000";
		var consts = {
			MAXREGSECT: -6,
			DIFSECT: -4,
			FATSECT: -3,
			ENDOFCHAIN,
			FREESECT: -1,
			HEADER_SIGNATURE,
			HEADER_MINOR_VERSION: "3e00",
			MAXREGSID: -6,
			NOSTREAM: -1,
			HEADER_CLSID,
			EntryTypes: [
				"unknown",
				"storage",
				"stream",
				"lockbytes",
				"property",
				"root"
			]
		};
		function write_file(cfb$1, filename$1, options) {
			get_fs();
			var o = _write(cfb$1, options);
			fs$1.writeFileSync(filename$1, o);
		}
		function a2s(o) {
			var out = new Array(o.length);
			for (var i$1 = 0; i$1 < o.length; ++i$1) out[i$1] = String.fromCharCode(o[i$1]);
			return out.join("");
		}
		function write(cfb$1, options) {
			var o = _write(cfb$1, options);
			switch (options && options.type || "buffer") {
				case "file":
					get_fs();
					fs$1.writeFileSync(options.filename, o);
					return o;
				case "binary": return typeof o == "string" ? o : a2s(o);
				case "base64": return Base64.encode(typeof o == "string" ? o : a2s(o));
				case "buffer": if (has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);
				case "array": return typeof o == "string" ? s2a(o) : o;
			}
			return o;
		}
		var _zlib;
		function use_zlib(zlib) {
			try {
				var InflateRaw = zlib.InflateRaw;
				var InflRaw = new InflateRaw();
				InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
				if (InflRaw.bytesRead) _zlib = zlib;
else throw new Error("zlib does not expose bytesRead");
			} catch (e) {
				console.error("cannot use native zlib: " + (e.message || e));
			}
		}
		function _inflateRawSync(payload, usz) {
			if (!_zlib) return _inflate(payload, usz);
			var InflateRaw = _zlib.InflateRaw;
			var InflRaw = new InflateRaw();
			var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
			payload.l += InflRaw.bytesRead;
			return out;
		}
		function _deflateRawSync(payload) {
			return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
		}
		var CLEN_ORDER = [
			16,
			17,
			18,
			0,
			8,
			7,
			9,
			6,
			10,
			5,
			11,
			4,
			12,
			3,
			13,
			2,
			14,
			1,
			15
		];
		var LEN_LN = [
			3,
			4,
			5,
			6,
			7,
			8,
			9,
			10,
			11,
			13,
			15,
			17,
			19,
			23,
			27,
			31,
			35,
			43,
			51,
			59,
			67,
			83,
			99,
			115,
			131,
			163,
			195,
			227,
			258
		];
		var DST_LN = [
			1,
			2,
			3,
			4,
			5,
			7,
			9,
			13,
			17,
			25,
			33,
			49,
			65,
			97,
			129,
			193,
			257,
			385,
			513,
			769,
			1025,
			1537,
			2049,
			3073,
			4097,
			6145,
			8193,
			12289,
			16385,
			24577
		];
		function bit_swap_8(n) {
			var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
			return (t >> 16 | t >> 8 | t) & 255;
		}
		var use_typed_arrays = typeof Uint8Array !== "undefined";
		var bitswap8 = use_typed_arrays ? new Uint8Array(256) : [];
		for (var q = 0; q < 256; ++q) bitswap8[q] = bit_swap_8(q);
		function bit_swap_n(n, b) {
			var rev = bitswap8[n & 255];
			if (b <= 8) return rev >>> 8 - b;
			rev = rev << 8 | bitswap8[n >> 8 & 255];
			if (b <= 16) return rev >>> 16 - b;
			rev = rev << 8 | bitswap8[n >> 16 & 255];
			return rev >>> 24 - b;
		}
		function read_bits_2(buf, bl) {
			var w = bl & 7, h = bl >>> 3;
			return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 3;
		}
		function read_bits_3(buf, bl) {
			var w = bl & 7, h = bl >>> 3;
			return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 7;
		}
		function read_bits_4(buf, bl) {
			var w = bl & 7, h = bl >>> 3;
			return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 15;
		}
		function read_bits_5(buf, bl) {
			var w = bl & 7, h = bl >>> 3;
			return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 31;
		}
		function read_bits_7(buf, bl) {
			var w = bl & 7, h = bl >>> 3;
			return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 127;
		}
		function read_bits_n(buf, bl, n) {
			var w = bl & 7, h = bl >>> 3, f = (1 << n) - 1;
			var v = buf[h] >>> w;
			if (n < 8 - w) return v & f;
			v |= buf[h + 1] << 8 - w;
			if (n < 16 - w) return v & f;
			v |= buf[h + 2] << 16 - w;
			if (n < 24 - w) return v & f;
			v |= buf[h + 3] << 24 - w;
			return v & f;
		}
		function write_bits_3(buf, bl, v) {
			var w = bl & 7, h = bl >>> 3;
			if (w <= 5) buf[h] |= (v & 7) << w;
else {
				buf[h] |= v << w & 255;
				buf[h + 1] = (v & 7) >> 8 - w;
			}
			return bl + 3;
		}
		function write_bits_1(buf, bl, v) {
			var w = bl & 7, h = bl >>> 3;
			v = (v & 1) << w;
			buf[h] |= v;
			return bl + 1;
		}
		function write_bits_8(buf, bl, v) {
			var w = bl & 7, h = bl >>> 3;
			v <<= w;
			buf[h] |= v & 255;
			v >>>= 8;
			buf[h + 1] = v;
			return bl + 8;
		}
		function write_bits_16(buf, bl, v) {
			var w = bl & 7, h = bl >>> 3;
			v <<= w;
			buf[h] |= v & 255;
			v >>>= 8;
			buf[h + 1] = v & 255;
			buf[h + 2] = v >>> 8;
			return bl + 16;
		}
		function realloc(b, sz) {
			var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i$1 = 0;
			if (L >= sz) return b;
			if (has_buf) {
				var o = new_unsafe_buf(M);
				if (b.copy) b.copy(o);
else for (; i$1 < b.length; ++i$1) o[i$1] = b[i$1];
				return o;
			} else if (use_typed_arrays) {
				var a = new Uint8Array(M);
				if (a.set) a.set(b);
else for (; i$1 < L; ++i$1) a[i$1] = b[i$1];
				return a;
			}
			b.length = M;
			return b;
		}
		function zero_fill_array(n) {
			var o = new Array(n);
			for (var i$1 = 0; i$1 < n; ++i$1) o[i$1] = 0;
			return o;
		}
		function build_tree(clens, cmap, MAX) {
			var maxlen = 1, w = 0, i$1 = 0, j = 0, ccode = 0, L = clens.length;
			var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
			for (i$1 = 0; i$1 < 32; ++i$1) bl_count[i$1] = 0;
			for (i$1 = L; i$1 < MAX; ++i$1) clens[i$1] = 0;
			L = clens.length;
			var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
			for (i$1 = 0; i$1 < L; ++i$1) {
				bl_count[w = clens[i$1]]++;
				if (maxlen < w) maxlen = w;
				ctree[i$1] = 0;
			}
			bl_count[0] = 0;
			for (i$1 = 1; i$1 <= maxlen; ++i$1) bl_count[i$1 + 16] = ccode = ccode + bl_count[i$1 - 1] << 1;
			for (i$1 = 0; i$1 < L; ++i$1) {
				ccode = clens[i$1];
				if (ccode != 0) ctree[i$1] = bl_count[ccode + 16]++;
			}
			var cleni = 0;
			for (i$1 = 0; i$1 < L; ++i$1) {
				cleni = clens[i$1];
				if (cleni != 0) {
					ccode = bit_swap_n(ctree[i$1], maxlen) >> maxlen - cleni;
					for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j) cmap[ccode | j << cleni] = cleni & 15 | i$1 << 4;
				}
			}
			return maxlen;
		}
		var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
		var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
		if (!use_typed_arrays) {
			for (var i = 0; i < 512; ++i) fix_lmap[i] = 0;
			for (i = 0; i < 32; ++i) fix_dmap[i] = 0;
		}
		(function() {
			var dlens = [];
			var i$1 = 0;
			for (; i$1 < 32; i$1++) dlens.push(5);
			build_tree(dlens, fix_dmap, 32);
			var clens = [];
			i$1 = 0;
			for (; i$1 <= 143; i$1++) clens.push(8);
			for (; i$1 <= 255; i$1++) clens.push(9);
			for (; i$1 <= 279; i$1++) clens.push(7);
			for (; i$1 <= 287; i$1++) clens.push(8);
			build_tree(clens, fix_lmap, 288);
		})();
		var _deflateRaw = function() {
			var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
			for (var j = 0, k = 0; j < DST_LN.length; ++j) for (; k < DST_LN[j + 1]; ++k) DST_LN_RE[k] = j;
			for (; k < 32768; ++k) DST_LN_RE[k] = 29;
			var LEN_LN_RE = use_typed_arrays ? new Uint8Array(258) : [];
			for (j = 0, k = 0; j < LEN_LN.length; ++j) for (; k < LEN_LN[j + 1]; ++k) LEN_LN_RE[k] = j;
			function write_stored(data, out) {
				var boff = 0;
				while (boff < data.length) {
					var L = Math.min(65535, data.length - boff);
					var h = boff + L == data.length;
					out.write_shift(1, +h);
					out.write_shift(2, L);
					out.write_shift(2, ~L & 65535);
					while (L-- > 0) out[out.l++] = data[boff++];
				}
				return out.l;
			}
			function write_huff_fixed(data, out) {
				var bl = 0;
				var boff = 0;
				var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
				while (boff < data.length) {
					var L = Math.min(65535, data.length - boff);
					if (L < 10) {
						bl = write_bits_3(out, bl, +!!(boff + L == data.length));
						if (bl & 7) bl += 8 - (bl & 7);
						out.l = bl / 8 | 0;
						out.write_shift(2, L);
						out.write_shift(2, ~L & 65535);
						while (L-- > 0) out[out.l++] = data[boff++];
						bl = out.l * 8;
						continue;
					}
					bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
					var hash = 0;
					while (L-- > 0) {
						var d = data[boff];
						hash = (hash << 5 ^ d) & 32767;
						var match = -1, mlen = 0;
						if (match = addrs[hash]) {
							match |= boff & -32768;
							if (match > boff) match -= 32768;
							if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) ++mlen;
						}
						if (mlen > 2) {
							d = LEN_LN_RE[mlen];
							if (d <= 22) bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
else {
								write_bits_8(out, bl, 3);
								bl += 5;
								write_bits_8(out, bl, bitswap8[d - 23] >> 5);
								bl += 3;
							}
							var len_eb = d < 8 ? 0 : d - 4 >> 2;
							if (len_eb > 0) {
								write_bits_16(out, bl, mlen - LEN_LN[d]);
								bl += len_eb;
							}
							d = DST_LN_RE[boff - match];
							bl = write_bits_8(out, bl, bitswap8[d] >> 3);
							bl -= 3;
							var dst_eb = d < 4 ? 0 : d - 2 >> 1;
							if (dst_eb > 0) {
								write_bits_16(out, bl, boff - match - DST_LN[d]);
								bl += dst_eb;
							}
							for (var q$1 = 0; q$1 < mlen; ++q$1) {
								addrs[hash] = boff & 32767;
								hash = (hash << 5 ^ data[boff]) & 32767;
								++boff;
							}
							L -= mlen - 1;
						} else {
							if (d <= 143) d = d + 48;
else bl = write_bits_1(out, bl, 1);
							bl = write_bits_8(out, bl, bitswap8[d]);
							addrs[hash] = boff & 32767;
							++boff;
						}
					}
					bl = write_bits_8(out, bl, 0) - 1;
				}
				out.l = (bl + 7) / 8 | 0;
				return out.l;
			}
			return function _deflateRaw$1(data, out) {
				if (data.length < 8) return write_stored(data, out);
				return write_huff_fixed(data, out);
			};
		}();
		function _deflate(data) {
			var buf = new_buf(50 + Math.floor(data.length * 1.1));
			var off = _deflateRaw(data, buf);
			return buf.slice(0, off);
		}
		var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
		var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
		var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
		var dyn_len_1 = 1, dyn_len_2 = 1;
		function dyn(data, boff) {
			var _HLIT = read_bits_5(data, boff) + 257;
			boff += 5;
			var _HDIST = read_bits_5(data, boff) + 1;
			boff += 5;
			var _HCLEN = read_bits_4(data, boff) + 4;
			boff += 4;
			var w = 0;
			var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
			var ctree = [
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0
			];
			var maxlen = 1;
			var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
			var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
			var L = clens.length;
			for (var i$1 = 0; i$1 < _HCLEN; ++i$1) {
				clens[CLEN_ORDER[i$1]] = w = read_bits_3(data, boff);
				if (maxlen < w) maxlen = w;
				bl_count[w]++;
				boff += 3;
			}
			var ccode = 0;
			bl_count[0] = 0;
			for (i$1 = 1; i$1 <= maxlen; ++i$1) next_code[i$1] = ccode = ccode + bl_count[i$1 - 1] << 1;
			for (i$1 = 0; i$1 < L; ++i$1) if ((ccode = clens[i$1]) != 0) ctree[i$1] = next_code[ccode]++;
			var cleni = 0;
			for (i$1 = 0; i$1 < L; ++i$1) {
				cleni = clens[i$1];
				if (cleni != 0) {
					ccode = bitswap8[ctree[i$1]] >> 8 - cleni;
					for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) dyn_cmap[ccode | j << cleni] = cleni & 7 | i$1 << 3;
				}
			}
			var hcodes = [];
			maxlen = 1;
			for (; hcodes.length < _HLIT + _HDIST;) {
				ccode = dyn_cmap[read_bits_7(data, boff)];
				boff += ccode & 7;
				switch (ccode >>>= 3) {
					case 16:
						w = 3 + read_bits_2(data, boff);
						boff += 2;
						ccode = hcodes[hcodes.length - 1];
						while (w-- > 0) hcodes.push(ccode);
						break;
					case 17:
						w = 3 + read_bits_3(data, boff);
						boff += 3;
						while (w-- > 0) hcodes.push(0);
						break;
					case 18:
						w = 11 + read_bits_7(data, boff);
						boff += 7;
						while (w-- > 0) hcodes.push(0);
						break;
					default:
						hcodes.push(ccode);
						if (maxlen < ccode) maxlen = ccode;
						break;
				}
			}
			var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
			for (i$1 = _HLIT; i$1 < 286; ++i$1) h1[i$1] = 0;
			for (i$1 = _HDIST; i$1 < 30; ++i$1) h2[i$1] = 0;
			dyn_len_1 = build_tree(h1, dyn_lmap, 286);
			dyn_len_2 = build_tree(h2, dyn_dmap, 30);
			return boff;
		}
		function inflate(data, usz) {
			if (data[0] == 3 && !(data[1] & 3)) return [new_raw_buf(usz), 2];
			var boff = 0;
			var header = 0;
			var outbuf = new_unsafe_buf(usz ? usz : 262144);
			var woff = 0;
			var OL = outbuf.length >>> 0;
			var max_len_1 = 0, max_len_2 = 0;
			while ((header & 1) == 0) {
				header = read_bits_3(data, boff);
				boff += 3;
				if (header >>> 1 == 0) {
					if (boff & 7) boff += 8 - (boff & 7);
					var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
					boff += 32;
					if (!usz && OL < woff + sz) {
						outbuf = realloc(outbuf, woff + sz);
						OL = outbuf.length;
					}
					if (typeof data.copy === "function") {
						data.copy(outbuf, woff, boff >>> 3, (boff >>> 3) + sz);
						woff += sz;
						boff += 8 * sz;
					} else while (sz-- > 0) {
						outbuf[woff++] = data[boff >>> 3];
						boff += 8;
					}
					continue;
				} else if (header >>> 1 == 1) {
					max_len_1 = 9;
					max_len_2 = 5;
				} else {
					boff = dyn(data, boff);
					max_len_1 = dyn_len_1;
					max_len_2 = dyn_len_2;
				}
				for (;;) {
					if (!usz && OL < woff + 32767) {
						outbuf = realloc(outbuf, woff + 32767);
						OL = outbuf.length;
					}
					var bits = read_bits_n(data, boff, max_len_1);
					var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
					boff += code & 15;
					code >>>= 4;
					if ((code >>> 8 & 255) === 0) outbuf[woff++] = code;
else if (code == 256) break;
else {
						code -= 257;
						var len_eb = code < 8 ? 0 : code - 4 >> 2;
						if (len_eb > 5) len_eb = 0;
						var tgt = woff + LEN_LN[code];
						if (len_eb > 0) {
							tgt += read_bits_n(data, boff, len_eb);
							boff += len_eb;
						}
						bits = read_bits_n(data, boff, max_len_2);
						code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
						boff += code & 15;
						code >>>= 4;
						var dst_eb = code < 4 ? 0 : code - 2 >> 1;
						var dst = DST_LN[code];
						if (dst_eb > 0) {
							dst += read_bits_n(data, boff, dst_eb);
							boff += dst_eb;
						}
						if (!usz && OL < tgt) {
							outbuf = realloc(outbuf, tgt + 100);
							OL = outbuf.length;
						}
						while (woff < tgt) {
							outbuf[woff] = outbuf[woff - dst];
							++woff;
						}
					}
				}
			}
			return [usz ? outbuf : outbuf.slice(0, woff), boff + 7 >>> 3];
		}
		function _inflate(payload, usz) {
			var data = payload.slice(payload.l || 0);
			var out = inflate(data, usz);
			payload.l += out[1];
			return out[0];
		}
		function warn_or_throw(wrn, msg) {
			if (wrn) {
				if (typeof console !== "undefined") console.error(msg);
			} else throw new Error(msg);
		}
		function parse_zip(file, options) {
			var blob = file;
			prep_blob(blob, 0);
			var FileIndex = [], FullPaths = [];
			var o = {
				FileIndex,
				FullPaths
			};
			init_cfb(o, { root: options.root });
			var i$1 = blob.length - 4;
			while ((blob[i$1] != 80 || blob[i$1 + 1] != 75 || blob[i$1 + 2] != 5 || blob[i$1 + 3] != 6) && i$1 >= 0) --i$1;
			blob.l = i$1 + 4;
			blob.l += 4;
			var fcnt = blob.read_shift(2);
			blob.l += 6;
			var start_cd = blob.read_shift(4);
			blob.l = start_cd;
			for (i$1 = 0; i$1 < fcnt; ++i$1) {
				blob.l += 20;
				var csz = blob.read_shift(4);
				var usz = blob.read_shift(4);
				var namelen = blob.read_shift(2);
				var efsz = blob.read_shift(2);
				var fcsz = blob.read_shift(2);
				blob.l += 8;
				var offset = blob.read_shift(4);
				var EF = parse_extra_field(blob.slice(blob.l + namelen, blob.l + namelen + efsz));
				blob.l += namelen + efsz + fcsz;
				var L = blob.l;
				blob.l = offset + 4;
				parse_local_file(blob, csz, usz, o, EF);
				blob.l = L;
			}
			return o;
		}
		function parse_local_file(blob, csz, usz, o, EF) {
			blob.l += 2;
			var flags = blob.read_shift(2);
			var meth = blob.read_shift(2);
			var date = parse_dos_date(blob);
			if (flags & 8257) throw new Error("Unsupported ZIP encryption");
			var crc32 = blob.read_shift(4);
			var _csz = blob.read_shift(4);
			var _usz = blob.read_shift(4);
			var namelen = blob.read_shift(2);
			var efsz = blob.read_shift(2);
			var name$1 = "";
			for (var i$1 = 0; i$1 < namelen; ++i$1) name$1 += String.fromCharCode(blob[blob.l++]);
			if (efsz) {
				var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));
				if ((ef[21589] || {}).mt) date = ef[21589].mt;
				if (((EF || {})[21589] || {}).mt) date = EF[21589].mt;
			}
			blob.l += efsz;
			var data = blob.slice(blob.l, blob.l + _csz);
			switch (meth) {
				case 8:
					data = _inflateRawSync(blob, _usz);
					break;
				case 0: break;
				default: throw new Error("Unsupported ZIP Compression method " + meth);
			}
			var wrn = false;
			if (flags & 8) {
				crc32 = blob.read_shift(4);
				if (crc32 == 134695760) {
					crc32 = blob.read_shift(4);
					wrn = true;
				}
				_csz = blob.read_shift(4);
				_usz = blob.read_shift(4);
			}
			if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
			if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
			var _crc32 = CRC32.buf(data, 0);
			if (crc32 >> 0 != _crc32 >> 0) warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);
			cfb_add(o, name$1, data, {
				unsafe: true,
				mt: date
			});
		}
		function write_zip(cfb$1, options) {
			var _opts = options || {};
			var out = [], cdirs = [];
			var o = new_buf(1);
			var method = _opts.compression ? 8 : 0, flags = 0;
			var i$1 = 0, j = 0;
			var start_cd = 0, fcnt = 0;
			var root = cfb$1.FullPaths[0], fp = root, fi = cfb$1.FileIndex[0];
			var crcs = [];
			var sz_cd = 0;
			for (i$1 = 1; i$1 < cfb$1.FullPaths.length; ++i$1) {
				fp = cfb$1.FullPaths[i$1].slice(root.length);
				fi = cfb$1.FileIndex[i$1];
				if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
				var start = start_cd;
				var namebuf = new_buf(fp.length);
				for (j = 0; j < fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) & 127);
				namebuf = namebuf.slice(0, namebuf.l);
				crcs[fcnt] = CRC32.buf(fi.content, 0);
				var outbuf = fi.content;
				if (method == 8) outbuf = _deflateRawSync(outbuf);
				o = new_buf(30);
				o.write_shift(4, 67324752);
				o.write_shift(2, 20);
				o.write_shift(2, flags);
				o.write_shift(2, method);
				if (fi.mt) write_dos_date(o, fi.mt);
else o.write_shift(4, 0);
				o.write_shift(-4, crcs[fcnt]);
				o.write_shift(4, outbuf.length);
				o.write_shift(4, fi.content.length);
				o.write_shift(2, namebuf.length);
				o.write_shift(2, 0);
				start_cd += o.length;
				out.push(o);
				start_cd += namebuf.length;
				out.push(namebuf);
				start_cd += outbuf.length;
				out.push(outbuf);
				o = new_buf(46);
				o.write_shift(4, 33639248);
				o.write_shift(2, 0);
				o.write_shift(2, 20);
				o.write_shift(2, flags);
				o.write_shift(2, method);
				o.write_shift(4, 0);
				o.write_shift(-4, crcs[fcnt]);
				o.write_shift(4, outbuf.length);
				o.write_shift(4, fi.content.length);
				o.write_shift(2, namebuf.length);
				o.write_shift(2, 0);
				o.write_shift(2, 0);
				o.write_shift(2, 0);
				o.write_shift(2, 0);
				o.write_shift(4, 0);
				o.write_shift(4, start);
				sz_cd += o.l;
				cdirs.push(o);
				sz_cd += namebuf.length;
				cdirs.push(namebuf);
				++fcnt;
			}
			o = new_buf(22);
			o.write_shift(4, 101010256);
			o.write_shift(2, 0);
			o.write_shift(2, 0);
			o.write_shift(2, fcnt);
			o.write_shift(2, fcnt);
			o.write_shift(4, sz_cd);
			o.write_shift(4, start_cd);
			o.write_shift(2, 0);
			return bconcat([
				bconcat(out),
				bconcat(cdirs),
				o
			]);
		}
		var ContentTypeMap = {
			"htm": "text/html",
			"xml": "text/xml",
			"gif": "image/gif",
			"jpg": "image/jpeg",
			"png": "image/png",
			"mso": "application/x-mso",
			"thmx": "application/vnd.ms-officetheme",
			"sh33tj5": "application/octet-stream"
		};
		function get_content_type(fi, fp) {
			if (fi.ctype) return fi.ctype;
			var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
			if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
			if (fp) {
				m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
				if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
			}
			return "application/octet-stream";
		}
		function write_base64_76(bstr) {
			var data = Base64.encode(bstr);
			var o = [];
			for (var i$1 = 0; i$1 < data.length; i$1 += 76) o.push(data.slice(i$1, i$1 + 76));
			return o.join("\r\n") + "\r\n";
		}
		function write_quoted_printable(text) {
			var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
				var w = c.charCodeAt(0).toString(16).toUpperCase();
				return "=" + (w.length == 1 ? "0" + w : w);
			});
			encoded = encoded.replace(/ $/gm, "=20").replace(/\t$/gm, "=09");
			if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
			encoded = encoded.replace(/\r(?!\n)/gm, "=0D").replace(/\n\n/gm, "\n=0A").replace(/([^\r\n])\n/gm, "$1=0A");
			var o = [], split = encoded.split("\r\n");
			for (var si = 0; si < split.length; ++si) {
				var str = split[si];
				if (str.length == 0) {
					o.push("");
					continue;
				}
				for (var i$1 = 0; i$1 < str.length;) {
					var end = 76;
					var tmp = str.slice(i$1, i$1 + end);
					if (tmp.charAt(end - 1) == "=") end--;
else if (tmp.charAt(end - 2) == "=") end -= 2;
else if (tmp.charAt(end - 3) == "=") end -= 3;
					tmp = str.slice(i$1, i$1 + end);
					i$1 += end;
					if (i$1 < str.length) tmp += "=";
					o.push(tmp);
				}
			}
			return o.join("\r\n");
		}
		function parse_quoted_printable(data) {
			var o = [];
			for (var di = 0; di < data.length; ++di) {
				var line = data[di];
				while (di <= data.length && line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di];
				o.push(line);
			}
			for (var oi = 0; oi < o.length; ++oi) o[oi] = o[oi].replace(/=[0-9A-Fa-f]{2}/g, function($$) {
				return String.fromCharCode(parseInt($$.slice(1), 16));
			});
			return s2a(o.join("\r\n"));
		}
		function parse_mime(cfb$1, data, root) {
			var fname = "", cte = "", ctype = "", fdata;
			var di = 0;
			for (; di < 10; ++di) {
				var line = data[di];
				if (!line || line.match(/^\s*$/)) break;
				var m = line.match(/^(.*?):\s*([^\s].*)$/);
				if (m) switch (m[1].toLowerCase()) {
					case "content-location":
						fname = m[2].trim();
						break;
					case "content-type":
						ctype = m[2].trim();
						break;
					case "content-transfer-encoding":
						cte = m[2].trim();
						break;
				}
			}
			++di;
			switch (cte.toLowerCase()) {
				case "base64":
					fdata = s2a(Base64.decode(data.slice(di).join("")));
					break;
				case "quoted-printable":
					fdata = parse_quoted_printable(data.slice(di));
					break;
				default: throw new Error("Unsupported Content-Transfer-Encoding " + cte);
			}
			var file = cfb_add(cfb$1, fname.slice(root.length), fdata, { unsafe: true });
			if (ctype) file.ctype = ctype;
		}
		function parse_mad(file, options) {
			if (a2s(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
			var root = options && options.root || "";
			var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s(file)).split("\r\n");
			var di = 0, row = "";
			for (di = 0; di < data.length; ++di) {
				row = data[di];
				if (!/^Content-Location:/i.test(row)) continue;
				row = row.slice(row.indexOf("file"));
				if (!root) root = row.slice(0, row.lastIndexOf("/") + 1);
				if (row.slice(0, root.length) == root) continue;
				while (root.length > 0) {
					root = root.slice(0, root.length - 1);
					root = root.slice(0, root.lastIndexOf("/") + 1);
					if (row.slice(0, root.length) == root) break;
				}
			}
			var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
			if (!mboundary) throw new Error("MAD cannot find boundary");
			var boundary = "--" + (mboundary[1] || "");
			var FileIndex = [], FullPaths = [];
			var o = {
				FileIndex,
				FullPaths
			};
			init_cfb(o);
			var start_di, fcnt = 0;
			for (di = 0; di < data.length; ++di) {
				var line = data[di];
				if (line !== boundary && line !== boundary + "--") continue;
				if (fcnt++) parse_mime(o, data.slice(start_di, di), root);
				start_di = di;
			}
			return o;
		}
		function write_mad(cfb$1, options) {
			var opts = options || {};
			var boundary = opts.boundary || "SheetJS";
			boundary = "------=" + boundary;
			var out = [
				"MIME-Version: 1.0",
				"Content-Type: multipart/related; boundary=\"" + boundary.slice(2) + "\"",
				"",
				"",
				""
			];
			var root = cfb$1.FullPaths[0], fp = root, fi = cfb$1.FileIndex[0];
			for (var i$1 = 1; i$1 < cfb$1.FullPaths.length; ++i$1) {
				fp = cfb$1.FullPaths[i$1].slice(root.length);
				fi = cfb$1.FileIndex[i$1];
				if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
				fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
					return "_x" + c.charCodeAt(0).toString(16) + "_";
				}).replace(/[\u0080-\uFFFF]/g, function(u) {
					return "_u" + u.charCodeAt(0).toString(16) + "_";
				});
				var ca = fi.content;
				var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s(ca);
				var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
				for (var csl = 0; csl <= L; ++csl) if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128) ++dispcnt;
				var qp = dispcnt >= L * 4 / 5;
				out.push(boundary);
				out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
				out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
				out.push("Content-Type: " + get_content_type(fi, fp));
				out.push("");
				out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
			}
			out.push(boundary + "--\r\n");
			return out.join("\r\n");
		}
		function cfb_new(opts) {
			var o = {};
			init_cfb(o, opts);
			return o;
		}
		function cfb_add(cfb$1, name$1, content, opts) {
			var unsafe = opts && opts.unsafe;
			if (!unsafe) init_cfb(cfb$1);
			var file = !unsafe && CFB.find(cfb$1, name$1);
			if (!file) {
				var fpath = cfb$1.FullPaths[0];
				if (name$1.slice(0, fpath.length) == fpath) fpath = name$1;
else {
					if (fpath.slice(-1) != "/") fpath += "/";
					fpath = (fpath + name$1).replace("//", "/");
				}
				file = {
					name: filename(name$1),
					type: 2
				};
				cfb$1.FileIndex.push(file);
				cfb$1.FullPaths.push(fpath);
				if (!unsafe) CFB.utils.cfb_gc(cfb$1);
			}
			file.content = content;
			file.size = content ? content.length : 0;
			if (opts) {
				if (opts.CLSID) file.clsid = opts.CLSID;
				if (opts.mt) file.mt = opts.mt;
				if (opts.ct) file.ct = opts.ct;
			}
			return file;
		}
		function cfb_del(cfb$1, name$1) {
			init_cfb(cfb$1);
			var file = CFB.find(cfb$1, name$1);
			if (file) {
				for (var j = 0; j < cfb$1.FileIndex.length; ++j) if (cfb$1.FileIndex[j] == file) {
					cfb$1.FileIndex.splice(j, 1);
					cfb$1.FullPaths.splice(j, 1);
					return true;
				}
			}
			return false;
		}
		function cfb_mov(cfb$1, old_name, new_name) {
			init_cfb(cfb$1);
			var file = CFB.find(cfb$1, old_name);
			if (file) {
				for (var j = 0; j < cfb$1.FileIndex.length; ++j) if (cfb$1.FileIndex[j] == file) {
					cfb$1.FileIndex[j].name = filename(new_name);
					cfb$1.FullPaths[j] = new_name;
					return true;
				}
			}
			return false;
		}
		function cfb_gc(cfb$1) {
			rebuild_cfb(cfb$1, true);
		}
		exports.find = find;
		exports.read = read;
		exports.parse = parse;
		exports.write = write;
		exports.writeFile = write_file;
		exports.utils = {
			cfb_new,
			cfb_add,
			cfb_del,
			cfb_mov,
			cfb_gc,
			ReadShift,
			CheckField,
			prep_blob,
			bconcat,
			use_zlib,
			_deflateRaw: _deflate,
			_inflateRaw: _inflate,
			consts
		};
		return exports;
	}();
	if (typeof commonjsRequire !== "undefined" && typeof DO_NOT_EXPORT_CFB === "undefined") module.exports = CFB;
});
var CFBStorage = class CFBStorage {
	constructor(cfb$1) {
		this._cfb = cfb$1 || cfb.utils.cfb_new();
		this._path = "";
	}
	/**
	* add substorage to this (doesn't modify the underlying CFBContainer)
	* @param name {string} name of the subdir
	* @returns {CFBStorage} a storage that will add storage and streams to the subdir
	* */
	addStorage(name$1) {
		const child = new CFBStorage(this._cfb);
		child._path = this._path + "/" + name$1;
		return child;
	}
	/**
	*
	*/
	getStorage(name$1) {
		return this.addStorage(name$1);
	}
	/**
	* add a stream (file) to the cfb at the current _path. creates all parent dirs if they don't exist yet
	* should the stream already exist, this will replace the contents.
	* @param name {string} the name of the new stream
	* @param content {Uint8Array} the contents of the stream
	* @return {void}
	* */
	addStream(name$1, content) {
		const entryIndex = this._getEntryIndex(name$1);
		if (entryIndex < 0) cfb.utils.cfb_add(this._cfb, this._path + "/" + name$1, content);
else this._cfb.FileIndex[entryIndex].content = content;
	}
	/**
	* get the contents of a stream or an empty array
	* @param name {string} the name of the stream
	* @return {Uint8Array} the contents of the named stream, empty if it wasn't found
	* TODO: should this be absolute?
	*/
	getStream(name$1) {
		const entryIndex = this._getEntryIndex(name$1);
		return entryIndex < 0 ? Uint8Array.of() : Uint8Array.from(this._cfb.FileIndex[entryIndex].content);
	}
	/** write the contents of the cfb container to a byte array */
	toBytes() {
		return Uint8Array.from(cfb.write(this._cfb));
	}
	_getEntryIndex(name$1) {
		return this._cfb.FullPaths.findIndex((p) => p === this._path + "/" + name$1);
	}
};
var PropertyType;
(function(PropertyType$1) {
	PropertyType$1[PropertyType$1["PT_UNSPECIFIED"] = 0] = "PT_UNSPECIFIED";
	PropertyType$1[PropertyType$1["PT_NULL"] = 1] = "PT_NULL";
	PropertyType$1[PropertyType$1["PT_SHORT"] = 2] = "PT_SHORT";
	PropertyType$1[PropertyType$1["PT_LONG"] = 3] = "PT_LONG";
	PropertyType$1[PropertyType$1["PT_FLOAT"] = 4] = "PT_FLOAT";
	PropertyType$1[PropertyType$1["PT_DOUBLE"] = 5] = "PT_DOUBLE";
	PropertyType$1[PropertyType$1["PT_APPTIME"] = 7] = "PT_APPTIME";
	PropertyType$1[PropertyType$1["PT_ERROR"] = 10] = "PT_ERROR";
	PropertyType$1[PropertyType$1["PT_BOOLEAN"] = 11] = "PT_BOOLEAN";
	PropertyType$1[PropertyType$1["PT_OBJECT"] = 13] = "PT_OBJECT";
	PropertyType$1[PropertyType$1["PT_I8"] = 20] = "PT_I8";
	PropertyType$1[PropertyType$1["PT_LONGLONG"] = 20] = "PT_LONGLONG";
	PropertyType$1[PropertyType$1["PT_UNICODE"] = 31] = "PT_UNICODE";
	PropertyType$1[PropertyType$1["PT_STRING8"] = 30] = "PT_STRING8";
	PropertyType$1[PropertyType$1["PT_SYSTIME"] = 64] = "PT_SYSTIME";
	PropertyType$1[PropertyType$1["PT_CLSID"] = 72] = "PT_CLSID";
	PropertyType$1[PropertyType$1["PT_SVREID"] = 251] = "PT_SVREID";
	PropertyType$1[PropertyType$1["PT_SRESTRICT"] = 253] = "PT_SRESTRICT";
	PropertyType$1[PropertyType$1["PT_ACTIONS"] = 254] = "PT_ACTIONS";
	PropertyType$1[PropertyType$1["PT_BINARY"] = 258] = "PT_BINARY";
	PropertyType$1[PropertyType$1["PT_MV_SHORT"] = 4098] = "PT_MV_SHORT";
	PropertyType$1[PropertyType$1["PT_MV_LONG"] = 4099] = "PT_MV_LONG";
	PropertyType$1[PropertyType$1["PT_MV_FLOAT"] = 4100] = "PT_MV_FLOAT";
	PropertyType$1[PropertyType$1["PT_MV_DOUBLE"] = 4101] = "PT_MV_DOUBLE";
	PropertyType$1[PropertyType$1["PT_MV_CURRENCY"] = 4102] = "PT_MV_CURRENCY";
	PropertyType$1[PropertyType$1["PT_MV_APPTIME"] = 4103] = "PT_MV_APPTIME";
	PropertyType$1[PropertyType$1["PT_MV_LONGLONG"] = 4116] = "PT_MV_LONGLONG";
	PropertyType$1[PropertyType$1["PT_MV_TSTRING"] = 4127] = "PT_MV_TSTRING";
	PropertyType$1[PropertyType$1["PT_MV_UNICODE"] = 4127] = "PT_MV_UNICODE";
	PropertyType$1[PropertyType$1["PT_MV_STRING8"] = 4126] = "PT_MV_STRING8";
	PropertyType$1[PropertyType$1["PT_MV_SYSTIME"] = 4160] = "PT_MV_SYSTIME";
	PropertyType$1[PropertyType$1["PT_MV_CLSID"] = 4168] = "PT_MV_CLSID";
	PropertyType$1[PropertyType$1["PT_MV_BINARY"] = 4354] = "PT_MV_BINARY";
})(PropertyType || (PropertyType = {}));
var MessageEditorFormat;
(function(MessageEditorFormat$1) {
	MessageEditorFormat$1[MessageEditorFormat$1["EDITOR_FORMAT_DONTKNOW"] = 0] = "EDITOR_FORMAT_DONTKNOW";
	MessageEditorFormat$1[MessageEditorFormat$1["EDITOR_FORMAT_PLAINTEXT"] = 1] = "EDITOR_FORMAT_PLAINTEXT";
	MessageEditorFormat$1[MessageEditorFormat$1["EDITOR_FORMAT_HTML"] = 2] = "EDITOR_FORMAT_HTML";
	MessageEditorFormat$1[MessageEditorFormat$1["EDITOR_FORMAT_RTF"] = 3] = "EDITOR_FORMAT_RTF";
})(MessageEditorFormat || (MessageEditorFormat = {}));
var AttachmentType;
(function(AttachmentType$1) {
	AttachmentType$1[AttachmentType$1["NO_ATTACHMENT"] = 0] = "NO_ATTACHMENT";
	AttachmentType$1[AttachmentType$1["ATTACH_BY_VALUE"] = 1] = "ATTACH_BY_VALUE";
	AttachmentType$1[AttachmentType$1["ATTACH_BY_REFERENCE"] = 2] = "ATTACH_BY_REFERENCE";
	AttachmentType$1[AttachmentType$1["ATTACH_BY_REF_RESOLVE"] = 3] = "ATTACH_BY_REF_RESOLVE";
	AttachmentType$1[AttachmentType$1["ATTACH_BY_REF_ONLY"] = 4] = "ATTACH_BY_REF_ONLY";
	AttachmentType$1[AttachmentType$1["ATTACH_EMBEDDED_MSG"] = 5] = "ATTACH_EMBEDDED_MSG";
	AttachmentType$1[AttachmentType$1["ATTACH_OLE"] = 6] = "ATTACH_OLE";
})(AttachmentType || (AttachmentType = {}));
const StoreSupportMaskConst = 327736;
var ContentTransferEncoding;
(function(ContentTransferEncoding$1) {
	ContentTransferEncoding$1["SevenBit"] = "7bit";
	ContentTransferEncoding$1["EightBit"] = "8bit";
	ContentTransferEncoding$1["QuotedPrintable"] = "quoted-printable";
	ContentTransferEncoding$1["Base64"] = "base64";
	ContentTransferEncoding$1["Binary"] = "binary";
})(ContentTransferEncoding || (ContentTransferEncoding = {}));
const PropertyTags = Object.freeze({
	PR_ACKNOWLEDGEMENT_MODE: {
		id: 1,
		type: PropertyType.PT_LONG
	},
	PR_ALTERNATE_RECIPIENT_ALLOWED: {
		id: 2,
		type: PropertyType.PT_BOOLEAN
	},
	PR_AUTHORIZING_USERS: {
		id: 3,
		type: PropertyType.PT_BINARY
	},
	PR_AUTO_FORWARD_COMMENT_: {
		id: 4,
		type: PropertyType.PT_UNICODE
	},
	PR_AUTO_FORWARD_COMMENT_A: {
		id: 4,
		type: PropertyType.PT_STRING8
	},
	PR_AUTO_FORWARDED: {
		id: 5,
		type: PropertyType.PT_BOOLEAN
	},
	PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID: {
		id: 6,
		type: PropertyType.PT_BINARY
	},
	PR_CONTENT_CORRELATOR: {
		id: 7,
		type: PropertyType.PT_BINARY
	},
	PR_CONTENT_IDENTIFIER_W: {
		id: 8,
		type: PropertyType.PT_UNICODE
	},
	PR_CONTENT_IDENTIFIER_A: {
		id: 8,
		type: PropertyType.PT_STRING8
	},
	PR_CONTENT_LENGTH: {
		id: 9,
		type: PropertyType.PT_LONG
	},
	PR_CONTENT_RETURN_REQUESTED: {
		id: 10,
		type: PropertyType.PT_BOOLEAN
	},
	PR_CONVERSATION_KEY: {
		id: 11,
		type: PropertyType.PT_BINARY
	},
	PR_CONVERSION_EITS: {
		id: 12,
		type: PropertyType.PT_BINARY
	},
	PR_CONVERSION_WITH_LOSS_PROHIBITED: {
		id: 13,
		type: PropertyType.PT_BOOLEAN
	},
	PR_CONVERTED_EITS: {
		id: 14,
		type: PropertyType.PT_BINARY
	},
	PR_DEFERRED_DELIVERY_TIME: {
		id: 15,
		type: PropertyType.PT_SYSTIME
	},
	PR_DELIVER_TIME: {
		id: 16,
		type: PropertyType.PT_SYSTIME
	},
	PR_DISCARD_REASON: {
		id: 17,
		type: PropertyType.PT_LONG
	},
	PR_DISCLOSURE_OF_RECIPIENTS: {
		id: 18,
		type: PropertyType.PT_BOOLEAN
	},
	PR_DL_EXPANSION_HISTORY: {
		id: 19,
		type: PropertyType.PT_BINARY
	},
	PR_DL_EXPANSION_PROHIBITED: {
		id: 20,
		type: PropertyType.PT_BOOLEAN
	},
	PR_EXPIRY_TIME: {
		id: 21,
		type: PropertyType.PT_SYSTIME
	},
	PR_IMPLICIT_CONVERSION_PROHIBITED: {
		id: 22,
		type: PropertyType.PT_BOOLEAN
	},
	PR_IMPORTANCE: {
		id: 23,
		type: PropertyType.PT_LONG
	},
	PR_IPM_ID: {
		id: 24,
		type: PropertyType.PT_BINARY
	},
	PR_LATEST_DELIVERY_TIME: {
		id: 25,
		type: PropertyType.PT_SYSTIME
	},
	PR_MESSAGE_CLASS_W: {
		id: 26,
		type: PropertyType.PT_UNICODE
	},
	PR_MESSAGE_CLASS_A: {
		id: 26,
		type: PropertyType.PT_STRING8
	},
	PR_MESSAGE_DELIVERY_ID: {
		id: 27,
		type: PropertyType.PT_BINARY
	},
	PR_MESSAGE_SECURITY_LABEL: {
		id: 30,
		type: PropertyType.PT_BINARY
	},
	PR_OBSOLETED_IPMS: {
		id: 31,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINALLY_INTENDED_RECIPIENT_NAME: {
		id: 32,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_EITS: {
		id: 33,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINATOR_CERTIFICATE: {
		id: 34,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED: {
		id: 35,
		type: PropertyType.PT_BOOLEAN
	},
	PR_ORIGINATOR_RETURN_ADDRESS: {
		id: 36,
		type: PropertyType.PT_BINARY
	},
	PR_PARENT_KEY: {
		id: 37,
		type: PropertyType.PT_BINARY
	},
	PR_PRIORITY: {
		id: 38,
		type: PropertyType.PT_LONG
	},
	PR_ORIGIN_CHECK: {
		id: 39,
		type: PropertyType.PT_BINARY
	},
	PR_PROOF_OF_SUBMISSION_REQUESTED: {
		id: 40,
		type: PropertyType.PT_BOOLEAN
	},
	PR_READ_RECEIPT_REQUESTED: {
		id: 41,
		type: PropertyType.PT_BOOLEAN
	},
	PR_RECEIPT_TIME: {
		id: 42,
		type: PropertyType.PT_SYSTIME
	},
	PR_RECIPIENT_REASSIGNMENT_PROHIBITED: {
		id: 43,
		type: PropertyType.PT_BOOLEAN
	},
	PR_REDIRECTION_HISTORY: {
		id: 44,
		type: PropertyType.PT_BINARY
	},
	PR_RELATED_IPMS: {
		id: 45,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_SENSITIVITY: {
		id: 46,
		type: PropertyType.PT_LONG
	},
	PR_LANGUAGES_W: {
		id: 47,
		type: PropertyType.PT_UNICODE
	},
	PR_LANGUAGES_A: {
		id: 47,
		type: PropertyType.PT_STRING8
	},
	PR_REPLY_TIME: {
		id: 48,
		type: PropertyType.PT_SYSTIME
	},
	PR_REPORT_TAG: {
		id: 49,
		type: PropertyType.PT_BINARY
	},
	PR_REPORT_TIME: {
		id: 50,
		type: PropertyType.PT_SYSTIME
	},
	PR_RETURNED_IPM: {
		id: 51,
		type: PropertyType.PT_BOOLEAN
	},
	PR_SECURITY: {
		id: 52,
		type: PropertyType.PT_LONG
	},
	PR_INCOMPLETE_COPY: {
		id: 53,
		type: PropertyType.PT_BOOLEAN
	},
	PR_SENSITIVITY: {
		id: 54,
		type: PropertyType.PT_LONG
	},
	PR_SUBJECT_W: {
		id: 55,
		type: PropertyType.PT_UNICODE
	},
	PR_SUBJECT_A: {
		id: 55,
		type: PropertyType.PT_STRING8
	},
	PR_SUBJECT_IPM: {
		id: 56,
		type: PropertyType.PT_BINARY
	},
	PR_CLIENT_SUBMIT_TIME: {
		id: 57,
		type: PropertyType.PT_SYSTIME
	},
	PR_REPORT_NAME_W: {
		id: 58,
		type: PropertyType.PT_UNICODE
	},
	PR_REPORT_NAME_A: {
		id: 58,
		type: PropertyType.PT_STRING8
	},
	PR_SENT_REPRESENTING_SEARCH_KEY: {
		id: 59,
		type: PropertyType.PT_BINARY
	},
	PR_X400_CONTENT_TYPE: {
		id: 60,
		type: PropertyType.PT_BINARY
	},
	PR_SUBJECT_PREFIX_W: {
		id: 61,
		type: PropertyType.PT_UNICODE
	},
	PR_SUBJECT_PREFIX_A: {
		id: 61,
		type: PropertyType.PT_STRING8
	},
	PR_NON_RECEIPT_REASON: {
		id: 62,
		type: PropertyType.PT_LONG
	},
	PR_RECEIVED_BY_ENTRYID: {
		id: 63,
		type: PropertyType.PT_BINARY
	},
	PR_RECEIVED_BY_NAME_W: {
		id: 64,
		type: PropertyType.PT_UNICODE
	},
	PR_RECEIVED_BY_NAME_A: {
		id: 64,
		type: PropertyType.PT_STRING8
	},
	PR_SENT_REPRESENTING_ENTRYID: {
		id: 65,
		type: PropertyType.PT_BINARY
	},
	PR_SENT_REPRESENTING_NAME_W: {
		id: 66,
		type: PropertyType.PT_UNICODE
	},
	PR_SENT_REPRESENTING_NAME_A: {
		id: 66,
		type: PropertyType.PT_STRING8
	},
	PR_RCVD_REPRESENTING_NAME_W: {
		id: 68,
		type: PropertyType.PT_UNICODE
	},
	PR_RCVD_REPRESENTING_NAME_A: {
		id: 68,
		type: PropertyType.PT_STRING8
	},
	PR_REPORT_ENTRYID: {
		id: 69,
		type: PropertyType.PT_BINARY
	},
	PR_READ_RECEIPT_ENTRYID: {
		id: 70,
		type: PropertyType.PT_BINARY
	},
	PR_MESSAGE_SUBMISSION_ID: {
		id: 71,
		type: PropertyType.PT_BINARY
	},
	PR_PROVIDER_SUBMIT_TIME: {
		id: 72,
		type: PropertyType.PT_SYSTIME
	},
	PR_ORIGINAL_SUBJECT_W: {
		id: 73,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_SUBJECT_A: {
		id: 73,
		type: PropertyType.PT_STRING8
	},
	PR_DISC_VAL: {
		id: 74,
		type: PropertyType.PT_BOOLEAN
	},
	PR_ORIG_MESSAGE_CLASS_W: {
		id: 75,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIG_MESSAGE_CLASS_A: {
		id: 75,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_AUTHOR_ENTRYID: {
		id: 76,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_AUTHOR_NAME_W: {
		id: 77,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_AUTHOR_NAME_A: {
		id: 77,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SUBMIT_TIME: {
		id: 78,
		type: PropertyType.PT_SYSTIME
	},
	PR_REPLY_RECIPIENT_ENTRIES: {
		id: 79,
		type: PropertyType.PT_BINARY
	},
	PR_REPLY_RECIPIENT_NAMES_W: {
		id: 80,
		type: PropertyType.PT_UNICODE
	},
	PR_REPLY_RECIPIENT_NAMES_A: {
		id: 80,
		type: PropertyType.PT_STRING8
	},
	PR_RECEIVED_BY_SEARCH_KEY: {
		id: 81,
		type: PropertyType.PT_BINARY
	},
	PR_RCVD_REPRESENTING_SEARCH_KEY: {
		id: 82,
		type: PropertyType.PT_BINARY
	},
	PR_READ_RECEIPT_SEARCH_KEY: {
		id: 83,
		type: PropertyType.PT_BINARY
	},
	PR_REPORT_SEARCH_KEY: {
		id: 84,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_DELIVERY_TIME: {
		id: 85,
		type: PropertyType.PT_SYSTIME
	},
	PR_ORIGINAL_AUTHOR_SEARCH_KEY: {
		id: 86,
		type: PropertyType.PT_BINARY
	},
	PR_MESSAGE_TO_ME: {
		id: 87,
		type: PropertyType.PT_BOOLEAN
	},
	PR_MESSAGE_CC_ME: {
		id: 88,
		type: PropertyType.PT_BOOLEAN
	},
	PR_MESSAGE_RECIP_ME: {
		id: 89,
		type: PropertyType.PT_BOOLEAN
	},
	PR_ORIGINAL_SENDER_NAME_W: {
		id: 90,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_SENDER_NAME_A: {
		id: 90,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SENDER_ENTRYID: {
		id: 91,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_SENDER_SEARCH_KEY: {
		id: 92,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_SENT_REPRESENTING_NAME_W: {
		id: 93,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_SENT_REPRESENTING_NAME_A: {
		id: 93,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SENT_REPRESENTING_ENTRYID: {
		id: 94,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY: {
		id: 95,
		type: PropertyType.PT_BINARY
	},
	PR_START_DATE: {
		id: 96,
		type: PropertyType.PT_SYSTIME
	},
	PR_END_DATE: {
		id: 97,
		type: PropertyType.PT_SYSTIME
	},
	PR_OWNER_APPT_ID: {
		id: 98,
		type: PropertyType.PT_LONG
	},
	PR_RESPONSE_REQUESTED: {
		id: 99,
		type: PropertyType.PT_BOOLEAN
	},
	PR_SENT_REPRESENTING_ADDRTYPE_W: {
		id: 100,
		type: PropertyType.PT_UNICODE
	},
	PR_SENT_REPRESENTING_ADDRTYPE_A: {
		id: 100,
		type: PropertyType.PT_STRING8
	},
	PR_SENT_REPRESENTING_EMAIL_ADDRESS_W: {
		id: 101,
		type: PropertyType.PT_UNICODE
	},
	PR_SENT_REPRESENTING_EMAIL_ADDRESS_A: {
		id: 101,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SENDER_ADDRTYPE_W: {
		id: 102,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_SENDER_ADDRTYPE_A: {
		id: 102,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W: {
		id: 103,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A: {
		id: 103,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W: {
		id: 104,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A: {
		id: 104,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W: {
		id: 105,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A: {
		id: 105,
		type: PropertyType.PT_STRING8
	},
	PR_CONVERSATION_TOPIC_W: {
		id: 112,
		type: PropertyType.PT_UNICODE
	},
	PR_CONVERSATION_TOPIC_A: {
		id: 112,
		type: PropertyType.PT_STRING8
	},
	PR_CONVERSATION_INDEX: {
		id: 113,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_DISPLAY_BCC_W: {
		id: 114,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_DISPLAY_BCC_A: {
		id: 114,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_DISPLAY_CC_W: {
		id: 115,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_DISPLAY_CC_A: {
		id: 115,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_DISPLAY_TO_W: {
		id: 116,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_DISPLAY_TO_A: {
		id: 116,
		type: PropertyType.PT_STRING8
	},
	PR_RECEIVED_BY_ADDRTYPE_W: {
		id: 117,
		type: PropertyType.PT_UNICODE
	},
	PR_RECEIVED_BY_ADDRTYPE_A: {
		id: 117,
		type: PropertyType.PT_STRING8
	},
	PR_RECEIVED_BY_EMAIL_ADDRESS_W: {
		id: 118,
		type: PropertyType.PT_UNICODE
	},
	PR_RECEIVED_BY_EMAIL_ADDRESS_A: {
		id: 118,
		type: PropertyType.PT_STRING8
	},
	PR_RCVD_REPRESENTING_ADDRTYPE_W: {
		id: 119,
		type: PropertyType.PT_UNICODE
	},
	PR_RCVD_REPRESENTING_ADDRTYPE_A: {
		id: 119,
		type: PropertyType.PT_STRING8
	},
	PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W: {
		id: 120,
		type: PropertyType.PT_UNICODE
	},
	PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A: {
		id: 120,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_AUTHOR_ADDRTYPE_W: {
		id: 121,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_AUTHOR_ADDRTYPE_A: {
		id: 121,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W: {
		id: 122,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A: {
		id: 122,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W: {
		id: 123,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A: {
		id: 123,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W: {
		id: 124,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A: {
		id: 124,
		type: PropertyType.PT_STRING8
	},
	PR_TRANSPORT_MESSAGE_HEADERS_A: {
		id: 125,
		type: PropertyType.PT_STRING8
	},
	PR_TRANSPORT_MESSAGE_HEADERS_W: {
		id: 125,
		type: PropertyType.PT_UNICODE
	},
	PR_DELEGATION: {
		id: 126,
		type: PropertyType.PT_BINARY
	},
	PR_TNEF_CORRELATION_KEY: {
		id: 127,
		type: PropertyType.PT_BINARY
	},
	PR_BODY_W: {
		id: 4096,
		type: PropertyType.PT_UNICODE
	},
	PR_BODY_A: {
		id: 4096,
		type: PropertyType.PT_STRING8
	},
	PR_REPORT_TEXT_W: {
		id: 4097,
		type: PropertyType.PT_UNICODE
	},
	PR_REPORT_TEXT_A: {
		id: 4097,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY: {
		id: 4098,
		type: PropertyType.PT_BINARY
	},
	PR_REPORTING_DL_NAME: {
		id: 4099,
		type: PropertyType.PT_BINARY
	},
	PR_REPORTING_MTA_CERTIFICATE: {
		id: 4100,
		type: PropertyType.PT_BINARY
	},
	PR_RTF_SYNC_BODY_CRC: {
		id: 4102,
		type: PropertyType.PT_LONG
	},
	PR_RTF_SYNC_BODY_COUNT: {
		id: 4103,
		type: PropertyType.PT_LONG
	},
	PR_RTF_SYNC_BODY_TAG_W: {
		id: 4104,
		type: PropertyType.PT_UNICODE
	},
	PR_RTF_SYNC_BODY_TAG_A: {
		id: 4104,
		type: PropertyType.PT_STRING8
	},
	PR_RTF_COMPRESSED: {
		id: 4105,
		type: PropertyType.PT_BINARY
	},
	PR_RTF_SYNC_PREFIX_COUNT: {
		id: 4112,
		type: PropertyType.PT_LONG
	},
	PR_RTF_SYNC_TRAILING_COUNT: {
		id: 4113,
		type: PropertyType.PT_LONG
	},
	PR_ORIGINALLY_INTENDED_RECIP_ENTRYID: {
		id: 4114,
		type: PropertyType.PT_BINARY
	},
	PR_BODY_HTML_A: {
		id: 4115,
		type: PropertyType.PT_STRING8
	},
	PR_HTML: {
		id: 4115,
		type: PropertyType.PT_BINARY
	},
	PR_BODY_CONTENT_LOCATION_A: {
		id: 4116,
		type: PropertyType.PT_STRING8
	},
	PR_BODY_CONTENT_LOCATION_W: {
		id: 4116,
		type: PropertyType.PT_UNICODE
	},
	PR_INTERNET_MESSAGE_ID_A: {
		id: 4149,
		type: PropertyType.PT_STRING8
	},
	PR_INTERNET_MESSAGE_ID_W: {
		id: 4149,
		type: PropertyType.PT_UNICODE
	},
	PR_IN_REPLY_TO_ID_A: {
		id: 4162,
		type: PropertyType.PT_STRING8
	},
	PR_IN_REPLY_TO_ID_W: {
		id: 4162,
		type: PropertyType.PT_UNICODE
	},
	PR_INTERNET_REFERENCES_A: {
		id: 4153,
		type: PropertyType.PT_STRING8
	},
	PR_INTERNET_REFERENCES_W: {
		id: 4153,
		type: PropertyType.PT_UNICODE
	},
	PR_CONTENT_INTEGRITY_CHECK: {
		id: 3072,
		type: PropertyType.PT_BINARY
	},
	PR_EXPLICIT_CONVERSION: {
		id: 3073,
		type: PropertyType.PT_LONG
	},
	PR_IPM_RETURN_REQUESTED: {
		id: 3074,
		type: PropertyType.PT_BOOLEAN
	},
	PR_MESSAGE_TOKEN: {
		id: 3075,
		type: PropertyType.PT_BINARY
	},
	PR_NDR_REASON_CODE: {
		id: 3076,
		type: PropertyType.PT_LONG
	},
	PR_NDR_DIAG_CODE: {
		id: 3077,
		type: PropertyType.PT_LONG
	},
	PR_NON_RECEIPT_NOTIFICATION_REQUESTED: {
		id: 3078,
		type: PropertyType.PT_BOOLEAN
	},
	PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED: {
		id: 3080,
		type: PropertyType.PT_BOOLEAN
	},
	PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT: {
		id: 3081,
		type: PropertyType.PT_BINARY
	},
	PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY: {
		id: 3082,
		type: PropertyType.PT_BOOLEAN
	},
	PR_PHYSICAL_DELIVERY_MODE: {
		id: 3083,
		type: PropertyType.PT_LONG
	},
	PR_PHYSICAL_DELIVERY_REPORT_REQUEST: {
		id: 3084,
		type: PropertyType.PT_LONG
	},
	PR_PHYSICAL_FORWARDING_ADDRESS: {
		id: 3085,
		type: PropertyType.PT_BINARY
	},
	PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED: {
		id: 3086,
		type: PropertyType.PT_BOOLEAN
	},
	PR_PHYSICAL_FORWARDING_PROHIBITED: {
		id: 3087,
		type: PropertyType.PT_BOOLEAN
	},
	PR_PHYSICAL_RENDITION_ATTRIBUTES: {
		id: 3088,
		type: PropertyType.PT_BINARY
	},
	PR_PROOF_OF_DELIVERY: {
		id: 3089,
		type: PropertyType.PT_BINARY
	},
	PR_PROOF_OF_DELIVERY_REQUESTED: {
		id: 3090,
		type: PropertyType.PT_BOOLEAN
	},
	PR_RECIPIENT_CERTIFICATE: {
		id: 3091,
		type: PropertyType.PT_BINARY
	},
	PR_RECIPIENT_NUMBER_FOR_ADVICE_W: {
		id: 3092,
		type: PropertyType.PT_UNICODE
	},
	PR_RECIPIENT_NUMBER_FOR_ADVICE_A: {
		id: 3092,
		type: PropertyType.PT_STRING8
	},
	PR_RECIPIENT_TYPE: {
		id: 3093,
		type: PropertyType.PT_LONG
	},
	PR_REGISTERED_MAIL_TYPE: {
		id: 3094,
		type: PropertyType.PT_LONG
	},
	PR_REPLY_REQUESTED: {
		id: 3095,
		type: PropertyType.PT_BOOLEAN
	},
	PR_REQUESTED_DELIVERY_METHOD: {
		id: 3096,
		type: PropertyType.PT_LONG
	},
	PR_SENDER_ENTRYID: {
		id: 3097,
		type: PropertyType.PT_BINARY
	},
	PR_SENDER_NAME_W: {
		id: 3098,
		type: PropertyType.PT_UNICODE
	},
	PR_SENDER_NAME_A: {
		id: 3098,
		type: PropertyType.PT_STRING8
	},
	PR_SUPPLEMENTARY_INFO_W: {
		id: 3099,
		type: PropertyType.PT_UNICODE
	},
	PR_SUPPLEMENTARY_INFO_A: {
		id: 3099,
		type: PropertyType.PT_STRING8
	},
	PR_TYPE_OF_MTS_USER: {
		id: 3100,
		type: PropertyType.PT_LONG
	},
	PR_SENDER_SEARCH_KEY: {
		id: 3101,
		type: PropertyType.PT_BINARY
	},
	PR_SENDER_ADDRTYPE_W: {
		id: 3102,
		type: PropertyType.PT_UNICODE
	},
	PR_SENDER_ADDRTYPE_A: {
		id: 3102,
		type: PropertyType.PT_STRING8
	},
	PR_SENDER_EMAIL_ADDRESS_W: {
		id: 3103,
		type: PropertyType.PT_UNICODE
	},
	PR_SENDER_EMAIL_ADDRESS_A: {
		id: 3103,
		type: PropertyType.PT_STRING8
	},
	PR_CURRENT_VERSION: {
		id: 3584,
		type: PropertyType.PT_I8
	},
	PR_DELETE_AFTER_SUBMIT: {
		id: 3585,
		type: PropertyType.PT_BOOLEAN
	},
	PR_DISPLAY_BCC_W: {
		id: 3586,
		type: PropertyType.PT_UNICODE
	},
	PR_DISPLAY_BCC_A: {
		id: 3586,
		type: PropertyType.PT_STRING8
	},
	PR_DISPLAY_CC_W: {
		id: 3587,
		type: PropertyType.PT_UNICODE
	},
	PR_DISPLAY_CC_A: {
		id: 3587,
		type: PropertyType.PT_STRING8
	},
	PR_DISPLAY_TO_W: {
		id: 3588,
		type: PropertyType.PT_UNICODE
	},
	PR_DISPLAY_TO_A: {
		id: 3588,
		type: PropertyType.PT_STRING8
	},
	PR_PARENT_DISPLAY_W: {
		id: 3589,
		type: PropertyType.PT_UNICODE
	},
	PR_PARENT_DISPLAY_A: {
		id: 3589,
		type: PropertyType.PT_STRING8
	},
	PR_MESSAGE_DELIVERY_TIME: {
		id: 3590,
		type: PropertyType.PT_SYSTIME
	},
	PR_MESSAGE_FLAGS: {
		id: 3591,
		type: PropertyType.PT_LONG
	},
	PR_MESSAGE_SIZE: {
		id: 3592,
		type: PropertyType.PT_LONG
	},
	PR_PARENT_ENTRYID: {
		id: 3593,
		type: PropertyType.PT_BINARY
	},
	PR_SENTMAIL_ENTRYID: {
		id: 3594,
		type: PropertyType.PT_BINARY
	},
	PR_CORRELATE: {
		id: 3596,
		type: PropertyType.PT_BOOLEAN
	},
	PR_CORRELATE_MTSID: {
		id: 3597,
		type: PropertyType.PT_BINARY
	},
	PR_DISCRETE_VALUES: {
		id: 3598,
		type: PropertyType.PT_BOOLEAN
	},
	PR_RESPONSIBILITY: {
		id: 3599,
		type: PropertyType.PT_BOOLEAN
	},
	PR_SPOOLER_STATUS: {
		id: 3600,
		type: PropertyType.PT_LONG
	},
	PR_TRANSPORT_STATUS: {
		id: 3601,
		type: PropertyType.PT_LONG
	},
	PR_MESSAGE_RECIPIENTS: {
		id: 3602,
		type: PropertyType.PT_OBJECT
	},
	PR_MESSAGE_ATTACHMENTS: {
		id: 3603,
		type: PropertyType.PT_OBJECT
	},
	PR_SUBMIT_FLAGS: {
		id: 3604,
		type: PropertyType.PT_LONG
	},
	PR_RECIPIENT_STATUS: {
		id: 3605,
		type: PropertyType.PT_LONG
	},
	PR_TRANSPORT_KEY: {
		id: 3606,
		type: PropertyType.PT_LONG
	},
	PR_MSG_STATUS: {
		id: 3607,
		type: PropertyType.PT_LONG
	},
	PR_MESSAGE_DOWNLOAD_TIME: {
		id: 3608,
		type: PropertyType.PT_LONG
	},
	PR_CREATION_VERSION: {
		id: 3609,
		type: PropertyType.PT_I8
	},
	PR_MODIFY_VERSION: {
		id: 3610,
		type: PropertyType.PT_I8
	},
	PR_HASATTACH: {
		id: 3611,
		type: PropertyType.PT_BOOLEAN
	},
	PR_BODY_CRC: {
		id: 3612,
		type: PropertyType.PT_LONG
	},
	PR_NORMALIZED_SUBJECT_W: {
		id: 3613,
		type: PropertyType.PT_UNICODE
	},
	PR_NORMALIZED_SUBJECT_A: {
		id: 3613,
		type: PropertyType.PT_STRING8
	},
	PR_RTF_IN_SYNC: {
		id: 3615,
		type: PropertyType.PT_BOOLEAN
	},
	PR_ATTACH_SIZE: {
		id: 3616,
		type: PropertyType.PT_LONG
	},
	PR_ATTACH_NUM: {
		id: 3617,
		type: PropertyType.PT_LONG
	},
	PR_ATTACH_FLAGS: {
		id: 14100,
		type: PropertyType.PT_LONG
	},
	PR_PREPROCESS: {
		id: 3618,
		type: PropertyType.PT_BOOLEAN
	},
	PR_ORIGINATING_MTA_CERTIFICATE: {
		id: 3621,
		type: PropertyType.PT_BINARY
	},
	PR_PROOF_OF_SUBMISSION: {
		id: 3622,
		type: PropertyType.PT_BINARY
	},
	PR_ENTRYID: {
		id: 4095,
		type: PropertyType.PT_BINARY
	},
	PR_OBJECT_TYPE: {
		id: 4094,
		type: PropertyType.PT_LONG
	},
	PR_ICON: {
		id: 4093,
		type: PropertyType.PT_BINARY
	},
	PR_MINI_ICON: {
		id: 4092,
		type: PropertyType.PT_BINARY
	},
	PR_STORE_ENTRYID: {
		id: 4091,
		type: PropertyType.PT_BINARY
	},
	PR_STORE_RECORD_KEY: {
		id: 4090,
		type: PropertyType.PT_BINARY
	},
	PR_RECORD_KEY: {
		id: 4089,
		type: PropertyType.PT_BINARY
	},
	PR_MAPPING_SIGNATURE: {
		id: 4088,
		type: PropertyType.PT_BINARY
	},
	PR_ACCESS_LEVEL: {
		id: 4087,
		type: PropertyType.PT_LONG
	},
	PR_INSTANCE_KEY: {
		id: 4086,
		type: PropertyType.PT_BINARY
	},
	PR_ROW_TYPE: {
		id: 4085,
		type: PropertyType.PT_LONG
	},
	PR_ACCESS: {
		id: 4084,
		type: PropertyType.PT_LONG
	},
	PR_ICON_INDEX: {
		id: 4224,
		type: PropertyType.PT_LONG
	},
	PR_LAST_VERB_EXECUTED: {
		id: 4225,
		type: PropertyType.PT_LONG
	},
	PR_LAST_VERB_EXECUTION_TIME: {
		id: 4226,
		type: PropertyType.PT_SYSTIME
	},
	PR_ROWID: {
		id: 12288,
		type: PropertyType.PT_LONG
	},
	PR_DISPLAY_NAME_W: {
		id: 12289,
		type: PropertyType.PT_UNICODE
	},
	PR_RECIPIENT_DISPLAY_NAME_A: {
		id: 24566,
		type: PropertyType.PT_STRING8
	},
	PR_RECIPIENT_DISPLAY_NAME_W: {
		id: 24566,
		type: PropertyType.PT_UNICODE
	},
	PR_RECIPIENT_FLAGS: {
		id: 24573,
		type: PropertyType.PT_LONG
	},
	PR_DISPLAY_NAME_A: {
		id: 12289,
		type: PropertyType.PT_STRING8
	},
	PR_ADDRTYPE_W: {
		id: 12290,
		type: PropertyType.PT_UNICODE
	},
	PR_ADDRTYPE_A: {
		id: 12290,
		type: PropertyType.PT_STRING8
	},
	PR_EMAIL_ADDRESS_W: {
		id: 12291,
		type: PropertyType.PT_UNICODE
	},
	PR_SMTP_ADDRESS_A: {
		id: 14846,
		type: PropertyType.PT_STRING8
	},
	PR_SMTP_ADDRESS_W: {
		id: 14846,
		type: PropertyType.PT_UNICODE
	},
	PR_7BIT_DISPLAY_NAME_A: {
		id: 14847,
		type: PropertyType.PT_STRING8
	},
	PR_7BIT_DISPLAY_NAME_W: {
		id: 14847,
		type: PropertyType.PT_UNICODE
	},
	PR_EMAIL_ADDRESS_A: {
		id: 12291,
		type: PropertyType.PT_STRING8
	},
	PR_COMMENT_W: {
		id: 12292,
		type: PropertyType.PT_UNICODE
	},
	PR_COMMENT_A: {
		id: 12292,
		type: PropertyType.PT_STRING8
	},
	PR_DEPTH: {
		id: 12293,
		type: PropertyType.PT_LONG
	},
	PR_PROVIDER_DISPLAY_W: {
		id: 12294,
		type: PropertyType.PT_UNICODE
	},
	PR_PROVIDER_DISPLAY_A: {
		id: 12294,
		type: PropertyType.PT_STRING8
	},
	PR_CREATION_TIME: {
		id: 12295,
		type: PropertyType.PT_SYSTIME
	},
	PR_LAST_MODIFICATION_TIME: {
		id: 12296,
		type: PropertyType.PT_SYSTIME
	},
	PR_RESOURCE_FLAGS: {
		id: 12297,
		type: PropertyType.PT_LONG
	},
	PR_PROVIDER_DLL_NAME_W: {
		id: 12298,
		type: PropertyType.PT_UNICODE
	},
	PR_PROVIDER_DLL_NAME_A: {
		id: 12298,
		type: PropertyType.PT_STRING8
	},
	PR_SEARCH_KEY: {
		id: 12299,
		type: PropertyType.PT_BINARY
	},
	PR_PROVIDER_UID: {
		id: 12300,
		type: PropertyType.PT_BINARY
	},
	PR_PROVIDER_ORDINAL: {
		id: 12301,
		type: PropertyType.PT_LONG
	},
	PR_FORM_VERSION_W: {
		id: 13057,
		type: PropertyType.PT_UNICODE
	},
	PR_FORM_VERSION_A: {
		id: 13057,
		type: PropertyType.PT_STRING8
	},
	PR_FORM_CONTACT_NAME_W: {
		id: 13059,
		type: PropertyType.PT_UNICODE
	},
	PR_FORM_CONTACT_NAME_A: {
		id: 13059,
		type: PropertyType.PT_STRING8
	},
	PR_FORM_CATEGORY_W: {
		id: 13060,
		type: PropertyType.PT_UNICODE
	},
	PR_FORM_CATEGORY_A: {
		id: 13060,
		type: PropertyType.PT_STRING8
	},
	PR_FORM_CATEGORY_SUB_W: {
		id: 13061,
		type: PropertyType.PT_UNICODE
	},
	PR_FORM_CATEGORY_SUB_A: {
		id: 13061,
		type: PropertyType.PT_STRING8
	},
	PR_FORM_HOST_MAP: {
		id: 13062,
		type: PropertyType.PT_MV_LONG
	},
	PR_FORM_HIDDEN: {
		id: 13063,
		type: PropertyType.PT_BOOLEAN
	},
	PR_FORM_DESIGNER_NAME_W: {
		id: 13064,
		type: PropertyType.PT_UNICODE
	},
	PR_FORM_DESIGNER_NAME_A: {
		id: 13064,
		type: PropertyType.PT_STRING8
	},
	PR_FORM_MESSAGE_BEHAVIOR: {
		id: 13066,
		type: PropertyType.PT_LONG
	},
	PR_DEFAULT_STORE: {
		id: 13312,
		type: PropertyType.PT_BOOLEAN
	},
	PR_STORE_SUPPORT_MASK: {
		id: 13325,
		type: PropertyType.PT_LONG
	},
	PR_STORE_STATE: {
		id: 13326,
		type: PropertyType.PT_LONG
	},
	PR_STORE_UNICODE_MASK: {
		id: 13327,
		type: PropertyType.PT_LONG
	},
	PR_IPM_SUBTREE_SEARCH_KEY: {
		id: 13328,
		type: PropertyType.PT_BINARY
	},
	PR_IPM_OUTBOX_SEARCH_KEY: {
		id: 13329,
		type: PropertyType.PT_BINARY
	},
	PR_IPM_WASTEBASKET_SEARCH_KEY: {
		id: 13330,
		type: PropertyType.PT_BINARY
	},
	PR_IPM_SENTMAIL_SEARCH_KEY: {
		id: 13331,
		type: PropertyType.PT_BINARY
	},
	PR_MDB_PROVIDER: {
		id: 13332,
		type: PropertyType.PT_BINARY
	},
	PR_RECEIVE_FOLDER_SETTINGS: {
		id: 13333,
		type: PropertyType.PT_OBJECT
	},
	PR_VALID_FOLDER_MASK: {
		id: 13791,
		type: PropertyType.PT_LONG
	},
	PR_IPM_SUBTREE_ENTRYID: {
		id: 13792,
		type: PropertyType.PT_BINARY
	},
	PR_IPM_OUTBOX_ENTRYID: {
		id: 13794,
		type: PropertyType.PT_BINARY
	},
	PR_IPM_WASTEBASKET_ENTRYID: {
		id: 13795,
		type: PropertyType.PT_BINARY
	},
	PR_IPM_SENTMAIL_ENTRYID: {
		id: 13796,
		type: PropertyType.PT_BINARY
	},
	PR_VIEWS_ENTRYID: {
		id: 13797,
		type: PropertyType.PT_BINARY
	},
	PR_COMMON_VIEWS_ENTRYID: {
		id: 13798,
		type: PropertyType.PT_BINARY
	},
	PR_FINDER_ENTRYID: {
		id: 13799,
		type: PropertyType.PT_BINARY
	},
	PR_CE_RECEIVE_BEFORE_SEND: {
		id: 33069,
		type: PropertyType.PT_BOOLEAN
	},
	PR_CONTAINER_FLAGS: {
		id: 13824,
		type: PropertyType.PT_LONG
	},
	PR_FOLDER_TYPE: {
		id: 13825,
		type: PropertyType.PT_LONG
	},
	PR_CONTENT_COUNT: {
		id: 13826,
		type: PropertyType.PT_LONG
	},
	PR_CONTENT_UNREAD: {
		id: 13827,
		type: PropertyType.PT_LONG
	},
	PR_CREATE_TEMPLATES: {
		id: 13828,
		type: PropertyType.PT_OBJECT
	},
	PR_DETAILS_TABLE: {
		id: 13829,
		type: PropertyType.PT_OBJECT
	},
	PR_SEARCH: {
		id: 13831,
		type: PropertyType.PT_OBJECT
	},
	PR_SELECTABLE: {
		id: 13833,
		type: PropertyType.PT_BOOLEAN
	},
	PR_SUBFOLDERS: {
		id: 13834,
		type: PropertyType.PT_BOOLEAN
	},
	PR_STATUS: {
		id: 13835,
		type: PropertyType.PT_LONG
	},
	PR_ANR_W: {
		id: 13836,
		type: PropertyType.PT_UNICODE
	},
	PR_ANR_A: {
		id: 13836,
		type: PropertyType.PT_STRING8
	},
	PR_CONTENTS_SORT_ORDER: {
		id: 13837,
		type: PropertyType.PT_MV_LONG
	},
	PR_CONTAINER_HIERARCHY: {
		id: 13838,
		type: PropertyType.PT_OBJECT
	},
	PR_CONTAINER_CONTENTS: {
		id: 13839,
		type: PropertyType.PT_OBJECT
	},
	PR_FOLDER_ASSOCIATED_CONTENTS: {
		id: 13840,
		type: PropertyType.PT_OBJECT
	},
	PR_DEF_CREATE_DL: {
		id: 13841,
		type: PropertyType.PT_BINARY
	},
	PR_DEF_CREATE_MAILUSER: {
		id: 13842,
		type: PropertyType.PT_BINARY
	},
	PR_CONTAINER_CLASS_W: {
		id: 13843,
		type: PropertyType.PT_UNICODE
	},
	PR_CONTAINER_CLASS_A: {
		id: 13843,
		type: PropertyType.PT_STRING8
	},
	PR_CONTAINER_MODIFY_VERSION: {
		id: 13844,
		type: PropertyType.PT_I8
	},
	PR_AB_PROVIDER_ID: {
		id: 13845,
		type: PropertyType.PT_BINARY
	},
	PR_DEFAULT_VIEW_ENTRYID: {
		id: 13846,
		type: PropertyType.PT_BINARY
	},
	PR_ASSOC_CONTENT_COUNT: {
		id: 13847,
		type: PropertyType.PT_LONG
	},
	PR_ATTACHMENT_X400_PARAMETERS: {
		id: 14080,
		type: PropertyType.PT_BINARY
	},
	PR_ATTACH_CONTENT_ID_W: {
		id: 14098,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_CONTENT_ID_A: {
		id: 14098,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_CONTENT_LOCATION_W: {
		id: 14099,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_CONTENT_LOCATION_A: {
		id: 14099,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_DATA_OBJ: {
		id: 14081,
		type: PropertyType.PT_OBJECT
	},
	PR_ATTACH_DATA_BIN: {
		id: 14081,
		type: PropertyType.PT_BINARY
	},
	PR_ATTACH_ENCODING: {
		id: 14082,
		type: PropertyType.PT_BINARY
	},
	PR_ATTACH_EXTENSION_W: {
		id: 14083,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_EXTENSION_A: {
		id: 14083,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_FILENAME_W: {
		id: 14084,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_FILENAME_A: {
		id: 14084,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_METHOD: {
		id: 14085,
		type: PropertyType.PT_LONG
	},
	PR_ATTACH_LONG_FILENAME_W: {
		id: 14087,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_LONG_FILENAME_A: {
		id: 14087,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_PATHNAME_W: {
		id: 14088,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_PATHNAME_A: {
		id: 14088,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_RENDERING: {
		id: 14089,
		type: PropertyType.PT_BINARY
	},
	PR_ATTACH_TAG: {
		id: 14090,
		type: PropertyType.PT_BINARY
	},
	PR_RENDERING_POSITION: {
		id: 14091,
		type: PropertyType.PT_LONG
	},
	PR_ATTACH_TRANSPORT_NAME_W: {
		id: 14092,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_TRANSPORT_NAME_A: {
		id: 14092,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_LONG_PATHNAME_W: {
		id: 14093,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_LONG_PATHNAME_A: {
		id: 14093,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_MIME_TAG_W: {
		id: 14094,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACH_MIME_TAG_A: {
		id: 14094,
		type: PropertyType.PT_STRING8
	},
	PR_ATTACH_ADDITIONAL_INFO: {
		id: 14095,
		type: PropertyType.PT_BINARY
	},
	PR_DISPLAY_TYPE: {
		id: 14592,
		type: PropertyType.PT_LONG
	},
	PR_TEMPLATEID: {
		id: 14594,
		type: PropertyType.PT_BINARY
	},
	PR_PRIMARY_CAPABILITY: {
		id: 14596,
		type: PropertyType.PT_BINARY
	},
	PR_DISPLAY_TYPE_EX: {
		id: 14597,
		type: PropertyType.PT_LONG
	},
	PR_ACCOUNT_W: {
		id: 14848,
		type: PropertyType.PT_UNICODE
	},
	PR_ACCOUNT_A: {
		id: 14848,
		type: PropertyType.PT_STRING8
	},
	PR_ALTERNATE_RECIPIENT: {
		id: 14849,
		type: PropertyType.PT_BINARY
	},
	PR_CALLBACK_TELEPHONE_NUMBER_W: {
		id: 14850,
		type: PropertyType.PT_UNICODE
	},
	PR_CALLBACK_TELEPHONE_NUMBER_A: {
		id: 14850,
		type: PropertyType.PT_STRING8
	},
	PR_CONVERSION_PROHIBITED: {
		id: 14851,
		type: PropertyType.PT_BOOLEAN
	},
	PR_DISCLOSE_RECIPIENTS: {
		id: 14852,
		type: PropertyType.PT_BOOLEAN
	},
	PR_GENERATION_W: {
		id: 14853,
		type: PropertyType.PT_UNICODE
	},
	PR_GENERATION_A: {
		id: 14853,
		type: PropertyType.PT_STRING8
	},
	PR_GIVEN_NAME_W: {
		id: 14854,
		type: PropertyType.PT_UNICODE
	},
	PR_GIVEN_NAME_A: {
		id: 14854,
		type: PropertyType.PT_STRING8
	},
	PR_GOVERNMENT_ID_NUMBER_W: {
		id: 14855,
		type: PropertyType.PT_UNICODE
	},
	PR_GOVERNMENT_ID_NUMBER_A: {
		id: 14855,
		type: PropertyType.PT_STRING8
	},
	PR_BUSINESS_TELEPHONE_NUMBER_W: {
		id: 14856,
		type: PropertyType.PT_UNICODE
	},
	PR_BUSINESS_TELEPHONE_NUMBER_A: {
		id: 14856,
		type: PropertyType.PT_STRING8
	},
	PR_HOME_TELEPHONE_NUMBER_W: {
		id: 14857,
		type: PropertyType.PT_UNICODE
	},
	PR_HOME_TELEPHONE_NUMBER_A: {
		id: 14857,
		type: PropertyType.PT_STRING8
	},
	PR_INITIALS_W: {
		id: 14858,
		type: PropertyType.PT_UNICODE
	},
	PR_INITIALS_A: {
		id: 14858,
		type: PropertyType.PT_STRING8
	},
	PR_KEYWORD_W: {
		id: 14859,
		type: PropertyType.PT_UNICODE
	},
	PR_KEYWORD_A: {
		id: 14859,
		type: PropertyType.PT_STRING8
	},
	PR_LANGUAGE_W: {
		id: 14860,
		type: PropertyType.PT_UNICODE
	},
	PR_LANGUAGE_A: {
		id: 14860,
		type: PropertyType.PT_STRING8
	},
	PR_LOCATION_W: {
		id: 14861,
		type: PropertyType.PT_UNICODE
	},
	PR_LOCATION_A: {
		id: 14861,
		type: PropertyType.PT_STRING8
	},
	PR_MAIL_PERMISSION: {
		id: 14862,
		type: PropertyType.PT_BOOLEAN
	},
	PR_MHS_COMMON_NAME_W: {
		id: 14863,
		type: PropertyType.PT_UNICODE
	},
	PR_MHS_COMMON_NAME_A: {
		id: 14863,
		type: PropertyType.PT_STRING8
	},
	PR_ORGANIZATIONAL_ID_NUMBER_W: {
		id: 14864,
		type: PropertyType.PT_UNICODE
	},
	PR_ORGANIZATIONAL_ID_NUMBER_A: {
		id: 14864,
		type: PropertyType.PT_STRING8
	},
	PR_SURNAME_W: {
		id: 14865,
		type: PropertyType.PT_UNICODE
	},
	PR_SURNAME_A: {
		id: 14865,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_ENTRYID: {
		id: 14866,
		type: PropertyType.PT_BINARY
	},
	PR_ORIGINAL_DISPLAY_NAME_W: {
		id: 14867,
		type: PropertyType.PT_UNICODE
	},
	PR_ORIGINAL_DISPLAY_NAME_A: {
		id: 14867,
		type: PropertyType.PT_STRING8
	},
	PR_ORIGINAL_SEARCH_KEY: {
		id: 14868,
		type: PropertyType.PT_BINARY
	},
	PR_POSTAL_ADDRESS_W: {
		id: 14869,
		type: PropertyType.PT_UNICODE
	},
	PR_POSTAL_ADDRESS_A: {
		id: 14869,
		type: PropertyType.PT_STRING8
	},
	PR_COMPANY_NAME_W: {
		id: 14870,
		type: PropertyType.PT_UNICODE
	},
	PR_COMPANY_NAME_A: {
		id: 14870,
		type: PropertyType.PT_STRING8
	},
	PR_TITLE_W: {
		id: 14871,
		type: PropertyType.PT_UNICODE
	},
	PR_TITLE_A: {
		id: 14871,
		type: PropertyType.PT_STRING8
	},
	PR_DEPARTMENT_NAME_W: {
		id: 14872,
		type: PropertyType.PT_UNICODE
	},
	PR_DEPARTMENT_NAME_A: {
		id: 14872,
		type: PropertyType.PT_STRING8
	},
	PR_OFFICE_LOCATION_W: {
		id: 14873,
		type: PropertyType.PT_UNICODE
	},
	PR_OFFICE_LOCATION_A: {
		id: 14873,
		type: PropertyType.PT_STRING8
	},
	PR_PRIMARY_TELEPHONE_NUMBER_W: {
		id: 14874,
		type: PropertyType.PT_UNICODE
	},
	PR_PRIMARY_TELEPHONE_NUMBER_A: {
		id: 14874,
		type: PropertyType.PT_STRING8
	},
	PR_BUSINESS2_TELEPHONE_NUMBER_W: {
		id: 14875,
		type: PropertyType.PT_UNICODE
	},
	PR_BUSINESS2_TELEPHONE_NUMBER_A: {
		id: 14875,
		type: PropertyType.PT_STRING8
	},
	PR_MOBILE_TELEPHONE_NUMBER_W: {
		id: 14876,
		type: PropertyType.PT_UNICODE
	},
	PR_MOBILE_TELEPHONE_NUMBER_A: {
		id: 14876,
		type: PropertyType.PT_STRING8
	},
	PR_RADIO_TELEPHONE_NUMBER_W: {
		id: 14877,
		type: PropertyType.PT_UNICODE
	},
	PR_RADIO_TELEPHONE_NUMBER_A: {
		id: 14877,
		type: PropertyType.PT_STRING8
	},
	PR_CAR_TELEPHONE_NUMBER_W: {
		id: 14878,
		type: PropertyType.PT_UNICODE
	},
	PR_CAR_TELEPHONE_NUMBER_A: {
		id: 14878,
		type: PropertyType.PT_STRING8
	},
	PR_OTHER_TELEPHONE_NUMBER_W: {
		id: 14879,
		type: PropertyType.PT_UNICODE
	},
	PR_OTHER_TELEPHONE_NUMBER_A: {
		id: 14879,
		type: PropertyType.PT_STRING8
	},
	PR_TRANSMITABLE_DISPLAY_NAME_W: {
		id: 14880,
		type: PropertyType.PT_UNICODE
	},
	PR_TRANSMITABLE_DISPLAY_NAME_A: {
		id: 14880,
		type: PropertyType.PT_STRING8
	},
	PR_PAGER_TELEPHONE_NUMBER_W: {
		id: 14881,
		type: PropertyType.PT_UNICODE
	},
	PR_PAGER_TELEPHONE_NUMBER_A: {
		id: 14881,
		type: PropertyType.PT_STRING8
	},
	PR_USER_CERTIFICATE: {
		id: 14882,
		type: PropertyType.PT_BINARY
	},
	PR_PRIMARY_FAX_NUMBER_W: {
		id: 14883,
		type: PropertyType.PT_UNICODE
	},
	PR_PRIMARY_FAX_NUMBER_A: {
		id: 14883,
		type: PropertyType.PT_STRING8
	},
	PR_BUSINESS_FAX_NUMBER_W: {
		id: 14884,
		type: PropertyType.PT_UNICODE
	},
	PR_BUSINESS_FAX_NUMBER_A: {
		id: 14884,
		type: PropertyType.PT_STRING8
	},
	PR_HOME_FAX_NUMBER_W: {
		id: 14885,
		type: PropertyType.PT_UNICODE
	},
	PR_HOME_FAX_NUMBER_A: {
		id: 14885,
		type: PropertyType.PT_STRING8
	},
	PR_COUNTRY_W: {
		id: 14886,
		type: PropertyType.PT_UNICODE
	},
	PR_COUNTRY_A: {
		id: 14886,
		type: PropertyType.PT_STRING8
	},
	PR_LOCALITY_W: {
		id: 14887,
		type: PropertyType.PT_UNICODE
	},
	PR_LOCALITY_A: {
		id: 14887,
		type: PropertyType.PT_STRING8
	},
	PR_STATE_OR_PROVINCE_W: {
		id: 14888,
		type: PropertyType.PT_UNICODE
	},
	PR_STATE_OR_PROVINCE_A: {
		id: 14888,
		type: PropertyType.PT_STRING8
	},
	PR_STREET_ADDRESS_W: {
		id: 14889,
		type: PropertyType.PT_UNICODE
	},
	PR_STREET_ADDRESS_A: {
		id: 14889,
		type: PropertyType.PT_STRING8
	},
	PR_POSTAL_CODE_W: {
		id: 14890,
		type: PropertyType.PT_UNICODE
	},
	PR_POSTAL_CODE_A: {
		id: 14890,
		type: PropertyType.PT_STRING8
	},
	PR_POST_OFFICE_BOX_W: {
		id: 14891,
		type: PropertyType.PT_UNICODE
	},
	PR_POST_OFFICE_BOX_A: {
		id: 14891,
		type: PropertyType.PT_STRING8
	},
	PR_TELEX_NUMBER_W: {
		id: 14892,
		type: PropertyType.PT_UNICODE
	},
	PR_TELEX_NUMBER_A: {
		id: 14892,
		type: PropertyType.PT_STRING8
	},
	PR_ISDN_NUMBER_W: {
		id: 14893,
		type: PropertyType.PT_UNICODE
	},
	PR_ISDN_NUMBER_A: {
		id: 14893,
		type: PropertyType.PT_STRING8
	},
	PR_ASSISTANT_TELEPHONE_NUMBER_W: {
		id: 14894,
		type: PropertyType.PT_UNICODE
	},
	PR_ASSISTANT_TELEPHONE_NUMBER_A: {
		id: 14894,
		type: PropertyType.PT_STRING8
	},
	PR_HOME2_TELEPHONE_NUMBER_W: {
		id: 14895,
		type: PropertyType.PT_UNICODE
	},
	PR_HOME2_TELEPHONE_NUMBER_A: {
		id: 14895,
		type: PropertyType.PT_STRING8
	},
	PR_ASSISTANT_W: {
		id: 14896,
		type: PropertyType.PT_UNICODE
	},
	PR_ASSISTANT_A: {
		id: 14896,
		type: PropertyType.PT_STRING8
	},
	PR_SEND_RICH_INFO: {
		id: 14912,
		type: PropertyType.PT_BOOLEAN
	},
	PR_STORE_PROVIDERS: {
		id: 15616,
		type: PropertyType.PT_BINARY
	},
	PR_AB_PROVIDERS: {
		id: 15617,
		type: PropertyType.PT_BINARY
	},
	PR_TRANSPORT_PROVIDERS: {
		id: 15618,
		type: PropertyType.PT_BINARY
	},
	PR_DEFAULT_PROFILE: {
		id: 15620,
		type: PropertyType.PT_BOOLEAN
	},
	PR_AB_SEARCH_PATH: {
		id: 15621,
		type: PropertyType.PT_MV_BINARY
	},
	PR_AB_DEFAULT_DIR: {
		id: 15622,
		type: PropertyType.PT_BINARY
	},
	PR_AB_DEFAULT_PAB: {
		id: 15623,
		type: PropertyType.PT_BINARY
	},
	PR_FILTERING_HOOKS: {
		id: 15624,
		type: PropertyType.PT_BINARY
	},
	PR_SERVICE_NAME_W: {
		id: 15625,
		type: PropertyType.PT_UNICODE
	},
	PR_SERVICE_NAME_A: {
		id: 15625,
		type: PropertyType.PT_STRING8
	},
	PR_SERVICE_DLL_NAME_W: {
		id: 15626,
		type: PropertyType.PT_UNICODE
	},
	PR_SERVICE_DLL_NAME_A: {
		id: 15626,
		type: PropertyType.PT_STRING8
	},
	PR_SERVICE_UID: {
		id: 15628,
		type: PropertyType.PT_BINARY
	},
	PR_SERVICE_EXTRA_UIDS: {
		id: 15629,
		type: PropertyType.PT_BINARY
	},
	PR_SERVICES: {
		id: 15630,
		type: PropertyType.PT_BINARY
	},
	PR_SERVICE_SUPPORT_FILES_W: {
		id: 15631,
		type: PropertyType.PT_MV_UNICODE
	},
	PR_SERVICE_SUPPORT_FILES_A: {
		id: 15631,
		type: PropertyType.PT_MV_STRING8
	},
	PR_SERVICE_DELETE_FILES_W: {
		id: 15632,
		type: PropertyType.PT_MV_UNICODE
	},
	PR_SERVICE_DELETE_FILES_A: {
		id: 15632,
		type: PropertyType.PT_MV_STRING8
	},
	PR_AB_SEARCH_PATH_UPDATE: {
		id: 15633,
		type: PropertyType.PT_BINARY
	},
	PR_PROFILE_NAME_A: {
		id: 15634,
		type: PropertyType.PT_STRING8
	},
	PR_PROFILE_NAME_W: {
		id: 15634,
		type: PropertyType.PT_UNICODE
	},
	PR_IDENTITY_DISPLAY_W: {
		id: 15872,
		type: PropertyType.PT_UNICODE
	},
	PR_IDENTITY_DISPLAY_A: {
		id: 15872,
		type: PropertyType.PT_STRING8
	},
	PR_IDENTITY_ENTRYID: {
		id: 15873,
		type: PropertyType.PT_BINARY
	},
	PR_RESOURCE_METHODS: {
		id: 15874,
		type: PropertyType.PT_LONG
	},
	PR_RESOURCE_TYPE: {
		id: 15875,
		type: PropertyType.PT_LONG
	},
	PR_STATUS_CODE: {
		id: 15876,
		type: PropertyType.PT_LONG
	},
	PR_IDENTITY_SEARCH_KEY: {
		id: 15877,
		type: PropertyType.PT_BINARY
	},
	PR_OWN_STORE_ENTRYID: {
		id: 15878,
		type: PropertyType.PT_BINARY
	},
	PR_RESOURCE_PATH_W: {
		id: 15879,
		type: PropertyType.PT_UNICODE
	},
	PR_RESOURCE_PATH_A: {
		id: 15879,
		type: PropertyType.PT_STRING8
	},
	PR_STATUS_STRING_W: {
		id: 15880,
		type: PropertyType.PT_UNICODE
	},
	PR_STATUS_STRING_A: {
		id: 15880,
		type: PropertyType.PT_STRING8
	},
	PR_X400_DEFERRED_DELIVERY_CANCEL: {
		id: 15881,
		type: PropertyType.PT_BOOLEAN
	},
	PR_HEADER_FOLDER_ENTRYID: {
		id: 15882,
		type: PropertyType.PT_BINARY
	},
	PR_REMOTE_PROGRESS: {
		id: 15883,
		type: PropertyType.PT_LONG
	},
	PR_REMOTE_PROGRESS_TEXT_W: {
		id: 15884,
		type: PropertyType.PT_UNICODE
	},
	PR_REMOTE_PROGRESS_TEXT_A: {
		id: 15884,
		type: PropertyType.PT_STRING8
	},
	PR_REMOTE_VALIDATE_OK: {
		id: 15885,
		type: PropertyType.PT_BOOLEAN
	},
	PR_CONTROL_FLAGS: {
		id: 16128,
		type: PropertyType.PT_LONG
	},
	PR_CONTROL_STRUCTURE: {
		id: 16129,
		type: PropertyType.PT_BINARY
	},
	PR_CONTROL_TYPE: {
		id: 16130,
		type: PropertyType.PT_LONG
	},
	PR_DELTAX: {
		id: 16131,
		type: PropertyType.PT_LONG
	},
	PR_DELTAY: {
		id: 16132,
		type: PropertyType.PT_LONG
	},
	PR_XPOS: {
		id: 16133,
		type: PropertyType.PT_LONG
	},
	PR_YPOS: {
		id: 16134,
		type: PropertyType.PT_LONG
	},
	PR_CONTROL_ID: {
		id: 16135,
		type: PropertyType.PT_BINARY
	},
	PR_INITIAL_DETAILS_PANE: {
		id: 16136,
		type: PropertyType.PT_LONG
	},
	PR_MESSAGE_LOCALE_ID: {
		id: 16136,
		type: PropertyType.PT_LONG
	},
	PR_INTERNET_CPID: {
		id: 16350,
		type: PropertyType.PT_LONG
	},
	PR_CreatorAddrType_W: {
		id: 16418,
		type: PropertyType.PT_UNICODE
	},
	PR_CreatorEmailAddr_W: {
		id: 16419,
		type: PropertyType.PT_UNICODE
	},
	PR_CreatorSimpleDispName_W: {
		id: 16440,
		type: PropertyType.PT_UNICODE
	},
	PR_SenderSimpleDispName_W: {
		id: 16432,
		type: PropertyType.PT_UNICODE
	},
	PR_ATTACHMENT_LINKID: {
		id: 32762,
		type: PropertyType.PT_LONG
	},
	PR_ATTACHMENT_FLAGS: {
		id: 32765,
		type: PropertyType.PT_LONG
	},
	PR_ATTACHMENT_HIDDEN: {
		id: 32766,
		type: PropertyType.PT_BOOLEAN
	},
	PR_MSG_EDITOR_FORMAT: {
		id: 22793,
		type: PropertyType.PT_LONG
	}
});
var _default = rng;
var _crypto = _interopRequireDefault(require$$0$2);
function _interopRequireDefault(obj) {
	return obj && obj.__esModule ? obj : { default: obj };
}
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
	if (poolPtr > rnds8Pool.length - 16) {
		_crypto.default.randomFillSync(rnds8Pool);
		poolPtr = 0;
	}
	return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var rng_1 = /*#__PURE__*/ Object.defineProperty({ default: _default }, "__esModule", { value: true });
var regex = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _default$1 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
	exports.default = _default$1;
});
var validate_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _regex = _interopRequireDefault$1(regex);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function validate(uuid) {
		return typeof uuid === "string" && _regex.default.test(uuid);
	}
	var _default$1 = validate;
	exports.default = _default$1;
});
var stringify_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _validate = _interopRequireDefault$1(validate_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	/**
	* Convert array of 16 byte values to UUID string format of the form:
	* XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	*/
	const byteToHex = [];
	for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));
	function stringify(arr, offset = 0) {
		const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
		if (!(0, _validate.default)(uuid)) throw TypeError("Stringified UUID is invalid");
		return uuid;
	}
	var _default$1 = stringify;
	exports.default = _default$1;
});
var v1_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _rng = _interopRequireDefault$1(rng_1);
	var _stringify = _interopRequireDefault$1(stringify_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	let _nodeId;
	let _clockseq;
	let _lastMSecs = 0;
	let _lastNSecs = 0;
	function v1(options, buf, offset) {
		let i = buf && offset || 0;
		const b = buf || new Array(16);
		options = options || {};
		let node = options.node || _nodeId;
		let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
		if (node == null || clockseq == null) {
			const seedBytes = options.random || (options.rng || _rng.default)();
			if (node == null) node = _nodeId = [
				seedBytes[0] | 1,
				seedBytes[1],
				seedBytes[2],
				seedBytes[3],
				seedBytes[4],
				seedBytes[5]
			];
			if (clockseq == null) clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
		}
		let msecs = options.msecs !== undefined ? options.msecs : Date.now();
		let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
		const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
		if (dt < 0 && options.clockseq === undefined) clockseq = clockseq + 1 & 16383;
		if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) nsecs = 0;
		if (nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
		_lastMSecs = msecs;
		_lastNSecs = nsecs;
		_clockseq = clockseq;
		msecs += 122192928e5;
		const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
		b[i++] = tl >>> 24 & 255;
		b[i++] = tl >>> 16 & 255;
		b[i++] = tl >>> 8 & 255;
		b[i++] = tl & 255;
		const tmh = msecs / 4294967296 * 1e4 & 268435455;
		b[i++] = tmh >>> 8 & 255;
		b[i++] = tmh & 255;
		b[i++] = tmh >>> 24 & 15 | 16;
		b[i++] = tmh >>> 16 & 255;
		b[i++] = clockseq >>> 8 | 128;
		b[i++] = clockseq & 255;
		for (let n = 0; n < 6; ++n) b[i + n] = node[n];
		return buf || (0, _stringify.default)(b);
	}
	var _default$1 = v1;
	exports.default = _default$1;
});
var parse_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _validate = _interopRequireDefault$1(validate_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function parse(uuid) {
		if (!(0, _validate.default)(uuid)) throw TypeError("Invalid UUID");
		let v;
		const arr = new Uint8Array(16);
		arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
		arr[1] = v >>> 16 & 255;
		arr[2] = v >>> 8 & 255;
		arr[3] = v & 255;
		arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
		arr[5] = v & 255;
		arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
		arr[7] = v & 255;
		arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
		arr[9] = v & 255;
		arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
		arr[11] = v / 4294967296 & 255;
		arr[12] = v >>> 24 & 255;
		arr[13] = v >>> 16 & 255;
		arr[14] = v >>> 8 & 255;
		arr[15] = v & 255;
		return arr;
	}
	var _default$1 = parse;
	exports.default = _default$1;
});
var v35 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = _default$1;
	exports.URL = exports.DNS = void 0;
	var _stringify = _interopRequireDefault$1(stringify_1);
	var _parse = _interopRequireDefault$1(parse_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function stringToBytes(str) {
		str = unescape(encodeURIComponent(str));
		const bytes = [];
		for (let i = 0; i < str.length; ++i) bytes.push(str.charCodeAt(i));
		return bytes;
	}
	const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
	exports.DNS = DNS;
	const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
	exports.URL = URL;
	function _default$1(name$1, version, hashfunc) {
		function generateUUID(value, namespace, buf, offset) {
			if (typeof value === "string") value = stringToBytes(value);
			if (typeof namespace === "string") namespace = (0, _parse.default)(namespace);
			if (namespace.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
			let bytes = new Uint8Array(16 + value.length);
			bytes.set(namespace);
			bytes.set(value, namespace.length);
			bytes = hashfunc(bytes);
			bytes[6] = bytes[6] & 15 | version;
			bytes[8] = bytes[8] & 63 | 128;
			if (buf) {
				offset = offset || 0;
				for (let i = 0; i < 16; ++i) buf[offset + i] = bytes[i];
				return buf;
			}
			return (0, _stringify.default)(bytes);
		}
		try {
			generateUUID.name = name$1;
		} catch (err) {}
		generateUUID.DNS = DNS;
		generateUUID.URL = URL;
		return generateUUID;
	}
});
var md5_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _crypto$1 = _interopRequireDefault$1(require$$0$2);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function md5(bytes) {
		if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
		return _crypto$1.default.createHash("md5").update(bytes).digest();
	}
	var _default$1 = md5;
	exports.default = _default$1;
});
var v3_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _v = _interopRequireDefault$1(v35);
	var _md = _interopRequireDefault$1(md5_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	const v3 = (0, _v.default)("v3", 48, _md.default);
	var _default$1 = v3;
	exports.default = _default$1;
});
var v4_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _rng = _interopRequireDefault$1(rng_1);
	var _stringify = _interopRequireDefault$1(stringify_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function v4(options, buf, offset) {
		options = options || {};
		const rnds = options.random || (options.rng || _rng.default)();
		rnds[6] = rnds[6] & 15 | 64;
		rnds[8] = rnds[8] & 63 | 128;
		if (buf) {
			offset = offset || 0;
			for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
			return buf;
		}
		return (0, _stringify.default)(rnds);
	}
	var _default$1 = v4;
	exports.default = _default$1;
});
var sha1_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _crypto$1 = _interopRequireDefault$1(require$$0$2);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function sha1(bytes) {
		if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
		return _crypto$1.default.createHash("sha1").update(bytes).digest();
	}
	var _default$1 = sha1;
	exports.default = _default$1;
});
var v5_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _v = _interopRequireDefault$1(v35);
	var _sha = _interopRequireDefault$1(sha1_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	const v5 = (0, _v.default)("v5", 80, _sha.default);
	var _default$1 = v5;
	exports.default = _default$1;
});
var nil = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _default$1 = "00000000-0000-0000-0000-000000000000";
	exports.default = _default$1;
});
var version_1 = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _validate = _interopRequireDefault$1(validate_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function version(uuid) {
		if (!(0, _validate.default)(uuid)) throw TypeError("Invalid UUID");
		return parseInt(uuid.substr(14, 1), 16);
	}
	var _default$1 = version;
	exports.default = _default$1;
});
var dist = createCommonjsModule(function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	Object.defineProperty(exports, "v1", {
		enumerable: true,
		get: function() {
			return _v.default;
		}
	});
	Object.defineProperty(exports, "v3", {
		enumerable: true,
		get: function() {
			return _v2.default;
		}
	});
	Object.defineProperty(exports, "v4", {
		enumerable: true,
		get: function() {
			return _v3.default;
		}
	});
	Object.defineProperty(exports, "v5", {
		enumerable: true,
		get: function() {
			return _v4.default;
		}
	});
	Object.defineProperty(exports, "NIL", {
		enumerable: true,
		get: function() {
			return _nil.default;
		}
	});
	Object.defineProperty(exports, "version", {
		enumerable: true,
		get: function() {
			return _version.default;
		}
	});
	Object.defineProperty(exports, "validate", {
		enumerable: true,
		get: function() {
			return _validate.default;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return _stringify.default;
		}
	});
	Object.defineProperty(exports, "parse", {
		enumerable: true,
		get: function() {
			return _parse.default;
		}
	});
	var _v = _interopRequireDefault$1(v1_1);
	var _v2 = _interopRequireDefault$1(v3_1);
	var _v3 = _interopRequireDefault$1(v4_1);
	var _v4 = _interopRequireDefault$1(v5_1);
	var _nil = _interopRequireDefault$1(nil);
	var _version = _interopRequireDefault$1(version_1);
	var _validate = _interopRequireDefault$1(validate_1);
	var _stringify = _interopRequireDefault$1(stringify_1);
	var _parse = _interopRequireDefault$1(parse_1);
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
});
var Property = class {
	constructor(obj) {
		this.id = obj.id;
		this.type = obj.type;
		this._data = obj.data;
		this._multiValue = obj.multiValue == null ? false : obj.multiValue;
		this._flags = obj.flags == null ? 0 : obj.flags;
	}
	name() {
		return name(this);
	}
	shortName() {
		return X4(this.id);
	}
	flagsCollection() {
		const result = [];
		if ((this._flags & 1) !== 0) result.push(
			1
			/* PROPATTR_MANDATORY */
);
		if ((this._flags & 2) !== 0) result.push(
			2
			/* PROPATTR_READABLE */
);
		if ((this._flags & 4) !== 0) result.push(
			4
			/* PROPATTR_WRITABLE */
);
		return result;
	}
	asInt() {
		const view = new DataView(this._data.buffer, 0);
		switch (this.type) {
			case PropertyType.PT_SHORT: return view.getInt16(0, false);
			case PropertyType.PT_LONG: return view.getInt32(0, false);
			default: throw new Error("type is not PT_SHORT or PT_LONG");
		}
	}
	asSingle() {
		const view = new DataView(this._data.buffer, 0);
		switch (this.type) {
			case PropertyType.PT_FLOAT: return view.getFloat32(0, false);
			default: throw new Error("type is not PT_FLOAT");
		}
	}
	asDouble() {
		const view = new DataView(this._data.buffer, 0);
		switch (this.type) {
			case PropertyType.PT_FLOAT: return view.getFloat64(0, false);
			default: throw new Error("type is not PT_DOUBLE");
		}
	}
	asDecimal() {
		const view = new DataView(this._data.buffer, 0);
		switch (this.type) {
			case PropertyType.PT_FLOAT: return view.getFloat32(0, false);
			default: throw new Error("type is not PT_FLOAT");
		}
	}
	asDateTime() {
		const view = new DataView(this._data.buffer, 0);
		switch (this.type) {
			case PropertyType.PT_APPTIME:
				const oaDate = view.getFloat64(0, false);
				return oADateToDate(oaDate);
			case PropertyType.PT_SYSTIME:
				const fileTimeLower = view.getUint32(0, false);
				const fileTimeUpper = view.getUint32(4, false);
				return fileTimeToDate(bigInt64FromParts(fileTimeLower, fileTimeUpper));
			default: throw new Error("type is not PT_APPTIME or PT_SYSTIME");
		}
	}
	asBool() {
		new DataView(this._data.buffer, 0);
		switch (this.type) {
			case PropertyType.PT_BOOLEAN: return Boolean(this._data[0]);
			default: throw new Error("type is not PT_BOOLEAN");
		}
	}
	asLong() {
		const view = new DataView(this._data.buffer, 0);
		switch (this.type) {
			case PropertyType.PT_LONG:
			case PropertyType.PT_LONGLONG:
				const val = view.getFloat64(0, false);
				if (val > Number.MAX_SAFE_INTEGER) throw new Error("implementation can't handle big longs yet");
				return val;
			default: throw new Error("type is not PT_LONG");
		}
	}
	asString() {
		switch (this.type) {
			case PropertyType.PT_UNICODE: return utf8ArrayToString(this._data);
			case PropertyType.PT_STRING8: return String.fromCharCode(...this._data);
			default: throw new Error("Type is not PT_UNICODE or PT_STRING8");
		}
	}
	asGuid() {
		switch (this.type) {
			case PropertyType.PT_CLSID: return dist.v4({ random: this._data.slice(0, 16) });
			default: throw new Error("Type is not PT_CLSID");
		}
	}
	asBinary() {
		switch (this.type) {
			case PropertyType.PT_BINARY: return this._data.slice();
			default: throw new Error("Type is not PT_BINARY");
		}
	}
};
const DEFAULT_FLAGS = 6;
var Properties = class extends Array {
	/**
	* add a prop it it doesn't exist, otherwise replace it
	*/
	addOrReplaceProperty(tag, obj, flags = 6) {
		const index = this.findIndex((p) => p.id === tag.id);
		if (index >= 0) this.splice(index, 1);
		this.addProperty(tag, obj, flags);
	}
	_expectPropertyType(expected, actual) {
		if (actual !== expected) throw new Error(`Invalid PropertyType "${PropertyType[actual]}". Expected "${PropertyType[expected]}"`);
	}
	addDateProperty(tag, value, flags = DEFAULT_FLAGS) {
		this._expectPropertyType(PropertyType.PT_SYSTIME, tag.type);
		this._addProperty(tag, dateToFileTime(value), flags);
	}
	addBinaryProperty(tag, data, flags = DEFAULT_FLAGS) {
		this._expectPropertyType(PropertyType.PT_BINARY, tag.type);
		this._addProperty(tag, data, flags);
	}
	_addProperty(tag, value, flags) {
		return this.addProperty(tag, value, flags);
	}
	/**
	* @deprecated use typed addPropertyFunctions instead (or make one if it doesn't exist). replace this method with _addProperty and only use it internally
	* @param tag
	* @param value
	* @param flags
	*/
	addProperty(tag, value, flags = DEFAULT_FLAGS) {
		if (value == null) return;
		let data = new Uint8Array(0);
		let view;
		switch (tag.type) {
			case PropertyType.PT_APPTIME:
				data = new Uint8Array(8);
				view = new DataView(data.buffer);
				view.setFloat64(0, value, true);
				break;
			case PropertyType.PT_SYSTIME:
				data = new Uint8Array(8);
				view = new DataView(data.buffer);
				const { upper, lower } = bigInt64ToParts(value);
				view.setInt32(0, lower, true);
				view.setInt32(4, upper, true);
				break;
			case PropertyType.PT_SHORT:
				data = new Uint8Array(2);
				view = new DataView(data.buffer);
				view.setInt16(0, value, true);
				break;
			case PropertyType.PT_ERROR:
			case PropertyType.PT_LONG:
				data = new Uint8Array(4);
				view = new DataView(data.buffer);
				view.setInt32(0, value, true);
				break;
			case PropertyType.PT_FLOAT:
				data = new Uint8Array(4);
				view = new DataView(data.buffer);
				view.setFloat32(0, value, true);
				break;
			case PropertyType.PT_DOUBLE:
				data = new Uint8Array(8);
				view = new DataView(data.buffer);
				view.setFloat64(0, value, true);
				break;
			case PropertyType.PT_BOOLEAN:
				data = Uint8Array.from([value ? 1 : 0]);
				break;
			case PropertyType.PT_I8: throw new Error("PT_I8 property type is not supported (64 bit ints)!");
			case PropertyType.PT_UNICODE:
				data = stringToUtf16LeArray(value);
				break;
			case PropertyType.PT_STRING8:
				data = stringToAnsiArray(value);
				break;
			case PropertyType.PT_CLSID:
				data = value;
				break;
			case PropertyType.PT_BINARY:
				if (value instanceof Uint8Array) {
					data = value;
					break;
				}
				const objType = typeof value;
				switch (objType) {
					case "boolean":
						data = Uint8Array.from(value);
						break;
					case "string":
						data = stringToUtf8Array(value);
						break;
					default: throw new Error(`PT_BINARY property of type '${objType}' not supported!`);
				}
				break;
			case PropertyType.PT_NULL: break;
			case PropertyType.PT_ACTIONS: throw new Error("PT_ACTIONS property type is not supported");
			case PropertyType.PT_UNSPECIFIED: throw new Error("PT_UNSPECIFIED property type is not supported");
			case PropertyType.PT_OBJECT: break;
			case PropertyType.PT_SVREID: throw new Error("PT_SVREID property type is not supported");
			case PropertyType.PT_SRESTRICT: throw new Error("PT_SRESTRICT property type is not supported");
			default: throw new Error("type is out of range!");
		}
		this.push(new Property({
			id: tag.id,
			type: tag.type,
			flags,
			data
		}));
	}
	/**
	* writes the properties structure to a cfb stream in storage
	* @param storage
	* @param prefix a function that will be called with the buffer before the properties get written to it.
	* @param messageSize
	* @returns {number}
	*/
	writeProperties(storage, prefix, messageSize) {
		const buf = makeByteBuffer();
		prefix(buf);
		let size = 0;
		for (let property of this) {
			buf.writeUint16(property.type);
			buf.writeUint16(property.id);
			buf.writeUint32(property._flags);
			switch (property.type) {
				case PropertyType.PT_I8:
				case PropertyType.PT_APPTIME:
				case PropertyType.PT_SYSTIME:
				case PropertyType.PT_DOUBLE:
					buf.append(property._data);
					break;
				case PropertyType.PT_ERROR:
				case PropertyType.PT_LONG:
				case PropertyType.PT_FLOAT:
					buf.append(property._data);
					buf.writeUint32(0);
					break;
				case PropertyType.PT_SHORT:
					buf.append(property._data);
					buf.writeUint32(0);
					buf.writeUint16(0);
					break;
				case PropertyType.PT_BOOLEAN:
					buf.append(property._data);
					buf.append(new Uint8Array(7));
					break;
				case PropertyType.PT_UNICODE:
					buf.writeInt32(property._data.length + 2);
					buf.writeUint32(0);
					storage.addStream(property.name(), property._data);
					size += property._data.length;
					break;
				case PropertyType.PT_STRING8:
					buf.writeInt32(property._data.length + 1);
					buf.writeUint32(0);
					storage.addStream(property.name(), property._data);
					size += property._data.length;
					break;
				case PropertyType.PT_CLSID:
					buf.append(property._data);
					break;
				case PropertyType.PT_BINARY:
					buf.writeInt32(property._data.length);
					buf.writeUint32(0);
					storage.addStream(property.name(), property._data);
					size += property._data.length;
					break;
				case PropertyType.PT_MV_SHORT: break;
				case PropertyType.PT_MV_LONG: break;
				case PropertyType.PT_MV_FLOAT: break;
				case PropertyType.PT_MV_DOUBLE: break;
				case PropertyType.PT_MV_CURRENCY: break;
				case PropertyType.PT_MV_APPTIME: break;
				case PropertyType.PT_MV_LONGLONG: break;
				case PropertyType.PT_MV_UNICODE: break;
				case PropertyType.PT_MV_STRING8: break;
				case PropertyType.PT_MV_SYSTIME: break;
				case PropertyType.PT_MV_BINARY: break;
				case PropertyType.PT_UNSPECIFIED: break;
				case PropertyType.PT_NULL: break;
				case PropertyType.PT_OBJECT: break;
			}
		}
		if (messageSize != null) {
			buf.writeUint16(PropertyTags.PR_MESSAGE_SIZE.type);
			buf.writeUint16(PropertyTags.PR_MESSAGE_SIZE.id);
			buf.writeUint32(
				6
				/* PROPATTR_WRITABLE */
);
			buf.writeUint64(messageSize + size + 8);
			buf.writeUint32(0);
		}
		size += buf.offset;
		storage.addStream("__properties_version1.0", byteBufferAsUint8Array(buf));
		return size;
	}
};
var TopLevelProperties = class extends Properties {
	/**
	*
	* @param storage
	* @param prefix
	* @param messageSize
	*/
	writeProperties(storage, prefix, messageSize) {
		const topLevelPropPrefix = (buf) => {
			prefix(buf);
			buf.writeUint64(0);
			buf.writeUint32(this.nextRecipientId);
			buf.writeUint32(this.nextAttachmentId);
			buf.writeUint32(this.recipientCount);
			buf.writeUint32(this.attachmentCount);
			buf.writeUint64(0);
		};
		return super.writeProperties(storage, topLevelPropPrefix, messageSize);
	}
};
var EntryStream = class extends Array {
	/**
	* creates this object and reads all the EntryStreamItems from
	* the given storage
	* @param storage {any}
	*/
	constructor(storage) {
		super();
		if (storage == null) return;
		const stream = storage.getStream(
			"__substg1.0_00030102"
			/* EntryStream */
);
		if (stream.byteLength <= 0) storage.addStream("__substg1.0_00030102", Uint8Array.of());
		const buf = makeByteBuffer(null, stream);
		while (buf.offset < buf.limit) {
			const entryStreamItem = EntryStreamItem.fromBuffer(buf);
			this.push(entryStreamItem);
		}
	}
	/**
	* writes all the EntryStreamItems as a stream to the storage
	* @param storage {any}
	* @param streamName {string?}
	*/
	write(storage, streamName = "__substg1.0_00030102") {
		const buf = makeByteBuffer();
		this.forEach((entry) => entry.write(buf));
		storage.addStream(streamName, byteBufferAsUint8Array(buf));
	}
};
var EntryStreamItem = class EntryStreamItem {
	/**
	* creates this object from the properties
	* @param nameIdentifierOrStringOffset {number}
	* @param indexAndKindInformation {IndexAndKindInformation}
	*/
	constructor(nameIdentifierOrStringOffset, indexAndKindInformation) {
		this.nameIdentifierOrStringOffset = nameIdentifierOrStringOffset;
		this.nameIdentifierOrStringOffsetHex = nameIdentifierOrStringOffset.toString(16).toUpperCase().padStart(4, "0");
		this.indexAndKindInformation = indexAndKindInformation;
	}
	/**
	* creates this objcet and reads all the properties from the given buffer
	* @param buf {ByteBuffer}
	*/
	static fromBuffer(buf) {
		const nameIdentifierOrStringOffset = buf.readUint16();
		const indexAndKindInformation = IndexAndKindInformation.fromBuffer(buf);
		return new EntryStreamItem(nameIdentifierOrStringOffset, indexAndKindInformation);
	}
	/**
	* write all the internal properties to the given buffer
	* @param buf {ByteBuffer}
	*/
	write(buf) {
		buf.writeUint32(this.nameIdentifierOrStringOffset);
		const packed = this.indexAndKindInformation.guidIndex << 1 | this.indexAndKindInformation.propertyKind;
		buf.writeUint16(packed);
		buf.writeUint16(this.indexAndKindInformation.propertyIndex);
	}
};
var IndexAndKindInformation = class IndexAndKindInformation {
	constructor(propertyIndex, guidIndex, propertyKind) {
		this.guidIndex = guidIndex;
		this.propertyIndex = propertyIndex;
		this.propertyKind = propertyKind;
	}
	static fromBuffer(buf) {
		const propertyIndex = buf.readUint16();
		const packedValue = buf.readUint16();
		const guidIndex = packedValue >>> 1 & 65535;
		const propertyKind = packedValue & 7;
		if (![
			255,
			1,
			0
		].includes(propertyKind)) throw new Error("invalid propertyKind:" + propertyKind);
		return new IndexAndKindInformation(propertyIndex, guidIndex, propertyKind);
	}
	write(buf) {
		buf.writeUint16(this.propertyIndex);
		buf.writeUint32(this.guidIndex + this.propertyKind);
	}
};
var GuidStream = class extends Array {
	/**
	* create this object
	* @param storage the storage that contains the PropertyTags.GuidStream
	*/
	constructor(storage) {
		super();
		if (storage == null) return;
		const stream = storage.getStream(
			"__substg1.0_00020102"
			/* GuidStream */
);
		const buf = makeByteBuffer(null, stream);
		while (buf.offset < buf.limit) {
			const guid = buf.slice(buf.offset, buf.offset + 16).toArrayBuffer(true);
			this.push(new Uint8Array(guid));
		}
	}
	/**
	* writes all the guids as a stream to the storage
	* @param storage
	*/
	write(storage) {
		const buf = makeByteBuffer();
		this.forEach((g) => {
			buf.append(g);
			storage.addStream("__substg1.0_00020102", buf);
		});
	}
};
var StringStream = class extends Array {
	/**
	* create StringStream and read all the StringStreamItems from the given storage, if any.
	*/
	constructor(storage) {
		super();
		if (storage == null) return;
		const stream = storage.getStream(
			"__substg1.0_00040102"
			/* StringStream */
);
		const buf = makeByteBuffer(null, stream);
		while (buf.offset < buf.limit) this.push(StringStreamItem.fromBuffer(buf));
	}
	/**
	* write all the StringStreamItems as a stream to the storage
	* @param storage
	*/
	write(storage) {
		const buf = makeByteBuffer();
		this.forEach((s) => s.write(buf));
		storage.addStream("__substg1.0_00040102", buf);
	}
};
var StringStreamItem = class StringStreamItem {
	constructor(name$1) {
		this.length = name$1.length;
		this.name = name$1;
	}
	/**
	* create a StringStreamItem from a byte buffer
	* @param buf {ByteBuffer}
	*/
	static fromBuffer(buf) {
		const length = buf.readUint32();
		const name$1 = buf.readUTF8String(length);
		const boundary = StringStreamItem.get4BytesBoundary(length);
		buf.offset = buf.offset + boundary;
		return new StringStreamItem(name$1);
	}
	/**
	* write this item to the ByteBuffer
	* @param buf {ByteBuffer}
	*/
	write(buf) {
		buf.writeUint32(this.length);
		buf.writeUTF8String(this.name);
		const boundary = StringStreamItem.get4BytesBoundary(this.length);
		for (let i = 0; i < boundary; i++) buf.writeUint8(0);
	}
	/**
	* Extract 4 from the given <paramref name="length"/> until the result is smaller
	* than 4 and then returns this result
	* @param length {number} was uint
	*/
	static get4BytesBoundary(length) {
		if (length === 0) return 4;
		while (length >= 4) length -= 4;
		return length;
	}
};
var NamedProperties = class NamedProperties extends Array {
	constructor(topLevelProperties) {
		super();
		this._topLevelProperties = topLevelProperties;
	}
	/**
	* adds a NamedPropertyTag. Only support for properties by ID for now.
	* @param mapiTag {NamedProperty}
	* @param obj {any}
	*/
	addProperty(mapiTag, obj) {
		throw new Error("Not implemented");
	}
	/**
	* Writes the properties to the storage. Unfortunately this is going to have to be used after we already written the top level properties.
	* @param storage {any}
	* @param messageSize {number}
	*/
	writeProperties(storage, messageSize = 0) {
		storage = storage.getStorage(
			"__nameid_version1.0"
			/* NameIdStorage */
);
		const entryStream = new EntryStream(storage);
		const stringStream = new StringStream(storage);
		const guidStream = new GuidStream(storage);
		const entryStream2 = new EntryStream(storage);
		const guids = this.map((np) => np.guid).filter(
			/* TODO: unique*/
			() => {
				throw new Error();
			}
);
		guids.forEach((g) => guidStream.push(g));
		this.forEach((np, propertyIndex) => {
			const guidIndex = guids.indexOf(np.guid) + 3;
			entryStream.push(new EntryStreamItem(np.nameIdentifier, new IndexAndKindInformation(
				propertyIndex,
				guidIndex,
				0
				/* Lid */
)));
			entryStream2.push(new EntryStreamItem(np.nameIdentifier, new IndexAndKindInformation(
				propertyIndex,
				guidIndex,
				0
				/* Lid */
)));
			entryStream2.write(storage, NamedProperties._generateStreamString(np.nameIdentifier, guidIndex, np.kind));
			entryStream2.splice(0, entryStream2.length);
		});
		guidStream.write(storage);
		entryStream.write(storage);
		stringStream.write(storage);
	}
	/**
	* generates the stream strings
	* @param nameIdentifier {number} was uint
	* @param guidTarget {number} was uint
	* @param propertyKind {PropertyKindEnum} 1 byte
	*/
	static _generateStreamString(nameIdentifier, guidTarget, propertyKind) {
		switch (propertyKind) {
			case 0:
				const number = 4096 + (nameIdentifier ^ guidTarget << 1) % 31 << 16 | 258;
				return "__substg1.0_" + number.toString(16).toUpperCase().padStart(8, "0");
			default: throw new Error("not implemented!");
		}
	}
};
const OUTLOOK_CLSID = "0b0d020000000000c000000000000046";
var Message = class {
	constructor() {
		this._saved = false;
		this._messageClass = "";
		this._storage = new CFBStorage(cfb.utils.cfb_new({ CLSID: OUTLOOK_CLSID }));
		const nameIdStorage = this._storage.addStorage(
			"__nameid_version1.0"
			/* NameIdStorage */
);
		nameIdStorage.addStream("__substg1.0_00030102", Uint8Array.of());
		nameIdStorage.addStream("__substg1.0_00040102", Uint8Array.of());
		nameIdStorage.addStream("__substg1.0_00020102", Uint8Array.of());
		this._topLevelProperties = new TopLevelProperties();
		this._namedProperties = new NamedProperties(this._topLevelProperties);
	}
	_save() {
		this._topLevelProperties.addProperty(PropertyTags.PR_MESSAGE_CLASS_W, this._messageClass);
		this._topLevelProperties.writeProperties(this._storage, () => {}, this._messageSize);
		this._namedProperties.writeProperties(this._storage, 0);
		this._saved = true;
		this._messageSize = 0;
	}
	/**
	* writes the Message to an underlying CFB
	* structure and returns a serialized
	* representation
	*
	*/
	saveToBuffer() {
		this._save();
		return this._storage.toBytes();
	}
	addProperty(propertyTag, value, flags = 4) {
		if (this._saved) throw new Error("Message is already saved!");
		this._topLevelProperties.addOrReplaceProperty(propertyTag, value, flags);
	}
};
var Address = class {
	constructor(email, displayName, addressType = "SMTP") {
		this.email = email;
		this.displayName = isNullOrWhiteSpace(displayName) ? email : displayName;
		this.addressType = addressType;
	}
};
function makeUUIDBuffer() {
	return dist.v4({}, new Uint8Array(16), 0);
}
let instanceKey = null;
function generateSearchKey(addressType, emailAddress) {
	return stringToUtf16LeArray(addressType + emailAddress);
}
function generateRecordKey() {
	return makeUUIDBuffer();
}
function generateInstanceKey() {
	if (instanceKey == null) instanceKey = makeUUIDBuffer().slice(0, 4);
	return instanceKey;
}
function generateEntryId() {
	const val = dist.v4();
	return stringToUtf16LeArray(val);
}
var RecipientProperties = class extends Properties {
	writeProperties(storage, prefix, messageSize) {
		const recipPropPrefix = (buf) => {
			prefix(buf);
			buf.writeUint64(0);
		};
		return super.writeProperties(storage, recipPropPrefix, messageSize);
	}
};
var Recipients = class extends Array {
	/**
	* add a new To-Recipient to the list
	* @param email email address of the recipient
	* @param displayName display name of the recipient (optional)
	* @param addressType address type of the recipient (default SMTP)
	* @param objectType mapiObjectType of the recipient (default MAPI_MAILUSER)
	* @param displayType recipientRowDisplayType of the recipient (default MessagingUser)
	*/
	addTo(email, displayName = "", addressType = "SMTP", objectType = 6, displayType = 0) {
		this.push(new Recipient(this.length, email, displayName, addressType, 1, objectType, displayType));
	}
	/**
	* add a new Cc-Recipient to the list
	* @param email email address of the recipient
	* @param displayName display name of the recipient (optional)
	* @param addressType address type of the recipient (default SMTP)
	* @param objectType mapiObjectType of the recipient (default MAPI_MAILUSER)
	* @param displayType recipientRowDisplayType of the recipient (default MessagingUser)
	*/
	addCc(email, displayName = "", addressType = "SMTP", objectType = 6, displayType = 0) {
		this.push(new Recipient(this.length, email, displayName, addressType, 2, objectType, displayType));
	}
	addBcc(email, displayName = "", addressType = "SMTP", objectType = 6, displayType = 0) {
		this.push(new Recipient(this.length, email, displayName, addressType, 3, objectType, displayType));
	}
	writeToStorage(rootStorage) {
		let size = 0;
		for (let i = 0; i < this.length; i++) {
			const recipient = this[i];
			const storage = rootStorage.addStorage("__recip_version1.0_#" + X8(i));
			size += recipient.writeProperties(storage);
		}
		return size;
	}
};
var Recipient = class extends Address {
	constructor(rowId, email, displayName, addressType, recipientType, objectType, displayType) {
		super(email, displayName, addressType);
		this._rowId = rowId;
		this.recipientType = recipientType;
		this._displayType = displayType;
		this._objectType = objectType;
	}
	writeProperties(storage) {
		const propertiesStream = new RecipientProperties();
		propertiesStream.addProperty(PropertyTags.PR_ROWID, this._rowId);
		propertiesStream.addProperty(PropertyTags.PR_ENTRYID, generateEntryId());
		propertiesStream.addProperty(PropertyTags.PR_INSTANCE_KEY, generateInstanceKey());
		propertiesStream.addProperty(PropertyTags.PR_RECIPIENT_TYPE, this.recipientType);
		propertiesStream.addProperty(PropertyTags.PR_ADDRTYPE_W, this.addressType);
		propertiesStream.addProperty(PropertyTags.PR_EMAIL_ADDRESS_W, this.email);
		propertiesStream.addProperty(PropertyTags.PR_OBJECT_TYPE, this._objectType);
		propertiesStream.addProperty(PropertyTags.PR_DISPLAY_TYPE, this._displayType);
		propertiesStream.addProperty(PropertyTags.PR_DISPLAY_NAME_W, this.displayName);
		propertiesStream.addProperty(PropertyTags.PR_SEARCH_KEY, generateSearchKey(this.addressType, this.email));
		return propertiesStream.writeProperties(storage, () => {});
	}
};
var OneOffEntryId = class extends Address {
	constructor(email, displayName, addressType = "SMTP", messageFormat = 2, canLookupEmailAddress = false) {
		super(email, displayName, addressType);
		this._messageFormat = messageFormat;
		this._canLookupEmailAddress = canLookupEmailAddress;
	}
	toByteArray() {
		const buf = makeByteBuffer();
		buf.writeUint32(0);
		buf.append(Uint8Array.from([
			129,
			43,
			31,
			164,
			190,
			163,
			16,
			25,
			157,
			110,
			0,
			221,
			1,
			15,
			84,
			2
		]));
		buf.writeUint16(0);
		let bits = 0;
		switch (this._messageFormat) {
			case 0:
				bits |= 32;
				bits |= 64;
				break;
			case 1:
				bits |= 16;
				bits |= 32;
				bits |= 64;
				break;
			case 2:
				bits |= 8;
				bits |= 32;
				bits |= 64;
				break;
		}
		bits |= 128;
		bits |= 256;
		if (this._canLookupEmailAddress) bits |= 2048;
		buf.writeUint8(bits >>> 8 & 255);
		buf.writeUint8(bits & 255);
		buf.append(stringToUtf16LeArray(this.displayName));
		buf.writeUint16(0);
		buf.append(stringToUtf16LeArray(this.addressType));
		buf.writeUint16(0);
		buf.append(stringToUtf16LeArray(this.email));
		buf.writeUint16(0);
		return byteBufferAsUint8Array(buf);
	}
};
var Sender = class extends Address {
	constructor(email, displayName, addressType = "SMTP", messageFormat = 2, canLookupEmailAddress = false, senderIsCreator = true) {
		super(email, displayName, addressType);
		this._messageFormat = messageFormat;
		this._canLookupEmailAddress = canLookupEmailAddress;
		this._senderIsCreator = senderIsCreator;
	}
	writeProperties(stream) {
		if (this._senderIsCreator) {
			stream.addProperty(PropertyTags.PR_CreatorEmailAddr_W, this.email);
			stream.addProperty(PropertyTags.PR_CreatorSimpleDispName_W, this.displayName);
			stream.addProperty(PropertyTags.PR_CreatorAddrType_W, this.addressType);
		}
		const senderEntryId = new OneOffEntryId(this.email, this.displayName, this.addressType, this._messageFormat, this._canLookupEmailAddress);
		stream.addProperty(PropertyTags.PR_SENDER_ENTRYID, senderEntryId.toByteArray());
		stream.addProperty(PropertyTags.PR_SENDER_EMAIL_ADDRESS_W, this.email);
		stream.addProperty(PropertyTags.PR_SENDER_NAME_W, this.displayName);
		stream.addProperty(PropertyTags.PR_SENT_REPRESENTING_NAME_W, this.displayName);
		stream.addProperty(PropertyTags.PR_SENDER_ADDRTYPE_W, this.addressType);
	}
};
var Attachments = class extends Array {
	/**
	* Writes the Attachment objects to the given storage and sets all the needed properties
	* @param rootStorage
	* @returns {number} the total size of the written attachment objects and their properties
	*/
	writeToStorage(rootStorage) {
		let size = 0;
		for (let i = 0; i < this.length; i++) {
			const attachment = this[i];
			const storage = rootStorage.addStorage("__attach_version1.0_#" + X8(i));
			size += attachment.writeProperties(storage, i);
		}
		return size;
	}
	attach(attachment) {
		if (this.length >= 2048) throw new Error("length > 2048 => too many attachments!");
		this.push(attachment);
	}
};
var Strings = class {
	/**
	* returns the str as an escaped RTF string
	* @param str {string} string to escape
	*/
	static escapeRtf(str) {
		const rtfEscaped = [];
		const escapedChars = [
			"{",
			"}",
			"\\"
		];
		for (const glyph of str) {
			const charCode = glyph.charCodeAt(0);
			if (charCode <= 31) continue;
			if (charCode <= 127) {
				if (escapedChars.includes(glyph)) rtfEscaped.push("\\");
				rtfEscaped.push(glyph);
			} else if (charCode <= 255) rtfEscaped.push("\\'" + x2(charCode));
else for (const codepoint of glyph.split("")) {
				rtfEscaped.push("\\u");
				rtfEscaped.push(codepoint.charCodeAt(0));
				rtfEscaped.push("?");
			}
		}
		return "{\\rtf1\\ansi\\ansicpg1252\\fromhtml1 {\\*\\htmltag1 " + rtfEscaped.join("") + " }}";
	}
};
var ReportTag = class {
	constructor(ansiText) {
		this.cookie = "PCDFEB09\0";
		this.version = 65537;
		this.storeEntryIdSize = 0;
		this.folderEntryIdSize = 0;
		this.folderEntryId = 0;
		this.messageEntryIdSize = 0;
		this.messageEntryId = 0;
		this.searchFolderEntryIdSize = 0;
		this.messageSearchKeySize = 0;
		this.ansiText = ansiText;
	}
	/**
	* Returns this object as a byte array
	*/
	toByteArray() {
		const buf = makeByteBuffer();
		buf.writeUTF8String(this.cookie);
		buf.writeUint32(this.version);
		buf.writeUint32(this.storeEntryIdSize);
		buf.writeUint32(this.folderEntryIdSize);
		buf.writeUint32(this.messageEntryIdSize);
		buf.writeUint32(this.searchFolderEntryIdSize);
		buf.writeUint32(this.messageSearchKeySize);
		buf.writeUint32(this.ansiText.length);
		buf.writeUTF8String(this.ansiText);
		return byteBufferAsUint8Array(buf);
	}
};
const CRC32_TABLE = [
	0,
	1996959894,
	3993919788,
	2567524794,
	124634137,
	1886057615,
	3915621685,
	2657392035,
	249268274,
	2044508324,
	3772115230,
	2547177864,
	162941995,
	2125561021,
	3887607047,
	2428444049,
	498536548,
	1789927666,
	4089016648,
	2227061214,
	450548861,
	1843258603,
	4107580753,
	2211677639,
	325883990,
	1684777152,
	4251122042,
	2321926636,
	335633487,
	1661365465,
	4195302755,
	2366115317,
	997073096,
	1281953886,
	3579855332,
	2724688242,
	1006888145,
	1258607687,
	3524101629,
	2768942443,
	901097722,
	1119000684,
	3686517206,
	2898065728,
	853044451,
	1172266101,
	3705015759,
	2882616665,
	651767980,
	1373503546,
	3369554304,
	3218104598,
	565507253,
	1454621731,
	3485111705,
	3099436303,
	671266974,
	1594198024,
	3322730930,
	2970347812,
	795835527,
	1483230225,
	3244367275,
	3060149565,
	1994146192,
	31158534,
	2563907772,
	4023717930,
	1907459465,
	112637215,
	2680153253,
	3904427059,
	2013776290,
	251722036,
	2517215374,
	3775830040,
	2137656763,
	141376813,
	2439277719,
	3865271297,
	1802195444,
	476864866,
	2238001368,
	4066508878,
	1812370925,
	453092731,
	2181625025,
	4111451223,
	1706088902,
	314042704,
	2344532202,
	4240017532,
	1658658271,
	366619977,
	2362670323,
	4224994405,
	1303535960,
	984961486,
	2747007092,
	3569037538,
	1256170817,
	1037604311,
	2765210733,
	3554079995,
	1131014506,
	879679996,
	2909243462,
	3663771856,
	1141124467,
	855842277,
	2852801631,
	3708648649,
	1342533948,
	654459306,
	3188396048,
	3373015174,
	1466479909,
	544179635,
	3110523913,
	3462522015,
	1591671054,
	702138776,
	2966460450,
	3352799412,
	1504918807,
	783551873,
	3082640443,
	3233442989,
	3988292384,
	2596254646,
	62317068,
	1957810842,
	3939845945,
	2647816111,
	81470997,
	1943803523,
	3814918930,
	2489596804,
	225274430,
	2053790376,
	3826175755,
	2466906013,
	167816743,
	2097651377,
	4027552580,
	2265490386,
	503444072,
	1762050814,
	4150417245,
	2154129355,
	426522225,
	1852507879,
	4275313526,
	2312317920,
	282753626,
	1742555852,
	4189708143,
	2394877945,
	397917763,
	1622183637,
	3604390888,
	2714866558,
	953729732,
	1340076626,
	3518719985,
	2797360999,
	1068828381,
	1219638859,
	3624741850,
	2936675148,
	906185462,
	1090812512,
	3747672003,
	2825379669,
	829329135,
	1181335161,
	3412177804,
	3160834842,
	628085408,
	1382605366,
	3423369109,
	3138078467,
	570562233,
	1426400815,
	3317316542,
	2998733608,
	733239954,
	1555261956,
	3268935591,
	3050360625,
	752459403,
	1541320221,
	2607071920,
	3965973030,
	1969922972,
	40735498,
	2617837225,
	3943577151,
	1913087877,
	83908371,
	2512341634,
	3803740692,
	2075208622,
	213261112,
	2463272603,
	3855990285,
	2094854071,
	198958881,
	2262029012,
	4057260610,
	1759359992,
	534414190,
	2176718541,
	4139329115,
	1873836001,
	414664567,
	2282248934,
	4279200368,
	1711684554,
	285281116,
	2405801727,
	4167216745,
	1634467795,
	376229701,
	2685067896,
	3608007406,
	1308918612,
	956543938,
	2808555105,
	3495958263,
	1231636301,
	1047427035,
	2932959818,
	3654703836,
	1088359270,
	936918e3,
	2847714899,
	3736837829,
	1202900863,
	817233897,
	3183342108,
	3401237130,
	1404277552,
	615818150,
	3134207493,
	3453421203,
	1423857449,
	601450431,
	3009837614,
	3294710456,
	1567103746,
	711928724,
	3020668471,
	3272380065,
	1510334235,
	755167117
];
var Crc32 = class {
	/**
	* calculates a checksum of a ByteBuffers contents
	* @param buffer {ByteBuffer}
	* @returns {number} the crc32 of this buffer's contents between offset and limit
	*/
	static calculate(buffer) {
		if (buffer.offset >= buffer.limit) return 0;
		const origOffset = buffer.offset;
		let result = 0;
		while (buffer.offset < buffer.limit) {
			const cur = buffer.readUint8();
			result = CRC32_TABLE[(result ^ cur) & 255] ^ result >>> 8;
		}
		buffer.offset = origOffset;
		return result >>> 0;
	}
};
const INIT_DICT_SIZE = 207;
const MAX_DICT_SIZE = 4096;
const COMP_TYPE = "LZFu";
const HEADER_SIZE = 16;
function getInitialDict() {
	const builder = [];
	builder.push("{\\rtf1\\ansi\\mac\\deff0\\deftab720{\\fonttbl;}");
	builder.push("{\\f0\\fnil \\froman \\fswiss \\fmodern \\fscript ");
	builder.push("\\fdecor MS Sans SerifSymbolArialTimes New RomanCourier{\\colortbl\\red0\\green0\\blue0");
	builder.push("\r\n");
	builder.push("\\par \\pard\\plain\\f0\\fs20\\b\\i\\u\\tab\\tx");
	const res = builder.join("");
	let initialDictionary = makeByteBuffer(null, stringToUtf8Array(res));
	initialDictionary.ensureCapacity(MAX_DICT_SIZE);
	initialDictionary.limit = MAX_DICT_SIZE;
	initialDictionary.offset = INIT_DICT_SIZE;
	return initialDictionary;
}
/**
* find the longest match of the start of the current input in the dictionary.
* finds the length of the longest match of the start of the current input in the dictionary and
* the position of it in the dictionary.
* @param dictionary {ByteBuffer} part of the MS-OXRTFCP spec.
* @param inputBuffer {ByteBuffer} pointing at the input data
* @returns {MatchInfo} object containing dictionaryOffset, length
*/
function findLongestMatch(dictionary, inputBuffer) {
	const positionData = {
		length: 0,
		dictionaryOffset: 0
	};
	if (inputBuffer.offset >= inputBuffer.limit) return positionData;
	inputBuffer.mark();
	dictionary.mark();
	let matchLength = 0;
	let dictionaryIndex = 0;
	while (true) {
		const inputCharacter = inputBuffer.readUint8();
		const dictCharacter = dictionary.readUint8(dictionaryIndex % MAX_DICT_SIZE);
		if (dictCharacter === inputCharacter) {
			matchLength += 1;
			if (matchLength <= 17 && matchLength > positionData.length) {
				positionData.dictionaryOffset = dictionaryIndex - matchLength + 1;
				dictionary.writeUint8(inputCharacter);
				dictionary.offset = dictionary.offset % MAX_DICT_SIZE;
				positionData.length = matchLength;
			}
			if (inputBuffer.offset >= inputBuffer.limit) break;
		} else {
			inputBuffer.reset();
			inputBuffer.mark();
			matchLength = 0;
			if (inputBuffer.offset >= inputBuffer.limit) break;
		}
		dictionaryIndex += 1;
		if (dictionaryIndex >= dictionary.markedOffset + positionData.length) break;
	}
	inputBuffer.reset();
	return positionData;
}
/**
* Takes in input, compresses it using LZFu by Microsoft. Can be viewed in the [MS-OXRTFCP].pdf document.
* https://msdn.microsoft.com/en-us/library/cc463890(v=exchg.80).aspx. Returns the input as a byte array.
* @param input {Uint8Array} the input to compress
* @returns {Uint8Array} compressed input
*/
function compress(input) {
	let matchData = {
		length: 0,
		dictionaryOffset: 0
	};
	const inputBuffer = makeByteBuffer(null, input);
	const dictionary = getInitialDict();
	const tokenBuffer = makeByteBuffer(16);
	const resultBuffer = makeByteBuffer(17);
	resultBuffer.offset = HEADER_SIZE;
	let controlByte = 0;
	let controlBit = 1;
	while (true) {
		matchData = findLongestMatch(dictionary, inputBuffer);
		if (inputBuffer.offset >= inputBuffer.limit) {
			let dictReference = (dictionary.offset & 4095) << 4;
			tokenBuffer.writeUint8(dictReference >>> 8 & 255);
			tokenBuffer.writeUint8(dictReference >>> 0 & 255);
			controlByte |= controlBit;
			resultBuffer.writeUint8(controlByte);
			tokenBuffer.limit = tokenBuffer.offset;
			tokenBuffer.offset = 0;
			resultBuffer.append(tokenBuffer);
			break;
		}
		if (matchData.length <= 1) {
			const inputCharacter = inputBuffer.readUint8();
			if (matchData.length === 0) {
				dictionary.writeUint8(inputCharacter);
				dictionary.offset = dictionary.offset % dictionary.limit;
			}
			tokenBuffer.writeUint8(inputCharacter);
		} else {
			let dictReference = (matchData.dictionaryOffset & 4095) << 4 | matchData.length - 2 & 15;
			controlByte |= controlBit;
			tokenBuffer.writeUint8(dictReference >>> 8 & 255);
			tokenBuffer.writeUint8(dictReference >>> 0 & 255);
			inputBuffer.offset = inputBuffer.offset + matchData.length;
		}
		matchData.length = 0;
		if (controlBit === 128) {
			resultBuffer.writeUint8(controlByte);
			tokenBuffer.limit = tokenBuffer.offset;
			tokenBuffer.offset = 0;
			resultBuffer.append(tokenBuffer);
			controlByte = 0;
			controlBit = 1;
			tokenBuffer.clear();
			continue;
		}
		controlBit <<= 1;
	}
	resultBuffer.limit = resultBuffer.offset;
	resultBuffer.writeUint32(resultBuffer.limit - HEADER_SIZE + 12, 0);
	resultBuffer.writeUint32(input.length, 4);
	resultBuffer.writeUTF8String(COMP_TYPE, 8);
	resultBuffer.offset = HEADER_SIZE;
	resultBuffer.writeUint32(Crc32.calculate(resultBuffer), 12);
	resultBuffer.offset = resultBuffer.limit;
	return byteBufferAsUint8Array(resultBuffer);
}
const subjectPrefixRegex = /^(\D{1,3}:\s)(.*)$/;
var Email = class extends Message {
	constructor(draft = false, readReceipt = false) {
		super();
		this._subject = "";
		this.recipients = new Recipients();
		this.replyToRecipients = new Recipients();
		this.attachments = new Attachments();
		this.priority = 0;
		this.importance = 1;
		this.iconIndex = 0;
		this.draft = draft;
		this.readReceipt = readReceipt;
		this._bodyHtml = "";
		this._bodyText = "";
		this._sentOn = null;
		this._receivedOn = null;
	}
	sender(address, displayName) {
		this._sender = new Sender(address, displayName || "");
		return this;
	}
	bodyHtml(html) {
		this._bodyHtml = html;
		return this;
	}
	bodyText(txt) {
		this._bodyText = txt;
		return this;
	}
	bodyFormat(fmt) {
		this.messageEditorFormat = fmt;
		return this;
	}
	subject(subject) {
		this._subject = subject;
		this._setSubject();
		return this;
	}
	to(address, displayName) {
		this.recipients.addTo(address, displayName);
		return this;
	}
	cc(address, displayName) {
		this.recipients.addCc(address, displayName);
		return this;
	}
	bcc(address, displayName) {
		this.recipients.addBcc(address, displayName);
		return this;
	}
	replyTo(address, displayName) {
		this.replyToRecipients.addTo(address, displayName);
		return this;
	}
	tos(recipients) {
		recipients.forEach((r) => this.to(r.address, r.name));
		return this;
	}
	ccs(recipients) {
		recipients.forEach((r) => this.cc(r.address, r.name));
		return this;
	}
	bccs(recipients) {
		recipients.forEach((r) => this.bcc(r.address, r.name));
		return this;
	}
	replyTos(recipients) {
		recipients.forEach((r) => this.replyTo(r.address, r.name));
		return this;
	}
	sentOn(when$1) {
		this._sentOn = when$1;
		return this;
	}
	receivedOn(when$1) {
		this._receivedOn = when$1;
		return this;
	}
	attach(attachment) {
		this.attachments.attach(attachment);
		return this;
	}
	/**
	* the raw transport headers
	* @param headers
	*/
	headers(headers) {
		this.transportMessageHeadersText = headers;
		return this;
	}
	msg() {
		this._writeToStorage();
		return super.saveToBuffer();
	}
	_setSubject() {
		if (!isNullOrEmpty(this.subjectPrefix)) if (this._subject.startsWith(this.subjectPrefix)) this._subjectNormalized = this._subject.slice(this.subjectPrefix.length);
else {
			const match = this._subject.match(subjectPrefixRegex);
			if (match != null) {
				this.subjectPrefix = match[1];
				this._subjectNormalized = match[2];
			}
		}
else if (!isNullOrEmpty(this._subject)) {
			this._subjectNormalized = this._subject;
			const match = this._subject.match(subjectPrefixRegex);
			if (match != null) {
				this.subjectPrefix = match[1];
				this._subjectNormalized = match[2];
			}
		} else this._subjectNormalized = this._subject;
		if (!this.subjectPrefix) this.subjectPrefix = "";
	}
	/**
	* write to the cfb of the underlying message
	*/
	_writeToStorage() {
		const rootStorage = this._storage;
		if (this._messageClass === "") this._messageClass = "IPM.Note";
		this._messageSize += this.recipients.writeToStorage(rootStorage);
		this._messageSize += this.attachments.writeToStorage(rootStorage);
		const recipientCount = this.recipients.length;
		const attachmentCount = this.attachments.length;
		this._topLevelProperties.recipientCount = recipientCount;
		this._topLevelProperties.attachmentCount = attachmentCount;
		this._topLevelProperties.nextRecipientId = recipientCount;
		this._topLevelProperties.nextAttachmentId = attachmentCount;
		this._topLevelProperties.addProperty(PropertyTags.PR_ENTRYID, generateEntryId());
		this._topLevelProperties.addProperty(PropertyTags.PR_INSTANCE_KEY, generateInstanceKey());
		this._topLevelProperties.addProperty(
			PropertyTags.PR_STORE_SUPPORT_MASK,
			StoreSupportMaskConst,
			2
			/* PROPATTR_READABLE */
);
		this._topLevelProperties.addProperty(
			PropertyTags.PR_STORE_UNICODE_MASK,
			StoreSupportMaskConst,
			2
			/* PROPATTR_READABLE */
);
		this._topLevelProperties.addProperty(
			PropertyTags.PR_ALTERNATE_RECIPIENT_ALLOWED,
			true,
			2
			/* PROPATTR_READABLE */
);
		this._topLevelProperties.addProperty(PropertyTags.PR_HASATTACH, attachmentCount > 0);
		if (this.transportMessageHeadersText) this._topLevelProperties.addProperty(PropertyTags.PR_TRANSPORT_MESSAGE_HEADERS_W, this.transportMessageHeadersText);
		const transportHeaders = this.transportMessageHeaders;
		if (transportHeaders) {
			if (!isNullOrWhiteSpace(transportHeaders.messageId)) this._topLevelProperties.addProperty(PropertyTags.PR_INTERNET_MESSAGE_ID_W, transportHeaders.messageId);
			const refCount = transportHeaders.references.length;
			if (refCount > 0) this._topLevelProperties.addProperty(PropertyTags.PR_INTERNET_REFERENCES_W, transportHeaders.references[refCount - 1]);
			const replCount = transportHeaders.inReplyTo.length;
			if (replCount > 0) this._topLevelProperties.addProperty(PropertyTags.PR_IN_REPLY_TO_ID_W, transportHeaders.inReplyTo[replCount - 1]);
		}
		if (!isNullOrWhiteSpace(this.internetMessageId)) this._topLevelProperties.addOrReplaceProperty(PropertyTags.PR_INTERNET_MESSAGE_ID_W, this.internetMessageId);
		if (!isNullOrWhiteSpace(this.internetReferences)) this._topLevelProperties.addOrReplaceProperty(PropertyTags.PR_INTERNET_REFERENCES_W, this.internetReferences);
		if (!isNullOrWhiteSpace(this.inReplyToId)) this._topLevelProperties.addOrReplaceProperty(PropertyTags.PR_IN_REPLY_TO_ID_W, this.inReplyToId);
		let messageFlags = 2;
		if (attachmentCount > 0) messageFlags |= 16;
		this._topLevelProperties.addProperty(PropertyTags.PR_INTERNET_CPID, 65001);
		this._topLevelProperties.addProperty(PropertyTags.PR_BODY_W, this._bodyText);
		if (!isNullOrEmpty(this._bodyHtml) && !this.draft) {
			this._topLevelProperties.addProperty(PropertyTags.PR_HTML, this._bodyHtml);
			this._topLevelProperties.addProperty(PropertyTags.PR_RTF_IN_SYNC, false);
		} else if (isNullOrWhiteSpace(this._bodyRtf) && !isNullOrWhiteSpace(this._bodyHtml)) {
			this._bodyRtf = Strings.escapeRtf(this._bodyHtml);
			this.bodyRtfCompressed = true;
		}
		if (!isNullOrWhiteSpace(this._bodyRtf)) {
			this._topLevelProperties.addProperty(PropertyTags.PR_RTF_COMPRESSED, compress(stringToUtf8Array(this._bodyRtf)));
			this._topLevelProperties.addProperty(PropertyTags.PR_RTF_IN_SYNC, this.bodyRtfCompressed);
		}
		if (this.messageEditorFormat !== MessageEditorFormat.EDITOR_FORMAT_DONTKNOW) this._topLevelProperties.addProperty(PropertyTags.PR_MSG_EDITOR_FORMAT, this.messageEditorFormat);
		if (this._sentOn == null) this._sentOn = new Date();
		if (this._receivedOn != null) this._topLevelProperties.addDateProperty(PropertyTags.PR_MESSAGE_DELIVERY_TIME, this._receivedOn);
		this._topLevelProperties.addDateProperty(PropertyTags.PR_CLIENT_SUBMIT_TIME, this._sentOn);
		this._topLevelProperties.addProperty(
			PropertyTags.PR_ACCESS,
			7
			/* MAPI_ACCESS_READ */
);
		this._topLevelProperties.addProperty(
			PropertyTags.PR_ACCESS_LEVEL,
			1
			/* MAPI_ACCESS_MODIFY */
);
		this._topLevelProperties.addProperty(
			PropertyTags.PR_OBJECT_TYPE,
			5
			/* MAPI_MESSAGE */
);
		this._setSubject();
		this._topLevelProperties.addProperty(PropertyTags.PR_SUBJECT_W, this._subject);
		this._topLevelProperties.addProperty(PropertyTags.PR_NORMALIZED_SUBJECT_W, this._subjectNormalized);
		this._topLevelProperties.addProperty(PropertyTags.PR_SUBJECT_PREFIX_W, this.subjectPrefix);
		this._topLevelProperties.addProperty(PropertyTags.PR_CONVERSATION_TOPIC_W, this._subjectNormalized);
		const utcNow = new Date();
		this._topLevelProperties.addDateProperty(PropertyTags.PR_CREATION_TIME, utcNow);
		this._topLevelProperties.addDateProperty(PropertyTags.PR_LAST_MODIFICATION_TIME, utcNow);
		this._topLevelProperties.addProperty(PropertyTags.PR_PRIORITY, this.priority);
		this._topLevelProperties.addProperty(PropertyTags.PR_IMPORTANCE, this.importance);
		this._topLevelProperties.addProperty(PropertyTags.PR_MESSAGE_LOCALE_ID, localeId());
		if (this.draft) {
			messageFlags |= 8;
			this.iconIndex = 259;
		}
		if (this.readReceipt) {
			this._topLevelProperties.addProperty(PropertyTags.PR_READ_RECEIPT_REQUESTED, true);
			const reportTag = new ReportTag(this._subject);
			this._topLevelProperties.addProperty(PropertyTags.PR_REPORT_TAG, reportTag.toByteArray());
		}
		this._topLevelProperties.addProperty(PropertyTags.PR_MESSAGE_FLAGS, messageFlags);
		this._topLevelProperties.addProperty(PropertyTags.PR_ICON_INDEX, this.iconIndex);
		if (!!this._sender) this._sender.writeProperties(this._topLevelProperties);
		if (!!this._receiving) this._receiving.writeProperties(this._topLevelProperties);
		if (!!this._receivingRepresenting) this._receivingRepresenting.writeProperties(this._topLevelProperties);
		if (!!this._representing) this._representing.writeProperties(this._topLevelProperties);
		if (recipientCount > 0) {
			const displayTo = [];
			const displayCc = [];
			const displayBcc = [];
			for (const recipient of this.recipients) switch (recipient.recipientType) {
				case 1:
					if (!isNullOrWhiteSpace(recipient.displayName)) displayTo.push(recipient.displayName);
else if (!isNullOrWhiteSpace(recipient.email)) displayTo.push(recipient.email);
					break;
				case 2:
					if (!isNullOrWhiteSpace(recipient.displayName)) displayCc.push(recipient.displayName);
else if (!isNullOrWhiteSpace(recipient.email)) displayCc.push(recipient.email);
					break;
				case 3:
					if (!isNullOrWhiteSpace(recipient.displayName)) displayBcc.push(recipient.displayName);
else if (!isNullOrWhiteSpace(recipient.email)) displayBcc.push(recipient.email);
					break;
				default: throw new Error("RecipientType out of Range: " + recipient.recipientType);
			}
			const replyToRecipients = [];
			for (const recipient of this.replyToRecipients) replyToRecipients.push(recipient.email);
			this._topLevelProperties.addProperty(
				PropertyTags.PR_DISPLAY_TO_W,
				displayTo.join(";"),
				2
				/* PROPATTR_READABLE */
);
			this._topLevelProperties.addProperty(
				PropertyTags.PR_DISPLAY_CC_W,
				displayCc.join(";"),
				2
				/* PROPATTR_READABLE */
);
			this._topLevelProperties.addProperty(
				PropertyTags.PR_DISPLAY_BCC_W,
				displayBcc.join(";"),
				2
				/* PROPATTR_READABLE */
);
			this._topLevelProperties.addProperty(
				PropertyTags.PR_REPLY_RECIPIENT_NAMES_W,
				replyToRecipients.join(";"),
				2
				/* PROPATTR_READABLE */
);
		}
	}
};
const MimeTypes = Object.freeze({
	"323": "text/h323",
	"3dmf": "x-world/x-3dmf",
	"3dm": "x-world/x-3dmf",
	"3g2": "video/3gpp2",
	"3gp": "video/3gpp",
	"7z": "application/x-7z-compressed",
	aab: "application/x-authorware-bin",
	aac: "audio/aac",
	aam: "application/x-authorware-map",
	aas: "application/x-authorware-seg",
	abc: "text/vnd.abc",
	acgi: "text/html",
	acx: "application/internet-property-stream",
	afl: "video/animaflex",
	ai: "application/postscript",
	aif: "audio/aiff",
	aifc: "audio/aiff",
	aiff: "audio/aiff",
	aim: "application/x-aim",
	aip: "text/x-audiosoft-intra",
	ani: "application/x-navi-animation",
	aos: "application/x-nokia-9000-communicator-add-on-software",
	appcache: "text/cache-manifest",
	application: "application/x-ms-application",
	aps: "application/mime",
	art: "image/x-jg",
	asf: "video/x-ms-asf",
	asm: "text/x-asm",
	asp: "text/asp",
	asr: "video/x-ms-asf",
	asx: "application/x-mplayer2",
	atom: "application/atom+xml",
	au: "audio/x-au",
	avi: "video/avi",
	avs: "video/avs-video",
	axs: "application/olescript",
	bas: "text/plain",
	bcpio: "application/x-bcpio",
	bin: "application/octet-stream",
	bm: "image/bmp",
	bmp: "image/bmp",
	boo: "application/book",
	book: "application/book",
	boz: "application/x-bzip2",
	bsh: "application/x-bsh",
	bz2: "application/x-bzip2",
	bz: "application/x-bzip",
	cat: "application/vnd.ms-pki.seccat",
	ccad: "application/clariscad",
	cco: "application/x-cocoa",
	cc: "text/plain",
	cdf: "application/cdf",
	cer: "application/pkix-cert",
	cha: "application/x-chat",
	chat: "application/x-chat",
	class: "application/x-java-applet",
	clp: "application/x-msclip",
	cmx: "image/x-cmx",
	cod: "image/cis-cod",
	coffee: "text/x-coffeescript",
	conf: "text/plain",
	cpio: "application/x-cpio",
	cpp: "text/plain",
	cpt: "application/x-cpt",
	crd: "application/x-mscardfile",
	crl: "application/pkix-crl",
	crt: "application/pkix-cert",
	csh: "application/x-csh",
	css: "text/css",
	c: "text/plain",
	"c++": "text/plain",
	cxx: "text/plain",
	dart: "application/dart",
	dcr: "application/x-director",
	deb: "application/x-deb",
	deepv: "application/x-deepv",
	def: "text/plain",
	deploy: "application/octet-stream",
	der: "application/x-x509-ca-cert",
	dib: "image/bmp",
	dif: "video/x-dv",
	dir: "application/x-director",
	disco: "text/xml",
	dll: "application/x-msdownload",
	dl: "video/dl",
	doc: "application/msword",
	docm: "application/vnd.ms-word.document.macroEnabled.12",
	docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
	dot: "application/msword",
	dotm: "application/vnd.ms-word.template.macroEnabled.12",
	dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
	dp: "application/commonground",
	drw: "application/drafting",
	dtd: "application/xml-dtd",
	dvi: "application/x-dvi",
	dv: "video/x-dv",
	dwf: "drawing/x-dwf (old)",
	dwg: "application/acad",
	dxf: "application/dxf",
	dxr: "application/x-director",
	elc: "application/x-elc",
	el: "text/x-script.elisp",
	eml: "message/rfc822",
	eot: "application/vnd.bw-fontobject",
	eps: "application/postscript",
	es: "application/x-esrehber",
	etx: "text/x-setext",
	evy: "application/envoy",
	exe: "application/octet-stream",
	f77: "text/plain",
	f90: "text/plain",
	fdf: "application/vnd.fdf",
	fif: "image/fif",
	flac: "audio/x-flac",
	fli: "video/fli",
	flo: "image/florian",
	flr: "x-world/x-vrml",
	flx: "text/vnd.fmi.flexstor",
	fmf: "video/x-atomic3d-feature",
	for: "text/plain",
	fpx: "image/vnd.fpx",
	frl: "application/freeloader",
	f: "text/plain",
	funk: "audio/make",
	g3: "image/g3fax",
	gif: "image/gif",
	gl: "video/gl",
	gsd: "audio/x-gsm",
	gsm: "audio/x-gsm",
	gsp: "application/x-gsp",
	gss: "application/x-gss",
	gtar: "application/x-gtar",
	g: "text/plain",
	gz: "application/x-gzip",
	gzip: "application/x-gzip",
	hdf: "application/x-hdf",
	help: "application/x-helpfile",
	hgl: "application/vnd.hp-HPGL",
	hh: "text/plain",
	hlb: "text/x-script",
	hlp: "application/x-helpfile",
	hpg: "application/vnd.hp-HPGL",
	hpgl: "application/vnd.hp-HPGL",
	hqx: "application/binhex",
	hta: "application/hta",
	htc: "text/x-component",
	h: "text/plain",
	htmls: "text/html",
	html: "text/html",
	htm: "text/html",
	htt: "text/webviewhtml",
	htx: "text/html",
	ice: "x-conference/x-cooltalk",
	ico: "image/x-icon",
	ics: "text/calendar",
	idc: "text/plain",
	ief: "image/ief",
	iefs: "image/ief",
	iges: "application/iges",
	igs: "application/iges",
	iii: "application/x-iphone",
	ima: "application/x-ima",
	imap: "application/x-httpd-imap",
	inf: "application/inf",
	ins: "application/x-internett-signup",
	ip: "application/x-ip2",
	isp: "application/x-internet-signup",
	isu: "video/x-isvideo",
	it: "audio/it",
	iv: "application/x-inventor",
	ivf: "video/x-ivf",
	ivr: "i-world/i-vrml",
	ivy: "application/x-livescreen",
	jam: "audio/x-jam",
	jar: "application/java-archive",
	java: "text/plain",
	jav: "text/plain",
	jcm: "application/x-java-commerce",
	jfif: "image/jpeg",
	"jfif-tbnl": "image/jpeg",
	jpeg: "image/jpeg",
	jpe: "image/jpeg",
	jpg: "image/jpeg",
	jps: "image/x-jps",
	js: "application/javascript",
	json: "application/json",
	jut: "image/jutvision",
	kar: "audio/midi",
	ksh: "text/x-script.ksh",
	la: "audio/nspaudio",
	lam: "audio/x-liveaudio",
	latex: "application/x-latex",
	list: "text/plain",
	lma: "audio/nspaudio",
	log: "text/plain",
	lsp: "application/x-lisp",
	lst: "text/plain",
	lsx: "text/x-la-asf",
	ltx: "application/x-latex",
	m13: "application/x-msmediaview",
	m14: "application/x-msmediaview",
	m1v: "video/mpeg",
	m2a: "audio/mpeg",
	m2v: "video/mpeg",
	m3u: "audio/x-mpequrl",
	m4a: "audio/mp4",
	m4v: "video/mp4",
	man: "application/x-troff-man",
	manifest: "application/x-ms-manifest",
	map: "application/x-navimap",
	mar: "text/plain",
	mbd: "application/mbedlet",
	mc$: "application/x-magic-cap-package-1.0",
	mcd: "application/mcad",
	mcf: "image/vasa",
	mcp: "application/netmc",
	mdb: "application/x-msaccess",
	mesh: "model/mesh",
	me: "application/x-troff-me",
	mid: "audio/midi",
	midi: "audio/midi",
	mif: "application/x-mif",
	mjf: "audio/x-vnd.AudioExplosion.MjuiceMediaFile",
	mjpg: "video/x-motion-jpeg",
	mm: "application/base64",
	mme: "application/base64",
	mny: "application/x-msmoney",
	mod: "audio/mod",
	mov: "video/quicktime",
	movie: "video/x-sgi-movie",
	mp2: "video/mpeg",
	mp3: "audio/mpeg",
	mp4: "video/mp4",
	mp4a: "audio/mp4",
	mp4v: "video/mp4",
	mpa: "audio/mpeg",
	mpc: "application/x-project",
	mpeg: "video/mpeg",
	mpe: "video/mpeg",
	mpga: "audio/mpeg",
	mpg: "video/mpeg",
	mpp: "application/vnd.ms-project",
	mpt: "application/x-project",
	mpv2: "video/mpeg",
	mpv: "application/x-project",
	mpx: "application/x-project",
	mrc: "application/marc",
	ms: "application/x-troff-ms",
	msh: "model/mesh",
	m: "text/plain",
	mvb: "application/x-msmediaview",
	mv: "video/x-sgi-movie",
	my: "audio/make",
	mzz: "application/x-vnd.AudioExplosion.mzz",
	nap: "image/naplps",
	naplps: "image/naplps",
	nc: "application/x-netcdf",
	ncm: "application/vnd.nokia.configuration-message",
	niff: "image/x-niff",
	nif: "image/x-niff",
	nix: "application/x-mix-transfer",
	nsc: "application/x-conference",
	nvd: "application/x-navidoc",
	nws: "message/rfc822",
	oda: "application/oda",
	ods: "application/oleobject",
	oga: "audio/ogg",
	ogg: "audio/ogg",
	ogv: "video/ogg",
	ogx: "application/ogg",
	omc: "application/x-omc",
	omcd: "application/x-omcdatamaker",
	omcr: "application/x-omcregerator",
	opus: "audio/ogg",
	oxps: "application/oxps",
	p10: "application/pkcs10",
	p12: "application/pkcs-12",
	p7a: "application/x-pkcs7-signature",
	p7b: "application/x-pkcs7-certificates",
	p7c: "application/pkcs7-mime",
	p7m: "application/pkcs7-mime",
	p7r: "application/x-pkcs7-certreqresp",
	p7s: "application/pkcs7-signature",
	part: "application/pro_eng",
	pas: "text/pascal",
	pbm: "image/x-portable-bitmap",
	pcl: "application/x-pcl",
	pct: "image/x-pict",
	pcx: "image/x-pcx",
	pdb: "chemical/x-pdb",
	pdf: "application/pdf",
	pfunk: "audio/make",
	pfx: "application/x-pkcs12",
	pgm: "image/x-portable-graymap",
	pic: "image/pict",
	pict: "image/pict",
	pkg: "application/x-newton-compatible-pkg",
	pko: "application/vnd.ms-pki.pko",
	pl: "text/plain",
	plx: "application/x-PiXCLscript",
	pm4: "application/x-pagemaker",
	pm5: "application/x-pagemaker",
	pma: "application/x-perfmon",
	pmc: "application/x-perfmon",
	pm: "image/x-xpixmap",
	pml: "application/x-perfmon",
	pmr: "application/x-perfmon",
	pmw: "application/x-perfmon",
	png: "image/png",
	pnm: "application/x-portable-anymap",
	pot: "application/vnd.ms-powerpoint",
	potm: "application/vnd.ms-powerpoint.template.macroEnabled.12",
	potx: "application/vnd.openxmlformats-officedocument.presentationml.template",
	pov: "model/x-pov",
	ppa: "application/vnd.ms-powerpoint",
	ppam: "application/vnd.ms-powerpoint.addin.macroEnabled.12",
	ppm: "image/x-portable-pixmap",
	pps: "application/vnd.ms-powerpoint",
	ppsm: "application/vnd.ms-powerpoint.slideshow.macroEnabled.12",
	ppsx: "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
	ppt: "application/vnd.ms-powerpoint",
	pptm: "application/vnd.ms-powerpoint.presentation.macroEnabled.12",
	pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
	ppz: "application/mspowerpoint",
	pre: "application/x-freelance",
	prf: "application/pics-rules",
	prt: "application/pro_eng",
	ps: "application/postscript",
	p: "text/x-pascal",
	pub: "application/x-mspublisher",
	pvu: "paleovu/x-pv",
	pwz: "application/vnd.ms-powerpoint",
	pyc: "applicaiton/x-bytecode.python",
	py: "text/x-script.phyton",
	qcp: "audio/vnd.qcelp",
	qd3d: "x-world/x-3dmf",
	qd3: "x-world/x-3dmf",
	qif: "image/x-quicktime",
	qtc: "video/x-qtc",
	qtif: "image/x-quicktime",
	qti: "image/x-quicktime",
	qt: "video/quicktime",
	ra: "audio/x-pn-realaudio",
	ram: "audio/x-pn-realaudio",
	ras: "application/x-cmu-raster",
	rast: "image/cmu-raster",
	rexx: "text/x-script.rexx",
	rf: "image/vnd.rn-realflash",
	rgb: "image/x-rgb",
	rm: "application/vnd.rn-realmedia",
	rmi: "audio/mid",
	rmm: "audio/x-pn-realaudio",
	rmp: "audio/x-pn-realaudio",
	rng: "application/ringing-tones",
	rnx: "application/vnd.rn-realplayer",
	roff: "application/x-troff",
	rp: "image/vnd.rn-realpix",
	rpm: "audio/x-pn-realaudio-plugin",
	rss: "application/rss+xml",
	rtf: "text/richtext",
	rt: "text/richtext",
	rtx: "text/richtext",
	rv: "video/vnd.rn-realvideo",
	s3m: "audio/s3m",
	sbk: "application/x-tbook",
	scd: "application/x-msschedule",
	scm: "application/x-lotusscreencam",
	sct: "text/scriptlet",
	sdml: "text/plain",
	sdp: "application/sdp",
	sdr: "application/sounder",
	sea: "application/sea",
	set: "application/set",
	setpay: "application/set-payment-initiation",
	setreg: "application/set-registration-initiation",
	sgml: "text/sgml",
	sgm: "text/sgml",
	shar: "application/x-bsh",
	sh: "text/x-script.sh",
	shtml: "text/html",
	sid: "audio/x-psid",
	silo: "model/mesh",
	sit: "application/x-sit",
	skd: "application/x-koan",
	skm: "application/x-koan",
	skp: "application/x-koan",
	skt: "application/x-koan",
	sl: "application/x-seelogo",
	smi: "application/smil",
	smil: "application/smil",
	snd: "audio/basic",
	sol: "application/solids",
	spc: "application/x-pkcs7-certificates",
	spl: "application/futuresplash",
	spr: "application/x-sprite",
	sprite: "application/x-sprite",
	spx: "audio/ogg",
	src: "application/x-wais-source",
	ssi: "text/x-server-parsed-html",
	ssm: "application/streamingmedia",
	sst: "application/vnd.ms-pki.certstore",
	step: "application/step",
	s: "text/x-asm",
	stl: "application/sla",
	stm: "text/html",
	stp: "application/step",
	sv4cpio: "application/x-sv4cpio",
	sv4crc: "application/x-sv4crc",
	svf: "image/x-dwg",
	svg: "image/svg+xml",
	svr: "application/x-world",
	swf: "application/x-shockwave-flash",
	talk: "text/x-speech",
	t: "application/x-troff",
	tar: "application/x-tar",
	tbk: "application/toolbook",
	tcl: "text/x-script.tcl",
	tcsh: "text/x-script.tcsh",
	tex: "application/x-tex",
	texi: "application/x-texinfo",
	texinfo: "application/x-texinfo",
	text: "text/plain",
	tgz: "application/x-compressed",
	tiff: "image/tiff",
	tif: "image/tiff",
	tr: "application/x-troff",
	trm: "application/x-msterminal",
	ts: "text/x-typescript",
	tsi: "audio/tsp-audio",
	tsp: "audio/tsplayer",
	tsv: "text/tab-separated-values",
	ttf: "application/x-font-ttf",
	turbot: "image/florian",
	txt: "text/plain",
	uil: "text/x-uil",
	uls: "text/iuls",
	unis: "text/uri-list",
	uni: "text/uri-list",
	unv: "application/i-deas",
	uris: "text/uri-list",
	uri: "text/uri-list",
	ustar: "multipart/x-ustar",
	uue: "text/x-uuencode",
	uu: "text/x-uuencode",
	vcd: "application/x-cdlink",
	vcf: "text/vcard",
	vcard: "text/vcard",
	vcs: "text/x-vCalendar",
	vda: "application/vda",
	vdo: "video/vdo",
	vew: "application/groupwise",
	vivo: "video/vivo",
	viv: "video/vivo",
	vmd: "application/vocaltec-media-desc",
	vmf: "application/vocaltec-media-file",
	voc: "audio/voc",
	vos: "video/vosaic",
	vox: "audio/voxware",
	vqe: "audio/x-twinvq-plugin",
	vqf: "audio/x-twinvq",
	vql: "audio/x-twinvq-plugin",
	vrml: "application/x-vrml",
	vrt: "x-world/x-vrt",
	vsd: "application/x-visio",
	vst: "application/x-visio",
	vsw: "application/x-visio",
	w60: "application/wordperfect6.0",
	w61: "application/wordperfect6.1",
	w6w: "application/msword",
	wav: "audio/wav",
	wb1: "application/x-qpro",
	wbmp: "image/vnd.wap.wbmp",
	wcm: "application/vnd.ms-works",
	wdb: "application/vnd.ms-works",
	web: "application/vnd.xara",
	webm: "video/webm",
	wiz: "application/msword",
	wk1: "application/x-123",
	wks: "application/vnd.ms-works",
	wmf: "windows/metafile",
	wmlc: "application/vnd.wap.wmlc",
	wmlsc: "application/vnd.wap.wmlscriptc",
	wmls: "text/vnd.wap.wmlscript",
	wml: "text/vnd.wap.wml",
	wmp: "video/x-ms-wmp",
	wmv: "video/x-ms-wmv",
	wmx: "video/x-ms-wmx",
	woff: "application/x-woff",
	word: "application/msword",
	wp5: "application/wordperfect",
	wp6: "application/wordperfect",
	wp: "application/wordperfect",
	wpd: "application/wordperfect",
	wps: "application/vnd.ms-works",
	wq1: "application/x-lotus",
	wri: "application/mswrite",
	wrl: "application/x-world",
	wrz: "model/vrml",
	wsc: "text/scriplet",
	wsdl: "text/xml",
	wsrc: "application/x-wais-source",
	wtk: "application/x-wintalk",
	wvx: "video/x-ms-wvx",
	x3d: "model/x3d+xml",
	x3db: "model/x3d+fastinfoset",
	x3dv: "model/x3d-vrml",
	xaf: "x-world/x-vrml",
	xaml: "application/xaml+xml",
	xap: "application/x-silverlight-app",
	xbap: "application/x-ms-xbap",
	xbm: "image/x-xbitmap",
	xdr: "video/x-amt-demorun",
	xgz: "xgl/drawing",
	xht: "application/xhtml+xml",
	xhtml: "application/xhtml+xml",
	xif: "image/vnd.xiff",
	xla: "application/vnd.ms-excel",
	xlam: "application/vnd.ms-excel.addin.macroEnabled.12",
	xl: "application/excel",
	xlb: "application/excel",
	xlc: "application/excel",
	xld: "application/excel",
	xlk: "application/excel",
	xll: "application/excel",
	xlm: "application/excel",
	xls: "application/vnd.ms-excel",
	xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.12",
	xlsm: "application/vnd.ms-excel.sheet.macroEnabled.12",
	xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
	xlt: "application/vnd.ms-excel",
	xltm: "application/vnd.ms-excel.template.macroEnabled.12",
	xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
	xlv: "application/excel",
	xlw: "application/excel",
	xm: "audio/xm",
	xml: "text/xml",
	xmz: "xgl/movie",
	xof: "x-world/x-vrml",
	xpi: "application/x-xpinstall",
	xpix: "application/x-vnd.ls-xpix",
	xpm: "image/xpm",
	xps: "application/vnd.ms-xpsdocument",
	"x-png": "image/png",
	xsd: "text/xml",
	xsl: "text/xml",
	xslt: "text/xml",
	xsr: "video/x-amt-showrun",
	xwd: "image/x-xwd",
	xyz: "chemical/x-pdb",
	z: "application/x-compressed",
	zip: "application/zip",
	zsh: "text/x-script.zsh"
});
function getMimeType(fileName) {
	if (fileName == null) throw new Error("fileName is null!");
	const aos = MimeTypes["exe"];
	const dot = fileName.lastIndexOf(".");
	if (dot !== -1 && fileName.length > dot + 1) {
		const ext = fileName.substring(dot + 1);
		return MimeTypes[ext] || aos;
	}
	return aos;
}
var Attachment = class {
	constructor(data, fileName, contentId = "", type = AttachmentType.ATTACH_BY_VALUE, renderingPosition = -1, isContactPhoto = false) {
		this.data = data;
		this.fileName = fileName;
		this.type = type;
		this.renderingPosition = renderingPosition;
		this.contentId = contentId;
		this.isContactPhoto = isContactPhoto;
	}
	writeProperties(storage, index) {
		const attachmentProperties = new Properties();
		attachmentProperties.addProperty(
			PropertyTags.PR_ATTACH_NUM,
			index,
			2
			/* PROPATTR_READABLE */
);
		attachmentProperties.addBinaryProperty(
			PropertyTags.PR_INSTANCE_KEY,
			generateInstanceKey(),
			2
			/* PROPATTR_READABLE */
);
		attachmentProperties.addBinaryProperty(
			PropertyTags.PR_RECORD_KEY,
			generateRecordKey(),
			2
			/* PROPATTR_READABLE */
);
		attachmentProperties.addProperty(
			PropertyTags.PR_RENDERING_POSITION,
			this.renderingPosition,
			2
			/* PROPATTR_READABLE */
);
		attachmentProperties.addProperty(
			PropertyTags.PR_OBJECT_TYPE,
			7
			/* MAPI_ATTACH */
);
		if (!isNullOrEmpty(this.fileName)) {
			attachmentProperties.addProperty(PropertyTags.PR_DISPLAY_NAME_W, this.fileName);
			attachmentProperties.addProperty(PropertyTags.PR_ATTACH_FILENAME_W, fileNameToDosFileName(this.fileName));
			attachmentProperties.addProperty(PropertyTags.PR_ATTACH_LONG_FILENAME_W, this.fileName);
			attachmentProperties.addProperty(PropertyTags.PR_ATTACH_EXTENSION_W, getPathExtension(this.fileName));
			if (!isNullOrEmpty(this.contentId)) attachmentProperties.addProperty(PropertyTags.PR_ATTACH_CONTENT_ID_W, this.contentId);
			attachmentProperties.addProperty(PropertyTags.PR_ATTACH_MIME_TAG_W, getMimeType(this.fileName));
		}
		attachmentProperties.addProperty(PropertyTags.PR_ATTACH_METHOD, this.type);
		switch (this.type) {
			case AttachmentType.ATTACH_BY_VALUE:
			case AttachmentType.ATTACH_EMBEDDED_MSG:
				attachmentProperties.addBinaryProperty(PropertyTags.PR_ATTACH_DATA_BIN, this.data);
				attachmentProperties.addProperty(PropertyTags.PR_ATTACH_SIZE, this.data.length);
				break;
			case AttachmentType.ATTACH_BY_REF_ONLY:
			case AttachmentType.ATTACH_BY_REFERENCE:
			case AttachmentType.ATTACH_BY_REF_RESOLVE:
			case AttachmentType.NO_ATTACHMENT:
			case AttachmentType.ATTACH_OLE: throw new Error(`Attachment type "${AttachmentType[this.type]} is not supported`);
		}
		if (this.contentId) {
			attachmentProperties.addProperty(PropertyTags.PR_ATTACHMENT_HIDDEN, true);
			attachmentProperties.addProperty(
				PropertyTags.PR_ATTACH_FLAGS,
				4
				/* ATT_MHTML_REF */
);
		}
		attachmentProperties.addDateProperty(PropertyTags.PR_CREATION_TIME, new Date());
		attachmentProperties.addDateProperty(PropertyTags.PR_LAST_MODIFICATION_TIME, new Date());
		attachmentProperties.addProperty(
			PropertyTags.PR_STORE_SUPPORT_MASK,
			StoreSupportMaskConst,
			2
			/* PROPATTR_READABLE */
);
		return attachmentProperties.writeProperties(storage, (buf) => {
			buf.writeUint64(0);
		});
	}
};

//#endregion
//#region ../src/common/desktop/export/DesktopExportLock.ts
let LockResult = function(LockResult$1) {
	LockResult$1[LockResult$1["LockAcquired"] = 0] = "LockAcquired";
	LockResult$1[LockResult$1["AlreadyLocked"] = 1] = "AlreadyLocked";
	return LockResult$1;
}({});

//#endregion
//#region ../src/common/desktop/export/DesktopExportFacade.ts
const EXPORT_DIR = "export";
var DesktopExportFacade = class {
	constructor(tfs, electron, conf, window$1, dragIcons, mailboxExportPersistence, fs$1, dateProvider, desktopExportLock) {
		this.tfs = tfs;
		this.electron = electron;
		this.conf = conf;
		this.window = window$1;
		this.dragIcons = dragIcons;
		this.mailboxExportPersistence = mailboxExportPersistence;
		this.fs = fs$1;
		this.dateProvider = dateProvider;
		this.desktopExportLock = desktopExportLock;
	}
	async checkFileExistsInExportDir(fileName) {
		return fileExists(path.join(await this.getExportDirectoryPath(), fileName));
	}
	async mailToMsg(bundle, fileName) {
		const subject = `[Tuta Mail] ${bundle.subject}`;
		const email = new Email(bundle.isDraft, bundle.isRead).subject(subject).bodyHtml(bundle.body).bodyFormat(MessageEditorFormat.EDITOR_FORMAT_HTML).sender(bundle.sender.address, bundle.sender.name).tos(bundle.to).ccs(bundle.cc).bccs(bundle.bcc).replyTos(bundle.replyTo).sentOn(new Date(bundle.sentOn)).receivedOn(new Date(bundle.receivedOn)).headers(bundle.headers || "");
		for (let attachment of bundle.attachments) email.attach(new Attachment(new Uint8Array(attachment.data), attachment.name, attachment.cid || ""));
		return createDataFile(fileName, "application/vnd.ms-outlook", email.msg());
	}
	async saveToExportDir(file) {
		const exportDir = await this.getExportDirectoryPath();
		const fullPath = path.join(exportDir, sanitizeFilename(file.name));
		return promises.writeFile(fullPath, file.data);
	}
	async startNativeDrag(fileNames) {
		const exportDir = await this.getExportDirectoryPath();
		const files = fileNames.map((fileName) => path.join(exportDir, fileName)).filter(fileExists);
		const exportMode = await this.conf.getVar(DesktopConfigKey.mailExportMode);
		const icon = this.dragIcons[exportMode];
		this.window._browserWindow.webContents.startDrag({
			file: "",
			files,
			icon
		});
	}
	async startMailboxExport(userId, mailboxId, mailBagId, mailId) {
		if (this.desktopExportLock.acquireLock(userId) === LockResult.AlreadyLocked) throw new ExportError(`Export is locked for user: ${userId}`, ExportErrorReason.LockedForUser);
		const previousExportState = await this.mailboxExportPersistence.getStateForUser(userId);
		if (previousExportState != null && previousExportState.type !== "finished") throw new ExportError(`Export is already running for user: ${userId}`, ExportErrorReason.RunningForUser);
		const directory = await this.electron.dialog.showOpenDialog(this.window._browserWindow, { properties: ["openDirectory"] }).then(({ filePaths }) => filePaths[0] ?? null);
		if (directory == null) {
			this.desktopExportLock.unlock(userId);
			throw new CancelledError("Directory picking canceled");
		}
		const folderName = `TutaExport-${formatSortableDate(new Date(this.dateProvider.now()))}`;
		const fullPath = await this.pickUniqueFileName(path.join(directory, folderName));
		await this.fs.promises.mkdir(fullPath);
		await this.mailboxExportPersistence.setStateForUser({
			type: "running",
			userId,
			mailboxId,
			exportDirectoryPath: fullPath,
			mailBagId,
			mailId,
			exportedMails: 0
		});
	}
	async pickUniqueFileName(path$1) {
		let counter = 0;
		let currentCandidate = path$1;
		while (await this.fileExists(currentCandidate)) {
			counter += 1;
			currentCandidate = path$1 + `-${counter}`;
		}
		return currentCandidate;
	}
	async fileExists(path$1) {
		try {
			await this.fs.promises.stat(path$1);
		} catch (e) {
			if (e.code === "ENOENT") return false;
else throw e;
		}
		return true;
	}
	async getMailboxExportState(userId) {
		const state = await this.mailboxExportPersistence.getStateForUser(userId);
		if (state && state.type === "running") {
			if (this.desktopExportLock.acquireLock(userId) === LockResult.AlreadyLocked) return {
				type: "locked",
				userId
			};
		}
		return state;
	}
	async endMailboxExport(userId) {
		const previousExportState = await this.mailboxExportPersistence.getStateForUser(userId);
		if (previousExportState && previousExportState.type === "running") await this.mailboxExportPersistence.setStateForUser({
			type: "finished",
			userId,
			exportDirectoryPath: previousExportState.exportDirectoryPath,
			mailboxId: previousExportState.mailboxId
		});
else throw new ProgrammingError("An Export was not previously running");
	}
	async saveMailboxExport(bundle, userId, mailBagId, mailId) {
		const exportState = await this.mailboxExportPersistence.getStateForUser(userId);
		if (exportState == null || exportState.type !== "running") throw new ProgrammingError("Export is not running");
		const filename = generateExportFileName(elementIdPart(bundle.mailId), bundle.subject, new Date(bundle.sentOn), "eml");
		const fullPath = path.join(exportState.exportDirectoryPath, filename);
		const file = mailToEmlFile(bundle, filename);
		try {
			await this.fs.promises.writeFile(fullPath, file.data);
		} catch (e) {
			if (e.code === "ENOENT" || e.code === "EPERM") throw new FileOpenError(`Could not write ${fullPath}`);
else throw e;
		}
		await this.mailboxExportPersistence.setStateForUser({
			type: "running",
			userId,
			mailBagId,
			mailId,
			exportDirectoryPath: exportState.exportDirectoryPath,
			mailboxId: exportState.mailboxId,
			exportedMails: exportState.exportedMails + 1
		});
	}
	async clearExportState(userId) {
		await this.mailboxExportPersistence.clearStateForUser(userId);
		this.desktopExportLock.unlock(userId);
	}
	async openExportDirectory(userId) {
		const exportState = await this.mailboxExportPersistence.getStateForUser(userId);
		if (exportState == null || exportState.type !== "finished") throw new ProgrammingError("Export is not finished");
		await this.electron.shell.openPath(exportState.exportDirectoryPath);
	}
	async getExportDirectoryPath() {
		const directory = path.join(this.tfs.getTutanotaTempPath(), EXPORT_DIR);
		await promises.mkdir(directory, { recursive: true });
		return directory;
	}
};

//#endregion
//#region tests/desktop/export/DesktopExportFacadeTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
function enoentError() {
	const err = new Error();
	Object.assign(err, { code: "ENOENT" });
	return err;
}
dist_default.spec("DesktopExportFacade", function() {
	const userId = "userId";
	let facade;
	let dialog;
	let persistence;
	let fsPromises;
	let fs$1;
	let dateProvider;
	let desktopExportLock;
	const mailboxId = "mailboxId";
	const mailBagId = "mailBagId";
	const mailId = "mailId";
	dist_default.beforeEach(function() {
		dialog = (0, import_testdouble.object)();
		const electron = { dialog };
		persistence = (0, import_testdouble.object)();
		fsPromises = (0, import_testdouble.object)();
		dateProvider = (0, import_testdouble.object)();
		desktopExportLock = (0, import_testdouble.object)();
		(0, import_testdouble.when)(desktopExportLock.acquireLock(userId)).thenReturn(LockResult.LockAcquired);
		(0, import_testdouble.when)(dateProvider.now()).thenReturn(new Date("2024-12-05T12:00").getTime());
		fs$1 = { promises: fsPromises };
		facade = new DesktopExportFacade((0, import_testdouble.object)(), electron, (0, import_testdouble.object)(), (0, import_testdouble.object)(), (0, import_testdouble.object)(), persistence, fs$1, dateProvider, desktopExportLock);
	});
	dist_default.spec("startMailboxExport", function() {
		dist_default.test("if export is already running it throws an ExportError", async function() {
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve({
				type: "running",
				userId,
				mailboxId: "",
				exportDirectoryPath: "",
				exportedMails: 0,
				mailId: "",
				mailBagId: ""
			});
			await dist_default(() => facade.startMailboxExport(userId, "", "", "")).asyncThrows(ExportError);
		});
		dist_default.test("if export is locked for user it throws an ExportError", async function() {
			(0, import_testdouble.when)(desktopExportLock.acquireLock(userId)).thenReturn(LockResult.AlreadyLocked);
			await dist_default(() => facade.startMailboxExport(userId, "", "", "")).asyncThrows(ExportError);
		});
		dist_default.test("if no directory is selected it throws an error", async function() {
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve(null);
			(0, import_testdouble.when)(dialog.showOpenDialog(import_testdouble.matchers.anything(), { properties: ["openDirectory"] })).thenResolve({ filePaths: [] });
			await dist_default(() => facade.startMailboxExport(userId, "", "", "")).asyncThrows(CancelledError);
			(0, import_testdouble.verify)(desktopExportLock.unlock(userId));
		});
		dist_default.test("when directory already exists it picks a unique path", async function() {
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve(null);
			const selectedDirectory = "path";
			const finalExportDirectoryPath = "path/TutaExport-2024-12-05-1";
			(0, import_testdouble.when)(dialog.showOpenDialog(import_testdouble.matchers.anything(), { properties: ["openDirectory"] })).thenResolve({ filePaths: [selectedDirectory] });
			(0, import_testdouble.when)(fsPromises.stat(finalExportDirectoryPath)).thenReject(enoentError());
			await facade.startMailboxExport(userId, mailboxId, mailBagId, mailId);
			(0, import_testdouble.verify)(fsPromises.mkdir(finalExportDirectoryPath));
			(0, import_testdouble.verify)(persistence.setStateForUser({
				type: "running",
				userId,
				mailboxId,
				exportDirectoryPath: finalExportDirectoryPath,
				mailBagId,
				mailId,
				exportedMails: 0
			}));
		});
		dist_default.test("new state is set", async function() {
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve(null);
			const selectedDirectory = "path";
			const exportDirectoryPath = "path/TutaExport-2024-12-05";
			(0, import_testdouble.when)(dialog.showOpenDialog(import_testdouble.matchers.anything(), { properties: ["openDirectory"] })).thenResolve({ filePaths: [selectedDirectory] });
			(0, import_testdouble.when)(fsPromises.stat(exportDirectoryPath)).thenReject(enoentError());
			await facade.startMailboxExport(userId, mailboxId, mailBagId, mailId);
			(0, import_testdouble.verify)(fsPromises.mkdir(exportDirectoryPath));
			(0, import_testdouble.verify)(persistence.setStateForUser({
				type: "running",
				userId,
				mailboxId,
				exportDirectoryPath,
				mailBagId,
				mailId,
				exportedMails: 0
			}));
		});
	});
	dist_default.spec("endMailboxExport", function() {
		dist_default.test("when there's no previous state it throws an error", async function() {
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve(null);
			await dist_default(() => facade.endMailboxExport(userId)).asyncThrows(ProgrammingError);
		});
		dist_default.test("saves the state", async function() {
			const exportDirectoryPath = "exportPath";
			const previousState = {
				type: "running",
				userId,
				mailboxId,
				mailId,
				mailBagId,
				exportDirectoryPath,
				exportedMails: 42
			};
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve(previousState);
			await facade.endMailboxExport(userId);
			(0, import_testdouble.verify)(persistence.setStateForUser({
				type: "finished",
				userId,
				exportDirectoryPath,
				mailboxId
			}));
		});
	});
	dist_default.spec("saveMailboxExport", function() {
		const sentOn = new Date("2024-12-05T11:58Z");
		const receivedOn = new Date("2024-12-05T11:59Z");
		const mailBundleStub = {
			mailId: ["mailListId", mailId],
			bcc: [],
			body: "and I am a body!!",
			attachments: [],
			headers: null,
			isDraft: false,
			isRead: true,
			replyTo: [],
			sender: { address: "sender@example.com" },
			sentOn: sentOn.getTime(),
			cc: [],
			receivedOn: receivedOn.getTime(),
			subject: "I am a subject!!",
			to: []
		};
		dist_default.test("when there's no previous state it throws an error", async function() {
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve(null);
			await dist_default(() => facade.saveMailboxExport(mailBundleStub, userId, mailBagId, mailId)).asyncThrows(ProgrammingError);
		});
		dist_default.test("when there's mail bundle without attachments it writes the file", async function() {
			const runningState = {
				type: "running",
				userId,
				mailboxId,
				mailId,
				mailBagId,
				exportDirectoryPath: "test/innerFolder/TutaExport-2024-12-05",
				exportedMails: 42
			};
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve(runningState);
			await facade.saveMailboxExport(mailBundleStub, userId, mailBagId, mailId);
			const fileName = generateExportFileName(elementIdPart(mailBundleStub.mailId), mailBundleStub.subject, sentOn, "eml");
			const fullPath = path.join(runningState.exportDirectoryPath, fileName);
			const bundleData = mailToEmlFile(mailBundleStub, fileName);
			(0, import_testdouble.verify)(fsPromises.writeFile(fullPath, bundleData.data));
			(0, import_testdouble.verify)(persistence.setStateForUser({
				type: "running",
				userId,
				mailboxId,
				mailId,
				mailBagId,
				exportDirectoryPath: "test/innerFolder/TutaExport-2024-12-05",
				exportedMails: 43
			}));
		});
	});
	dist_default.spec("clearExportState", function() {
		dist_default.test("calls the correct function", async function() {
			await facade.clearExportState(userId);
			(0, import_testdouble.verify)(persistence.clearStateForUser(userId));
		});
		dist_default.test("unlocks export for user", async function() {
			await facade.clearExportState(userId);
			(0, import_testdouble.verify)(desktopExportLock.unlock(userId));
		});
	});
	dist_default.spec("getExportState", function() {
		dist_default.test("returns locked state when export is locked", async function() {
			(0, import_testdouble.when)(desktopExportLock.acquireLock(userId)).thenReturn(LockResult.AlreadyLocked);
			(0, import_testdouble.when)(persistence.getStateForUser(userId)).thenResolve({
				type: "running",
				userId,
				mailboxId: "",
				exportDirectoryPath: "",
				exportedMails: 0,
				mailId: "",
				mailBagId: ""
			});
			dist_default(await facade.getMailboxExportState(userId)).deepEquals({
				type: "locked",
				userId
			});
		});
	});
});

//#endregion
//# sourceMappingURL=DesktopExportFacadeTest-CEtrIUBl.js.map