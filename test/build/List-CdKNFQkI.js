
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { debounce, mapLazily, memoized, numberRange } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { isBrowser } from "./Env-D5xGlXfw.js";
import { DefaultAnimationTime, TransformEnum, animations, applySafeAreaInsetMarginLR, ease, opacity, px, size, styles, theme, transform } from "./HtmlUtils-C-ecR7U7.js";
import { client } from "./ClientDetector-D0v6Vqu6.js";
import { Keys, TabIndex } from "./TutanotaConstants-3bwAESYA.js";
import { Button, ButtonType, progressIcon } from "./Icon-BuqNK7vz.js";
import { isKeyPressed } from "./KeyManager-B0OGXEyJ.js";

//#region ../src/common/gui/base/SwipeHandler.ts
let DirectionLock = function(DirectionLock$1) {
	DirectionLock$1[DirectionLock$1["Horizontal"] = 0] = "Horizontal";
	DirectionLock$1[DirectionLock$1["Vertical"] = 1] = "Vertical";
	return DirectionLock$1;
}({});
var SwipeHandler = class {
	/** uses clientX/clientY thus relative to view port */
	startPos;
	touchArea;
	animating;
	isAnimating = false;
	directionLock;
	constructor(touchArea) {
		this.startPos = {
			x: 0,
			y: 0
		};
		this.touchArea = touchArea;
		this.animating = Promise.resolve();
		this.directionLock = null;
	}
	attach() {
		this.touchArea.addEventListener("touchstart", this.onTouchStart, { passive: true });
		this.touchArea.addEventListener("touchmove", this.onTouchMove, { passive: false });
		this.touchArea.addEventListener("touchend", this.onTouchEnd, { passive: true });
	}
	detach() {
		this.touchArea.removeEventListener("touchstart", this.onTouchStart);
		this.touchArea.removeEventListener("touchmove", this.onTouchMove);
		this.touchArea.removeEventListener("touchend", this.onTouchEnd);
	}
	onTouchStart = (e) => {
		this.startPos = {
			x: e.touches[0].clientX,
			y: e.touches[0].clientY
		};
	};
	onTouchMove = (e) => {
		let { x, y } = this.getDelta(e);
		if (this.directionLock === DirectionLock.Horizontal || this.directionLock !== DirectionLock.Vertical && Math.abs(x) > Math.abs(y) && Math.abs(x) > 14) {
			this.directionLock = DirectionLock.Horizontal;
			e.preventDefault();
			if (!this.isAnimating) this.onHorizontalDrag(x, y);
		} else if (this.directionLock !== DirectionLock.Vertical && Math.abs(y) > Math.abs(x) && Math.abs(y) > size.list_row_height) {
			this.directionLock = DirectionLock.Vertical;
			if (!this.isAnimating) window.requestAnimationFrame(() => {
				if (!this.isAnimating) this.reset({
					x,
					y
				});
			});
		}
	};
	onTouchEnd = (e) => {
		this.gestureEnd(e);
	};
	gestureEnd(e) {
		const delta = this.getDelta(e);
		if (!this.isAnimating && this.directionLock === DirectionLock.Horizontal) {
			this.animating = this.onHorizontalGestureCompleted(delta);
			this.isAnimating = true;
		} else if (!this.isAnimating) {
			this.animating = this.reset(delta);
			this.isAnimating = true;
		}
		this.animating.then(() => this.isAnimating = false);
		this.directionLock = null;
	}
	onHorizontalDrag(xDelta, yDelta) {}
	onHorizontalGestureCompleted(delta) {
		return Promise.resolve();
	}
	reset(delta) {
		return Promise.resolve();
	}
	getDelta(e) {
		return {
			x: e.changedTouches[0].clientX - this.startPos.x,
			y: e.changedTouches[0].clientY - this.startPos.y
		};
	}
};

//#endregion
//#region ../src/common/gui/base/ListUtils.ts
const ACTION_DISTANCE = 150;
const PageSize = 100;
function listSelectionKeyboardShortcuts(multiselectMode, callbacks) {
	const multiselectionEnabled = multiselectMode == MultiselectMode.Enabled ? () => true : () => false;
	return [
		{
			key: Keys.UP,
			exec: mapLazily(callbacks, (list) => list?.selectPrevious(false)),
			help: "selectPrevious_action"
		},
		{
			key: Keys.K,
			exec: mapLazily(callbacks, (list) => list?.selectPrevious(false)),
			help: "selectPrevious_action"
		},
		{
			key: Keys.UP,
			shift: true,
			exec: mapLazily(callbacks, (list) => list?.selectPrevious(true)),
			help: "addPrevious_action",
			enabled: multiselectionEnabled
		},
		{
			key: Keys.K,
			shift: true,
			exec: mapLazily(callbacks, (list) => list?.selectPrevious(true)),
			help: "addPrevious_action",
			enabled: multiselectionEnabled
		},
		{
			key: Keys.DOWN,
			exec: mapLazily(callbacks, (list) => list?.selectNext(false)),
			help: "selectNext_action"
		},
		{
			key: Keys.J,
			exec: mapLazily(callbacks, (list) => list?.selectNext(false)),
			help: "selectNext_action"
		},
		{
			key: Keys.DOWN,
			shift: true,
			exec: mapLazily(callbacks, (list) => list?.selectNext(true)),
			help: "addNext_action",
			enabled: multiselectionEnabled
		},
		{
			key: Keys.J,
			shift: true,
			exec: mapLazily(callbacks, (list) => list?.selectNext(true)),
			help: "addNext_action",
			enabled: multiselectionEnabled
		},
		{
			key: Keys.A,
			ctrlOrCmd: true,
			shift: true,
			exec: mapLazily(callbacks, (list) => list?.areAllSelected() ? list.selectNone() : list?.selectAll()),
			help: "selectAllLoaded_action",
			enabled: () => multiselectionEnabled() && !isBrowser()
		}
	];
}

//#endregion
//#region ../src/common/gui/base/ListSwipeHandler.ts
var ListSwipeHandler = class extends SwipeHandler {
	virtualElement = null;
	xoffset;
	constructor(touchArea, config) {
		super(touchArea);
		this.config = config;
	}
	onHorizontalDrag(xDelta, yDelta) {
		super.onHorizontalDrag(xDelta, yDelta);
		const ve = this.getVirtualElement();
		window.requestAnimationFrame(() => {
			this.xoffset = xDelta < 0 ? Math.max(xDelta, -ACTION_DISTANCE) : Math.min(xDelta, ACTION_DISTANCE);
			if (!this.isAnimating && ve && ve.domElement && ve.entity) {
				ve.domElement.style.transform = `translateX(${this.xoffset}px) translateY(${ve.top}px)`;
				this.config.domSwipeSpacerLeft().style.transform = `translateX(${this.xoffset - this.width()}px) translateY(${ve.top}px)`;
				this.config.domSwipeSpacerRight().style.transform = `
				translateX(${this.xoffset + this.width()}px) translateY(${ve.top}px)`;
			}
		});
	}
	onHorizontalGestureCompleted(delta) {
		if (this.virtualElement && this.virtualElement.entity && Math.abs(delta.x) > ACTION_DISTANCE) return this.finish(this.virtualElement, this.virtualElement.entity, delta);
else return this.reset(delta);
	}
	async finish(virtualElement, entity, delta) {
		if (this.xoffset === 0) return;
		try {
			const listTargetPosition = this.xoffset < 0 ? -this.width() : this.width();
			await Promise.all([
				virtualElement.domElement && animations.add(virtualElement.domElement, transform(TransformEnum.TranslateX, this.xoffset, listTargetPosition).chain(TransformEnum.TranslateY, virtualElement.top, virtualElement.top), {
					easing: ease.inOut,
					duration: DefaultAnimationTime * 2
				}),
				animations.add(this.config.domSwipeSpacerLeft(), transform(TransformEnum.TranslateX, this.xoffset - this.width(), listTargetPosition - this.width()).chain(TransformEnum.TranslateY, virtualElement.top, virtualElement.top), {
					easing: ease.inOut,
					duration: DefaultAnimationTime * 2
				}),
				animations.add(this.config.domSwipeSpacerRight(), transform(TransformEnum.TranslateX, this.xoffset + this.width(), listTargetPosition + this.width()).chain(TransformEnum.TranslateY, virtualElement.top, virtualElement.top), {
					easing: ease.inOut,
					duration: DefaultAnimationTime * 2
				})
			]);
			this.xoffset = listTargetPosition;
			let swipeDecision;
			try {
				if (delta.x < 0) swipeDecision = await this.config.onSwipeLeft(entity);
else swipeDecision = await this.config.onSwipeRight(entity);
			} catch (e) {
				console.error("rejection in swipe action", e);
				swipeDecision = ListSwipeDecision.Cancel;
			}
			if (swipeDecision === ListSwipeDecision.Cancel) {
				await this.reset(delta);
				return;
			}
			this.xoffset = 0;
			if (virtualElement.domElement) virtualElement.domElement.style.transform = `translateX(${this.xoffset}px) translateY(${virtualElement.top}px)`;
			await Promise.all([animations.add(this.config.domSwipeSpacerLeft(), opacity(1, 0, true)), animations.add(this.config.domSwipeSpacerRight(), opacity(1, 0, true))]);
			this.config.domSwipeSpacerLeft().style.transform = `translateX(${this.xoffset - this.width() - 1}px) translateY(${virtualElement.top}px)`;
			this.config.domSwipeSpacerRight().style.transform = `translateX(${this.xoffset + this.width() + 1}px) translateY(${virtualElement.top}px)`;
			this.config.domSwipeSpacerRight().style.opacity = "";
			this.config.domSwipeSpacerLeft().style.opacity = "";
		} finally {
			this.virtualElement = null;
		}
	}
	width() {
		return this.config.width();
	}
	getVirtualElement() {
		if (!this.virtualElement) this.virtualElement = this.config.getRowForPosition(this.startPos);
		return this.virtualElement;
	}
	reset(delta) {
		try {
			if (this.xoffset !== 0) {
				const ve = this.virtualElement;
				if (ve && ve.domElement && ve.entity) return Promise.all([
					animations.add(ve.domElement, transform(TransformEnum.TranslateX, this.xoffset, 0).chain(TransformEnum.TranslateY, ve.top, ve.top), { easing: ease.inOut }),
					animations.add(this.config.domSwipeSpacerLeft(), transform(TransformEnum.TranslateX, this.xoffset - this.width(), -this.width()).chain(TransformEnum.TranslateY, ve.top, ve.top), { easing: ease.inOut }),
					animations.add(this.config.domSwipeSpacerRight(), transform(TransformEnum.TranslateX, this.xoffset + this.width(), this.width()).chain(TransformEnum.TranslateY, ve.top, ve.top), { easing: ease.inOut })
				]);
				this.xoffset = 0;
			}
		} finally {
			this.virtualElement = null;
		}
		return Promise.resolve();
	}
};

//#endregion
//#region ../src/common/gui/base/List.ts
let ListLoadingState = function(ListLoadingState$1) {
	/** not loading anything */
	ListLoadingState$1[ListLoadingState$1["Idle"] = 0] = "Idle";
	ListLoadingState$1[ListLoadingState$1["Loading"] = 1] = "Loading";
	/** loading was cancelled, e.g. because of the network error or explicit user request */
	ListLoadingState$1[ListLoadingState$1["ConnectionLost"] = 2] = "ConnectionLost";
	/** finished loading */
	ListLoadingState$1[ListLoadingState$1["Done"] = 3] = "Done";
	return ListLoadingState$1;
}({});
let MultiselectMode = function(MultiselectMode$1) {
	MultiselectMode$1[MultiselectMode$1["Disabled"] = 0] = "Disabled";
	MultiselectMode$1[MultiselectMode$1["Enabled"] = 1] = "Enabled";
	return MultiselectMode$1;
}({});
let ListSwipeDecision = function(ListSwipeDecision$1) {
	ListSwipeDecision$1[ListSwipeDecision$1["Cancel"] = 0] = "Cancel";
	ListSwipeDecision$1[ListSwipeDecision$1["Commit"] = 1] = "Commit";
	return ListSwipeDecision$1;
}({});
const ScrollBuffer = 15;
var List = class {
	innerDom = null;
	containerDom = null;
	rows = [];
	state = null;
	currentPosition = 0;
	lastAttrs;
	domSwipeSpacerLeft;
	domSwipeSpacerRight;
	loadingIndicatorChildDom;
	swipeHandler;
	width = 0;
	height = 0;
	activeIndex = null;
	lastThemeId = theme.themeId;
	view({ attrs }) {
		const oldAttrs = this.lastAttrs;
		this.lastAttrs = attrs;
		return mithril_default(
			".list-container.overflow-y-scroll.nofocus.overflow-x-hidden.fill-absolute",
			{
				"data-testid": "unordered_list",
				oncreate: ({ dom }) => {
					this.containerDom = dom;
					if (typeof ResizeObserver !== "undefined") new ResizeObserver(() => {
						this.updateSize();
					}).observe(this.containerDom);
else requestAnimationFrame(() => this.updateSize());
					this.swipeHandler = this.createSwipeHandler();
				},
				onscroll: () => {
					this.onScroll(attrs);
				}
			},
			this.renderSwipeItems(attrs),
			// we need rel for the status indicator
			mithril_default("ul.list.rel.click", {
				oncreate: ({ dom }) => {
					this.innerDom = dom;
					this.initializeDom(dom, attrs);
					this.updateDomElements(attrs);
					this.state = attrs.state;
					this.lastThemeId = theme.themeId;
					if (styles.isSingleColumnLayout()) this.innerDom.focus();
				},
				onupdate: ({ dom }) => {
					if (oldAttrs.renderConfig !== attrs.renderConfig) {
						console.log("list renderConfig has changed, reset");
						dom.vnodes = null;
						this.initializeDom(dom, attrs);
					}
					if (this.state !== attrs.state || this.lastThemeId !== theme.themeId) {
						this.updateDomElements(attrs);
						this.state = attrs.state;
					}
					this.lastThemeId = theme.themeId;
				},
				onscroll: () => {
					attrs.onLoadMore();
				}
			})
);
	}
	createSwipeHandler() {
		return new ListSwipeHandler(this.containerDom, {
			width: () => this.width,
			domSwipeSpacerLeft: () => this.domSwipeSpacerLeft,
			domSwipeSpacerRight: () => this.domSwipeSpacerRight,
			getRowForPosition: (coord) => this.getRowForPosition(coord),
			onSwipeLeft: async (el) => this.lastAttrs.renderConfig.swipe?.swipeLeft(el) ?? ListSwipeDecision.Cancel,
			onSwipeRight: async (el) => this.lastAttrs.renderConfig.swipe?.swipeRight(el) ?? ListSwipeDecision.Cancel
		});
	}
	getRowForPosition(clientCoordiante) {
		const touchAreaOffset = this.containerDom.getBoundingClientRect().top;
		const relativeYPosition = this.currentPosition + clientCoordiante.y - touchAreaOffset;
		const itemIndex = Math.floor(relativeYPosition / this.lastAttrs.renderConfig.itemHeight);
		const targetElementPosition = itemIndex * this.lastAttrs.renderConfig.itemHeight;
		return this.rows.find((ve) => ve.top === targetElementPosition) ?? null;
	}
	VIRTUAL_LIST_LENGTH = 100;
	initializeDom(dom, attrs) {
		const rows = [];
		mithril_default.render(
			dom,
			// hardcoded number of elements for now
			[numberRange(0, this.VIRTUAL_LIST_LENGTH - 1).map(() => this.createRow(attrs, rows)), this.renderStatusRow()]
);
		this.rows = rows;
		if (rows.length !== this.VIRTUAL_LIST_LENGTH) throw new ProgrammingError(`invalid rows length, expected ${this.VIRTUAL_LIST_LENGTH} rows, got ${this.rows.length}`);
		if (attrs.renderConfig.swipe) this.swipeHandler?.attach();
else this.swipeHandler.detach();
	}
	onScroll(attrs) {
		const visibleElementHeight = this.updateDomElements(attrs);
		this.loadMoreIfNecessary(attrs, visibleElementHeight);
	}
	createRow(attrs, rows) {
		return mithril_default("li.list-row.nofocus", {
			draggable: attrs.renderConfig.dragStart ? "true" : undefined,
			tabindex: TabIndex.Default,
			oncreate: (vnode) => {
				const dom = vnode.dom;
				const row = {
					row: attrs.renderConfig.createElement(dom),
					domElement: dom,
					top: -1,
					entity: null
				};
				rows.push(row);
				this.setRowEventListeners(attrs, dom, row);
			}
		});
	}
	setRowEventListeners(attrs, domElement, row) {
		const LONG_PRESS_DURATION_MS = 400;
		let touchStartTime = null;
		domElement.onclick = (e) => {
			if (!touchStartTime || Date.now() - touchStartTime < LONG_PRESS_DURATION_MS) {
				if (row.entity) this.handleEvent(row.entity, e);
			}
		};
		domElement.onkeyup = (e) => {
			if (isKeyPressed(e.key, Keys.SPACE, Keys.RETURN)) {
				if (row.entity) this.handleEvent(row.entity, e);
			}
		};
		const onFocus = (focusType) => {
			return (e) => {
				const dom = e.target;
				if (dom && dom.firstElementChild) dom.firstElementChild?.dispatchEvent(new FocusEvent(focusType));
			};
		};
		domElement.onfocus = onFocus("focus");
		domElement.onblur = onFocus("blur");
		domElement.ondragstart = (e) => {
			if (row.domElement) row.domElement.style.background = theme.navigation_bg;
			requestAnimationFrame(() => {
				if (row.domElement) row.domElement.style.background = "";
			});
			if (attrs.renderConfig.dragStart) {
				if (row.entity && this.state) attrs.renderConfig.dragStart(e, row.entity, this.state.selectedItems);
			}
		};
		if (attrs.renderConfig.multiselectionAllowed === MultiselectMode.Enabled) {
			let timeoutId;
			let touchStartCoords = null;
			domElement.addEventListener("touchstart", (e) => {
				touchStartTime = Date.now();
				timeoutId = setTimeout(() => {
					if (row.entity) attrs.onSingleTogglingMultiselection(row.entity);
					mithril_default.redraw();
				}, LONG_PRESS_DURATION_MS);
				touchStartCoords = {
					x: e.touches[0].pageX,
					y: e.touches[0].pageY
				};
			});
			const touchEnd = () => {
				if (timeoutId) clearTimeout(timeoutId);
			};
			domElement.addEventListener("touchend", touchEnd);
			domElement.addEventListener("touchcancel", touchEnd);
			domElement.addEventListener("touchmove", (e) => {
				const maxDistance = 30;
				const touch = e.touches[0];
				if (touchStartCoords && timeoutId && (Math.abs(touch.pageX - touchStartCoords.x) > maxDistance || Math.abs(touch.pageY - touchStartCoords.y) > maxDistance)) clearTimeout(timeoutId);
			});
		}
	}
	/**
	* Updates the given list of selected items with a click on the given clicked item. Takes ctrl and shift key events into consideration for multi selection.
	* If ctrl is pressed the selection status of the clickedItem is toggled.
	* If shift is pressed, all items beginning from the nearest selected item to the clicked item are additionally selected.
	* If neither ctrl nor shift are pressed only the clicked item is selected.
	*/
	handleEvent(clickedEntity, event) {
		let changeType;
		if (client.isMobileDevice() && this.lastAttrs.state.inMultiselect || event.ctrlKey || client.isMacOS && event.metaKey) changeType = "togglingIncludingSingle";
else if (event.shiftKey) changeType = "range";
else changeType = "single";
		this.changeSelection(clickedEntity, changeType);
	}
	/**
	* changeType:
	*  * single: one item selection (not multiselect)
	*  * togglingIncludingSingle: if not in multiselect, start multiselect. Turns multiselect on or off for the item. Includes the item from single selection
	*    when turning multiselect on.
	*  * togglingNewMultiselect: if not in multiselect, start multiselect. Turns multiselect on or off for the item. Only selected item will be in multiselect
	*    when turning multiselect on.
	*  * range: range selection, extends the range until the selected item
	*/
	changeSelection(clickedEntity, changeType) {
		switch (changeType) {
			case "single":
				this.lastAttrs.onSingleSelection(clickedEntity);
				break;
			case "togglingIncludingSingle":
				if (this.lastAttrs.renderConfig.multiselectionAllowed === MultiselectMode.Enabled) this.lastAttrs.onSingleTogglingMultiselection(clickedEntity);
				break;
			case "range":
				if (this.lastAttrs.renderConfig.multiselectionAllowed === MultiselectMode.Enabled) this.lastAttrs.onRangeSelectionTowards(clickedEntity);
				break;
		}
	}
	updateDomElements(attrs) {
		if (this.height === 0) this.height = this.containerDom.clientHeight;
		const rowHeight = attrs.renderConfig.itemHeight;
		const statusHeight = attrs.state.loadingStatus === ListLoadingState.Done ? 0 : size.list_row_height;
		this.innerDom.style.height = px(attrs.state.items.length * rowHeight + statusHeight);
		if (attrs.state.activeIndex != null && attrs.state.activeIndex !== this.activeIndex) {
			const index = attrs.state.activeIndex;
			const desiredPosition = attrs.state.activeIndex * rowHeight;
			if (desiredPosition > this.containerDom.scrollTop + this.height || desiredPosition < this.containerDom.scrollTop) {
				console.log("active item out of screen, scrolling to", index, desiredPosition);
				this.currentPosition = this.containerDom.scrollTop = desiredPosition;
			} else this.currentPosition = this.containerDom.scrollTop;
		} else this.currentPosition = this.containerDom.scrollTop;
		this.activeIndex = attrs.state.activeIndex;
		const visibleElements = 2 * Math.ceil(this.height / rowHeight / 2);
		const visibleElementsHeight = visibleElements * rowHeight;
		const bufferHeight = ScrollBuffer * rowHeight;
		const maxStartPosition = rowHeight * attrs.state.items.length - bufferHeight * 2 - visibleElementsHeight;
		let nextPosition = this.currentPosition - this.currentPosition % rowHeight - bufferHeight;
		if (nextPosition < 0) nextPosition = 0;
else if (nextPosition > maxStartPosition) nextPosition = maxStartPosition;
		for (const row of this.rows) {
			row.top = nextPosition;
			nextPosition += rowHeight;
			const pos = row.top / rowHeight;
			const item = attrs.state.items[pos];
			row.entity = item;
			if (!item) row.domElement.style.display = "none";
else {
				row.domElement.style.display = "";
				row.domElement.style.transform = `translateY(${row.top}px)`;
				row.row.update(item, attrs.state.selectedItems.has(item), attrs.state.inMultiselect);
			}
			if (attrs.state.selectedItems.has(item) && (!this.state?.selectedItems.has(item) || this.state == null)) row.domElement.focus();
		}
		this.updateStatus(attrs.state.loadingStatus);
		this.loadMoreIfNecessary(attrs, visibleElementsHeight);
		return visibleElementsHeight;
	}
	updateStatus = memoized((status) => {
		switch (status) {
			case ListLoadingState.Idle:
			case ListLoadingState.Done:
				mithril_default.render(this.loadingIndicatorChildDom, null);
				this.loadingIndicatorChildDom.style.display = "none";
				break;
			case ListLoadingState.Loading:
				mithril_default.render(this.loadingIndicatorChildDom, this.renderLoadingIndicator());
				this.loadingIndicatorChildDom.style.display = "";
				break;
			case ListLoadingState.ConnectionLost:
				mithril_default.render(this.loadingIndicatorChildDom, this.renderConnectionLostIndicator());
				this.loadingIndicatorChildDom.style.display = "";
				break;
		}
	});
	renderLoadingIndicator() {
		return mithril_default(".flex-center.items-center", { style: {
			height: px(size.list_row_height),
			width: "100%",
			position: "absolute",
			gap: px(size.hpad_small)
		} }, progressIcon(), mithril_default(Button, {
			label: "cancel_action",
			type: ButtonType.Primary,
			click: () => this.lastAttrs.onStopLoading()
		}));
	}
	renderConnectionLostIndicator() {
		return mithril_default(".plr-l.flex-center.items-center", { style: { height: px(size.list_row_height) } }, mithril_default(Button, {
			label: "loadMore_action",
			type: ButtonType.Primary,
			click: () => this.retryLoading()
		}));
	}
	retryLoading() {
		this.lastAttrs.onRetryLoading();
	}
	async loadMoreIfNecessary(attrs, visibleElementsHeight) {
		const lastBunchVisible = this.currentPosition > attrs.state.items.length * attrs.renderConfig.itemHeight - visibleElementsHeight * 2;
		if (lastBunchVisible && attrs.state.loadingStatus == ListLoadingState.Idle) await attrs.onLoadMore();
	}
	renderStatusRow() {
		return mithril_default("li.list-row", {
			style: {
				bottom: 0,
				height: px(size.list_row_height),
				display: this.shouldDisplayStatusRow() ? "none" : null
			},
			oncreate: (vnode) => {
				this.loadingIndicatorChildDom = vnode.dom;
			}
		});
	}
	shouldDisplayStatusRow() {
		return this.state?.loadingStatus === ListLoadingState.Done || this.state?.loadingStatus === ListLoadingState.Idle;
	}
	renderSwipeItems(attrs) {
		if (attrs.renderConfig.swipe == null) return null;
		return [mithril_default(".swipe-spacer.flex.items-center.justify-end.pr-l.blue", {
			oncreate: (vnode) => this.domSwipeSpacerLeft = vnode.dom,
			tabindex: TabIndex.Programmatic,
			"aria-hidden": "true",
			style: {
				height: px(attrs.renderConfig.itemHeight),
				transform: `translateY(-${attrs.renderConfig.itemHeight}px)`,
				position: "absolute",
				"z-index": 1
			}
		}, attrs.renderConfig.swipe.renderLeftSpacer()), mithril_default(".swipe-spacer.flex.items-center.pl-l.red", {
			oncreate: (vnode) => this.domSwipeSpacerRight = vnode.dom,
			tabindex: TabIndex.Programmatic,
			"aria-hidden": "true",
			style: {
				height: px(attrs.renderConfig.itemHeight),
				transform: `translateY(-${attrs.renderConfig.itemHeight}px)`,
				position: "absolute",
				"z-index": 1
			}
		}, attrs.renderConfig.swipe.renderRightSpacer())];
	}
	updateSize() {
		const containerDom = this.containerDom;
		if (containerDom && this.domSwipeSpacerLeft && this.domSwipeSpacerRight) {
			this.domSwipeSpacerLeft.style.opacity = "0";
			this.domSwipeSpacerRight.style.opacity = "0";
			this.doUpdateWidth(containerDom);
		}
	}
	doUpdateWidth = debounce(60, (containerDom) => {
		this.width = containerDom.clientWidth;
		this.height = containerDom.clientHeight;
		if (this.swipeHandler) {
			const translateX = this.width + 1;
			this.domSwipeSpacerLeft.style.width = px(this.width);
			this.domSwipeSpacerRight.style.width = px(this.width);
			this.domSwipeSpacerLeft.style.transform = `translateX(${-translateX}px) translateY(0px)`;
			this.domSwipeSpacerRight.style.transform = `translateX(${translateX}px) translateY(0px)`;
			for (const row of this.rows) if (row.domElement) applySafeAreaInsetMarginLR(row.domElement);
			this.domSwipeSpacerLeft.style.opacity = "1";
			this.domSwipeSpacerRight.style.opacity = "1";
		}
	});
};

//#endregion
export { List, ListLoadingState, MultiselectMode, PageSize, listSelectionKeyboardShortcuts };
//# sourceMappingURL=List-CdKNFQkI.js.map