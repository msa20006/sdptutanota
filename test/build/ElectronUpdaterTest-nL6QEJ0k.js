
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { assertNotNull, delay, downcast, neverNull } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { BuildConfigKey, DesktopConfigKey } from "./ConfigKeys-B1UD5FwS.js";
import { en_default } from "./en-BgRn5Lom.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { spy } from "./dist-BY49f75m.js";
import { nodemocker_default } from "./nodemocker-Bh_RUICG.js";
import { NotificationResult } from "./DesktopNotifier-BR7GuUWK.js";

//#region ../src/common/desktop/ElectronUpdater.ts
/**
* Wraps electron-updater for Tutanota Desktop
*
* To test:
* run local server to serve updates
* run 'node dist -l local' to build initial client
* run 'cp ./build/desktop-snapshot/tutanota-desktop-snapshot-linux.AppImage ~/tutanota-desktop-snapshot-linux.AppImage'
* run '~/tutanota-desktop-snapshot-linux.AppImage'
* run 'node dist -el local' to build an update when it's needed (takes about 20s)
*
*/
const TAG = "[ElectronUpdater]";
var ElectronUpdater = class {
	updatePollInterval = null;
	checkUpdateSignature = false;
	errorCount = 0;
	logger;
	_updateInfo = null;
	enableAutoUpdateListener = () => {
		this.start();
	};
	get updateInfo() {
		return this._updateInfo;
	}
	constructor(conf, notifier, crypto, app, icon, updater, fs, scheduler = setInterval) {
		this.conf = conf;
		this.notifier = notifier;
		this.crypto = crypto;
		this.app = app;
		this.icon = icon;
		this.updater = updater;
		this.fs = fs;
		this.scheduler = scheduler;
		this.logger = {
			info: (m, ...args) => console.log.apply(console, [
				TAG,
				"INFO:",
				m
			].concat(args)),
			warn: (m, ...args) => console.warn.apply(console, [
				TAG,
				"WARN:",
				m
			].concat(args)),
			error: (m, ...args) => console.error.apply(console, [
				TAG,
				"ERROR:",
				m
			].concat(args)),
			verbose: (m, ...args) => console.log.apply(console, [
				TAG,
				":",
				m
			].concat(args)),
			debug: (m, ...args) => console.log.apply(console, [
				TAG,
				"DEBUG:",
				m
			].concat(args)),
			silly: (m, ...args) => console.log.apply(console, [
				TAG,
				"DEBUG:",
				m
			].concat(args))
		};
		const autoUpdater = this.updater.electronUpdater;
		autoUpdater.logger = this.logger;
		autoUpdater.autoDownload = false;
		autoUpdater.autoInstallOnAppQuit = false;
		autoUpdater.on("checking-for-update", () => {
			this.logger.info("checking-for-update");
		}).on("update-available", () => {
			this.logger.info("update-available");
			this.stopPolling();
			this.downloadUpdate();
		}).on("update-not-available", (info) => {
			this.logger.info("update not available:", info);
		}).on("download-progress", (prg) => {
			this.logger.debug("update dl progress:", prg);
		}).on("update-downloaded", async (info) => {
			this._updateInfo = info;
			this.logger.info(`update-downloaded: ${JSON.stringify(info)}`);
			this.stopPolling();
			const data$1 = await this.fs.promises.readFile(info.downloadedFile);
			const publicKeys = await this.conf.getConst(BuildConfigKey.pubKeys);
			const verified = publicKeys.some((pk) => this.verifySignature(pk, assertNotNull(info), data$1));
			if (verified) this.notifyAndInstall(info);
else {
				this._updateInfo = null;
				this.logger.warn(`all signatures invalid, could not update. Deleting ${info.downloadedFile}.`);
				this.fs.promises.unlink(info.downloadedFile);
			}
		}).on("error", (e) => {
			this.stopPolling();
			this.errorCount += 1;
			const messageEvent = downcast(e);
			if (this.errorCount >= 5) {
				this.logger.error(`Auto Update Error ${this.errorCount}, polling is stopped:\n${messageEvent.message}`);
				if (this.errorCount === 5) this.notifyUpdateError();
				this.logger.error(`Update failed multiple times. Last error:\n${messageEvent.message}`);
			} else {
				this.logger.error(`Auto Update Error ${this.errorCount}, continuing polling:\n${messageEvent.message}`);
				this.startPolling();
			}
		});
		/**
		* this replaces the autoInstallOnAppQuit feature of autoUpdater,
		* which causes the app to uninstall itself if it is installed for
		* all users on a windows system.
		*
		* should be removed once https://github.com/electron-userland/electron-builder/issues/4815
		* is resolved.
		*/
		this.app.once("before-quit", (ev) => {
			if (this._updateInfo) {
				ev.preventDefault();
				this._updateInfo = null;
				if (process.platform !== "win32") this.updater.electronUpdater.quitAndInstall(true, false);
			}
		});
	}
	async start() {
		if (!this.updater.updatesEnabledInBuild()) {
			this.logger.debug("no update info on disk, disabling updater.");
			this.conf.setVar(DesktopConfigKey.showAutoUpdateOption, false);
			return;
		}
		this.conf.setVar(DesktopConfigKey.showAutoUpdateOption, true);
		this.conf.removeListener(DesktopConfigKey.enableAutoUpdate, this.enableAutoUpdateListener).on(DesktopConfigKey.enableAutoUpdate, this.enableAutoUpdateListener);
		if (!await this.conf.getVar(DesktopConfigKey.enableAutoUpdate)) {
			this.stopPolling();
			return;
		}
		if (this.updatePollInterval) return;
		this.checkUpdateSignature = await this.conf.getConst(BuildConfigKey.checkUpdateSignature);
		this.startPolling();
		this.checkUpdate();
	}
	verifySignature(pubKey, updateInfo, data$1) {
		if (!this.checkUpdateSignature) return true;
		try {
			const signature = Buffer.from(updateInfo.signature, "base64");
			if (this.crypto.verifySignature(pubKey, data$1, signature)) {
				this.logger.info("Signature verification successful, installing update");
				return true;
			}
		} catch (e) {
			this.logger.error("Failed to verify update signature", e);
			return false;
		}
		return false;
	}
	setUpdateDownloadedListener(listener) {
		this.updater.electronUpdater.on("update-downloaded", listener);
	}
	async startPolling() {
		if (!this.updatePollInterval) {
			const multiplier = Math.floor(Math.random() * Math.pow(2, this.errorCount)) + 1;
			const interval = await this.conf.getConst(BuildConfigKey.pollingInterval);
			this.updatePollInterval = this.scheduler(() => this.checkUpdate(), interval * multiplier);
		}
	}
	async checkUpdateThrottleTime() {
		if (this.errorCount >= 5) {
			const throttleTime = 500 * this.errorCount;
			this.logger.debug(`Auto Update: throttling manual update attempt # ${this.errorCount} by ${throttleTime}`);
			await delay(throttleTime);
		}
	}
	stopPolling() {
		clearInterval(neverNull(this.updatePollInterval));
		this.updatePollInterval = null;
	}
	/**
	* try to get the update:
	* check update availability,
	* check signatures
	* try to download
	*
	* if the signature check is successful, further handling of the update
	* will be done by the 'update-downloaded' callback set up in the constructor
	* @returns {Promise} true if an update was downloaded, false otherwise
	*/
	async checkUpdate() {
		const autoUpdater = await this.updater.electronUpdater;
		return new Promise((resolve) => {
			let cleanup = (hasUpdate) => {
				cleanup = (hasUpdate$1) => {};
				resolve(hasUpdate);
				autoUpdater.removeListener("update-not-available", updateNotAvailable);
				autoUpdater.removeListener("update-downloaded", updateDownloaded);
				autoUpdater.removeListener("error", updateNotAvailable);
			};
			const updateNotAvailable = () => cleanup(false);
			const updateDownloaded = () => cleanup(true);
			autoUpdater.checkForUpdates().catch((e) => {
				this.logger.error("Update check failed,", e.message);
				cleanup(false);
			});
			autoUpdater.once("update-not-available", updateNotAvailable).once("update-downloaded", updateDownloaded).once("error", updateNotAvailable);
		});
	}
	/**
	* check for update if none is currently available,
	* quit and install otherwise
	* @returns {Promise<boolean>} True if an update is available and the next call will install it, false otherwise.
	*/
	manualUpdate() {
		return this.checkUpdateThrottleTime().then(() => {
			if (!this.updateInfo) return this.checkUpdate();
			this.installUpdate();
			return Promise.resolve(false);
		});
	}
	async downloadUpdate() {
		this.logger.debug("downloading");
		try {
			return await this.updater.electronUpdater.downloadUpdate();
		} catch (e) {
			this.logger.error("Update Download failed,", e.message);
			return [];
		}
	}
	async notifyAndInstall(info) {
		this.logger.debug("notifying for update");
		this.notifier.showOneShot({
			title: lang.get("updateAvailable_label", { "{version}": info.version }),
			body: lang.get("clickToUpdate_msg"),
			icon: this.icon
		}).then((res) => {
			if (res === NotificationResult.Click) this.installUpdate();
		}).catch((e) => this.logger.error("Notification failed, error message:", e?.message));
	}
	installUpdate() {
		this.logger.debug("installing update");
		this.app.emit("enable-force-quit");
		this._updateInfo = null;
		this.updater.electronUpdater.quitAndInstall(false, true);
	}
	async notifyUpdateError() {
		this.notifier.showOneShot({
			title: lang.get("errorReport_label"),
			body: lang.get("errorDuringUpdate_msg"),
			icon: this.icon
		}).catch((e) => this.logger.error("Error Notification failed, error message:", e?.message));
	}
};

//#endregion
//#region tests/desktop/ElectronUpdaterTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
lang.init(en_default);
const sigB64 = "c2lnbmF0dXJlCg==";
const shaB64 = "c2hhNTEyCg==";
const data = Buffer.from([
	1,
	2,
	3
]);
dist_default.spec("ElectronUpdater Test", function() {
	let electron;
	let fs;
	let crypto;
	let autoUpdater;
	let conf;
	let notifier;
	let updaterImpl;
	dist_default.beforeEach(function() {
		fs = (0, import_testdouble.object)();
		(0, import_testdouble.when)(fs.promises.unlink("downloadedFile.AppImage")).thenResolve();
		(0, import_testdouble.when)(fs.promises.readFile("downloadedFile.AppImage")).thenResolve(data);
		notifier = downcast({ showOneShot: spy((prop) => Promise.resolve("click")) });
		conf = downcast({
			removeListener: spy((key, cb) => conf),
			on: spy((key) => conf),
			setVar: spy(),
			getVar: (key) => {
				switch (key) {
					case "enableAutoUpdate": return true;
					case "showAutoUpdateOption": return true;
					default: throw new Error(`unexpected getVar key ${key}`);
				}
			},
			getConst: (key) => {
				switch (key) {
					case "checkUpdateSignature": return true;
					case "pubKeys": return ["no", "yes"];
					case "pollingInterval": return 300;
					case "iconName": return "iconName.name";
					default: throw new Error(`unexpected getConst key ${key}`);
				}
			}
		});
		const app = (0, import_testdouble.object)();
		(0, import_testdouble.when)(app.getVersion()).thenReturn("3.45.0");
		electron = { app };
		const pathCaptor = import_testdouble.matchers.captor();
		(0, import_testdouble.when)(app.getPath(pathCaptor.capture())).thenReturn(`/mock-${pathCaptor.value}/`);
		(0, import_testdouble.when)(app.once(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenReturn(app);
		crypto = (0, import_testdouble.object)();
		(0, import_testdouble.when)(crypto.verifySignature("yes", data, Buffer.from(sigB64, "base64"))).thenReturn(true);
		(0, import_testdouble.when)(crypto.verifySignature("no", import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenReturn(false);
		autoUpdater = {
			callbacks: {},
			logger: undefined,
			on: spy(function(ev, cb) {
				if (!this.callbacks[ev]) this.callbacks[ev] = [];
				this.callbacks[ev].push({
					fn: spy(cb),
					once: false
				});
				return this;
			}),
			once: function(ev, cb) {
				if (!this.callbacks[ev]) this.callbacks[ev] = [];
				this.callbacks[ev].push({
					fn: spy(cb),
					once: true
				});
				return this;
			},
			removeListener: function(ev, cb) {
				if (!this.callbacks[ev]) return;
				this.callbacks[ev] = this.callbacks[ev].filter((entry) => entry.fn !== cb);
			},
			removeAllListeners: spy(function(ev) {
				this.callbacks[ev] = [];
				return this;
			}),
			emit: function(ev, args) {
				const entries = this.callbacks[ev];
				for (const entry of entries) setTimeout(() => entry.fn(args), 1);
				this.callbacks[ev] = entries.filter((entry) => !entry.once);
			},
			checkForUpdates: spy(function() {
				this.emit("update-available", {
					downloadedFile: "downloadedFile.AppImage",
					sha512: shaB64,
					signature: sigB64,
					version: "4.5.0"
				});
				return Promise.resolve();
			}),
			downloadUpdate: spy(function() {
				this.emit("update-downloaded", {
					downloadedFile: "downloadedFile.AppImage",
					sha512: shaB64,
					signature: sigB64,
					version: "4.5.0"
				});
				return Promise.resolve();
			}),
			quitAndInstall: spy()
		};
		updaterImpl = downcast({
			electronUpdater: autoUpdater,
			updatesEnabledInBuild: () => true
		});
	});
	dist_default("update is available", async function() {
		downcast(updaterImpl).updatesEnabledInBuild = () => true;
		const upd = new ElectronUpdater(conf, notifier, crypto, electron.app, (0, import_testdouble.object)(), updaterImpl, fs);
		upd.start();
		dist_default(conf.setVar.callCount).equals(1);
		dist_default(conf.setVar.args).deepEquals(["showAutoUpdateOption", true]);
		dist_default(conf.removeListener.callCount).equals(1);
		dist_default(conf.removeListener.args[0]).equals("enableAutoUpdate");
		dist_default(conf.on.callCount).equals(1);
		await updaterImpl.electronUpdater;
		await delay(190);
		dist_default(notifier.showOneShot.callCount).equals(1);
		(0, import_testdouble.verify)(electron.app.emit("enable-force-quit"), { times: 1 });
		dist_default(autoUpdater.quitAndInstall.callCount).equals(1);
		dist_default(autoUpdater.quitAndInstall.args[0]).equals(false);
		dist_default(autoUpdater.quitAndInstall.args[1]).equals(true);
	});
	dist_default("update is not available", async function() {
		autoUpdater.checkForUpdates = spy(() => Promise.resolve());
		const upd = new ElectronUpdater(conf, notifier, crypto, electron.app, (0, import_testdouble.object)(), updaterImpl, fs);
		upd.start();
		await delay(190);
		dist_default(autoUpdater.checkForUpdates.callCount).equals(1);
		(0, import_testdouble.verify)(crypto.verifySignature(import_testdouble.matchers.anything(), import_testdouble.matchers.anything(), import_testdouble.matchers.anything()), { times: 0 });
		dist_default(notifier.showOneShot.callCount).equals(0);
		dist_default(autoUpdater.quitAndInstall.callCount).equals(0);
		upd.stopPolling();
	});
	dist_default("enable autoUpdate while running", async function() {
		let enabled = false;
		const oldConf = conf;
		conf = nodemocker_default.mock("__conf", oldConf).with({
			removeListener: () => conf,
			on: (key, cb) => {
				if (!enabled) setTimeout(() => {
					enabled = true;
					cb();
				}, 25);
				return conf;
			},
			getVar: (key) => {
				switch (key) {
					case "enableAutoUpdate": return enabled;
					case "showAutoUpdateOption": return true;
					default: throw new Error(`unexpected getVar key ${key}`);
				}
			}
		}).set();
		const upd = new ElectronUpdater(conf, notifier, crypto, electron.app, (0, import_testdouble.object)(), updaterImpl, fs);
		upd.start();
		await delay(100);
		dist_default(conf.removeListener.callCount).equals(2);
		dist_default(conf.on.callCount).equals(2);
		(0, import_testdouble.verify)(crypto.verifySignature("yes", data, Buffer.from(sigB64, "base64")));
		(0, import_testdouble.verify)(crypto.verifySignature("no", data, Buffer.from(sigB64, "base64")));
		dist_default(notifier.showOneShot.callCount).equals(1);
		(0, import_testdouble.verify)(electron.app.emit("enable-force-quit"), { times: 1 });
		dist_default(autoUpdater.quitAndInstall.callCount).equals(1);
		dist_default(autoUpdater.quitAndInstall.args[0]).equals(false);
		dist_default(autoUpdater.quitAndInstall.args[1]).equals(true);
	});
	dist_default("retry after autoUpdater reports an error", async function() {
		dist_default.timeout(500);
		let first = true;
		autoUpdater.checkForUpdates = function() {
			if (first) {
				first = false;
				this.emit("error", { message: "this is an autoUpdater error" });
				return Promise.reject("oops");
			} else {
				this.emit("update-available", {
					sha512: "sha512",
					signature: "signature"
				});
				return Promise.resolve();
			}
		};
		const scheduler = (fn, time) => setInterval(fn, 10);
		const upd = new ElectronUpdater(conf, notifier, crypto, electron.app, (0, import_testdouble.object)(), updaterImpl, fs, scheduler);
		upd.start();
		await delay(2);
		dist_default(autoUpdater.downloadUpdate.callCount).equals(0)("downloadUpdate after error");
		await delay(200);
		dist_default(notifier.showOneShot.callCount).equals(1)("showOneShot");
		dist_default(autoUpdater.downloadUpdate.callCount).equals(1)("downloadUpdate after download");
	});
	dist_default("shut down autoUpdater after errors", async function() {
		autoUpdater.downloadUpdate = function() {
			autoUpdater.emit("error", { message: "this is an autoUpdater error" });
			return Promise.resolve();
		};
		const scheduler = (fn) => setInterval(fn, 5);
		const upd = new ElectronUpdater(conf, notifier, crypto, electron.app, (0, import_testdouble.object)(), updaterImpl, fs, scheduler);
		upd.start();
		await delay(150);
		upd.stopPolling();
		dist_default(notifier.showOneShot.callCount).equals(1)("showOneShot");
	});
	dist_default("works if second key is right one", async function() {
		dist_default.timeout(1e3);
		const upd = new ElectronUpdater(conf, notifier, crypto, electron.app, (0, import_testdouble.object)(), updaterImpl, fs);
		upd.start();
		dist_default(conf.removeListener.callCount).equals(1);
		dist_default(conf.removeListener.args[0]).equals("enableAutoUpdate");
		dist_default(conf.on.callCount).equals(1);
		await delay(250);
		dist_default(autoUpdater.checkForUpdates.callCount).equals(1);
		(0, import_testdouble.verify)(crypto.verifySignature("no", data, Buffer.from(sigB64, "base64")));
		(0, import_testdouble.verify)(crypto.verifySignature("yes", data, Buffer.from(sigB64, "base64")));
		dist_default(notifier.showOneShot.callCount).equals(1);
		(0, import_testdouble.verify)(electron.app.emit("enable-force-quit"), { times: 1 });
		dist_default(autoUpdater.quitAndInstall.callCount).equals(1);
		dist_default(autoUpdater.quitAndInstall.args[0]).equals(false);
		dist_default(autoUpdater.quitAndInstall.args[1]).equals(true);
		upd.stopPolling();
	});
	dist_default("updater disables itself if accessSync throws", async function() {
		downcast(updaterImpl).updatesEnabledInBuild = () => false;
		const upd = new ElectronUpdater(conf, notifier, crypto, electron.app, (0, import_testdouble.object)(), updaterImpl, fs);
		await updaterImpl.electronUpdater;
		dist_default(autoUpdater.on.callCount).equals(6);
		upd.start();
		dist_default(conf.setVar.callCount).equals(1);
		dist_default(conf.setVar.args).deepEquals(["showAutoUpdateOption", false]);
		dist_default(conf.removeListener.callCount).equals(0);
	});
});

//#endregion
//# sourceMappingURL=ElectronUpdaterTest-nL6QEJ0k.js.map