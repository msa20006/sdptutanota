
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { LazyLoaded, arrayEquals, assert, assertNonNull, assertNotNull, asyncFind, collectToMap, debounceStart, defer, downcast, findAndRemove, first, getFirstOrThrow, getFromMap, groupBy, identity, incrementMonth, isEmpty, isNotNull, isSameDayOfDate, isSameTypeRef, last, lastThrow, lazyMemoized, mapAndFilterNull, neverNull, noOp, ofClass, pMap, partition, partitionAsync, remove, sortableTimestamp, splitInChunks, stringToUtf8Uint8Array, throttle, tokenize, typedValues } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertMainOrNode, assertMainOrNodeBoot, getApiBaseUrl, isAndroidApp, isApp, isBrowser, isDesktop, isElectronClient, isIOSApp, isTest } from "./Env-D5xGlXfw.js";
import { getWhitelabelCustomizations } from "./WhitelabelCustomizations-D1L5qbZi.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { getCalendarLogoSvg, getMailLogoSvg, logoDefaultGrey, styles, theme, themes } from "./HtmlUtils-C-ecR7U7.js";
import { AppType, client } from "./ClientDetector-D0v6Vqu6.js";
import { ArchiveDataType, CLIENT_ONLY_CALENDARS, Const, DEFAULT_CLIENT_ONLY_CALENDAR_COLORS, FeatureType, GroupType, ImportStatus, InboxRuleType, MAX_NBR_MOVE_DELETE_MAIL_SERVICE, MailSetKind, NOTHING_INDEXED_TIMESTAMP, OperationType, SecondFactorType, SessionState, isLabel } from "./TutanotaConstants-3bwAESYA.js";
import { Icon, IconSize, progressIcon } from "./Icon-BuqNK7vz.js";
import { Icons, SecondFactorImage } from "./Icons-Dl3nFav5.js";
import { windowFacade } from "./WindowFacade-B9kSBKw7.js";
import { Autocomplete, Dialog, TextField } from "./Dialog-B6-HFvZd.js";
import { AccessBlockedError, BadRequestError, LockedError, NotAuthenticatedError, NotFoundError, PreconditionFailedError } from "./RestError-D17JEBMr.js";
import { ContactStoreError, ImportErrorCategories, MailImportError, WebauthnError } from "./ErrorUtils-o1-v67Dd.js";
import { DbError } from "./DbError-CcwZaPG2.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { PermissionError } from "./PermissionError-BGDsHuAh.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { CUSTOM_MIN_ID, GENERATED_MAX_ID, GENERATED_MIN_ID, elementIdPart, getElementId, getListId, isSameId, listIdPart } from "./EntityUtils-RQxXZlcV.js";
import { CalendarEventTypeRef, ContactTypeRef, ImportMailStateTypeRef, MailBoxTypeRef, MailFolderTypeRef, MailSetEntryTypeRef, MailTypeRef, MailboxGroupRootTypeRef, MailboxPropertiesTypeRef, createContact, createContactAddress, createContactCustomDate, createContactMailAddress, createContactMessengerHandle, createContactPhoneNumber, createContactRelationship, createContactWebsite, createMailAddressProperties, createMailboxProperties, createMoveMailData, createNewsIn } from "./TypeRefs-CR3TLWn0.js";
import { GroupInfoTypeRef, GroupTypeRef, SessionTypeRef, createSecondFactorAuthData, createU2fRegisteredDevice, createWebauthnResponseData } from "./TypeRefs-BP1jvX9p.js";
import { ProgressMonitor } from "./ProgressMonitor-HBfOF56H.js";
import { NotificationType, notifications } from "./Notifications-DLibQbV7.js";
import { EntityClient } from "./EntityClient-B0RSdk2i.js";
import { NewsService } from "./Services-DCx-CeM7.js";
import { containsEventOfType, isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { isDomainName, isRegularExpression } from "./FormatValidator-2BBermUe.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import { assertOnlyDataFiles, assertOnlyFileReferences } from "./FileUtils-W-u2-gZz.js";
import { showProgressDialog } from "./ProgressDialog-CJfJjh62.js";
import { createReferencingInstance } from "./BlobUtils-D5ADcckZ.js";
import { CALENDAR_MIME_TYPE, FileController, MAIL_MIME_TYPES, VCARD_MIME_TYPES, getEnabledMailAddressesWithUser, guiDownload, openDataFileInBrowser, zipDataFiles } from "./SharedMailUtils-AmFaSJP6.js";
import { extractStructuredAddresses, extractStructuredCustomDates, extractStructuredMailAddresses, extractStructuredMessengerHandle, extractStructuredPhoneNumbers, extractStructuredRelationships, extractStructuredWebsites } from "./ContactUtils-Bbon2oOk.js";
import { ExternalLink } from "./ExternalLink-rsCBSC7U.js";
import { showSnackBar } from "./SnackBar-CoP3lSVs.js";
import { show } from "./NotificationOverlay-C-YNCUiT.js";
import { SessionType } from "./SessionType-rxSDsswH.js";
import { deviceConfig } from "./DeviceConfig-payZM407.js";
import { isCustomizationEnabledForCustomer } from "./CustomerUtils-DmaZpb7Y.js";
import { CacheMode, WsConnectionState, bootstrapWorker, decode } from "./EntityRestClient--6dT7ZRF.js";
import { LoginButton } from "./LoginButton-DzCRy0Yt.js";
import { EphemeralUsageTestStorage, StorageBehavior, UsageTestController, UsageTestModel } from "./UsageTestModel-CjGx3RZo.js";
import { getDisplayedSender } from "./CommonMailUtils-DNufl6ib.js";
import { PermissionType$1 as PermissionType } from "./PermissionType-Bwii3hCe.js";
import { MAIL_PREFIX, throttleRoute } from "./RouteChange-im6yOAT2.js";
import { SearchCategoryTypes } from "./SearchUtils-Cu31OiTT.js";
import { PageContextLoginListener } from "./PageContextLoginListener-dgY8O-YX.js";
import { DomainConfigProvider, NoZoneDateProvider, SchedulerImpl } from "./Scheduler-B2H65_EO.js";
import { assertSystemFolderOfType, getMailHeaders } from "./MailUtils-ChhZAFAd.js";
import { FolderSystem } from "./FolderSystem-DLrUB8MO.js";
import { isMailInSpamOrTrash, isSpamOrTrashFolder } from "./MailChecks-PhVUoR7f.js";

//#region ../src/common/api/main/EventController.ts
var import_stream$7 = __toESM(require_stream(), 1);
assertMainOrNode();
const TAG = "[EventController]";
var EventController = class {
	countersStream = (0, import_stream$7.default)();
	entityListeners = new Set();
	constructor(logins) {
		this.logins = logins;
	}
	addEntityListener(listener) {
		if (this.entityListeners.has(listener)) console.warn(TAG, "Adding the same listener twice!");
else this.entityListeners.add(listener);
	}
	removeEntityListener(listener) {
		const wasRemoved = this.entityListeners.delete(listener);
		if (!wasRemoved) console.warn(TAG, "Could not remove listener, possible leak?", listener);
	}
	getCountersStream() {
		return this.countersStream.map(identity);
	}
	async onEntityUpdateReceived(entityUpdates, eventOwnerGroupId) {
		let loginsUpdates = Promise.resolve();
		if (this.logins.isUserLoggedIn()) loginsUpdates = this.logins.getUserController().entityEventsReceived(entityUpdates, eventOwnerGroupId);
		return loginsUpdates.then(async () => {
			for (const listener of this.entityListeners) {
				let entityUpdatesData = downcast(entityUpdates);
				await listener(entityUpdatesData, eventOwnerGroupId);
			}
		}).then(noOp);
	}
	async onCountersUpdateReceived(update) {
		this.countersStream(update);
	}
};

//#endregion
//#region ../src/mail-app/search/model/SearchModel.ts
var import_stream$6 = __toESM(require_stream(), 1);
assertMainOrNode();
var SearchModel = class {
	result;
	indexState;
	lastQueryString;
	indexingSupported;
	_searchFacade;
	lastQuery;
	lastSearchPromise;
	cancelSignal;
	constructor(searchFacade, calendarModel) {
		this.calendarModel = calendarModel;
		this._searchFacade = searchFacade;
		this.result = (0, import_stream$6.default)();
		this.lastQueryString = (0, import_stream$6.default)("");
		this.indexingSupported = true;
		this.indexState = (0, import_stream$6.default)({
			initializing: true,
			mailIndexEnabled: false,
			progress: 0,
			currentMailIndexTimestamp: NOTHING_INDEXED_TIMESTAMP,
			aimedMailIndexTimestamp: NOTHING_INDEXED_TIMESTAMP,
			indexedMailCount: 0,
			failedIndexingUpTo: null
		});
		this.lastQuery = null;
		this.lastSearchPromise = Promise.resolve();
		this.cancelSignal = (0, import_stream$6.default)(false);
	}
	async search(searchQuery, progressTracker) {
		if (this.lastQuery && searchQueryEquals(searchQuery, this.lastQuery)) return this.lastSearchPromise;
		this.lastQuery = searchQuery;
		const { query, restriction, minSuggestionCount, maxResults } = searchQuery;
		this.lastQueryString(query);
		let result = this.result();
		if (result && !isSameTypeRef(restriction.type, result.restriction.type)) this.result(null);
else if (this.indexState().progress > 0 && result && isSameTypeRef(MailTypeRef, result.restriction.type)) this.result(null);
		if (query.trim() === "") {
			const result$1 = {
				query,
				restriction,
				results: [],
				currentIndexTimestamp: this.indexState().currentMailIndexTimestamp,
				lastReadSearchIndexRow: [],
				maxResults: 0,
				matchWordOrder: false,
				moreResults: [],
				moreResultsEntries: []
			};
			this.result(result$1);
			this.lastSearchPromise = Promise.resolve(result$1);
		} else if (isSameTypeRef(CalendarEventTypeRef, restriction.type)) {
			let currentDate = new Date(assertNotNull(restriction.start));
			const endDate = new Date(assertNotNull(restriction.end));
			const calendarModel = await this.calendarModel();
			const daysInMonths = [];
			while (currentDate.getTime() <= endDate.getTime()) {
				daysInMonths.push(currentDate);
				currentDate = incrementMonth(currentDate, 1);
			}
			const calendarResult = {
				currentIndexTimestamp: 0,
				moreResults: [],
				moreResultsEntries: [],
				lastReadSearchIndexRow: [],
				matchWordOrder: false,
				restriction,
				results: [],
				query
			};
			const monitorHandle = progressTracker.registerMonitorSync(daysInMonths.length);
			const monitor = assertNotNull(progressTracker.getMonitor(monitorHandle));
			if (this.cancelSignal()) {
				this.result(calendarResult);
				this.lastSearchPromise = Promise.resolve(calendarResult);
				return this.lastSearchPromise;
			}
			const hasNewPaidPlan = await calendarModel.canLoadBirthdaysCalendar();
			if (hasNewPaidPlan) await calendarModel.loadContactsBirthdays();
			await calendarModel.loadMonthsIfNeeded(daysInMonths, monitor, this.cancelSignal);
			monitor.completed();
			const eventsForDays = calendarModel.getEventsForMonths()();
			assertNonNull(restriction.start);
			assertNonNull(restriction.end);
			const tokens = tokenize(query.trim());
			const alreadyAdded = new Set();
			if (this.cancelSignal()) {
				this.result(calendarResult);
				this.lastSearchPromise = Promise.resolve(calendarResult);
				return this.lastSearchPromise;
			}
			const followCommonRestrictions = (key, event) => {
				if (alreadyAdded.has(key)) return false;
				if (restriction.folderIds.length > 0 && !restriction.folderIds.includes(listIdPart(event._id))) return false;
				if (restriction.eventSeries === false && event.repeatRule != null) return false;
				for (const token of tokens) if (event.summary.toLowerCase().includes(token)) {
					alreadyAdded.add(key);
					calendarResult.results.push(event._id);
					return false;
				}
				return true;
			};
			if (tokens.length > 0) {
				for (const [startOfDay, eventsOnDay] of eventsForDays) eventLoop: for (const event of eventsOnDay) {
					if (!(startOfDay >= restriction.start && startOfDay <= restriction.end)) continue;
					const key = idToKey(event._id);
					if (!followCommonRestrictions(key, event)) continue;
					for (const token of tokens) if (event.summary.toLowerCase().includes(token)) {
						alreadyAdded.add(key);
						calendarResult.results.push(event._id);
						continue eventLoop;
					}
					const descriptionToSearch = event.description.replaceAll(/(<[^>]+>)/gi, " ").toLowerCase();
					for (const token of tokens) if (descriptionToSearch.includes(token)) {
						alreadyAdded.add(key);
						calendarResult.results.push(event._id);
						continue eventLoop;
					}
					if (this.cancelSignal()) {
						this.result(calendarResult);
						this.lastSearchPromise = Promise.resolve(calendarResult);
						return this.lastSearchPromise;
					}
				}
				const startDate = new Date(restriction.start);
				const endDate$1 = new Date(restriction.end);
				if (hasNewPaidPlan) {
					const birthdayEvents = Array.from(calendarModel.getBirthdayEvents().values()).flat();
					eventLoop: for (const eventRegistry of birthdayEvents) {
						const month = eventRegistry.event.startTime.getMonth();
						if (!(month >= startDate.getMonth() && month <= endDate$1.getMonth())) continue;
						const key = idToKey(eventRegistry.event._id);
						if (!followCommonRestrictions(key, eventRegistry.event)) continue;
						for (const token of tokens) if (eventRegistry.event.summary.toLowerCase().includes(token)) {
							alreadyAdded.add(key);
							calendarResult.results.push(eventRegistry.event._id);
							continue eventLoop;
						}
						if (this.cancelSignal()) {
							this.result(calendarResult);
							this.lastSearchPromise = Promise.resolve(calendarResult);
							return this.lastSearchPromise;
						}
					}
				}
			}
			this.result(calendarResult);
			this.lastSearchPromise = Promise.resolve(calendarResult);
		} else this.lastSearchPromise = this._searchFacade.search(query, restriction, minSuggestionCount, maxResults ?? undefined).then((result$1) => {
			this.result(result$1);
			return result$1;
		}).catch(ofClass(DbError, (e) => {
			console.log("DBError while search", e);
			throw e;
		}));
		return this.lastSearchPromise;
	}
	isNewSearch(query, restriction) {
		let isNew = false;
		let lastQuery = this.lastQuery;
		if (lastQuery == null) isNew = true;
else if (lastQuery.query !== query) isNew = true;
else if (lastQuery.restriction !== restriction) isNew = !isSameSearchRestriction(restriction, lastQuery.restriction);
		if (isNew) this.sendCancelSignal();
		return isNew;
	}
	sendCancelSignal() {
		this.cancelSignal(true);
		this.cancelSignal.end(true);
		this.cancelSignal = (0, import_stream$6.default)(false);
	}
};
function idToKey(id) {
	return id.join("/");
}
function searchQueryEquals(a, b) {
	return a.query === b.query && isSameSearchRestriction(a.restriction, b.restriction) && a.minSuggestionCount === b.minSuggestionCount && a.maxResults === b.maxResults;
}
function isSameSearchRestriction(a, b) {
	const isSameAttributeIds = a.attributeIds === b.attributeIds || !!a.attributeIds && !!b.attributeIds && arrayEquals(a.attributeIds, b.attributeIds);
	return isSameTypeRef(a.type, b.type) && a.start === b.start && a.end === b.end && a.field === b.field && isSameAttributeIds && (a.eventSeries === b.eventSeries || a.eventSeries === null && b.eventSeries === true || a.eventSeries === true && b.eventSeries === null) && arrayEquals(a.folderIds, b.folderIds);
}
function areResultsForTheSameQuery(a, b) {
	return a.query === b.query && isSameSearchRestriction(a.restriction, b.restriction);
}
function hasMoreResults(searchResult) {
	return searchResult.moreResults.length > 0 || searchResult.lastReadSearchIndexRow.length > 0 && searchResult.lastReadSearchIndexRow.every(([word, id]) => id !== 0);
}

//#endregion
//#region ../src/common/mailFunctionality/MailboxModel.ts
var import_stream$5 = __toESM(require_stream(), 1);
var MailboxModel = class {
	/** Empty stream until init() is finished, exposed mostly for map()-ing, use getMailboxDetails to get a promise */
	mailboxDetails = (0, import_stream$5.default)();
	initialization = null;
	/**
	* Map from MailboxGroupRoot id to MailboxProperties
	* A way to avoid race conditions in case we try to create mailbox properties from multiple places.
	*
	*/
	mailboxPropertiesPromises = new Map();
	constructor(eventController, entityClient, logins) {
		this.eventController = eventController;
		this.entityClient = entityClient;
		this.logins = logins;
	}
	initListeners = lazyMemoized(() => {
		this.eventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId));
	});
	init() {
		if (this.initialization) return this.initialization;
		this.initListeners();
		return this._init();
	}
	_init() {
		const mailGroupMemberships = this.logins.getUserController().getMailGroupMemberships();
		const mailBoxDetailsPromises = mailGroupMemberships.map((m) => this.mailboxDetailsFromMembership(m));
		this.initialization = Promise.all(mailBoxDetailsPromises).then((details) => {
			this.mailboxDetails(details);
		});
		return this.initialization.catch((e) => {
			console.warn("mailbox model initialization failed!", e);
			this.initialization = null;
			throw e;
		});
	}
	/**
	* load mailbox details from a mailgroup membership
	*/
	async mailboxDetailsFromMembership(membership) {
		const [mailboxGroupRoot, mailGroupInfo, mailGroup] = await Promise.all([
			this.entityClient.load(MailboxGroupRootTypeRef, membership.group),
			this.entityClient.load(GroupInfoTypeRef, membership.groupInfo),
			this.entityClient.load(GroupTypeRef, membership.group)
		]);
		const mailbox = await this.entityClient.load(MailBoxTypeRef, mailboxGroupRoot.mailbox);
		return {
			mailbox,
			mailGroupInfo,
			mailGroup,
			mailboxGroupRoot
		};
	}
	/**
	* Get the list of MailboxDetails that this user has access to from their memberships.
	*
	* Will wait for successful initialization.
	*/
	async getMailboxDetails() {
		if (this.mailboxDetails()) return this.mailboxDetails();
else return new Promise((resolve) => {
			this.init();
			const end = this.mailboxDetails.map((details) => {
				resolve(details);
				end.end(true);
			});
		});
	}
	async getMailboxDetailByMailboxId(mailboxId) {
		const allDetails = await this.getMailboxDetails();
		return allDetails.find((detail) => isSameId(detail.mailbox._id, mailboxId)) ?? null;
	}
	async getMailboxDetailsForMailGroup(mailGroupId) {
		const mailboxDetails = await this.getMailboxDetails();
		return assertNotNull(mailboxDetails.find((md) => mailGroupId === md.mailGroup._id), "Mailbox detail for mail group does not exist");
	}
	async getUserMailboxDetails() {
		const userMailGroupMembership = this.logins.getUserController().getUserMailGroupMembership();
		const mailboxDetails = await this.getMailboxDetails();
		return assertNotNull(mailboxDetails.find((md) => md.mailGroup._id === userMailGroupMembership.group), "Mailbox detail for user does not exist");
	}
	async entityEventsReceived(updates, eventOwnerGroupId) {
		for (const update of updates) if (isUpdateForTypeRef(GroupInfoTypeRef, update)) {
			if (update.operation === OperationType.UPDATE) {
				await this._init();
				mithril_default.redraw();
			}
		} else if (this.logins.getUserController().isUpdateForLoggedInUserInstance(update, eventOwnerGroupId)) {
			let newMemberships = this.logins.getUserController().getMailGroupMemberships();
			const mailboxDetails = await this.getMailboxDetails();
			if (newMemberships.length !== mailboxDetails.length) {
				await this._init();
				mithril_default.redraw();
			}
		}
	}
	async getMailboxProperties(mailboxGroupRoot) {
		const existingPromise = this.mailboxPropertiesPromises.get(mailboxGroupRoot._id);
		if (existingPromise) return existingPromise;
		const promise = this.loadOrCreateMailboxProperties(mailboxGroupRoot);
		this.mailboxPropertiesPromises.set(mailboxGroupRoot._id, promise);
		return promise.finally(() => this.mailboxPropertiesPromises.delete(mailboxGroupRoot._id));
	}
	async loadOrCreateMailboxProperties(mailboxGroupRoot) {
		if (!mailboxGroupRoot.mailboxProperties) mailboxGroupRoot.mailboxProperties = await this.entityClient.setup(null, createMailboxProperties({
			_ownerGroup: mailboxGroupRoot._ownerGroup ?? "",
			reportMovedMails: "0",
			mailAddressProperties: []
		})).catch(ofClass(PreconditionFailedError, (e) => {
			if (e.data && e.data.startsWith("exists:")) {
				const existingId = e.data.substring("exists:".length);
				console.log("mailboxProperties already exists", existingId);
				return existingId;
			} else throw new ProgrammingError(`Could not create mailboxProperties, precondition: ${e.data}`);
		}));
		const mailboxProperties = await this.entityClient.load(MailboxPropertiesTypeRef, mailboxGroupRoot.mailboxProperties);
		if (mailboxProperties.mailAddressProperties.length === 0) await this.migrateFromOldSenderName(mailboxGroupRoot, mailboxProperties);
		return mailboxProperties;
	}
	/** If there was no sender name configured before take the user's name and assign it to all email addresses. */
	async migrateFromOldSenderName(mailboxGroupRoot, mailboxProperties) {
		const userGroupInfo = this.logins.getUserController().userGroupInfo;
		const legacySenderName = userGroupInfo.name;
		const mailboxDetails = await this.getMailboxDetailsForMailGroup(mailboxGroupRoot._id);
		const mailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, userGroupInfo);
		for (const mailAddress of mailAddresses) mailboxProperties.mailAddressProperties.push(createMailAddressProperties({
			mailAddress,
			senderName: legacySenderName
		}));
		await this.entityClient.update(mailboxProperties);
	}
};

//#endregion
//#region ../src/mail-app/mail/model/MinimizedMailEditorViewModel.ts
let SaveStatusEnum = function(SaveStatusEnum$1) {
	SaveStatusEnum$1[SaveStatusEnum$1["Saving"] = 0] = "Saving";
	SaveStatusEnum$1[SaveStatusEnum$1["Saved"] = 1] = "Saved";
	SaveStatusEnum$1[SaveStatusEnum$1["NotSaved"] = 2] = "NotSaved";
	return SaveStatusEnum$1;
}({});
let SaveErrorReason = function(SaveErrorReason$1) {
	SaveErrorReason$1[SaveErrorReason$1["Unknown"] = 0] = "Unknown";
	SaveErrorReason$1[SaveErrorReason$1["ConnectionLost"] = 1] = "ConnectionLost";
	return SaveErrorReason$1;
}({});
var MinimizedMailEditorViewModel = class {
	_minimizedEditors;
	constructor() {
		this._minimizedEditors = [];
	}
	minimizeMailEditor(dialog, sendMailModel, dispose, saveStatus, closeOverlayFunction) {
		dialog.close();
		if (!this._minimizedEditors.some((editor) => editor.dialog === dialog)) this._minimizedEditors.push({
			sendMailModel,
			dialog,
			dispose,
			saveStatus,
			closeOverlayFunction
		});
		return lastThrow(this._minimizedEditors);
	}
	reopenMinimizedEditor(editor) {
		editor.closeOverlayFunction();
		editor.dialog.show();
		remove(this._minimizedEditors, editor);
	}
	removeMinimizedEditor(editor) {
		editor.closeOverlayFunction();
		editor.dispose();
		remove(this._minimizedEditors, editor);
	}
	getMinimizedEditors() {
		return this._minimizedEditors;
	}
	getEditorForDraft(mail) {
		return this.getMinimizedEditors().find((e) => {
			const draft = e.sendMailModel.getDraft();
			return draft ? isSameId(draft._id, mail._id) : null;
		}) ?? null;
	}
};

//#endregion
//#region ../src/common/api/main/ProgressTracker.ts
var import_stream$4 = __toESM(require_stream(), 1);
var ProgressTracker = class {
	onProgressUpdate;
	monitors;
	idCounter;
	constructor() {
		this.onProgressUpdate = (0, import_stream$4.default)(1);
		this.monitors = new Map();
		this.idCounter = 0;
	}
	/**
	* Register a monitor with the tracker, so that it's progress can be displayed
	* Returns an ID as a handle, useful for making calls from the worker
	*
	* Make sure that monitor completes, so it can be unregistered.
	* @param work - total work to do
	*/
	registerMonitorSync(work) {
		const id = this.idCounter++;
		const monitor = new ProgressMonitor(work, (percentage) => this.onProgress(id, percentage));
		this.monitors.set(id, monitor);
		return id;
	}
	/** async wrapper for remote */
	async registerMonitor(work) {
		return this.registerMonitorSync(work);
	}
	async workDoneForMonitor(id, amount) {
		this.getMonitor(id)?.workDone(amount);
	}
	getMonitor(id) {
		return this.monitors.get(id) ?? null;
	}
	onProgress(id, percentage) {
		this.onProgressUpdate(this.completedAmount());
		if (percentage >= 100) this.monitors.delete(id);
	}
	/**
	* Total work that will be done from all monitors
	*/
	totalWork() {
		let total = 0;
		for (const monitor of this.monitors.values()) total += monitor.totalWork;
		return total;
	}
	/**
	* Current absolute amount of completed work from all monitors
	*/
	completedWork() {
		let total = 0;
		for (const monitor of this.monitors.values()) total += monitor.workCompleted;
		return total;
	}
	/**
	* Completed percentage of completed work as a number between 0 and 1
	*/
	completedAmount() {
		const totalWork = this.totalWork();
		const completedWork = this.completedWork();
		return totalWork !== 0 ? Math.min(1, completedWork / totalWork) : 1;
	}
};

//#endregion
//#region ../src/common/misc/2fa/SecondFactorAuthView.ts
var SecondFactorAuthView = class {
	view(vnode) {
		const { attrs } = vnode;
		return mithril_default(".flex.col", [
			mithril_default("p.center", [lang.get(attrs.webauthn?.canLogin || attrs.otp ? "secondFactorPending_msg" : "secondFactorPendingOtherClientOnly_msg")]),
			this.renderWebauthn(vnode.attrs),
			this._renderOtp(vnode.attrs),
			this._renderRecover(vnode.attrs)
		]);
	}
	_renderOtp(attrs) {
		const { otp } = attrs;
		if (!otp) return null;
		return mithril_default(".left.mb", mithril_default(TextField, {
			label: "totpCode_label",
			value: otp.codeFieldValue,
			autocompleteAs: Autocomplete.oneTimeCode,
			oninput: (value) => otp.onValueChanged(value.trim()),
			injectionsRight: () => otp.inProgress ? mithril_default(".mr-s", progressIcon()) : null
		}));
	}
	renderWebauthn(attrs) {
		const { webauthn } = attrs;
		if (!webauthn) return null;
		if (webauthn.canLogin) return this.renderWebauthnLogin(webauthn);
else return this._renderOtherDomainLogin(webauthn);
	}
	renderWebauthnLogin(webauthn) {
		let items;
		const { state } = webauthn;
		const doWebAuthnButton = mithril_default(LoginButton, {
			label: "useSecurityKey_action",
			onclick: () => webauthn.doWebauthn()
		});
		switch (state.state) {
			case "init":
				items = [mithril_default(".align-self-center", doWebAuthnButton)];
				break;
			case "progress":
				items = [mithril_default(".flex.justify-center", [mithril_default(".mr-s", progressIcon()), mithril_default("", lang.get("waitingForU2f_msg"))])];
				break;
			case "error":
				items = [mithril_default(".flex.col.items-center", [mithril_default(".flex.items-center", [mithril_default(".mr-s", mithril_default(Icon, {
					icon: Icons.Cancel,
					size: IconSize.Medium,
					style: { fill: theme.content_accent }
				})), mithril_default("", lang.get(state.error))]), doWebAuthnButton])];
				break;
			default: throw new Error();
		}
		return [mithril_default(".flex-center", mithril_default("img", { src: SecondFactorImage })), mithril_default(".mt.flex.col", items)];
	}
	_renderOtherDomainLogin({ otherDomainLoginUrl }) {
		const hostname = new URL(otherDomainLoginUrl).hostname;
		return [
			lang.get("differentSecurityKeyDomain_msg", { "{domain}": hostname }),
			mithril_default("br"),
			mithril_default(ExternalLink, {
				href: otherDomainLoginUrl,
				text: hostname,
				class: "text-center",
				isCompanySite: false
			})
		];
	}
	_renderRecover(attrs) {
		const { onRecover } = attrs;
		if (onRecover == null) return null;
		return mithril_default(".small.text-center.pt", [mithril_default(`a[href=#]`, { onclick: (e) => {
			onRecover();
			e.preventDefault();
		} }, lang.get("recoverAccountAccess_action"))]);
	}
};

//#endregion
//#region ../src/common/misc/2fa/SecondFactorUtils.ts
function appIdToLoginUrl(appId, domainConfigProvider) {
	if (appId === Const.WEBAUTHN_RP_ID) return webauthnUrlToLoginUrl(domainConfigProvider.getCurrentDomainConfig().webauthnUrl);
else if (appId === Const.LEGACY_WEBAUTHN_RP_ID) return webauthnUrlToLoginUrl(domainConfigProvider.getCurrentDomainConfig().legacyWebauthnUrl);
	const parts = (appId.endsWith(".json") ? new URL(appId).hostname : appId).split(":");
	const domain = parts[0];
	const port = parts[1];
	const domainConfig = domainConfigProvider.getDomainConfigForHostname(domain, "https:", port);
	return webauthnUrlToLoginUrl(domainConfig.webauthnUrl);
}
function webauthnUrlToLoginUrl(webauthnUrl) {
	const url = new URL(webauthnUrl);
	url.pathname = "";
	return url.toString();
}

//#endregion
//#region ../src/common/misc/2fa/SecondFactorAuthDialog.ts
var SecondFactorAuthDialog = class SecondFactorAuthDialog {
	waitingForSecondFactorDialog = null;
	webauthnState = { state: "init" };
	otpState = {
		code: "",
		inProgress: false
	};
	/** @private */
	constructor(webauthnClient, loginFacade, domainConfigProvider, authData, onClose) {
		this.webauthnClient = webauthnClient;
		this.loginFacade = loginFacade;
		this.domainConfigProvider = domainConfigProvider;
		this.authData = authData;
		this.onClose = onClose;
	}
	/**
	* @param onClose will be called when the dialog is closed (one way or another).
	*/
	static show(webauthnClient, loginFacade, domainConfigProvider, authData, onClose) {
		const dialog = new SecondFactorAuthDialog(webauthnClient, loginFacade, domainConfigProvider, authData, onClose);
		dialog.show();
		return dialog;
	}
	close() {
		if (this.waitingForSecondFactorDialog?.visible) this.waitingForSecondFactorDialog?.close();
		this.webauthnClient.abortCurrentOperation();
		this.waitingForSecondFactorDialog = null;
		this.onClose();
	}
	async show() {
		const u2fChallenge = this.authData.challenges.find((challenge) => challenge.type === SecondFactorType.u2f || challenge.type === SecondFactorType.webauthn);
		const otpChallenge = this.authData.challenges.find((challenge) => challenge.type === SecondFactorType.totp);
		const u2fSupported = await this.webauthnClient.isSupported();
		console.log("webauthn supported: ", u2fSupported);
		let canLoginWithU2f;
		let otherDomainLoginUrl;
		if (u2fChallenge?.u2f != null && u2fSupported) {
			const { canAttempt, cannotAttempt } = await this.webauthnClient.canAttemptChallenge(u2fChallenge.u2f);
			canLoginWithU2f = canAttempt.length !== 0;
			if (cannotAttempt.length > 0) {
				const loginUrlString = appIdToLoginUrl(getFirstOrThrow(cannotAttempt).appId, this.domainConfigProvider);
				const loginUrl = new URL(loginUrlString);
				loginUrl.searchParams.set("noAutoLogin", "true");
				otherDomainLoginUrl = loginUrl.toString();
			} else otherDomainLoginUrl = null;
		} else {
			canLoginWithU2f = false;
			otherDomainLoginUrl = null;
		}
		const { mailAddress } = this.authData;
		this.waitingForSecondFactorDialog = Dialog.showActionDialog({
			title: "emptyString_msg",
			allowOkWithReturn: true,
			child: { view: () => {
				return mithril_default(SecondFactorAuthView, {
					webauthn: canLoginWithU2f ? {
						canLogin: true,
						state: this.webauthnState,
						doWebauthn: () => this.doWebauthn(assertNotNull(u2fChallenge))
					} : otherDomainLoginUrl ? {
						canLogin: false,
						otherDomainLoginUrl
					} : null,
					otp: otpChallenge ? {
						codeFieldValue: this.otpState.code,
						inProgress: this.otpState.inProgress,
						onValueChanged: (newValue) => this.otpState.code = newValue
					} : null,
					onRecover: mailAddress ? () => this.recoverLogin(mailAddress) : null
				});
			} },
			okAction: otpChallenge ? () => this.onConfirmOtp() : null,
			cancelAction: () => this.cancel()
		});
	}
	async onConfirmOtp() {
		this.otpState.inProgress = true;
		const authData = createSecondFactorAuthData({
			type: SecondFactorType.totp,
			session: this.authData.sessionId,
			otpCode: this.otpState.code.replace(/ /g, ""),
			u2f: null,
			webauthn: null
		});
		try {
			await this.loginFacade.authenticateWithSecondFactor(authData);
			this.waitingForSecondFactorDialog?.close();
		} catch (e) {
			if (e instanceof NotAuthenticatedError) Dialog.message("loginFailed_msg");
else if (e instanceof BadRequestError) Dialog.message("loginFailed_msg");
else if (e in AccessBlockedError) {
				Dialog.message("loginFailedOften_msg");
				this.close();
			} else throw e;
		} finally {
			this.otpState.inProgress = false;
		}
	}
	async cancel() {
		this.webauthnClient.abortCurrentOperation();
		await this.loginFacade.cancelCreateSession(this.authData.sessionId);
		this.close();
	}
	async doWebauthn(u2fChallenge) {
		this.webauthnState = { state: "progress" };
		const sessionId = this.authData.sessionId;
		const challenge = assertNotNull(u2fChallenge.u2f);
		try {
			const { responseData, apiBaseUrl } = await this.webauthnClient.authenticate(challenge);
			const authData = createSecondFactorAuthData({
				type: SecondFactorType.webauthn,
				session: sessionId,
				webauthn: responseData,
				u2f: null,
				otpCode: null
			});
			await this.loginFacade.authenticateWithSecondFactor(authData, apiBaseUrl);
		} catch (e) {
			if (e instanceof CancelledError) this.webauthnState = { state: "init" };
else if (e instanceof AccessBlockedError && this.waitingForSecondFactorDialog?.visible) {
				Dialog.message("loginFailedOften_msg");
				this.close();
			} else if (e instanceof WebauthnError) {
				console.log("Error during webAuthn: ", e);
				this.webauthnState = {
					state: "error",
					error: "couldNotAuthU2f_msg"
				};
			} else if (e instanceof LockedError) {
				this.webauthnState = { state: "init" };
				Dialog.message("serviceUnavailable_msg");
			} else if (e instanceof NotAuthenticatedError) {
				this.webauthnState = { state: "init" };
				Dialog.message("loginFailed_msg");
			} else throw e;
		} finally {
			mithril_default.redraw();
		}
	}
	async recoverLogin(mailAddress) {
		this.cancel();
		const dialog = await import("./RecoverLoginDialog-BoZwr80p.js");
		dialog.show(mailAddress, "secondFactor");
	}
};

//#endregion
//#region ../src/common/misc/2fa/SecondFactorHandler.ts
assertMainOrNode();
var SecondFactorHandler = class {
	otherLoginSessionId = null;
	otherLoginDialog = null;
	otherLoginListenerInitialized = false;
	waitingForSecondFactorDialog = null;
	constructor(eventController, entityClient, webauthnClient, loginFacade, domainConfigProvider) {
		this.eventController = eventController;
		this.entityClient = entityClient;
		this.webauthnClient = webauthnClient;
		this.loginFacade = loginFacade;
		this.domainConfigProvider = domainConfigProvider;
	}
	setupAcceptOtherClientLoginListener() {
		if (this.otherLoginListenerInitialized) return;
		this.otherLoginListenerInitialized = true;
		this.eventController.addEntityListener((updates) => this.entityEventsReceived(updates));
	}
	async entityEventsReceived(updates) {
		for (const update of updates) {
			const sessionId = [neverNull(update.instanceListId), update.instanceId];
			if (isUpdateForTypeRef(SessionTypeRef, update)) {
				if (update.operation === OperationType.CREATE) {
					let session;
					try {
						session = await this.entityClient.load(SessionTypeRef, sessionId);
					} catch (e) {
						if (e instanceof NotFoundError) console.log("Failed to load session", e);
else throw e;
						continue;
					}
					if (session.state === SessionState.SESSION_STATE_PENDING) {
						if (this.otherLoginDialog != null) this.otherLoginDialog.close();
						this.otherLoginSessionId = session._id;
						this.showConfirmLoginDialog(session);
					}
				} else if (update.operation === OperationType.UPDATE && this.otherLoginSessionId && isSameId(this.otherLoginSessionId, sessionId)) {
					let session;
					try {
						session = await this.entityClient.load(SessionTypeRef, sessionId);
					} catch (e) {
						if (e instanceof NotFoundError) console.log("Failed to load session", e);
else throw e;
						continue;
					}
					if (session.state !== SessionState.SESSION_STATE_PENDING && this.otherLoginDialog && isSameId(neverNull(this.otherLoginSessionId), sessionId)) {
						this.otherLoginDialog.close();
						this.otherLoginSessionId = null;
						this.otherLoginDialog = null;
					}
				} else if (update.operation === OperationType.DELETE && this.otherLoginSessionId && isSameId(this.otherLoginSessionId, sessionId)) {
					if (this.otherLoginDialog) {
						this.otherLoginDialog.close();
						this.otherLoginSessionId = null;
						this.otherLoginDialog = null;
					}
				}
			}
		}
	}
	showConfirmLoginDialog(session) {
		let text;
		if (session.loginIpAddress) text = lang.get("secondFactorConfirmLogin_msg", {
			"{clientIdentifier}": session.clientIdentifier,
			"{ipAddress}": session.loginIpAddress
		});
else text = lang.get("secondFactorConfirmLoginNoIp_msg", { "{clientIdentifier}": session.clientIdentifier });
		this.otherLoginDialog = Dialog.showActionDialog({
			title: "secondFactorConfirmLogin_label",
			child: { view: () => mithril_default(".text-break.pt", text) },
			okAction: async () => {
				await this.loginFacade.authenticateWithSecondFactor(createSecondFactorAuthData({
					session: session._id,
					type: null,
					otpCode: null,
					u2f: null,
					webauthn: null
				}));
				if (this.otherLoginDialog) {
					this.otherLoginDialog.close();
					this.otherLoginSessionId = null;
					this.otherLoginDialog = null;
				}
			}
		});
		let sessionId = session._id;
		setTimeout(() => {
			if (this.otherLoginDialog && isSameId(neverNull(this.otherLoginSessionId), sessionId)) {
				this.otherLoginDialog.close();
				this.otherLoginSessionId = null;
				this.otherLoginDialog = null;
			}
		}, 6e4);
	}
	closeWaitingForSecondFactorDialog() {
		this.waitingForSecondFactorDialog?.close();
		this.waitingForSecondFactorDialog = null;
	}
	/**
	* @inheritDoc
	*/
	async showSecondFactorAuthenticationDialog(sessionId, challenges, mailAddress) {
		if (this.waitingForSecondFactorDialog) return;
		this.waitingForSecondFactorDialog = SecondFactorAuthDialog.show(this.webauthnClient, this.loginFacade, this.domainConfigProvider, {
			sessionId,
			challenges,
			mailAddress
		}, () => {
			this.waitingForSecondFactorDialog = null;
		});
	}
};

//#endregion
//#region ../src/common/misc/2fa/webauthn/WebauthnClient.ts
var WebauthnClient = class {
	constructor(webauthn, domainConfigProvider, isApp$1) {
		this.webauthn = webauthn;
		this.domainConfigProvider = domainConfigProvider;
		this.isApp = isApp$1;
	}
	isSupported() {
		return this.webauthn.isSupported();
	}
	/** Whether it's possible to attempt a challenge. It might not be possible if there are not keys for this domain. */
	async canAttemptChallenge(challenge) {
		const [canAttempt, cannotAttempt] = await partitionAsync(challenge.keys, async (k) => await this.webauthn.canAttemptChallengeForRpId(k.appId) || await this.webauthn.canAttemptChallengeForU2FAppId(k.appId));
		return {
			canAttempt,
			cannotAttempt
		};
	}
	async register(userId, displayName) {
		const challenge = this.getChallenge();
		const name = `userId="${userId}"`;
		const registrationResult = await this.webauthn.register({
			challenge,
			userId,
			name,
			displayName,
			domain: this.selectRegistrationUrl()
		});
		const attestationObject = this.parseAttestationObject(registrationResult.attestationObject);
		const publicKey = this.parsePublicKey(downcast(attestationObject).authData);
		return createU2fRegisteredDevice({
			keyHandle: new Uint8Array(registrationResult.rawId),
			appId: registrationResult.rpId,
			publicKey: this.serializePublicKey(publicKey),
			compromised: false,
			counter: "-1"
		});
	}
	selectRegistrationUrl() {
		const domainConfig = this.domainConfigProvider.getCurrentDomainConfig();
		return this.getWebauthnUrl(domainConfig, "new");
	}
	/**
	* Attempt to complete Webauthn challenge (the local part, signing of the data).
	* U2fChallenge might have multiple keys for different domains and this method takes care of picking the one we can attempt to solve.
	* @return responseData to send to the server and base api url which should be contacted in order to finish the challenge
	* @throws CancelledError
	* @throws WebauthnError
	*/
	async authenticate(challenge) {
		const allowedKeys = challenge.keys.map((key) => {
			return { id: key.keyHandle };
		});
		const authenticationUrl = this.selectAuthenticationUrl(challenge);
		const signResult = await this.webauthn.sign({
			challenge: challenge.challenge,
			keys: allowedKeys,
			domain: authenticationUrl
		});
		const responseData = createWebauthnResponseData({
			keyHandle: new Uint8Array(signResult.rawId),
			clientData: new Uint8Array(signResult.clientDataJSON),
			signature: new Uint8Array(signResult.signature),
			authenticatorData: new Uint8Array(signResult.authenticatorData)
		});
		const authUrlObject = new URL(authenticationUrl);
		const domainConfig = this.domainConfigProvider.getDomainConfigForHostname(authUrlObject.hostname, authUrlObject.protocol, authUrlObject.port);
		const apiUrl = getApiBaseUrl(domainConfig);
		return {
			responseData,
			apiBaseUrl: apiUrl
		};
	}
	abortCurrentOperation() {
		return this.webauthn.abortCurrentOperation();
	}
	selectAuthenticationUrl(challenge) {
		const domainConfig = this.domainConfigProvider.getCurrentDomainConfig();
		if (challenge.keys.some((k) => k.appId === Const.WEBAUTHN_RP_ID)) return this.getWebauthnUrl(domainConfig, "new");
else if (challenge.keys.some((k) => k.appId === Const.LEGACY_WEBAUTHN_RP_ID)) return this.getWebauthnUrl(domainConfig, "legacy");
else {
			const webauthnKey = challenge.keys.find((k) => !this.isLegacyU2fKey(k));
			if (webauthnKey) {
				const domainConfigForHostname = this.domainConfigProvider.getDomainConfigForHostname(webauthnKey.appId, "https:");
				return this.getWebauthnUrl(domainConfigForHostname, "new");
			} else if (challenge.keys.some((k) => k.appId === Const.U2F_LEGACY_APPID)) return this.getWebauthnUrl(domainConfig, "legacy");
else {
				const keyToUse = getFirstOrThrow(challenge.keys);
				const keyUrl = new URL(keyToUse.appId);
				const domainConfigForHostname = this.domainConfigProvider.getDomainConfigForHostname(keyUrl.hostname, keyUrl.protocol, keyUrl.port);
				return this.getWebauthnUrl(domainConfigForHostname, "new");
			}
		}
	}
	getWebauthnUrl(domainConfig, type) {
		if (type === "legacy") return this.isApp ? domainConfig.legacyWebauthnMobileUrl : domainConfig.legacyWebauthnUrl;
else return this.isApp ? domainConfig.webauthnMobileUrl : domainConfig.webauthnUrl;
	}
	isLegacyU2fKey(key) {
		return key.appId.endsWith(Const.U2f_APPID_SUFFIX);
	}
	getChallenge() {
		const random = new Uint8Array(32);
		crypto.getRandomValues(random);
		return random;
	}
	parseAttestationObject(raw) {
		return decode(new Uint8Array(raw));
	}
	parsePublicKey(authData) {
		const dataView = new DataView(new ArrayBuffer(2));
		const idLenBytes = authData.slice(53, 55);
		for (const [index, value] of idLenBytes.entries()) dataView.setUint8(index, value);
		const credentialIdLength = dataView.getUint16(0);
		const publicKeyBytes = authData.slice(55 + credentialIdLength);
		return decode(new Uint8Array(publicKeyBytes.buffer), { useMaps: true });
	}
	serializePublicKey(publicKey) {
		const encoded = new Uint8Array(65);
		encoded[0] = 4;
		const x = publicKey.get(-2);
		const y = publicKey.get(-3);
		if (!(x instanceof Uint8Array) || !(y instanceof Uint8Array)) throw new Error("Public key is in unknown format");
		encoded.set(x, 1);
		encoded.set(y, 33);
		return encoded;
	}
};
/** authenticators are allowed to truncate strings to this length */
const WEBAUTHN_STRING_MAX_BYTE_LENGTH = 64;
function validateWebauthnDisplayName(displayName) {
	return WEBAUTHN_STRING_MAX_BYTE_LENGTH - stringToUtf8Uint8Array(displayName).byteLength >= 0;
}

//#endregion
//#region ../src/common/api/main/LoginController.ts
assertMainOrNodeBoot();
var LoginController = class {
	userController = null;
	customizations = null;
	partialLogin = defer();
	_isWhitelabel = !!getWhitelabelCustomizations(window);
	postLoginActions = [];
	fullyLoggedIn = false;
	atLeastPartiallyLoggedIn = false;
	constructor(loginFacade, loginListener, resetAppState) {
		this.loginFacade = loginFacade;
		this.loginListener = loginListener;
		this.resetAppState = resetAppState;
	}
	init() {
		this.waitForFullLogin().then(async () => {
			this.fullyLoggedIn = true;
			await this.waitForPartialLogin();
			for (const lazyAction of this.postLoginActions) {
				const action = await lazyAction();
				await action.onFullLoginSuccess({
					sessionType: this.getUserController().sessionType,
					userId: this.getUserController().userId
				});
			}
		});
	}
	/**
	* create a new session and set up stored credentials and offline database, if applicable.
	* @param username the mail address being used to log in
	* @param password the password given to log in
	* @param sessionType whether to store the credentials in local storage
	* @param databaseKey if given, will use this key for the offline database. if not, will force a new database to be created and generate a key.
	*/
	async createSession(username, password, sessionType, databaseKey = null) {
		const newSessionData = await this.loginFacade.createSession(username, password, client.getIdentifier(), sessionType, databaseKey);
		const { user, credentials, sessionId, userGroupInfo } = newSessionData;
		await this.onPartialLoginSuccess({
			user,
			userGroupInfo,
			sessionId,
			accessToken: credentials.accessToken,
			sessionType,
			loginUsername: username
		}, sessionType);
		return newSessionData;
	}
	addPostLoginAction(handler) {
		this.postLoginActions.push(handler);
	}
	async onPartialLoginSuccess(initData, sessionType) {
		const { initUserController } = await import("./UserController-9L0-v1kK.js");
		this.userController = await initUserController(initData);
		await this.loadCustomizations();
		await this._determineIfWhitelabel();
		for (const lazyHandler of this.postLoginActions) {
			const handler = await lazyHandler();
			await handler.onPartialLoginSuccess({
				sessionType,
				userId: initData.user._id
			});
		}
		this.atLeastPartiallyLoggedIn = true;
		this.partialLogin.resolve();
	}
	async createExternalSession(userId, password, salt, kdfType, clientIdentifier, sessionType) {
		const persistentSession = sessionType === SessionType.Persistent;
		const { user, credentials, sessionId, userGroupInfo } = await this.loginFacade.createExternalSession(userId, password, salt, kdfType, clientIdentifier, persistentSession);
		await this.onPartialLoginSuccess({
			user,
			accessToken: credentials.accessToken,
			sessionType,
			sessionId,
			userGroupInfo,
			loginUsername: userId
		}, SessionType.Login);
		return credentials;
	}
	/**
	* Resume an existing session using stored credentials, may or may not unlock a persistent local database
	* @param unencryptedCredentials The stored credentials and optional database key for the offline db
	* @param externalUserKeyDeriver The KDF type and salt to resume a session
	* @param offlineTimeRangeDays the user configured time range for their offline storage, used to initialize the offline db
	*/
	async resumeSession(unencryptedCredentials, externalUserKeyDeriver, offlineTimeRangeDays) {
		const { unencryptedToCredentials } = await import("./Credentials-Dc14MVRJ.js");
		const credentials = unencryptedToCredentials(unencryptedCredentials);
		const resumeResult = await this.loginFacade.resumeSession(credentials, externalUserKeyDeriver ?? null, unencryptedCredentials.databaseKey ?? null, offlineTimeRangeDays ?? null);
		if (resumeResult.type === "error") return resumeResult;
else {
			const { user, userGroupInfo, sessionId } = resumeResult.data;
			try {
				await this.onPartialLoginSuccess({
					user,
					accessToken: credentials.accessToken,
					userGroupInfo,
					sessionId,
					sessionType: SessionType.Persistent,
					loginUsername: credentials.login
				}, SessionType.Persistent);
			} catch (e) {
				console.log("Error finishing login, logging out now!", e);
				await this.logout(false);
				throw e;
			}
			return { type: "success" };
		}
	}
	isUserLoggedIn() {
		return this.userController != null;
	}
	isFullyLoggedIn() {
		return this.fullyLoggedIn;
	}
	isAtLeastPartiallyLoggedIn() {
		return this.atLeastPartiallyLoggedIn;
	}
	waitForPartialLogin() {
		return this.partialLogin.promise;
	}
	async waitForFullLogin() {
		await this.waitForPartialLogin();
		const loginListener = await this.loginListener();
		return loginListener.waitForFullLogin();
	}
	isInternalUserLoggedIn() {
		return this.isUserLoggedIn() && this.getUserController().isInternalUser();
	}
	isGlobalAdminUserLoggedIn() {
		return this.isUserLoggedIn() && this.getUserController().isGlobalAdmin();
	}
	getUserController() {
		return assertNotNull(this.userController);
	}
	isEnabled(feature) {
		return this.customizations != null ? this.customizations.indexOf(feature) !== -1 : false;
	}
	async loadCustomizations(cacheMode = CacheMode.ReadAndWrite) {
		if (this.getUserController().isInternalUser()) {
			const customer = await this.getUserController().loadCustomer(cacheMode);
			this.customizations = customer.customizations.map((f) => f.feature);
		}
	}
	/**
	* Reset login state, delete session, if not {@link SessionType.Persistent}.
	* @param sync whether to try and close the session before the window is closed
	*/
	async logout(sync) {
		if (this.userController) await this.userController.deleteSession(sync);
else console.log("No session to delete");
		await this.resetAppState();
		this.userController = null;
		this.partialLogin = defer();
		this.fullyLoggedIn = false;
		const loginListener = await this.loginListener();
		loginListener.reset();
		this.init();
	}
	async _determineIfWhitelabel() {
		this._isWhitelabel = await this.getUserController().isWhitelabelAccount();
	}
	isWhitelabel() {
		return this._isWhitelabel;
	}
	/**
	* Deletes the session on the server.
	* @param credentials
	* @param pushIdentifier identifier associated with this device, if any, to delete PushIdentifier on the server
	*/
	async deleteOldSession(credentials, pushIdentifier = null) {
		try {
			await this.loginFacade.deleteSession(credentials.accessToken, pushIdentifier);
		} catch (e) {
			if (e instanceof NotFoundError) console.log("session already deleted");
else throw e;
		}
	}
	async retryAsyncLogin() {
		const loginListener = await this.loginListener();
		loginListener.onRetryLogin();
		await this.loginFacade.retryAsyncLogin();
	}
};

//#endregion
//#region ../src/common/misc/news/NewsModel.ts
var NewsModel = class {
	liveNewsIds = [];
	liveNewsListItems = {};
	constructor(serviceExecutor, storage, newsListItemFactory) {
		this.serviceExecutor = serviceExecutor;
		this.storage = storage;
		this.newsListItemFactory = newsListItemFactory;
	}
	/**
	* Loads the user's unacknowledged NewsItems.
	*/
	async loadNewsIds() {
		const response = await this.serviceExecutor.get(NewsService, null);
		this.liveNewsIds = [];
		this.liveNewsListItems = {};
		for (const newsItemId of response.newsItemIds) {
			const newsItemName = newsItemId.newsItemName;
			const newsListItem = await this.newsListItemFactory(newsItemName);
			if (!!newsListItem && await newsListItem.isShown(newsItemId)) {
				const unsupportedIosNewsItem = isIOSApp() && ["newPlans", "newPlansOfferEnding"].includes(newsItemId.newsItemName);
				if (!unsupportedIosNewsItem) {
					this.liveNewsIds.push(newsItemId);
					this.liveNewsListItems[newsItemName] = newsListItem;
				}
			}
		}
		return this.liveNewsIds;
	}
	/**
	* Acknowledges the NewsItem with the given ID.
	*/
	async acknowledgeNews(newsItemId) {
		const data = createNewsIn({ newsItemId });
		try {
			await this.serviceExecutor.post(NewsService, data);
			return true;
		} catch (e) {
			if (e instanceof NotFoundError) {
				console.log(`Could not acknowledge newsItem with ID '${newsItemId}'`);
				return false;
			} else throw e;
		} finally {
			await this.loadNewsIds();
		}
	}
	acknowledgeNewsForDevice(newsItemId) {
		return this.storage.acknowledgeNewsItemForDevice(newsItemId);
	}
	hasAcknowledgedNewsForDevice(newsItemId) {
		return this.storage.hasAcknowledgedNewsItemForDevice(newsItemId);
	}
};

//#endregion
//#region ../src/common/misc/WebsocketConnectivityModel.ts
var import_stream$3 = __toESM(require_stream(), 1);
var WebsocketConnectivityModel = class {
	wsState = (0, import_stream$3.default)(WsConnectionState.terminated);
	leaderStatus = false;
	constructor(eventBus) {
		this.eventBus = eventBus;
	}
	async updateWebSocketState(wsConnectionState) {
		this.wsState(wsConnectionState);
	}
	async onLeaderStatusChanged(leaderStatus) {
		this.leaderStatus = leaderStatus.leaderStatus;
	}
	isLeader() {
		return this.leaderStatus;
	}
	wsConnection() {
		return this.wsState.map(identity);
	}
	tryReconnect(closeIfOpen, enableAutomaticState, delay = null) {
		return this.eventBus.tryReconnect(closeIfOpen, enableAutomaticState, delay);
	}
	close(option) {
		return this.eventBus.close(option);
	}
};

//#endregion
//#region ../src/common/api/main/OperationProgressTracker.ts
var import_stream$2 = __toESM(require_stream(), 1);
var OperationProgressTracker = class {
	progressPerOp = new Map();
	operationId = 0;
	/**
	* Prepares a new operation and gives a handle for it which contains:
	*   - id for sending updates
	*   - progress, a stream to observe
	*   - done, a handle to stop tracking the operation progress
	*/
	startNewOperation() {
		const id = this.operationId++;
		const progress = (0, import_stream$2.default)(0);
		this.progressPerOp.set(id, progress);
		return {
			id,
			progress,
			done: () => this.progressPerOp.delete(id)
		};
	}
	/** Updates the progress for {@param operation} with {@param progressValue}. */
	async onProgress(operation, progressValue) {
		this.progressPerOp.get(operation)?.(progressValue);
	}
};

//#endregion
//#region ../src/common/gui/InfoMessageHandler.ts
assertMainOrNode();
var InfoMessageHandler = class {
	constructor(handleIndexStateUpdate) {
		this.handleIndexStateUpdate = handleIndexStateUpdate;
	}
	async onInfoMessage(message) {
		show({ view: () => mithril_default("", lang.get(message.translationKey, message.args)) }, { label: "close_alt" }, []);
	}
	async onSearchIndexStateUpdate(state) {
		this.handleIndexStateUpdate(state);
	}
};

//#endregion
//#region ../src/common/gui/base/ProgressBar.ts
let ProgressBarType = function(ProgressBarType$1) {
	ProgressBarType$1[ProgressBarType$1["Small"] = 0] = "Small";
	ProgressBarType$1[ProgressBarType$1["Large"] = 1] = "Large";
	return ProgressBarType$1;
}({});
const PROGRESS_DONE = 1;
var ProgressBar = class {
	lastProgress = null;
	view(vnode) {
		const a = vnode.attrs;
		if (this.lastProgress === null && a.progress >= PROGRESS_DONE) return null;
		if (this.lastProgress !== null && this.lastProgress >= PROGRESS_DONE) return null;
		if (a.progress >= PROGRESS_DONE) mithril_default.redraw();
		this.lastProgress = a.progress;
		let progressBarSelector = a.type == ProgressBarType.Large ? ".abs.accent-bg.border-radius-big" : ".abs.accent-bg";
		return mithril_default(progressBarSelector, {
			onbeforeremove: (vn) => new Promise((resolve) => {
				vn.dom.addEventListener("transitionend", () => {
					this.lastProgress = null;
					resolve();
				});
				setTimeout(() => {
					this.lastProgress = null;
					resolve();
				}, 500);
			}),
			style: {
				top: 0,
				left: 0,
				transition: "width 500ms",
				width: a.progress * 100 + "%",
				height: a.type == ProgressBarType.Large ? "100%" : "2px"
			}
		});
	}
};

//#endregion
//#region ../src/common/gui/base/OfflineIndicator.ts
let OfflineIndicatorState = function(OfflineIndicatorState$1) {
	OfflineIndicatorState$1[OfflineIndicatorState$1["Offline"] = 0] = "Offline";
	OfflineIndicatorState$1[OfflineIndicatorState$1["Connecting"] = 1] = "Connecting";
	OfflineIndicatorState$1[OfflineIndicatorState$1["Synchronizing"] = 2] = "Synchronizing";
	OfflineIndicatorState$1[OfflineIndicatorState$1["Online"] = 3] = "Online";
	return OfflineIndicatorState$1;
}({});
/**
* the first line of the offline indicator shows if we're offline or online and
* adds action prompts (if any)
* it's returned as a span so the consumer can decide how to layout it.
*/
function attrToFirstLine(attr) {
	const { state } = attr;
	switch (state) {
		case OfflineIndicatorState.Online:
		case OfflineIndicatorState.Synchronizing: return mithril_default("span", lang.get("online_label"));
		case OfflineIndicatorState.Offline: return mithril_default("span", [lang.get("offline_label"), mithril_default("span.b.content-accent-fg.mlr-s", lang.get("reconnect_action"))]);
		case OfflineIndicatorState.Connecting: return mithril_default("span", lang.get("offline_label"));
	}
}
/**
* the second line provides additional information about the current state.
* it's returned as a span so the consumer can decide how to layout it.
*/
function attrToSecondLine(a) {
	switch (a.state) {
		case OfflineIndicatorState.Online: return mithril_default("span", lang.get("upToDate_label"));
		case OfflineIndicatorState.Offline: if (a.lastUpdate) return mithril_default("span", lang.get("lastSync_label", { "{date}": formatDate(a.lastUpdate) }));
else return null;
		case OfflineIndicatorState.Synchronizing: return mithril_default("span", lang.get("synchronizing_label", { "{progress}": formatPercentage(a.progress) }));
		case OfflineIndicatorState.Connecting: return mithril_default("span", lang.get("reconnecting_label"));
	}
}
/**
* format a number as a percentage string with 0 = 0% and 1 = 100%
*/
function formatPercentage(percentage) {
	return `${Math.round(percentage * 100)}%`;
}
function formatDate(date) {
	return isSameDayOfDate(new Date(), date) ? lang.formats.time.format(date) : lang.formats.simpleDate.format(date);
}
var OfflineIndicator = class {
	view(vnode) {
		const a = vnode.attrs;
		const isOffline = a.state === OfflineIndicatorState.Offline;
		return mithril_default("button.small", {
			class: a.isSingleColumn ? "center mb-xs" : "mlr-l flex col",
			type: "button",
			href: "#",
			tabindex: "0",
			role: "button",
			"aria-disabled": !isOffline,
			onclick: isOffline ? a.reconnectAction : noOp
		}, a.isSingleColumn ? attrToFirstLine(a) : [attrToFirstLine(a), attrToSecondLine(a)]);
	}
};

//#endregion
//#region ../src/common/gui/base/OfflineIndicatorViewModel.ts
var OfflineIndicatorViewModel = class {
	lastProgress = PROGRESS_DONE;
	lastWsState = WsConnectionState.connecting;
	lastUpdate = null;
	/**
	* keeping this prevents flashing misleading states during login when
	* the full login succeeded but the ws connection attempt didn't
	* succeed or fail yet.
	* wsState is "connecting" both during first connect attempt and after we
	* disconnected.
	**/
	wsWasConnectedBefore = false;
	constructor(cacheStorage, loginListener, connectivityModel, logins, progressTracker, cb) {
		this.cacheStorage = cacheStorage;
		this.loginListener = loginListener;
		this.connectivityModel = connectivityModel;
		this.logins = logins;
		this.cb = cb;
		logins.waitForFullLogin().then(() => this.cb());
		this.setProgressUpdateStream(progressTracker.onProgressUpdate);
		this.setWsStateStream(this.connectivityModel.wsConnection());
	}
	setProgressUpdateStream(progressStream) {
		progressStream.map((progress) => this.onProgressUpdate(progress));
		this.onProgressUpdate(progressStream());
	}
	setWsStateStream(wsStream) {
		wsStream.map((state) => {
			this.onWsStateChange(state);
		});
		this.onWsStateChange(wsStream()).then();
	}
	onProgressUpdate(progress) {
		this.lastProgress = progress;
		this.cb();
	}
	async onWsStateChange(newState) {
		this.lastWsState = newState;
		if (newState !== WsConnectionState.connected) {
			const lastUpdate = await this.cacheStorage.getLastUpdateTime();
			switch (lastUpdate.type) {
				case "recorded":
					this.lastUpdate = new Date(lastUpdate.time);
					break;
				case "never":
				case "uninitialized":
					this.lastUpdate = null;
					this.wsWasConnectedBefore = false;
					break;
			}
		} else this.wsWasConnectedBefore = true;
		this.cb();
	}
	getCurrentAttrs() {
		const isSingleColumn = styles.isUsingBottomNavigation();
		if (this.logins.isFullyLoggedIn() && this.wsWasConnectedBefore) if (this.lastWsState === WsConnectionState.connected) if (this.lastProgress < PROGRESS_DONE) return {
			state: OfflineIndicatorState.Synchronizing,
			progress: this.lastProgress,
			isSingleColumn
		};
else return {
			state: OfflineIndicatorState.Online,
			isSingleColumn
		};
else return {
			state: OfflineIndicatorState.Offline,
			lastUpdate: this.lastUpdate,
			reconnectAction: () => {
				console.log("try reconnect ws");
				this.connectivityModel.tryReconnect(true, true, 2e3);
			},
			isSingleColumn
		};
else if (this.loginListener.getFullLoginFailed()) return {
			state: OfflineIndicatorState.Offline,
			lastUpdate: this.lastUpdate,
			reconnectAction: () => {
				console.log("try full login");
				this.logins.retryAsyncLogin().finally(() => this.cb());
			},
			isSingleColumn
		};
else return {
			state: OfflineIndicatorState.Connecting,
			isSingleColumn
		};
	}
	getProgress() {
		const a = this.getCurrentAttrs();
		return a.state === OfflineIndicatorState.Synchronizing && this.logins?.isUserLoggedIn() ? a.progress : 1;
	}
};

//#endregion
//#region ../src/common/gui/ScopedRouter.ts
var ThrottledRouter = class {
	throttledRoute = debounceStart(32, throttleRoute());
	getFullPath() {
		return mithril_default.route.get();
	}
	routeTo(path, params) {
		this.throttledRoute(path, params);
	}
};
var ScopedRouter = class {
	scope;
	constructor(router, scope) {
		this.router = router;
		if (!scope.startsWith("/")) throw new ProgrammingError(`Scope must start with a forward slash! got: ${scope}`);
		if (scope.split("/").length > 2) throw new ProgrammingError(`Does not support nested scopes yet. Easter egg! got: ${scope}`);
		this.scope = scope.substring(1);
	}
	getFullPath() {
		return this.router.getFullPath();
	}
	routeTo(path, params) {
		if (routeMatchesPrefix(this.scope, this.router.getFullPath())) this.router.routeTo(path, params);
	}
};
function routeMatchesPrefix(prefixWithoutLeadingSlash, route) {
	const { path } = mithril_default.parsePathname(route);
	return path.split("/")[1] === prefixWithoutLeadingSlash;
}

//#endregion
//#region ../src/mail-app/mail/model/InboxRuleHandler.ts
assertMainOrNode();
const moveMailDataPerFolder = [];
const DEBOUNCE_FIRST_MOVE_MAIL_REQUEST_MS = 200;
let applyingRules = false;
async function sendMoveMailRequest(mailFacade) {
	if (moveMailDataPerFolder.length) {
		const moveToTargetFolder = assertNotNull(moveMailDataPerFolder.shift());
		const mailChunks = splitInChunks(MAX_NBR_MOVE_DELETE_MAIL_SERVICE, moveToTargetFolder.mails);
		await pMap(mailChunks, (mailChunk) => {
			moveToTargetFolder.mails = mailChunk;
			const sourceFolder = assertNotNull(moveToTargetFolder.sourceFolder);
			return mailFacade.moveMails(mailChunk, sourceFolder, moveToTargetFolder.targetFolder);
		}).catch(ofClass(LockedError, (e) => {
			console.log("moving mail failed", e, moveToTargetFolder);
		})).catch(ofClass(PreconditionFailedError, (e) => {
			console.log("moving mail failed", e, moveToTargetFolder);
		})).finally(() => {
			return sendMoveMailRequest(mailFacade);
		});
	}
}
const applyMatchingRules = throttle(DEBOUNCE_FIRST_MOVE_MAIL_REQUEST_MS, (mailFacade) => {
	if (applyingRules) return;
	applyingRules = true;
	sendMoveMailRequest(mailFacade).finally(() => {
		applyingRules = false;
	});
});
var InboxRuleHandler = class {
	constructor(mailFacade, logins) {
		this.mailFacade = mailFacade;
		this.logins = logins;
	}
	/**
	* Checks the mail for an existing inbox rule and moves the mail to the target folder of the rule.
	* @returns true if a rule matches otherwise false
	*/
	async findAndApplyMatchingRule(mailboxDetail, mail, applyRulesOnServer) {
		if (mail._errors || !mail.unread || !await isInboxFolder(mailboxDetail, mail) || !this.logins.getUserController().isPremiumAccount() || mailboxDetail.mailbox.folders == null) return null;
		const inboxRule = await _findMatchingRule(this.mailFacade, mail, this.logins.getUserController().props.inboxRules);
		if (inboxRule) {
			const folders = await mailLocator.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id);
			const inboxFolder = assertNotNull(folders.getSystemFolderByType(MailSetKind.INBOX));
			const targetFolder = folders.getFolderById(elementIdPart(inboxRule.targetFolder));
			if (targetFolder && targetFolder.folderType !== MailSetKind.INBOX) {
				if (applyRulesOnServer) {
					let moveMailData = moveMailDataPerFolder.find((folderMoveMailData) => isSameId(folderMoveMailData.targetFolder, inboxRule.targetFolder));
					if (moveMailData) moveMailData.mails.push(mail._id);
else {
						moveMailData = createMoveMailData({
							sourceFolder: inboxFolder._id,
							targetFolder: inboxRule.targetFolder,
							mails: [mail._id]
						});
						moveMailDataPerFolder.push(moveMailData);
					}
					applyMatchingRules(this.mailFacade);
				}
				return {
					folder: targetFolder,
					mail
				};
			} else return null;
		} else return null;
	}
};
async function _findMatchingRule(mailFacade, mail, rules) {
	return asyncFind(rules, (rule) => checkInboxRule(mailFacade, mail, rule)).then((v) => v ?? null);
}
async function checkInboxRule(mailFacade, mail, inboxRule) {
	const ruleType = inboxRule.type;
	try {
		if (ruleType === InboxRuleType.FROM_EQUALS) {
			let mailAddresses = [mail.sender.address];
			if (mail.differentEnvelopeSender) mailAddresses.push(mail.differentEnvelopeSender);
			return _checkEmailAddresses(mailAddresses, inboxRule);
		} else if (ruleType === InboxRuleType.RECIPIENT_TO_EQUALS) {
			const toRecipients = (await mailFacade.loadMailDetailsBlob(mail)).recipients.toRecipients;
			return _checkEmailAddresses(toRecipients.map((m) => m.address), inboxRule);
		} else if (ruleType === InboxRuleType.RECIPIENT_CC_EQUALS) {
			const ccRecipients = (await mailFacade.loadMailDetailsBlob(mail)).recipients.ccRecipients;
			return _checkEmailAddresses(ccRecipients.map((m) => m.address), inboxRule);
		} else if (ruleType === InboxRuleType.RECIPIENT_BCC_EQUALS) {
			const bccRecipients = (await mailFacade.loadMailDetailsBlob(mail)).recipients.bccRecipients;
			return _checkEmailAddresses(bccRecipients.map((m) => m.address), inboxRule);
		} else if (ruleType === InboxRuleType.SUBJECT_CONTAINS) return _checkContainsRule(mail.subject, inboxRule);
else if (ruleType === InboxRuleType.MAIL_HEADER_CONTAINS) {
			const details = await mailFacade.loadMailDetailsBlob(mail);
			if (details.headers != null) return _checkContainsRule(getMailHeaders(details.headers), inboxRule);
else return false;
		} else {
			console.warn("Unknown rule type: ", inboxRule.type);
			return false;
		}
	} catch (e) {
		console.error("Error processing inbox rule:", e.message);
		return false;
	}
}
function _checkContainsRule(value, inboxRule) {
	return isRegularExpression(inboxRule.value) && _matchesRegularExpression(value, inboxRule) || value.includes(inboxRule.value);
}
function _matchesRegularExpression(value, inboxRule) {
	if (isRegularExpression(inboxRule.value)) {
		let flags = inboxRule.value.replace(/.*\/([gimsuy]*)$/, "$1");
		let pattern = inboxRule.value.replace(new RegExp("^/(.*?)/" + flags + "$"), "$1");
		let regExp = new RegExp(pattern, flags);
		return regExp.test(value);
	}
	return false;
}
function _checkEmailAddresses(mailAddresses, inboxRule) {
	const mailAddress = mailAddresses.find((mailAddress$1) => {
		let cleanMailAddress = mailAddress$1.toLowerCase().trim();
		if (isRegularExpression(inboxRule.value)) return _matchesRegularExpression(cleanMailAddress, inboxRule);
else if (isDomainName(inboxRule.value)) {
			let domain = cleanMailAddress.split("@")[1];
			return domain === inboxRule.value;
		} else return cleanMailAddress === inboxRule.value;
	});
	return mailAddress != null;
}
async function isInboxFolder(mailboxDetail, mail) {
	const folders = await mailLocator.mailModel.getMailboxFoldersForId(assertNotNull(mailboxDetail.mailbox.folders)._id);
	const mailFolder = folders.getFolderByMail(mail);
	return mailFolder?.folderType === MailSetKind.INBOX;
}

//#endregion
//#region ../src/common/api/main/EntropyCollector.ts
assertMainOrNode();
var EntropyCollector = class EntropyCollector {
	static SEND_INTERVAL = 5e3;
	stopped = true;
	entropyCache = [];
	constructor(entropyFacade, scheduler, window$1) {
		this.entropyFacade = entropyFacade;
		this.scheduler = scheduler;
		this.window = window$1;
	}
	mouse = (e) => {
		const value = e.clientX ^ e.clientY;
		this.addEntropy(value, 2, "mouse");
	};
	keyDown = (e) => {
		const value = e.key ? e.key.charCodeAt(0) : undefined;
		this.addEntropy(value, 2, "key");
	};
	touch = (e) => {
		const value = e.touches[0].clientX ^ e.touches[0].clientY;
		this.addEntropy(value, 2, "touch");
	};
	/** e is a DeviceMotionEvent but it's typed in a very annoying way */
	accelerometer = (e) => {
		if (e.accelerationIncludingGravity) this.addEntropy(e.accelerationIncludingGravity.x ^ e.accelerationIncludingGravity.y ^ e.accelerationIncludingGravity.z, 2, "accel");
		this.addEntropy(this.window.screen.orientation.angle, 0, "accel");
	};
	/**
	* Adds entropy to the random number generator algorithm
	* @param data Any number value, or undefined
	* @param entropy The amount of entropy in the number in bit.
	* @param source The source of the number. One of RandomizerInterface.ENTROPY_SRC_*.
	*/
	addEntropy(data, entropy, source) {
		if (data) this.entropyCache.push({
			source,
			entropy,
			data
		});
		if (this.window.performance && typeof window.performance.now === "function") this.entropyCache.push({
			source: "time",
			entropy: 2,
			data: this.window.performance.now()
		});
else this.entropyCache.push({
			source: "time",
			entropy: 2,
			data: new Date().valueOf()
		});
	}
	start() {
		this.addPerformanceTimingValues();
		this.window.addEventListener("mousemove", this.mouse);
		this.window.addEventListener("click", this.mouse);
		this.window.addEventListener("touchstart", this.touch);
		this.window.addEventListener("touchmove", this.touch);
		this.window.addEventListener("keydown", this.keyDown);
		this.window.addEventListener("devicemotion", this.accelerometer);
		this.scheduler.schedulePeriodic(() => this.sendEntropyToWorker(), EntropyCollector.SEND_INTERVAL);
		this.stopped = false;
	}
	addPerformanceTimingValues() {
		if (!this.window.performance) return;
		const entries = this.window.performance.getEntries();
		let added = [];
		for (const entry of entries.map((e) => e.toJSON())) for (let key in entry) {
			const value = entry[key];
			if (typeof value === "number" && value !== 0) {
				if (added.indexOf(value) === -1) {
					this.addEntropy(value, 1, "static");
					added.push(value);
				}
			}
		}
	}
	/**
	* Add data from secure random source as entropy.
	*/
	addNativeRandomValues(nbrOf32BitValues) {
		let valueList = new Uint32Array(nbrOf32BitValues);
		this.window.crypto.getRandomValues(valueList);
		for (let i = 0; i < valueList.length; i++) this.addEntropy(valueList[i], 32, "random");
	}
	sendEntropyToWorker() {
		if (this.entropyCache.length > 0) {
			this.addNativeRandomValues(1);
			this.entropyFacade.addEntropy(this.entropyCache);
			this.entropyCache = [];
		}
	}
	stop() {
		this.stopped = true;
		this.window.removeEventListener("mousemove", this.mouse);
		this.window.removeEventListener("mouseclick", this.mouse);
		this.window.removeEventListener("touchstart", this.touch);
		this.window.removeEventListener("touchmove", this.touch);
		this.window.removeEventListener("keydown", this.keyDown);
		this.window.removeEventListener("devicemotion", this.accelerometer);
	}
};

//#endregion
//#region ../src/common/misc/2fa/webauthn/WebauthnTypes.ts
let COSEAlgorithmIdentifier = function(COSEAlgorithmIdentifier$1) {
	COSEAlgorithmIdentifier$1[COSEAlgorithmIdentifier$1["ES256"] = -7] = "ES256";
	COSEAlgorithmIdentifier$1[COSEAlgorithmIdentifier$1["ES384"] = -35] = "ES384";
	COSEAlgorithmIdentifier$1[COSEAlgorithmIdentifier$1["ES512"] = -36] = "ES512";
	COSEAlgorithmIdentifier$1[COSEAlgorithmIdentifier$1["EdDSA"] = -8] = "EdDSA";
	return COSEAlgorithmIdentifier$1;
}({});

//#endregion
//#region ../src/common/misc/2fa/webauthn/BrowserWebauthn.ts
const WEBAUTHN_TIMEOUT_MS = 6e4;
var BrowserWebauthn = class {
	/**
	* Relying Party Identifier
	* see https://www.w3.org/TR/webauthn-2/#public-key-credential-source-rpid
	*/
	rpId;
	/** Backward-compatible identifier for the legacy U2F API */
	appId;
	currentOperationSignal = null;
	constructor(api, domainConfig) {
		this.api = api;
		this.rpId = domainConfig.webauthnRpId;
		this.appId = domainConfig.u2fAppId;
	}
	async canAttemptChallengeForRpId(rpId) {
		return rpId === this.rpId;
	}
	async canAttemptChallengeForU2FAppId(appId) {
		return this.appId === appId;
	}
	/**
	* test whether hardware key second factors are supported for this client
	*/
	async isSupported() {
		return !isApp() && this.api != null && !BigInt.polyfilled;
	}
	async register({ challenge, userId, name, displayName }) {
		const publicKeyCredentialCreationOptions = {
			challenge,
			rp: {
				name: "Tutanota",
				id: this.rpId
			},
			user: {
				id: stringToUtf8Uint8Array(userId),
				name,
				displayName
			},
			pubKeyCredParams: [{
				alg: COSEAlgorithmIdentifier.ES256,
				type: "public-key"
			}],
			authenticatorSelection: {
				authenticatorAttachment: "cross-platform",
				userVerification: "discouraged"
			},
			timeout: WEBAUTHN_TIMEOUT_MS,
			attestation: "none"
		};
		this.currentOperationSignal = new AbortController();
		const credential = await this.api.create({
			publicKey: publicKeyCredentialCreationOptions,
			signal: this.currentOperationSignal.signal
		});
		return {
			rpId: this.rpId,
			rawId: new Uint8Array(credential.rawId),
			attestationObject: new Uint8Array(credential.response.attestationObject)
		};
	}
	async sign({ challenge, keys }) {
		const allowCredentials = keys.map((key) => {
			return {
				id: key.id,
				type: "public-key"
			};
		});
		const publicKeyCredentialRequestOptions = {
			challenge,
			rpId: this.rpId,
			allowCredentials,
			extensions: { appid: this.appId },
			userVerification: "discouraged",
			timeout: WEBAUTHN_TIMEOUT_MS
		};
		let assertion;
		this.currentOperationSignal = new AbortController();
		try {
			assertion = await this.api.get({
				publicKey: publicKeyCredentialRequestOptions,
				signal: this.currentOperationSignal.signal
			});
		} catch (e) {
			if (e.name === "AbortError") throw new CancelledError(e);
else throw new WebauthnError(e);
		}
		const publicKeyCredential = assertion;
		if (publicKeyCredential == null) throw new ProgrammingError("Webauthn credential could not be unambiguously resolved");
		const assertionResponse = publicKeyCredential.response;
		return {
			rawId: new Uint8Array(publicKeyCredential.rawId),
			authenticatorData: new Uint8Array(assertionResponse.authenticatorData),
			signature: new Uint8Array(assertionResponse.signature),
			clientDataJSON: new Uint8Array(assertionResponse.clientDataJSON)
		};
	}
	async abortCurrentOperation() {
		this.currentOperationSignal?.abort();
		this.currentOperationSignal = null;
	}
};

//#endregion
//#region ../src/common/file/FileControllerBrowser.ts
assertMainOrNode();
var FileControllerBrowser = class extends FileController {
	constructor(blobFacade, guiDownload$1) {
		super(blobFacade, guiDownload$1);
	}
	async saveDataFile(file) {
		return openDataFileInBrowser(file);
	}
	async downloadAndDecrypt(file) {
		return this.getAsDataFile(file);
	}
	async writeDownloadedFiles(downloadedFiles) {
		if (downloadedFiles.length < 1) return;
		assertOnlyDataFiles(downloadedFiles);
		const fileToSave = downloadedFiles.length > 1 ? await zipDataFiles(downloadedFiles, `${sortableTimestamp()}-attachments.zip`) : downloadedFiles[0];
		return await openDataFileInBrowser(fileToSave);
	}
	async cleanUp(downloadedFiles) {}
	async openDownloadedFiles(downloadedFiles) {
		return await this.writeDownloadedFiles(downloadedFiles);
	}
};

//#endregion
//#region ../src/common/file/FileControllerNative.ts
assertMainOrNode();
var FileControllerNative = class extends FileController {
	constructor(blobFacade, guiDownload$1, fileApp) {
		assert(isElectronClient() || isApp() || isTest(), "Don't make native file controller when not in native");
		super(blobFacade, guiDownload$1);
		this.fileApp = fileApp;
	}
	async cleanUp(files) {
		assertOnlyFileReferences(files);
		if (files.length > 0) for (const file of files) try {
			await this.fileApp.deleteFile(file.location);
		} catch (e) {
			console.log("failed to delete file", file.location, e);
		}
	}
	/**
	* Does not delete temporary file in app.
	*/
	async saveDataFile(file) {
		try {
			const fileReference = await this.fileApp.writeDataFile(file);
			if (isAndroidApp() || isDesktop()) {
				await this.fileApp.putFileIntoDownloadsFolder(fileReference.location, fileReference.name);
				return;
			} else if (isIOSApp()) return this.fileApp.open(fileReference);
		} catch (e) {
			if (e instanceof CancelledError) console.log("saveDataFile cancelled");
else {
				console.warn("openDataFile failed", e);
				await Dialog.message("canNotOpenFileOnDevice_msg");
			}
		}
	}
	/** Public for testing */
	async downloadAndDecrypt(tutanotaFile) {
		return await this.blobFacade.downloadAndDecryptNative(ArchiveDataType.Attachments, createReferencingInstance(tutanotaFile), tutanotaFile.name, assertNotNull(tutanotaFile.mimeType, "tried to call blobfacade.downloadAndDecryptNative with null mimeType"));
	}
	async writeDownloadedFiles(downloadedFiles) {
		if (isIOSApp()) await this.processDownloadedFilesIOS(downloadedFiles);
else if (isDesktop()) await this.processDownloadedFilesDesktop(downloadedFiles);
else if (isAndroidApp()) await pMap(downloadedFiles, (file) => this.fileApp.putFileIntoDownloadsFolder(file.location, file.name));
else throw new ProgrammingError("in filecontroller native but not in ios, android or desktop? - tried to write");
	}
	async openDownloadedFiles(downloadedFiles) {
		if (isIOSApp()) await this.processDownloadedFilesIOS(downloadedFiles);
else if (isDesktop() || isAndroidApp()) await this.openFiles(downloadedFiles);
else throw new ProgrammingError("in filecontroller native but not in ios, android or desktop? - tried to open");
	}
	/**
	* for downloading multiple files on desktop. multiple files are bundled in a zip file, single files
	*
	* we could use the same strategy as on android, but
	* if the user doesn't have a default dl path selected on desktop,
	* the client will ask for a location for each file separately, so we zip them for now.
	*/
	async processDownloadedFilesDesktop(downloadedFiles) {
		if (downloadedFiles.length < 1) return;
		console.log("downloaded files in processing", downloadedFiles);
		const dataFiles = (await pMap(downloadedFiles, (f) => this.fileApp.readDataFile(f.location))).filter(Boolean);
		const fileInTemp = dataFiles.length === 1 ? downloadedFiles[0] : await this.fileApp.writeDataFile(await zipDataFiles(dataFiles, `${sortableTimestamp()}-attachments.zip`));
		await this.fileApp.putFileIntoDownloadsFolder(fileInTemp.location, fileInTemp.name);
	}
	async processDownloadedFilesIOS(downloadedFiles) {
		await pMap(downloadedFiles, async (file) => {
			try {
				await this.fileApp.open(file);
			} finally {
				await this.fileApp.deleteFile(file.location).catch((e) => console.log("failed to delete file", file.location, e));
			}
		});
	}
	async openFiles(downloadedFiles) {
		return pMap(downloadedFiles, async (file) => {
			try {
				await this.fileApp.open(file);
			} finally {
				if (isApp()) await this.fileApp.deleteFile(file.location).catch((e) => console.log("failed to delete file", file.location, e));
			}
		});
	}
};

//#endregion
//#region ../src/mail-app/contacts/model/NativeContactsSyncManager.ts
assertMainOrNode();
var NativeContactsSyncManager = class {
	entityUpdateLock = Promise.resolve();
	constructor(loginController, mobileContactsFacade, entityClient, eventController, contactModel, deviceConfig$1) {
		this.loginController = loginController;
		this.mobileContactsFacade = mobileContactsFacade;
		this.entityClient = entityClient;
		this.eventController = eventController;
		this.contactModel = contactModel;
		this.deviceConfig = deviceConfig$1;
		this.eventController.addEntityListener((updates) => this.nativeContactEntityEventsListener(updates));
	}
	async nativeContactEntityEventsListener(events) {
		await this.entityUpdateLock;
		await this.processContactEventUpdate(events);
	}
	async processContactEventUpdate(events) {
		const loginUsername = this.loginController.getUserController().loginUsername;
		const userId = this.loginController.getUserController().userId;
		const allowSync = this.deviceConfig.getUserSyncContactsWithPhonePreference(userId) ?? false;
		if (!allowSync) return;
		const contactsIdToCreateOrUpdate = new Map();
		for (const event of events) {
			if (!isUpdateForTypeRef(ContactTypeRef, event)) continue;
			if (event.operation === OperationType.CREATE) getFromMap(contactsIdToCreateOrUpdate, event.instanceListId, () => []).push(event.instanceId);
else if (event.operation === OperationType.UPDATE) getFromMap(contactsIdToCreateOrUpdate, event.instanceListId, () => []).push(event.instanceId);
else if (event.operation === OperationType.DELETE) await this.mobileContactsFacade.deleteContacts(loginUsername, event.instanceId).catch(ofClass(PermissionError, (e) => this.handleNoPermissionError(userId, e))).catch(ofClass(ContactStoreError, (e) => console.warn("Could not delete contact during sync: ", e)));
		}
		const contactsToInsertOrUpdate = [];
		for (const [listId, elementIds] of contactsIdToCreateOrUpdate.entries()) {
			const contactList = await this.entityClient.loadMultiple(ContactTypeRef, listId, elementIds);
			contactList.map((contact) => {
				contactsToInsertOrUpdate.push({
					id: getElementId(contact),
					firstName: contact.firstName,
					lastName: contact.lastName,
					nickname: contact.nickname ?? "",
					birthday: contact.birthdayIso,
					company: contact.company,
					mailAddresses: extractStructuredMailAddresses(contact.mailAddresses),
					phoneNumbers: extractStructuredPhoneNumbers(contact.phoneNumbers),
					addresses: extractStructuredAddresses(contact.addresses),
					rawId: null,
					customDate: extractStructuredCustomDates(contact.customDate),
					department: contact.department,
					messengerHandles: extractStructuredMessengerHandle(contact.messengerHandles),
					middleName: contact.middleName,
					nameSuffix: contact.nameSuffix,
					phoneticFirst: contact.phoneticFirst,
					phoneticLast: contact.phoneticLast,
					phoneticMiddle: contact.phoneticMiddle,
					relationships: extractStructuredRelationships(contact.relationships),
					websites: extractStructuredWebsites(contact.websites),
					notes: contact.comment,
					title: contact.title ?? "",
					role: contact.role
				});
			});
		}
		if (contactsToInsertOrUpdate.length > 0) await this.mobileContactsFacade.saveContacts(loginUsername, contactsToInsertOrUpdate).catch(ofClass(PermissionError, (e) => this.handleNoPermissionError(userId, e))).catch(ofClass(ContactStoreError, (e) => console.warn("Could not save contacts:", e)));
	}
	isEnabled() {
		return this.deviceConfig.getUserSyncContactsWithPhonePreference(this.loginController.getUserController().userId) ?? false;
	}
	/**
	* @return is sync succeeded. It might fail if we don't have a permission.
	*/
	async enableSync() {
		const loginUsername = this.loginController.getUserController().loginUsername;
		const contactListId = await this.contactModel.getContactListId();
		if (contactListId == null) return false;
		const contacts = await this.entityClient.loadAll(ContactTypeRef, contactListId);
		const structuredContacts = contacts.map((c) => this.toStructuredContact(c));
		try {
			await this.mobileContactsFacade.syncContacts(loginUsername, structuredContacts);
		} catch (e) {
			console.warn("Could not sync contacts:", e);
			if (e instanceof PermissionError) return false;
else if (e instanceof ContactStoreError) return false;
			throw e;
		}
		this.deviceConfig.setUserSyncContactsWithPhonePreference(this.loginController.getUserController().userId, true);
		await this.askToDedupeContacts(structuredContacts);
		return true;
	}
	/**
	* Check if syncing contacts is possible/allowed right now.
	*
	* On Android, this method simply requests permission to access contacts. On iOS, this also checks iCloud sync, as
	* it can interfere with
	*/
	async canSync() {
		if (!isApp()) throw new ProgrammingError("Can only check Contact permissions on app");
		const isContactPermissionGranted = await locator.systemPermissionHandler.requestPermission(PermissionType.Contacts, "allowContactReadWrite_msg");
		if (!isContactPermissionGranted) return false;
		return !isIOSApp() || this.checkIfExternalCloudSyncOnIos();
	}
	/**
	* Check that we are allowed to sync contacts on an iOS device
	* @returns false if no permission or iCloud sync is enabled and the user cancelled, or true if permission is granted and iCloud sync is disabled (or the user bypassed the warning dialog)
	*/
	async checkIfExternalCloudSyncOnIos() {
		assert(isIOSApp(), "Can only check cloud syncing on iOS");
		let localContactStorage = await this.mobileContactsFacade.isLocalStorageAvailable();
		if (!localContactStorage) {
			const choice = await Dialog.choiceVertical("externalContactSyncDetectedWarning_msg", [
				{
					text: "settings_label",
					value: "settings",
					type: "primary"
				},
				{
					text: "enableAnyway_action",
					value: "enable"
				},
				{
					text: "cancel_action",
					value: "cancel"
				}
			]);
			switch (choice) {
				case "enable": break;
				case "settings":
					locator.systemFacade.openLink("App-prefs:CONTACTS&path=ACCOUNTS");
					return false;
				case "cancel": return false;
			}
		}
		return true;
	}
	/**
	* @return is sync succeeded. It might fail if we don't have a permission.
	*/
	async syncContacts() {
		if (!this.isEnabled()) return false;
		const contactListId = await this.contactModel.getContactListId();
		if (contactListId == null) return false;
		const userId = this.loginController.getUserController().userId;
		const loginUsername = this.loginController.getUserController().loginUsername;
		const contacts = await this.entityClient.loadAll(ContactTypeRef, contactListId);
		const structuredContacts = contacts.map((contact) => this.toStructuredContact(contact));
		try {
			const syncResult = await this.mobileContactsFacade.syncContacts(loginUsername, structuredContacts);
			await this.applyDeviceChangesToServerContacts(contacts, syncResult, contactListId);
		} catch (e) {
			if (e instanceof PermissionError) {
				this.handleNoPermissionError(userId, e);
				return false;
			} else if (e instanceof ContactStoreError) {
				console.warn("Could not sync contacts:", e);
				return false;
			}
			throw e;
		}
		return true;
	}
	async askToDedupeContacts(contactsToDedupe) {
		const duplicateContacts = await this.mobileContactsFacade.findLocalMatches(contactsToDedupe);
		if (duplicateContacts.length === 0) return;
		const shouldDedupe = await Dialog.confirm(lang.getTranslation("importContactRemoveDuplicatesConfirm_msg", { "{count}": duplicateContacts.length }));
		if (shouldDedupe) await showProgressDialog("progressDeleting_msg", this.mobileContactsFacade.deleteLocalContacts(duplicateContacts));
	}
	toStructuredContact(contact) {
		return {
			id: getElementId(contact),
			firstName: contact.firstName,
			lastName: contact.lastName,
			mailAddresses: extractStructuredMailAddresses(contact.mailAddresses),
			phoneNumbers: extractStructuredPhoneNumbers(contact.phoneNumbers),
			nickname: contact.nickname ?? "",
			company: contact.company,
			birthday: contact.birthdayIso,
			addresses: extractStructuredAddresses(contact.addresses),
			rawId: null,
			customDate: extractStructuredCustomDates(contact.customDate),
			department: contact.department,
			messengerHandles: extractStructuredMessengerHandle(contact.messengerHandles),
			middleName: contact.middleName,
			nameSuffix: contact.nameSuffix,
			phoneticFirst: contact.phoneticFirst,
			phoneticLast: contact.phoneticLast,
			phoneticMiddle: contact.phoneticMiddle,
			relationships: extractStructuredRelationships(contact.relationships),
			websites: extractStructuredWebsites(contact.websites),
			notes: contact.comment,
			title: contact.title ?? "",
			role: contact.role
		};
	}
	async disableSync(userId, login) {
		const userIdToRemove = userId ?? this.loginController.getUserController().userId;
		if (this.deviceConfig.getUserSyncContactsWithPhonePreference(userIdToRemove)) {
			this.deviceConfig.setUserSyncContactsWithPhonePreference(userIdToRemove, false);
			await this.mobileContactsFacade.deleteContacts(login ?? this.loginController.getUserController().loginUsername, null).catch(ofClass(PermissionError, (e) => console.log("No permission to clear contacts", e)));
		}
	}
	handleNoPermissionError(userId, error) {
		console.log("No permission to sync contacts, disabling sync", error);
		this.deviceConfig.setUserSyncContactsWithPhonePreference(userId, false);
	}
	async applyDeviceChangesToServerContacts(contacts, syncResult, listId) {
		const entityUpdateDefer = defer();
		this.entityUpdateLock = entityUpdateDefer.promise;
		await this.loginController.waitForFullLogin();
		for (const contact of syncResult.createdOnDevice) {
			const newContact = createContact(this.createContactFromNative(contact));
			const entityId = await this.entityClient.setup(listId, newContact);
			const loginUsername = this.loginController.getUserController().loginUsername;
			await this.mobileContactsFacade.saveContacts(loginUsername, [{
				...contact,
				id: entityId
			}]);
		}
		for (const contact of syncResult.editedOnDevice) {
			const cleanContact = contacts.find((c) => elementIdPart(c._id) === contact.id);
			if (cleanContact == null) console.warn("Could not find a server contact for the contact edited on device: ", contact.id);
else {
				const updatedContact = this.mergeNativeContactWithTutaContact(contact, cleanContact);
				try {
					await this.entityClient.update(updatedContact);
				} catch (e) {
					if (e instanceof NotFoundError) console.warn("Not found contact to update during sync: ", cleanContact._id, e);
else throw e;
				}
			}
		}
		for (const deletedContactId of syncResult.deletedOnDevice) {
			const cleanContact = contacts.find((c) => elementIdPart(c._id) === deletedContactId);
			if (cleanContact == null) console.warn("Could not find a server contact for the contact deleted on device: ", deletedContactId);
else try {
				await this.entityClient.erase(cleanContact);
			} catch (e) {
				if (e instanceof NotFoundError) console.warn("Not found contact to delete during sync: ", cleanContact._id, e);
else throw e;
			}
		}
		entityUpdateDefer.resolve();
	}
	createContactFromNative(contact) {
		return {
			_ownerGroup: getFirstOrThrow(this.loginController.getUserController().user.memberships.filter((membership) => membership.groupType === GroupType.Contact)).group,
			oldBirthdayDate: null,
			presharedPassword: null,
			oldBirthdayAggregate: null,
			photo: null,
			socialIds: [],
			firstName: contact.firstName,
			lastName: contact.lastName,
			mailAddresses: contact.mailAddresses.map((mail) => createContactMailAddress(mail)),
			phoneNumbers: contact.phoneNumbers.map((phone) => createContactPhoneNumber(phone)),
			nickname: contact.nickname,
			company: contact.company,
			birthdayIso: contact.birthday,
			addresses: contact.addresses.map((address) => createContactAddress(address)),
			customDate: contact.customDate.map((date) => createContactCustomDate(date)),
			department: contact.department,
			messengerHandles: contact.messengerHandles.map((handle) => createContactMessengerHandle(handle)),
			middleName: contact.middleName,
			nameSuffix: contact.nameSuffix,
			phoneticFirst: contact.phoneticFirst,
			phoneticLast: contact.phoneticLast,
			phoneticMiddle: contact.phoneticMiddle,
			pronouns: [],
			relationships: contact.relationships.map((relation) => createContactRelationship(relation)),
			websites: contact.websites.map((website) => createContactWebsite(website)),
			comment: contact.notes,
			title: contact.title ?? "",
			role: contact.role
		};
	}
	mergeNativeContactWithTutaContact(contact, partialContact) {
		const canMergeCommentField = !isIOSApp();
		return {
			...partialContact,
			firstName: contact.firstName,
			lastName: contact.lastName,
			mailAddresses: contact.mailAddresses.map((mail) => createContactMailAddress(mail)),
			phoneNumbers: contact.phoneNumbers.map((phone) => createContactPhoneNumber(phone)),
			nickname: contact.nickname,
			company: contact.company,
			birthdayIso: contact.birthday,
			addresses: contact.addresses.map((address) => createContactAddress(address)),
			customDate: contact.customDate.map((date) => createContactCustomDate(date)),
			department: contact.department,
			messengerHandles: contact.messengerHandles.map((handle) => createContactMessengerHandle(handle)),
			middleName: contact.middleName,
			nameSuffix: contact.nameSuffix,
			phoneticFirst: contact.phoneticFirst,
			phoneticLast: contact.phoneticLast,
			phoneticMiddle: contact.phoneticMiddle,
			relationships: contact.relationships.map((relation) => createContactRelationship(relation)),
			websites: contact.websites.map((website) => createContactWebsite(website)),
			comment: canMergeCommentField ? contact.notes : partialContact.comment,
			title: contact.title ?? "",
			role: contact.role
		};
	}
};

//#endregion
//#region ../src/common/gui/ThemeController.ts
var import_stream$1 = __toESM(require_stream(), 1);
assertMainOrNodeBoot();
const defaultThemeId = "light";
var ThemeController = class {
	theme;
	_themeId;
	_themePreference;
	observableThemeId;
	initialized;
	constructor(themeSingleton, themeFacade, htmlSanitizer, app) {
		this.themeFacade = themeFacade;
		this.htmlSanitizer = htmlSanitizer;
		this.app = app;
		this._themeId = defaultThemeId;
		this._themePreference = "auto:light|dark";
		this.theme = Object.assign(themeSingleton, this.getDefaultTheme());
		this.observableThemeId = (0, import_stream$1.default)(this.themeId);
		this.initialized = Promise.all([this._initializeTheme(), this.updateSavedBuiltinThemes()]);
	}
	async _initializeTheme() {
		const whitelabelCustomizations = getWhitelabelCustomizations(window);
		if (whitelabelCustomizations && whitelabelCustomizations.theme) {
			const assembledTheme = await this.applyCustomizations(whitelabelCustomizations.theme, false);
			this._themePreference = assembledTheme.themeId;
		} else {
			const themeJson = window.location.href ? new URL(window.location.href).searchParams.get("theme") : null;
			if ((isApp() || isDesktop()) && themeJson) {
				const parsedTheme = this.parseCustomizations(themeJson);
				await this.applyCustomizations(parsedTheme, false);
			}
			await this.setThemePreference(await this.themeFacade.getThemePreference() ?? this._themePreference);
		}
	}
	parseCustomizations(stringTheme) {
		return JSON.parse(stringTheme, (k, v) => k === "__proto__" ? undefined : v);
	}
	async updateSavedBuiltinThemes() {
		for (const theme$1 of typedValues(themes())) await this.updateSavedThemeDefinition(theme$1);
		const oldThemes = await this.themeFacade.getThemes();
		findAndRemove(oldThemes, (t) => t.themeId === "blue");
		await this.themeFacade.setThemes(oldThemes);
		const themePreference = await this.themeFacade.getThemePreference();
		if (!themePreference || themePreference !== "blue") return;
		await this.setThemePreference("auto:light|dark", true);
	}
	async reloadTheme() {
		const themePreference = await this.themeFacade.getThemePreference();
		if (!themePreference) return;
		await this.setThemePreference(themePreference, false);
	}
	get themeId() {
		return this._themeId;
	}
	get themePreference() {
		return this._themePreference;
	}
	async getTheme(themeId) {
		if (themes()[themeId]) return Object.assign({}, themes()[themeId]);
else {
			const loadedThemes = await this.themeFacade.getThemes();
			const customTheme = loadedThemes.find((t) => t.themeId === themeId);
			if (customTheme) {
				await this.sanitizeTheme(customTheme);
				return customTheme;
			} else return this.getDefaultTheme();
		}
	}
	getCurrentTheme() {
		return Object.assign({}, this.theme);
	}
	/**
	* Set the theme, if permanent is true then the locally saved theme will be updated
	*/
	async setThemePreference(newThemePreference, permanent = true) {
		const themeId = await this.resolveThemePreference(newThemePreference);
		const newTheme = await this.getTheme(themeId);
		this.applyTrustedTheme(newTheme, themeId);
		this._themePreference = newThemePreference;
		if (permanent) await this.themeFacade.setThemePreference(newThemePreference);
	}
	async resolveThemePreference(newThemePreference) {
		if (newThemePreference === "auto:light|dark") return await this.themeFacade.prefersDark() ? "dark" : "light";
else return newThemePreference;
	}
	applyTrustedTheme(newTheme, newThemeId) {
		for (const key of Object.keys(this.theme)) delete downcast(this.theme)[key];
		Object.assign(this.theme, this.getDefaultTheme(), newTheme);
		this._themeId = newThemeId;
		this.observableThemeId(newThemeId);
		mithril_default.redraw();
	}
	/**
	* Apply the custom theme, if permanent === true, then the new theme will be saved
	*/
	async applyCustomizations(customizations, permanent = true) {
		const updatedTheme = this.assembleTheme(customizations);
		const filledWithoutLogo = Object.assign({}, updatedTheme, { logo: "" });
		this.applyTrustedTheme(filledWithoutLogo, filledWithoutLogo.themeId);
		await this.sanitizeTheme(updatedTheme);
		this.applyTrustedTheme(updatedTheme, filledWithoutLogo.themeId);
		if (permanent) {
			this._themePreference = updatedTheme.themeId;
			await this.updateSavedThemeDefinition(updatedTheme);
			await this.themeFacade.setThemePreference(updatedTheme.themeId);
		}
		return updatedTheme;
	}
	async storeCustomThemeForCustomizations(customizations) {
		const newTheme = this.assembleTheme(customizations);
		await this.updateSavedThemeDefinition(newTheme);
	}
	async sanitizeTheme(theme$1) {
		if (theme$1.logo) {
			const logo = theme$1.logo;
			const htmlSanitizer = await this.htmlSanitizer();
			theme$1.logo = htmlSanitizer.sanitizeHTML(logo).html;
		}
	}
	/**
	* Save theme to the storage.
	*/
	async updateSavedThemeDefinition(updatedTheme) {
		const nonNullTheme = Object.assign({}, this.getDefaultTheme(), updatedTheme);
		await this.sanitizeTheme(nonNullTheme);
		const oldThemes = await this.themeFacade.getThemes();
		findAndRemove(oldThemes, (t) => t.themeId === updatedTheme.themeId);
		oldThemes.push(nonNullTheme);
		await this.themeFacade.setThemes(oldThemes);
		return nonNullTheme;
	}
	getDefaultTheme() {
		return Object.assign({}, themes()[defaultThemeId]);
	}
	getBaseTheme(baseId) {
		return Object.assign({}, themes()[baseId]);
	}
	shouldAllowChangingTheme() {
		return window.whitelabelCustomizations == null;
	}
	/**
	* Assembles a new theme object from customizations.
	*/
	assembleTheme(customizations) {
		if (!customizations.base) return Object.assign({}, customizations);
else if (customizations.base && customizations.logo) return Object.assign({}, this.getBaseTheme(customizations.base), customizations);
else {
			const themeWithoutLogo = Object.assign({}, this.getBaseTheme(customizations.base), customizations);
			const grayedLogo = this.app === AppType.Calendar ? getCalendarLogoSvg(logoDefaultGrey, logoDefaultGrey, logoDefaultGrey) : getMailLogoSvg(logoDefaultGrey, logoDefaultGrey, logoDefaultGrey);
			return {
				...themeWithoutLogo,
				...{ logo: grayedLogo }
			};
		}
	}
	async getCustomThemes() {
		return mapAndFilterNull(await this.themeFacade.getThemes(), (theme$1) => {
			return !(theme$1.themeId in themes()) ? theme$1.themeId : null;
		});
	}
};
var NativeThemeFacade = class {
	constructor(themeFacade) {
		this.themeFacade = themeFacade;
	}
	async getThemePreference() {
		const dispatcher = await this.themeFacade.getAsync();
		return dispatcher.getThemePreference();
	}
	async setThemePreference(theme$1) {
		const dispatcher = await this.themeFacade.getAsync();
		return dispatcher.setThemePreference(theme$1);
	}
	async getThemes() {
		const dispatcher = await this.themeFacade.getAsync();
		return await dispatcher.getThemes();
	}
	async setThemes(themes$1) {
		const dispatcher = await this.themeFacade.getAsync();
		return dispatcher.setThemes(themes$1);
	}
	async prefersDark() {
		const dispatcher = await this.themeFacade.getAsync();
		return dispatcher.prefersDark();
	}
};
var WebThemeFacade = class {
	mediaQuery = window.matchMedia?.("(prefers-color-scheme: dark)");
	constructor(deviceConfig$1) {
		this.deviceConfig = deviceConfig$1;
	}
	async getThemePreference() {
		return this.deviceConfig.getTheme();
	}
	async setThemePreference(theme$1) {
		return this.deviceConfig.setTheme(theme$1);
	}
	async getThemes() {
		return [];
	}
	async setThemes(themes$1) {}
	async prefersDark() {
		return this.mediaQuery?.matches ?? false;
	}
	addDarkListener(listener) {
		this.mediaQuery?.addEventListener("change", listener);
	}
};

//#endregion
//#region ../src/mail-app/mail/model/MailModel.ts
var import_stream = __toESM(require_stream(), 1);
let LabelState = function(LabelState$1) {
	/** Label was applied to all emails*/
	LabelState$1[LabelState$1["Applied"] = 0] = "Applied";
	/** Label was applied to some of the emails but not to others*/
	LabelState$1[LabelState$1["AppliedToSome"] = 1] = "AppliedToSome";
	/** Label was applied to none of the emails */
	LabelState$1[LabelState$1["NotApplied"] = 2] = "NotApplied";
	return LabelState$1;
}({});
var MailModel = class {
	mailboxCounters = (0, import_stream.default)({});
	/**
	* map from mailbox folders list to folder system
	*/
	mailSets = new Map();
	constructor(notifications$1, mailboxModel, eventController, entityClient, logins, mailFacade, connectivityModel, inboxRuleHandler) {
		this.notifications = notifications$1;
		this.mailboxModel = mailboxModel;
		this.eventController = eventController;
		this.entityClient = entityClient;
		this.logins = logins;
		this.mailFacade = mailFacade;
		this.connectivityModel = connectivityModel;
		this.inboxRuleHandler = inboxRuleHandler;
	}
	initListeners = lazyMemoized(() => {
		this.eventController.addEntityListener((updates) => this.entityEventsReceived(updates));
		this.eventController.getCountersStream().map((update) => {
			this._mailboxCountersUpdates(update);
		});
		this.mailboxModel.mailboxDetails.map(() => {
			this.loadMailSets().then((newFolders) => this.mailSets = newFolders);
		});
	});
	async init() {
		this.initListeners();
		this.mailSets = await this.loadMailSets();
	}
	async loadMailSets() {
		const mailboxDetails = await this.mailboxModel.getMailboxDetails();
		const tempFolders = new Map();
		for (let detail of mailboxDetails) if (detail.mailbox.folders) {
			const mailSets = await this.loadMailSetsForListId(neverNull(detail.mailbox.folders).folders);
			const [labels, folders] = partition(mailSets, isLabel);
			const labelsMap = collectToMap(labels, getElementId);
			const folderSystem = new FolderSystem(folders);
			tempFolders.set(detail.mailbox.folders._id, {
				folders: folderSystem,
				labels: labelsMap
			});
		}
		return tempFolders;
	}
	loadMailSetsForListId(listId) {
		return this.entityClient.loadAll(MailFolderTypeRef, listId).then((folders) => {
			return folders.filter((f) => {
				if (!this.logins.isInternalUserLoggedIn() && (f.folderType === MailSetKind.SPAM || f.folderType === MailSetKind.ARCHIVE)) return false;
else return !(this.logins.isEnabled(FeatureType.InternalCommunication) && f.folderType === MailSetKind.SPAM);
			});
		});
	}
	async getFolders() {
		if (this.mailSets.size === 0) return await this.loadMailSets();
else return this.mailSets;
	}
	async entityEventsReceived(updates) {
		for (const update of updates) if (isUpdateForTypeRef(MailFolderTypeRef, update)) {
			await this.init();
			mithril_default.redraw();
		} else if (isUpdateForTypeRef(MailTypeRef, update) && update.operation === OperationType.CREATE && !containsEventOfType(updates, OperationType.DELETE, update.instanceId)) {
			if (this.inboxRuleHandler && this.connectivityModel) {
				const mailId = [update.instanceListId, update.instanceId];
				try {
					const mail = await this.entityClient.load(MailTypeRef, mailId);
					const folder = this.getMailFolderForMail(mail);
					if (folder && folder.folderType === MailSetKind.INBOX) await this.getMailboxDetailsForMail(mail).then((mailboxDetail) => {
						return mailboxDetail && this.inboxRuleHandler?.findAndApplyMatchingRule(mailboxDetail, mail, this.connectivityModel ? this.connectivityModel.isLeader() : false);
					}).then((newFolderAndMail) => {
						if (newFolderAndMail) this._showNotification(newFolderAndMail.folder, newFolderAndMail.mail);
else this._showNotification(folder, mail);
					}).catch(noOp);
				} catch (e) {
					if (e instanceof NotFoundError) console.log(`Could not find updated mail ${JSON.stringify(mailId)}`);
else throw e;
				}
			}
		}
	}
	async getMailboxDetailsForMail(mail) {
		const detail = await this.mailboxModel.getMailboxDetailsForMailGroup(assertNotNull(mail._ownerGroup));
		if (detail == null) console.warn("Mailbox detail for mail does not exist", mail);
		return detail;
	}
	async getMailboxDetailsForMailFolder(mailFolder) {
		const detail = await this.mailboxModel.getMailboxDetailsForMailGroup(assertNotNull(mailFolder._ownerGroup));
		if (detail == null) console.warn("Mailbox detail for mail folder does not exist", mailFolder);
		return detail;
	}
	async getMailboxFoldersForMail(mail) {
		const mailboxDetail = await this.getMailboxDetailsForMail(mail);
		if (mailboxDetail && mailboxDetail.mailbox.folders) {
			const folders = await this.getFolders();
			return folders.get(mailboxDetail.mailbox.folders._id)?.folders ?? null;
		} else return null;
	}
	async getMailboxFoldersForId(foldersId) {
		const folderStructures = await this.loadMailSets();
		const folderSystem = folderStructures.get(foldersId)?.folders;
		if (folderSystem == null) throw new ProgrammingError(`no folder system for folder id ${foldersId}`);
		return folderSystem;
	}
	getMailFolderForMail(mail) {
		const folderSystem = this.getFolderSystemByGroupId(assertNotNull(mail._ownerGroup));
		if (folderSystem == null) return null;
		return folderSystem.getFolderByMail(mail);
	}
	getFolderSystemByGroupId(groupId) {
		return this.getMailSetsForGroup(groupId)?.folders ?? null;
	}
	getLabelsByGroupId(groupId) {
		return this.getMailSetsForGroup(groupId)?.labels ?? new Map();
	}
	/**
	* @return all labels that could be applied to the {@param mails} with the state relative to {@param mails}.
	*/
	getLabelStatesForMails(mails) {
		if (mails.length === 0) return [];
		const labels = this.getLabelsByGroupId(assertNotNull(getFirstOrThrow(mails)._ownerGroup));
		const allUsedSets = new Map();
		for (const mail of mails) for (const set of mail.sets) {
			const currentValue = allUsedSets.get(elementIdPart(set)) ?? 0;
			allUsedSets.set(elementIdPart(set), currentValue + 1);
		}
		return Array.from(labels.values()).map((label) => {
			const count = allUsedSets.get(getElementId(label)) ?? 0;
			const state = count === 0 ? LabelState.NotApplied : count === mails.length ? LabelState.Applied : LabelState.AppliedToSome;
			return {
				label,
				state
			};
		});
	}
	getLabelsForMails(mails) {
		const labelsForMails = new Map();
		for (const mail of mails) labelsForMails.set(getElementId(mail), this.getLabelsForMail(mail));
		return labelsForMails;
	}
	/**
	* @return labels that are currently applied to {@param mail}.
	*/
	getLabelsForMail(mail) {
		const groupLabels = this.getLabelsByGroupId(assertNotNull(mail._ownerGroup));
		return mail.sets.map((labelId) => groupLabels.get(elementIdPart(labelId))).filter(isNotNull);
	}
	getMailSetsForGroup(groupId) {
		const mailboxDetails = this.mailboxModel.mailboxDetails() || [];
		const detail = mailboxDetails.find((md) => groupId === md.mailGroup._id);
		const sets = detail?.mailbox?.folders?._id;
		if (sets == null) return null;
		return this.mailSets.get(sets) ?? null;
	}
	/**
	* Finally move all given mails. Caller must ensure that mails are only from
	* * one folder (because we send one source folder)
	* * from one list (for locking it on the server)
	*/
	async _moveMails(mails, targetMailFolder) {
		const sourceMailFolder = this.getMailFolderForMail(mails[0]);
		let moveMails = mails.filter((m) => sourceMailFolder !== targetMailFolder && targetMailFolder._ownerGroup === m._ownerGroup);
		if (moveMails.length > 0 && sourceMailFolder && !isSameId(targetMailFolder._id, sourceMailFolder._id)) {
			const mailChunks = splitInChunks(MAX_NBR_MOVE_DELETE_MAIL_SERVICE, mails.map((m) => m._id));
			for (const mailChunk of mailChunks) await this.mailFacade.moveMails(mailChunk, sourceMailFolder._id, targetMailFolder._id);
		}
	}
	/**
	* Preferably use moveMails() in MailGuiUtils.js which has built-in error handling
	* @throws PreconditionFailedError or LockedError if operation is locked on the server
	*/
	async moveMails(mails, targetMailFolder) {
		const mailsPerFolder = groupBy(mails, (mail) => {
			return this.getMailFolderForMail(mail)?._id?.[1];
		});
		for (const [folderId, mailsInFolder] of mailsPerFolder) {
			const sourceMailFolder = this.getMailFolderForMail(mailsInFolder[0]);
			if (sourceMailFolder) {
				const mailsPerList = groupBy(mailsInFolder, (mail) => getListId(mail));
				for (const [listId, mailsInList] of mailsPerList) await this._moveMails(mailsInList, targetMailFolder);
			} else console.log("Move mail: no mail folder for folder id", folderId);
		}
	}
	/**
	* Finally deletes the given mails if they are already in the trash or spam folders,
	* otherwise moves them to the trash folder.
	* A deletion confirmation must have been show before.
	*/
	async deleteMails(mails) {
		if (mails.length === 0) return;
		const mailsPerFolder = groupBy(mails, (mail) => {
			return this.getMailFolderForMail(mail)?._id?.[1];
		});
		const folders = await this.getMailboxFoldersForMail(mails[0]);
		if (folders == null) return;
		const trashFolder = assertNotNull(folders.getSystemFolderByType(MailSetKind.TRASH));
		for (const [folder, mailsInFolder] of mailsPerFolder) {
			const sourceMailFolder = this.getMailFolderForMail(mailsInFolder[0]);
			const mailsPerList = groupBy(mailsInFolder, (mail) => getListId(mail));
			for (const [listId, mailsInList] of mailsPerList) if (sourceMailFolder) if (isSpamOrTrashFolder(folders, sourceMailFolder)) await this.finallyDeleteMails(mailsInList);
else await this._moveMails(mailsInList, trashFolder);
else console.log("Delete mail: no mail folder for list id", folder);
		}
	}
	/**
	* Finally deletes all given mails. Caller must ensure that mails are only from one folder and the folder must allow final delete operation.
	*/
	async finallyDeleteMails(mails) {
		if (!mails.length) return Promise.resolve();
		const mailFolder = neverNull(this.getMailFolderForMail(mails[0]));
		const mailIds = mails.map((m) => m._id);
		const mailChunks = splitInChunks(MAX_NBR_MOVE_DELETE_MAIL_SERVICE, mailIds);
		for (const mailChunk of mailChunks) await this.mailFacade.deleteMails(mailChunk, mailFolder._id);
	}
	/**
	* Sends the given folder and all its descendants to the spam folder, reporting mails (if applicable) and removes any empty folders
	*/
	async sendFolderToSpam(folder) {
		const mailboxDetail = await this.getMailboxDetailsForMailFolder(folder);
		if (mailboxDetail == null) return;
		const folderSystem = this.getFolderSystemByGroupId(assertNotNull(folder._ownerGroup));
		if (folderSystem == null) return;
		const deletedFolder = await this.removeAllEmpty(folderSystem, folder);
		if (!deletedFolder) return this.mailFacade.updateMailFolderParent(folder, assertSystemFolderOfType(folderSystem, MailSetKind.SPAM)._id);
	}
	async reportMails(reportType, mails) {
		for (const mail of mails) await this.mailFacade.reportMail(mail, reportType).catch(ofClass(NotFoundError, (e) => console.log("mail to be reported not found", e)));
	}
	isMovingMailsAllowed() {
		return this.logins.getUserController().isInternalUser();
	}
	canManageLabels() {
		return this.logins.getUserController().isInternalUser();
	}
	canAssignLabels() {
		return this.logins.getUserController().isInternalUser();
	}
	isExportingMailsAllowed() {
		return !this.logins.isEnabled(FeatureType.DisableMailExport);
	}
	async markMails(mails, unread) {
		await pMap(mails, async (mail) => {
			if (mail.unread !== unread) {
				mail.unread = unread;
				return this.entityClient.update(mail).catch(ofClass(NotFoundError, noOp)).catch(ofClass(LockedError, noOp));
			}
		}, { concurrency: 5 });
	}
	async applyLabels(mails, addedLabels, removedLabels) {
		const groupedByListIds = groupBy(mails, (mail) => listIdPart(mail._id));
		for (const [_, groupedMails] of groupedByListIds) {
			const mailChunks = splitInChunks(MAX_NBR_MOVE_DELETE_MAIL_SERVICE, groupedMails);
			for (const mailChunk of mailChunks) await this.mailFacade.applyLabels(mailChunk, addedLabels, removedLabels);
		}
	}
	_mailboxCountersUpdates(counters) {
		const normalized = this.mailboxCounters() || {};
		const group = normalized[counters.mailGroup] || {};
		for (const value of counters.counterValues) group[value.counterId] = Number(value.count) || 0;
		normalized[counters.mailGroup] = group;
		this.mailboxCounters(normalized);
	}
	_showNotification(folder, mail) {
		this.notifications.showNotification(NotificationType.Mail, lang.get("newMails_msg"), { actions: [] }, (_) => {
			mithril_default.route.set(`/mail/${getElementId(folder)}/${getElementId(mail)}`);
			window.focus();
		});
	}
	getCounterValue(folder) {
		return this.getMailboxDetailsForMailFolder(folder).then((mailboxDetails) => {
			if (mailboxDetails == null) return null;
else {
				const mailGroupCounter = this.mailboxCounters()[mailboxDetails.mailGroup._id];
				if (mailGroupCounter) {
					const counterId = folder.isMailSet ? getElementId(folder) : folder.mails;
					return mailGroupCounter[counterId];
				} else return null;
			}
		}).catch(() => null);
	}
	checkMailForPhishing(mail, links) {
		return this.mailFacade.checkMailForPhishing(mail, links);
	}
	/**
	* Sends the given folder and all its descendants to the trash folder, removes any empty folders
	*/
	async trashFolderAndSubfolders(folder) {
		const mailboxDetail = await this.getMailboxDetailsForMailFolder(folder);
		if (mailboxDetail == null) return;
		const folderSystem = this.getFolderSystemByGroupId(assertNotNull(folder._ownerGroup));
		if (folderSystem == null) return;
		const deletedFolder = await this.removeAllEmpty(folderSystem, folder);
		if (!deletedFolder) {
			const trash = assertSystemFolderOfType(folderSystem, MailSetKind.TRASH);
			return this.mailFacade.updateMailFolderParent(folder, trash._id);
		}
	}
	/**
	* This is called when moving a folder to SPAM or TRASH, which do not allow empty folders (since only folders that contain mail are allowed)
	*/
	async removeAllEmpty(folderSystem, folder) {
		const descendants = folderSystem.getDescendantFoldersOfParent(folder._id).sort((l, r) => r.level - l.level);
		let someNonEmpty = false;
		const deleted = new Set();
		for (const descendant of descendants) if (await this.isEmptyFolder(descendant.folder) && folderSystem.getCustomFoldersOfParent(descendant.folder._id).every((f) => deleted.has(getElementId(f)))) {
			deleted.add(getElementId(descendant.folder));
			await this.finallyDeleteCustomMailFolder(descendant.folder);
		} else someNonEmpty = true;
		if (await this.isEmptyFolder(folder) && folderSystem.getCustomFoldersOfParent(folder._id).every((f) => deleted.has(getElementId(f))) && !someNonEmpty) {
			await this.finallyDeleteCustomMailFolder(folder);
			return true;
		} else return false;
	}
	async isEmptyFolder(descendant) {
		if (descendant.isMailSet) return (await this.entityClient.loadRange(MailSetEntryTypeRef, descendant.entries, CUSTOM_MIN_ID, 1, false)).length === 0;
else return (await this.entityClient.loadRange(MailTypeRef, descendant.mails, GENERATED_MAX_ID, 1, true)).length === 0;
	}
	async finallyDeleteCustomMailFolder(folder) {
		if (folder.folderType !== MailSetKind.CUSTOM && folder.folderType !== MailSetKind.Imported) throw new ProgrammingError("Cannot delete non-custom folder: " + String(folder._id));
		return await this.mailFacade.deleteFolder(folder._id).catch(ofClass(NotFoundError, () => console.log("mail folder already deleted"))).catch(ofClass(PreconditionFailedError, () => {
			throw new UserError("operationStillActive_msg");
		}));
	}
	async fixupCounterForFolder(folder, unreadMails) {
		const mailboxDetails = await this.getMailboxDetailsForMailFolder(folder);
		if (mailboxDetails) await this.mailFacade.fixupCounterForFolder(mailboxDetails.mailGroup._id, folder, unreadMails);
	}
	async clearFolder(folder) {
		await this.mailFacade.clearFolder(folder._id);
	}
	async unsubscribe(mail, recipient, headers) {
		await this.mailFacade.unsubscribe(mail._id, recipient, headers);
	}
	async saveReportMovedMails(mailboxGroupRoot, reportMovedMails) {
		const mailboxProperties = await this.mailboxModel.loadOrCreateMailboxProperties(mailboxGroupRoot);
		mailboxProperties.reportMovedMails = reportMovedMails;
		await this.entityClient.update(mailboxProperties);
		return mailboxProperties;
	}
	/**
	* Create a label (aka MailSet aka {@link MailFolder} of kind {@link MailSetKind.LABEL}) for the group {@param mailGroupId}.
	*/
	async createLabel(mailGroupId, labelData) {
		await this.mailFacade.createLabel(mailGroupId, labelData);
	}
	async updateLabel(label, newData) {
		await this.mailFacade.updateLabel(label, newData.name, newData.color);
	}
	async deleteLabel(label) {
		await this.mailFacade.deleteLabel(label);
	}
	async getMailSetById(folderElementId) {
		const folderStructures = await this.loadMailSets();
		for (const folders of folderStructures.values()) {
			const folder = folders.folders.getFolderById(folderElementId);
			if (folder) return folder;
			const label = folders.labels.get(folderElementId);
			if (label) return label;
		}
		return null;
	}
	getImportedMailSets() {
		return [...this.mailSets.values()].filter((f) => f.folders.importedMailSet).map((f) => f.folders.importedMailSet);
	}
};

//#endregion
//#region ../src/common/api/common/utils/EstimatingProgressMonitor.ts
const DEFAULT_RATE_PER_SECOND = .5;
const DEFAULT_PROGRESS_ESTIMATION_REFRESH_MS = 1e3;
const MINIMUM_HISTORY_LENGTH_FOR_ESTIMATION = 3;
const RATE_PER_SECOND_MAXIMUM_SCALING_RATIO = .75;
const WORK_MAX_PERCENTAGE = 100;
const WORK_COMPLETED_MIN = 0;
var EstimatingProgressMonitor = class {
	workCompleted;
	ratePerSecondHistory = Array.of([Date.now(), DEFAULT_RATE_PER_SECOND]);
	totalWork;
	progressEstimation;
	constructor(totalWork, updater) {
		this.updater = updater;
		this.workCompleted = WORK_COMPLETED_MIN;
		this.totalWork = totalWork;
	}
	updateTotalWork(value) {
		this.totalWork = value;
	}
	continueEstimation() {
		clearInterval(this.progressEstimation);
		this.progressEstimation = setInterval(() => {
			if (this.ratePerSecondHistory.length < MINIMUM_HISTORY_LENGTH_FOR_ESTIMATION) this.workEstimate(DEFAULT_RATE_PER_SECOND);
else {
				const previousRateEntry = this.ratePerSecondHistory[this.ratePerSecondHistory.length - 2];
				const previousRateEntryTimestamp = first(previousRateEntry);
				const lastRateEntry = last(this.ratePerSecondHistory);
				const lastRateEntryTimestamp = first(lastRateEntry);
				const lastRatePerSecond = last(lastRateEntry);
				let lastDurationBetweenRatePerSecondUpdatesMs = lastRateEntryTimestamp - previousRateEntryTimestamp;
				let currentDurationMs = Date.now() - lastRateEntryTimestamp;
				let ratePerSecondScalingRatio = Math.min(RATE_PER_SECOND_MAXIMUM_SCALING_RATIO, lastDurationBetweenRatePerSecondUpdatesMs / currentDurationMs);
				let newRatePerSecondEstimate = lastRatePerSecond * ratePerSecondScalingRatio;
				let workDoneEstimation = Math.max(DEFAULT_RATE_PER_SECOND, newRatePerSecondEstimate);
				if (this.workCompleted + workDoneEstimation < this.totalWork) this.workEstimate(workDoneEstimation);
			}
		}, DEFAULT_PROGRESS_ESTIMATION_REFRESH_MS);
	}
	pauseEstimation() {
		clearInterval(this.progressEstimation);
		this.ratePerSecondHistory = Array.of([Date.now(), DEFAULT_RATE_PER_SECOND]);
	}
	updateRatePerSecond(newWorkAmount) {
		let lastRateEntry = last(this.ratePerSecondHistory);
		let lastTimestamp = first(lastRateEntry);
		let now = Date.now();
		let durationSinceLastRateEntrySeconds = (now - lastTimestamp) / 1e3;
		let ratePerSecond = newWorkAmount / durationSinceLastRateEntrySeconds;
		let newRateEntry = [now, ratePerSecond];
		this.ratePerSecondHistory.push(newRateEntry);
	}
	workEstimate(estimate) {
		this.workCompleted += estimate;
		this.updater(this.percentage());
	}
	workDone(amount) {
		this.updateRatePerSecond(amount);
		this.workCompleted += amount;
		this.updater(this.percentage());
	}
	totalWorkDone(totalAmount) {
		let workDifference = totalAmount - this.workCompleted;
		this.updateRatePerSecond(workDifference);
		this.workCompleted = totalAmount;
		this.updater(this.percentage());
	}
	percentage() {
		const result = WORK_MAX_PERCENTAGE * this.workCompleted / this.totalWork;
		return Math.min(WORK_MAX_PERCENTAGE, result);
	}
	completed() {
		this.workCompleted = this.totalWork;
		this.updater(WORK_MAX_PERCENTAGE);
	}
};

//#endregion
//#region ../src/mail-app/mail/import/MailImporter.ts
let ImportProgressAction = function(ImportProgressAction$1) {
	ImportProgressAction$1[ImportProgressAction$1["Continue"] = 0] = "Continue";
	ImportProgressAction$1[ImportProgressAction$1["Pause"] = 1] = "Pause";
	ImportProgressAction$1[ImportProgressAction$1["Stop"] = 2] = "Stop";
	return ImportProgressAction$1;
}({});
const DEFAULT_TOTAL_WORK = 1e4;
var MailImporter = class {
	finalisedImportStates = new Map();
	activeImport = null;
	foldersForMailbox;
	selectedTargetFolder = null;
	constructor(domainConfigProvider, loginController, mailboxModel, entityClient, eventController, credentialsProvider, nativeMailImportFacade, openSettingsHandler) {
		this.domainConfigProvider = domainConfigProvider;
		this.loginController = loginController;
		this.mailboxModel = mailboxModel;
		this.entityClient = entityClient;
		this.credentialsProvider = credentialsProvider;
		this.nativeMailImportFacade = nativeMailImportFacade;
		this.openSettingsHandler = openSettingsHandler;
		eventController.addEntityListener((updates) => this.entityEventsReceived(updates));
	}
	async getMailbox() {
		return assertNotNull(first(await this.mailboxModel.getMailboxDetails())).mailbox;
	}
	async initImportMailStates() {
		await this.checkForResumableImport();
		const importMailStatesCollection = await this.entityClient.loadAll(ImportMailStateTypeRef, (await this.getMailbox()).mailImportStates);
		for (const importMailState of importMailStatesCollection) if (this.isFinalisedImport(importMailState)) this.updateFinalisedImport(elementIdPart(importMailState._id), importMailState);
		mithril_default.redraw();
	}
	async checkForResumableImport() {
		const importFacade = assertNotNull(this.nativeMailImportFacade);
		const mailbox = await this.getMailbox();
		this.foldersForMailbox = this.getFoldersForMailGroup(assertNotNull(mailbox._ownerGroup));
		this.selectedTargetFolder = this.foldersForMailbox.getSystemFolderByType(MailSetKind.INBOX);
		let activeImportId = null;
		if (this.activeImport === null) {
			const mailOwnerGroupId = assertNotNull(mailbox._ownerGroup);
			const userId = this.loginController.getUserController().userId;
			const unencryptedCredentials = assertNotNull(await this.credentialsProvider?.getDecryptedCredentialsByUserId(userId));
			const apiUrl = getApiBaseUrl(this.domainConfigProvider.getCurrentDomainConfig());
			try {
				activeImportId = await importFacade.getResumableImport(mailbox._id, mailOwnerGroupId, unencryptedCredentials, apiUrl);
			} catch (e) {
				if (e instanceof MailImportError) this.handleError(e).catch();
else throw e;
			}
			this.listenForError(importFacade, mailbox._id).then();
		}
		if (activeImportId) {
			const importMailState = await this.entityClient.load(ImportMailStateTypeRef, activeImportId);
			const remoteStatus = parseInt(importMailState.status);
			switch (remoteStatus) {
				case ImportStatus.Canceled:
				case ImportStatus.Finished:
					activeImportId = null;
					this.activeImport = null;
					this.selectedTargetFolder = this.foldersForMailbox.getSystemFolderByType(MailSetKind.INBOX);
					break;
				case ImportStatus.Paused:
				case ImportStatus.Running: {
					let progressMonitor = this.activeImport?.progressMonitor ?? null;
					if (!progressMonitor) {
						const totalCount = parseInt(importMailState.totalMails);
						const doneCount = parseInt(importMailState.failedMails) + parseInt(importMailState.successfulMails);
						progressMonitor = this.createEstimatingProgressMonitor(totalCount);
						progressMonitor.totalWorkDone(doneCount);
					}
					this.activeImport = {
						remoteStateId: activeImportId,
						uiStatus: UiImportStatus.Paused,
						progressMonitor
					};
					this.selectedTargetFolder = await this.entityClient.load(MailFolderTypeRef, importMailState.targetFolder);
				}
			}
		}
	}
	async entityEventsReceived(updates) {
		for (const update of updates) if (isUpdateForTypeRef(ImportMailStateTypeRef, update)) {
			const updatedState = await this.entityClient.load(ImportMailStateTypeRef, [update.instanceListId, update.instanceId]);
			await this.newImportStateFromServer(updatedState);
		}
	}
	async newImportStateFromServer(serverState) {
		const remoteStatus = parseInt(serverState.status);
		const wasUpdatedForThisImport = this.activeImport !== null && isSameId(this.activeImport.remoteStateId, serverState._id);
		if (wasUpdatedForThisImport) if (isFinalisedImport(remoteStatus)) {
			this.resetStatus();
			this.updateFinalisedImport(elementIdPart(serverState._id), serverState);
		} else {
			const activeImport = assertNotNull(this.activeImport);
			activeImport.uiStatus = importStatusToUiImportStatus(remoteStatus);
			const newTotalWork = parseInt(serverState.totalMails);
			const newDoneWork = parseInt(serverState.successfulMails) + parseInt(serverState.failedMails);
			activeImport.progressMonitor.updateTotalWork(newTotalWork);
			activeImport.progressMonitor.totalWorkDone(newDoneWork);
			if (remoteStatus === ImportStatus.Paused) activeImport.progressMonitor.pauseEstimation();
else activeImport.progressMonitor.continueEstimation();
		}
else this.updateFinalisedImport(elementIdPart(serverState._id), serverState);
		mithril_default.redraw();
	}
	createEstimatingProgressMonitor(totalWork = DEFAULT_TOTAL_WORK) {
		return new EstimatingProgressMonitor(totalWork, (_) => {
			mithril_default.redraw();
		});
	}
	isFinalisedImport(importMailState) {
		return parseInt(importMailState.status) == ImportStatus.Finished || parseInt(importMailState.status) == ImportStatus.Canceled;
	}
	getFoldersForMailGroup(mailGroupId) {
		if (mailGroupId) {
			const folderSystem = mailLocator.mailModel.getFolderSystemByGroupId(mailGroupId);
			if (folderSystem) return folderSystem;
		}
		throw new Error("could not load folder list");
	}
	async listenForError(importFacade, mailboxId) {
		while (true) {
			try {
				await importFacade.setAsyncErrorHook(mailboxId);
			} catch (e) {
				if (e instanceof MailImportError) {
					this.handleError(e).catch();
					continue;
				}
				throw e;
			}
			throw new ProgrammingError("setAsyncErrorHook should never complete normally!");
		}
	}
	async handleError(err) {
		if (err.data.category == ImportErrorCategories.ImportFeatureDisabled) {
			if (this.activeImport) this.activeImport.uiStatus = UiImportStatus.Paused;
			await Dialog.message("mailImportErrorServiceUnavailable_msg");
		} else if (err.data.category == ImportErrorCategories.ConcurrentImport) {
			console.log("Tried to start concurrent import");
			showSnackBar({
				message: "pleaseWait_msg",
				button: {
					label: "ok_action",
					click: () => {}
				}
			});
		} else {
			console.log(`Error while importing mails, category: ${err.data.category}, source: ${err.data.source}`);
			const navigateToImportSettings = {
				label: "show_action",
				click: () => this.openSettingsHandler.openSettings("mailImport")
			};
			showSnackBar({
				message: "someMailFailedImport_msg",
				button: navigateToImportSettings
			});
		}
	}
	/**
	* Call to the nativeMailImportFacade in worker to start a mail import from .eml or .mbox files.
	* @param filePaths to the .eml/.mbox files to import mails from
	*/
	async onStartBtnClick(filePaths) {
		if (isEmpty(filePaths)) return;
		if (!this.shouldRenderStartButton()) throw new ProgrammingError("can't change state to starting");
		const apiUrl = getApiBaseUrl(this.domainConfigProvider.getCurrentDomainConfig());
		const mailbox = await this.getMailbox();
		const mailboxId = mailbox._id;
		const mailOwnerGroupId = assertNotNull(mailbox._ownerGroup);
		const userId = this.loginController.getUserController().userId;
		const importFacade = assertNotNull(this.nativeMailImportFacade);
		const selectedTargetFolder = assertNotNull(this.selectedTargetFolder);
		const unencryptedCredentials = assertNotNull(await this.credentialsProvider?.getDecryptedCredentialsByUserId(userId));
		this.resetStatus();
		let progressMonitor = this.createEstimatingProgressMonitor();
		this.activeImport = {
			remoteStateId: [GENERATED_MIN_ID, GENERATED_MIN_ID],
			uiStatus: UiImportStatus.Starting,
			progressMonitor
		};
		this.activeImport?.progressMonitor?.continueEstimation();
		mithril_default.redraw();
		try {
			this.activeImport.remoteStateId = await importFacade.prepareNewImport(mailboxId, mailOwnerGroupId, selectedTargetFolder._id, filePaths, unencryptedCredentials, apiUrl);
		} catch (e) {
			if (e instanceof MailImportError) this.handleError(e).catch();
else throw e;
		}
		await importFacade.setProgressAction(mailboxId, ImportProgressAction.Continue);
	}
	async onPauseBtnClick() {
		let activeImport = assertNotNull(this.activeImport);
		if (activeImport.uiStatus !== UiImportStatus.Running) throw new ProgrammingError("can't change state to pausing");
		activeImport.uiStatus = UiImportStatus.Pausing;
		activeImport.progressMonitor.pauseEstimation();
		mithril_default.redraw();
		const mailboxId = (await this.getMailbox())._id;
		const nativeImportFacade = assertNotNull(this.nativeMailImportFacade);
		await nativeImportFacade.setProgressAction(mailboxId, ImportProgressAction.Pause);
	}
	async onResumeBtnClick() {
		if (!this.shouldRenderResumeButton()) throw new ProgrammingError("can't change state to resuming");
		let activeImport = assertNotNull(this.activeImport);
		activeImport.uiStatus = UiImportStatus.Resuming;
		activeImport.progressMonitor.continueEstimation();
		mithril_default.redraw();
		const mailboxId = (await this.getMailbox())._id;
		const nativeImportFacade = assertNotNull(this.nativeMailImportFacade);
		await nativeImportFacade.setProgressAction(mailboxId, ImportProgressAction.Continue);
	}
	async onCancelBtnClick() {
		if (!this.shouldRenderCancelButton()) throw new ProgrammingError("can't change state to cancelling");
		let activeImport = assertNotNull(this.activeImport);
		activeImport.uiStatus = UiImportStatus.Cancelling;
		activeImport.progressMonitor.pauseEstimation();
		mithril_default.redraw();
		const mailboxId = (await this.getMailbox())._id;
		const nativeImportFacade = assertNotNull(this.nativeMailImportFacade);
		await nativeImportFacade.setProgressAction(mailboxId, ImportProgressAction.Stop);
	}
	shouldRenderStartButton() {
		return this.activeImport === null;
	}
	shouldRenderImportStatus() {
		const activeImportStatus = this.getUiStatus();
		if (activeImportStatus === null) return false;
		return activeImportStatus === UiImportStatus.Starting || activeImportStatus === UiImportStatus.Running || activeImportStatus === UiImportStatus.Pausing || activeImportStatus === UiImportStatus.Paused || activeImportStatus === UiImportStatus.Cancelling || activeImportStatus === UiImportStatus.Resuming;
	}
	shouldRenderPauseButton() {
		const activeImportStatus = this.getUiStatus();
		if (activeImportStatus === null) return false;
		return activeImportStatus === UiImportStatus.Running || activeImportStatus === UiImportStatus.Starting || activeImportStatus === UiImportStatus.Pausing;
	}
	shouldDisablePauseButton() {
		const activeImportStatus = this.getUiStatus();
		if (activeImportStatus === null) return false;
		return activeImportStatus === UiImportStatus.Pausing || activeImportStatus === UiImportStatus.Starting;
	}
	shouldRenderResumeButton() {
		const activeImportStatus = this.getUiStatus();
		if (activeImportStatus === null) return false;
		return activeImportStatus === UiImportStatus.Paused || activeImportStatus === UiImportStatus.Resuming;
	}
	shouldDisableResumeButton() {
		const activeImportStatus = this.getUiStatus();
		if (activeImportStatus === null) return false;
		return activeImportStatus === UiImportStatus.Resuming || activeImportStatus === UiImportStatus.Starting;
	}
	shouldRenderCancelButton() {
		const activeImportStatus = this.getUiStatus();
		if (activeImportStatus === null) return false;
		return activeImportStatus === UiImportStatus.Paused || activeImportStatus === UiImportStatus.Running || activeImportStatus === UiImportStatus.Pausing || activeImportStatus === UiImportStatus.Cancelling;
	}
	shouldDisableCancelButton() {
		const activeImportStatus = this.getUiStatus();
		return activeImportStatus === UiImportStatus.Cancelling || activeImportStatus === UiImportStatus.Pausing || activeImportStatus === UiImportStatus.Starting;
	}
	shouldRenderProcessedMails() {
		const activeImportStatus = this.getUiStatus();
		return this.activeImport?.progressMonitor?.totalWork != DEFAULT_TOTAL_WORK && (activeImportStatus === UiImportStatus.Running || activeImportStatus === UiImportStatus.Resuming || activeImportStatus === UiImportStatus.Pausing || activeImportStatus === UiImportStatus.Paused);
	}
	getTotalMailsCount() {
		return assertNotNull(this.activeImport).progressMonitor.totalWork;
	}
	getProcessedMailsCount() {
		const progressMonitor = assertNotNull(this.activeImport).progressMonitor;
		return Math.min(Math.round(progressMonitor.workCompleted), progressMonitor.totalWork);
	}
	getProgress() {
		const progressMonitor = assertNotNull(this.activeImport).progressMonitor;
		return Math.ceil(progressMonitor.percentage());
	}
	getFinalisedImports() {
		return Array.from(this.finalisedImportStates.values());
	}
	updateFinalisedImport(importMailStateElementId, importMailState) {
		this.finalisedImportStates.set(importMailStateElementId, importMailState);
	}
	resetStatus() {
		this.activeImport = null;
	}
	getUiStatus() {
		return this.activeImport?.uiStatus ?? null;
	}
};
let UiImportStatus = function(UiImportStatus$1) {
	UiImportStatus$1[UiImportStatus$1["Starting"] = 0] = "Starting";
	UiImportStatus$1[UiImportStatus$1["Resuming"] = 1] = "Resuming";
	UiImportStatus$1[UiImportStatus$1["Running"] = 2] = "Running";
	UiImportStatus$1[UiImportStatus$1["Pausing"] = 3] = "Pausing";
	UiImportStatus$1[UiImportStatus$1["Paused"] = 4] = "Paused";
	UiImportStatus$1[UiImportStatus$1["Cancelling"] = 5] = "Cancelling";
	return UiImportStatus$1;
}({});
function importStatusToUiImportStatus(importStatus) {
	switch (importStatus) {
		case ImportStatus.Finished: return UiImportStatus.Running;
		case ImportStatus.Canceled: return UiImportStatus.Cancelling;
		case ImportStatus.Paused: return UiImportStatus.Paused;
		case ImportStatus.Running: return UiImportStatus.Running;
	}
}
function isFinalisedImport(remoteImportStatus) {
	return remoteImportStatus == ImportStatus.Canceled || remoteImportStatus == ImportStatus.Finished;
}

//#endregion
//#region ../src/mail-app/mailLocator.ts
assertMainOrNode();
var MailLocator = class {
	eventController;
	search;
	mailboxModel;
	mailModel;
	minimizedMailModel;
	contactModel;
	entityClient;
	progressTracker;
	credentialsProvider;
	worker;
	fileController;
	secondFactorHandler;
	webAuthn;
	loginFacade;
	logins;
	header;
	customerFacade;
	keyLoaderFacade;
	giftCardFacade;
	groupManagementFacade;
	configFacade;
	calendarFacade;
	mailFacade;
	shareFacade;
	counterFacade;
	indexerFacade;
	searchFacade;
	bookingFacade;
	mailAddressFacade;
	blobFacade;
	userManagementFacade;
	recoverCodeFacade;
	contactFacade;
	usageTestController;
	usageTestModel;
	newsModel;
	serviceExecutor;
	cryptoFacade;
	searchTextFacade;
	desktopSettingsFacade;
	desktopSystemFacade;
	exportFacade;
	webMobileFacade;
	systemPermissionHandler;
	interWindowEventSender;
	cacheStorage;
	workerFacade;
	loginListener;
	random;
	connectivityModel;
	operationProgressTracker;
	infoMessageHandler;
	themeController;
	Const;
	bulkMailLoader;
	mailExportFacade;
	nativeInterfaces = null;
	mailImporter = null;
	entropyFacade;
	sqlCipherFacade;
	recipientsModel = lazyMemoized(async () => {
		const { RecipientsModel } = await import("./RecipientsModel-CPX3mti_.js");
		return new RecipientsModel(this.contactModel, this.logins, this.mailFacade, this.entityClient);
	});
	async noZoneDateProvider() {
		return new NoZoneDateProvider();
	}
	async sendMailModel(mailboxDetails, mailboxProperties) {
		const factory = await this.sendMailModelSyncFactory(mailboxDetails, mailboxProperties);
		return factory();
	}
	redraw = lazyMemoized(async () => {
		const m = await import("./mithril-BIaOo3Yj.js");
		return m.redraw;
	});
	offlineIndicatorViewModel = lazyMemoized(async () => {
		return new OfflineIndicatorViewModel(this.cacheStorage, this.loginListener, this.connectivityModel, this.logins, this.progressTracker, await this.redraw());
	});
	async appHeaderAttrs() {
		return {
			offlineIndicatorModel: await this.offlineIndicatorViewModel(),
			newsModel: this.newsModel
		};
	}
	mailViewModel = lazyMemoized(async () => {
		const { MailViewModel } = await import("./MailViewModel-BI0SdEEY.js");
		const conversationViewModelFactory = await this.conversationViewModelFactory();
		const router = new ScopedRouter(this.throttledRouter(), "/mail");
		return new MailViewModel(this.mailboxModel, this.mailModel, this.entityClient, this.eventController, this.connectivityModel, this.cacheStorage, conversationViewModelFactory, this.mailOpenedListener, deviceConfig, this.inboxRuleHanlder(), router, await this.redraw());
	});
	affiliateViewModel = lazyMemoized(async () => {
		const { AffiliateViewModel } = await import("./AffiliateViewModel-CrQG3TA2.js");
		return new AffiliateViewModel();
	});
	inboxRuleHanlder() {
		return new InboxRuleHandler(this.mailFacade, this.logins);
	}
	async searchViewModelFactory() {
		const { SearchViewModel } = await import("./SearchViewModel-D1L5qbZi.js");
		const conversationViewModelFactory = await this.conversationViewModelFactory();
		const redraw = await this.redraw();
		const searchRouter = await this.scopedSearchRouter();
		const calendarEventsRepository = await this.calendarEventsRepository();
		return () => {
			return new SearchViewModel(searchRouter, this.search, this.searchFacade, this.mailboxModel, this.logins, this.indexerFacade, this.entityClient, this.eventController, this.mailOpenedListener, this.calendarFacade, this.progressTracker, conversationViewModelFactory, calendarEventsRepository, redraw, deviceConfig.getMailAutoSelectBehavior(), deviceConfig.getClientOnlyCalendars());
		};
	}
	throttledRouter = lazyMemoized(() => new ThrottledRouter());
	scopedSearchRouter = lazyMemoized(async () => {
		const { SearchRouter } = await import("./SearchRouter-5YtVBwm8.js");
		return new SearchRouter(new ScopedRouter(this.throttledRouter(), "/search"));
	});
	unscopedSearchRouter = lazyMemoized(async () => {
		const { SearchRouter } = await import("./SearchRouter-5YtVBwm8.js");
		return new SearchRouter(this.throttledRouter());
	});
	mailOpenedListener = { onEmailOpened: isDesktop() ? (mail) => {
		this.desktopSystemFacade.sendSocketMessage(getDisplayedSender(mail).address);
	} : noOp };
	contactViewModel = lazyMemoized(async () => {
		const { ContactViewModel } = await import("./ContactViewModel-O-d13L3K.js");
		const router = new ScopedRouter(this.throttledRouter(), "/contact");
		return new ContactViewModel(this.contactModel, this.entityClient, this.eventController, router, await this.redraw());
	});
	contactListViewModel = lazyMemoized(async () => {
		const { ContactListViewModel } = await import("./ContactListViewModel-DP1b6VfQ.js");
		const router = new ScopedRouter(this.throttledRouter(), "/contactlist");
		return new ContactListViewModel(this.entityClient, this.groupManagementFacade, this.logins, this.eventController, this.contactModel, await this.receivedGroupInvitationsModel(GroupType.ContactList), router, await this.redraw());
	});
	async receivedGroupInvitationsModel(groupType) {
		const { ReceivedGroupInvitationsModel } = await import("./ReceivedGroupInvitationsModel-DKwkvrTP.js");
		return new ReceivedGroupInvitationsModel(groupType, this.eventController, this.entityClient, this.logins);
	}
	calendarViewModel = lazyMemoized(async () => {
		const { CalendarViewModel } = await import("./CalendarViewModel-c8xTfN7M.js");
		const { DefaultDateProvider } = await import("./CalendarUtils-DwR144gS.js");
		const timeZone = new DefaultDateProvider().timeZone();
		return new CalendarViewModel(this.logins, async (mode, event) => {
			const mailboxDetail = await this.mailboxModel.getUserMailboxDetails();
			const mailboxProperties = await this.mailboxModel.getMailboxProperties(mailboxDetail.mailboxGroupRoot);
			return await this.calendarEventModel(mode, event, mailboxDetail, mailboxProperties, null);
		}, (...args) => this.calendarEventPreviewModel(...args), (...args) => this.calendarContactPreviewModel(...args), await this.calendarModel(), await this.calendarEventsRepository(), this.entityClient, this.eventController, this.progressTracker, deviceConfig, await this.receivedGroupInvitationsModel(GroupType.Calendar), timeZone, this.mailboxModel, this.contactModel);
	});
	calendarEventsRepository = lazyMemoized(async () => {
		const { CalendarEventsRepository } = await import("./CalendarEventsRepository-JvaV7bn1.js");
		const { DefaultDateProvider } = await import("./CalendarUtils-DwR144gS.js");
		const timeZone = new DefaultDateProvider().timeZone();
		return new CalendarEventsRepository(await this.calendarModel(), this.calendarFacade, timeZone, this.entityClient, this.eventController, this.contactModel, this.logins);
	});
	/** This ugly bit exists because CalendarEventWhoModel wants a sync factory. */
	async sendMailModelSyncFactory(mailboxDetails, mailboxProperties) {
		const { SendMailModel } = await import("./SendMailModel-D_Jzx0yO.js");
		const recipientsModel = await this.recipientsModel();
		const dateProvider = await this.noZoneDateProvider();
		return () => new SendMailModel(this.mailFacade, this.entityClient, this.logins, this.mailboxModel, this.contactModel, this.eventController, mailboxDetails, recipientsModel, dateProvider, mailboxProperties, async (mail) => {
			return await isMailInSpamOrTrash(mail, mailLocator.mailModel);
		});
	}
	async calendarEventModel(editMode, event, mailboxDetail, mailboxProperties, responseTo) {
		const [{ makeCalendarEventModel }, { getTimeZone }, { calendarNotificationSender }] = await Promise.all([
			import("./CalendarEventModel-DAxkK4N0.js"),
			import("./CalendarUtils-DwR144gS.js"),
			import("./CalendarNotificationSender-DoWbzuto.js")
		]);
		const sendMailModelFactory = await this.sendMailModelSyncFactory(mailboxDetail, mailboxProperties);
		const showProgress = (p) => showProgressDialog("pleaseWait_msg", p);
		return await makeCalendarEventModel(editMode, event, await this.recipientsModel(), await this.calendarModel(), this.logins, mailboxDetail, mailboxProperties, sendMailModelFactory, calendarNotificationSender, this.entityClient, responseTo, getTimeZone(), showProgress);
	}
	async recipientsSearchModel() {
		const { RecipientsSearchModel } = await import("./RecipientsSearchModel-CWgbkZTK.js");
		const suggestionsProvider = await this.contactSuggestionProvider();
		return new RecipientsSearchModel(await this.recipientsModel(), this.contactModel, suggestionsProvider, this.entityClient);
	}
	async contactSuggestionProvider() {
		if (isApp()) {
			const { MobileContactSuggestionProvider } = await import("./MobileContactSuggestionProvider-Cgo5GUEb.js");
			return new MobileContactSuggestionProvider(this.mobileContactsFacade);
		} else return { async getContactSuggestions(_query) {
			return [];
		} };
	}
	conversationViewModelFactory = async () => {
		const { ConversationViewModel } = await import("./ConversationViewModel-Bu6Ag3K0.js");
		const factory = await this.mailViewerViewModelFactory();
		const m = await import("./mithril-BIaOo3Yj.js");
		return (options) => {
			return new ConversationViewModel(options, (options$1) => factory(options$1), this.entityClient, this.eventController, deviceConfig, this.mailModel, m.redraw);
		};
	};
	async conversationViewModel(options) {
		const factory = await this.conversationViewModelFactory();
		return factory(options);
	}
	contactImporter = async () => {
		const { ContactImporter } = await import("./ContactImporter-D5ZB41b5.js");
		return new ContactImporter(this.contactFacade, this.systemPermissionHandler, isApp() ? this.mobileContactsFacade : null, isApp() ? this.nativeContactsSyncManager() : null);
	};
	async mailViewerViewModelFactory() {
		const { MailViewerViewModel } = await import("./MailViewerViewModel-CF4JmEVI.js");
		return ({ mail, showFolder }) => new MailViewerViewModel(mail, showFolder, this.entityClient, this.mailboxModel, this.mailModel, this.contactModel, this.configFacade, this.fileController, this.logins, async (mailboxDetails) => {
			const mailboxProperties = await this.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot);
			return this.sendMailModel(mailboxDetails, mailboxProperties);
		}, this.eventController, this.workerFacade, this.search, this.mailFacade, this.cryptoFacade, () => this.contactImporter());
	}
	async externalLoginViewModelFactory() {
		const { ExternalLoginViewModel } = await import("./ExternalLoginView-CWVJkcn6.js");
		return () => new ExternalLoginViewModel(this.credentialsProvider);
	}
	get deviceConfig() {
		return deviceConfig;
	}
	get native() {
		return this.getNativeInterface("native");
	}
	get fileApp() {
		return this.getNativeInterface("fileApp");
	}
	get pushService() {
		return this.getNativeInterface("pushService");
	}
	get commonSystemFacade() {
		return this.getNativeInterface("commonSystemFacade");
	}
	get themeFacade() {
		return this.getNativeInterface("themeFacade");
	}
	get externalCalendarFacade() {
		return this.getNativeInterface("externalCalendarFacade");
	}
	get systemFacade() {
		return this.getNativeInterface("mobileSystemFacade");
	}
	get mobileContactsFacade() {
		return this.getNativeInterface("mobileContactsFacade");
	}
	get nativeCredentialsFacade() {
		return this.getNativeInterface("nativeCredentialsFacade");
	}
	get mobilePaymentsFacade() {
		return this.getNativeInterface("mobilePaymentsFacade");
	}
	async mailAddressTableModelForOwnMailbox() {
		const { MailAddressTableModel } = await import("./MailAddressTableModel-CdalvARh.js");
		const nameChanger = await this.ownMailAddressNameChanger();
		return new MailAddressTableModel(this.entityClient, this.serviceExecutor, this.mailAddressFacade, this.logins, this.eventController, this.logins.getUserController().userGroupInfo, nameChanger, await this.redraw());
	}
	async mailAddressTableModelForAdmin(mailGroupId, userId, userGroupInfo) {
		const { MailAddressTableModel } = await import("./MailAddressTableModel-CdalvARh.js");
		const nameChanger = await this.adminNameChanger(mailGroupId, userId);
		return new MailAddressTableModel(this.entityClient, this.serviceExecutor, this.mailAddressFacade, this.logins, this.eventController, userGroupInfo, nameChanger, await this.redraw());
	}
	async ownMailAddressNameChanger() {
		const { OwnMailAddressNameChanger } = await import("./OwnMailAddressNameChanger-n0V6M1sm.js");
		return new OwnMailAddressNameChanger(this.mailboxModel, this.entityClient);
	}
	async adminNameChanger(mailGroupId, userId) {
		const { AnotherUserMailAddressNameChanger } = await import("./AnotherUserMailAddressNameChanger-3Ji2KRt2.js");
		return new AnotherUserMailAddressNameChanger(this.mailAddressFacade, mailGroupId, userId);
	}
	async drawerAttrsFactory() {
		return () => ({
			logins: this.logins,
			newsModel: this.newsModel,
			desktopSystemFacade: this.desktopSystemFacade
		});
	}
	domainConfigProvider() {
		return new DomainConfigProvider();
	}
	async credentialsRemovalHandler() {
		const { NoopCredentialRemovalHandler, AppsCredentialRemovalHandler } = await import("./CredentialRemovalHandler-D5xGlXfw.js");
		return isBrowser() ? new NoopCredentialRemovalHandler() : new AppsCredentialRemovalHandler(this.pushService, this.configFacade, async (login, userId) => {
			if (isApp()) await mailLocator.nativeContactsSyncManager().disableSync(userId, login);
			await mailLocator.indexerFacade.deleteIndex(userId);
			if (isDesktop()) await mailLocator.exportFacade.clearExportState(userId);
		});
	}
	async loginViewModelFactory() {
		const { LoginViewModel } = await import("./LoginViewModel-BdxNzsw3.js");
		const credentialsRemovalHandler = await mailLocator.credentialsRemovalHandler();
		const { MobileAppLock, NoOpAppLock } = await import("./AppLock-B-RY8hQY.js");
		const appLock = isApp() ? new MobileAppLock(assertNotNull(this.nativeInterfaces).mobileSystemFacade, assertNotNull(this.nativeInterfaces).nativeCredentialsFacade) : new NoOpAppLock();
		return () => {
			const domainConfig = isBrowser() ? mailLocator.domainConfigProvider().getDomainConfigForHostname(location.hostname, location.protocol, location.port) : mailLocator.domainConfigProvider().getCurrentDomainConfig();
			return new LoginViewModel(mailLocator.logins, mailLocator.credentialsProvider, mailLocator.secondFactorHandler, deviceConfig, domainConfig, credentialsRemovalHandler, isBrowser() ? null : this.pushService, appLock);
		};
	}
	getNativeInterface(name) {
		if (!this.nativeInterfaces) throw new ProgrammingError(`Tried to use ${name} in web`);
		return this.nativeInterfaces[name];
	}
	getMailImporter() {
		if (this.mailImporter == null) throw new ProgrammingError(`Tried to use mail importer in web or mobile`);
		return this.mailImporter;
	}
	_workerDeferred;
	_entropyCollector;
	_deferredInitialized = defer();
	get initialized() {
		return this._deferredInitialized.promise;
	}
	constructor() {
		this._workerDeferred = defer();
	}
	async init() {
		this.worker = bootstrapWorker(this);
		await this._createInstances();
		this._entropyCollector = new EntropyCollector(this.entropyFacade, await this.scheduler(), window);
		this._entropyCollector.start();
		this._deferredInitialized.resolve();
	}
	async _createInstances() {
		const { loginFacade, customerFacade, giftCardFacade, groupManagementFacade, configFacade, calendarFacade, mailFacade, shareFacade, counterFacade, indexerFacade, searchFacade, bookingFacade, mailAddressFacade, blobFacade, userManagementFacade, recoverCodeFacade, restInterface, serviceExecutor, cryptoFacade, cacheStorage, random, eventBus, entropyFacade, workerFacade, sqlCipherFacade, contactFacade, bulkMailLoader, mailExportFacade } = this.worker.getWorkerInterface();
		this.loginFacade = loginFacade;
		this.customerFacade = customerFacade;
		this.giftCardFacade = giftCardFacade;
		this.groupManagementFacade = groupManagementFacade;
		this.configFacade = configFacade;
		this.calendarFacade = calendarFacade;
		this.mailFacade = mailFacade;
		this.shareFacade = shareFacade;
		this.counterFacade = counterFacade;
		this.indexerFacade = indexerFacade;
		this.searchFacade = searchFacade;
		this.bookingFacade = bookingFacade;
		this.mailAddressFacade = mailAddressFacade;
		this.blobFacade = blobFacade;
		this.userManagementFacade = userManagementFacade;
		this.recoverCodeFacade = recoverCodeFacade;
		this.contactFacade = contactFacade;
		this.serviceExecutor = serviceExecutor;
		this.sqlCipherFacade = sqlCipherFacade;
		this.logins = new LoginController(this.loginFacade, async () => this.loginListener, () => this.worker.reset());
		this.logins.init();
		this.eventController = new EventController(mailLocator.logins);
		this.progressTracker = new ProgressTracker();
		this.search = new SearchModel(this.searchFacade, () => this.calendarEventsRepository());
		this.entityClient = new EntityClient(restInterface);
		this.cryptoFacade = cryptoFacade;
		this.cacheStorage = cacheStorage;
		this.entropyFacade = entropyFacade;
		this.workerFacade = workerFacade;
		this.bulkMailLoader = bulkMailLoader;
		this.mailExportFacade = mailExportFacade;
		this.connectivityModel = new WebsocketConnectivityModel(eventBus);
		this.mailboxModel = new MailboxModel(this.eventController, this.entityClient, this.logins);
		this.mailModel = new MailModel(notifications, this.mailboxModel, this.eventController, this.entityClient, this.logins, this.mailFacade, this.connectivityModel, this.inboxRuleHanlder());
		this.operationProgressTracker = new OperationProgressTracker();
		this.infoMessageHandler = new InfoMessageHandler((state) => {
			mailLocator.search.indexState(state);
		});
		this.usageTestModel = new UsageTestModel({
			[StorageBehavior.Persist]: deviceConfig,
			[StorageBehavior.Ephemeral]: new EphemeralUsageTestStorage()
		}, {
			now() {
				return Date.now();
			},
			timeZone() {
				throw new Error("Not implemented by this provider");
			}
		}, this.serviceExecutor, this.entityClient, this.logins, this.eventController, () => this.usageTestController);
		this.usageTestController = new UsageTestController(this.usageTestModel);
		this.Const = Const;
		if (!isBrowser()) {
			const { WebDesktopFacade } = await import("./WebDesktopFacade-DrZRYxsf.js");
			const { WebMobileFacade } = await import("./WebMobileFacade-ep3XtQIt.js");
			const { WebCommonNativeFacade } = await import("./WebCommonNativeFacade-RpKaxJ1a.js");
			const { WebInterWindowEventFacade } = await import("./WebInterWindowEventFacade-NMCFKrHB.js");
			const { WebAuthnFacadeSendDispatcher } = await import("./WebAuthnFacadeSendDispatcher-BapqN6xx.js");
			const { OpenMailboxHandler } = await import("./OpenMailboxHandler-Bg4BSs3n.js");
			const { createNativeInterfaces, createDesktopInterfaces } = await import("./NativeInterfaceFactory-C-eDEjHc.js");
			const openMailboxHandler = new OpenMailboxHandler(this.logins, this.mailModel, this.mailboxModel);
			const { OpenCalendarHandler } = await import("./OpenCalendarHandler-Yvl4n6Ou.js");
			const openCalendarHandler = new OpenCalendarHandler(this.logins);
			const { OpenSettingsHandler } = await import("./OpenSettingsHandler-F7I6nN5r.js");
			const openSettingsHandler = new OpenSettingsHandler(this.logins);
			this.webMobileFacade = new WebMobileFacade(this.connectivityModel, MAIL_PREFIX);
			this.nativeInterfaces = createNativeInterfaces(this.webMobileFacade, new WebDesktopFacade(this.logins, async () => this.native), new WebInterWindowEventFacade(this.logins, windowFacade, deviceConfig), new WebCommonNativeFacade(this.logins, this.mailboxModel, this.usageTestController, async () => this.fileApp, async () => this.pushService, this.handleFileImport.bind(this), (userId, address, requestedPath) => openMailboxHandler.openMailbox(userId, address, requestedPath), (userId) => openCalendarHandler.openCalendar(userId), AppType.Integrated, (path) => openSettingsHandler.openSettings(path)), cryptoFacade, calendarFacade, this.entityClient, this.logins, AppType.Integrated);
			this.credentialsProvider = await this.createCredentialsProvider();
			if (isElectronClient()) {
				const desktopInterfaces = createDesktopInterfaces(this.native);
				this.searchTextFacade = desktopInterfaces.searchTextFacade;
				this.interWindowEventSender = desktopInterfaces.interWindowEventSender;
				this.webAuthn = new WebauthnClient(new WebAuthnFacadeSendDispatcher(this.native), this.domainConfigProvider(), isApp());
				if (isDesktop()) {
					this.desktopSettingsFacade = desktopInterfaces.desktopSettingsFacade;
					this.desktopSystemFacade = desktopInterfaces.desktopSystemFacade;
					this.mailImporter = new MailImporter(this.domainConfigProvider(), this.logins, this.mailboxModel, this.entityClient, this.eventController, this.credentialsProvider, desktopInterfaces.nativeMailImportFacade, openSettingsHandler);
					this.exportFacade = desktopInterfaces.exportFacade;
				}
			} else if (isAndroidApp() || isIOSApp()) {
				const { SystemPermissionHandler } = await import("./SystemPermissionHandler-BbVU7suI.js");
				this.systemPermissionHandler = new SystemPermissionHandler(this.systemFacade);
				this.webAuthn = new WebauthnClient(new WebAuthnFacadeSendDispatcher(this.native), this.domainConfigProvider(), isApp());
			}
		} else this.credentialsProvider = await this.createCredentialsProvider();
		if (this.webAuthn == null) this.webAuthn = new WebauthnClient(new BrowserWebauthn(navigator.credentials, this.domainConfigProvider().getCurrentDomainConfig()), this.domainConfigProvider(), isApp());
		this.secondFactorHandler = new SecondFactorHandler(this.eventController, this.entityClient, this.webAuthn, this.loginFacade, this.domainConfigProvider());
		this.loginListener = new PageContextLoginListener(this.secondFactorHandler, this.credentialsProvider);
		this.random = random;
		this.newsModel = new NewsModel(this.serviceExecutor, deviceConfig, async (name) => {
			switch (name) {
				case "usageOptIn": {
					const { UsageOptInNews } = await import("./UsageOptInNews-CSQVAKPp.js");
					return new UsageOptInNews(this.newsModel, this.usageTestModel);
				}
				case "recoveryCode": {
					const { RecoveryCodeNews } = await import("./RecoveryCodeNews-DLdvUu3I.js");
					return new RecoveryCodeNews(this.newsModel, this.logins.getUserController(), this.recoverCodeFacade);
				}
				case "pinBiometrics": {
					const { PinBiometricsNews } = await import("./PinBiometricsNews-1YR5uBKd.js");
					return new PinBiometricsNews(this.newsModel, this.credentialsProvider, this.logins.getUserController().userId);
				}
				case "referralLink": {
					const { ReferralLinkNews } = await import("./ReferralLinkNews-FXduc3Zu.js");
					const dateProvider = await this.noZoneDateProvider();
					return new ReferralLinkNews(this.newsModel, dateProvider, this.logins.getUserController());
				}
				case "richNotifications": {
					const { RichNotificationsNews } = await import("./RichNotificationsNews-CuMQbODn.js");
					return new RichNotificationsNews(this.newsModel, isApp() || isDesktop() ? this.pushService : null);
				}
				default:
					console.log(`No implementation for news named '${name}'`);
					return null;
			}
		});
		this.fileController = this.nativeInterfaces == null ? new FileControllerBrowser(blobFacade, guiDownload) : new FileControllerNative(blobFacade, guiDownload, this.nativeInterfaces.fileApp);
		const { ContactModel } = await import("./ContactModel-toSAU5Gg.js");
		this.contactModel = new ContactModel(this.entityClient, this.logins, this.eventController, async (query, field, minSuggestionCount, maxResults) => {
			const { createRestriction } = await import("./SearchUtils-DlTX0O2A.js");
			return mailLocator.searchFacade.search(query, createRestriction(SearchCategoryTypes.contact, null, null, field, [], null), minSuggestionCount, maxResults);
		});
		this.minimizedMailModel = new MinimizedMailEditorViewModel();
		const sanitizerStub = {
			sanitizeHTML: () => {
				return {
					html: "",
					blockedExternalContent: 0,
					inlineImageCids: [],
					links: []
				};
			},
			sanitizeSVG(svg, configExtra) {
				throw new Error("stub!");
			},
			sanitizeFragment(html, configExtra) {
				throw new Error("stub!");
			}
		};
		const selectedThemeFacade = isApp() || isDesktop() ? new NativeThemeFacade(new LazyLoaded(async () => mailLocator.themeFacade)) : new WebThemeFacade(deviceConfig);
		const lazySanitizer = isTest() ? () => Promise.resolve(sanitizerStub) : () => import("./HtmlSanitizer-DJqF9m1z.js").then(({ htmlSanitizer }) => htmlSanitizer);
		this.themeController = new ThemeController(theme, selectedThemeFacade, lazySanitizer, AppType.Mail);
		if (selectedThemeFacade instanceof WebThemeFacade) selectedThemeFacade.addDarkListener(() => mailLocator.themeController.reloadTheme());
	}
	calendarModel = lazyMemoized(async () => {
		const { DefaultDateProvider } = await import("./CalendarUtils-DwR144gS.js");
		const { CalendarModel } = await import("./CalendarModel-BALCdPt3.js");
		const timeZone = new DefaultDateProvider().timeZone();
		return new CalendarModel(notifications, this.alarmScheduler, this.eventController, this.serviceExecutor, this.logins, this.progressTracker, this.entityClient, this.mailboxModel, this.calendarFacade, this.fileController, timeZone, !isBrowser() ? this.externalCalendarFacade : null, deviceConfig, !isBrowser() ? this.pushService : null);
	});
	calendarInviteHandler = lazyMemoized(async () => {
		const { CalendarInviteHandler } = await import("./CalendarInvites-vQV5UEa1.js");
		const { calendarNotificationSender } = await import("./CalendarNotificationSender-DoWbzuto.js");
		return new CalendarInviteHandler(this.mailboxModel, await this.calendarModel(), this.logins, calendarNotificationSender, (...arg) => this.sendMailModel(...arg));
	});
	async handleFileImport(filesUris) {
		const files = await this.fileApp.getFilesMetaData(filesUris);
		const areAllFilesVCard = files.every((file) => file.mimeType === VCARD_MIME_TYPES.X_VCARD || file.mimeType === VCARD_MIME_TYPES.VCARD);
		const areAllFilesICS = files.every((file) => file.mimeType === CALENDAR_MIME_TYPE);
		const areAllFilesMail = files.every((file) => file.mimeType === MAIL_MIME_TYPES.EML || file.mimeType === MAIL_MIME_TYPES.MBOX);
		if (areAllFilesVCard) {
			const importer = await this.contactImporter();
			const { parseContacts } = await import("./ContactImporter-D5ZB41b5.js");
			const contacts = await parseContacts(files, this.fileApp);
			const vCardData = contacts.join("\n");
			const contactListId = assertNotNull(await this.contactModel.getContactListId());
			await importer.importContactsFromFile(vCardData, contactListId);
		} else if (areAllFilesICS) {
			const calendarModel = await this.calendarModel();
			const groupSettings = this.logins.getUserController().userSettingsGroupRoot.groupSettings;
			const calendarInfos = await calendarModel.getCalendarInfos();
			const groupColors = groupSettings.reduce((acc, gc) => {
				acc.set(gc.group, gc.color);
				return acc;
			}, new Map());
			const { calendarSelectionDialog, parseCalendarFile } = await import("./CalendarImporter-zjX-8iQD.js");
			const { handleCalendarImport } = await import("./CalendarImporterDialog-1PgzlPxJ.js");
			let parsedEvents = [];
			for (const fileRef of files) {
				const dataFile = await this.fileApp.readDataFile(fileRef.location);
				if (dataFile == null) continue;
				const data = parseCalendarFile(dataFile);
				parsedEvents.push(...data.contents);
			}
			calendarSelectionDialog(Array.from(calendarInfos.values()), this.logins.getUserController(), groupColors, (dialog, selectedCalendar) => {
				dialog.close();
				handleCalendarImport(selectedCalendar.groupRoot, parsedEvents);
			});
		}
	}
	alarmScheduler = lazyMemoized(async () => {
		const { AlarmScheduler } = await import("./AlarmScheduler-CVom6Dr2.js");
		const { DefaultDateProvider } = await import("./CalendarUtils-DwR144gS.js");
		const dateProvider = new DefaultDateProvider();
		return new AlarmScheduler(dateProvider, await this.scheduler());
	});
	async scheduler() {
		const dateProvider = await this.noZoneDateProvider();
		return new SchedulerImpl(dateProvider, window, window);
	}
	async calendarEventPreviewModel(selectedEvent, calendars) {
		const { findAttendeeInAddresses } = await import("./CommonCalendarUtils-D23yRzPh.js");
		const { getEventType } = await import("./CalendarGuiUtils-XsrYo5M5.js");
		const { CalendarEventPreviewViewModel } = await import("./CalendarEventPreviewViewModel-CWG_-5I4.js");
		const mailboxDetails = await this.mailboxModel.getUserMailboxDetails();
		const mailboxProperties = await this.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot);
		const userController = this.logins.getUserController();
		const customer = await userController.loadCustomer();
		const ownMailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, userController.userGroupInfo);
		const ownAttendee = findAttendeeInAddresses(selectedEvent.attendees, ownMailAddresses);
		const eventType = getEventType(selectedEvent, calendars, ownMailAddresses, userController);
		const hasBusinessFeature = isCustomizationEnabledForCustomer(customer, FeatureType.BusinessFeatureEnabled) || await userController.isNewPaidPlan();
		const lazyIndexEntry = async () => selectedEvent.uid != null ? this.calendarFacade.getEventsByUid(selectedEvent.uid) : null;
		const popupModel = new CalendarEventPreviewViewModel(selectedEvent, await this.calendarModel(), eventType, hasBusinessFeature, ownAttendee, lazyIndexEntry, async (mode) => this.calendarEventModel(mode, selectedEvent, mailboxDetails, mailboxProperties, null));
		await popupModel.sanitizeDescription();
		return popupModel;
	}
	async calendarContactPreviewModel(event, contact, canEdit) {
		const { CalendarContactPreviewViewModel } = await import("./CalendarContactPreviewViewModel-BkoK4iwJ.js");
		return new CalendarContactPreviewViewModel(event, contact, canEdit);
	}
	nativeContactsSyncManager = lazyMemoized(() => {
		assert(isApp(), "isApp");
		return new NativeContactsSyncManager(this.logins, this.mobileContactsFacade, this.entityClient, this.eventController, this.contactModel, deviceConfig);
	});
	postLoginActions = lazyMemoized(async () => {
		const { PostLoginActions } = await import("./PostLoginActions-_11wBBmn.js");
		return new PostLoginActions(this.credentialsProvider, this.secondFactorHandler, this.connectivityModel, this.logins, await this.noZoneDateProvider(), this.entityClient, this.userManagementFacade, this.customerFacade, this.themeController, () => this.showSetupWizard(), () => this.handleExternalSync(), () => this.setUpClientOnlyCalendars());
	});
	showSetupWizard = async () => {
		if (isApp()) {
			const { showSetupWizard } = await import("./SetupWizard-DDsxJjQJ.js");
			return showSetupWizard(this.systemPermissionHandler, this.webMobileFacade, await this.contactImporter(), this.systemFacade, this.credentialsProvider, await this.nativeContactsSyncManager(), deviceConfig, true);
		}
	};
	async handleExternalSync() {
		const calendarModel = await locator.calendarModel();
		if (isApp() || isDesktop()) {
			calendarModel.syncExternalCalendars().catch(async (e) => {
				showSnackBar({
					message: lang.makeTranslation("exception_msg", e.message),
					button: {
						label: "ok_action",
						click: noOp
					},
					waitingTime: 1e3
				});
			});
			calendarModel.scheduleExternalCalendarSync();
		}
	}
	setUpClientOnlyCalendars() {
		let configs = deviceConfig.getClientOnlyCalendars();
		for (const [id, name] of CLIENT_ONLY_CALENDARS.entries()) {
			const calendarId = `${this.logins.getUserController().userId}#${id}`;
			const config = configs.get(calendarId);
			if (!config) deviceConfig.updateClientOnlyCalendars(calendarId, {
				name: lang.get(name),
				color: DEFAULT_CLIENT_ONLY_CALENDAR_COLORS.get(id)
			});
		}
	}
	credentialFormatMigrator = lazyMemoized(async () => {
		const { CredentialFormatMigrator } = await import("./CredentialFormatMigrator-CXDsRLdK.js");
		if (isDesktop()) return new CredentialFormatMigrator(deviceConfig, this.nativeCredentialsFacade, null);
else if (isApp()) return new CredentialFormatMigrator(deviceConfig, this.nativeCredentialsFacade, this.systemFacade);
else return new CredentialFormatMigrator(deviceConfig, null, null);
	});
	async addNotificationEmailDialog() {
		const { AddNotificationEmailDialog } = await import("./AddNotificationEmailDialog-BPpUA5tG.js");
		return new AddNotificationEmailDialog(this.logins, this.entityClient);
	}
	mailExportController = lazyMemoized(async () => {
		const { htmlSanitizer } = await import("./HtmlSanitizer-DJqF9m1z.js");
		const { MailExportController } = await import("./MailExportController-b7SA26Mz.js");
		return new MailExportController(this.mailExportFacade, htmlSanitizer, this.exportFacade, this.logins, this.mailboxModel, await this.scheduler());
	});
	/**
	* Factory method for credentials provider that will return an instance injected with the implementations appropriate for the platform.
	*/
	async createCredentialsProvider() {
		const { CredentialsProvider } = await import("./CredentialsProvider-BofHkvzO.js");
		if (isDesktop() || isApp()) return new CredentialsProvider(this.nativeCredentialsFacade, this.sqlCipherFacade, isDesktop() ? this.interWindowEventSender : null);
else {
			const { WebCredentialsFacade } = await import("./WebCredentialsFacade-DDi71uel.js");
			return new CredentialsProvider(new WebCredentialsFacade(deviceConfig), null, null);
		}
	}
};
const mailLocator = new MailLocator();
if (typeof window !== "undefined") window.tutao.locator = mailLocator;

//#endregion
export { EntropyCollector, EventController, FileControllerBrowser, FileControllerNative, LoginController, MailModel, MailboxModel, NewsModel, OfflineIndicator, ProgressBar, SaveErrorReason, SaveStatusEnum, SecondFactorHandler, ThemeController, WebauthnClient, _findMatchingRule, _matchesRegularExpression, areResultsForTheSameQuery, hasMoreResults, isSameSearchRestriction, mailLocator, routeMatchesPrefix, validateWebauthnDisplayName };
//# sourceMappingURL=mailLocator-CrvEYt1k.js.map