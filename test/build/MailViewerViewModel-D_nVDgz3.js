
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { addAll, assertNonNull, assertNotNull, contains, downcast, endsWith, filterInt, first, neverNull, noOp, ofClass, pMap, sortableTimestamp, startsWith, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { isApp, isDesktop } from "./Env-D5xGlXfw.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { ConversationType, EncryptionAuthStatus, ExternalImageRule, FeatureType, MailAuthenticationStatus, MailMethod, MailPhishingStatus, MailReportType, MailSetKind, MailState, OperationType, ReportMovedMailsType, SYSTEM_GROUP_MAIL_ADDRESS, getMailFolderType } from "./TutanotaConstants-3bwAESYA.js";
import { ButtonType } from "./Icon-BuqNK7vz.js";
import { Icons } from "./Icons-Dl3nFav5.js";
import { Dialog } from "./Dialog-B6-HFvZd.js";
import { LockedError, NotAuthorizedError, NotFoundError, PreconditionFailedError } from "./RestError-D17JEBMr.js";
import { isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { IndexingNotSupportedError } from "./QuotaExceededError-nFM6SdTn.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { FileOpenError } from "./FileOpenError-C1_8yoXr.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { elementIdPart, getElementId, getLetId, haveSameId, isSameId } from "./EntityUtils-RQxXZlcV.js";
import { formatDateTime, urlEncodeHtmlTags } from "./Formatter-zB15D6XI.js";
import { ConversationEntryTypeRef, FileTypeRef, MailTypeRef, createMail, createMailAddress } from "./TypeRefs-CR3TLWn0.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import { CALENDAR_MIME_TYPE, getDefaultSender, getEnabledMailAddressesWithUser, getMailAddressDisplayText, getMailboxName, hasValidEncryptionAuthForTeamOrSystemMail, zipDataFiles } from "./SharedMailUtils-AmFaSJP6.js";
import { showSnackBar } from "./SnackBar-CoP3lSVs.js";
import { Checkbox } from "./Checkbox-WCw-l_7A.js";
import { showUserError } from "./ErrorHandlerImpl-DRpk8tE9.js";
import { checkApprovalStatus } from "./LoginViewModel-BX-8ry63.js";
import { revokeInlineImages } from "./inlineImagesUtils-BekMwI7k.js";
import { getDisplayedSender, getMailBodyText } from "./CommonMailUtils-DNufl6ib.js";
import { AttachmentType, getAttachmentType } from "./AttachmentBubble-CloIefNF.js";
import { mailLocator } from "./mailLocator-CrvEYt1k.js";
import { assertSystemFolderOfType, getFolderName, getPathToFolderString, loadMailHeaders } from "./MailUtils-ChhZAFAd.js";
import { isDraft, isOfTypeOrSubfolderOf, isSpamOrTrashFolder } from "./MailChecks-PhVUoR7f.js";
import { generateExportFileName, mailToEmlFile } from "./emlUtils-afBEUvhM.js";
import { LoadingStateTracker } from "./LoadingState-DqrMrOAm.js";

//#region ../src/mail-app/mail/view/MailReportDialog.ts
function confirmMailReportDialog(mailModel, mailboxDetails) {
	return new Promise((resolve) => {
		let shallRememberDecision = false;
		const child = () => mithril_default(Checkbox, {
			label: () => lang.get("rememberDecision_msg"),
			checked: shallRememberDecision,
			onChecked: (v) => shallRememberDecision = v,
			helpLabel: "changeMailSettings_msg"
		});
		async function updateSpamReportSetting(areMailsReported) {
			if (shallRememberDecision) {
				const reportMovedMails = areMailsReported ? ReportMovedMailsType.AUTOMATICALLY_ONLY_SPAM : ReportMovedMailsType.NEVER;
				await mailModel.saveReportMovedMails(mailboxDetails.mailboxGroupRoot, reportMovedMails);
			}
			resolve(areMailsReported);
			dialog.close();
		}
		const yesButton = {
			label: "yes_label",
			click: () => updateSpamReportSetting(true),
			type: ButtonType.Primary
		};
		const noButton = {
			label: "no_label",
			click: () => updateSpamReportSetting(false),
			type: ButtonType.Secondary
		};
		const onclose = () => {
			resolve(false);
		};
		const dialog = Dialog.confirmMultiple(lang.makeTranslation("unencryptedTransmission_msg", lang.get("unencryptedTransmission_msg") + " " + lang.get("allowOperation_msg")), [noButton, yesButton], onclose, child);
	});
}
async function reportMailsAutomatically(mailReportType, mailboxModel, mailModel, mailboxDetails, mails) {
	if (mailReportType !== MailReportType.SPAM) return;
	const mailboxProperties = await mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot);
	let allowUndoing = true;
	let isReportable = false;
	if (!mailboxProperties || mailboxProperties.reportMovedMails === ReportMovedMailsType.ALWAYS_ASK) {
		isReportable = await confirmMailReportDialog(mailModel, mailboxDetails);
		allowUndoing = false;
	} else if (mailboxProperties.reportMovedMails === ReportMovedMailsType.AUTOMATICALLY_ONLY_SPAM) isReportable = true;
else if (mailboxProperties.reportMovedMails === ReportMovedMailsType.NEVER) {}
	if (isReportable) if (allowUndoing) {
		let undoClicked = false;
		showSnackBar({
			message: "undoMailReport_msg",
			button: {
				label: "cancel_action",
				click: () => undoClicked = true
			},
			onClose: () => {
				if (!undoClicked) mailModel.reportMails(mailReportType, mails);
			}
		});
	} else mailModel.reportMails(mailReportType, mails);
}

//#endregion
//#region ../src/common/gui/PinchZoom.ts
var PinchZoom = class PinchZoom {
	onTouchEndListener = null;
	onTouchStartListener = null;
	onTouchCancelListener = null;
	onTouchMoveListener = null;
	draggingOrZooming = false;
	currentTouchStart = {
		x: 0,
		y: 0,
		startTime: 0
	};
	static DRAG_THRESHOLD = 10;
	pinchTouchIDs = new Set();
	lastPinchTouchPositions = {
		pointer1: {
			x: 0,
			y: 0
		},
		pointer2: {
			x: 0,
			y: 0
		}
	};
	initialZoomablePosition = {
		x: 0,
		y: 0
	};
	initialViewportPosition = {
		x: 0,
		y: 0
	};
	pinchSessionTranslation = {
		x: 0,
		y: 0
	};
	initialZoomableSize = {
		width: 0,
		height: 0
	};
	zoomBoundaries = {
		min: 1,
		max: 3
	};
	currentScale = 1;
	lastDragTouchPosition = null;
	LONG_PRESS_MIN_MS = 400;
	DOUBLE_TAP_TIME_MS = 350;
	SAME_POSITION_RADIUS = 40;
	lastDoubleTapTouchStart = {
		x: 0,
		y: 0
	};
	firstTapTime = 0;
	/**
	* Creates a PinchZoom object and immediately starts recognizing and reacting to zoom, drag and tab gestures.
	* @precondition zoomable.x <= viewport.x && zoomable.y <= viewport.y && zoomable.x2 >= viewport.x2 && zoomable.y2 >= viewport.y2
	* @precondition zoomable must have been rendered already at least once.
	* @param zoomable The HTMLElement that shall be zoomed inside the viewport.
	* @param viewport The HTMLElement in which the zoomable is zoomed and dragged.
	* @param initiallyZoomToViewportWidth If true and the width of the zoomable is bigger than the viewport width, the zoomable is zoomed out to match the viewport __width__ and not the height! the viewport height is adapted to match the zoomed zoomable height (calling PinchZoom.remove() resets the height)
	* @param singleClickAction This function is called whenever a single click on the zoomable is detected, e.g. on a link. Since the PinchZoom class prevents all default actions these clicks need to be handled outside of this class.
	*/
	constructor(zoomable, viewport, initiallyZoomToViewportWidth, singleClickAction) {
		this.zoomable = zoomable;
		this.viewport = viewport;
		this.initiallyZoomToViewportWidth = initiallyZoomToViewportWidth;
		this.singleClickAction = singleClickAction;
		this.viewport.style.overflow = "hidden";
		this.update({
			x: 0,
			y: 0
		});
		this.zoomable.style.touchAction = "pan-y pan-x";
		this.zoomable.style.minWidth = "100%";
		this.zoomable.style.width = "fit-content";
		const initialZoomableCoords = this.getCoords(this.zoomable);
		this.initialZoomableSize = {
			width: this.zoomable.scrollWidth,
			height: this.zoomable.scrollHeight
		};
		this.initialZoomablePosition = {
			x: initialZoomableCoords.x,
			y: initialZoomableCoords.y
		};
		const initialViewportCoords = this.getCoords(this.viewport);
		this.initialViewportPosition = {
			x: initialViewportCoords.x,
			y: initialViewportCoords.y
		};
		this.onTouchEndListener = this.zoomable.ontouchend = (e) => {
			this.removeTouches(e);
			const eventTarget = e.target;
			if (e.touches.length === 0 && e.changedTouches.length === 1) this.handleDoubleTap(e, eventTarget, (e$1, target) => singleClickAction(e$1, target), (e$1) => {
				let scale = 1;
				if (this.currentScale > this.zoomBoundaries.min) scale = this.zoomBoundaries.min;
else scale = (this.zoomBoundaries.min + this.zoomBoundaries.max) / 2;
				const translationAndOrigin = this.calculateSessionsTranslationAndTransformOrigin({
					x: e$1.changedTouches[0].clientX,
					y: e$1.changedTouches[0].clientY
				});
				const newTransformOrigin = this.setCurrentSafePosition(translationAndOrigin.newTransformOrigin, translationAndOrigin.sessionTranslation, this.getCurrentZoomablePositionWithoutTransformation(), scale).newTransformOrigin;
				this.update(newTransformOrigin);
			});
		};
		this.onTouchStartListener = this.zoomable.ontouchstart = (e) => {
			const touch = e.touches[0];
			this.currentTouchStart = {
				x: touch.clientX,
				y: touch.clientY,
				startTime: Date.now()
			};
			if (e.touches.length >= 2) this.draggingOrZooming = true;
			if (e.touches.length === 1) this.lastDragTouchPosition = {
				x: touch.clientX,
				y: touch.clientY
			};
else this.lastDragTouchPosition = null;
		};
		this.onTouchMoveListener = this.zoomable.ontouchmove = (e) => {
			this.touchmove_handler(e);
		};
		this.onTouchCancelListener = this.zoomable.ontouchcancel = (e) => {
			this.removeTouches(e);
		};
		if (this.initiallyZoomToViewportWidth) this.rescale();
	}
	getViewport() {
		return this.viewport;
	}
	getZoomable() {
		return this.zoomable;
	}
	isDraggingOrZooming() {
		return this.draggingOrZooming;
	}
	/**
	* call this method before throwing away the reference to the pinch zoom object
	* changes to the viewport needs to be reverted. Otherwise, future operations would be influenced
	*/
	remove() {
		if (this.onTouchEndListener) this.zoomable.removeEventListener("ontouchend", this.onTouchEndListener);
		if (this.onTouchStartListener) this.zoomable.removeEventListener("ontouchstart", this.onTouchStartListener);
		if (this.onTouchCancelListener) this.zoomable.removeEventListener("ontouchcancel", this.onTouchCancelListener);
		if (this.onTouchMoveListener) this.zoomable.removeEventListener("ontouchmove", this.onTouchMoveListener);
		this.currentScale = this.zoomBoundaries.min;
		this.update({
			x: 0,
			y: 0
		});
		this.viewport.style.height = "auto";
	}
	touchmove_handler(ev) {
		switch (ev.touches.length) {
			case 1:
				this.dragHandling(ev);
				break;
			case 2:
				this.pinchHandling(ev);
				break;
			default: break;
		}
	}
	removeTouches(ev) {
		if (ev.touches.length === 0) this.draggingOrZooming = false;
		this.pinchTouchIDs.clear();
	}
	pointDistance(point1, point2) {
		return Math.round(Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)));
	}
	centerOfPoints(...points) {
		let x = 0;
		let y = 0;
		for (let point of points) {
			x += point.x;
			y += point.y;
		}
		return {
			x: Math.round(x / points.length),
			y: Math.round(y / points.length)
		};
	}
	/**
	* returns the absolute coordinates of the rendered object (includes CSS transformations)
	*/
	getCoords(elem) {
		let box = elem.getBoundingClientRect();
		let body = document.body;
		let docEl = document.documentElement;
		let scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
		let scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
		let clientTop = docEl.clientTop || body.clientTop || 0;
		let clientLeft = docEl.clientLeft || body.clientLeft || 0;
		let top = box.top + scrollTop - clientTop;
		let left = box.left + scrollLeft - clientLeft;
		let bottom = box.bottom + scrollTop - clientTop;
		let right = box.right + scrollLeft - clientLeft;
		return {
			x: left,
			y: top,
			x2: right,
			y2: bottom
		};
	}
	getCurrentlyAppliedTransformOriginOfZoomable() {
		const computedStyle = getComputedStyle(this.zoomable);
		let transformOrigin = computedStyle.transformOrigin;
		let numberPattern = /-?\d+\.?\d*/g;
		let transformOriginValues = transformOrigin.match(numberPattern);
		if (transformOriginValues) return {
			x: Number(transformOriginValues[0]),
			y: Number(transformOriginValues[1])
		};
		return {
			x: 0,
			y: 0
		};
	}
	/**
	* Returns the current position of the original (without CSS transformation) zoomable
	* the transformOrigin is relative to this point
	*/
	getCurrentZoomablePositionWithoutTransformation() {
		let currentScrollOffset = this.getOffsetFromInitialToCurrentViewportPosition();
		return {
			x: this.initialZoomablePosition.x - currentScrollOffset.x,
			y: this.initialZoomablePosition.y - currentScrollOffset.y
		};
	}
	/**
	* Returns the current offset of the viewport compared to the original position. E.g. if the viewport was scrolled this scroll offset is returned.
	**/
	getOffsetFromInitialToCurrentViewportPosition() {
		let currentViewport = this.getCoords(this.viewport);
		return {
			x: this.initialViewportPosition.x - currentViewport.x,
			y: this.initialViewportPosition.y - currentViewport.y
		};
	}
	/**
	* Scales the zoomable to match the viewport width if the zoomable width is bigger.
	*/
	rescale() {
		const containerWidth = this.viewport.offsetWidth;
		if (containerWidth >= this.zoomable.scrollWidth) {
			this.zoomable.style.transform = "";
			this.zoomable.style.marginBottom = "";
		} else {
			const width = this.zoomable.scrollWidth;
			const scale = containerWidth / width;
			this.viewport.style.height = `${this.viewport.scrollHeight * scale}px`;
			this.zoomBoundaries = {
				min: scale,
				max: this.zoomBoundaries.max
			};
			const newTransformOrigin = this.setCurrentSafePosition({
				x: 0,
				y: 0
			}, {
				x: 0,
				y: 0
			}, this.getCurrentZoomablePositionWithoutTransformation(), scale).newTransformOrigin;
			this.update(newTransformOrigin);
		}
	}
	/**
	* Calculate the nw sessionTranslation and transformOrigin dependent on the new finger position for flawless zooming behavior.
	* Dependent on the new position of the fingers the sessionTranslation is calculated so that the transformOrigin is in the center of the touch points
	* The session translation is the offset by which the original/initial zoomable is moved inside the viewport in a non-scaled state, so that when scaling to the current scale factor (this.currentScale) at the
	* calculated transform origin we get the current position and size of the zoomable inside the viewport.
	* The transform origin is the position relative to the original/initial zoomable position (non-scaled) at which we need to zoom in so that we get the current  position and size of the zoomable inside the viewport (with applied session translation).
	* @param absoluteZoomPosition The position in which the user wants to zoom, i.e. the center between the two fingers. This position is relative to the screen coordinates.
	*/
	calculateSessionsTranslationAndTransformOrigin(absoluteZoomPosition) {
		let currentZoomable = this.getCoords(this.zoomable);
		let scrollOffset = this.getOffsetFromInitialToCurrentViewportPosition();
		let transformedInitialZoomable = {
			x: (currentZoomable.x + absoluteZoomPosition.x * (this.currentScale - 1)) / this.currentScale,
			y: (currentZoomable.y + absoluteZoomPosition.y * (this.currentScale - 1)) / this.currentScale
		};
		let sessionTranslation = {
			x: transformedInitialZoomable.x - this.initialZoomablePosition.x + scrollOffset.x,
			y: transformedInitialZoomable.y - this.initialZoomablePosition.y + scrollOffset.y
		};
		let transformOrigin = {
			x: absoluteZoomPosition.x - transformedInitialZoomable.x,
			y: absoluteZoomPosition.y - transformedInitialZoomable.y
		};
		return {
			sessionTranslation,
			newTransformOrigin: transformOrigin
		};
	}
	/**
	* Calculate the transform origin that is needed to the desired targetCoordinates of the zoomable, given the session translation, the targetCoordinates and the scale
	*/
	calculateTransformOriginFromTarget(targetCoordinates, currentZoomablePositionWithoutTransformation, sessionTranslation, scale) {
		return {
			x: (currentZoomablePositionWithoutTransformation.x + sessionTranslation.x - targetCoordinates.x) / (scale - 1),
			y: (currentZoomablePositionWithoutTransformation.y + sessionTranslation.y - targetCoordinates.y) / (scale - 1)
		};
	}
	pinchHandling(ev) {
		this.draggingOrZooming = true;
		let transformOrigin = this.getCurrentlyAppliedTransformOriginOfZoomable();
		let pinchSessionTranslation = this.pinchSessionTranslation;
		const newTouches = !(this.pinchTouchIDs.has(ev.touches[0].identifier) && this.pinchTouchIDs.has(ev.touches[1].identifier));
		if (newTouches) this.lastPinchTouchPositions = {
			pointer1: {
				x: ev.touches[0].clientX,
				y: ev.touches[0].clientY
			},
			pointer2: {
				x: ev.touches[1].clientX,
				y: ev.touches[1].clientY
			}
		};
		const scaleDifference = this.pointDistance({
			x: ev.touches[0].clientX,
			y: ev.touches[0].clientY
		}, {
			x: ev.touches[1].clientX,
			y: ev.touches[1].clientY
		}) / this.pointDistance(this.lastPinchTouchPositions.pointer1, this.lastPinchTouchPositions.pointer2);
		const newAbsoluteScale = this.currentScale + (scaleDifference - 1);
		this.lastPinchTouchPositions = {
			pointer1: {
				x: ev.touches[0].clientX,
				y: ev.touches[0].clientY
			},
			pointer2: {
				x: ev.touches[1].clientX,
				y: ev.touches[1].clientY
			}
		};
		const pinchCenter = this.centerOfPoints({
			x: ev.touches[0].clientX,
			y: ev.touches[0].clientY
		}, {
			x: ev.touches[1].clientX,
			y: ev.touches[1].clientY
		});
		const startedPinchSession = this.calculateSessionsTranslationAndTransformOrigin(pinchCenter);
		transformOrigin = startedPinchSession.newTransformOrigin;
		pinchSessionTranslation = startedPinchSession.sessionTranslation;
		this.pinchTouchIDs = new Set([ev.touches[0].identifier, ev.touches[1].identifier]);
		const newTransformOrigin = this.setCurrentSafePosition(transformOrigin, pinchSessionTranslation, this.getCurrentZoomablePositionWithoutTransformation(), newAbsoluteScale).newTransformOrigin;
		this.update(newTransformOrigin);
	}
	dragHandling(ev) {
		if (this.currentScale > this.zoomBoundaries.min && this.lastDragTouchPosition) {
			if (Math.abs(ev.touches[0].clientX - this.currentTouchStart.x) >= PinchZoom.DRAG_THRESHOLD || Math.abs(ev.touches[0].clientY - this.currentTouchStart.y) >= PinchZoom.DRAG_THRESHOLD) this.draggingOrZooming = true;
			let delta = {
				x: ev.touches[0].clientX - this.lastDragTouchPosition.x,
				y: ev.touches[0].clientY - this.lastDragTouchPosition.y
			};
			this.lastDragTouchPosition = {
				x: ev.touches[0].clientX,
				y: ev.touches[0].clientY
			};
			let currentRect = this.getCoords(this.zoomable);
			let currentOriginalRect = this.getCurrentZoomablePositionWithoutTransformation();
			let newTransformOrigin = {
				x: (currentRect.x + delta.x - (currentOriginalRect.x + this.pinchSessionTranslation.x)) / (1 - this.currentScale),
				y: (currentRect.y + delta.y - (currentOriginalRect.y + this.pinchSessionTranslation.y)) / (1 - this.currentScale)
			};
			let newPinchSessionTranslation = this.pinchSessionTranslation;
			if (this.currentScale === 1) {
				newTransformOrigin = {
					x: 0,
					y: 0
				};
				newPinchSessionTranslation = {
					x: newPinchSessionTranslation.x + delta.x,
					y: newPinchSessionTranslation.y + delta.y
				};
			}
			let result = this.setCurrentSafePosition(newTransformOrigin, newPinchSessionTranslation, this.getCurrentZoomablePositionWithoutTransformation(), this.currentScale);
			if (ev.cancelable && result.verticalTransformationAllowed) ev.preventDefault();
			this.update(result.newTransformOrigin);
		}
	}
	handleDoubleTap(event, target, singleClickAction, doubleClickAction) {
		const now = Date.now();
		const touch = event.changedTouches[0];
		if (!touch || !event.cancelable) return;
		event.preventDefault();
		if (now - this.firstTapTime < this.DOUBLE_TAP_TIME_MS && Math.abs(touch.clientX - this.lastDoubleTapTouchStart.x) < this.SAME_POSITION_RADIUS && Math.abs(touch.clientY - this.lastDoubleTapTouchStart.y) < this.SAME_POSITION_RADIUS) {
			this.firstTapTime = 0;
			doubleClickAction(event);
		} else setTimeout(() => {
			if (this.firstTapTime === now && Math.abs(touch.clientX - this.currentTouchStart.x) < this.SAME_POSITION_RADIUS && Math.abs(touch.clientY - this.currentTouchStart.y) < this.SAME_POSITION_RADIUS) {
				if (now - this.currentTouchStart.startTime < this.LONG_PRESS_MIN_MS) window.getSelection()?.empty();
				singleClickAction(event, target);
			}
		}, this.DOUBLE_TAP_TIME_MS);
		this.lastDoubleTapTouchStart = this.currentTouchStart;
		this.firstTapTime = now;
	}
	/**
	* Applies the current session translation and scale to the zoomable, so it becomes visible.
	*/
	update(newTransformOrigin) {
		this.zoomable.style.transformOrigin = `${newTransformOrigin.x}px ${newTransformOrigin.y}px`;
		this.zoomable.style.transform = `translate3d(${this.pinchSessionTranslation.x}px, ${this.pinchSessionTranslation.y}px, 0) scale(${this.currentScale})`;
	}
	/**
	* Checks whether the zoomable is still in the allowed are (viewport) after applying the transformations
	* if not allowed -> adjust the transformOrigin to keep the transformed zoomable in an allowed state
	* apply changes to sessionTranslation, zoom and transformOrigin
	*/
	setCurrentSafePosition(newTransformOrigin, newPinchSessionTranslation, currentZoomablePositionWithoutTransformation, newScale) {
		this.getOffsetFromInitialToCurrentViewportPosition();
		let currentViewport = this.getCoords(this.viewport);
		let borders = {
			x: currentViewport.x + 1,
			y: currentViewport.y + 1,
			x2: currentViewport.x2 - 1,
			y2: currentViewport.y2 - 1
		};
		newScale = Math.max(this.zoomBoundaries.min, Math.min(this.zoomBoundaries.max, newScale));
		const targetedOutcome = this.simulateTransformation(currentZoomablePositionWithoutTransformation, this.initialZoomableSize.width, this.initialZoomableSize.height, newTransformOrigin, newPinchSessionTranslation, newScale);
		const targetedHeight = targetedOutcome.y2 - targetedOutcome.y;
		const targetedWidth = targetedOutcome.x2 - targetedOutcome.x;
		const horizontal1Allowed = targetedOutcome.x <= borders.x;
		const horizontal2Allowed = targetedOutcome.x2 >= borders.x2;
		const vertical1Allowed = targetedOutcome.y <= borders.y;
		const vertical2Allowed = targetedOutcome.y2 >= borders.y2;
		const horizontalTransformationAllowed = horizontal1Allowed && horizontal2Allowed;
		const verticalTransformationAllowed = vertical1Allowed && vertical2Allowed;
		const targetX = !horizontal1Allowed ? borders.x : !horizontal2Allowed ? borders.x2 - targetedWidth : targetedOutcome.x;
		const targetY = !vertical1Allowed ? borders.y : !vertical2Allowed ? borders.y2 - targetedHeight : targetedOutcome.y;
		if (targetX !== targetedOutcome.x || targetY !== targetedOutcome.y) newTransformOrigin = this.calculateTransformOriginFromTarget({
			x: targetX,
			y: targetY
		}, currentZoomablePositionWithoutTransformation, newPinchSessionTranslation, newScale);
		if (newScale === 1 && this.zoomBoundaries.min === 1) this.pinchSessionTranslation = {
			x: 0,
			y: 0
		};
else this.pinchSessionTranslation = newPinchSessionTranslation;
		this.currentScale = newScale;
		return {
			verticalTransformationAllowed,
			horizontalTransformationAllowed,
			newTransformOrigin
		};
	}
	/**
	* calculate the outcome of the css transformation
	* this is used to check the boundaries before actually applying the transformation
	*/
	simulateTransformation(currentOriginalPosition, originalWidth, originalHeight, transformOrigin, translation, scale) {
		return {
			x: currentOriginalPosition.x + transformOrigin.x - transformOrigin.x * scale + translation.x,
			y: currentOriginalPosition.y + transformOrigin.y - transformOrigin.y * scale + translation.y,
			x2: currentOriginalPosition.x + transformOrigin.x + (originalWidth - transformOrigin.x) * scale + translation.x,
			y2: currentOriginalPosition.y + transformOrigin.y + (originalHeight - transformOrigin.y) * scale + translation.y
		};
	}
};

//#endregion
//#region ../src/common/gui/base/icons/FontIcons.ts
const FontIcons = Object.freeze({
	Reply: `\uea01`,
	ReplyAll: `\uea02`,
	Warning: `\uea03`,
	Forward: `\uea04`,
	Attach: `\uea05`,
	Folder: `\uea06`,
	Inbox: `\uea07`,
	Sent: `\uea08`,
	Trash: `\uea09`,
	Archive: `\uea0a`,
	Spam: `\uea0b`,
	Draft: `\uea0c`,
	Edit: `\uea0d`,
	Confidential: `\uea0e`,
	PQConfidential: `\uea0f`,
	Checkbox: `\uea10`
});

//#endregion
//#region ../src/mail-app/mail/view/MailGuiUtils.ts
async function showDeleteConfirmationDialog(mails) {
	let trashMails = [];
	let moveMails$1 = [];
	for (let mail of mails) {
		const folder = mailLocator.mailModel.getMailFolderForMail(mail);
		const folders = await mailLocator.mailModel.getMailboxFoldersForMail(mail);
		if (folders == null) continue;
		const isFinalDelete = folder && isSpamOrTrashFolder(folders, folder);
		if (isFinalDelete) trashMails.push(mail);
else moveMails$1.push(mail);
	}
	let confirmationTextId = null;
	if (trashMails.length > 0) if (moveMails$1.length > 0) confirmationTextId = "finallyDeleteSelectedEmails_msg";
else confirmationTextId = "finallyDeleteEmails_msg";
	if (confirmationTextId != null) return Dialog.confirm(confirmationTextId, "ok_action");
else return Promise.resolve(true);
}
function promptAndDeleteMails(mailModel, mails, onConfirm) {
	return showDeleteConfirmationDialog(mails).then((confirmed) => {
		if (confirmed) {
			onConfirm();
			return mailModel.deleteMails(mails).then(() => true).catch((e) => {
				if (e instanceof PreconditionFailedError || e instanceof LockedError) return Dialog.message("operationStillActive_msg").then(() => false);
else throw e;
			});
		} else return Promise.resolve(false);
	});
}
async function moveMails({ mailboxModel, mailModel, mails, targetMailFolder, isReportable = true }) {
	const details = await mailModel.getMailboxDetailsForMailFolder(targetMailFolder);
	if (details == null || details.mailbox.folders == null) return false;
	const system = await mailModel.getMailboxFoldersForId(details.mailbox.folders._id);
	return mailModel.moveMails(mails, targetMailFolder).then(async () => {
		if (isOfTypeOrSubfolderOf(system, targetMailFolder, MailSetKind.SPAM) && isReportable) {
			const reportableMails = mails.map((mail) => {
				const reportableMail = createMail(mail);
				reportableMail._id = targetMailFolder.isMailSet ? mail._id : [targetMailFolder.mails, getElementId(mail)];
				return reportableMail;
			});
			const mailboxDetails = await mailboxModel.getMailboxDetailsForMailGroup(assertNotNull(targetMailFolder._ownerGroup));
			await reportMailsAutomatically(MailReportType.SPAM, mailboxModel, mailModel, mailboxDetails, reportableMails);
		}
		return true;
	}).catch((e) => {
		if (e instanceof LockedError || e instanceof PreconditionFailedError) return Dialog.message("operationStillActive_msg").then(() => false);
else throw e;
	});
}
function getFolderIconByType(folderType) {
	switch (folderType) {
		case MailSetKind.CUSTOM: return Icons.Folder;
		case MailSetKind.INBOX: return Icons.Inbox;
		case MailSetKind.SENT: return Icons.Send;
		case MailSetKind.TRASH: return Icons.TrashBin;
		case MailSetKind.ARCHIVE: return Icons.Archive;
		case MailSetKind.SPAM: return Icons.Spam;
		case MailSetKind.DRAFT: return Icons.Draft;
		default: return Icons.Folder;
	}
}
function getFolderIcon(folder) {
	return getFolderIconByType(getMailFolderType(folder));
}
function getMailFolderIcon(mail) {
	let folder = mailLocator.mailModel.getMailFolderForMail(mail);
	if (folder) return getFolderIcon(folder);
else return Icons.Folder;
}
function replaceCidsWithInlineImages(dom, inlineImages, onContext) {
	const imageElements = Array.from(dom.querySelectorAll("img[cid]"));
	if (dom.shadowRoot) {
		const shadowImageElements = Array.from(dom.shadowRoot.querySelectorAll("img[cid]"));
		imageElements.push(...shadowImageElements);
	}
	const elementsWithCid = [];
	for (const imageElement of imageElements) {
		const cid = imageElement.getAttribute("cid");
		if (cid) {
			const inlineImage = inlineImages.get(cid);
			if (inlineImage) {
				elementsWithCid.push(imageElement);
				imageElement.setAttribute("src", inlineImage.objectUrl);
				imageElement.classList.remove("tutanota-placeholder");
				if (isApp()) {
					let timeoutId;
					let startCoords;
					imageElement.addEventListener("touchstart", (e) => {
						const touch = e.touches[0];
						if (!touch) return;
						startCoords = {
							x: touch.clientX,
							y: touch.clientY
						};
						if (timeoutId) clearTimeout(timeoutId);
						timeoutId = setTimeout(() => {
							onContext(inlineImage.cid, e, imageElement);
						}, 800);
					});
					imageElement.addEventListener("touchmove", (e) => {
						const touch = e.touches[0];
						if (!touch || !startCoords || !timeoutId) return;
						if (Math.abs(touch.clientX - startCoords.x) > PinchZoom.DRAG_THRESHOLD || Math.abs(touch.clientY - startCoords.y) > PinchZoom.DRAG_THRESHOLD) {
							clearTimeout(timeoutId);
							timeoutId = null;
						}
					});
					imageElement.addEventListener("touchend", () => {
						if (timeoutId) {
							clearTimeout(timeoutId);
							timeoutId = null;
						}
					});
				}
				if (isDesktop()) imageElement.addEventListener("contextmenu", (e) => {
					onContext(inlineImage.cid, e, imageElement);
					e.preventDefault();
				});
			}
		}
	}
	return elementsWithCid;
}
function replaceInlineImagesWithCids(dom) {
	const domClone = dom.cloneNode(true);
	const inlineImages = Array.from(domClone.querySelectorAll("img[cid]"));
	for (const inlineImage of inlineImages) {
		const cid = inlineImage.getAttribute("cid");
		inlineImage.setAttribute("src", "cid:" + (cid || ""));
		inlineImage.removeAttribute("cid");
	}
	return domClone;
}
function createInlineImage(file) {
	const cid = Math.random().toString(30).substring(2);
	file.cid = cid;
	return createInlineImageReference(file, cid);
}
function createInlineImageReference(file, cid) {
	const blob = new Blob([file.data], { type: file.mimeType });
	const objectUrl = URL.createObjectURL(blob);
	return {
		cid,
		objectUrl,
		blob
	};
}
async function loadInlineImages(fileController, attachments, referencedCids) {
	const filesToLoad = getReferencedAttachments(attachments, referencedCids);
	const inlineImages = new Map();
	return pMap(filesToLoad, async (file) => {
		let dataFile = await fileController.getAsDataFile(file);
		const { htmlSanitizer } = await import("./HtmlSanitizer-DJqF9m1z.js");
		dataFile = htmlSanitizer.sanitizeInlineAttachment(dataFile);
		const inlineImageReference = createInlineImageReference(dataFile, neverNull(file.cid));
		inlineImages.set(inlineImageReference.cid, inlineImageReference);
	}).then(() => inlineImages);
}
function getReferencedAttachments(attachments, referencedCids) {
	return attachments.filter((file) => referencedCids.find((rcid) => file.cid === rcid));
}
function isTutanotaTeamAddress(address) {
	return endsWith(address, "@tutao.de") || address === "no-reply@tutanota.de";
}
function isTutanotaTeamMail(mail) {
	const { confidential, sender, state } = mail;
	return confidential && state === MailState.RECEIVED && hasValidEncryptionAuthForTeamOrSystemMail(mail) && (sender.address === SYSTEM_GROUP_MAIL_ADDRESS || isTutanotaTeamAddress(sender.address));
}
function getConfidentialIcon(mail) {
	if (!mail.confidential) throw new ProgrammingError("mail is not confidential");
	if (mail.encryptionAuthStatus == EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED || mail.encryptionAuthStatus == EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED || mail.encryptionAuthStatus == EncryptionAuthStatus.TUTACRYPT_SENDER) return Icons.PQLock;
else return Icons.Lock;
}
function isMailContrastFixNeeded(editorDom) {
	return Array.from(editorDom.querySelectorAll("*[style]"), (e) => e.style).some((s) => s.color && s.color !== "inherit" || s.backgroundColor && s.backgroundColor !== "inherit") || editorDom.querySelectorAll("font[color]").length > 0;
}

//#endregion
//#region ../src/mail-app/mail/view/MailViewerUtils.ts
async function loadMailDetails(mailFacade, mail) {
	if (isDraft(mail)) {
		const detailsDraftId = assertNotNull(mail.mailDetailsDraft);
		return mailFacade.loadMailDetailsDraft(mail);
	} else {
		const mailDetailsId = neverNull(mail.mailDetails);
		return mailFacade.loadMailDetailsBlob(mail);
	}
}
function isNoReplyTeamAddress(address) {
	return address === "no-reply@tutao.de" || address === "no-reply@tutanota.de";
}
function isSystemNotification(mail) {
	const { confidential, sender, state } = mail;
	return state === MailState.RECEIVED && confidential && hasValidEncryptionAuthForTeamOrSystemMail(mail) && (sender.address === SYSTEM_GROUP_MAIL_ADDRESS || isNoReplyTeamAddress(sender.address));
}
function getRecipientHeading(mail, preferNameOnly) {
	let recipientCount = parseInt(mail.recipientCount);
	if (recipientCount > 0) {
		let recipient = neverNull(mail.firstRecipient);
		return getMailAddressDisplayText(recipient.name, recipient.address, preferNameOnly) + (recipientCount > 1 ? ", ..." : "");
	} else return "";
}
function getSenderOrRecipientHeading(mail, preferNameOnly) {
	if (isSystemNotification(mail)) return "";
else if (mail.state === MailState.RECEIVED) {
		const sender = getDisplayedSender(mail);
		return getMailAddressDisplayText(sender.name, sender.address, preferNameOnly);
	} else return getRecipientHeading(mail, preferNameOnly);
}
let MailFilterType = function(MailFilterType$1) {
	MailFilterType$1[MailFilterType$1["Unread"] = 0] = "Unread";
	MailFilterType$1[MailFilterType$1["Read"] = 1] = "Read";
	MailFilterType$1[MailFilterType$1["WithAttachments"] = 2] = "WithAttachments";
	return MailFilterType$1;
}({});
function getMailFilterForType(filter) {
	switch (filter) {
		case MailFilterType.Read: return (mail) => !mail.unread;
		case MailFilterType.Unread: return (mail) => mail.unread;
		case MailFilterType.WithAttachments: return (mail) => mail.attachments.length > 0;
		case null: return null;
	}
}

//#endregion
//#region ../src/mail-app/mail/export/Bundler.ts
function makeMailBundle(sanitizer, mail, mailDetails, attachments) {
	const recipientMapper = ({ address, name }) => ({
		address,
		name
	});
	const body = sanitizer.sanitizeHTML(getMailBodyText(mailDetails.body), {
		blockExternalContent: false,
		allowRelativeLinks: false,
		usePlaceholderForInlineImages: false
	}).html;
	return {
		mailId: getLetId(mail),
		subject: mail.subject,
		body,
		sender: recipientMapper(getDisplayedSender(mail)),
		to: mailDetails.recipients.toRecipients.map(recipientMapper),
		cc: mailDetails.recipients.ccRecipients.map(recipientMapper),
		bcc: mailDetails.recipients.bccRecipients.map(recipientMapper),
		replyTo: mailDetails.replyTos.map(recipientMapper),
		isDraft: mail.state === MailState.DRAFT,
		isRead: !mail.unread,
		sentOn: mailDetails.sentDate.getTime(),
		receivedOn: mail.receivedDate.getTime(),
		headers: mailDetails.headers?.compressedHeaders ?? mailDetails.headers?.headers ?? null,
		attachments
	};
}
async function downloadMailBundle(mail, mailFacade, entityClient, fileController, sanitizer, cryptoFacade) {
	const mailDetails = await loadMailDetails(mailFacade, mail);
	const files = await pMap(mail.attachments, async (fileId) => await entityClient.load(FileTypeRef, fileId));
	const attachments = await pMap(await cryptoFacade.enforceSessionKeyUpdateIfNeeded(mail, files), async (file) => await fileController.getAsDataFile(file));
	return makeMailBundle(sanitizer, mail, mailDetails, attachments);
}

//#endregion
//#region ../src/mail-app/mail/export/Exporter.ts
async function generateMailFile(bundle, fileName, mode) {
	return mode === "eml" ? mailToEmlFile(bundle, fileName) : locator.fileApp.mailToMsg(bundle, fileName);
}
async function getMailExportMode() {
	if (isDesktop()) {
		const ConfigKeys = await import("./ConfigKeys-DgG5bXPY.js");
		const mailExportMode = await locator.desktopSettingsFacade.getStringConfigValue(ConfigKeys.DesktopConfigKey.mailExportMode).catch(noOp);
		return mailExportMode ?? "eml";
	} else return "eml";
}
async function exportMails(mails, mailFacade, entityClient, fileController, cryptoFacade, operationId, signal) {
	let cancelled = false;
	const onAbort = () => {
		cancelled = true;
	};
	try {
		const totalMails = mails.length * 3;
		let doneMails = 0;
		const errorMails = [];
		signal?.addEventListener("abort", onAbort);
		const updateProgress = operationId !== undefined ? () => locator.operationProgressTracker.onProgress(operationId, ++doneMails / totalMails * 100) : noOp;
		const checkAbortSignal = () => {
			if (cancelled) throw new CancelledError("export cancelled");
		};
		const downloadPromise = pMap(mails, async (mail) => {
			checkAbortSignal();
			try {
				const { htmlSanitizer } = await import("./HtmlSanitizer-DJqF9m1z.js");
				return await downloadMailBundle(mail, mailFacade, entityClient, fileController, htmlSanitizer, cryptoFacade);
			} catch (e) {
				errorMails.push(mail);
			} finally {
				updateProgress();
				updateProgress();
			}
		});
		const [mode, bundles] = await Promise.all([getMailExportMode(), downloadPromise]);
		const dataFiles = [];
		for (const bundle of bundles) {
			if (!bundle) continue;
			checkAbortSignal();
			const mailFile = await generateMailFile(bundle, generateExportFileName(elementIdPart(bundle.mailId), bundle.subject, new Date(bundle.receivedOn), mode), mode);
			dataFiles.push(mailFile);
			updateProgress();
		}
		const zipName = `${sortableTimestamp()}-${mode}-mail-export.zip`;
		const outputFile = await (dataFiles.length === 1 ? dataFiles[0] : zipDataFiles(dataFiles, zipName));
		await fileController.saveDataFile(outputFile);
		return { failed: errorMails };
	} catch (e) {
		if (e.name !== "CancelledError") throw e;
	} finally {
		signal?.removeEventListener("abort", onAbort);
	}
	return { failed: [] };
}

//#endregion
//#region ../src/mail-app/mail/view/MailViewerViewModel.ts
var import_stream = __toESM(require_stream(), 1);
let ContentBlockingStatus = function(ContentBlockingStatus$1) {
	ContentBlockingStatus$1["Block"] = "0";
	ContentBlockingStatus$1["Show"] = "1";
	ContentBlockingStatus$1["AlwaysShow"] = "2";
	ContentBlockingStatus$1["NoExternalContent"] = "3";
	ContentBlockingStatus$1["AlwaysBlock"] = "4";
	return ContentBlockingStatus$1;
}({});
var MailViewerViewModel = class {
	contrastFixNeeded = false;
	sanitizeResult = null;
	loadingAttachments = false;
	attachments = [];
	contentBlockingStatus = null;
	errorOccurred = false;
	loadedInlineImages = null;
	/** only loaded when showFolder is set to true */
	folderMailboxText;
	/** @see getRelevantRecipient */
	relevantRecipient = null;
	warningDismissed = false;
	calendarEventAttachment = null;
	loadingState = new LoadingStateTracker();
	renderIsDelayed = true;
	loadCompleteNotification = (0, import_stream.default)();
	renderedMail = null;
	loading = null;
	collapsed = true;
	get mail() {
		return this._mail;
	}
	mailDetails = null;
	constructor(_mail, showFolder, entityClient, mailboxModel, mailModel, contactModel, configFacade, fileController, logins, sendMailModelFactory, eventController, workerFacade, searchModel, mailFacade, cryptoFacade, contactImporter) {
		this._mail = _mail;
		this.entityClient = entityClient;
		this.mailboxModel = mailboxModel;
		this.mailModel = mailModel;
		this.contactModel = contactModel;
		this.configFacade = configFacade;
		this.fileController = fileController;
		this.logins = logins;
		this.sendMailModelFactory = sendMailModelFactory;
		this.eventController = eventController;
		this.workerFacade = workerFacade;
		this.searchModel = searchModel;
		this.mailFacade = mailFacade;
		this.cryptoFacade = cryptoFacade;
		this.contactImporter = contactImporter;
		this.folderMailboxText = null;
		if (showFolder) this.showFolder();
		this.eventController.addEntityListener(this.entityListener);
	}
	entityListener = async (events) => {
		for (const update of events) if (isUpdateForTypeRef(MailTypeRef, update)) {
			const { instanceListId, instanceId, operation } = update;
			if (operation === OperationType.UPDATE && isSameId(this.mail._id, [instanceListId, instanceId])) try {
				const updatedMail = await this.entityClient.load(MailTypeRef, this.mail._id);
				this.updateMail({ mail: updatedMail });
			} catch (e) {
				if (e instanceof NotFoundError) console.log(`Could not find updated mail ${JSON.stringify([instanceListId, instanceId])}`);
else throw e;
			}
		}
	};
	async determineRelevantRecipient() {
		const mailboxDetails = await this.mailModel.getMailboxDetailsForMail(this.mail);
		if (mailboxDetails == null) return;
		const enabledMailAddresses = new Set(getEnabledMailAddressesWithUser(mailboxDetails, this.logins.getUserController().userGroupInfo));
		if (this.mailDetails == null) return;
		this.relevantRecipient = this.mailDetails.recipients.toRecipients.find((r) => enabledMailAddresses.has(r.address)) ?? this.mailDetails.recipients.ccRecipients.find((r) => enabledMailAddresses.has(r.address)) ?? this.mailDetails.recipients.bccRecipients.find((r) => enabledMailAddresses.has(r.address)) ?? first(this.mailDetails.recipients.toRecipients) ?? first(this.mailDetails.recipients.ccRecipients) ?? first(this.mailDetails.recipients.bccRecipients);
		mithril_default.redraw();
	}
	showFolder() {
		this.folderMailboxText = null;
		const folder = this.mailModel.getMailFolderForMail(this.mail);
		if (folder) this.mailModel.getMailboxDetailsForMail(this.mail).then(async (mailboxDetails) => {
			if (mailboxDetails == null || mailboxDetails.mailbox.folders == null) return;
			const folders = await this.mailModel.getMailboxFoldersForId(mailboxDetails.mailbox.folders._id);
			const name = getPathToFolderString(folders, folder);
			this.folderMailboxText = `${getMailboxName(this.logins, mailboxDetails)} / ${name}`;
			mithril_default.redraw();
		});
	}
	dispose() {
		this.dispose = () => console.log("disposed MailViewerViewModel a second time, ignoring");
		this.eventController.removeEntityListener(this.entityListener);
		const inlineImages = this.getLoadedInlineImages();
		revokeInlineImages(inlineImages);
	}
	async loadAll(delay, { notify } = { notify: true }) {
		this.renderIsDelayed = true;
		try {
			await this.loading;
			try {
				this.loading = this.loadAndProcessAdditionalMailInfo(this.mail, delay).then((inlineImageCids) => {
					this.determineRelevantRecipient();
					return inlineImageCids;
				}).then((inlineImageCids) => this.loadAttachments(this.mail, inlineImageCids));
				await this.loadingState.trackPromise(this.loading);
				if (notify) this.loadCompleteNotification(null);
			} catch (e) {
				this.loading = null;
				if (!isOfflineError(e)) throw e;
			}
			mithril_default.redraw();
			this.entityClient.load(ConversationEntryTypeRef, this.mail.conversationEntry).catch((e) => {
				if (e instanceof NotFoundError) console.log("could load conversation entry as it has been moved/deleted already", e);
else if (isOfflineError(e)) console.log("failed to load conversation entry, because of a lost connection", e);
else throw e;
			});
		} finally {
			this.renderIsDelayed = false;
		}
	}
	isLoading() {
		return this.loadingState.isLoading();
	}
	isConnectionLost() {
		return this.loadingState.isConnectionLost();
	}
	getAttachments() {
		return this.attachments;
	}
	getInlineCids() {
		return this.sanitizeResult?.inlineImageCids ?? [];
	}
	getLoadedInlineImages() {
		return this.loadedInlineImages ?? new Map();
	}
	isContrastFixNeeded() {
		return this.contrastFixNeeded;
	}
	isDraftMail() {
		return this.mail.state === MailState.DRAFT;
	}
	isReceivedMail() {
		return this.mail.state === MailState.RECEIVED;
	}
	isLoadingAttachments() {
		return this.loadingAttachments;
	}
	getFolderMailboxText() {
		return this.folderMailboxText;
	}
	getFolderInfo() {
		const folder = this.mailModel.getMailFolderForMail(this.mail);
		if (!folder) return null;
		return {
			folderType: folder.folderType,
			name: getFolderName(folder)
		};
	}
	getSubject() {
		return this.mail.subject;
	}
	isConfidential() {
		return this.mail.confidential;
	}
	isMailSuspicious() {
		return this.mail.phishingStatus === MailPhishingStatus.SUSPICIOUS;
	}
	getMailId() {
		return this.mail._id;
	}
	getSanitizedMailBody() {
		return this.sanitizeResult?.fragment ?? null;
	}
	getMailBody() {
		if (this.mailDetails) return getMailBodyText(this.mailDetails.body);
else return "";
	}
	getDate() {
		return this.mail.receivedDate;
	}
	getToRecipients() {
		if (this.mailDetails === null) return [];
		return this.mailDetails.recipients.toRecipients;
	}
	getCcRecipients() {
		if (this.mailDetails === null) return [];
		return this.mailDetails.recipients.ccRecipients;
	}
	getBccRecipients() {
		if (this.mailDetails === null) return [];
		return this.mailDetails.recipients.bccRecipients;
	}
	/** Get the recipient which is relevant the most for the current mailboxes. */
	getRelevantRecipient() {
		return this.relevantRecipient;
	}
	getNumberOfRecipients() {
		return filterInt(this.mail.recipientCount);
	}
	getReplyTos() {
		if (this.mailDetails === null) return [];
		return this.mailDetails.replyTos;
	}
	getSender() {
		return this.mail.sender;
	}
	/**
	* Can be {@code null} if sender should not be displayed e.g. for system notifications.
	*/
	getDisplayedSender() {
		if (isSystemNotification(this.mail)) return null;
else return getDisplayedSender(this.mail);
	}
	getPhishingStatus() {
		return this.mail.phishingStatus;
	}
	setPhishingStatus(status) {
		this.mail.phishingStatus = status;
	}
	checkMailAuthenticationStatus(status) {
		if (this.mail.authStatus != null) return this.mail.authStatus === status;
else if (this.mailDetails) return this.mailDetails.authStatus === status;
else return false;
	}
	canCreateSpamRule() {
		return this.logins.isGlobalAdminUserLoggedIn() && !this.logins.isEnabled(FeatureType.InternalCommunication);
	}
	didErrorsOccur() {
		let bodyErrors = false;
		if (this.mailDetails) bodyErrors = typeof downcast(this.mailDetails.body)._errors !== "undefined";
		return this.errorOccurred || typeof this.mail._errors !== "undefined" || bodyErrors;
	}
	isTutanotaTeamMail() {
		return isTutanotaTeamMail(this.mail);
	}
	isShowingExternalContent() {
		return this.contentBlockingStatus === ContentBlockingStatus.Show || this.contentBlockingStatus === ContentBlockingStatus.AlwaysShow;
	}
	isBlockingExternalImages() {
		return this.contentBlockingStatus === ContentBlockingStatus.Block || this.contentBlockingStatus === ContentBlockingStatus.AlwaysBlock;
	}
	getDifferentEnvelopeSender() {
		return this.mail.differentEnvelopeSender;
	}
	getCalendarEventAttachment() {
		return this.calendarEventAttachment;
	}
	getContentBlockingStatus() {
		return this.contentBlockingStatus;
	}
	isWarningDismissed() {
		return this.warningDismissed;
	}
	setWarningDismissed(dismissed) {
		this.warningDismissed = dismissed;
	}
	async setContentBlockingStatus(status) {
		if (status === ContentBlockingStatus.NoExternalContent || this.contentBlockingStatus === ContentBlockingStatus.NoExternalContent || this.contentBlockingStatus === status) return;
		if (status === ContentBlockingStatus.AlwaysShow) this.configFacade.addExternalImageRule(this.getSender().address, ExternalImageRule.Allow).catch(ofClass(IndexingNotSupportedError, noOp));
else if (status === ContentBlockingStatus.AlwaysBlock) this.configFacade.addExternalImageRule(this.getSender().address, ExternalImageRule.Block).catch(ofClass(IndexingNotSupportedError, noOp));
else this.configFacade.addExternalImageRule(this.getSender().address, ExternalImageRule.None).catch(ofClass(IndexingNotSupportedError, noOp));
		this.sanitizeResult = await this.sanitizeMailBody(this.mail, status === ContentBlockingStatus.Block || status === ContentBlockingStatus.AlwaysBlock);
		this.contentBlockingStatus = status;
	}
	async markAsNotPhishing() {
		const oldStatus = this.getPhishingStatus();
		if (oldStatus === MailPhishingStatus.WHITELISTED) return;
		this.setPhishingStatus(MailPhishingStatus.WHITELISTED);
		await this.entityClient.update(this.mail).catch(() => this.setPhishingStatus(oldStatus));
	}
	async reportMail(reportType) {
		try {
			await this.mailModel.reportMails(reportType, [this.mail]);
			if (reportType === MailReportType.PHISHING) {
				this.setPhishingStatus(MailPhishingStatus.SUSPICIOUS);
				await this.entityClient.update(this.mail);
			}
			const mailboxDetail = await this.mailModel.getMailboxDetailsForMail(this.mail);
			if (mailboxDetail == null || mailboxDetail.mailbox.folders == null) return;
			const folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id);
			const spamFolder = assertSystemFolderOfType(folders, MailSetKind.SPAM);
			await moveMails({
				mailboxModel: this.mailboxModel,
				mailModel: this.mailModel,
				mails: [this.mail],
				targetMailFolder: spamFolder,
				isReportable: false
			});
		} catch (e) {
			if (e instanceof NotFoundError) console.log("mail already moved");
else throw e;
		}
	}
	canExport() {
		return !this.isAnnouncement() && !this.logins.isEnabled(FeatureType.DisableMailExport);
	}
	canPrint() {
		return !this.logins.isEnabled(FeatureType.DisableMailExport);
	}
	canReport() {
		return this.getPhishingStatus() === MailPhishingStatus.UNKNOWN && !this.isTutanotaTeamMail() && this.logins.isInternalUserLoggedIn();
	}
	canShowHeaders() {
		return this.logins.isInternalUserLoggedIn();
	}
	canPersistBlockingStatus() {
		return this.searchModel.indexingSupported;
	}
	async exportMail() {
		await exportMails([this.mail], this.mailFacade, this.entityClient, this.fileController, this.cryptoFacade);
	}
	async getHeaders() {
		const mailDetails = await loadMailDetails(this.mailFacade, this.mail);
		return loadMailHeaders(mailDetails);
	}
	isUnread() {
		return this.mail.unread;
	}
	async setUnread(unread) {
		if (this.mail.unread !== unread) {
			this.mail.unread = unread;
			await this.entityClient.update(this.mail).catch(ofClass(LockedError, () => console.log("could not update mail read state: ", lang.get("operationStillActive_msg")))).catch(ofClass(NotFoundError, noOp));
		}
	}
	isListUnsubscribe() {
		return this.mail.listUnsubscribe;
	}
	isAnnouncement() {
		const replyTos = this.mailDetails?.replyTos;
		return isSystemNotification(this.mail) && (replyTos == null || replyTos?.length === 0 || replyTos?.length === 1 && isNoReplyTeamAddress(replyTos[0].address));
	}
	async unsubscribe() {
		if (!this.isListUnsubscribe()) return false;
		const mailHeaders = await this.getHeaders();
		if (!mailHeaders) return false;
		const unsubHeaders = mailHeaders.replaceAll(/\r\n/g, "\n").replaceAll(/\n[ \t]/g, "").split("\n").filter((headerLine) => headerLine.toLowerCase().startsWith("list-unsubscribe"));
		if (unsubHeaders.length > 0) {
			const recipient = await this.getSenderOfResponseMail();
			await this.mailModel.unsubscribe(this.mail, recipient, unsubHeaders);
			return true;
		} else return false;
	}
	getMailboxDetails() {
		return this.mailModel.getMailboxDetailsForMail(this.mail);
	}
	/** @return list of inline referenced cid */
	async loadAndProcessAdditionalMailInfo(mail, delayBodyRenderingUntil) {
		let isDraft$1 = mail.state === MailState.DRAFT;
		if (this.renderedMail != null && haveSameId(mail, this.renderedMail) && !isDraft$1 && this.sanitizeResult != null) return this.sanitizeResult.inlineImageCids;
		try {
			this.mailDetails = await loadMailDetails(this.mailFacade, this.mail);
		} catch (e) {
			if (e instanceof NotFoundError) {
				console.log("could load mail body as it has been moved/deleted already", e);
				this.errorOccurred = true;
				return [];
			}
			if (e instanceof NotAuthorizedError) {
				console.log("could load mail body as the permission is missing", e);
				this.errorOccurred = true;
				return [];
			}
			throw e;
		}
		const externalImageRule = await this.configFacade.getExternalImageRule(mail.sender.address).catch((e) => {
			console.log("Error getting external image rule:", e);
			return ExternalImageRule.None;
		});
		const isAllowedAndAuthenticatedExternalSender = externalImageRule === ExternalImageRule.Allow && this.checkMailAuthenticationStatus(MailAuthenticationStatus.AUTHENTICATED);
		await delayBodyRenderingUntil;
		this.renderIsDelayed = false;
		this.sanitizeResult = await this.sanitizeMailBody(mail, !isAllowedAndAuthenticatedExternalSender);
		if (!isDraft$1) this.checkMailForPhishing(mail, this.sanitizeResult.links);
		this.contentBlockingStatus = externalImageRule === ExternalImageRule.Block ? ContentBlockingStatus.AlwaysBlock : isAllowedAndAuthenticatedExternalSender ? ContentBlockingStatus.AlwaysShow : this.sanitizeResult.blockedExternalContent > 0 ? ContentBlockingStatus.Block : ContentBlockingStatus.NoExternalContent;
		mithril_default.redraw();
		this.renderedMail = this.mail;
		return this.sanitizeResult.inlineImageCids;
	}
	async loadAttachments(mail, inlineCids) {
		if (mail.attachments.length === 0) {
			this.loadingAttachments = false;
			mithril_default.redraw();
		} else {
			this.loadingAttachments = true;
			try {
				const files = await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, await this.mailFacade.loadAttachments(mail));
				this.handleCalendarFile(files, mail);
				this.attachments = files;
				this.loadingAttachments = false;
				mithril_default.redraw();
				if (this.loadedInlineImages == null) this.loadedInlineImages = await loadInlineImages(this.fileController, files, inlineCids);
				mithril_default.redraw();
			} catch (e) {
				if (e instanceof NotFoundError) console.log("could load attachments as they have been moved/deleted already", e);
else throw e;
			}
		}
	}
	checkMailForPhishing(mail, links) {
		if (mail.phishingStatus === MailPhishingStatus.UNKNOWN) {
			const linkObjects = links.map((link) => {
				return {
					href: link.getAttribute("href") || "",
					innerHTML: link.innerHTML
				};
			});
			this.mailModel.checkMailForPhishing(mail, linkObjects).then((isSuspicious) => {
				if (isSuspicious) {
					mail.phishingStatus = MailPhishingStatus.SUSPICIOUS;
					this.entityClient.update(mail).catch(ofClass(LockedError, (e) => console.log("could not update mail phishing status as mail is locked"))).catch(ofClass(NotFoundError, (e) => console.log("mail already moved")));
					mithril_default.redraw();
				}
			});
		}
	}
	/**
	* Check if the list of files contain an iCal file which we can then load and display details for. A calendar notification
	* should contain only one iCal attachment, so we only process the first matching one.
	*
	* (this is not true for ie google calendar, they send the invite twice in each mail, but it's always the same file twice)
	*/
	handleCalendarFile(files, mail) {
		const calendarFile = files.find((a) => a.mimeType && a.mimeType.startsWith(CALENDAR_MIME_TYPE));
		if (calendarFile && (mail.method === MailMethod.ICAL_REQUEST || mail.method === MailMethod.ICAL_REPLY) && mail.state === MailState.RECEIVED) Promise.all([import("./CalendarInvites-vQV5UEa1.js").then(({ getEventsFromFile }) => getEventsFromFile(calendarFile, mail.confidential)), this.getSenderOfResponseMail()]).then(([contents, recipient]) => {
			this.calendarEventAttachment = contents != null ? {
				contents,
				recipient
			} : null;
			mithril_default.redraw();
		});
	}
	getSenderOfResponseMail() {
		return this.mailModel.getMailboxDetailsForMail(this.mail).then(async (mailboxDetails) => {
			assertNonNull(mailboxDetails, "Mail list does not exist anymore");
			const myMailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, this.logins.getUserController().userGroupInfo);
			const addressesInMail = [];
			const mailDetails = await loadMailDetails(this.mailFacade, this.mail);
			addressesInMail.push(...mailDetails.recipients.toRecipients);
			addressesInMail.push(...mailDetails.recipients.ccRecipients);
			addressesInMail.push(...mailDetails.recipients.bccRecipients);
			const mailAddressAndName = this.getDisplayedSender();
			if (mailAddressAndName) addressesInMail.push(createMailAddress({
				name: mailAddressAndName.name,
				address: mailAddressAndName.address,
				contact: null
			}));
			const foundAddress = addressesInMail.find((address) => contains(myMailAddresses, address.address.toLowerCase()));
			if (foundAddress) return foundAddress.address.toLowerCase();
else return getDefaultSender(this.logins, mailboxDetails);
		});
	}
	/** @throws UserError */
	async forward() {
		const sendAllowed = await checkApprovalStatus(this.logins, false);
		if (sendAllowed) {
			const args = await this.createResponseMailArgsForForwarding([], [], true);
			const [mailboxDetails, { newMailEditorAsResponse }] = await Promise.all([this.getMailboxDetails(), import("./MailEditor-BuqlXNUT.js")]);
			if (mailboxDetails == null) return;
			const isReloadNeeded = !this.sanitizeResult || this.mail.attachments.length !== this.attachments.length;
			if (isReloadNeeded) await this.loadAll(Promise.resolve(), { notify: true });
			const editor = await newMailEditorAsResponse(args, this.isBlockingExternalImages(), this.getLoadedInlineImages(), mailboxDetails);
			editor.show();
		}
	}
	async createResponseMailArgsForForwarding(recipients, replyTos, addSignature) {
		let infoLine = lang.get("date_label") + ": " + formatDateTime(this.mail.receivedDate) + "<br>";
		const senderAddress = this.getDisplayedSender()?.address;
		if (senderAddress) infoLine += lang.get("from_label") + ": " + senderAddress + "<br>";
		if (this.getToRecipients().length > 0) {
			infoLine += lang.get("to_label") + ": " + this.getToRecipients().map((recipient) => recipient.address).join(", ");
			infoLine += "<br>";
		}
		if (this.getCcRecipients().length > 0) {
			infoLine += lang.get("cc_label") + ": " + this.getCcRecipients().map((recipient) => recipient.address).join(", ");
			infoLine += "<br>";
		}
		const mailSubject = this.getSubject() || "";
		infoLine += lang.get("subject_label") + ": " + urlEncodeHtmlTags(mailSubject);
		let body = infoLine + "<br><br><blockquote class=\"tutanota_quote\">" + this.getMailBody() + "</blockquote>";
		const { prependEmailSignature } = await import("./Signature-BcT8dcyW.js");
		const senderMailAddress = await this.getSenderOfResponseMail();
		return {
			previousMail: this.mail,
			conversationType: ConversationType.FORWARD,
			senderMailAddress,
			recipients,
			attachments: this.attachments.slice(),
			subject: "FWD: " + mailSubject,
			bodyText: addSignature ? prependEmailSignature(body, this.logins) : body,
			replyTos
		};
	}
	async reply(replyAll) {
		if (this.isAnnouncement()) return;
		const sendAllowed = await checkApprovalStatus(this.logins, false);
		if (sendAllowed) {
			const mailboxDetails = await this.mailModel.getMailboxDetailsForMail(this.mail);
			if (mailboxDetails == null) return;
			const mailAddressAndName = getDisplayedSender(this.mail);
			const sender = createMailAddress({
				name: mailAddressAndName.name,
				address: mailAddressAndName.address,
				contact: null
			});
			let prefix = "Re: ";
			const mailSubject = this.getSubject();
			let subject = mailSubject ? startsWith(mailSubject.toUpperCase(), prefix.toUpperCase()) ? mailSubject : prefix + mailSubject : "";
			let infoLine = formatDateTime(this.getDate()) + " " + lang.get("by_label") + " " + sender.address + ":";
			let body = infoLine + "<br><blockquote class=\"tutanota_quote\">" + this.getMailBody() + "</blockquote>";
			let toRecipients = [];
			let ccRecipients = [];
			let bccRecipients = [];
			if (!this.logins.getUserController().isInternalUser() && this.isReceivedMail()) toRecipients.push(sender);
else if (this.isReceivedMail()) {
				if (this.getReplyTos().some((address) => !downcast(address)._errors)) addAll(toRecipients, this.getReplyTos());
else toRecipients.push(sender);
				if (replyAll) {
					let myMailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, this.logins.getUserController().userGroupInfo);
					addAll(ccRecipients, this.getToRecipients().filter((recipient) => !contains(myMailAddresses, recipient.address.toLowerCase())));
					addAll(ccRecipients, this.getCcRecipients().filter((recipient) => !contains(myMailAddresses, recipient.address.toLowerCase())));
				}
			} else {
				addAll(toRecipients, this.getToRecipients());
				if (replyAll) {
					addAll(ccRecipients, this.getCcRecipients());
					addAll(bccRecipients, this.getBccRecipients());
				}
			}
			const { prependEmailSignature } = await import("./Signature-BcT8dcyW.js");
			const { newMailEditorAsResponse } = await import("./MailEditor-BuqlXNUT.js");
			const isReloadNeeded = !this.sanitizeResult || this.mail.attachments.length !== this.attachments.length;
			if (isReloadNeeded) await this.loadAll(Promise.resolve(), { notify: true });
			const inlineImageCids = this.sanitizeResult?.inlineImageCids ?? [];
			const [senderMailAddress, referencedCids] = await Promise.all([this.getSenderOfResponseMail(), inlineImageCids]);
			const attachmentsForReply = getReferencedAttachments(this.attachments, referencedCids);
			try {
				const editor = await newMailEditorAsResponse({
					previousMail: this.mail,
					conversationType: ConversationType.REPLY,
					senderMailAddress,
					recipients: {
						to: toRecipients,
						cc: ccRecipients,
						bcc: bccRecipients
					},
					attachments: attachmentsForReply,
					subject,
					bodyText: prependEmailSignature(body, this.logins),
					replyTos: []
				}, this.isBlockingExternalImages() || !this.isShowingExternalContent(), this.getLoadedInlineImages(), mailboxDetails);
				editor.show();
			} catch (e) {
				if (e instanceof UserError) showUserError(e);
else throw e;
			}
		}
	}
	async sanitizeMailBody(mail, blockExternalContent) {
		const { htmlSanitizer } = await import("./HtmlSanitizer-DJqF9m1z.js");
		const rawBody = this.getMailBody();
		const sanitizeResult = htmlSanitizer.sanitizeFragment(rawBody, {
			blockExternalContent,
			allowRelativeLinks: isTutanotaTeamMail(mail)
		});
		const { fragment, inlineImageCids, links, blockedExternalContent } = sanitizeResult;
		/**
		* Check if we need to improve contrast for dark theme. We apply the contrast fix if any of the following is contained in
		* the html body of the mail
		*  * any tag with a style attribute that has the color property set (besides "inherit")
		*  * any tag with a style attribute that has the background-color set (besides "inherit")
		*  * any font tag with the color attribute set
		*/
		this.contrastFixNeeded = isMailContrastFixNeeded(fragment);
		mithril_default.redraw();
		return {
			fragment,
			inlineImageCids,
			links,
			blockedExternalContent
		};
	}
	getNonInlineAttachments() {
		const inlineFileIds = this.sanitizeResult?.inlineImageCids ?? [];
		return this.attachments.filter((a) => a.cid == null || !inlineFileIds.includes(a.cid));
	}
	async downloadAll() {
		const nonInlineAttachments = await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, this.getNonInlineAttachments());
		try {
			await this.fileController.downloadAll(nonInlineAttachments);
		} catch (e) {
			if (e instanceof FileOpenError) {
				console.warn("FileOpenError", e);
				await Dialog.message("canNotOpenFileOnDevice_msg");
			} else {
				console.error("could not open file:", e.message ?? "unknown error");
				await Dialog.message("errorDuringFileOpen_msg");
			}
		}
	}
	async downloadAndOpenAttachment(file, open) {
		file = (await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, [file]))[0];
		try {
			if (open) await this.fileController.open(file);
else await this.fileController.download(file);
		} catch (e) {
			if (e instanceof FileOpenError) {
				console.warn("FileOpenError", e);
				await Dialog.message("canNotOpenFileOnDevice_msg");
			} else {
				console.error("could not open file:", e.message ?? "unknown error");
				await Dialog.message("errorDuringFileOpen_msg");
			}
		}
	}
	async importAttachment(file) {
		const attachmentType = getAttachmentType(file.mimeType ?? "");
		if (attachmentType === AttachmentType.CONTACT) await this.importContacts(file);
else if (attachmentType === AttachmentType.CALENDAR) await this.importCalendar(file);
	}
	async importContacts(file) {
		file = (await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, [file]))[0];
		try {
			const dataFile = await this.fileController.getAsDataFile(file);
			const contactListId = await this.contactModel.getContactListId();
			if (contactListId == null) return;
			const contactImporter = await this.contactImporter();
			await contactImporter.importContactsFromFile(utf8Uint8ArrayToString(dataFile.data), contactListId);
		} catch (e) {
			console.log(e);
			throw new UserError("errorDuringFileOpen_msg");
		}
	}
	async importCalendar(file) {
		file = (await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, [file]))[0];
		try {
			const { importCalendarFile, parseCalendarFile } = await import("./CalendarImporter-zjX-8iQD.js");
			const dataFile = await this.fileController.getAsDataFile(file);
			const data = parseCalendarFile(dataFile);
			await importCalendarFile(await mailLocator.calendarModel(), this.logins.getUserController(), data.contents);
		} catch (e) {
			console.log(e);
			throw new UserError("errorDuringFileOpen_msg");
		}
	}
	canImportFile(file) {
		if (!this.logins.isInternalUserLoggedIn() || file.mimeType == null) return false;
		const attachmentType = getAttachmentType(file.mimeType);
		return attachmentType === AttachmentType.CONTACT || attachmentType === AttachmentType.CALENDAR;
	}
	canReplyAll() {
		return this.logins.getUserController().isInternalUser() && this.getToRecipients().length + this.getCcRecipients().length + this.getBccRecipients().length > 1;
	}
	canForwardOrMove() {
		return this.logins.getUserController().isInternalUser();
	}
	shouldDelayRendering() {
		return this.renderIsDelayed;
	}
	isCollapsed() {
		return this.collapsed;
	}
	expandMail(delayBodyRendering) {
		this.loadAll(delayBodyRendering, { notify: true });
		if (this.isUnread()) this.logins.waitForFullLogin().then(() => this.setUnread(false));
		this.collapsed = false;
	}
	collapseMail() {
		this.collapsed = true;
	}
	getLabels() {
		return this.mailModel.getLabelsForMail(this.mail);
	}
	getMailOwnerGroup() {
		return this.mail._ownerGroup;
	}
	updateMail({ mail, showFolder }) {
		if (!isSameId(mail._id, this.mail._id)) throw new ProgrammingError(`Trying to update MailViewerViewModel with unrelated email ${JSON.stringify(this.mail._id)} ${JSON.stringify(mail._id)} ${mithril_default.route.get()}`);
		this._mail = mail;
		this.folderMailboxText = null;
		if (showFolder) this.showFolder();
		this.relevantRecipient = null;
		this.determineRelevantRecipient();
		this.loadAll(Promise.resolve(), { notify: true });
	}
};

//#endregion
export { ContentBlockingStatus, FontIcons, MailFilterType, MailViewerViewModel, createInlineImage, downloadMailBundle, getConfidentialIcon, getMailFilterForType, getMailFolderIcon, getSenderOrRecipientHeading, isMailContrastFixNeeded, isSystemNotification, isTutanotaTeamAddress, isTutanotaTeamMail, makeMailBundle, promptAndDeleteMails, replaceCidsWithInlineImages, replaceInlineImagesWithCids };
//# sourceMappingURL=MailViewerViewModel-D_nVDgz3.js.map