{"version":3,"file":"MailExportTokenFacade-KBHxS9-u.js","names":["serviceExecutor: IServiceExecutor","request: (token: string) => Promise<T>","token: string"],"sources":["../../src/common/api/worker/facades/lazy/MailExportTokenFacade.ts"],"sourcesContent":["import { AccessExpiredError } from \"../../../common/error/RestError.js\"\nimport { MailExportTokenService } from \"../../../entities/tutanota/Services.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { SuspensionBehavior } from \"../../rest/RestClient\"\n\nconst TAG = \"[MailExportTokenFacade]\"\n\n/**\n * Denotes an export token. This is internally just a string, but we want the TypeScript compiler to enforce strong\n * typing.\n */\ntype MailExportToken = string & { _exportToken: undefined }\n\n/**\n * Takes care of requested and invalidating export tokens as needed.\n *\n * Export token should be passed with network requests to avoid server penalties.\n */\nexport class MailExportTokenFacade {\n\t// This will only be set if a request is in progress\n\tprivate currentExportTokenRequest: Promise<MailExportToken> | null = null\n\t// Set when we have a known valid token\n\tprivate currentExportToken: MailExportToken | null = null\n\n\tconstructor(private readonly serviceExecutor: IServiceExecutor) {}\n\n\t/**\n\t * Runs {@param request}.\n\t *\n\t * If {@link AccessExpiredError} is thrown, deletes the cached token and re-runs it again.\n\t */\n\tasync loadWithToken<T>(request: (token: string) => Promise<T>): Promise<T> {\n\t\tconst token = this.currentExportToken ?? (await this.requestNewToken())\n\t\ttry {\n\t\t\treturn await request(token)\n\t\t} catch (e) {\n\t\t\t// We only allow one retry\n\t\t\tif (e instanceof AccessExpiredError) {\n\t\t\t\tlet newToken\n\t\t\t\tif (this.currentExportToken === token) {\n\t\t\t\t\tconsole.log(TAG, `token expired for exporting and will be renewed`)\n\t\t\t\t\tnewToken = await this.requestNewToken()\n\t\t\t\t} else {\n\t\t\t\t\t// Already a request going on... wait for that to finish\n\t\t\t\t\tnewToken = this.currentExportToken ?? (await this.requestNewToken())\n\t\t\t\t}\n\n\t\t\t\treturn await request(newToken)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Request a new token and write it to {@link currentExportToken}.\n\t *\n\t * This token will be valid for the mail group and current user for a short amount of time, after which you will get\n\t * an {@link AccessExpiredError} when using the token (or {@link NotAuthorizedError} if the user lost access to the group in the\n\t * meantime).\n\t * @throws TooManyRequestsError the user cannot request any more tokens right now\n\t */\n\tprivate requestNewToken(): Promise<MailExportToken> {\n\t\tif (this.currentExportTokenRequest) {\n\t\t\treturn this.currentExportTokenRequest\n\t\t}\n\n\t\tthis.currentExportToken = null\n\t\tthis.currentExportTokenRequest = this.serviceExecutor.post(MailExportTokenService, null, { suspensionBehavior: SuspensionBehavior.Throw }).then(\n\t\t\t(result) => {\n\t\t\t\tthis.currentExportToken = result.mailExportToken as MailExportToken\n\t\t\t\tthis.currentExportTokenRequest = null\n\t\t\t\treturn this.currentExportToken\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\t// Re-initialize in case MailExportTokenService won't fail on a future request\n\t\t\t\tthis.currentExportTokenRequest = null\n\t\t\t\tthrow error\n\t\t\t},\n\t\t)\n\t\treturn this.currentExportTokenRequest\n\t}\n\n\t// @VisibleForTesting\n\t_setCurrentExportToken(token: string) {\n\t\tthis.currentExportToken = token as MailExportToken\n\t\tthis.currentExportTokenRequest = null\n\t}\n\n\t// @VisibleForTesting\n\t_getCurrentExportToken(): string | null {\n\t\treturn this.currentExportToken\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAM,MAAM;IAaC,wBAAN,MAA4B;CAElC,AAAQ,4BAA6D;CAErE,AAAQ,qBAA6C;CAErD,YAA6BA,iBAAmC;EAsEhE,KAtE6B;CAAqC;;;;;;CAOlE,MAAM,cAAiBC,SAAoD;EAC1E,MAAM,QAAQ,KAAK,sBAAuB,MAAM,KAAK,iBAAiB;AACtE,MAAI;AACH,UAAO,MAAM,QAAQ,MAAM;EAC3B,SAAQ,GAAG;AAEX,OAAI,aAAa,oBAAoB;IACpC,IAAI;AACJ,QAAI,KAAK,uBAAuB,OAAO;AACtC,aAAQ,IAAI,MAAM,iDAAiD;AACnE,gBAAW,MAAM,KAAK,iBAAiB;IACvC,MAEA,YAAW,KAAK,sBAAuB,MAAM,KAAK,iBAAiB;AAGpE,WAAO,MAAM,QAAQ,SAAS;GAC9B,MACA,OAAM;EAEP;CACD;;;;;;;;;CAUD,AAAQ,kBAA4C;AACnD,MAAI,KAAK,0BACR,QAAO,KAAK;AAGb,OAAK,qBAAqB;AAC1B,OAAK,4BAA4B,KAAK,gBAAgB,KAAK,wBAAwB,MAAM,EAAE,oBAAoB,mBAAmB,MAAO,EAAC,CAAC,KAC1I,CAAC,WAAW;AACX,QAAK,qBAAqB,OAAO;AACjC,QAAK,4BAA4B;AACjC,UAAO,KAAK;EACZ,GACD,CAAC,UAAU;AAEV,QAAK,4BAA4B;AACjC,SAAM;EACN,EACD;AACD,SAAO,KAAK;CACZ;CAGD,uBAAuBC,OAAe;AACrC,OAAK,qBAAqB;AAC1B,OAAK,4BAA4B;CACjC;CAGD,yBAAwC;AACvC,SAAO,KAAK;CACZ;AACD"}