
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { LazyLoaded, delay, downcast, stringToUtf8Uint8Array, uint8ArrayToBase64 } from "./dist-CJHwsXKY.js";
import { DbError } from "./DbError-CcwZaPG2.js";
import { IndexingNotSupportedError, QuotaExceededError } from "./QuotaExceededError-nFM6SdTn.js";
import { sha256Hash } from "./dist-DcZ1Y4qd.js";

//#region ../src/common/api/worker/search/DbFacade.ts
const osName = (objectStoreName) => objectStoreName;
function extractErrorProperties(e) {
	const requestErrorEntries = {};
	for (let key in e) requestErrorEntries[key] = e[key];
	return JSON.stringify(requestErrorEntries);
}
var DbFacade = class DbFacade {
	_id;
	_db;
	_activeTransactions;
	indexingSupported = true;
	constructor(version, onupgrade) {
		this._activeTransactions = 0;
		this._db = new LazyLoaded(() => {
			if (!this.indexingSupported) return Promise.reject(new IndexingNotSupportedError("indexedDB not supported"));
else return new Promise((resolve, reject) => {
				let DBOpenRequest;
				try {
					DBOpenRequest = self.indexedDB.open(this._id, version);
					DBOpenRequest.onerror = (event) => {
						const target = event.target;
						const error = event.target?.error;
						const requestErrorEntries = extractErrorProperties(DBOpenRequest.error);
						const eventProperties = extractErrorProperties(event);
						this.indexingSupported = false;
						const message = "DbFacade.open.onerror: " + this._id + "\nrequest.error: " + requestErrorEntries + "\nevent: " + eventProperties + "\nevent.target.error: " + (error ?? "[none]");
						if (error?.name === "QuotaExceededError") {
							console.log("Storage Quota is exceeded");
							reject(new QuotaExceededError(message, DBOpenRequest.error || error));
						} else reject(new IndexingNotSupportedError(message, DBOpenRequest.error || error));
					};
					DBOpenRequest.onupgradeneeded = (event) => {
						try {
							onupgrade(event, event.target.result, this);
						} catch (e) {
							reject(new DbError("could not create object store for DB " + this._id, e));
						}
					};
					DBOpenRequest.onsuccess = (event) => {
						DBOpenRequest.result.onabort = (event$1) => console.log("db aborted", event$1);
						DBOpenRequest.result.onclose = (event$1) => {
							console.log("db closed", event$1);
							this._db.reset();
						};
						DBOpenRequest.result.onerror = (event$1) => console.log("db error", event$1);
						resolve(DBOpenRequest.result);
					};
				} catch (e) {
					this.indexingSupported = false;
					reject(new IndexingNotSupportedError(`exception when accessing indexeddb ${this._id}`, e));
				}
			});
		});
	}
	async open(id) {
		this._id = id;
		await this._db.getAsync();
	}
	isSameDbId(dbId) {
		return this._id === dbId;
	}
	/**
	* Closes the db if it's open and deletes it.
	*/
	deleteDatabase(id) {
		const ensureDbIsClosed = () => {
			if (this._db.isLoaded()) if (this._activeTransactions > 0) return delay(150).then(ensureDbIsClosed);
else {
				this._db.getLoaded().close();
				return Promise.resolve();
			}
else return Promise.resolve();
		};
		return ensureDbIsClosed().then(() => DbFacade.deleteDb(id)).then(() => this._db.reset());
	}
	static deleteDb(id) {
		return new Promise((resolve, reject) => {
			const deleteRequest = self.indexedDB.deleteDatabase(id);
			deleteRequest.onerror = (event) => reject(new DbError(`could not delete database ${id}`, downcast(event)));
			deleteRequest.onsuccess = () => resolve();
		});
	}
	/**
	* @pre open() must have been called before, but the promise does not need to have returned.
	*/
	createTransaction(readOnly, objectStores) {
		return this._db.getAsync().then((db) => {
			try {
				const idbTransaction = db.transaction(objectStores, readOnly ? "readonly" : "readwrite");
				const transaction = new IndexedDbTransaction(idbTransaction, () => {
					this.indexingSupported = false;
					this._db.reset();
				});
				this._activeTransactions++;
				transaction.wait().finally(() => {
					this._activeTransactions--;
				});
				return transaction;
			} catch (e) {
				throw new DbError("could not create transaction", e);
			}
		});
	}
};
var IndexedDbTransaction = class {
	_transaction;
	_promise;
	_onUnknownError;
	aborted = false;
	constructor(transaction, onUnknownError) {
		this._transaction = transaction;
		this._onUnknownError = onUnknownError;
		this._promise = new Promise((resolve, reject) => {
			let done = false;
			transaction.onerror = (event) => {
				if (!done) this._handleDbError(event, this._transaction, "transaction.onerror", (e) => {
					reject(e);
				});
else console.log("ignore error of aborted/fulfilled transaction", event);
			};
			transaction.oncomplete = () => {
				done = true;
				resolve();
			};
			transaction.onabort = (event) => {
				event.stopPropagation();
				done = true;
				resolve();
			};
		});
	}
	getAll(objectStore) {
		return new Promise((resolve, reject) => {
			try {
				let keys = [];
				let request = this._transaction.objectStore(objectStore).openCursor();
				request.onerror = (event) => {
					this._handleDbError(event, request, "getAll().onError " + objectStore, reject);
				};
				request.onsuccess = (event) => {
					let cursor = request.result;
					if (cursor) {
						keys.push({
							key: cursor.key,
							value: cursor.value
						});
						cursor.continue();
					} else resolve(keys);
				};
			} catch (e) {
				this._handleDbError(e, null, "getAll().catch", reject);
			}
		});
	}
	get(objectStore, key, indexName) {
		return new Promise((resolve, reject) => {
			try {
				const os = this._transaction.objectStore(objectStore);
				let request;
				if (indexName) request = os.index(indexName).get(key);
else request = os.get(key);
				request.onerror = (event) => {
					this._handleDbError(event, request, "get().onerror " + objectStore, reject);
				};
				request.onsuccess = (event) => {
					resolve(event.target.result);
				};
			} catch (e) {
				this._handleDbError(e, null, "get().catch", reject);
			}
		});
	}
	async getAsList(objectStore, key, indexName) {
		const result = await this.get(objectStore, key, indexName);
		return result ? [result] : [];
	}
	put(objectStore, key, value) {
		return new Promise((resolve, reject) => {
			try {
				let request = key ? this._transaction.objectStore(objectStore).put(value, key) : this._transaction.objectStore(objectStore).put(value);
				request.onerror = (event) => {
					this._handleDbError(event, request, "put().onerror " + objectStore, reject);
				};
				request.onsuccess = (event) => {
					resolve(event.target.result);
				};
			} catch (e) {
				this._handleDbError(e, null, "put().catch", reject);
			}
		});
	}
	delete(objectStore, key) {
		return new Promise((resolve, reject) => {
			try {
				let request = this._transaction.objectStore(objectStore).delete(key);
				request.onerror = (event) => {
					this._handleDbError(event, request, "delete().onerror " + objectStore, reject);
				};
				request.onsuccess = (event) => {
					resolve();
				};
			} catch (e) {
				this._handleDbError(e, null, ".delete().catch " + objectStore, reject);
			}
		});
	}
	abort() {
		this.aborted = true;
		this._transaction.abort();
	}
	wait() {
		return this._promise;
	}
	_handleDbError(event, customTarget, prefix, callback) {
		const errorEntries = extractErrorProperties(event);
		const eventTargetEntries = event.target ? extractErrorProperties(event.target) : "<null>";
		const eventTargetErrorEntries = event.target && event.target.error ? extractErrorProperties(event.target.error) : "<null>";
		const customTargetEntries = customTarget ? extractErrorProperties(customTarget) : "<null>";
		const customTargetErrorEntries = customTarget && customTarget.error ? extractErrorProperties(customTarget.error) : "<null>";
		const msg = "IndexedDbTransaction " + prefix + "\nOSes: " + JSON.stringify(this._transaction.objectStoreNames) + "\nevent:" + errorEntries + "\ntransaction.error: " + (this._transaction.error ? this._transaction.error.message : "<null>") + "\nevent.target: " + eventTargetEntries + "\nevent.target.error: " + eventTargetErrorEntries + "\ncustom.target: " + customTargetEntries + "\ncustom.target.error: " + customTargetErrorEntries;
		if (typeof event.stopPropagation === "function") event.stopPropagation();
		if (customTarget && customTarget.error && (customTarget.error.name === "UnknownError" || typeof customTarget.error.message === "string" && customTarget.error.message.includes("UnknownError"))) {
			this._onUnknownError(customTarget.error);
			callback(new IndexingNotSupportedError(msg, this._transaction.error ?? undefined));
		} else {
			const e = this._transaction.error || (customTarget ? customTarget.error : null);
			if (e && e.name && e.name === "QuotaExceededError") {
				console.warn("Storage Quota exceeded");
				callback(new QuotaExceededError(msg, e));
			} else callback(new DbError(msg, e));
		}
	}
};
function b64UserIdHash(userId) {
	return uint8ArrayToBase64(sha256Hash(stringToUtf8Uint8Array(userId)));
}

//#endregion
export { DbFacade, b64UserIdHash, osName };
//# sourceMappingURL=DbFacade-DYw6Nyfw.js.map