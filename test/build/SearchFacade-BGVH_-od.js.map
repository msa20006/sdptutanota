{"version":3,"file":"SearchFacade-BGVH_-od.js","names":["userFacade: UserFacade","db: Db","mailIndexer: MailIndexer","suggestionFacades: SuggestionFacade<any>[]","browserData: BrowserData","entityClient: EntityClient","query: string","restriction: SearchRestriction","minSuggestionCount: number","maxResults?: number","result: SearchResult","result","suggestionToken: string","finalResults: IdTuple[]","entity: Record<string, any>","model: TypeModel","attributeIds: number[] | null","matchWordOrder: boolean","attributeNames: string[]","searchResult: SearchResult","moreResultsEntries: Promise<Array<MoreResultsIndexEntry>>","searchIndexEntries: MoreResultsIndexEntry[]","searchToken: string","suggestionFacade: SuggestionFacade<any>","suggestionResult: SearchResult","maxResults: number | null | undefined","metaData: SearchIndexMetaDataDbRow | null","rowsToRead: RowsToReadForIndexKey","indexEntries: EncryptedSearchIndexEntry[]","indexEntries: EncryptedSearchIndexEntryWithHash[]","firstTokenInfo: [string, number | null]","safeMetaDataRows: Array<SearchIndexMetaDataRow>","typeInfo: TypeInfo","transaction: DbTransaction","entry: SearchIndexMetadataEntry","metaData: SearchIndexMetaDataRow","fromNewestTimestamp: number","toOldestTimestamp: number","passedRows: SearchIndexMetadataEntry[]","mustBeOlderThan: number","results: KeyToEncryptedIndexEntries[]","matchingEncIds: Set<number> | null","results: KeyToIndexEntries[]","matchingIds: Set<Id> | null","entry: SearchIndexEntry","minIncludedId: Id","maxExcludedId: Id | null","results: ReadonlyArray<DecryptedSearchIndexEntry>","previousResult: SearchResult","indexEntries: Array<MoreResultsIndexEntry>","entriesCopy: Array<MoreResultsIndexEntry | null>","elementData: ElementDataDbRow | null","folderIds: Array<Id>","moreResultCount: number"],"sources":["../../src/mail-app/workerUtils/index/SearchFacade.ts"],"sourcesContent":["import { MailTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { DbTransaction } from \"../../../common/api/worker/search/DbFacade.js\"\nimport { resolveTypeReference } from \"../../../common/api/common/EntityFunctions.js\"\nimport {\n\tarrayHash,\n\tasyncFind,\n\tcontains,\n\tdowncast,\n\tgetDayShifted,\n\tgetStartOfDay,\n\tisEmpty,\n\tisNotEmpty,\n\tisNotNull,\n\tisSameTypeRef,\n\tneverNull,\n\tofClass,\n\tpromiseMap,\n\tpromiseMapCompat,\n\tPromiseMapFn,\n\ttokenize,\n\tTypeRef,\n\tuint8ArrayToBase64,\n} from \"@tutao/tutanota-utils\"\nimport type {\n\tDb,\n\tDecryptedSearchIndexEntry,\n\tElementDataDbRow,\n\tEncryptedSearchIndexEntry,\n\tEncryptedSearchIndexEntryWithHash,\n\tKeyToEncryptedIndexEntries,\n\tKeyToIndexEntries,\n\tMoreResultsIndexEntry,\n\tSearchIndexEntry,\n\tSearchIndexMetaDataDbRow,\n\tSearchIndexMetadataEntry,\n\tSearchIndexMetaDataRow,\n\tSearchRestriction,\n\tSearchResult,\n} from \"../../../common/api/worker/search/SearchTypes.js\"\nimport type { TypeInfo } from \"../../../common/api/worker/search/IndexUtils.js\"\nimport {\n\tdecryptMetaData,\n\tdecryptSearchIndexEntry,\n\tencryptIndexKeyBase64,\n\tgetIdFromEncSearchIndexEntry,\n\tgetPerformanceTimestamp,\n\tmarkEnd,\n\tmarkStart,\n\tprintMeasure,\n\ttypeRefToTypeInfo,\n} from \"../../../common/api/worker/search/IndexUtils.js\"\nimport { FULL_INDEXED_TIMESTAMP, NOTHING_INDEXED_TIMESTAMP } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { compareNewestFirst, elementIdPart, firstBiggerThanSecond, getListId, timestampToGeneratedId } from \"../../../common/api/common/utils/EntityUtils.js\"\nimport { INITIAL_MAIL_INDEX_INTERVAL_DAYS, MailIndexer } from \"./MailIndexer.js\"\nimport { SuggestionFacade } from \"./SuggestionFacade.js\"\nimport { AssociationType, Cardinality, ValueType } from \"../../../common/api/common/EntityConstants.js\"\nimport { NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError.js\"\nimport { iterateBinaryBlocks } from \"../../../common/api/worker/search/SearchIndexEncoding.js\"\nimport type { BrowserData } from \"../../../common/misc/ClientConstants.js\"\nimport type { TypeModel } from \"../../../common/api/common/EntityTypes.js\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport { UserFacade } from \"../../../common/api/worker/facades/UserFacade.js\"\nimport { ElementDataOS, SearchIndexMetaDataOS, SearchIndexOS, SearchIndexWordsIndex } from \"../../../common/api/worker/search/IndexTables.js\"\n\ntype RowsToReadForIndexKey = {\n\tindexKey: string\n\trows: Array<SearchIndexMetadataEntry>\n}\n\nexport class SearchFacade {\n\t_db: Db\n\t_mailIndexer: MailIndexer\n\t_suggestionFacades: SuggestionFacade<any>[]\n\t_promiseMapCompat: PromiseMapFn\n\t_entityClient: EntityClient\n\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tdb: Db,\n\t\tmailIndexer: MailIndexer,\n\t\tsuggestionFacades: SuggestionFacade<any>[],\n\t\tbrowserData: BrowserData,\n\t\tentityClient: EntityClient,\n\t) {\n\t\tthis._db = db\n\t\tthis._mailIndexer = mailIndexer\n\t\tthis._suggestionFacades = suggestionFacades\n\t\tthis._promiseMapCompat = promiseMapCompat(browserData.needsMicrotaskHack)\n\t\tthis._entityClient = entityClient\n\t}\n\n\t/****************************** SEARCH ******************************/\n\n\t/**\n\t * Invoke an AND-query.\n\t * @param query is tokenized. All tokens must be matched by the result (AND-query)\n\t * @param minSuggestionCount If minSuggestionCount > 0 regards the last query token as suggestion token and includes suggestion results for that token, but not less than minSuggestionCount\n\t * @returns The result ids are sorted by id from newest to oldest\n\t */\n\tsearch(query: string, restriction: SearchRestriction, minSuggestionCount: number, maxResults?: number): Promise<SearchResult> {\n\t\treturn this._db.initialized.then(() => {\n\t\t\tlet searchTokens = tokenize(query)\n\t\t\tlet result: SearchResult = {\n\t\t\t\tquery,\n\t\t\t\trestriction,\n\t\t\t\tresults: [],\n\t\t\t\tcurrentIndexTimestamp: this._getSearchEndTimestamp(restriction),\n\t\t\t\tlastReadSearchIndexRow: searchTokens.map((token) => [token, null]),\n\t\t\t\tmatchWordOrder: searchTokens.length > 1 && query.startsWith('\"') && query.endsWith('\"'),\n\t\t\t\tmoreResults: [],\n\t\t\t\tmoreResultsEntries: [],\n\t\t\t}\n\n\t\t\tif (searchTokens.length > 0) {\n\t\t\t\tlet isFirstWordSearch = searchTokens.length === 1\n\t\t\t\tlet before = getPerformanceTimestamp()\n\n\t\t\t\tlet suggestionFacade = this._suggestionFacades.find((f) => isSameTypeRef(f.type, restriction.type))\n\n\t\t\t\tlet searchPromise\n\n\t\t\t\tif (minSuggestionCount > 0 && isFirstWordSearch && suggestionFacade) {\n\t\t\t\t\tlet addSuggestionBefore = getPerformanceTimestamp()\n\t\t\t\t\tsearchPromise = this._addSuggestions(searchTokens[0], suggestionFacade, minSuggestionCount, result).then(() => {\n\t\t\t\t\t\tif (result.results.length < minSuggestionCount) {\n\t\t\t\t\t\t\t// there may be fields that are not indexed with suggestions but which we can find with the normal search\n\t\t\t\t\t\t\t// TODO: let suggestion facade and search facade know which fields are\n\t\t\t\t\t\t\t// indexed with suggestions, so that we\n\t\t\t\t\t\t\t// 1) know if we also have to search normally and\n\t\t\t\t\t\t\t// 2) in which fields we have to search for second word suggestions because now we would also find words of non-suggestion fields as second words\n\t\t\t\t\t\t\tlet searchForTokensAfterSuggestionsBefore = getPerformanceTimestamp()\n\t\t\t\t\t\t\treturn this._startOrContinueSearch(result).then((result) => {\n\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t} else if (minSuggestionCount > 0 && !isFirstWordSearch && suggestionFacade) {\n\t\t\t\t\tlet suggestionToken = neverNull(result.lastReadSearchIndexRow.pop())[0]\n\t\t\t\t\tsearchPromise = this._startOrContinueSearch(result).then(() => {\n\t\t\t\t\t\t// we now filter for the suggestion token manually because searching for suggestions for the last word and reducing the initial search result with them can lead to\n\t\t\t\t\t\t// dozens of searches without any effect when the seach token is found in too many contacts, e.g. in the email address with the ending \"de\"\n\t\t\t\t\t\tresult.results.sort(compareNewestFirst)\n\t\t\t\t\t\treturn this._loadAndReduce(restriction, result, suggestionToken, minSuggestionCount)\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tsearchPromise = this._startOrContinueSearch(result, maxResults)\n\t\t\t\t}\n\n\t\t\t\treturn searchPromise.then(() => {\n\t\t\t\t\tresult.results.sort(compareNewestFirst)\n\t\t\t\t\treturn result\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve(result)\n\t\t\t}\n\t\t})\n\t}\n\n\tasync _loadAndReduce(restriction: SearchRestriction, result: SearchResult, suggestionToken: string, minSuggestionCount: number): Promise<void> {\n\t\tif (result.results.length > 0) {\n\t\t\tconst model = await resolveTypeReference(restriction.type)\n\t\t\t// if we want the exact search order we try to find the complete sequence of words in an attribute of the instance.\n\t\t\t// for other cases we only check that an attribute contains a word that starts with suggestion word\n\t\t\tconst suggestionQuery = result.matchWordOrder ? normalizeQuery(result.query) : suggestionToken\n\t\t\tconst finalResults: IdTuple[] = []\n\n\t\t\tfor (const id of result.results) {\n\t\t\t\tif (finalResults.length >= minSuggestionCount) {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tlet entity\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tentity = await this._entityClient.load(restriction.type, id)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst found = await this._containsSuggestionToken(entity, model, restriction.attributeIds, suggestionQuery, result.matchWordOrder)\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tfinalResults.push(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.results = finalResults\n\t\t} else {\n\t\t\treturn Promise.resolve()\n\t\t}\n\t}\n\n\t/**\n\t * Looks for a word in any of the entities string values or aggregations string values that starts with suggestionToken.\n\t * @param attributeIds Only looks in these attribute ids (or all its string values if it is an aggregation attribute id. If null, looks in all string values and aggregations.\n\t */\n\t_containsSuggestionToken(\n\t\tentity: Record<string, any>,\n\t\tmodel: TypeModel,\n\t\tattributeIds: number[] | null,\n\t\tsuggestionToken: string,\n\t\tmatchWordOrder: boolean,\n\t): Promise<boolean> {\n\t\tlet attributeNames: string[]\n\n\t\tif (!attributeIds) {\n\t\t\tattributeNames = Object.keys(model.values).concat(Object.keys(model.associations))\n\t\t} else {\n\t\t\tattributeNames = attributeIds.map((id) =>\n\t\t\t\tneverNull(\n\t\t\t\t\tObject.keys(model.values).find((valueName) => model.values[valueName].id === id) ||\n\t\t\t\t\t\tObject.keys(model.associations).find((associationName) => model.associations[associationName].id === id),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\treturn asyncFind(attributeNames, async (attributeName) => {\n\t\t\tif (model.values[attributeName] && model.values[attributeName].type === ValueType.String && entity[attributeName]) {\n\t\t\t\tif (matchWordOrder) {\n\t\t\t\t\treturn Promise.resolve(normalizeQuery(entity[attributeName]).indexOf(suggestionToken) !== -1)\n\t\t\t\t} else {\n\t\t\t\t\tlet words = tokenize(entity[attributeName])\n\t\t\t\t\treturn Promise.resolve(words.some((w) => w.startsWith(suggestionToken)))\n\t\t\t\t}\n\t\t\t} else if (model.associations[attributeName] && model.associations[attributeName].type === AssociationType.Aggregation && entity[attributeName]) {\n\t\t\t\tlet aggregates = model.associations[attributeName].cardinality === Cardinality.Any ? entity[attributeName] : [entity[attributeName]]\n\t\t\t\tconst refModel = await resolveTypeReference(new TypeRef(model.app, model.associations[attributeName].refType))\n\t\t\t\treturn asyncFind(aggregates, (aggregate) => {\n\t\t\t\t\treturn this._containsSuggestionToken(downcast<Record<string, any>>(aggregate), refModel, null, suggestionToken, matchWordOrder)\n\t\t\t\t}).then((found) => found != null)\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve(false)\n\t\t\t}\n\t\t}).then((found) => found != null)\n\t}\n\n\t_startOrContinueSearch(searchResult: SearchResult, maxResults?: number): Promise<void> {\n\t\tmarkStart(\"findIndexEntries\")\n\n\t\tconst nextScheduledIndexingRun = getStartOfDay(getDayShifted(new Date(this._mailIndexer.currentIndexTimestamp), INITIAL_MAIL_INDEX_INTERVAL_DAYS))\n\t\tconst theDayAfterTomorrow = getStartOfDay(getDayShifted(new Date(), 1))\n\n\t\tif (searchResult.moreResults.length === 0 && nextScheduledIndexingRun.getTime() > theDayAfterTomorrow.getTime() && !this._mailIndexer.isIndexing) {\n\t\t\tthis._mailIndexer.extendIndexIfNeeded(\n\t\t\t\tthis.userFacade.getLoggedInUser(),\n\t\t\t\tgetStartOfDay(getDayShifted(new Date(), -INITIAL_MAIL_INDEX_INTERVAL_DAYS)).getTime(),\n\t\t\t)\n\t\t}\n\n\t\tlet moreResultsEntries: Promise<Array<MoreResultsIndexEntry>>\n\n\t\tif (maxResults && searchResult.moreResults.length >= maxResults) {\n\t\t\tmoreResultsEntries = Promise.resolve(searchResult.moreResults)\n\t\t} else {\n\t\t\tmoreResultsEntries = this._findIndexEntries(searchResult, maxResults)\n\t\t\t\t.then((keyToEncryptedIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"findIndexEntries\")\n\t\t\t\t\tmarkStart(\"_filterByEncryptedId\")\n\t\t\t\t\treturn this._filterByEncryptedId(keyToEncryptedIndexEntries)\n\t\t\t\t})\n\t\t\t\t.then((keyToEncryptedIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_filterByEncryptedId\")\n\t\t\t\t\tmarkStart(\"_decryptSearchResult\")\n\t\t\t\t\treturn this._decryptSearchResult(keyToEncryptedIndexEntries)\n\t\t\t\t})\n\t\t\t\t.then((keyToIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_decryptSearchResult\")\n\t\t\t\t\tmarkStart(\"_filterByTypeAndAttributeAndTime\")\n\t\t\t\t\treturn this._filterByTypeAndAttributeAndTime(keyToIndexEntries, searchResult.restriction)\n\t\t\t\t})\n\t\t\t\t.then((keyToIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_filterByTypeAndAttributeAndTime\")\n\t\t\t\t\tmarkStart(\"_reduceWords\")\n\t\t\t\t\treturn this._reduceWords(keyToIndexEntries, searchResult.matchWordOrder)\n\t\t\t\t})\n\t\t\t\t.then((searchIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_reduceWords\")\n\t\t\t\t\tmarkStart(\"_reduceToUniqueElementIds\")\n\t\t\t\t\treturn this._reduceToUniqueElementIds(searchIndexEntries, searchResult)\n\t\t\t\t})\n\t\t\t\t.then((additionalEntries) => {\n\t\t\t\t\tmarkEnd(\"_reduceToUniqueElementIds\")\n\t\t\t\t\treturn additionalEntries.concat(searchResult.moreResults)\n\t\t\t\t})\n\t\t}\n\n\t\treturn moreResultsEntries\n\t\t\t.then((searchIndexEntries: MoreResultsIndexEntry[]) => {\n\t\t\t\tmarkStart(\"_filterByListIdAndGroupSearchResults\")\n\t\t\t\treturn this._filterByListIdAndGroupSearchResults(searchIndexEntries, searchResult, maxResults)\n\t\t\t})\n\t\t\t.then((result) => {\n\t\t\t\tmarkEnd(\"_filterByListIdAndGroupSearchResults\")\n\t\t\t\tif (typeof self !== \"undefined\") {\n\t\t\t\t\tprintMeasure(\"query: \" + searchResult.query + \", maxResults: \" + String(maxResults), [\n\t\t\t\t\t\t\"findIndexEntries\",\n\t\t\t\t\t\t\"_filterByEncryptedId\",\n\t\t\t\t\t\t\"_decryptSearchResult\",\n\t\t\t\t\t\t\"_filterByTypeAndAttributeAndTime\",\n\t\t\t\t\t\t\"_reduceWords\",\n\t\t\t\t\t\t\"_reduceToUniqueElementIds\",\n\t\t\t\t\t\t\"_filterByListIdAndGroupSearchResults\",\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t})\n\t}\n\n\t/**\n\t * Adds suggestions for the given searchToken to the searchResult until at least minSuggestionCount results are existing\n\t */\n\t_addSuggestions(searchToken: string, suggestionFacade: SuggestionFacade<any>, minSuggestionCount: number, searchResult: SearchResult): Promise<any> {\n\t\tlet suggestions = suggestionFacade.getSuggestions(searchToken)\n\t\treturn promiseMap(suggestions, (suggestion) => {\n\t\t\tif (searchResult.results.length < minSuggestionCount) {\n\t\t\t\tconst suggestionResult: SearchResult = {\n\t\t\t\t\tquery: suggestion,\n\t\t\t\t\trestriction: searchResult.restriction,\n\t\t\t\t\tresults: searchResult.results,\n\t\t\t\t\tcurrentIndexTimestamp: searchResult.currentIndexTimestamp,\n\t\t\t\t\tlastReadSearchIndexRow: [[suggestion, null]],\n\t\t\t\t\tmatchWordOrder: false,\n\t\t\t\t\tmoreResults: [],\n\t\t\t\t\tmoreResultsEntries: [],\n\t\t\t\t}\n\t\t\t\treturn this._startOrContinueSearch(suggestionResult)\n\t\t\t}\n\t\t})\n\t}\n\n\t_findIndexEntries(searchResult: SearchResult, maxResults: number | null | undefined): Promise<KeyToEncryptedIndexEntries[]> {\n\t\tconst typeInfo = typeRefToTypeInfo(searchResult.restriction.type)\n\t\tconst firstSearchTokenInfo = searchResult.lastReadSearchIndexRow[0]\n\t\t// First read all metadata to narrow time range we search in.\n\t\treturn this._db.dbFacade.createTransaction(true, [SearchIndexOS, SearchIndexMetaDataOS]).then((transaction) => {\n\t\t\treturn this._promiseMapCompat(searchResult.lastReadSearchIndexRow, (tokenInfo, index) => {\n\t\t\t\tconst [searchToken] = tokenInfo\n\t\t\t\tlet indexKey = encryptIndexKeyBase64(this._db.key, searchToken, this._db.iv)\n\t\t\t\treturn transaction.get(SearchIndexMetaDataOS, indexKey, SearchIndexWordsIndex).then((metaData: SearchIndexMetaDataDbRow | null) => {\n\t\t\t\t\tif (!metaData) {\n\t\t\t\t\t\ttokenInfo[1] = 0 // \"we've read all\" (because we don't have anything\n\n\t\t\t\t\t\t// If there's no metadata for key, return empty result\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid: -index,\n\t\t\t\t\t\t\tword: indexKey,\n\t\t\t\t\t\t\trows: [],\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn decryptMetaData(this._db.key, metaData)\n\t\t\t\t})\n\t\t\t})\n\t\t\t\t.thenOrApply((metaRows) => {\n\t\t\t\t\t// Find index entry rows in which we will search.\n\t\t\t\t\tconst rowsToReadForIndexKeys = this._findRowsToReadFromMetaData(firstSearchTokenInfo, metaRows, typeInfo, maxResults)\n\n\t\t\t\t\t// Iterate each query token\n\t\t\t\t\treturn this._promiseMapCompat(rowsToReadForIndexKeys, (rowsToRead: RowsToReadForIndexKey) => {\n\t\t\t\t\t\t// For each token find token entries in the rows we've found\n\t\t\t\t\t\treturn this._promiseMapCompat(rowsToRead.rows, (entry) => this._findEntriesForMetadata(transaction, entry))\n\t\t\t\t\t\t\t.thenOrApply((a) => a.flat())\n\t\t\t\t\t\t\t.thenOrApply((indexEntries: EncryptedSearchIndexEntry[]) => {\n\t\t\t\t\t\t\t\treturn indexEntries.map((entry) => ({\n\t\t\t\t\t\t\t\t\tencEntry: entry,\n\t\t\t\t\t\t\t\t\tidHash: arrayHash(getIdFromEncSearchIndexEntry(entry)),\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.thenOrApply((indexEntries: EncryptedSearchIndexEntryWithHash[]) => {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tindexKey: rowsToRead.indexKey,\n\t\t\t\t\t\t\t\t\tindexEntries: indexEntries,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}).value\n\t\t\t\t\t}).value\n\t\t\t\t})\n\t\t\t\t.toPromise()\n\t\t})\n\t}\n\n\t_findRowsToReadFromMetaData(\n\t\tfirstTokenInfo: [string, number | null],\n\t\tsafeMetaDataRows: Array<SearchIndexMetaDataRow>,\n\t\ttypeInfo: TypeInfo,\n\t\tmaxResults: number | null | undefined,\n\t): Array<RowsToReadForIndexKey> {\n\t\t// \"Leading row\" narrows down time range in which we search in this iteration\n\t\t// Doesn't matter for correctness which one it is (because query is always AND) but matters for performance\n\t\t// For now arbitrarily picked first (usually it's the most specific part anyway)\n\t\tconst leadingRow = safeMetaDataRows[0]\n\t\tconst otherRows = safeMetaDataRows.slice(1)\n\n\t\tconst rangeForLeadingRow = this._findRowsToRead(leadingRow, typeInfo, firstTokenInfo[1] || Number.MAX_SAFE_INTEGER, maxResults)\n\n\t\tconst rowsForLeadingRow = [\n\t\t\t{\n\t\t\t\tindexKey: leadingRow.word,\n\t\t\t\trows: rangeForLeadingRow.metaEntries,\n\t\t\t},\n\t\t]\n\t\tfirstTokenInfo[1] = rangeForLeadingRow.oldestTimestamp\n\t\tconst rowsForOtherRows = otherRows.map((r) => {\n\t\t\treturn {\n\t\t\t\tindexKey: r.word,\n\t\t\t\trows: this._findRowsToReadByTimeRange(r, typeInfo, rangeForLeadingRow.newestRowTimestamp, rangeForLeadingRow.oldestTimestamp),\n\t\t\t}\n\t\t})\n\t\treturn rowsForLeadingRow.concat(rowsForOtherRows)\n\t}\n\n\t_findEntriesForMetadata(transaction: DbTransaction, entry: SearchIndexMetadataEntry): Promise<EncryptedSearchIndexEntry[]> {\n\t\treturn transaction.get(SearchIndexOS, entry.key).then((indexEntriesRow) => {\n\t\t\tif (!indexEntriesRow) return []\n\t\t\tconst result = new Array(entry.size)\n\t\t\titerateBinaryBlocks(indexEntriesRow as Uint8Array, (block, s, e, iteration) => {\n\t\t\t\tresult[iteration] = block\n\t\t\t})\n\t\t\treturn result\n\t\t})\n\t}\n\n\t_findRowsToReadByTimeRange(\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\ttypeInfo: TypeInfo,\n\t\tfromNewestTimestamp: number,\n\t\ttoOldestTimestamp: number,\n\t): Array<SearchIndexMetadataEntry> {\n\t\tconst filteredRows = metaData.rows.filter((r) => r.app === typeInfo.appId && r.type === typeInfo.typeId)\n\t\tfilteredRows.reverse()\n\t\tconst passedRows: SearchIndexMetadataEntry[] = []\n\n\t\tfor (let row of filteredRows) {\n\t\t\tif (row.oldestElementTimestamp < fromNewestTimestamp) {\n\t\t\t\tpassedRows.push(row)\n\n\t\t\t\tif (row.oldestElementTimestamp <= toOldestTimestamp) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn passedRows\n\t}\n\n\t_findRowsToRead(\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\ttypeInfo: TypeInfo,\n\t\tmustBeOlderThan: number,\n\t\tmaxResults: number | null | undefined,\n\t): {\n\t\tmetaEntries: Array<SearchIndexMetadataEntry>\n\t\toldestTimestamp: number\n\t\tnewestRowTimestamp: number\n\t} {\n\t\tconst filteredRows = metaData.rows.filter((r) => r.app === typeInfo.appId && r.type === typeInfo.typeId)\n\t\tfilteredRows.reverse()\n\t\tlet entitiesToRead = 0\n\t\tlet lastReadRowTimestamp = 0\n\t\tlet newestRowTimestamp = Number.MAX_SAFE_INTEGER\n\t\tlet rowsToRead\n\n\t\tif (maxResults) {\n\t\t\trowsToRead = []\n\n\t\t\tfor (let r of filteredRows) {\n\t\t\t\tif (r.oldestElementTimestamp < mustBeOlderThan) {\n\t\t\t\t\tif (entitiesToRead < 1000) {\n\t\t\t\t\t\tentitiesToRead += r.size\n\t\t\t\t\t\tlastReadRowTimestamp = r.oldestElementTimestamp\n\t\t\t\t\t\trowsToRead.push(r)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewestRowTimestamp = r.oldestElementTimestamp\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trowsToRead = filteredRows\n\t\t}\n\n\t\treturn {\n\t\t\tmetaEntries: rowsToRead,\n\t\t\toldestTimestamp: lastReadRowTimestamp,\n\t\t\tnewestRowTimestamp: newestRowTimestamp,\n\t\t}\n\t}\n\n\t/**\n\t * Reduces the search result by filtering out all mailIds that don't match all search tokens\n\t */\n\t_filterByEncryptedId(results: KeyToEncryptedIndexEntries[]): KeyToEncryptedIndexEntries[] {\n\t\tlet matchingEncIds: Set<number> | null = null\n\t\tfor (const keyToEncryptedIndexEntry of results) {\n\t\t\tif (matchingEncIds == null) {\n\t\t\t\tmatchingEncIds = new Set(keyToEncryptedIndexEntry.indexEntries.map((entry) => entry.idHash))\n\t\t\t} else {\n\t\t\t\tconst filtered = new Set<number>()\n\t\t\t\tfor (const indexEntry of keyToEncryptedIndexEntry.indexEntries) {\n\t\t\t\t\tif (matchingEncIds.has(indexEntry.idHash)) {\n\t\t\t\t\t\tfiltered.add(indexEntry.idHash)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatchingEncIds = filtered\n\t\t\t}\n\t\t}\n\t\treturn results.map((r) => {\n\t\t\treturn {\n\t\t\t\tindexKey: r.indexKey,\n\t\t\t\tindexEntries: r.indexEntries.filter((entry) => matchingEncIds?.has(entry.idHash)),\n\t\t\t}\n\t\t})\n\t}\n\n\t_decryptSearchResult(results: KeyToEncryptedIndexEntries[]): KeyToIndexEntries[] {\n\t\treturn results.map((searchResult) => {\n\t\t\treturn {\n\t\t\t\tindexKey: searchResult.indexKey,\n\t\t\t\tindexEntries: searchResult.indexEntries.map((entry) => decryptSearchIndexEntry(this._db.key, entry.encEntry, this._db.iv)),\n\t\t\t}\n\t\t})\n\t}\n\n\t_filterByTypeAndAttributeAndTime(results: KeyToIndexEntries[], restriction: SearchRestriction): KeyToIndexEntries[] {\n\t\t// first filter each index entry by itself\n\t\tlet endTimestamp = this._getSearchEndTimestamp(restriction)\n\n\t\tconst minIncludedId = timestampToGeneratedId(endTimestamp)\n\t\tconst maxExcludedId = restriction.start ? timestampToGeneratedId(restriction.start + 1) : null\n\t\tfor (const result of results) {\n\t\t\tresult.indexEntries = result.indexEntries.filter((entry) => {\n\t\t\t\treturn this._isValidAttributeAndTime(restriction, entry, minIncludedId, maxExcludedId)\n\t\t\t})\n\t\t}\n\t\t// now filter all ids that are in all of the search words\n\t\tlet matchingIds: Set<Id> | null = null\n\t\tfor (const keyToIndexEntry of results) {\n\t\t\tif (!matchingIds) {\n\t\t\t\tmatchingIds = new Set(keyToIndexEntry.indexEntries.map((entry) => entry.id))\n\t\t\t} else {\n\t\t\t\tlet filtered = new Set<Id>()\n\t\t\t\tfor (const entry of keyToIndexEntry.indexEntries) {\n\t\t\t\t\tif (matchingIds.has(entry.id)) {\n\t\t\t\t\t\tfiltered.add(entry.id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatchingIds = filtered\n\t\t\t}\n\t\t}\n\t\treturn results.map((r) => {\n\t\t\treturn {\n\t\t\t\tindexKey: r.indexKey,\n\t\t\t\tindexEntries: r.indexEntries.filter((entry) => matchingIds?.has(entry.id)),\n\t\t\t}\n\t\t})\n\t}\n\n\t_isValidAttributeAndTime(restriction: SearchRestriction, entry: SearchIndexEntry, minIncludedId: Id, maxExcludedId: Id | null): boolean {\n\t\tif (restriction.attributeIds) {\n\t\t\tif (!contains(restriction.attributeIds, entry.attribute)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tif (maxExcludedId) {\n\t\t\t// timestampToGeneratedId provides the lowest id with the given timestamp (server id and counter set to 0),\n\t\t\t// so we add one millisecond to make sure all ids of the timestamp are covered\n\t\t\tif (!firstBiggerThanSecond(maxExcludedId, entry.id)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn !firstBiggerThanSecond(minIncludedId, entry.id)\n\t}\n\n\t_reduceWords(results: KeyToIndexEntries[], matchWordOrder: boolean): ReadonlyArray<DecryptedSearchIndexEntry> {\n\t\tif (matchWordOrder) {\n\t\t\treturn results[0].indexEntries.filter((firstWordEntry) => {\n\t\t\t\t// reduce the filtered positions for this first word entry and its attribute with each next word to those that are in order\n\t\t\t\tlet filteredPositions = firstWordEntry.positions.slice()\n\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tlet entry = results[i].indexEntries.find((e) => e.id === firstWordEntry.id && e.attribute === firstWordEntry.attribute)\n\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\tfilteredPositions = filteredPositions.filter((firstWordPosition) =>\n\t\t\t\t\t\t\tneverNull(entry).positions.find((position) => position === firstWordPosition + i),\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the id was probably not found for the same attribute as the current filtered positions, so we could not find all words in order in the same attribute\n\t\t\t\t\t\tfilteredPositions = []\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn filteredPositions.length > 0\n\t\t\t})\n\t\t} else {\n\t\t\t// all ids must appear in all words now, so we can use any of the entries lists\n\t\t\treturn results[0].indexEntries\n\t\t}\n\t}\n\n\t_reduceToUniqueElementIds(results: ReadonlyArray<DecryptedSearchIndexEntry>, previousResult: SearchResult): ReadonlyArray<MoreResultsIndexEntry> {\n\t\tconst uniqueIds = new Set<string>()\n\t\treturn results.filter((entry) => {\n\t\t\tif (!uniqueIds.has(entry.id) && !previousResult.results.some((r) => r[1] === entry.id)) {\n\t\t\t\tuniqueIds.add(entry.id)\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t})\n\t}\n\n\t_filterByListIdAndGroupSearchResults(\n\t\tindexEntries: Array<MoreResultsIndexEntry>,\n\t\tsearchResult: SearchResult,\n\t\tmaxResults: number | null | undefined,\n\t): Promise<void> {\n\t\tindexEntries.sort((l, r) => compareNewestFirst(l.id, r.id))\n\t\t// We filter out everything we've processed from moreEntries, even if we didn't include it\n\t\t// downcast: Array of optional elements in not subtype of non-optional elements\n\t\tconst entriesCopy: Array<MoreResultsIndexEntry | null> = downcast(indexEntries.slice())\n\t\t// Results are added in the random order and we may filter some of them out. We need to sort them.\n\t\t// Use separate array to only sort new results and not all of them.\n\t\treturn this._db.dbFacade\n\t\t\t.createTransaction(true, [ElementDataOS])\n\t\t\t.then((transaction) =>\n\t\t\t\t// As an attempt to optimize search we look for items in parallel. Promise.map iterates in arbitrary order!\n\t\t\t\t// BUT! we have to look at all of them! Otherwise, we may return them in the wrong order.\n\t\t\t\t// We cannot return elements 10, 15, 20 if we didn't return element 5 first, no one will ask for it later.\n\t\t\t\t// The best thing performance-wise would be to split into chunks of certain length and process them in parallel and stop after certain chunk.\n\t\t\t\tpromiseMap(\n\t\t\t\t\tindexEntries.slice(0, maxResults || indexEntries.length + 1),\n\t\t\t\t\tasync (entry, index) => {\n\t\t\t\t\t\treturn transaction.get(ElementDataOS, uint8ArrayToBase64(entry.encId)).then((elementData: ElementDataDbRow | null) => {\n\t\t\t\t\t\t\t// mark result index id as processed to not query result in next load more operation\n\t\t\t\t\t\t\tentriesCopy[index] = null\n\n\t\t\t\t\t\t\tif (elementData) {\n\t\t\t\t\t\t\t\treturn [elementData[0], entry.id] as IdTuple\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tconcurrency: 5,\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t)\n\t\t\t.then((intermediateResults) => intermediateResults.filter(isNotNull))\n\t\t\t.then(async (intermediateResults) => {\n\t\t\t\t// apply folder restrictions to intermediateResults\n\n\t\t\t\tif (isEmpty(searchResult.restriction.folderIds)) {\n\t\t\t\t\t// no folder restrictions (ALL)\n\t\t\t\t\treturn intermediateResults\n\t\t\t\t} else {\n\t\t\t\t\t// some folder restrictions (e.g. INBOX)\n\n\t\t\t\t\t// With the new mailSet architecture (static mail lists) we need to load every mail\n\t\t\t\t\t// in order to check in which mailSet (folder) a mail is included in.\n\t\t\t\t\tconst mails = await Promise.all(\n\t\t\t\t\t\tintermediateResults.map((intermediateResultId) =>\n\t\t\t\t\t\t\tthis._entityClient.load(MailTypeRef, intermediateResultId).catch(\n\t\t\t\t\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\t\t\t\t\tconsole.log(`Could not find updated mail ${JSON.stringify(intermediateResultId)}`)\n\t\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t\treturn mails\n\t\t\t\t\t\t.filter(isNotNull)\n\t\t\t\t\t\t.filter((mail) => {\n\t\t\t\t\t\t\tlet folderIds: Array<Id>\n\t\t\t\t\t\t\tif (isNotEmpty(mail.sets)) {\n\t\t\t\t\t\t\t\t// new mailSet folders\n\t\t\t\t\t\t\t\tfolderIds = mail.sets.map((setId) => elementIdPart(setId))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// legacy mail folder (mail list)\n\t\t\t\t\t\t\t\tfolderIds = [getListId(mail)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn folderIds.some((folderId) => searchResult.restriction.folderIds.includes(folderId))\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.map((mail) => mail._id)\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then((newResults) => {\n\t\t\t\tsearchResult.results.push(...(newResults as IdTuple[]))\n\t\t\t\tsearchResult.moreResults = entriesCopy.filter(isNotNull)\n\t\t\t})\n\t}\n\n\tasync getMoreSearchResults(searchResult: SearchResult, moreResultCount: number): Promise<SearchResult> {\n\t\tawait this._startOrContinueSearch(searchResult, moreResultCount)\n\t\treturn searchResult\n\t}\n\n\t_getSearchEndTimestamp(restriction: SearchRestriction): number {\n\t\tif (restriction.end) {\n\t\t\treturn restriction.end\n\t\t} else if (isSameTypeRef(MailTypeRef, restriction.type)) {\n\t\t\treturn this._mailIndexer.currentIndexTimestamp === NOTHING_INDEXED_TIMESTAMP ? Date.now() : this._mailIndexer.currentIndexTimestamp\n\t\t} else {\n\t\t\treturn FULL_INDEXED_TIMESTAMP\n\t\t}\n\t}\n}\n\nfunction normalizeQuery(query: string): string {\n\treturn tokenize(query).join(\" \")\n}\n"],"mappings":"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"}