
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { DAY_IN_MILLIS, filterInt, freezeMap, getFromMap, groupBy, insertIntoSortedArray, neverNull } from "./dist-CJHwsXKY.js";
import { CalendarAttendeeStatus, CalendarMethod, EndType, RepeatPeriod, reverse } from "./TutanotaConstants-3bwAESYA.js";
import { ParserError, StringIterator, combineParsers, makeCharacterParser, makeEitherParser, makeNotCharacterParser, makeSeparatedByParser, makeZeroOrMoreParser, mapParser, maybeParse, numberParser } from "./ParserCombinator-D38ofgFx.js";
import { DateTime, Duration, IANAZone } from "./luxon-D6cgmg6Q.js";
import { generateEventElementId, serializeAlarmInterval } from "./CommonCalendarUtils-DKaO7v1K.js";
import { createCalendarEvent, createCalendarEventAttendee, createEncryptedMailAddress } from "./TypeRefs-CR3TLWn0.js";
import { createCalendarAdvancedRepeatRule, createDateWrapper, createRepeatRule } from "./TypeRefs-BP1jvX9p.js";
import { AlarmIntervalUnit, CalendarEventValidity, assignEventId, checkEventValidity, getTimeZone } from "./CalendarUtils-C6jeYrj9.js";
import { isMailAddress } from "./FormatValidator-2BBermUe.js";

//#region ../src/calendar-app/calendar/export/WindowsZones.ts
var WindowsZones_default = {
	"Afghanistan Standard Time": "Asia/Kabul",
	"Alaskan Standard Time": "America/Anchorage",
	"Aleutian Standard Time": "America/Adak",
	"Altai Standard Time": "Asia/Barnaul",
	"Arab Standard Time": "Asia/Riyadh",
	"Arabian Standard Time": "Asia/Dubai",
	"Arabic Standard Time": "Asia/Baghdad",
	"Argentina Standard Time": "America/Buenos_Aires",
	"Astrakhan Standard Time": "Europe/Astrakhan",
	"Atlantic Standard Time": "America/Halifax",
	"AUS Central Standard Time": "Australia/Darwin",
	"Aus Central W. Standard Time": "Australia/Eucla",
	"AUS Eastern Standard Time": "Australia/Sydney",
	"Azerbaijan Standard Time": "Asia/Baku",
	"Azores Standard Time": "Atlantic/Azores",
	"Bahia Standard Time": "America/Bahia",
	"Bangladesh Standard Time": "Asia/Dhaka",
	"Belarus Standard Time": "Europe/Minsk",
	"Bougainville Standard Time": "Pacific/Bougainville",
	"Canada Central Standard Time": "America/Regina",
	"Cape Verde Standard Time": "Atlantic/Cape_Verde",
	"Caucasus Standard Time": "Asia/Yerevan",
	"Cen. Australia Standard Time": "Australia/Adelaide",
	"Central America Standard Time": "America/Guatemala",
	"Central Asia Standard Time": "Asia/Almaty",
	"Central Brazilian Standard Time": "America/Cuiaba",
	"Central Europe Standard Time": "Europe/Budapest",
	"Central European Standard Time": "Europe/Warsaw",
	"Central Pacific Standard Time": "Pacific/Guadalcanal",
	"Central Standard Time": "America/Chicago",
	"Central Standard Time (Mexico)": "America/Mexico_City",
	"Chatham Islands Standard Time": "Pacific/Chatham",
	"China Standard Time": "Asia/Shanghai",
	"Cuba Standard Time": "America/Havana",
	"Dateline Standard Time": "Etc/GMT+12",
	"E. Africa Standard Time": "Africa/Nairobi",
	"E. Australia Standard Time": "Australia/Brisbane",
	"E. Europe Standard Time": "Europe/Chisinau",
	"E. South America Standard Time": "America/Sao_Paulo",
	"Easter Island Standard Time": "Pacific/Easter",
	"Eastern Standard Time": "America/New_York",
	"Eastern Standard Time (Mexico)": "America/Cancun",
	"Egypt Standard Time": "Africa/Cairo",
	"Ekaterinburg Standard Time": "Asia/Yekaterinburg",
	"Fiji Standard Time": "Pacific/Fiji",
	"FLE Standard Time": "Europe/Kiev",
	"Georgian Standard Time": "Asia/Tbilisi",
	"GMT Standard Time": "Europe/London",
	"Greenland Standard Time": "America/Godthab",
	"Greenwich Standard Time": "Atlantic/Reykjavik",
	"GTB Standard Time": "Europe/Bucharest",
	"Haiti Standard Time": "America/Port-au-Prince",
	"Hawaiian Standard Time": "Pacific/Honolulu",
	"India Standard Time": "Asia/Calcutta",
	"Iran Standard Time": "Asia/Tehran",
	"Israel Standard Time": "Asia/Jerusalem",
	"Jordan Standard Time": "Asia/Amman",
	"Kaliningrad Standard Time": "Europe/Kaliningrad",
	"Korea Standard Time": "Asia/Seoul",
	"Libya Standard Time": "Africa/Tripoli",
	"Line Islands Standard Time": "Pacific/Kiritimati",
	"Lord Howe Standard Time": "Australia/Lord_Howe",
	"Magadan Standard Time": "Asia/Magadan",
	"Magallanes Standard Time": "America/Punta_Arenas",
	"Marquesas Standard Time": "Pacific/Marquesas",
	"Mauritius Standard Time": "Indian/Mauritius",
	"Middle East Standard Time": "Asia/Beirut",
	"Montevideo Standard Time": "America/Montevideo",
	"Morocco Standard Time": "Africa/Casablanca",
	"Mountain Standard Time": "America/Denver",
	"Mountain Standard Time (Mexico)": "America/Chihuahua",
	"Myanmar Standard Time": "Asia/Rangoon",
	"N. Central Asia Standard Time": "Asia/Novosibirsk",
	"Namibia Standard Time": "Africa/Windhoek",
	"Nepal Standard Time": "Asia/Katmandu",
	"New Zealand Standard Time": "Pacific/Auckland",
	"Newfoundland Standard Time": "America/St_Johns",
	"Norfolk Standard Time": "Pacific/Norfolk",
	"North Asia East Standard Time": "Asia/Irkutsk",
	"North Asia Standard Time": "Asia/Krasnoyarsk",
	"North Korea Standard Time": "Asia/Pyongyang",
	"Omsk Standard Time": "Asia/Omsk",
	"Pacific SA Standard Time": "America/Santiago",
	"Pacific Standard Time": "America/Los_Angeles",
	"Pacific Standard Time (Mexico)": "America/Tijuana",
	"Pakistan Standard Time": "Asia/Karachi",
	"Paraguay Standard Time": "America/Asuncion",
	"Romance Standard Time": "Europe/Paris",
	"Russia Time Zone 3": "Europe/Samara",
	"Russia Time Zone 10": "Asia/Srednekolymsk",
	"Russia Time Zone 11": "Asia/Kamchatka",
	"Russian Standard Time": "Europe/Moscow",
	"SA Eastern Standard Time": "America/Cayenne",
	"SA Pacific Standard Time": "America/Bogota",
	"SA Western Standard Time": "America/La_Paz",
	"Saint Pierre Standard Time": "America/Miquelon",
	"Sakhalin Standard Time": "Asia/Sakhalin",
	"Samoa Standard Time": "Pacific/Apia",
	"Sao Tome Standard Time": "Africa/Sao_Tome",
	"Saratov Standard Time": "Europe/Saratov",
	"SE Asia Standard Time": "Asia/Bangkok",
	"Singapore Standard Time": "Asia/Singapore",
	"South Africa Standard Time": "Africa/Johannesburg",
	"Sri Lanka Standard Time": "Asia/Colombo",
	"Sudan Standard Time": "Africa/Khartoum",
	"Syria Standard Time": "Asia/Damascus",
	"Taipei Standard Time": "Asia/Taipei",
	"Tasmania Standard Time": "Australia/Hobart",
	"Tocantins Standard Time": "America/Araguaina",
	"Tokyo Standard Time": "Asia/Tokyo",
	"Tomsk Standard Time": "Asia/Tomsk",
	"Tonga Standard Time": "Pacific/Tongatapu",
	"Transbaikal Standard Time": "Asia/Chita",
	"Turkey Standard Time": "Europe/Istanbul",
	"Turks And Caicos Standard Time": "America/Grand_Turk",
	"Ulaanbaatar Standard Time": "Asia/Ulaanbaatar",
	"US Eastern Standard Time": "America/Indianapolis",
	"US Mountain Standard Time": "America/Phoenix",
	UTC: "Etc/GMT",
	"UTC-02": "Etc/GMT+2",
	"UTC-08": "Etc/GMT+8",
	"UTC-09": "Etc/GMT+9",
	"UTC-11": "Etc/GMT+11",
	"UTC+12": "Etc/GMT-12",
	"UTC+13": "Etc/GMT-13",
	"Venezuela Standard Time": "America/Caracas",
	"Vladivostok Standard Time": "Asia/Vladivostok",
	"W. Australia Standard Time": "Australia/Perth",
	"W. Central Africa Standard Time": "Africa/Lagos",
	"W. Europe Standard Time": "Europe/Berlin",
	"W. Mongolia Standard Time": "Asia/Hovd",
	"West Asia Standard Time": "Asia/Tashkent",
	"West Bank Standard Time": "Asia/Hebron",
	"West Pacific Standard Time": "Pacific/Port_Moresby",
	"Yakutsk Standard Time": "Asia/Yakutsk"
};

//#endregion
//#region ../src/calendar-app/calendar/export/CalendarParser.ts
function parseDateString(dateString) {
	const year = parseInt(dateString.slice(0, 4));
	const month = parseInt(dateString.slice(4, 6));
	const day = parseInt(dateString.slice(6, 8));
	return {
		year,
		month,
		day
	};
}
function getProp(obj, tag, optional) {
	const prop = obj.properties.find((p) => p.name === tag);
	if (!optional && prop == null) throw new ParserError(`Missing prop ${tag}`);
	return prop;
}
function getPropStringValue(obj, tag, optional) {
	const prop = getProp(obj, tag, optional);
	if (!optional && typeof prop?.value !== "string") throw new ParserError(`value of ${tag} is not of type string, got ${JSON.stringify(prop)}`);
	return prop?.value;
}
const parameterStringValueParser = (iterator) => {
	let value = "";
	let next;
	while ((next = iterator.peek()) && /[:;,]/.test(next) === false) value += neverNull(iterator.next().value);
	return value;
};
const escapedStringValueParser = (iterator) => {
	if (iterator.next().value !== "\"") throw new ParserError("Not a quoted value");
	let value = "";
	while (iterator.peek() && iterator.peek() !== "\"") value += neverNull(iterator.next().value);
	if (!(iterator.peek() === "\"")) throw new Error("Not a quoted value, does not end with quote: " + value);
	iterator.next();
	return value;
};
const propertyParametersKeyValueParser = combineParsers(parsePropertyName, makeCharacterParser("="), makeEitherParser(escapedStringValueParser, parameterStringValueParser));
const parsePropertyParameters = combineParsers(makeCharacterParser(";"), makeSeparatedByParser(
	/*separator*/
	makeCharacterParser(";"),
	/*value*/
	propertyParametersKeyValueParser
));
const iCalReplacements = {
	"\\": "\\\\",
	";": "\\;",
	",": "\\,",
	"\n": "\\n"
};
const revICalReplacements = reverse(iCalReplacements);
/**
* Parses everything until the end of the string and unescapes what it should
*/
const anyStringUnescapeParser = (iterator) => {
	let value = "";
	let lastCharacter = null;
	while (iterator.peek()) {
		lastCharacter = iterator.next().value;
		if (lastCharacter === "\\") {
			const next = iterator.peek();
			if (next != null && next in iCalReplacements) continue;
else if (iterator.peek() === "n") {
				iterator.next();
				value += "\n";
				continue;
			}
		}
		value += neverNull(lastCharacter);
	}
	return value;
};
/**
* Parses everything until the semicolon character
*/
const propertyStringValueParser = (iterator) => {
	let value = "";
	let next;
	while ((next = iterator.peek()) && /[;]/.test(next) === false) value += neverNull(iterator.next().value);
	return value;
};
/**
* Parses values separated by commas
*/
const separatedByCommaParser = makeSeparatedByParser(makeCharacterParser(","), mapParser(makeZeroOrMoreParser(makeNotCharacterParser(",")), (arr) => arr.join("")));
const propertySequenceParser = combineParsers(parsePropertyName, maybeParse(parsePropertyParameters), makeCharacterParser(":"), anyStringUnescapeParser);
function parseProperty(data) {
	try {
		const sequence = propertySequenceParser(new StringIterator(data));
		const name = sequence[0];
		const params = {};
		if (sequence[1]) for (const [name$1, _eq, value$1] of sequence[1][1]) params[name$1] = value$1;
		const value = sequence[3];
		return {
			name,
			params,
			value
		};
	} catch (e) {
		return null;
	}
}
/**
* Parses single key=value pair on the right side of the semicolon (value side)
*/
const propertyKeyValueParser = combineParsers(parsePropertyName, makeCharacterParser("="), propertyStringValueParser);
/**
* Parses multiple key=value pair on the right side of the semicolon (value side)
*/
const valuesSeparatedBySemicolonParser = makeSeparatedByParser(makeCharacterParser(";"), propertyKeyValueParser);
function parsePropertyKeyValue(data) {
	const values = valuesSeparatedBySemicolonParser(new StringIterator(data));
	const result = {};
	for (const [key, _eq, value] of values) result[key] = value;
	return result;
}
function parseIcalObject(tag, iterator) {
	let iteration = iterator.next();
	let properties = [];
	let children = [];
	while (!iteration.done && iteration.value) {
		const property = parseProperty(iteration.value);
		if (!property) {
			iteration = iterator.next();
			continue;
		}
		if (property.name === "END" && property.value === tag) return {
			type: tag,
			properties,
			children
		};
		if (property.name === "BEGIN") {
			if (typeof property.value !== "string") throw new ParserError("BEGIN with array value");
			children.push(parseIcalObject(property.value, iterator));
		} else properties.push(property);
		iteration = iterator.next();
	}
	throw new ParserError("no end for tag " + tag);
}
function parseICalendar(stringData) {
	const withFoldedLines = stringData.replace(/\r?\n\s/g, "").split(/\r?\n/).filter((e) => e !== "");
	const iterator = withFoldedLines.values();
	const firstLine = iterator.next();
	if (firstLine.value !== "BEGIN:VCALENDAR") throw new ParserError("Not a VCALENDAR: " + String(firstLine.value));
	return parseIcalObject("VCALENDAR", iterator);
}
function parseAlarm(alarmObject, startTime) {
	const triggerValue = getPropStringValue(alarmObject, "TRIGGER", false);
	const alarmInterval = triggerToAlarmInterval(startTime, triggerValue);
	return alarmInterval != null ? {
		trigger: serializeAlarmInterval(alarmInterval),
		alarmIdentifier: ""
	} : null;
}
function triggerToAlarmInterval(eventStart, triggerValue) {
	if (triggerValue.endsWith("Z")) {
		const triggerTime = parseTime(triggerValue).date;
		const tillEvent = eventStart.getTime() - triggerTime.getTime();
		const minutes = Duration.fromMillis(tillEvent).as("minutes");
		return {
			unit: AlarmIntervalUnit.MINUTE,
			value: minutes
		};
	} else {
		const duration = parseDuration(triggerValue);
		if (duration.positive) return null;
		let smallestUnit = AlarmIntervalUnit.MINUTE;
		if (duration.week) smallestUnit = AlarmIntervalUnit.WEEK;
		if (duration.day) smallestUnit = AlarmIntervalUnit.DAY;
		if (duration.hour) smallestUnit = AlarmIntervalUnit.HOUR;
		if (duration.minute) smallestUnit = AlarmIntervalUnit.MINUTE;
		const luxonDuration = {
			week: duration.week,
			day: duration.day,
			minute: duration.minute,
			hour: duration.hour
		};
		let value;
		switch (smallestUnit) {
			case AlarmIntervalUnit.WEEK:
				value = Duration.fromObject(luxonDuration).as("weeks");
				break;
			case AlarmIntervalUnit.DAY:
				value = Duration.fromObject(luxonDuration).as("days");
				break;
			case AlarmIntervalUnit.HOUR:
				value = Duration.fromObject(luxonDuration).as("hours");
				break;
			case AlarmIntervalUnit.MINUTE:
				value = Duration.fromObject(luxonDuration).as("minutes");
				break;
		}
		return {
			unit: smallestUnit,
			value
		};
	}
}
function parseRrule(rawRruleValue, tzId) {
	let rruleValue;
	try {
		rruleValue = parsePropertyKeyValue(rawRruleValue);
	} catch (e) {
		if (e instanceof ParserError) throw new ParserError("RRULE is not an object " + e.message);
else throw e;
	}
	const frequency = icalFrequencyToRepeatPeriod(rruleValue["FREQ"]);
	const until = rruleValue["UNTIL"] ? parseUntilRruleTime(rruleValue["UNTIL"], tzId) : null;
	const count = rruleValue["COUNT"] ? parseInt(rruleValue["COUNT"]) : null;
	const endType = until != null ? EndType.UntilDate : count != null ? EndType.Count : EndType.Never;
	const interval = rruleValue["INTERVAL"] ? parseInt(rruleValue["INTERVAL"]) : 1;
	const repeatRule = createRepeatRule({
		endValue: until ? String(until.getTime()) : count ? String(count) : null,
		endType,
		interval: String(interval),
		frequency,
		excludedDates: [],
		timeZone: "",
		advancedRules: parseAdvancedRule(rruleValue)
	});
	if (typeof tzId === "string") repeatRule.timeZone = tzId;
	return repeatRule;
}
function parseAdvancedRule(rrule) {
	const advancedRepeatRules = [];
	for (const rruleKey in rrule) {
		if (!BYRULE_MAP.has(rruleKey)) continue;
		for (const interval of rrule[rruleKey].split(",")) {
			if (interval === "") continue;
			advancedRepeatRules.push(createCalendarAdvancedRepeatRule({
				ruleType: BYRULE_MAP.get(rruleKey).toString(),
				interval
			}));
		}
	}
	return advancedRepeatRules;
}
function parseExDates(excludedDatesProps) {
	const allExDates = new Map();
	for (let excludedDatesProp of excludedDatesProps) {
		const tzId = getTzId(excludedDatesProp);
		const values = separatedByCommaParser(new StringIterator(excludedDatesProp.value));
		for (let value of values) {
			const { date: exDate } = parseTime(value, tzId ?? undefined);
			allExDates.set(exDate.getTime(), createDateWrapper({ date: exDate }));
		}
	}
	return [...allExDates.values()].sort((dateWrapper1, dateWrapper2) => dateWrapper1.date.getTime() - dateWrapper2.date.getTime());
}
function parseRecurrenceId(recurrenceIdProp, tzId) {
	const components = parseTimeIntoComponents(recurrenceIdProp.value);
	const filledComponents = components;
	const allDay = !("minute" in components);
	const effectiveZone = allDay ? "UTC" : components.zone ?? getTzId(recurrenceIdProp) ?? tzId ?? undefined;
	delete filledComponents["zone"];
	const luxonDate = DateTime.fromObject(filledComponents, { zone: effectiveZone });
	return toValidJSDate(luxonDate, recurrenceIdProp.value, tzId);
}
/**
* @returns new end time
*/
function parseEventDuration(durationValue, startTime) {
	const duration = parseDuration(durationValue);
	let durationInMillis = 0;
	if (duration.week) durationInMillis += DAY_IN_MILLIS * 7 * duration.week;
	if (duration.day) durationInMillis += DAY_IN_MILLIS * duration.day;
	if (duration.hour) durationInMillis += 36e5 * duration.hour;
	if (duration.minute) durationInMillis += 6e4 * duration.minute;
	return new Date(startTime.getTime() + durationInMillis);
}
function getTzId(prop) {
	let tzId = null;
	const tzIdValue = prop.params["TZID"];
	if (tzIdValue) {
		if (IANAZone.isValidZone(tzIdValue)) tzId = tzIdValue;
else if (tzIdValue in WindowsZones_default) tzId = WindowsZones_default[tzIdValue];
	}
	return tzId;
}
function oneDayDurationEnd(startTime, allDay, tzId, zone) {
	return DateTime.fromJSDate(startTime, { zone: allDay ? "UTC" : tzId || zone }).plus({ day: 1 }).toJSDate();
}
const MAILTO_PREFIX_REGEX = /^mailto:(.*)/i;
function parseMailtoValue(value) {
	const match = value.match(MAILTO_PREFIX_REGEX);
	return match && match[1];
}
const calendarAttendeeStatusToParstat = {
	[CalendarAttendeeStatus.ADDED]: "NEEDS-ACTION",
	[CalendarAttendeeStatus.NEEDS_ACTION]: "NEEDS-ACTION",
	[CalendarAttendeeStatus.ACCEPTED]: "ACCEPTED",
	[CalendarAttendeeStatus.DECLINED]: "DECLINED",
	[CalendarAttendeeStatus.TENTATIVE]: "TENTATIVE"
};
const parstatToCalendarAttendeeStatus = reverse(calendarAttendeeStatusToParstat);
function parseCalendarEvents(icalObject, zone) {
	const methodProp = getProp(icalObject, "METHOD", true);
	const method = methodProp ? methodProp.value : CalendarMethod.PUBLISH;
	const eventObjects = icalObject.children.filter((obj) => obj.type === "VEVENT");
	const contents = getContents(eventObjects, zone);
	return {
		method,
		contents
	};
}
function getContents(eventObjects, zone) {
	return eventObjects.map((eventObj, index) => {
		const startProp = getProp(eventObj, "DTSTART", false);
		const tzId = getTzId(startProp);
		const { date: startTime, allDay } = parseTime(startProp.value, tzId ?? undefined);
		let hasValidUid = false;
		let uid = null;
		try {
			uid = getPropStringValue(eventObj, "UID", false);
			hasValidUid = true;
		} catch (e) {
			if (e instanceof ParserError) uid = `import-${Date.now()}-${index}@tuta.com`;
else throw e;
		}
		const recurrenceIdProp = getProp(eventObj, "RECURRENCE-ID", true);
		let recurrenceId = null;
		if (recurrenceIdProp != null && hasValidUid) recurrenceId = parseRecurrenceId(recurrenceIdProp, tzId);
		const endTime = parseEndTime(eventObj, allDay, startTime, tzId, zone);
		let summary = "";
		const maybeSummary = parseICalText(eventObj, "SUMMARY");
		if (maybeSummary) summary = maybeSummary;
		let location = "";
		const maybeLocation = parseICalText(eventObj, "LOCATION");
		if (maybeLocation) location = maybeLocation;
		const rruleProp = getPropStringValue(eventObj, "RRULE", true);
		const excludedDateProps = eventObj.properties.filter((p) => p.name === "EXDATE");
		let repeatRule = null;
		if (rruleProp != null) {
			repeatRule = parseRrule(rruleProp, tzId);
			repeatRule.excludedDates = parseExDates(excludedDateProps);
		}
		const description = parseICalText(eventObj, "DESCRIPTION") ?? "";
		const sequenceProp = getProp(eventObj, "SEQUENCE", true);
		let sequence = "0";
		if (sequenceProp) {
			const sequenceNumber = filterInt(sequenceProp.value);
			if (Number.isNaN(sequenceNumber)) throw new ParserError("SEQUENCE value is not a number");
			sequence = String(sequenceNumber);
		}
		const attendees = getAttendees(eventObj);
		const organizerProp = getProp(eventObj, "ORGANIZER", true);
		let organizer = null;
		if (organizerProp) {
			const organizerAddress = parseMailtoValue(organizerProp.value);
			if (organizerAddress && isMailAddress(organizerAddress, false)) organizer = createEncryptedMailAddress({
				address: organizerAddress,
				name: organizerProp.params["name"] || ""
			});
else console.log("organizer has no address or address is invalid, ignoring: ", organizerAddress);
		}
		const event = createCalendarEvent({
			description,
			startTime,
			endTime,
			uid,
			recurrenceId,
			summary,
			location,
			repeatRule,
			sequence,
			attendees,
			organizer,
			hashedUid: null,
			invitedConfidentially: null,
			alarmInfos: []
		});
		let alarms = [];
		try {
			alarms = getAlarms(eventObj, startTime);
		} catch (e) {
			console.log("alarm is invalid for event: ", event.summary, event.startTime);
		}
		return {
			event,
			alarms
		};
	});
}
function getAttendees(eventObj) {
	let attendees = [];
	for (const property of eventObj.properties) if (property.name === "ATTENDEE") {
		const attendeeAddress = parseMailtoValue(property.value);
		if (!attendeeAddress || !isMailAddress(attendeeAddress, false)) {
			console.log("attendee has no address or address is invalid, ignoring: ", attendeeAddress);
			continue;
		}
		const partStatString = property.params["PARTSTAT"];
		const status = partStatString ? parstatToCalendarAttendeeStatus[partStatString] : CalendarAttendeeStatus.NEEDS_ACTION;
		if (!status) {
			console.log(`attendee has invalid partsat: ${partStatString}, ignoring`);
			continue;
		}
		attendees.push(createCalendarEventAttendee({
			address: createEncryptedMailAddress({
				address: attendeeAddress,
				name: property.params["CN"] || ""
			}),
			status
		}));
	}
	return attendees;
}
function getAlarms(eventObj, startTime) {
	const alarms = [];
	for (const alarmChild of eventObj.children) if (alarmChild.type === "VALARM") {
		const newAlarm = parseAlarm(alarmChild, startTime);
		if (newAlarm) alarms.push(newAlarm);
	}
	return alarms;
}
/**
* Parses text properties according to the iCal standard.
* https://icalendar.org/iCalendar-RFC-5545/3-3-11-text.html
* @param eventObj
* @param tag
*/
function parseICalText(eventObj, tag) {
	let text = getPropStringValue(eventObj, tag, true);
	for (const rawEscape in revICalReplacements) {
		if (rawEscape === "\\n") text = text?.replace("\\N", revICalReplacements[rawEscape]);
		text = text?.replace(rawEscape, revICalReplacements[rawEscape]);
	}
	return text;
}
function parseEndTime(eventObj, allDay, startTime, tzId, zone) {
	const endProp = getProp(eventObj, "DTEND", true);
	if (endProp) {
		if (typeof endProp.value !== "string") throw new ParserError("DTEND value is not a string");
		const endTzId = getTzId(endProp);
		const parsedEndTime = parseTime(endProp.value, typeof endTzId === "string" ? endTzId : undefined);
		const endTime = parsedEndTime.date;
		if (endTime > startTime) return endTime;
		if (allDay) return DateTime.fromJSDate(startTime).plus({ day: 1 }).toJSDate();
else return DateTime.fromJSDate(startTime).plus({ second: 1 }).toJSDate();
	} else {
		const durationValue = getPropStringValue(eventObj, "DURATION", true);
		if (durationValue) return parseEventDuration(durationValue, startTime);
else return oneDayDurationEnd(startTime, allDay, tzId, zone);
	}
}
function icalFrequencyToRepeatPeriod(value) {
	const convertedValue = {
		DAILY: RepeatPeriod.DAILY,
		WEEKLY: RepeatPeriod.WEEKLY,
		MONTHLY: RepeatPeriod.MONTHLY,
		YEARLY: RepeatPeriod.ANNUALLY
	}[value];
	if (convertedValue == null) throw new ParserError("Invalid frequency: " + value);
	return convertedValue;
}
function repeatPeriodToIcalFrequency(repeatPeriod) {
	const mapping = {
		[RepeatPeriod.DAILY]: "DAILY",
		[RepeatPeriod.WEEKLY]: "WEEKLY",
		[RepeatPeriod.MONTHLY]: "MONTHLY",
		[RepeatPeriod.ANNUALLY]: "YEARLY"
	};
	return mapping[repeatPeriod];
}
function parseTimeIntoComponents(value) {
	const trimmedValue = value.trim();
	if (/[0-9]{8}T[0-9]{6}Z/.test(trimmedValue)) {
		const { year, month, day } = parseDateString(trimmedValue);
		const hour = parseInt(trimmedValue.slice(9, 11));
		const minute = parseInt(trimmedValue.slice(11, 13));
		return {
			year,
			month,
			day,
			hour,
			minute,
			zone: "UTC"
		};
	} else if (/[0-9]{8}T[0-9]{6}/.test(trimmedValue)) {
		const { year, month, day } = parseDateString(trimmedValue);
		const hour = parseInt(trimmedValue.slice(9, 11));
		const minute = parseInt(trimmedValue.slice(11, 13));
		return {
			year,
			month,
			day,
			hour,
			minute
		};
	} else if (/[0-9]{8}/.test(trimmedValue)) return Object.assign({}, parseDateString(trimmedValue));
else throw new ParserError("Failed to parse time: " + trimmedValue);
}
function parseUntilRruleTime(value, zone) {
	const components = parseTimeIntoComponents(value);
	const filledComponents = components;
	const allDay = !("minute" in components);
	const effectiveZone = allDay ? "UTC" : zone ?? undefined;
	delete filledComponents["zone"];
	const luxonDate = DateTime.fromObject(filledComponents, { zone: effectiveZone });
	const startOfNextDay = luxonDate.plus({ day: 1 }).startOf("day");
	return toValidJSDate(startOfNextDay, value, zone);
}
function parseTime(value, zone) {
	const components = parseTimeIntoComponents(value);
	const allDay = !("minute" in components);
	const effectiveZone = allDay ? "UTC" : components.zone ?? zone;
	delete components["zone"];
	const filledComponents = Object.assign({}, allDay ? {
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0
	} : {}, components);
	try {
		const dateTime = DateTime.fromObject(filledComponents, { zone: effectiveZone });
		return {
			date: toValidJSDate(dateTime, value, zone ?? null),
			allDay
		};
	} catch (e) {
		if (e instanceof ParserError) throw e;
		throw new ParserError(`failed to parse time from ${value} to ${JSON.stringify(filledComponents)}, effectiveZone: ${effectiveZone}, original error: ${e.message}`);
	}
}
function toValidJSDate(dateTime, value, zone) {
	if (!dateTime.isValid) throw new ParserError(`Date value ${value} is invalid in zone ${String(zone)}`);
	return dateTime.toJSDate();
}
function parsePropertyName(iterator) {
	let text = "";
	let next;
	while ((next = iterator.peek()) && /[a-zA-Z0-9-_]/.test(next)) text += neverNull(iterator.next().value);
	if (text === "") throw new ParserError("could not parse property name: " + iterator.peek());
	return text;
}
const secondDurationParser = combineParsers(numberParser, makeCharacterParser("S"));
const minuteDurationParser = combineParsers(numberParser, makeCharacterParser("M"));
const hourDurationParser = combineParsers(numberParser, makeCharacterParser("H"));
const durationTimeParser = mapParser(combineParsers(makeCharacterParser("T"), maybeParse(hourDurationParser), maybeParse(minuteDurationParser), maybeParse(secondDurationParser)), (parsed) => {
	let hour, minute;
	if (parsed[1]) hour = parsed[1][0];
	if (parsed[2]) minute = parsed[2][0];
	return {
		hour,
		minute
	};
});
const durationDayParser = combineParsers(numberParser, makeCharacterParser("D"));
const durationWeekParser = combineParsers(numberParser, makeCharacterParser("W"));
const durationParser = mapParser(combineParsers(maybeParse(makeEitherParser(makeCharacterParser("+"), makeCharacterParser("-"))), makeCharacterParser("P"), maybeParse(durationWeekParser), maybeParse(durationDayParser), maybeParse(durationTimeParser)), (parsed) => {
	const positive = parsed[0] !== "-";
	let week, day, hour, minute;
	if (parsed[2]) week = parsed[2][0];
	if (parsed[3]) day = parsed[3][0];
	return {
		positive,
		week,
		day,
		hour: parsed[4]?.hour,
		minute: parsed[4]?.minute
	};
});
function parseDuration(value) {
	const iterator = new StringIterator(value);
	const duration = durationParser(iterator);
	if (iterator.peek()) throw new ParserError("Could not parse duration completely");
	return duration;
}

//#endregion
//#region ../src/common/calendar/import/ImportExportUtils.ts
let EventImportRejectionReason = function(EventImportRejectionReason$1) {
	EventImportRejectionReason$1[EventImportRejectionReason$1["Pre1970"] = 0] = "Pre1970";
	EventImportRejectionReason$1[EventImportRejectionReason$1["Inversed"] = 1] = "Inversed";
	EventImportRejectionReason$1[EventImportRejectionReason$1["InvalidDate"] = 2] = "InvalidDate";
	EventImportRejectionReason$1[EventImportRejectionReason$1["Duplicate"] = 3] = "Duplicate";
	return EventImportRejectionReason$1;
}({});
/** check if the event should be skipped because it's invalid or already imported. if not, add it to the map. */
function shouldBeSkipped(event, instanceIdentifierToEventMap) {
	if (!event.uid) throw new Error("Uid is not set for imported event");
	switch (checkEventValidity(event)) {
		case CalendarEventValidity.InvalidContainsInvalidDate: return EventImportRejectionReason.InvalidDate;
		case CalendarEventValidity.InvalidEndBeforeStart: return EventImportRejectionReason.Inversed;
		case CalendarEventValidity.InvalidPre1970: return EventImportRejectionReason.Pre1970;
	}
	const instanceIdentifier = makeInstanceIdentifier(event);
	if (!instanceIdentifierToEventMap.has(instanceIdentifier)) {
		instanceIdentifierToEventMap.set(instanceIdentifier, event);
		return null;
	} else return EventImportRejectionReason.Duplicate;
}
/** we try to enforce that each calendar only contains each uid once, but we need to take into consideration
* that altered instances have the same uid as their progenitor.*/
function makeInstanceIdentifier(event) {
	return `${event.uid}-${event.recurrenceId?.getTime() ?? "progenitor"}`;
}
function sortOutParsedEvents(parsedEvents, existingEvents, calendarGroupRoot, zone) {
	const instanceIdentifierToEventMap = new Map();
	for (const existingEvent of existingEvents) {
		if (existingEvent.uid == null) continue;
		instanceIdentifierToEventMap.set(makeInstanceIdentifier(existingEvent), existingEvent);
	}
	const rejectedEvents = new Map();
	const eventsForCreation = [];
	for (const [_, flatParsedEvents] of groupBy(parsedEvents, (e) => e.event.uid)) {
		let progenitor = null;
		let alteredInstances = [];
		for (const { event, alarms } of flatParsedEvents) {
			if (flatParsedEvents.length > 1) console.warn("[ImportExportUtils] Found events with same uid: flatParsedEvents with more than one entry", { flatParsedEvents });
			const rejectionReason = shouldBeSkipped(event, instanceIdentifierToEventMap);
			if (rejectionReason != null) {
				getFromMap(rejectedEvents, rejectionReason, () => []).push(event);
				continue;
			}
			const repeatRule = event.repeatRule;
			event._ownerGroup = calendarGroupRoot._id;
			if (repeatRule != null && repeatRule.timeZone === "") repeatRule.timeZone = getTimeZone();
			for (let alarmInfo of alarms) alarmInfo.alarmIdentifier = generateEventElementId(Date.now());
			assignEventId(event, zone, calendarGroupRoot);
			if (event.recurrenceId == null) progenitor = {
				event,
				alarms
			};
else {
				if (progenitor?.event.repeatRule != null) insertIntoSortedArray(createDateWrapper({ date: event.recurrenceId }), progenitor.event.repeatRule.excludedDates, (left, right) => left.date.getTime() - right.date.getTime(), () => true);
				alteredInstances.push({
					event,
					alarms
				});
			}
		}
		if (progenitor != null) eventsForCreation.push(progenitor);
		eventsForCreation.push(...alteredInstances);
	}
	return {
		rejectedEvents,
		eventsForCreation
	};
}
function parseCalendarStringData(value, zone) {
	const tree = parseICalendar(value);
	return parseCalendarEvents(tree, zone);
}
let SyncStatus = function(SyncStatus$1) {
	SyncStatus$1["Failed"] = "Failed";
	SyncStatus$1["Success"] = "Success";
	return SyncStatus$1;
}({});
let ByRule = function(ByRule$1) {
	ByRule$1[ByRule$1["BYMINUTE"] = 0] = "BYMINUTE";
	ByRule$1[ByRule$1["BYHOUR"] = 1] = "BYHOUR";
	ByRule$1[ByRule$1["BYDAY"] = 2] = "BYDAY";
	ByRule$1[ByRule$1["BYMONTHDAY"] = 3] = "BYMONTHDAY";
	ByRule$1[ByRule$1["BYYEARDAY"] = 4] = "BYYEARDAY";
	ByRule$1[ByRule$1["BYWEEKNO"] = 5] = "BYWEEKNO";
	ByRule$1[ByRule$1["BYMONTH"] = 6] = "BYMONTH";
	ByRule$1[ByRule$1["BYSETPOS"] = 7] = "BYSETPOS";
	ByRule$1[ByRule$1["WKST"] = 8] = "WKST";
	return ByRule$1;
}({});
const BYRULE_MAP = freezeMap(new Map([
	["BYMINUTE", ByRule.BYMINUTE],
	["BYHOUR", ByRule.BYHOUR],
	["BYDAY", ByRule.BYDAY],
	["BYMONTHDAY", ByRule.BYMONTHDAY],
	["BYYEARDAY", ByRule.BYYEARDAY],
	["BYWEEKNO", ByRule.BYWEEKNO],
	["BYMONTH", ByRule.BYMONTH],
	["BYSETPOS", ByRule.BYSETPOS],
	["WKST", ByRule.WKST]
]));

//#endregion
export { EventImportRejectionReason, SyncStatus, calendarAttendeeStatusToParstat, iCalReplacements, parseCalendarEvents, parseCalendarStringData, parseDuration, parseExDates, parseICalendar, parseProperty, parsePropertyKeyValue, parseRecurrenceId, parseTime, parseUntilRruleTime, propertySequenceParser, repeatPeriodToIcalFrequency, sortOutParsedEvents, triggerToAlarmInterval };
//# sourceMappingURL=ImportExportUtils-B1MoOmZ0.js.map