
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { assertNonNull, binarySearch, defer, findBy, findLast, first, getFirstOrThrow, last, lastThrow, memoizedWithHiddenArgument, remove, setAddAll, setEquals, setMap, settledThen } from "./dist-CJHwsXKY.js";
import { isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { ListAutoSelectBehavior } from "./DeviceConfig-payZM407.js";
import { ListLoadingState, PageSize } from "./List-CdKNFQkI.js";

//#region ../src/common/misc/ListModel.ts
var import_stream = __toESM(require_stream(), 1);
var import_stream$1 = __toESM(require_stream(), 1);
var ListModel = class {
	constructor(config) {
		this.config = config;
	}
	loadState = "created";
	loading = Promise.resolve();
	filter = null;
	rangeSelectionAnchorItem = null;
	get state() {
		return this.stateStream();
	}
	get rawState() {
		return this.rawStateStream();
	}
	defaultRawStateStream = {
		unfilteredItems: [],
		filteredItems: [],
		inMultiselect: false,
		loadingStatus: ListLoadingState.Idle,
		loadingAll: false,
		selectedItems: new Set(),
		activeItem: null
	};
	rawStateStream = (0, import_stream$1.default)(this.defaultRawStateStream);
	stateStream = this.rawStateStream.map((state) => {
		const activeItem = state.activeItem;
		const foundIndex = activeItem ? binarySearch(state.filteredItems, activeItem, (l, r) => this.config.sortCompare(l, r)) : -1;
		const activeIndex = foundIndex < 0 ? null : foundIndex;
		return {
			...state,
			items: state.filteredItems,
			activeIndex
		};
	});
	differentItemsSelected = import_stream.default.scan((acc, state) => {
		const newSelectedIds = setMap(state.selectedItems, (item) => this.config.getItemId(item));
		const oldSelectedIds = setMap(acc, (item) => this.config.getItemId(item));
		if (setEquals(oldSelectedIds, newSelectedIds)) return import_stream.default.SKIP;
else return state.selectedItems;
	}, new Set(), this.stateStream);
	updateState(newStatePart) {
		this.rawStateStream({
			...this.rawState,
			...newStatePart
		});
	}
	waitUtilInit() {
		const deferred = defer();
		const subscription = this.rawStateStream.map(() => {
			if (this.loadState === "initialized") Promise.resolve().then(() => {
				subscription.end(true);
				deferred.resolve(undefined);
			});
		});
		return deferred.promise;
	}
	async loadInitial() {
		if (this.loadState !== "created") return;
		this.loadState = "initialized";
		await this.doLoad();
	}
	async loadMore() {
		if (this.rawState.loadingStatus === ListLoadingState.Loading) return this.loading;
		if (this.loadState !== "initialized" || this.rawState.loadingStatus !== ListLoadingState.Idle) return;
		await this.doLoad();
	}
	async retryLoading() {
		if (this.loadState !== "initialized" || this.rawState.loadingStatus !== ListLoadingState.ConnectionLost) return;
		await this.doLoad();
	}
	updateLoadingStatus(status) {
		if (this.rawState.loadingStatus === status) return;
		this.updateState({ loadingStatus: status });
	}
	async doLoad() {
		this.updateLoadingStatus(ListLoadingState.Loading);
		this.loading = Promise.resolve().then(async () => {
			const lastFetchedItem = last(this.rawState.unfilteredItems);
			try {
				const { items: newItems, complete } = await this.config.fetch(lastFetchedItem, PageSize);
				if (this.state.loadingStatus === ListLoadingState.ConnectionLost) return;
				const newUnfilteredItems = [...this.rawState.unfilteredItems, ...newItems];
				newUnfilteredItems.sort(this.config.sortCompare);
				const newFilteredItems = [...this.rawState.filteredItems, ...this.applyFilter(newItems)];
				newFilteredItems.sort(this.config.sortCompare);
				const loadingStatus = complete ? ListLoadingState.Done : ListLoadingState.Idle;
				this.updateState({
					loadingStatus,
					unfilteredItems: newUnfilteredItems,
					filteredItems: newFilteredItems
				});
			} catch (e) {
				this.updateLoadingStatus(ListLoadingState.ConnectionLost);
				if (!isOfflineError(e)) throw e;
			}
		});
		return this.loading;
	}
	applyFilter(newItems) {
		return newItems.filter(this.filter ?? (() => true));
	}
	setFilter(filter) {
		this.filter = filter;
		this.reapplyFilter();
	}
	reapplyFilter() {
		const newFilteredItems = this.applyFilter(this.rawState.unfilteredItems);
		const newSelectedItems = new Set(this.applyFilter([...this.state.selectedItems]));
		this.updateState({
			filteredItems: newFilteredItems,
			selectedItems: newSelectedItems
		});
	}
	onSingleSelection(item) {
		this.updateState({
			selectedItems: new Set([item]),
			inMultiselect: false,
			activeItem: item
		});
		this.rangeSelectionAnchorItem = item;
	}
	/** An item was added to the selection. If multiselect was not on, discard previous single selection and only added selected item to the selection. */
	onSingleExclusiveSelection(item) {
		if (!this.rawState.inMultiselect) {
			this.updateState({
				selectedItems: new Set([item]),
				inMultiselect: true,
				activeItem: item
			});
			this.rangeSelectionAnchorItem = item;
		} else {
			const selectedItems = new Set(this.state.selectedItems);
			if (selectedItems.has(item)) selectedItems.delete(item);
else selectedItems.add(item);
			if (selectedItems.size === 0) {
				this.updateState({
					selectedItems,
					inMultiselect: false,
					activeItem: null
				});
				this.rangeSelectionAnchorItem = null;
			} else {
				this.updateState({
					selectedItems,
					inMultiselect: true,
					activeItem: item
				});
				this.rangeSelectionAnchorItem = item;
			}
		}
	}
	/** An item was added to the selection. If multiselect was not on, add previous single selection and newly added selected item to the selection. */
	onSingleInclusiveSelection(item, clearSelectionOnMultiSelectStart) {
		if (!this.state.inMultiselect && clearSelectionOnMultiSelectStart) this.selectNone();
		const selectedItems = new Set(this.state.selectedItems);
		if (this.state.inMultiselect && selectedItems.has(item)) selectedItems.delete(item);
else selectedItems.add(item);
		if (selectedItems.size === 0) {
			this.updateState({
				selectedItems,
				inMultiselect: false,
				activeItem: null
			});
			this.rangeSelectionAnchorItem = null;
		} else {
			this.updateState({
				selectedItems,
				inMultiselect: true,
				activeItem: item
			});
			this.rangeSelectionAnchorItem = item;
		}
	}
	async loadAndSelect(finder, shouldStop) {
		await this.waitUtilInit();
		let foundItem = undefined;
		while (!(foundItem = this.rawState.unfilteredItems.find(finder)) && !shouldStop() && this.rawState.loadingStatus !== ListLoadingState.Done && this.rawState.loadingStatus !== ListLoadingState.ConnectionLost) await this.loadMore();
		if (foundItem) this.onSingleSelection(foundItem);
		return foundItem ?? null;
	}
	selectRangeTowards(item) {
		const selectedItems = new Set(this.state.selectedItems);
		if (selectedItems.size === 0) selectedItems.add(item);
else {
			const clickedItemIndex = this.state.items.indexOf(item);
			let nearestSelectedIndex = null;
			for (const selectedItem of selectedItems) {
				const currentSelectedItemIndex = this.state.items.indexOf(selectedItem);
				if (nearestSelectedIndex == null || Math.abs(clickedItemIndex - currentSelectedItemIndex) < Math.abs(clickedItemIndex - nearestSelectedIndex)) nearestSelectedIndex = currentSelectedItemIndex;
			}
			assertNonNull(nearestSelectedIndex);
			const itemsToAddToSelection = [];
			if (nearestSelectedIndex < clickedItemIndex) for (let i = nearestSelectedIndex + 1; i <= clickedItemIndex; i++) itemsToAddToSelection.push(this.state.items[i]);
else for (let i = clickedItemIndex; i < nearestSelectedIndex; i++) itemsToAddToSelection.push(this.state.items[i]);
			setAddAll(selectedItems, itemsToAddToSelection);
		}
		this.updateState({
			selectedItems,
			inMultiselect: true,
			activeItem: item
		});
		this.rangeSelectionAnchorItem = item;
	}
	selectPrevious(multiselect) {
		const oldActiveItem = this.rawState.activeItem;
		const newActiveItem = this.getPreviousItem(oldActiveItem);
		if (newActiveItem != null) if (!multiselect) this.onSingleSelection(newActiveItem);
else {
			const selectedItems = new Set(this.state.selectedItems);
			this.rangeSelectionAnchorItem = this.rangeSelectionAnchorItem ?? first(this.state.items);
			if (!this.rangeSelectionAnchorItem) return;
			const previousActiveIndex = this.state.activeIndex ?? 0;
			const towardsAnchor = this.config.sortCompare(oldActiveItem ?? getFirstOrThrow(this.state.items), this.rangeSelectionAnchorItem) > 0;
			if (towardsAnchor) selectedItems.delete(this.state.items[previousActiveIndex]);
else selectedItems.add(newActiveItem);
			this.updateState({
				activeItem: newActiveItem,
				selectedItems,
				inMultiselect: true
			});
		}
	}
	getPreviousItem(oldActiveItem) {
		return oldActiveItem == null ? first(this.state.items) : findLast(this.state.items, (item) => this.config.sortCompare(item, oldActiveItem) < 0) ?? first(this.state.items);
	}
	selectNext(multiselect) {
		const oldActiveItem = this.rawState.activeItem;
		const lastItem = last(this.state.items);
		const newActiveItem = this.getNextItem(oldActiveItem, lastItem);
		if (newActiveItem != null) if (!multiselect) this.onSingleSelection(newActiveItem);
else {
			const selectedItems = new Set(this.state.selectedItems);
			this.rangeSelectionAnchorItem = this.rangeSelectionAnchorItem ?? first(this.state.items);
			if (!this.rangeSelectionAnchorItem) return;
			const previousActiveIndex = this.state.activeIndex ?? 0;
			const towardsAnchor = this.config.sortCompare(oldActiveItem ?? getFirstOrThrow(this.state.items), this.rangeSelectionAnchorItem) < 0;
			if (towardsAnchor) selectedItems.delete(this.state.items[previousActiveIndex]);
else selectedItems.add(newActiveItem);
			this.updateState({
				selectedItems,
				inMultiselect: true,
				activeItem: newActiveItem
			});
		}
	}
	getNextItem(oldActiveItem, lastItem) {
		return oldActiveItem == null ? first(this.state.items) : lastItem && this.config.sortCompare(lastItem, oldActiveItem) <= 0 ? lastItem : this.state.items.find((item) => this.config.sortCompare(item, oldActiveItem) > 0) ?? first(this.state.items);
	}
	areAllSelected() {
		return this.rawState.inMultiselect && this.state.selectedItems.size === this.state.items.length;
	}
	selectAll() {
		this.updateState({
			selectedItems: new Set(this.state.items),
			activeItem: null,
			inMultiselect: true
		});
		this.rangeSelectionAnchorItem = null;
	}
	selectNone() {
		this.rangeSelectionAnchorItem = null;
		this.updateState({
			selectedItems: new Set(),
			inMultiselect: false
		});
	}
	isItemSelected(itemId) {
		return findBy(this.state.selectedItems, (item) => this.config.isSameId(this.config.getItemId(item), itemId)) != null;
	}
	getSelectedAsArray = memoizedWithHiddenArgument(() => this.state, (state) => [...state.selectedItems]);
	isSelectionEmpty = memoizedWithHiddenArgument(() => this.state, (state) => state.selectedItems.size === 0);
	getUnfilteredAsArray = memoizedWithHiddenArgument(() => this.rawState, (state) => [...state.unfilteredItems]);
	enterMultiselect() {
		this.selectNone();
		this.updateState({ inMultiselect: true });
	}
	sort() {
		const filteredItems = this.rawState.filteredItems.slice().sort(this.config.sortCompare);
		const unfilteredItems = this.rawState.filteredItems.slice().sort(this.config.sortCompare);
		this.updateState({
			filteredItems,
			unfilteredItems
		});
	}
	isLoadedCompletely() {
		return this.rawState.loadingStatus === ListLoadingState.Done;
	}
	cancelLoadAll() {
		if (this.state.loadingAll) this.updateState({ loadingAll: false });
	}
	async loadAll() {
		if (this.rawState.loadingAll) return;
		this.updateState({ loadingAll: true });
		try {
			while (this.rawState.loadingAll && !this.isLoadedCompletely()) {
				await this.loadMore();
				this.selectAll();
			}
		} finally {
			this.cancelLoadAll();
		}
	}
	isEmptyAndDone() {
		return this.state.items.length === 0 && this.state.loadingStatus === ListLoadingState.Done;
	}
	stopLoading() {
		if (this.state.loadingStatus === ListLoadingState.Loading) this.updateState({ loadingStatus: ListLoadingState.ConnectionLost });
	}
	waitLoad(what) {
		return settledThen(this.loading, what);
	}
	insertLoadedItem(item) {
		if (this.rawState.unfilteredItems.some((unfilteredItem) => this.hasSameId(unfilteredItem, item))) return;
		const unfilteredItems = this.rawState.unfilteredItems.concat(item).sort(this.config.sortCompare);
		const filteredItems = this.rawState.filteredItems.concat(this.applyFilter([item])).sort(this.config.sortCompare);
		this.updateState({
			filteredItems,
			unfilteredItems
		});
	}
	updateLoadedItem(item) {
		const positionToUpdateUnfiltered = this.rawState.unfilteredItems.findIndex((unfilteredItem) => this.hasSameId(unfilteredItem, item));
		const unfilteredItems = this.rawState.unfilteredItems.slice();
		if (positionToUpdateUnfiltered >= 0) {
			unfilteredItems.splice(positionToUpdateUnfiltered, 1, item);
			unfilteredItems.sort(this.config.sortCompare);
		}
		const positionToUpdateFiltered = this.rawState.filteredItems.findIndex((filteredItem) => this.hasSameId(filteredItem, item));
		const filteredItems = this.rawState.filteredItems.slice();
		const selectedItems = new Set(this.rawState.selectedItems);
		if (positionToUpdateFiltered >= 0) {
			const [oldItem] = filteredItems.splice(positionToUpdateFiltered, 1, item);
			filteredItems.sort(this.config.sortCompare);
			if (selectedItems.delete(oldItem)) selectedItems.add(item);
		}
		const activeItemUpdated = this.rawState.activeItem != null && this.hasSameId(this.rawState.activeItem, item);
		const newActiveItem = this.rawState.activeItem;
		if (positionToUpdateUnfiltered !== -1 || positionToUpdateFiltered !== -1 || activeItemUpdated) this.updateState({
			unfilteredItems,
			filteredItems,
			selectedItems,
			activeItem: newActiveItem
		});
		if (this.rangeSelectionAnchorItem != null && this.hasSameId(this.rangeSelectionAnchorItem, item)) this.rangeSelectionAnchorItem = item;
	}
	deleteLoadedItem(itemId) {
		return settledThen(this.loading, () => {
			const item = this.rawState.filteredItems.find((e) => this.config.isSameId(this.config.getItemId(e), itemId));
			const selectedItems = new Set(this.rawState.selectedItems);
			let newActiveItem;
			if (item) {
				const wasRemoved = selectedItems.delete(item);
				if (this.rawState.filteredItems.length > 1) {
					const desiredBehavior = this.config.autoSelectBehavior?.() ?? null;
					if (wasRemoved) if (desiredBehavior === ListAutoSelectBehavior.NONE || this.state.inMultiselect) selectedItems.clear();
else if (desiredBehavior === ListAutoSelectBehavior.NEWER) newActiveItem = this.getPreviousItem(item);
else newActiveItem = item === last(this.state.items) ? this.getPreviousItem(item) : this.getNextItem(item, null);
					if (newActiveItem) selectedItems.add(newActiveItem);
else newActiveItem = this.rawState.activeItem;
				}
				const filteredItems = this.rawState.filteredItems.slice();
				remove(filteredItems, item);
				const unfilteredItems = this.rawState.unfilteredItems.slice();
				remove(unfilteredItems, item);
				this.updateState({
					filteredItems,
					selectedItems,
					unfilteredItems,
					activeItem: newActiveItem
				});
			}
		});
	}
	getLastItem() {
		if (this.rawState.unfilteredItems.length > 0) return lastThrow(this.rawState.unfilteredItems);
else return null;
	}
	hasSameId(item1, item2) {
		const id1 = this.config.getItemId(item1);
		const id2 = this.config.getItemId(item2);
		return this.config.isSameId(id1, id2);
	}
	canInsertItem(entity) {
		if (this.state.loadingStatus === ListLoadingState.Done) return true;
		const lastElement = this.getLastItem();
		return lastElement != null && this.config.sortCompare(entity, lastElement) < 0;
	}
};
function selectionAttrsForList(listModel) {
	return {
		selected: listModel?.areAllSelected() ?? false,
		selectNone: () => listModel?.selectNone(),
		selectAll: () => listModel?.selectAll()
	};
}

//#endregion
export { ListModel, selectionAttrsForList };
//# sourceMappingURL=ListModel-jYF3dysm.js.map