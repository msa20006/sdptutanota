{"version":3,"file":"OfflineDbRefCounter-BNorH-9b.js","names":["offlineDbFactory: OfflineDbFactory","userId: Id","dbKey: Uint8Array","entry: CacheEntry | undefined","userId: string","listId: Id"],"sources":["../../src/common/desktop/db/OfflineDbRefCounter.ts"],"sourcesContent":["import { defer, DeferredObject, delay } from \"@tutao/tutanota-utils\"\nimport { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { log } from \"../DesktopLog.js\"\nimport { OfflineDbFactory } from \"./PerWindowSqlCipherFacade.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\n\nconst TAG = \"[OfflineDbRefCounter]\"\nconst MAX_WAIT_FOR_DB_CLOSE_MS = 1000\n\ninterface CacheEntry {\n\treadonly db: Promise<SqlCipherFacade>\n\t/** Reference counting for db in case multiple windows open it. */\n\tcounter: number\n\t/**\n\t * We want to lock the access to the \"ranges\" table when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId).\n\t * We store locks with their corresponding listId in this Map.\n\t */\n\tlistIdLocks: Map<string, DeferredObject<void>>\n}\n\n/**\n * mainly for reference counting sqlcipher database connections coming from different windows.\n * keeps one opened database for each userId, independent of the number of windows logged\n * into that account (as long as it's bigger than 0)\n */\nexport class OfflineDbRefCounter {\n\t/**\n\t * a map from userId to an instance of an offlineDb for that user and the number of references currently held to it.\n\t * @private\n\t */\n\tprivate readonly cache: Map<Id, CacheEntry> = new Map()\n\n\tconstructor(private readonly offlineDbFactory: OfflineDbFactory) {}\n\n\tasync getOrCreateDb(userId: Id, dbKey: Uint8Array): Promise<SqlCipherFacade> {\n\t\tlet entry: CacheEntry | undefined = this.cache.get(userId)\n\t\tif (entry) {\n\t\t\tentry.counter += 1\n\t\t\treturn await entry.db\n\t\t} else {\n\t\t\tconst db = this.offlineDbFactory.create(userId, dbKey)\n\t\t\tentry = { db, counter: 1, listIdLocks: new Map() }\n\t\t\tthis.cache.set(userId, entry)\n\t\t\treturn await entry.db\n\t\t}\n\n\t\t// not returning from here makes for better stack traces.\n\t}\n\n\t/*\n\t * de-reference the offline db belonging to the userId.\n\t * will release the db connection if this is the last reference.\n\t *\n\t * must only be called directly from PerWindowSqlCipherFacade or from within this class.\n\t *\n\t **/\n\tasync disposeDb(userId: Id) {\n\t\tlet entry = this.cache.get(userId)\n\t\tif (entry == null) {\n\t\t\treturn\n\t\t}\n\t\tentry.counter -= 1\n\n\t\tif (entry.counter === 0) {\n\t\t\tthis.cache.delete(userId)\n\t\t\tconst db = await entry.db\n\t\t\tawait db.closeDb()\n\t\t\tconsole.log(TAG, \"closed db for\", userId)\n\t\t} else {\n\t\t\tconsole.log(TAG, \"dispose done, still ref'd\")\n\t\t}\n\t}\n\n\t/**\n\t * deletes the offline DB file from the disk, making a best-effort attempt to let all\n\t * windows close the connection before removing it.\n\t *\n\t * should be used when:\n\t * * the offline DB is out of sync\n\t * * the credentials are deleted from the app\n\t * * the user logs in with a userId that is already stored in the app (internal and external users)\n\t * * there was an error during session creation that could cause us to have a new database but no new credentials.\n\t *\n\t * the database is not necessarily open or in the cache; it may be deleted directly from the login screen.\n\t */\n\tasync deleteDb(userId: string): Promise<void> {\n\t\tlog.debug(TAG, `Deleting db for user ${userId}`)\n\t\tawait this.disposeDb(userId)\n\t\tconst waitUntilMax = Date.now() + MAX_WAIT_FOR_DB_CLOSE_MS\n\t\twhile (this.cache.has(userId) && Date.now() < waitUntilMax) {\n\t\t\tlog.debug(`waiting for other windows to close db before deleting it for user ${userId}`)\n\t\t\tawait delay(100)\n\t\t}\n\t\tthis.cache.delete(userId)\n\t\tawait this.offlineDbFactory.delete(userId)\n\t\tlog.debug(TAG, `Deleted db for user ${userId}`)\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" table when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId).\n\t * @param userId the user the mail list that we're locking belongs to\n\t * @param listId the mail list that we want to lock\n\t */\n\tasync lockRangesDbAccess(userId: Id, listId: Id): Promise<void> {\n\t\tconst entry = this.cache.get(userId)\n\t\tif (entry == null) {\n\t\t\t// should not happen because why would we lock a table that we do not hold a ref for.\n\t\t\t// the caller will probably run into a offlineDbClosedError very soon.\n\t\t\tthrow new ProgrammingError(\"tried to lock a db that's not open.\")\n\t\t}\n\t\tif (entry.listIdLocks.get(listId)) {\n\t\t\tawait entry.listIdLocks.get(listId)?.promise\n\t\t\tentry.listIdLocks.set(listId, defer())\n\t\t} else {\n\t\t\tentry.listIdLocks.set(listId, defer())\n\t\t}\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(userId, listId)\".\n\t * @param userId the user the mail list that we're locking belongs to\n\t * @param listId the mail list that we want to unlock\n\t */\n\tasync unlockRangesDbAccess(userId: Id, listId: Id): Promise<void> {\n\t\tconst entry = this.cache.get(userId)\n\t\tif (entry == null) {\n\t\t\t// should not happen because why would we lock a table that we do not hold a ref for.\n\t\t\t// the caller will probably run into a offlineDbClosedError very soon.\n\t\t\tthrow new ProgrammingError(\"tried to unlock a db that's not open.\")\n\t\t}\n\t\tentry.listIdLocks.get(listId)?.resolve()\n\t\tentry.listIdLocks.delete(listId)\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,MAAM,MAAM;AACZ,MAAM,2BAA2B;IAmBpB,sBAAN,MAA0B;;;;;CAKhC,AAAiB,QAA6B,IAAI;CAElD,YAA6BA,kBAAoC;EAuGjE,KAvG6B;CAAsC;CAEnE,MAAM,cAAcC,QAAYC,OAA6C;EAC5E,IAAIC,QAAgC,KAAK,MAAM,IAAI,OAAO;AAC1D,MAAI,OAAO;AACV,SAAM,WAAW;AACjB,UAAO,MAAM,MAAM;EACnB,OAAM;GACN,MAAM,KAAK,KAAK,iBAAiB,OAAO,QAAQ,MAAM;AACtD,WAAQ;IAAE;IAAI,SAAS;IAAG,aAAa,IAAI;GAAO;AAClD,QAAK,MAAM,IAAI,QAAQ,MAAM;AAC7B,UAAO,MAAM,MAAM;EACnB;CAGD;CASD,MAAM,UAAUF,QAAY;EAC3B,IAAI,QAAQ,KAAK,MAAM,IAAI,OAAO;AAClC,MAAI,SAAS,KACZ;AAED,QAAM,WAAW;AAEjB,MAAI,MAAM,YAAY,GAAG;AACxB,QAAK,MAAM,OAAO,OAAO;GACzB,MAAM,KAAK,MAAM,MAAM;AACvB,SAAM,GAAG,SAAS;AAClB,WAAQ,IAAI,KAAK,iBAAiB,OAAO;EACzC,MACA,SAAQ,IAAI,KAAK,4BAA4B;CAE9C;;;;;;;;;;;;;CAcD,MAAM,SAASG,QAA+B;AAC7C,MAAI,MAAM,MAAM,uBAAuB,OAAO,EAAE;AAChD,QAAM,KAAK,UAAU,OAAO;EAC5B,MAAM,eAAe,KAAK,KAAK,GAAG;AAClC,SAAO,KAAK,MAAM,IAAI,OAAO,IAAI,KAAK,KAAK,GAAG,cAAc;AAC3D,OAAI,OAAO,oEAAoE,OAAO,EAAE;AACxF,SAAM,MAAM,IAAI;EAChB;AACD,OAAK,MAAM,OAAO,OAAO;AACzB,QAAM,KAAK,iBAAiB,OAAO,OAAO;AAC1C,MAAI,MAAM,MAAM,sBAAsB,OAAO,EAAE;CAC/C;;;;;;;CAQD,MAAM,mBAAmBH,QAAYI,QAA2B;EAC/D,MAAM,QAAQ,KAAK,MAAM,IAAI,OAAO;AACpC,MAAI,SAAS,KAGZ,OAAM,IAAI,iBAAiB;AAE5B,MAAI,MAAM,YAAY,IAAI,OAAO,EAAE;AAClC,SAAM,MAAM,YAAY,IAAI,OAAO,EAAE;AACrC,SAAM,YAAY,IAAI,QAAQ,OAAO,CAAC;EACtC,MACA,OAAM,YAAY,IAAI,QAAQ,OAAO,CAAC;CAEvC;;;;;;CAOD,MAAM,qBAAqBJ,QAAYI,QAA2B;EACjE,MAAM,QAAQ,KAAK,MAAM,IAAI,OAAO;AACpC,MAAI,SAAS,KAGZ,OAAM,IAAI,iBAAiB;AAE5B,QAAM,YAAY,IAAI,OAAO,EAAE,SAAS;AACxC,QAAM,YAAY,OAAO,OAAO;CAChC;AACD"}