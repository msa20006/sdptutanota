
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`

//#region ../packages/otest/dist/fancy.js
const ansiSequences = Object.freeze({
	redFg: "\x1B[31m",
	greenBg: "\x1B[42m",
	redBg: "\x1B[41m",
	yellowBg: "\x1B[43m",
	reset: "\x1B[0m",
	bold: "\x1B[0;1m",
	faint: "\x1B[0;2m"
});
function fancy(text, code) {
	if (typeof process !== "undefined" && process.stdout.isTTY) return `${code}${text}${ansiSequences.reset}`;
else return text;
}

//#endregion
//#region ../packages/otest/dist/Assertion.js
let asString;
if (typeof process !== "undefined") {
	const { inspect } = await import("node:util");
	asString = function(thing) {
		return inspect(thing, { depth: 5 });
	};
} else asString = function(thing) {
	return JSON.stringify(thing);
};
var Assertion = class {
	actual;
	testResult;
	constructor(actual, testResult) {
		this.actual = actual;
		this.testResult = testResult;
	}
	/**
	* Verify that two items are deeply equal.
	* For arrays length and each element must be deeply equal.
	* For objects the key sets must match and each property must be deeply equal.
	*/
	deepEquals(expected) {
		if (!deepEqual(this.actual, expected)) return this.addError(`expected "${asString(this.actual)}" to be deep equal to "${asString(expected)}"`);
		return noop;
	}
	/**
	* Verify that two items are referentially equal.
	*/
	equals(expected) {
		if (this.actual !== expected) return this.addError(`expected "${asString(this.actual)}" to be equal to "${asString(expected)}"`);
		return noop;
	}
	/** {@see deepEquals} */
	notDeepEquals(value) {
		if (deepEqual(this.actual, value)) return this.addError(`expected to "${asString(this.actual)}" NOT deep equal to "${asString(value)}"`);
		return noop;
	}
	/** {@see equals} */
	notEquals(value) {
		if (this.actual === value) return this.addError(`expected "${asString(this.actual)}" to NOT be equal to "${asString(value)}"`);
		return noop;
	}
	/**
	* Verify that the value satisfies the {@param check}.
	*/
	satisfies(check) {
		const result = check(this.actual);
		if (!result.pass) return this.addError(`expected "${asString(this.actual)}" to satisfy condition: "${result.message}"`);
		return noop;
	}
	/**
	* Same as {@link satisfies} but the check function is async.
	*/
	async asyncSatisfies(check) {
		const result = await check(this.actual);
		if (!result.pass) return this.addError(`expected "${asString(this.actual)}" to satisfy condition: "${result.message}"`);
		return noop;
	}
	/** {@see satisfies} */
	notSatisfies(check) {
		const result = check(this.actual);
		if (result.pass) return this.addError(`expected "${asString(this.actual)}" to NOT satisfy condition: "${result.message}"`);
		return noop;
	}
	/**
	* Verify that the value returned by the subject function matches the description.
	* In case of a string description the message is matched, otherwise the error is checked by instanceof.
	*/
	throws(errorDescription) {
		if (typeof this.actual !== "function") throw new Error(`Value for throws() call is not a function! ${errorDescription}`);
		try {
			this.actual();
			return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but nothing was thrown`);
		} catch (e) {
			if (errorMatchesDescription(e, errorDescription)) return noop;
else return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but instead was thrown: ${this.errorName(e)}`);
		}
	}
	/**
	* Verity that the value returned by the subject function matches the description.
	* In case of a string description the message is matched, otherwise the error is checked by instanceof.
	*/
	async asyncThrows(errorDescription) {
		if (typeof this.actual !== "function") throw new Error(`Value for throws() call is not a function! ${errorDescription}`);
		try {
			await this.actual();
			return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but nothing was thrown`);
		} catch (e) {
			if (errorMatchesDescription(e, errorDescription)) return noop;
else return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but instead was thrown: ${this.errorName(e)}`);
		}
	}
	addError(assertionDescription) {
		const testError = {
			error: new AssertionError(assertionDescription),
			userMessage: null
		};
		this.testResult.errors.push(testError);
		return (userMessage) => {
			testError.userMessage = userMessage;
		};
	}
	errorName(error) {
		return typeof error === "string" ? error : typeof error === "function" ? error.name : String(error);
	}
};
/**
* modified deepEquals from ospec is only needed as long as we use custom classes (TypeRef) and Date is not properly handled
*/
function deepEqual(a, b) {
	if (a === b) return true;
	if (xor(a === null, b === null) || xor(a === undefined, b === undefined)) return false;
	if (typeof a === "object" && typeof b === "object") {
		const aIsArgs = isArguments(a), bIsArgs = isArguments(b);
		if (a.length === b.length && (a instanceof Array && b instanceof Array || aIsArgs && bIsArgs)) {
			const aKeys = Object.getOwnPropertyNames(a), bKeys = Object.getOwnPropertyNames(b);
			if (aKeys.length !== bKeys.length) return false;
			for (let i = 0; i < aKeys.length; i++) if (!Object.hasOwn(b, aKeys[i]) || !deepEqual(a[aKeys[i]], b[aKeys[i]])) return false;
			return true;
		}
		if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
		if (a instanceof Uint8Array && b instanceof Uint8Array) {
			if (a.length != b.length) return false;
			for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
			return true;
		}
		if (a instanceof Object && b instanceof Object && !aIsArgs && !bIsArgs) {
			for (let i in a) if (!(i in b) || !deepEqual(a[i], b[i])) return false;
			for (let i in b) if (!(i in a)) return false;
			return true;
		}
		if (typeof Buffer === "function" && a instanceof Buffer && b instanceof Buffer) {
			if (a.length != b.length) return false;
			for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
			return true;
		}
		if (a.valueOf() === b.valueOf()) return true;
	}
	return false;
}
var AssertionError = class extends Error {};
function xor(a, b) {
	return a && !b || b && !a;
}
function isArguments(a) {
	if ("callee" in a) {
		for (const i in a) if (i === "callee") return false;
		return true;
	}
}
function errorMatchesDescription(e, errorDescription) {
	if (e == null) return false;
	const erased = e;
	return typeof errorDescription === "string" && typeof erased.message === "string" && erased.message === errorDescription || e instanceof errorDescription;
}
function noop() {}

//#endregion
//#region ../packages/otest/dist/otest.js
var OTest = class OTest {
	static DEFAULT_TIMEOUT_MS = 200;
	taskTree = {
		name: "O",
		specs: [],
		tests: [],
		before: [],
		after: [],
		beforeEach: [],
		afterEach: []
	};
	currentSpec = this.taskTree;
	currentTest = null;
	/**
	* Define a group of tests.
	* Spec may contain:
	*  * tests
	*  * before/beforeEach/after/afterEach clauses
	*  * other specs
	*
	*  Example:
	*  ```ts
	*  o.spec("testableFunction", () => {
	*      o.test("it works", () => {
	*          o.check(testableFunction(1)).equals(2)
	*      })
	*  })
	*  ```
	*/
	spec(name, definition) {
		const previousCurrentSpec = this.currentSpec;
		const newSpec = this.currentSpec = {
			name,
			tests: [],
			specs: [],
			before: [],
			after: [],
			beforeEach: [],
			afterEach: []
		};
		Object.defineProperty(definition, "name", {
			value: name,
			writable: false
		});
		const definitionResult = definition();
		if (typeof definitionResult !== "undefined") throw new Error(`Invalid spec definition for "${previousCurrentSpec.name} > ${name}"! Is it async by any chance?`);
		this.currentSpec = previousCurrentSpec;
		this.currentSpec.specs.push(newSpec);
	}
	/**
	* Define a test.
	* Tests may be async in which case they should either await or return a promise.
	* Timeouts apply and can be changed with {@link timeout}.
	*/
	test(name, definition) {
		Object.defineProperty(definition, "name", {
			value: name,
			writable: false
		});
		this.currentSpec.tests.push({
			name,
			task: definition
		});
	}
	/**
	* Start an assertion.
	*/
	check(value) {
		if (this.currentTest == null) throw new Error("Assertion outside of running test!");
		return new Assertion(value, this.currentTest);
	}
	/**
	* Define a task to be executed before any test in the spec (once per spec).
	*/
	before(task) {
		this.currentSpec.before.push(task);
	}
	/**
	* Define a task to be executed after all test in the spec (once per spec).
	*/
	after(task) {
		this.currentSpec.after.push(task);
	}
	/**
	* Define a task to be executed before each test in the spec (once per test).
	* Also applies to tests in nested specs.
	*/
	beforeEach(task) {
		this.currentSpec.beforeEach.push(task);
	}
	/**
	* Define a task to be executed after each test in the spec (once per test).
	* Also applies to tests in nested specs.
	*/
	afterEach(task) {
		this.currentSpec.afterEach.push(task);
	}
	/**
	* Set a timeout (in ms) for the currently running test.
	*/
	timeout(ms) {
		if (this.currentTest === null) throw new Error("timeout() call outside of test");
else if (this.currentTest.timeout != null) throw new Error(`timeout is already set! ${this.currentTest}`);
else this.currentTest.timeout = ms;
	}
	/**
	* Run the tests that were previously defined.
	* @param {string} filter: only run tests that match the filter string in either spec name or a test name.
	*/
	async run({ filter } = {}) {
		const runResult = {
			passedTests: [],
			failingTests: [],
			skippedTests: []
		};
		function processSpecResult(spec, path) {
			const pathNames = path.map((s) => s.name).concat(spec.name);
			for (const test of spec.testResults) if (test.errors.length) runResult.failingTests.push({
				path: pathNames,
				result: test
			});
else if (test.skipped) runResult.skippedTests.push({
				path: pathNames,
				result: test
			});
else runResult.passedTests.push({
				path: pathNames,
				result: test
			});
			for (const subspec of spec.specResults) processSpecResult(subspec, [...path, spec]);
		}
		const topSpecResult = await this.runSpec(this.currentSpec, [], filter ?? "");
		processSpecResult(topSpecResult, []);
		return runResult;
	}
	async runSpec(spec, path, filter) {
		const newPath = [...path, spec];
		const newPathSerialized = newPath.map((s) => s.name).join(" > ");
		let printSpecOnce = () => {
			printSpecOnce = () => {};
			console.log(fancy("SPEC", ansiSequences.greenBg), newPathSerialized);
		};
		for (const before of spec.before) try {
			await before();
		} catch (e) {
			console.error("Spec before() failed!", newPathSerialized, e);
			throw e;
		}
		const specMatches = filter === "" || spec.name.includes(filter);
		const result = {
			name: spec.name,
			specResults: await promiseMap(spec.specs, (nestedSpec) => this.runSpec(nestedSpec, newPath, specMatches ? "" : filter)),
			testResults: await promiseMap(spec.tests, async (test) => {
				if (specMatches || test.name.includes(filter)) {
					printSpecOnce();
					printSpecOnce = () => {};
					const allBeforeEach = [...path.flatMap((s) => s.beforeEach), ...spec.beforeEach];
					for (const beforeEach of allBeforeEach) await beforeEach();
					console.log("  ", fancy("TEST", ansiSequences.greenBg), test.name);
					const testResult = await this.runTest(test);
					const allAfterEach = [...path.flatMap((s) => s.afterEach), ...spec.afterEach];
					for (const afterEach of allAfterEach) await afterEach();
					return testResult;
				} else return {
					name: test.name,
					errors: [],
					timeout: null,
					skipped: true
				};
			})
		};
		for (const after of spec.after) try {
			await after();
		} catch (e) {
			console.error("Spec after() failed!", newPathSerialized, e);
			throw e;
		}
		return result;
	}
	/**
	* Output the result of the test run.
	* @param result
	*/
	printReport(result) {
		console.log(`

${fancy("TEST FINISHED", ansiSequences.bold)}

${result.filter ? `filter: "${result.filter}"` : ""}

${fancy("passing", ansiSequences.greenBg)}: ${result.passedTests.length} ${fancy("failing", ansiSequences.redBg)}: ${result.failingTests.length} ${fancy("skipped", ansiSequences.yellowBg)}: ${result.skippedTests.length}`, "\n");
		for (const test of result.failingTests) {
			console.error(fancy("FAIL", ansiSequences.redBg), test.path.join(" > "), "|", test.result.name);
			for (const error of test.result.errors) {
				if (error.userMessage) console.error(fancy(error.userMessage, ansiSequences.redFg));
				console.error(error.error);
				console.log();
			}
		}
	}
	/**
	* A utility to exit the process with the appropriate exit code.
	* only runs in node, no-op otherwise.
	*/
	terminateProcess(result) {
		if (typeof process !== "undefined") process.exit(result.failingTests.length ? 1 : 0);
	}
	async runTest(test) {
		const currentTestResult = this.currentTest = {
			name: test.name,
			errors: [],
			timeout: null,
			skipped: false
		};
		let testResolved = false;
		async function startTimeoutTask() {
			await new Promise((resolve) => {
				if (currentTestResult.timeout == null) throw new Error("timeout not set while running timeout task!");
				setTimeout(resolve, currentTestResult.timeout);
			});
			if (!testResolved) throw new Error("timed out!");
		}
		async function runTask() {
			try {
				const p = test.task();
				currentTestResult.timeout = currentTestResult.timeout ?? OTest.DEFAULT_TIMEOUT_MS;
				await p;
			} finally {
				testResolved = true;
			}
		}
		try {
			await Promise.race([runTask(), startTimeoutTask()]);
		} catch (e) {
			currentTestResult.errors.push({
				error: wrapError(e),
				userMessage: null
			});
		} finally {
			this.currentTest = null;
		}
		return currentTestResult;
	}
};
function wrapError(e) {
	return e instanceof Error ? e : new Error(String(e));
}
async function promiseMap(array, mapper) {
	const result = [];
	for (const el of array) result.push(await mapper(el));
	return result;
}
const otest = new OTest();
function o(item, definition) {
	const oo = o;
	if (typeof definition === "undefined") return oo.check(item);
else oo.test(item, definition);
}
Object.assign(o, otest);
Object.setPrototypeOf(o, Object.getPrototypeOf(otest));
var otest_default = o;

//#endregion
//#region ../packages/otest/dist/index.js
var dist_default = otest_default;

//#endregion
export { dist_default, otest_default };
//# sourceMappingURL=dist-Ci1bEzYU.js.map