{"version":3,"file":"DesktopKeyStoreFacadeTest-WEJhc16R.js","names":["DeviceKeySpec: NativeKeySpec","CredentialsKeySpec: NativeKeySpec","secretStorage: SecretStorage","crypto: DesktopNativeCryptoFacade","spec: NativeKeySpec","key: Aes256Key","secretStorage: SecretStorage","crypto: DesktopNativeCryptoFacade","cryptoFacadeSpy: DesktopNativeCryptoFacade","service: string","account: string","password: string"],"sources":["../../src/common/desktop/DesktopKeyStoreFacade.ts","../tests/desktop/DesktopKeyStoreFacadeTest.ts"],"sourcesContent":["import type { SecretStorage } from \"./sse/SecretStorage\"\nimport { DesktopNativeCryptoFacade } from \"./DesktopNativeCryptoFacade\"\nimport { log } from \"./DesktopLog\"\nimport { getFromMap } from \"@tutao/tutanota-utils\"\nimport { Aes256Key, base64ToKey, keyToBase64 } from \"@tutao/tutanota-crypto\"\nimport { DeviceStorageUnavailableError } from \"../api/common/error/DeviceStorageUnavailableError.js\"\nimport { CancelledError } from \"../api/common/error/CancelledError\"\n\ninterface NativeKeySpec {\n\t/**\n\t * This is supposed to be internet service but this is what is usually presented to the user (at least mac os does this).\n\t * One would thing that this would group all the things but in reality permissions are set per-account anyway.\n\t */\n\treadonly serviceName: string\n\t/** This is supposed to be account name but this is usually not shown. */\n\treadonly accountName: string\n\t/** Whether we want to cache the key in memory */\n\treadonly cached: boolean\n}\n\nexport const DeviceKeySpec: NativeKeySpec = Object.freeze({\n\tserviceName: \"tutanota-vault\",\n\taccountName: \"tuta\",\n\tcached: true,\n})\n\nexport const CredentialsKeySpec: NativeKeySpec = Object.freeze({\n\tserviceName: \"tutanota-credentials\",\n\taccountName: \"tutanota-credentials\",\n\t// Credentials key should not be cached, we should ask it every time we operate on credentials (there's already intermediate in web to avoid asking\n\t// too many times)\n\tcached: false,\n})\n\n/** Interface for accessing/generating/caching keys. */\nexport class DesktopKeyStoreFacade {\n\tprivate readonly resolvedKeys: Map<NativeKeySpec, Promise<Aes256Key>> = new Map()\n\n\tconstructor(private readonly secretStorage: SecretStorage, private readonly crypto: DesktopNativeCryptoFacade) {}\n\n\t/**\n\t * get the key used to encrypt alarms and settings\n\t */\n\tasync getDeviceKey(): Promise<Aes256Key> {\n\t\t// Device key can be cached\n\t\treturn this.resolveKey(DeviceKeySpec)\n\t}\n\n\t/**\n\t * get the key used to encrypt saved credentials\n\t */\n\tasync getKeyChainKey(): Promise<Aes256Key> {\n\t\treturn this.resolveKey(CredentialsKeySpec)\n\t}\n\n\tprivate resolveKey(spec: NativeKeySpec): Promise<Aes256Key> {\n\t\t// Asking for the same key in parallel easily breaks gnome-keyring so we cache the promise.\n\t\tconst entry = getFromMap(this.resolvedKeys, spec, () => this.fetchOrGenerateKey(spec))\n\n\t\tif (spec.cached) {\n\t\t\t// We only want to cache *successful* promises, otherwise we have no chance to retry.\n\t\t\treturn entry.catch((e) => {\n\t\t\t\tthis.resolvedKeys.delete(spec)\n\t\t\t\tthrow e\n\t\t\t})\n\t\t} else {\n\t\t\t// If we don't want to cache the key we remove it in any case.\n\t\t\treturn entry.finally(() => {\n\t\t\t\tthis.resolvedKeys.delete(spec)\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate async fetchOrGenerateKey(spec: NativeKeySpec): Promise<Aes256Key> {\n\t\tlog.debug(\"resolving key...\", spec.serviceName)\n\t\ttry {\n\t\t\treturn (await this.fetchKey(spec)) ?? (await this.generateAndStoreKey(spec))\n\t\t} catch (e) {\n\t\t\tlog.warn(\"Failed to resolve/generate key: \", spec.serviceName, e)\n\t\t\tif (e instanceof CancelledError) {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t\tthrow new DeviceStorageUnavailableError(\"failed to resolve/generate key\", e)\n\t\t}\n\t}\n\n\tprivate async fetchKey(spec: NativeKeySpec): Promise<Aes256Key | null> {\n\t\tconst base64 = await this.secretStorage.getPassword(spec.serviceName, spec.accountName)\n\n\t\tif (base64 == null) {\n\t\t\treturn null\n\t\t}\n\t\treturn base64ToKey(base64)\n\t}\n\n\tprivate async generateAndStoreKey(spec: NativeKeySpec): Promise<Aes256Key> {\n\t\tlog.warn(`key ${spec.serviceName} not found, generating a new one`)\n\n\t\tconst key: Aes256Key = this.crypto.generateDeviceKey()\n\n\t\tconst base64 = keyToBase64(key)\n\n\t\tawait this.secretStorage.setPassword(spec.serviceName, spec.accountName, base64)\n\t\treturn key\n\t}\n}\n","import o from \"@tutao/otest\"\nimport { CredentialsKeySpec, DesktopKeyStoreFacade, DeviceKeySpec } from \"../../../src/common/desktop/DesktopKeyStoreFacade.js\"\nimport { DesktopNativeCryptoFacade } from \"../../../src/common/desktop/DesktopNativeCryptoFacade.js\"\nimport type { SecretStorage } from \"../../../src/common/desktop/sse/SecretStorage.js\"\nimport { spyify } from \"../nodemocker.js\"\nimport { keyToBase64, uint8ArrayToKey } from \"@tutao/tutanota-crypto\"\nimport { CancelledError } from \"../../../src/common/api/common/error/CancelledError.js\"\nimport { assertThrows } from \"@tutao/tutanota-test-utils\"\nimport { DeviceStorageUnavailableError } from \"../../../src/common/api/common/error/DeviceStorageUnavailableError.js\"\n\nfunction initKeyStoreFacade(secretStorage: SecretStorage, crypto: DesktopNativeCryptoFacade): DesktopKeyStoreFacade {\n\treturn new DesktopKeyStoreFacade(secretStorage, crypto)\n}\n\no.spec(\"DesktopKeyStoreFacade\", function () {\n\tconst aes256Key = uint8ArrayToKey(new Uint8Array([1, 2]))\n\tlet cryptoFacadeSpy: DesktopNativeCryptoFacade\n\n\to.beforeEach(function () {\n\t\tconst stub = { generateDeviceKey: () => uint8ArrayToKey(new Uint8Array([0, 0])) } as DesktopNativeCryptoFacade\n\t\tcryptoFacadeSpy = spyify(stub)\n\t})\n\n\tconst toSpec = {\n\t\tgetDeviceKey: DeviceKeySpec,\n\t\tgetKeyChainKey: CredentialsKeySpec,\n\t}\n\n\tfor (const [opName, spec] of Object.entries(toSpec)) {\n\t\to.spec(opName, function () {\n\t\t\to(opName + \" should return stored key\", async function () {\n\t\t\t\tconst secretStorageSpy = spyify<SecretStorage>({\n\t\t\t\t\tasync getPassword(service: string, account: string): Promise<string | null> {\n\t\t\t\t\t\treturn keyToBase64(aes256Key)\n\t\t\t\t\t},\n\n\t\t\t\t\tasync setPassword(service: string, account: string, password: string): Promise<void> {},\n\t\t\t\t})\n\t\t\t\tconst keyStoreFacade = initKeyStoreFacade(secretStorageSpy, cryptoFacadeSpy)\n\t\t\t\tconst actualKey = await keyStoreFacade[opName]()\n\t\t\t\to(actualKey).deepEquals(aes256Key)\n\t\t\t\to(secretStorageSpy.getPassword.callCount).equals(1)\n\t\t\t\to(secretStorageSpy.getPassword.calls[0]).deepEquals([spec.serviceName, spec.accountName])\n\t\t\t})\n\n\t\t\to(\"should store the key\", async function () {\n\t\t\t\tconst secretStorageSpy = spyify<SecretStorage>({\n\t\t\t\t\tasync getPassword(service: string, account: string): Promise<string | null> {\n\t\t\t\t\t\treturn null\n\t\t\t\t\t},\n\n\t\t\t\t\tasync setPassword(service: string, account: string, password: string): Promise<void> {},\n\t\t\t\t})\n\t\t\t\tcryptoFacadeSpy = {\n\t\t\t\t\tgenerateDeviceKey() {\n\t\t\t\t\t\treturn aes256Key\n\t\t\t\t\t},\n\t\t\t\t} as DesktopNativeCryptoFacade\n\t\t\t\tconst keyStoreFacade = initKeyStoreFacade(secretStorageSpy, cryptoFacadeSpy)\n\t\t\t\tawait keyStoreFacade[opName]()\n\t\t\t\to(secretStorageSpy.setPassword.args).deepEquals([spec.serviceName, spec.accountName, keyToBase64(aes256Key)])\n\t\t\t})\n\n\t\t\to(spec.cached ? opName + \" should cache successful key fetch\" : opName + \" should NOT cache successful key fetch\", async function () {\n\t\t\t\tconst secretStorageSpy = spyify<SecretStorage>({\n\t\t\t\t\tasync getPassword(service: string, account: string): Promise<string | null> {\n\t\t\t\t\t\treturn keyToBase64(aes256Key)\n\t\t\t\t\t},\n\n\t\t\t\t\tasync setPassword(service: string, account: string, password: string): Promise<void> {},\n\t\t\t\t})\n\t\t\t\tconst keyStoreFacade = initKeyStoreFacade(secretStorageSpy, cryptoFacadeSpy)\n\t\t\t\tconst actualKey = await keyStoreFacade[opName]()\n\t\t\t\to(actualKey).deepEquals(aes256Key)\n\n\t\t\t\tconst actualKey2 = await keyStoreFacade[opName]()\n\t\t\t\to(actualKey2).deepEquals(aes256Key)\n\t\t\t\tif (spec.cached) {\n\t\t\t\t\to(secretStorageSpy.getPassword.callCount).equals(1)\n\t\t\t\t\to(secretStorageSpy.getPassword.calls[0]).deepEquals([spec.serviceName, spec.accountName])\n\t\t\t\t} else {\n\t\t\t\t\to(secretStorageSpy.getPassword.callCount).equals(2)\n\t\t\t\t\to(secretStorageSpy.getPassword.calls[1]).deepEquals([spec.serviceName, spec.accountName])\n\t\t\t\t}\n\t\t\t})\n\n\t\t\to(opName + \" should not cache failures\", async function () {\n\t\t\t\tlet calls = 0\n\t\t\t\tconst secretStorageSpy = spyify<SecretStorage>({\n\t\t\t\t\tasync getPassword(service: string, account: string): Promise<string | null> {\n\t\t\t\t\t\tif (calls == 0) {\n\t\t\t\t\t\t\tcalls++\n\t\t\t\t\t\t\tthrow new CancelledError(\"Test\")\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcalls++\n\t\t\t\t\t\t\treturn keyToBase64(aes256Key)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tasync setPassword(service: string, account: string, password: string): Promise<void> {},\n\t\t\t\t})\n\n\t\t\t\tconst keyStoreFacade = initKeyStoreFacade(secretStorageSpy, cryptoFacadeSpy)\n\t\t\t\tawait assertThrows(CancelledError, () => keyStoreFacade[opName]())\n\n\t\t\t\tconst actualKey = await keyStoreFacade[opName]()\n\t\t\t\to(actualKey).deepEquals(aes256Key)\n\n\t\t\t\to(secretStorageSpy.getPassword.callCount).equals(2)\n\t\t\t\to(secretStorageSpy.getPassword.calls[1]).deepEquals([spec.serviceName, spec.accountName])\n\t\t\t})\n\t\t})\n\t}\n\n\to.spec(\"key storage errors get propagated properly\", function () {\n\t\tasync function testErrorWrapping({ onget, onset, expectError }) {\n\t\t\tconst secretStorageSpy = spyify<SecretStorage>({\n\t\t\t\tasync getPassword(service: string, account: string): Promise<string | null> {\n\t\t\t\t\treturn onget()\n\t\t\t\t},\n\t\t\t\tasync setPassword(service: string, account: string, password: string): Promise<void> {\n\t\t\t\t\treturn onset()\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tconst keyStoreFacade = initKeyStoreFacade(secretStorageSpy, cryptoFacadeSpy)\n\t\t\tawait assertThrows(expectError, () => keyStoreFacade.getDeviceKey())\n\t\t}\n\n\t\to(\"CancelledError passes through for getPassword\", async function () {\n\t\t\tawait testErrorWrapping({\n\t\t\t\tonget: () => {\n\t\t\t\t\tthrow new CancelledError(\"getting\")\n\t\t\t\t},\n\t\t\t\tonset: () => {},\n\t\t\t\texpectError: CancelledError,\n\t\t\t})\n\t\t})\n\n\t\to(\"CancelledError passes through for setPassword\", async function () {\n\t\t\tawait testErrorWrapping({\n\t\t\t\tonget: () => null,\n\t\t\t\tonset: () => {\n\t\t\t\t\tthrow new CancelledError(\"setting\")\n\t\t\t\t},\n\t\t\t\texpectError: CancelledError,\n\t\t\t})\n\t\t})\n\n\t\to(\"other errors get wrapped for getPassword\", async function () {\n\t\t\tawait testErrorWrapping({\n\t\t\t\tonget: () => {\n\t\t\t\t\tthrow new Error(\"random get failure\")\n\t\t\t\t},\n\t\t\t\tonset: () => {},\n\t\t\t\texpectError: DeviceStorageUnavailableError,\n\t\t\t})\n\t\t})\n\n\t\to(\"other errors get wrapped for setPassword\", async function () {\n\t\t\tawait testErrorWrapping({\n\t\t\t\tonget: () => null,\n\t\t\t\tonset: () => {\n\t\t\t\t\tthrow new Error(\"random set failure\")\n\t\t\t\t},\n\t\t\t\texpectError: DeviceStorageUnavailableError,\n\t\t\t})\n\t\t})\n\t})\n})\n"],"mappings":"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"}