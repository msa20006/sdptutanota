
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, downcast, first, mapAndFilterNull, neverNull, ofClass } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import { assertMainOrNode, getApiBaseUrl, isDesktop } from "./Env-D5xGlXfw.js";
import { getWhitelabelCustomizations } from "./WhitelabelCustomizations-D1L5qbZi.js";
import "./ClientDetector-D0v6Vqu6.js";
import { AccountType, FeatureType, GroupType, LegacyPlans, OperationType, PlanType } from "./TutanotaConstants-3bwAESYA.js";
import { NotFoundError } from "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import { elementIdPart, isSameId, listIdPart } from "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import { TutanotaPropertiesTypeRef, UserSettingsGroupRootTypeRef, createUserSettingsGroupRoot } from "./TypeRefs-CR3TLWn0.js";
import { typeModels$4 as typeModels } from "./TypeModels-BktRFNDN.js";
import { AccountingInfoTypeRef, CustomerInfoTypeRef, CustomerPropertiesTypeRef, CustomerTypeRef, GroupInfoTypeRef, UserTypeRef, WhitelabelConfigTypeRef, createCloseSessionServicePost } from "./TypeRefs-BP1jvX9p.js";
import { MediaType } from "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./SetupMultipleError-B6uY8P-x.js";
import { CloseSessionService, PlanService } from "./Services-CZFE0084.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import "./ErrorHandler-DbW1lJbv.js";
import { SessionType } from "./SessionType-rxSDsswH.js";
import { isCustomizationEnabledForCustomer } from "./CustomerUtils-DmaZpb7Y.js";
import { isGlobalAdmin, isInternalUser } from "./UserUtils-C4O25CeW.js";
import "./EventQueue-c-5UmjJa.js";
import { CacheMode } from "./EntityRestClient--6dT7ZRF.js";
import "./MessageDispatcher-wJwFhXWv.js";
import "./SqlValue-CkGu32Qd.js";
import "./Sql-C9YhYNym.js";

//#region ../src/common/api/main/UserController.ts
assertMainOrNode();
var UserController = class {
	planConfig;
	constructor(user, _userGroupInfo, sessionId, _props, accessToken, _userSettingsGroupRoot, sessionType, loginUsername, entityClient, serviceExecutor) {
		this.user = user;
		this._userGroupInfo = _userGroupInfo;
		this.sessionId = sessionId;
		this._props = _props;
		this.accessToken = accessToken;
		this._userSettingsGroupRoot = _userSettingsGroupRoot;
		this.sessionType = sessionType;
		this.loginUsername = loginUsername;
		this.entityClient = entityClient;
		this.serviceExecutor = serviceExecutor;
		this.planConfig = null;
	}
	get userId() {
		return this.user._id;
	}
	get props() {
		return this._props;
	}
	get userGroupInfo() {
		return this._userGroupInfo;
	}
	get userSettingsGroupRoot() {
		return this._userSettingsGroupRoot;
	}
	/**
	* Checks if the current user is an admin of the customer.
	* @return True if the user is an admin
	*/
	isGlobalAdmin() {
		return isGlobalAdmin(this.user);
	}
	/**
	* Checks if the account type of the logged-in user is FREE.
	* @returns True if the account type is FREE otherwise false
	*/
	isFreeAccount() {
		return this.user.accountType === AccountType.FREE;
	}
	isPremiumAccount() {
		return this.user.accountType === AccountType.PAID;
	}
	/**
	* Provides the information if an internal user is logged in.
	* @return True if an internal user is logged in, false if no user or an external user is logged in.
	*/
	isInternalUser() {
		return isInternalUser(this.user);
	}
	loadCustomer(cacheMode = CacheMode.ReadAndWrite) {
		return this.entityClient.load(CustomerTypeRef, assertNotNull(this.user.customer), { cacheMode });
	}
	async loadCustomerInfo() {
		const customer = await this.loadCustomer();
		return await this.entityClient.load(CustomerInfoTypeRef, customer.customerInfo);
	}
	async loadCustomerProperties() {
		const customer = await this.loadCustomer();
		return await this.entityClient.load(CustomerPropertiesTypeRef, assertNotNull(customer.properties));
	}
	async getPlanType() {
		const customerInfo = await this.loadCustomerInfo();
		return downcast(customerInfo.plan);
	}
	async getPlanConfig() {
		if (this.planConfig === null) {
			const planServiceGetOut = await this.serviceExecutor.get(PlanService, null);
			this.planConfig = planServiceGetOut.config;
		}
		return downcast(this.planConfig);
	}
	isLegacyPlan(type) {
		return LegacyPlans.includes(type);
	}
	async isNewPaidPlan() {
		const type = await this.getPlanType();
		return !this.isLegacyPlan(type) && type !== PlanType.Free;
	}
	async useLegacyBookingItem() {
		const customerInfo = await this.loadCustomerInfo();
		const type = downcast(customerInfo.plan);
		return !(this.isLegacyPlan(type) && customerInfo.customPlan == null) && type !== PlanType.Free;
	}
	/**
	* Checks if the current plan allows adding users and groups.
	*/
	async canHaveUsers() {
		const customer = await this.loadCustomer();
		const planType = await this.getPlanType();
		const planConfig = await this.getPlanConfig();
		return this.isLegacyPlan(planType) || planConfig.multiUser || isCustomizationEnabledForCustomer(customer, FeatureType.MultipleUsers);
	}
	async loadAccountingInfo() {
		const customerInfo = await this.loadCustomerInfo();
		return await this.entityClient.load(AccountingInfoTypeRef, customerInfo.accountingInfo);
	}
	getMailGroupMemberships() {
		return this.user.memberships.filter((membership) => membership.groupType === GroupType.Mail);
	}
	getContactGroupMemberships() {
		return this.user.memberships.filter((membership) => membership.groupType === GroupType.Contact);
	}
	getCalendarMemberships() {
		return this.user.memberships.filter((membership) => membership.groupType === GroupType.Calendar);
	}
	getUserMailGroupMembership() {
		return this.getMailGroupMemberships()[0];
	}
	getTemplateMemberships() {
		return this.user.memberships.filter((membership) => membership.groupType === GroupType.Template);
	}
	getContactListMemberships() {
		return this.user.memberships.filter((membership) => membership.groupType === GroupType.ContactList);
	}
	/**
	* Returns true if the given update is an update on the user instance of the logged in user and the update event is sent for the user group.
	* There are two updates for the user instance sent if the logged in user is an admin:, one for the user group and one for the admin group.
	* We only want to process it once, so we skip the admin group update
	*
	* Attention: Modules that act on user updates, e.g. for changed group memberships, need to use this function in their entityEventsReceived listener.
	* Only then it is guaranteed that the user in the user controller has been updated. The update event for the admin group might come first, so if a module
	* reacts on that one the user controller is not updated yet.
	*/
	isUpdateForLoggedInUserInstance(update, eventOwnerGroupId) {
		return update.operation === OperationType.UPDATE && isUpdateForTypeRef(UserTypeRef, update) && isSameId(this.user._id, update.instanceId) && isSameId(this.user.userGroup.group, eventOwnerGroupId);
	}
	async entityEventsReceived(updates, eventOwnerGroupId) {
		for (const update of updates) {
			const { instanceListId, instanceId, operation } = update;
			if (this.isUpdateForLoggedInUserInstance(update, eventOwnerGroupId)) this.user = await this.entityClient.load(UserTypeRef, this.user._id);
else if (operation === OperationType.UPDATE && isUpdateForTypeRef(GroupInfoTypeRef, update) && isSameId(this.userGroupInfo._id, [neverNull(instanceListId), instanceId])) this._userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, this._userGroupInfo._id);
else if (isUpdateForTypeRef(TutanotaPropertiesTypeRef, update) && operation === OperationType.UPDATE) this._props = await this.entityClient.loadRoot(TutanotaPropertiesTypeRef, this.user.userGroup.group);
else if (isUpdateForTypeRef(UserSettingsGroupRootTypeRef, update)) this._userSettingsGroupRoot = await this.entityClient.load(UserSettingsGroupRootTypeRef, this.user.userGroup.group);
else if (isUpdateForTypeRef(CustomerInfoTypeRef, update)) {
				if (operation === OperationType.CREATE) await this.entityClient.load(CustomerInfoTypeRef, [update.instanceListId, update.instanceId]);
				this.planConfig = null;
			}
		}
	}
	/**
	* Delete the session (only if it's a non-persistent session
	* @param sync whether or not to delete in the main thread. For example, will be true when logging out due to closing the tab
	*/
	async deleteSession(sync) {
		if (sync) {
			if (this.sessionType !== SessionType.Persistent) await this.deleteSessionSync();
		} else if (this.sessionType !== SessionType.Persistent) await locator.loginFacade.deleteSession(this.accessToken).catch((e) => console.log("Error ignored on Logout:", e));
	}
	deleteSessionSync() {
		return new Promise((resolve, reject) => {
			const sendBeacon = navigator.sendBeacon;
			if (sendBeacon) try {
				const apiUrl = new URL(getApiBaseUrl(locator.domainConfigProvider().getCurrentDomainConfig()));
				apiUrl.pathname += `/rest/sys/${CloseSessionService.name.toLowerCase()}`;
				const requestObject = createCloseSessionServicePost({
					accessToken: this.accessToken,
					sessionId: this.sessionId
				});
				delete downcast(requestObject)["_type"];
				const queued = sendBeacon.call(navigator, apiUrl, new Blob([JSON.stringify(requestObject)], { type: MediaType.Json }));
				console.log("queued closing session: ", queued);
				resolve();
			} catch (e) {
				console.log("Failed to send beacon", e);
				reject(e);
			}
else {
				const apiUrl = new URL(getApiBaseUrl(locator.domainConfigProvider().getCurrentDomainConfig()));
				apiUrl.pathname += `/rest/sys/session/${listIdPart(this.sessionId)}/${elementIdPart(this.sessionId)}`;
				const xhr = new XMLHttpRequest();
				xhr.open("DELETE", apiUrl, false);
				xhr.setRequestHeader("accessToken", this.accessToken);
				xhr.setRequestHeader("v", typeModels.Session.version);
				xhr.onload = function() {
					if (xhr.status === 200) {
						console.log("deleted session");
						resolve();
					} else if (xhr.status === 401) {
						console.log("authentication failed => session is already deleted");
						resolve();
					} else {
						console.error("could not delete session " + xhr.status);
						reject(new Error("could not delete session " + xhr.status));
					}
				};
				xhr.onerror = function() {
					console.error("failed to request delete session");
					reject(new Error("failed to request delete session"));
				};
				xhr.send();
			}
		});
	}
	async isWhitelabelAccount() {
		if (!isDesktop()) return !!getWhitelabelCustomizations(window);
		const customerInfo = await this.loadCustomerInfo();
		return customerInfo.domainInfos.some((domainInfo) => domainInfo.whitelabelConfig);
	}
	async loadWhitelabelConfig() {
		const customerInfo = await this.loadCustomerInfo();
		const domainInfoAndConfig = first(mapAndFilterNull(customerInfo.domainInfos, (domainInfo) => domainInfo.whitelabelConfig && {
			domainInfo,
			whitelabelConfig: domainInfo.whitelabelConfig
		}));
		if (domainInfoAndConfig) {
			const whitelabelConfig = await locator.entityClient.load(WhitelabelConfigTypeRef, domainInfoAndConfig.whitelabelConfig);
			return {
				domainInfo: domainInfoAndConfig.domainInfo,
				whitelabelConfig
			};
		}
	}
};
async function initUserController({ user, userGroupInfo, sessionId, accessToken, sessionType, loginUsername }) {
	const entityClient = locator.entityClient;
	const [props, userSettingsGroupRoot] = await Promise.all([entityClient.loadRoot(TutanotaPropertiesTypeRef, user.userGroup.group), entityClient.load(UserSettingsGroupRootTypeRef, user.userGroup.group).catch(ofClass(NotFoundError, () => entityClient.setup(null, createUserSettingsGroupRoot({
		_ownerGroup: user.userGroup.group,
		startOfTheWeek: "0",
		timeFormat: "0",
		groupSettings: [],
		usageDataOptedIn: null
	})).then(() => entityClient.load(UserSettingsGroupRootTypeRef, user.userGroup.group))))]);
	return new UserController(user, userGroupInfo, sessionId, props, accessToken, userSettingsGroupRoot, sessionType, loginUsername, entityClient, locator.serviceExecutor);
}

//#endregion
export { initUserController };
//# sourceMappingURL=UserController-9L0-v1kK.js.map