{"version":3,"file":"DbFacade-DYw6Nyfw.js","names":["objectStoreName: ObjectStoreName","e: any","requestErrorEntries: Record<string, any>","version: number","onupgrade: (event: any, db: IDBDatabase, dbFacade: DbFacade) => void","DBOpenRequest: IDBOpenDBRequest","event: IDBVersionChangeEvent","event","id: string","dbId: string","event: ErrorEvent","readOnly: boolean","objectStores: ObjectStoreName[]","transaction: IDBTransaction","onUnknownError: (e: any) => unknown","objectStore: ObjectStoreName","keys: DatabaseEntry[]","key: DbKey","indexName?: IndexName","request: IDBRequest<any>","key: DbKey | null","value: any","event: any","customTarget: any | null","prefix: string","callback: (e: any) => unknown","userId: Id"],"sources":["../../src/common/api/worker/search/DbFacade.ts"],"sourcesContent":["import { DbError } from \"../../common/error/DbError\"\nimport { delay, downcast, LazyLoaded, stringToUtf8Uint8Array, uint8ArrayToBase64 } from \"@tutao/tutanota-utils\"\nimport { IndexingNotSupportedError } from \"../../common/error/IndexingNotSupportedError\"\nimport { QuotaExceededError } from \"../../common/error/QuotaExceededError\"\nimport { sha256Hash } from \"@tutao/tutanota-crypto\"\nimport { IndexName, ObjectStoreName } from \"./IndexTables.js\"\n\nexport const osName = (objectStoreName: ObjectStoreName): string => objectStoreName\nexport type DbKey = string | number | Uint8Array\nexport type DatabaseEntry = {\n\tkey: DbKey\n\tvalue: any\n}\n\nexport interface DbTransaction {\n\tgetAll(objectStore: ObjectStoreName): Promise<Array<DatabaseEntry>>\n\n\tget<T = any>(objectStore: ObjectStoreName, key: DbKey, indexName?: IndexName): Promise<T | null>\n\n\tgetAsList<T = any>(objectStore: ObjectStoreName, key: DbKey, indexName?: IndexName): Promise<T[]>\n\n\tput(objectStore: ObjectStoreName, key: DbKey | null, value: any): Promise<any>\n\n\tdelete(objectStore: ObjectStoreName, key: DbKey): Promise<void>\n\n\tabort(): void\n\n\twait(): Promise<void>\n\n\taborted: boolean\n}\n\nfunction extractErrorProperties(e: any): string {\n\tconst requestErrorEntries: Record<string, any> = {}\n\n\tfor (let key in e) {\n\t\trequestErrorEntries[key] = e[key]\n\t}\n\n\treturn JSON.stringify(requestErrorEntries)\n}\n\n/** facade to manage a single named indexedDb */\nexport class DbFacade {\n\tprivate _id!: string\n\tprivate _db: LazyLoaded<IDBDatabase>\n\tprivate _activeTransactions: number\n\tindexingSupported: boolean = true\n\n\tconstructor(version: number, onupgrade: (event: any, db: IDBDatabase, dbFacade: DbFacade) => void) {\n\t\tthis._activeTransactions = 0\n\t\tthis._db = new LazyLoaded(() => {\n\t\t\tif (!this.indexingSupported) {\n\t\t\t\treturn Promise.reject(new IndexingNotSupportedError(\"indexedDB not supported\"))\n\t\t\t} else {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tlet DBOpenRequest: IDBOpenDBRequest\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDBOpenRequest = self.indexedDB.open(this._id, version)\n\n\t\t\t\t\t\tDBOpenRequest.onerror = (event) => {\n\t\t\t\t\t\t\tconst target = event.target\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tconst error = event.target?.error\n\n\t\t\t\t\t\t\t// Copy all the keys from the error, including inheritent ones so we can get some info\n\t\t\t\t\t\t\tconst requestErrorEntries = extractErrorProperties(DBOpenRequest.error)\n\t\t\t\t\t\t\tconst eventProperties = extractErrorProperties(event)\n\t\t\t\t\t\t\tthis.indexingSupported = false\n\t\t\t\t\t\t\tconst message =\n\t\t\t\t\t\t\t\t\"DbFacade.open.onerror: \" +\n\t\t\t\t\t\t\t\tthis._id +\n\t\t\t\t\t\t\t\t\"\\nrequest.error: \" +\n\t\t\t\t\t\t\t\trequestErrorEntries +\n\t\t\t\t\t\t\t\t\"\\nevent: \" +\n\t\t\t\t\t\t\t\teventProperties +\n\t\t\t\t\t\t\t\t\"\\nevent.target.error: \" +\n\t\t\t\t\t\t\t\t(error ?? \"[none]\")\n\n\t\t\t\t\t\t\tif (error?.name === \"QuotaExceededError\") {\n\t\t\t\t\t\t\t\tconsole.log(\"Storage Quota is exceeded\")\n\t\t\t\t\t\t\t\treject(new QuotaExceededError(message, DBOpenRequest.error || error))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treject(new IndexingNotSupportedError(message, DBOpenRequest.error || error))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tDBOpenRequest.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n\t\t\t\t\t\t\t//console.log(\"upgrade db\", event)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\tonupgrade(event, event.target.result, this)\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treject(new DbError(\"could not create object store for DB \" + this._id, e))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tDBOpenRequest.onsuccess = (event) => {\n\t\t\t\t\t\t\t//console.log(\"opened db\", event)\n\t\t\t\t\t\t\tDBOpenRequest.result.onabort = (event) => console.log(\"db aborted\", event)\n\n\t\t\t\t\t\t\tDBOpenRequest.result.onclose = (event) => {\n\t\t\t\t\t\t\t\tconsole.log(\"db closed\", event)\n\n\t\t\t\t\t\t\t\tthis._db.reset()\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tDBOpenRequest.result.onerror = (event) => console.log(\"db error\", event)\n\n\t\t\t\t\t\t\tresolve(DBOpenRequest.result)\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis.indexingSupported = false\n\t\t\t\t\t\treject(new IndexingNotSupportedError(`exception when accessing indexeddb ${this._id}`, e))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\tasync open(id: string): Promise<void> {\n\t\tthis._id = id\n\t\tawait this._db.getAsync()\n\t}\n\n\tisSameDbId(dbId: string): boolean {\n\t\treturn this._id === dbId\n\t}\n\n\t/**\n\t * Closes the db if it's open and deletes it.\n\t */\n\tdeleteDatabase(id: string): Promise<void> {\n\t\tconst ensureDbIsClosed = (): Promise<void> => {\n\t\t\tif (this._db.isLoaded()) {\n\t\t\t\tif (this._activeTransactions > 0) {\n\t\t\t\t\treturn delay(150).then(ensureDbIsClosed)\n\t\t\t\t} else {\n\t\t\t\t\tthis._db.getLoaded().close()\n\t\t\t\t\treturn Promise.resolve()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve()\n\t\t\t}\n\t\t}\n\n\t\treturn ensureDbIsClosed()\n\t\t\t.then(() => DbFacade.deleteDb(id))\n\t\t\t.then(() => this._db.reset())\n\t}\n\n\tstatic deleteDb(id: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst deleteRequest = self.indexedDB.deleteDatabase(id)\n\t\t\tdeleteRequest.onerror = (event: ErrorEvent) => reject(new DbError(`could not delete database ${id}`, downcast<Error>(event)))\n\t\t\tdeleteRequest.onsuccess = () => resolve()\n\t\t})\n\t}\n\n\t/**\n\t * @pre open() must have been called before, but the promise does not need to have returned.\n\t */\n\tcreateTransaction(readOnly: boolean, objectStores: ObjectStoreName[]): Promise<DbTransaction> {\n\t\t// WARNING\n\t\t// Do not make this method async because Safari likes to close the transaction if it's not used right away and async somehow influences that.\n\t\t// Would be great if we couldn't even call `createTransaction` without having a database beforehand, then this method could be sync.\n\t\treturn this._db.getAsync().then((db) => {\n\t\t\ttry {\n\t\t\t\tconst idbTransaction = db.transaction(objectStores as string[], readOnly ? \"readonly\" : \"readwrite\")\n\t\t\t\tconst transaction = new IndexedDbTransaction(idbTransaction, () => {\n\t\t\t\t\tthis.indexingSupported = false\n\n\t\t\t\t\tthis._db.reset()\n\t\t\t\t})\n\t\t\t\tthis._activeTransactions++\n\t\t\t\ttransaction.wait().finally(() => {\n\t\t\t\t\tthis._activeTransactions--\n\t\t\t\t})\n\t\t\t\treturn transaction\n\t\t\t} catch (e) {\n\t\t\t\tthrow new DbError(\"could not create transaction\", e)\n\t\t\t}\n\t\t})\n\t}\n}\n\n/**\n * A transaction is usually committed after all requests placed against the transaction have been executed and their\n * returned results handled, and no new requests have been placed against the transaction.\n * @see https://w3c.github.io/IndexedDB/#ref-for-transaction-finish\n */\nexport class IndexedDbTransaction implements DbTransaction {\n\tprivate readonly _transaction: IDBTransaction\n\tprivate readonly _promise: Promise<void>\n\tprivate readonly _onUnknownError: (e: any) => unknown\n\taborted: boolean = false\n\n\tconstructor(transaction: IDBTransaction, onUnknownError: (e: any) => unknown) {\n\t\tthis._transaction = transaction\n\t\tthis._onUnknownError = onUnknownError\n\t\tthis._promise = new Promise((resolve, reject) => {\n\t\t\tlet done = false\n\n\t\t\ttransaction.onerror = (event) => {\n\t\t\t\tif (!done) {\n\t\t\t\t\tthis._handleDbError(event, this._transaction, \"transaction.onerror\", (e) => {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"ignore error of aborted/fulfilled transaction\", event)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttransaction.oncomplete = () => {\n\t\t\t\tdone = true\n\t\t\t\tresolve()\n\t\t\t}\n\n\t\t\ttransaction.onabort = (event) => {\n\t\t\t\tevent.stopPropagation()\n\t\t\t\tdone = true\n\t\t\t\tresolve()\n\t\t\t}\n\t\t})\n\t}\n\n\tgetAll(objectStore: ObjectStoreName): Promise<Array<DatabaseEntry>> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tlet keys: DatabaseEntry[] = []\n\t\t\t\tlet request = this._transaction.objectStore(objectStore).openCursor()\n\n\t\t\t\trequest.onerror = (event) => {\n\t\t\t\t\tthis._handleDbError(event, request, \"getAll().onError \" + objectStore, reject)\n\t\t\t\t}\n\n\t\t\t\trequest.onsuccess = (event) => {\n\t\t\t\t\tlet cursor = request.result\n\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\tkeys.push({\n\t\t\t\t\t\t\t// @ts-ignore Key can be something crazy like Date or array of keys\n\t\t\t\t\t\t\tkey: cursor.key,\n\t\t\t\t\t\t\tvalue: cursor.value,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tcursor.continue() // onsuccess is called again\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(keys) // cursor has reached the end\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis._handleDbError(e, null, \"getAll().catch\", reject)\n\t\t\t}\n\t\t})\n\t}\n\n\tget<T>(objectStore: ObjectStoreName, key: DbKey, indexName?: IndexName): Promise<T | null> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst os = this._transaction.objectStore(objectStore)\n\n\t\t\t\tlet request: IDBRequest<any>\n\n\t\t\t\tif (indexName) {\n\t\t\t\t\trequest = os.index(indexName).get(key)\n\t\t\t\t} else {\n\t\t\t\t\trequest = os.get(key)\n\t\t\t\t}\n\n\t\t\t\trequest.onerror = (event) => {\n\t\t\t\t\tthis._handleDbError(event, request, \"get().onerror \" + objectStore, reject)\n\t\t\t\t}\n\n\t\t\t\trequest.onsuccess = (event) => {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tresolve(event.target.result)\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis._handleDbError(e, null, \"get().catch\", reject)\n\t\t\t}\n\t\t})\n\t}\n\n\tasync getAsList<T>(objectStore: ObjectStoreName, key: DbKey, indexName?: IndexName): Promise<T[]> {\n\t\tconst result = await this.get<T>(objectStore, key, indexName)\n\t\treturn result ? [result] : []\n\t}\n\n\tput(objectStore: ObjectStoreName, key: DbKey | null, value: any): Promise<any> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tlet request = key ? this._transaction.objectStore(objectStore).put(value, key) : this._transaction.objectStore(objectStore).put(value)\n\n\t\t\t\trequest.onerror = (event) => {\n\t\t\t\t\tthis._handleDbError(event, request, \"put().onerror \" + objectStore, reject)\n\t\t\t\t}\n\n\t\t\t\trequest.onsuccess = (event) => {\n\t\t\t\t\t// event.target.result isn't known by typescript definitions\n\t\t\t\t\t// see: https://github.com/Microsoft/TypeScript/issues/30669\n\t\t\t\t\tresolve((event.target as any).result)\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis._handleDbError(e, null, \"put().catch\", reject)\n\t\t\t}\n\t\t})\n\t}\n\n\tdelete(objectStore: ObjectStoreName, key: DbKey): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tlet request = this._transaction.objectStore(objectStore).delete(key)\n\n\t\t\t\trequest.onerror = (event) => {\n\t\t\t\t\tthis._handleDbError(event, request, \"delete().onerror \" + objectStore, reject)\n\t\t\t\t}\n\n\t\t\t\trequest.onsuccess = (event) => {\n\t\t\t\t\tresolve()\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis._handleDbError(e, null, \".delete().catch \" + objectStore, reject)\n\t\t\t}\n\t\t})\n\t}\n\n\tabort() {\n\t\tthis.aborted = true\n\n\t\tthis._transaction.abort()\n\t}\n\n\twait(): Promise<void> {\n\t\treturn this._promise\n\t}\n\n\t_handleDbError(event: any, customTarget: any | null, prefix: string, callback: (e: any) => unknown) {\n\t\tconst errorEntries = extractErrorProperties(event)\n\t\tconst eventTargetEntries = event.target ? extractErrorProperties(event.target) : \"<null>\"\n\t\tconst eventTargetErrorEntries = event.target && event.target.error ? extractErrorProperties(event.target.error) : \"<null>\"\n\t\tconst customTargetEntries = customTarget ? extractErrorProperties(customTarget) : \"<null>\"\n\t\tconst customTargetErrorEntries = customTarget && customTarget.error ? extractErrorProperties(customTarget.error) : \"<null>\"\n\t\tconst msg =\n\t\t\t\"IndexedDbTransaction \" +\n\t\t\tprefix +\n\t\t\t\"\\nOSes: \" +\n\t\t\tJSON.stringify((this._transaction as any).objectStoreNames) +\n\t\t\t\"\\nevent:\" +\n\t\t\terrorEntries +\n\t\t\t\"\\ntransaction.error: \" +\n\t\t\t(this._transaction.error ? this._transaction.error.message : \"<null>\") +\n\t\t\t\"\\nevent.target: \" +\n\t\t\teventTargetEntries +\n\t\t\t\"\\nevent.target.error: \" +\n\t\t\teventTargetErrorEntries +\n\t\t\t\"\\ncustom.target: \" +\n\t\t\tcustomTargetEntries +\n\t\t\t\"\\ncustom.target.error: \" +\n\t\t\tcustomTargetErrorEntries\n\t\t// In some cases it's not available on Firefox 70\n\t\tif (typeof event.stopPropagation === \"function\") event.stopPropagation()\n\n\t\tif (\n\t\t\tcustomTarget &&\n\t\t\tcustomTarget.error &&\n\t\t\t(customTarget.error.name === \"UnknownError\" ||\n\t\t\t\t(typeof customTarget.error.message === \"string\" && customTarget.error.message.includes(\"UnknownError\")))\n\t\t) {\n\t\t\tthis._onUnknownError(customTarget.error)\n\n\t\t\tcallback(new IndexingNotSupportedError(msg, this._transaction.error ?? undefined))\n\t\t} else {\n\t\t\tconst e = this._transaction.error || (customTarget ? customTarget.error : null)\n\n\t\t\tif (e && e.name && e.name === \"QuotaExceededError\") {\n\t\t\t\tconsole.warn(\"Storage Quota exceeded\")\n\t\t\t\tcallback(new QuotaExceededError(msg, e))\n\t\t\t} else {\n\t\t\t\tcallback(new DbError(msg, e))\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function b64UserIdHash(userId: Id): string {\n\treturn uint8ArrayToBase64(sha256Hash(stringToUtf8Uint8Array(userId)))\n}\n"],"mappings":"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"}