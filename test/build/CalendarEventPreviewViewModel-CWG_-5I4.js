
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { assertNotNull, clone, debounceStart, deepEqual, filterInt, getFirstOrThrow, getStartOfDay, isSameDayOfDate, memoized, noOp } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { isApp } from "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { DefaultAnimationTime, getSafeAreaInsetBottom, getSafeAreaInsetTop, px, size, theme } from "./HtmlUtils-C-ecR7U7.js";
import { client } from "./ClientDetector-D0v6Vqu6.js";
import { AccountType, CalendarAttendeeStatus, EndType, Keys, RepeatPeriod, TabIndex, TimeFormat, defaultCalendarColor } from "./TutanotaConstants-3bwAESYA.js";
import { BaseButton, BootIcons, ButtonColor, ButtonType, Icon, IconSize, getColors } from "./Icon-BuqNK7vz.js";
import { Icons } from "./Icons-Dl3nFav5.js";
import { focusNext, focusPrevious, isKeyPressed, keyboardEventToKeyPress, useKeyHandler } from "./KeyManager-B0OGXEyJ.js";
import "./WindowFacade-B9kSBKw7.js";
import { modal } from "./Modal-g4c-b9IU.js";
import { AriaPopupType, AriaRole, Dialog, DropDownSelector, TextField, TextFieldType, attachDropdown, showDropdown } from "./Dialog-B6-HFvZd.js";
import "./CountryList-DkVQtcTj.js";
import { ButtonSize, IconButton } from "./IconButton-DsU60HJ_.js";
import { NotFoundError } from "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { DateTime } from "./luxon-D6cgmg6Q.js";
import { Time } from "./CalendarEventWhenModel-DEedSoEH.js";
import "./EntityUtils-RQxXZlcV.js";
import { getAllDayDateLocal } from "./CommonCalendarUtils-DKaO7v1K.js";
import { convertTextToHtml, formatDate, formatDateWithWeekdayAndYear, formatMonthWithFullYear, timeStringFromParts } from "./Formatter-zB15D6XI.js";
import "./TypeModels-XIXYys8J.js";
import "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import "./TypeRefs-BP1jvX9p.js";
import { AlarmIntervalUnit, calendarEventHasMoreThanOneOccurrencesLeft, getStartOfTheWeekOffsetForUser, getTimeFormatForUser, parseAlarmInterval } from "./CalendarUtils-C6jeYrj9.js";
import "./ProgressMonitor-HBfOF56H.js";
import "./Notifications-DLibQbV7.js";
import "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./EntityClient-B0RSdk2i.js";
import "./SetupMultipleError-B6uY8P-x.js";
import "./dist-DcZ1Y4qd.js";
import "./Services-CZFE0084.js";
import "./Services-DCx-CeM7.js";
import "./CalendarFacade-CaovxyFN.js";
import "./CalendarModel-DK762b35.js";
import "./EntityUpdateUtils-B5iTKMk4.js";
import { getSharedGroupName } from "./GroupUtils-CpT2lvVS.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import "./ImportExportUtils-B1MoOmZ0.js";
import "./FormatValidator-2BBermUe.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import "./MailAddressParser-BgYy6oyp.js";
import "./GroupUtils-0ZkLIAeC.js";
import "./DataFile-CY7uuk9j.js";
import "./FileUtils-W-u2-gZz.js";
import "./ProgressDialog-CJfJjh62.js";
import "./BlobUtils-D5ADcckZ.js";
import "./SharedMailUtils-AmFaSJP6.js";
import { scaleToVisualPasswordStrength } from "./PasswordUtils-C4jlV9GF.js";
import { RecipientType } from "./Recipient-BFxhfecW.js";
import "./BirthdayUtils-BcCMglSq.js";
import "./ContactUtils-Bbon2oOk.js";
import "./RecipientsModel-DxwXuUvL.js";
import { CalendarOperation, EventSaveResult, EventType, ReadonlyReason, askIfShouldSendCalendarUpdatesToAttendees, createAlarmIntervalItems, createAttendingItems, createCustomEndTypeOptions, createCustomRepeatRuleUnitValues, createIntervalValues, createRepeatRuleOptions, customFrequenciesOptions, getCalendarMonth, getNonOrganizerAttendees, hasPlanWithInvites, humanDescriptionForAlarmInterval, iconForAttendeeStatus } from "./CalendarGuiUtils-CkzhFM1K.js";
import { UpgradeRequiredError } from "./UpgradeRequiredError-CbZr7beN.js";
import "./ColorPickerModel-C1q3CWkL.js";
import "./BannerButton-BeplPQdI.js";
import { showPlanUpgradeRequiredDialog } from "./SubscriptionDialogs-DAlWs68I.js";
import "./ExternalLink-rsCBSC7U.js";
import { formatRepetitionEnd, formatRepetitionFrequency } from "./EventPreviewView-8_o5U-Qy.js";
import { ToggleButton } from "./ToggleButton-DxuDa0rS.js";
import { parseMailAddress, parsePastedInput, parseTypedInput } from "./MailRecipientsTextField-BmI2qlpf.js";
import { IconMessageBox } from "./ColumnEmptyMessageBox-TSIJJX7z.js";
import { parseDate } from "./DateParser-DIjdXKhX.js";
import "./ErrorHandler-DbW1lJbv.js";
import { BannerType, InfoBanner } from "./InfoBanner-CobgB3Oz.js";
import "./SnackBar-CoP3lSVs.js";
import "./Credentials-BM35X_na.js";
import "./NotificationOverlay-C-YNCUiT.js";
import "./Checkbox-WCw-l_7A.js";
import "./Expander-Bautb1_0.js";
import "./ClipboardUtils-mz40UK5S.js";
import "./ErrorReporter-7sfLhWZg.js";
import "./Services-CupYet_j.js";
import "./BubbleButton-DGGInJMg.js";
import "./SessionType-rxSDsswH.js";
import "./PasswordField-CPKPoLq8.js";
import "./PasswordRequestDialog-B7ZIVTVw.js";
import { showUserError } from "./ErrorHandlerImpl-DRpk8tE9.js";
import "./DeviceConfig-payZM407.js";
import "./InAppRatingUtils-DwsFPPTC.js";
import { handleRatingByEvent } from "./InAppRatingDialog-Cp5yqAc1.js";

//#region ../src/common/gui/base/Card.ts
var Card = class {
	view({ attrs, children }) {
		return mithril_default(`${attrs.rootElementType ?? "div"}.tutaui-card-container`, {
			class: attrs.classes?.join(" "),
			style: attrs.style
		}, children);
	}
};

//#endregion
//#region ../src/common/gui/base/Select.ts
var Select = class {
	isExpanded = false;
	dropdownContainer;
	key = 0;
	view({ attrs: { onchange, options, renderOption, renderDisplay, classes, selected, placeholder, expanded, disabled, ariaLabel, iconColor, id, noIcon, keepFocus, tabIndex, onclose, dropdownPosition } }) {
		return mithril_default("button.tutaui-select-trigger.clickable", {
			id,
			class: this.resolveClasses(classes, disabled, expanded),
			onclick: (event) => event.currentTarget && this.renderDropdown(options, event.currentTarget, onchange, renderOption, keepFocus ?? false, selected?.value, onclose, dropdownPosition),
			role: AriaRole.Combobox,
			ariaLabel,
			disabled,
			ariaExpanded: String(this.isExpanded),
			tabIndex: tabIndex ?? Number(disabled ? TabIndex.Programmatic : TabIndex.Default),
			value: selected?.ariaValue
		}, [selected != null ? renderDisplay(selected) : this.renderPlaceholder(placeholder), noIcon !== true ? mithril_default(Icon, {
			icon: BootIcons.Expand,
			container: "div",
			class: `fit-content transition-transform`,
			size: IconSize.Medium,
			style: { fill: iconColor ?? getColors(ButtonColor.Content).button }
		}) : null]);
	}
	resolveClasses(classes = [], disabled = false, expanded = false) {
		const classList = [...classes];
		if (disabled) classList.push("disabled", "click-disabled");
else classList.push("flash");
		if (expanded) classList.push("full-width");
else classList.push("fit-content");
		return classList.join(" ");
	}
	renderPlaceholder(placeholder) {
		if (placeholder == null || typeof placeholder === "string") return mithril_default("span.placeholder", placeholder ?? lang.get("noSelection_msg"));
		return placeholder;
	}
	renderDropdown(options, dom, onSelect, renderOptions, keepFocus, selected, onClose, dropdownPosition) {
		const optionListContainer = new OptionListContainer(options, (option) => {
			return mithril_default.fragment({
				key: ++this.key,
				oncreate: ({ dom: dom$1 }) => this.setupOption(dom$1, onSelect, option, optionListContainer, selected)
			}, [renderOptions(option)]);
		}, dom.getBoundingClientRect().width, keepFocus, dropdownPosition);
		optionListContainer.onClose = () => {
			optionListContainer.close();
			onClose?.();
			this.isExpanded = false;
		};
		optionListContainer.setOrigin(dom.getBoundingClientRect());
		this.isExpanded = true;
		this.dropdownContainer = optionListContainer;
		modal.displayUnique(optionListContainer, false);
	}
	setupOption(dom, onSelect, option, optionListContainer, selected) {
		dom.onclick = this.wrapOnChange.bind(this, onSelect, option, optionListContainer);
		if (!("disabled" in dom)) {
			dom.tabIndex = Number(TabIndex.Default);
			if (!dom.style.cursor) dom.style.cursor = "pointer";
			if (!dom.role) dom.role = AriaRole.Option;
			dom.ariaSelected = `${selected === option.value}`;
		}
		dom.onkeydown = (e) => {
			if (isKeyPressed(e.key, Keys.SPACE, Keys.RETURN)) {
				e.preventDefault();
				this.wrapOnChange(onSelect, option, optionListContainer);
			}
		};
	}
	wrapOnChange(callback, option, container) {
		callback(option);
		container.onClose();
	}
};
var OptionListContainer = class {
	domDropdown = null;
	view;
	origin = null;
	shortcuts;
	width;
	domContents = null;
	maxHeight = null;
	focusedBeforeShown = document.activeElement;
	children = [];
	constructor(items, buildFunction, width, keepFocus, dropdownPosition) {
		this.items = items;
		this.buildFunction = buildFunction;
		this.width = width;
		this.shortcuts = this.buildShortcuts;
		this.items.map((newItems) => {
			this.children = [];
			this.children.push(newItems.length === 0 ? this.renderNoItem() : newItems.map((item) => this.buildFunction(item)));
		});
		this.view = () => {
			return mithril_default(".dropdown-panel-scrollable.elevated-bg.border-radius.dropdown-shadow.fit-content", { oncreate: (vnode) => {
				this.domDropdown = vnode.dom;
				this.domDropdown.style.opacity = "0";
			} }, mithril_default(".dropdown-content.scroll.flex.flex-column", {
				role: AriaRole.Listbox,
				tabindex: TabIndex.Programmatic,
				oncreate: (vnode) => {
					this.domContents = vnode.dom;
				},
				onupdate: (vnode) => {
					if (this.maxHeight == null) {
						const children = Array.from(vnode.dom.children);
						this.maxHeight = Math.min(400 + size.vpad, children.reduce((accumulator, children$1) => accumulator + children$1.offsetHeight, 0) + size.vpad);
						if (this.origin) showDropdown(this.origin, assertNotNull(this.domDropdown), this.maxHeight, this.width, dropdownPosition).then(() => {
							const selectedOption = vnode.dom.querySelector("[aria-selected='true']");
							if (selectedOption && !keepFocus) selectedOption.focus();
else if (!keepFocus && (!this.domDropdown || focusNext(this.domDropdown))) this.domContents?.focus();
						});
					} else this.updateDropdownSize(vnode);
				},
				onscroll: (ev) => {
					const target = ev.target;
					ev.redraw = this.domContents != null && target.scrollTop < 0 && target.scrollTop + this.domContents.offsetHeight > target.scrollHeight;
				}
			}, this.children));
		};
	}
	updateDropdownSize(vnode) {
		if (!(this.origin && this.domDropdown)) return;
		const upperSpace = this.origin.top - getSafeAreaInsetTop();
		const lowerSpace = window.innerHeight - this.origin.bottom - getSafeAreaInsetBottom();
		const children = Array.from(vnode.dom.children);
		const contentHeight = Math.min(400 + size.vpad, children.reduce((accumulator, children$1) => accumulator + children$1.offsetHeight, 0) + size.vpad);
		this.maxHeight = lowerSpace > upperSpace ? Math.min(contentHeight, lowerSpace) : Math.min(contentHeight, upperSpace);
		const newHeight = px(this.maxHeight);
		if (this.domDropdown.style.height !== newHeight) this.domDropdown.style.height = newHeight;
	}
	renderNoItem() {
		return mithril_default("span.placeholder.text-center", { color: theme.list_message_bg }, lang.get("noEntries_msg"));
	}
	backgroundClick = (e) => {
		if (this.domDropdown && !e.target.classList.contains("doNotClose") && (this.domDropdown.contains(e.target) || this.domDropdown.parentNode === e.target)) this.onClose();
	};
	buildShortcuts() {
		return [
			{
				key: Keys.ESC,
				exec: () => this.onClose(),
				help: "close_alt"
			},
			{
				key: Keys.TAB,
				shift: true,
				exec: () => this.domDropdown ? focusPrevious(this.domDropdown) : false,
				help: "selectPrevious_action"
			},
			{
				key: Keys.TAB,
				shift: false,
				exec: () => this.domDropdown ? focusNext(this.domDropdown) : false,
				help: "selectNext_action"
			},
			{
				key: Keys.UP,
				exec: () => this.domDropdown ? focusPrevious(this.domDropdown) : false,
				help: "selectPrevious_action"
			},
			{
				key: Keys.DOWN,
				exec: () => this.domDropdown ? focusNext(this.domDropdown) : false,
				help: "selectNext_action"
			}
		];
	}
	setOrigin(origin) {
		this.origin = origin;
		return this;
	}
	close() {
		modal.remove(this);
	}
	hideAnimation() {
		return Promise.resolve();
	}
	onClose() {
		this.close();
	}
	popState(e) {
		this.onClose();
		return false;
	}
	callingElement() {
		return this.focusedBeforeShown;
	}
};

//#endregion
//#region ../src/common/gui/base/SingleLineTextField.ts
let InputMode = function(InputMode$1) {
	InputMode$1["NONE"] = "none";
	InputMode$1["NUMERIC"] = "numeric";
	InputMode$1["TEXT"] = "text";
	return InputMode$1;
}({});
var SingleLineTextField = class {
	domInput;
	view({ attrs }) {
		return attrs.leadingIcon ? this.renderInputWithIcon(attrs) : this.renderInput(attrs);
	}
	renderInputWithIcon(attrs) {
		if (!attrs.leadingIcon) return;
		const fontSizeString = attrs.style?.fontSize;
		const fontSizeNumber = fontSizeString ? filterInt(fontSizeString.replace("px", "")) : NaN;
		const fontSize = isNaN(fontSizeNumber) ? 16 : fontSizeNumber;
		let iconSize;
		let padding;
		if (fontSize > 16 && fontSize < 32) {
			iconSize = IconSize.Large;
			padding = size.icon_size_large;
		} else if (fontSize > 32) {
			iconSize = IconSize.XL;
			padding = size.icon_size_xl;
		} else {
			iconSize = IconSize.Medium;
			padding = size.icon_size_medium_large;
		}
		return mithril_default(".rel.flex.flex-grow", [mithril_default(".abs.pl-vpad-s.flex.items-center", { style: {
			top: 0,
			bottom: 0
		} }, mithril_default(Icon, {
			size: iconSize,
			icon: attrs.leadingIcon.icon,
			style: { fill: attrs.leadingIcon.color }
		})), this.renderInput(attrs, px(padding + size.vpad))]);
	}
	renderInput(attrs, inputPadding) {
		return mithril_default("input.tutaui-text-field", {
			ariaLabel: attrs.ariaLabel,
			value: attrs.value,
			disabled: attrs.disabled ?? false,
			onblur: attrs.onblur,
			onfocus: attrs.onfocus,
			onkeydown: attrs.onkeydown,
			onclick: attrs.onclick,
			oninput: () => {
				if (!attrs.oninput) {
					console.error("oninput fired without a handler function");
					return;
				}
				attrs.oninput(this.domInput.value);
			},
			oncreate: (vnode) => {
				this.domInput = vnode.dom;
				if (attrs.oncreate) attrs.oncreate(vnode);
			},
			placeholder: attrs.placeholder,
			class: this.resolveClasses(attrs.classes, attrs.disabled),
			style: {
				...inputPadding ? { paddingLeft: inputPadding } : {},
				...attrs.style
			},
			type: attrs.inputMode === InputMode.NONE ? undefined : attrs.type,
			inputMode: attrs.inputMode,
			readonly: attrs.readonly,
			...this.getInputProperties(attrs)
		});
	}
	getInputProperties(attrs) {
		if (attrs.type === TextFieldType.Number) {
			const numberAttrs = attrs;
			return {
				min: numberAttrs.min,
				max: numberAttrs.max
			};
		}
		return undefined;
	}
	resolveClasses(classes = [], disabled = false) {
		const classList = [...classes];
		if (disabled) classList.push("disabled");
		return classList.join(" ");
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/pickers/GuestPicker.ts
var import_stream$6 = __toESM(require_stream(), 1);
var GuestPicker = class {
	isExpanded = false;
	isFocused = false;
	value = "";
	selected;
	options = (0, import_stream$6.default)([]);
	selectDOM = null;
	view({ attrs }) {
		return mithril_default(Select, {
			classes: ["flex-grow"],
			dropdownPosition: "bottom",
			onchange: ({ value: guest }) => {
				this.handleSelection(attrs, guest);
			},
			onclose: () => {
				this.isExpanded = false;
			},
			oncreate: (node) => {
				this.selectDOM = node;
			},
			selected: this.selected,
			ariaLabel: attrs.ariaLabel,
			disabled: attrs.disabled,
			options: this.options,
			noIcon: true,
			expanded: true,
			tabIndex: Number(TabIndex.Programmatic),
			placeholder: this.renderSearchInput(attrs),
			renderDisplay: () => this.renderSearchInput(attrs),
			renderOption: (option) => this.renderSuggestionItem(option === this.selected, option),
			keepFocus: true
		});
	}
	renderSuggestionItem(selected, option) {
		const firstRow = option.value.type === "recipient" ? option.value.value.name : mithril_default(Icon, {
			icon: Icons.People,
			style: {
				fill: theme.content_fg,
				"aria-describedby": lang.get("contactListName_label")
			}
		});
		const secondRow = option.value.type === "recipient" ? option.value.value.address : option.value.value.name;
		return mithril_default(".pt-s.pb-s.click.content-hover.button-min-height", {
			class: selected ? "content-accent-fg row-selected icon-accent" : "",
			style: {
				"padding-left": selected ? px(size.hpad_large - 3) : px(size.hpad_large),
				"border-left": selected ? "3px solid" : null
			}
		}, [mithril_default(".small.full-width.text-ellipsis", firstRow), mithril_default(".name.full-width.text-ellipsis", secondRow)]);
	}
	async handleSelection(attrs, guest) {
		if (guest.value != null) if (guest.type === "recipient") {
			const { address, name, contact } = guest.value;
			attrs.onRecipientAdded(address, name, contact);
			attrs.search.clear();
			this.value = "";
		} else {
			this.value = "";
			const recipients = await attrs.search.resolveContactList(guest.value);
			for (const { address, name, contact } of recipients) attrs.onRecipientAdded(address, name, contact);
			attrs.search.clear();
			mithril_default.redraw();
		}
	}
	renderSearchInput(attrs) {
		return mithril_default(SingleLineTextField, {
			classes: ["height-100p"],
			value: this.value,
			placeholder: lang.get("addGuest_label"),
			onclick: (e) => {
				e.stopImmediatePropagation();
				if (!this.isExpanded && this.value.length > 0 && this.selectDOM) {
					this.selectDOM.dom.click();
					this.isExpanded = true;
				}
			},
			oninput: (val) => {
				if (val.length > 0 && !this.isExpanded && this.selectDOM) {
					this.selectDOM.dom.click();
					this.isExpanded = true;
				}
				const { remainingText, newRecipients, errors } = val.length - this.value.length > 1 ? parsePastedInput(val) : parseTypedInput(val);
				for (const { address, name } of newRecipients) attrs.onRecipientAdded(address, name, null);
				if (errors.length === 1 && newRecipients.length === 0) this.value = getFirstOrThrow(errors);
else {
					if (errors.length > 0) Dialog.message(lang.makeTranslation("error_message", `${lang.get("invalidPastedRecipients_msg")}\n\n${errors.join("\n")}`));
					this.value = remainingText;
				}
				this.doSearch(val, attrs);
			},
			disabled: attrs.disabled,
			ariaLabel: attrs.ariaLabel,
			onfocus: (event) => {
				this.isFocused = true;
			},
			onblur: (e) => {
				if (this.isFocused) {
					this.resolveInput(attrs, false);
					this.isFocused = false;
				}
				e.redraw = false;
			},
			onkeydown: (event) => this.handleKeyDown(event, attrs),
			type: TextFieldType.Text
		});
	}
	doSearch = debounceStart(DefaultAnimationTime, (val, attrs) => {
		attrs.search.search(val).then(() => {
			const searchResult = attrs.search.results();
			if (searchResult.length === 0) this.selected = undefined;
			this.options(searchResult.map((option) => ({
				name: option.value.name,
				value: option,
				type: option.type,
				ariaValue: option.value.name
			})));
			mithril_default.redraw();
		});
	});
	handleKeyDown(event, attrs) {
		const keyPress = keyboardEventToKeyPress(event);
		switch (keyPress.key.toLowerCase()) {
			case Keys.RETURN.code:
				this.resolveInput(attrs, true);
				break;
			case Keys.DOWN.code:
				this.moveSelection(true);
				event.stopImmediatePropagation();
				return false;
			case Keys.UP.code:
				this.moveSelection(false);
				event.stopImmediatePropagation();
				return false;
		}
		return true;
	}
	moveSelection(forward) {
		const selectedIndex = this.selected ? this.options().indexOf(this.selected) : -1;
		const optionsLength = this.options().length;
		let newIndex;
		if (forward) newIndex = selectedIndex + 1 < optionsLength ? selectedIndex + 1 : 0;
else newIndex = selectedIndex - 1 >= 0 ? selectedIndex - 1 : optionsLength - 1;
		this.selected = this.options()[newIndex];
	}
	async selectSuggestion(attrs) {
		if (this.selected == null) return;
		if (this.selected.value.type === "recipient") {
			const { address, name, contact } = this.selected.value.value;
			attrs.onRecipientAdded(address, name, contact);
			attrs.search.clear();
			this.value = "";
		} else {
			attrs.search.clear();
			this.value = "";
			const recipients = await attrs.search.resolveContactList(this.selected.value.value);
			for (const { address, name, contact } of recipients) attrs.onRecipientAdded(address, name, contact);
			mithril_default.redraw();
		}
		this.closePicker();
	}
	/**
	* Resolves a typed in mail address or one of the suggested ones.
	* @param attrs
	* @param selectSuggestion boolean value indicating whether a suggestion should be selected or not. Should be true if a suggestion is explicitly selected by
	* for example hitting the enter key and false e.g. if the dialog is closed
	*/
	resolveInput(attrs, selectSuggestion) {
		const suggestions = attrs.search.results();
		if (suggestions.length > 0 && selectSuggestion) this.selectSuggestion(attrs);
else {
			const parsed = parseMailAddress(this.value);
			if (parsed != null) {
				attrs.onRecipientAdded(parsed.address, parsed.name, null);
				this.value = "";
				this.closePicker();
			}
		}
	}
	closePicker() {
		if (this.selectDOM) this.selectDOM.state.dropdownContainer?.onClose();
	}
};

//#endregion
//#region ../src/common/gui/PasswordInput.ts
var PasswordInput = class {
	showPassword = false;
	view(vnode) {
		return mithril_default(".flex.flex-grow.full-width.justify-between.items-center.gap-vpad-s", [
			vnode.attrs.showStrength ? mithril_default("div", { style: {
				width: px(size.icon_size_medium),
				height: px(size.icon_size_medium),
				border: `1px solid ${theme.content_button}`,
				borderRadius: "50%",
				background: `conic-gradient(from .25turn, ${theme.content_button} ${scaleToVisualPasswordStrength(vnode.attrs.strength)}%, transparent 0%)`
			} }) : null,
			mithril_default(SingleLineTextField, {
				classes: ["flex-grow"],
				ariaLabel: vnode.attrs.ariaLabel,
				type: this.showPassword ? TextFieldType.Text : TextFieldType.Password,
				value: vnode.attrs.password,
				oninput: vnode.attrs.oninput,
				style: { padding: `${px(size.vpad_xsm)} ${px(size.vpad_small)}` },
				placeholder: lang.get("password_label")
			}),
			mithril_default(IconButton, {
				size: ButtonSize.Compact,
				title: this.showPassword ? "concealPassword_action" : "revealPassword_action",
				icon: this.showPassword ? Icons.NoEye : Icons.Eye,
				click: () => this.showPassword = !this.showPassword
			})
		]);
	}
};

//#endregion
//#region ../src/common/gui/base/Switch.ts
var Switch = class {
	checkboxDom;
	view({ attrs: { disabled, variant, ariaLabel, checked, onclick, togglePillPosition, classes }, children }) {
		const childrenArr = [children, this.buildTogglePillComponent(checked, onclick, disabled)];
		if (togglePillPosition === "left") childrenArr.reverse();
		return mithril_default("label.tutaui-switch.flash", {
			class: this.resolveClasses(classes, disabled, variant),
			role: AriaRole.Switch,
			ariaLabel,
			ariaChecked: String(checked),
			ariaDisabled: disabled ? "true" : undefined,
			tabIndex: Number(disabled ? TabIndex.Programmatic : TabIndex.Default),
			onkeydown: (e) => {
				if (isKeyPressed(e.key, Keys.SPACE, Keys.RETURN)) {
					e.preventDefault();
					this.checkboxDom?.click();
				}
			}
		}, childrenArr);
	}
	buildTogglePillComponent(checked = false, onclick, disabled) {
		return mithril_default("span.tutaui-toggle-pill", { class: this.checkboxDom?.checked ? "checked" : "unchecked" }, mithril_default("input[type='checkbox']", {
			role: AriaRole.Switch,
			onclick: () => {
				onclick(this.checkboxDom?.checked ?? false);
			},
			oncreate: ({ dom }) => {
				this.checkboxDom = dom;
				this.checkboxDom.checked = checked;
			},
			tabIndex: TabIndex.Programmatic,
			disabled: disabled ? true : undefined
		}));
	}
	resolveClasses(classes = [], disabled = false, variant = "normal") {
		const classList = [...classes];
		if (disabled) classList.push("disabled", "click-disabled");
else classList.push("click");
		if (variant === "expanded") classList.push("justify-between", "full-width");
else classList.push("fit-content");
		return classList.join(" ");
	}
};

//#endregion
//#region ../src/common/gui/Divider.ts
var Divider = class {
	view({ attrs }) {
		return mithril_default("hr.m-0.border-none.full-width", { style: {
			height: "1px",
			backgroundColor: attrs.color,
			color: attrs.color,
			...attrs.style
		} });
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-view/AttendeeListEditor.ts
var import_stream$5 = __toESM(require_stream(), 1);
var AttendeeListEditor = class {
	hasPlanWithInvites = false;
	view({ attrs }) {
		const { whoModel } = attrs.model.editModels;
		const organizer = whoModel.organizer;
		return [mithril_default(".flex-grow.flex.flex-column.gap-vpad.pb.pt.fit-height", { style: { width: px(attrs.width) } }, [this.renderOrganizer(attrs.model, organizer), mithril_default(".flex.flex-column.gap-vpad-s", [
			mithril_default("small.uppercase.b.text-ellipsis", { style: { color: theme.navigation_button } }, lang.get("guests_label")),
			whoModel.canModifyGuests ? this.renderGuestsInput(whoModel, attrs.logins, attrs.recipientsSearch) : null,
			this.renderSendUpdateCheckbox(attrs.model.editModels.whoModel),
			this.renderGuestList(attrs, organizer)
		])])];
	}
	renderGuestList(attrs, organizer) {
		const { whoModel } = attrs.model.editModels;
		const guestItems = [];
		for (const guest of whoModel.guests) {
			let password;
			let strength;
			if (guest.type === RecipientType.EXTERNAL) {
				const presharedPassword = whoModel.getPresharedPassword(guest.address);
				password = presharedPassword.password;
				strength = presharedPassword.strength;
			}
			guestItems.push(() => this.renderGuest(guest, attrs, password, strength));
		}
		const ownGuest = whoModel.ownGuest;
		if (ownGuest != null && ownGuest.address !== organizer?.address) guestItems.push(() => this.renderGuest(ownGuest, attrs));
		const verticalPadding = guestItems.length > 0 ? size.vpad_small : 0;
		return guestItems.length === 0 ? mithril_default(Card, {
			classes: ["min-h-s flex flex-column gap-vpad-s"],
			style: { padding: `${px(verticalPadding)} ${px(guestItems.length === 0 ? size.vpad_small : 0)} ${px(size.vpad_small)} ${px(verticalPadding)}` }
		}, mithril_default(".flex.items-center.justify-center.min-h-s", [mithril_default(IconMessageBox, {
			message: "noEntries_msg",
			icon: Icons.People,
			color: theme.list_message_bg
		})])) : guestItems.map((r, index) => r());
	}
	renderGuestsInput(whoModel, logins, recipientsSearch) {
		const guests = whoModel.guests;
		const hasExternalGuests = guests.some((a) => a.type === RecipientType.EXTERNAL);
		return mithril_default(".flex.items-center.flex-grow.gap-vpad-s", [mithril_default(Card, {
			style: { padding: "0" },
			classes: ["flex-grow"]
		}, [mithril_default(".flex.flex-grow.rel.button-height", [mithril_default(GuestPicker, {
			ariaLabel: "addGuest_label",
			disabled: false,
			onRecipientAdded: async (address, name, contact) => {
				if (!await hasPlanWithInvites(logins) && !this.hasPlanWithInvites) {
					if (logins.getUserController().user.accountType === AccountType.EXTERNAL) return;
					if (logins.getUserController().isGlobalAdmin()) {
						const { getAvailablePlansWithEventInvites } = await import("./SubscriptionUtils-j-oFQxhJ.js");
						const plansWithEventInvites = await getAvailablePlansWithEventInvites();
						if (plansWithEventInvites.length === 0) return;
						this.hasPlanWithInvites = await showPlanUpgradeRequiredDialog(plansWithEventInvites);
						if (!this.hasPlanWithInvites) return;
					} else Dialog.message("contactAdmin_msg");
				} else whoModel.addAttendee(address, contact);
			},
			search: recipientsSearch
		})])]), hasExternalGuests ? mithril_default(Card, { style: { padding: "0" } }, mithril_default(ToggleButton, {
			title: "confidential_action",
			onToggled: (_, e) => {
				whoModel.isConfidential = !whoModel.isConfidential;
				e.stopPropagation();
			},
			icon: whoModel.isConfidential ? Icons.Lock : Icons.Unlock,
			toggled: whoModel.isConfidential,
			size: ButtonSize.Normal
		})) : null]);
	}
	renderAttendeeStatus(model, organizer) {
		const { status } = organizer ?? { status: CalendarAttendeeStatus.TENTATIVE };
		const attendingOptions = createAttendingItems().filter((option) => option.selectable !== false);
		const attendingStatus = attendingOptions.find((option) => option.value === status);
		return mithril_default(".flex.flex-column.pl-vpad-s.pr-vpad-s", [mithril_default(Select, {
			onchange: (option) => {
				if (option.selectable === false) return;
				model.setOwnAttendance(option.value);
			},
			classes: ["button-min-height"],
			selected: attendingStatus,
			disabled: organizer == null,
			ariaLabel: lang.get("attending_label"),
			renderOption: (option) => mithril_default("button.items-center.flex-grow.state-bg.button-content.dropdown-button.pt-s.pb-s.button-min-height", {
				class: option.selectable === false ? `no-hover` : "",
				style: { color: option.value === status ? theme.content_button_selected : undefined }
			}, option.name),
			renderDisplay: (option) => mithril_default("", option.name),
			options: (0, import_stream$5.default)(attendingOptions),
			expanded: true,
			noIcon: organizer == null
		})]);
	}
	renderOrganizer(model, organizer) {
		const { whoModel } = model.editModels;
		if (!(whoModel.possibleOrganizers.length > 0 || organizer)) {
			console.log("Trying to access guest without organizer");
			return null;
		}
		const { address, name, status } = organizer ?? {};
		const hasGuest = whoModel.guests.length > 0;
		const isMe = organizer?.address === whoModel.ownGuest?.address;
		const editableOrganizer = whoModel.possibleOrganizers.length > 1 && isMe;
		const options = whoModel.possibleOrganizers.map((organizer$1) => {
			return {
				name: organizer$1.name,
				address: organizer$1.address,
				ariaValue: organizer$1.address,
				value: organizer$1.address
			};
		});
		const disabled = !editableOrganizer || !hasGuest;
		const selected = options.find((option) => option.address === address) ?? options[0];
		return mithril_default(".flex.col", [mithril_default("small.uppercase.pb-s.b.text-ellipsis", { style: { color: theme.navigation_button } }, lang.get("organizer_label")), mithril_default(Card, { style: { padding: `0` } }, [mithril_default(".flex.flex-column", [mithril_default(".flex.pl-vpad-s.pr-vpad-s", [mithril_default(Select, {
			classes: ["flex-grow", "button-min-height"],
			onchange: (option) => {
				const organizer$1 = whoModel.possibleOrganizers.find((organizer$2) => organizer$2.address === option.address);
				if (organizer$1) whoModel.addAttendee(organizer$1.address, null);
			},
			selected,
			disabled,
			ariaLabel: lang.get("organizer_label"),
			renderOption: (option) => mithril_default("button.items-center.flex-grow.state-bg.button-content.dropdown-button.pt-s.pb-s.button-min-height", { style: { color: selected.address === option.address ? theme.content_button_selected : undefined } }, option.address),
			renderDisplay: (option) => mithril_default("", option.name ? `${option.name} <${option.address}>` : option.address),
			options: (0, import_stream$5.default)(whoModel.possibleOrganizers.map((organizer$1) => {
				return {
					name: organizer$1.name,
					address: organizer$1.address,
					ariaValue: organizer$1.address,
					value: organizer$1.address
				};
			})),
			noIcon: disabled,
			expanded: true
		}), model.operation !== CalendarOperation.EditThis && organizer && !isMe ? mithril_default(IconButton, {
			title: "sendMail_alt",
			click: async () => (await import("./ContactView-D8FqOa_D.js")).writeMail(organizer, lang.get("repliedToEventInvite_msg", { "{event}": model.editModels.summary.content })),
			size: ButtonSize.Compact,
			icon: Icons.PencilSquare
		}) : null]), isMe && model.operation !== CalendarOperation.EditThis ? [mithril_default(Divider, { color: theme.button_bubble_bg }), this.renderAttendeeStatus(whoModel, organizer)] : null])])]);
	}
	renderSendUpdateCheckbox(whoModel) {
		return !whoModel.initiallyHadOtherAttendees || !whoModel.canModifyGuests ? null : mithril_default(Card, mithril_default(Switch, {
			checked: whoModel.shouldSendUpdates,
			onclick: (value) => whoModel.shouldSendUpdates = value,
			ariaLabel: lang.get("sendUpdates_label"),
			disabled: false,
			variant: "expanded"
		}, lang.get("sendUpdates_label")));
	}
	renderGuest(guest, { model }, password, strength) {
		const { whoModel } = model.editModels;
		const { address, name, status } = guest;
		const isMe = guest.address === whoModel.ownGuest?.address;
		const roleLabel = isMe ? `${lang.get("guest_label")} | ${lang.get("you_label")}` : lang.get("guest_label");
		const renderPasswordField = whoModel.isConfidential && password != null && guest.type === RecipientType.EXTERNAL;
		let rightContent = null;
		if (isMe) rightContent = mithril_default("", { style: { paddingRight: px(size.vpad_small) } }, this.renderAttendeeStatus(model.editModels.whoModel, guest));
else if (whoModel.canModifyGuests) rightContent = mithril_default(IconButton, {
			title: "remove_action",
			icon: Icons.Cancel,
			click: () => whoModel.removeAttendee(guest.address)
		});
		return mithril_default(Card, { style: { padding: `${px(size.vpad_small)} ${px(0)} ${px(size.vpad_small)} ${px(size.vpad_small)}` } }, mithril_default(".flex.flex-column.items-center", [mithril_default(".flex.items-center.flex-grow.full-width", [
			this.renderStatusIcon(status),
			mithril_default(".flex.flex-column.flex-grow.min-width-0", [mithril_default(".small", { style: { lineHeight: px(size.vpad_small) } }, roleLabel), mithril_default(".text-ellipsis", name.length > 0 ? `${name} ${address}` : address)]),
			rightContent
		]), renderPasswordField ? [mithril_default(".flex.full-width", { style: { padding: `0 0 ${px(size.vpad_xsm)} ${px(size.vpad_small + size.icon_size_medium_large)}` } }, mithril_default(Divider, { color: theme.button_bubble_bg })), this.renderPasswordField(address, password, strength ?? 0, whoModel)] : null]));
	}
	renderPasswordField(address, password, strength, whoModel) {
		const label = lang.get("passwordFor_label", { "{1}": address });
		return [mithril_default(".flex.flex-grow.full-width.justify-between.items-end", [mithril_default(".flex.flex-column.full-width", { style: {
			paddingLeft: px(size.hpad_medium + size.vpad_small),
			paddingRight: px((size.button_height - size.button_height_compact) / 2)
		} }, [mithril_default(PasswordInput, {
			ariaLabel: label,
			password,
			strength,
			oninput: (newPassword) => {
				whoModel.setPresharedPassword(address, newPassword);
			}
		})])])];
	}
	renderStatusIcon(status) {
		const icon = iconForAttendeeStatus[status];
		return mithril_default(Icon, {
			icon,
			size: IconSize.Large,
			class: "mr-s",
			style: { fill: theme.content_fg }
		});
	}
};

//#endregion
//#region ../src/common/gui/base/buttons/ArrowButton.ts
function renderSwitchMonthArrowIcon(forward, size$1, onClick) {
	return mithril_default(BaseButton, {
		label: forward ? "nextMonth_label" : "prevMonth_label",
		icon: mithril_default(Icon, {
			icon: forward ? Icons.ArrowForward : BootIcons.Back,
			container: "div",
			class: "center-h",
			size: IconSize.Normal,
			style: { fill: theme.content_fg }
		}),
		style: {
			width: px(size$1),
			height: px(size$1)
		},
		class: "state-bg circle",
		onclick: onClick
	});
}

//#endregion
//#region ../src/common/gui/base/InputButton.ts
let InputButtonVariant = function(InputButtonVariant$1) {
	InputButtonVariant$1["OUTLINE"] = "outline";
	return InputButtonVariant$1;
}({});
var InputButton = class {
	isFocused = false;
	inputDOM;
	buttonDOM;
	view({ attrs }) {
		return mithril_default("button", {
			title: attrs.ariaLabel,
			"aria-live": "off",
			class: this.resolveContainerClasses(attrs.variant, attrs.classes, attrs.disabled),
			tabIndex: attrs.tabIndex,
			style: {
				borderColor: theme.content_message_bg,
				padding: 0,
				...attrs.containerStyle
			},
			oncreate: (vnode) => {
				this.buttonDOM = vnode.dom;
			},
			onclick: (event) => {
				this.isFocused = true;
				if (this.inputDOM) {
					this.inputDOM.style.display = "block";
					this.inputDOM.click();
				}
				attrs.onclick?.(event);
			},
			onfocus: () => {
				this.isFocused = true;
				if (this.inputDOM) {
					this.inputDOM.style.display = "block";
					if (this.buttonDOM) this.buttonDOM.tabIndex = Number(TabIndex.Programmatic);
					this.inputDOM.focus();
				}
			},
			disabled: attrs.disabled
		}, [mithril_default.fragment({}, [mithril_default(SingleLineTextField, {
			ariaLabel: attrs.ariaLabel,
			onblur: () => {
				this.isFocused = false;
				this.inputDOM.style.display = "none";
				if (this.buttonDOM) this.buttonDOM.tabIndex = Number(attrs.tabIndex ?? TabIndex.Default);
				attrs.onblur?.();
			},
			oncreate: (vnode) => {
				this.inputDOM = vnode.dom;
				this.inputDOM.style.display = "none";
				attrs.oncreate?.(vnode);
			},
			disabled: attrs.disabled,
			value: attrs.inputValue,
			oninput: attrs.oninput,
			onkeydown: attrs.onkeydown,
			onfocus: attrs.onfocus,
			classes: this.resolveInputClasses(attrs.variant),
			style: { padding: `${px(size.vpad_small)} 0` },
			type: TextFieldType.Text
		})]), mithril_default("span.tutaui-text-field", { style: {
			display: this.isFocused ? "none" : "block",
			padding: `${px(size.vpad_small)} 0`,
			...attrs.displayStyle
		} }, attrs.display)]);
	}
	resolveInputClasses(variant) {
		const resolvedClasses = ["text-center", "noselect"];
		if (variant === InputButtonVariant.OUTLINE && this.isFocused) resolvedClasses.push("tutaui-button-outline", "border-content-message-bg");
		return resolvedClasses;
	}
	resolveContainerClasses(variant = InputButtonVariant.OUTLINE, classes = [], disabled = false) {
		const resolvedClasses = [...classes, "full-width"];
		if (disabled) resolvedClasses.push("disabled", "click-disabled");
		if (variant === InputButtonVariant.OUTLINE && !this.isFocused) resolvedClasses.push("tutaui-button-outline");
		return resolvedClasses.join(" ");
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/pickers/DatePicker.ts
let PickerPosition = function(PickerPosition$1) {
	PickerPosition$1[PickerPosition$1["TOP"] = 0] = "TOP";
	PickerPosition$1[PickerPosition$1["BOTTOM"] = 1] = "BOTTOM";
	return PickerPosition$1;
}({});
var DatePicker = class {
	inputText = "";
	showingDropdown = false;
	domInput = null;
	documentInteractionListener = null;
	textFieldHasFocus = false;
	previousPassedDownDate;
	constructor({ attrs }) {
		this.inputText = attrs.date ? formatDate(attrs.date) : "";
		this.previousPassedDownDate = attrs.date;
	}
	view({ attrs }) {
		const date = attrs.date;
		if (!this.textFieldHasFocus && !isSameDayOfDate(date, this.previousPassedDownDate)) {
			this.inputText = date ? formatDate(date) : "";
			this.previousPassedDownDate = date;
		}
		return mithril_default(".rel", { class: attrs.classes?.join(" ") }, [
			!attrs.useInputButton ? this.renderTextField(attrs) : this.renderInputButtonPicker(attrs),
			this.showingDropdown ? this.renderDropdown(attrs) : null,
			client.isMobileDevice() && !attrs.useInputButton ? this.renderMobileDateInput(attrs) : null
		]);
	}
	renderInputButtonPicker({ disabled, date, onDateSelected, label }) {
		return mithril_default.fragment({}, [isApp() ? mithril_default("input.fill-absolute.invisible.tutaui-button-outline", {
			disabled,
			type: TextFieldType.Date,
			style: {
				zIndex: 1,
				border: `2px solid ${theme.content_message_bg}`,
				width: "auto",
				height: "auto",
				padding: 0,
				appearance: "none",
				opacity: disabled ? .7 : 1
			},
			value: date != null ? DateTime.fromJSDate(date).toISODate() : "",
			oninput: (event) => {
				this.handleNativeInput(event, onDateSelected);
			}
		}) : null, mithril_default(InputButton, {
			tabIndex: Number(isApp() ? TabIndex.Programmatic : TabIndex.Default),
			ariaLabel: lang.getTranslationText(label),
			inputValue: this.inputText,
			oninput: (newValue) => this.inputText = newValue,
			display: formatDateWithWeekdayAndYear(date ?? new Date()),
			variant: InputButtonVariant.OUTLINE,
			disabled,
			type: TextFieldType.Text,
			onclick: () => {
				if (!disabled) this.showingDropdown = true;
			},
			onfocus: (_, input) => {
				if (!disabled) this.showingDropdown = true;
				this.textFieldHasFocus = true;
			},
			oncreate: (input) => {
				if (this.domInput == null) this.domInput = input.dom;
			},
			onblur: () => {
				this.textFieldHasFocus = false;
			},
			onkeydown: (event) => {
				const key = keyboardEventToKeyPress(event);
				return this.handleInputKeyEvents(key, disabled, onDateSelected);
			},
			containerStyle: isApp() ? {
				zIndex: "2",
				position: "inherit",
				borderColor: "transparent",
				pointerEvents: "none"
			} : {}
		})]);
	}
	renderTextField({ date, onDateSelected, label, nullSelectionText, disabled }) {
		return mithril_default("", { onclick: () => {
			if (!disabled) this.showingDropdown = true;
		} }, mithril_default(TextField, {
			value: this.inputText,
			label,
			helpLabel: () => this.renderHelpLabel(date, nullSelectionText ?? null),
			disabled,
			hasPopup: AriaPopupType.Dialog,
			oninput: (text) => {
				this.inputText = text;
			},
			onfocus: (_, input) => {
				if (!disabled) this.showingDropdown = true;
				this.textFieldHasFocus = true;
			},
			onDomInputCreated: (input) => {
				if (this.domInput == null) this.domInput = input;
			},
			onblur: () => {
				this.textFieldHasFocus = false;
			},
			keyHandler: (key) => {
				return this.handleInputKeyEvents(key, disabled, onDateSelected);
			}
		}));
	}
	handleEscapePress(key) {
		if (isKeyPressed(key.key, Keys.ESC) && this.showingDropdown) {
			this.domInput?.focus();
			this.showingDropdown = false;
			return false;
		}
		return true;
	}
	renderHelpLabel(date, nullSelectionText) {
		if (this.showingDropdown) return null;
else if (date != null) return [mithril_default("", formatDateWithWeekdayAndYear(date)), nullSelectionText ? mithril_default("", lang.getTranslationText(nullSelectionText)) : null];
else return lang.getTranslationText(nullSelectionText ?? "emptyString_msg");
	}
	renderDropdown({ date, onDateSelected, startOfTheWeekOffset, rightAlignDropdown, label, position }) {
		const dropdownDate = this.parseDate(this.inputText) ?? date ?? new Date();
		return mithril_default(".content-bg.z3.menu-shadow.plr.pb-s", {
			"aria-modal": "true",
			"aria-label": lang.get(label),
			style: {
				width: "240px",
				right: rightAlignDropdown ? "0" : null
			},
			class: position === PickerPosition.TOP ? "abs" : "fixed",
			oncreate: (vnode) => {
				const listener = (e) => {
					if (!vnode.dom.contains(e.target) && !this.domInput?.contains(e.target)) {
						if (this.showingDropdown) {
							this.showingDropdown = false;
							this.handleInput(this.inputText, onDateSelected);
							mithril_default.redraw();
						}
					}
				};
				if (position === PickerPosition.TOP && vnode.dom.parentElement) {
					const bottomMargin = vnode.dom.parentElement.getBoundingClientRect().height;
					vnode.dom.style.bottom = px(bottomMargin);
				}
				this.documentInteractionListener = listener;
				document.addEventListener("click", listener, true);
				document.addEventListener("focus", listener, true);
			},
			onremove: () => {
				if (this.documentInteractionListener) {
					document.removeEventListener("click", this.documentInteractionListener, true);
					document.removeEventListener("focus", this.documentInteractionListener, true);
				}
			}
		}, mithril_default(VisualDatePicker, {
			selectedDate: dropdownDate,
			onDateSelected: (newDate, dayClick) => {
				this.handleSelectedDate(newDate, onDateSelected);
				if (dayClick) {
					if (this.domInput) {
						this.domInput.addEventListener("focus", () => {
							this.showingDropdown = false;
							mithril_default.redraw();
						}, { once: true });
						this.domInput.focus();
					}
				}
			},
			keyHandler: (key) => this.handleEscapePress(key),
			wide: false,
			startOfTheWeekOffset
		}));
	}
	renderMobileDateInput({ date, onDateSelected, disabled }) {
		return mithril_default("input.fill-absolute", {
			disabled,
			type: "date",
			style: {
				opacity: 0,
				minWidth: "100%",
				minHeight: "100%"
			},
			value: date != null ? DateTime.fromJSDate(date).toISODate() : "",
			oninput: (event) => {
				this.handleNativeInput(event, onDateSelected);
			}
		});
	}
	handleInput(text, onDateSelected) {
		this.inputText = text;
		const parsedDate = this.parseDate(text);
		if (parsedDate) onDateSelected(parsedDate);
	}
	handleSelectedDate(date, onDateSelected) {
		this.inputText = formatDate(date);
		onDateSelected(date);
	}
	parseDate = memoized((text) => {
		const trimmedValue = text.trim();
		if (trimmedValue !== "") try {
			return parseDate(trimmedValue, (referenceDate) => formatDate(referenceDate));
		} catch (e) {}
		return null;
	});
	handleInputKeyEvents(key, disabled, onDateSelected) {
		if (isKeyPressed(key.key, Keys.DOWN)) {
			if (!disabled && !key.shift && !key.ctrl && !key.meta) this.showingDropdown = true;
		} else if (isKeyPressed(key.key, Keys.RETURN)) this.handleInput(this.inputText, onDateSelected);
		return this.handleEscapePress(key);
	}
	handleNativeInput(event, onDateSelected) {
		const htmlDate = event.target.valueAsDate;
		if (htmlDate != null) this.handleSelectedDate(getAllDayDateLocal(htmlDate), onDateSelected);
	}
};
var VisualDatePicker = class {
	displayingDate;
	lastSelectedDate = null;
	constructor(vnode) {
		this.displayingDate = vnode.attrs.selectedDate || getStartOfDay(new Date());
	}
	view(vnode) {
		const selectedDate = vnode.attrs.selectedDate;
		if (selectedDate && !isSameDayOfDate(this.lastSelectedDate, selectedDate)) {
			this.lastSelectedDate = selectedDate;
			this.displayingDate = new Date(selectedDate);
			this.displayingDate.setDate(1);
		}
		let date = new Date(this.displayingDate);
		let { weeks, weekdays } = getCalendarMonth(this.displayingDate, vnode.attrs.startOfTheWeekOffset, true);
		return mithril_default(".flex.flex-column", { onkeydown: (event) => useKeyHandler(event, vnode.attrs.keyHandler) }, [
			this.renderPickerHeader(vnode, date),
			mithril_default(".flex.flex-space-between", this.renderWeekDays(vnode.attrs.wide, weekdays)),
			mithril_default(".flex.flex-column.flex-space-around", { style: {
				fontSize: px(14),
				lineHeight: px(this.getElementWidth(vnode.attrs))
			} }, weeks.map((w) => this.renderWeek(w, vnode.attrs)))
		]);
	}
	renderPickerHeader(vnode, date) {
		const size$1 = this.getElementWidth(vnode.attrs);
		return mithril_default(".flex.flex-space-between.pt-s.pb-s.items-center", [
			renderSwitchMonthArrowIcon(false, size$1, () => this.onPrevMonthSelected()),
			mithril_default(".b", { style: { fontSize: px(14) } }, formatMonthWithFullYear(date)),
			renderSwitchMonthArrowIcon(true, size$1, () => this.onNextMonthSelected())
		]);
	}
	onPrevMonthSelected() {
		this.displayingDate.setMonth(this.displayingDate.getMonth() - 1);
	}
	onNextMonthSelected() {
		this.displayingDate.setMonth(this.displayingDate.getMonth() + 1);
	}
	renderDay({ date, day, isPaddingDay }, index, attrs) {
		const isSelectedDay = isSameDayOfDate(date, attrs.selectedDate);
		const isSubstituteDay = attrs.selectedDate?.getMonth() !== date.getMonth() && date.getDate() === 1;
		const isTabbable = !isPaddingDay && (isSelectedDay || isSubstituteDay);
		const size$1 = this.getElementWidth(attrs);
		const selector = isSelectedDay && !isPaddingDay ? ".circle.accent-bg" : "";
		return mithril_default(".rel.flex.items-center.justify-center", {
			style: {
				height: px(size$1),
				width: px(size$1)
			},
			class: isPaddingDay ? undefined : "click",
			"aria-hidden": `${isPaddingDay}`,
			"aria-label": date.toLocaleDateString(),
			"aria-selected": `${isSelectedDay}`,
			role: "option",
			tabindex: isTabbable ? TabIndex.Default : TabIndex.Programmatic,
			onclick: isPaddingDay ? undefined : () => attrs.onDateSelected?.(date, true),
			onkeydown: (event) => {
				const key = keyboardEventToKeyPress(event);
				const target = event.target;
				if (isKeyPressed(key.key, Keys.LEFT)) {
					let targetDay;
					if (target.previousElementSibling == null) targetDay = target.parentElement?.previousElementSibling?.children.item(6);
else targetDay = target.previousElementSibling;
					if (!this.focusDayIfPossible(target, targetDay)) {
						this.onPrevMonthSelected();
						mithril_default.redraw.sync();
						this.focusLastDay(target);
					}
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.RIGHT)) {
					let targetDay;
					if (target.nextElementSibling == null) targetDay = target.parentElement?.nextElementSibling?.children.item(0);
else targetDay = target.nextElementSibling;
					if (!this.focusDayIfPossible(target, targetDay)) {
						this.onNextMonthSelected();
						mithril_default.redraw.sync();
						this.focusFirstDay(target);
					}
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.UP)) {
					const dayAbove = target.parentElement?.previousElementSibling?.children.item(index);
					if (!this.focusDayIfPossible(target, dayAbove)) {
						this.onPrevMonthSelected();
						mithril_default.redraw.sync();
						this.focusLastWeekDay(target, index);
					}
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.DOWN)) {
					const dayBelow = target.parentElement?.nextElementSibling?.children.item(index);
					if (!this.focusDayIfPossible(target, dayBelow)) {
						this.onNextMonthSelected();
						mithril_default.redraw.sync();
						this.focusFirstWeekDay(target, index);
					}
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.HOME) && !isPaddingDay) {
					this.focusFirstDay(target);
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.END) && !isPaddingDay) {
					this.focusLastDay(target);
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.PAGE_UP) && !isPaddingDay) {
					if (key.shift) this.displayingDate.setFullYear(this.displayingDate.getFullYear() - 1);
else this.onPrevMonthSelected();
					mithril_default.redraw.sync();
					this.focusFirstDay(target);
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.PAGE_DOWN) && !isPaddingDay) {
					if (key.shift) this.displayingDate.setFullYear(this.displayingDate.getFullYear() + 1);
else this.onNextMonthSelected();
					mithril_default.redraw.sync();
					this.focusFirstDay(target);
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.RETURN) && !isPaddingDay) {
					attrs.onDateSelected?.(date, true);
					event.preventDefault();
				}
				if (isKeyPressed(key.key, Keys.SPACE) && !isPaddingDay) {
					attrs.onDateSelected?.(date, false);
					event.preventDefault();
				}
			}
		}, [mithril_default(".abs.z1" + selector, { style: {
			width: px(size$1),
			height: px(size$1)
		} }), mithril_default(selector + ".full-width.height-100p.center.z2", { style: { "background-color": "transparent" } }, isPaddingDay ? null : day)]);
	}
	focusDayIfPossible(previousElement, dayElement) {
		const element = dayElement;
		if (element != null && element.ariaHidden === "false") {
			element.focus();
			element.tabIndex = 0;
			previousElement.tabIndex = -1;
			return true;
		}
		return false;
	}
	focusLastDay(target) {
		const weeks = target.parentElement?.parentElement?.children;
		if (weeks != null) for (let i = weeks.length - 1; i >= 0; i--) {
			const week = weeks.item(i)?.children;
			let isDateFound = false;
			if (week != null) for (let j = week.length - 1; j >= 0; j--) {
				const child = week.item(j);
				if (this.focusDayIfPossible(target, child)) {
					isDateFound = true;
					break;
				}
			}
			if (isDateFound) break;
		}
	}
	focusLastWeekDay(target, weekDay) {
		const weeks = target.parentElement?.parentElement?.children;
		if (weeks != null) for (let i = weeks.length - 1; i >= 0; i--) {
			const week = weeks.item(i)?.children;
			if (week != null) {
				const child = week.item(weekDay);
				if (this.focusDayIfPossible(target, child)) break;
			}
		}
	}
	focusFirstDay(target) {
		const weeks = target.parentElement?.parentElement?.children;
		if (weeks != null) for (let i = 0; i < weeks.length; i++) {
			const week = weeks.item(i)?.children;
			let isDateFound = false;
			if (week != null) for (let j = 0; j < week.length; j++) {
				const child = week.item(j);
				if (this.focusDayIfPossible(target, child)) {
					isDateFound = true;
					break;
				}
			}
			if (isDateFound) break;
		}
	}
	focusFirstWeekDay(target, weekDay) {
		const weeks = target.parentElement?.parentElement?.children;
		if (weeks != null) for (let i = 0; i < weeks.length; i++) {
			const week = weeks.item(i)?.children;
			if (week != null) {
				const child = week.item(weekDay);
				if (this.focusDayIfPossible(target, child)) break;
			}
		}
	}
	getElementWidth(attrs) {
		return attrs.wide ? 40 : 24;
	}
	renderWeek(week, attrs) {
		return mithril_default(".flex.flex-space-between", week.map((d, i) => this.renderDay(d, i, attrs)));
	}
	renderWeekDays(wide, weekdays) {
		const size$1 = px(wide ? 40 : 24);
		const fontSize = px(14);
		return weekdays.map((wd) => mithril_default(".center", {
			"aria-hidden": "true",
			style: {
				fontSize,
				height: size$1,
				width: size$1,
				lineHeight: size$1,
				color: theme.navigation_menu_icon
			}
		}, wd));
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/pickers/TimePicker.ts
var import_stream$4 = __toESM(require_stream(), 1);
var TimePicker = class {
	values;
	focused;
	isExpanded = false;
	oldValue;
	value;
	amPm;
	constructor({ attrs }) {
		this.focused = false;
		this.value = "";
		this.amPm = attrs.timeFormat === TimeFormat.TWELVE_HOURS;
		const times = [];
		for (let hour = 0; hour < 24; hour++) for (let minute = 0; minute < 60; minute += 30) times.push(timeStringFromParts(hour, minute, this.amPm));
		this.oldValue = attrs.time?.toString(false) ?? "--";
		this.values = times;
	}
	view({ attrs }) {
		if (attrs.time) {
			const timeAsString = attrs.time?.toString(this.amPm) ?? "";
			if (!this.focused) this.value = timeAsString;
		}
		if (isApp()) return this.renderNativeTimePicker(attrs);
else return this.renderCustomTimePicker(attrs);
	}
	renderNativeTimePicker(attrs) {
		if (this.oldValue !== attrs.time?.toString(false)) this.onSelected(attrs);
		const timeAsString = attrs.time?.toString(false) ?? "";
		this.oldValue = timeAsString;
		this.value = timeAsString;
		const displayTime = attrs.time?.toString(this.amPm);
		return mithril_default(".rel", [mithril_default("input.fill-absolute.invisible.tutaui-button-outline", {
			disabled: attrs.disabled,
			type: TextFieldType.Time,
			style: {
				zIndex: 1,
				border: `2px solid ${theme.content_message_bg}`,
				width: "auto",
				height: "auto",
				appearance: "none",
				opacity: attrs.disabled ? .7 : 1
			},
			value: this.value,
			oninput: (event) => {
				const inputValue = event.target.value;
				if (this.value === inputValue) return;
				this.value = inputValue;
				attrs.onTimeSelected(Time.parseFromString(inputValue));
			}
		}), mithril_default(".tutaui-button-outline", {
			class: attrs.classes?.join(" "),
			style: {
				zIndex: "2",
				position: "inherit",
				borderColor: "transparent",
				pointerEvents: "none",
				padding: `${px(size.vpad_small)} 0`,
				opacity: attrs.disabled ? .7 : 1
			}
		}, displayTime)]);
	}
	renderCustomTimePicker(attrs) {
		const options = this.values.map((time) => ({
			value: time,
			name: time,
			ariaValue: time
		}));
		return mithril_default(Select, {
			onchange: (newValue) => {
				if (this.value === newValue.value) return;
				this.value = newValue.value;
				this.onSelected(attrs);
				mithril_default.redraw.sync();
			},
			onclose: () => {
				this.isExpanded = false;
			},
			selected: {
				value: this.value,
				name: this.value,
				ariaValue: this.value
			},
			ariaLabel: attrs.ariaLabel,
			disabled: attrs.disabled,
			options: (0, import_stream$4.default)(options),
			noIcon: true,
			expanded: true,
			tabIndex: Number(TabIndex.Programmatic),
			renderDisplay: () => this.renderTimeSelectInput(attrs),
			renderOption: (option) => this.renderTimeOptions(option),
			keepFocus: true
		});
	}
	renderTimeOptions(option) {
		return mithril_default("button.items-center.flex-grow", { class: "state-bg button-content dropdown-button pt-s pb-s button-min-height" }, option.name);
	}
	renderTimeSelectInput(attrs) {
		return mithril_default(SingleLineTextField, {
			classes: [
				...attrs.classes ?? [],
				"tutaui-button-outline",
				"text-center",
				"border-content-message-bg"
			],
			value: this.value,
			oninput: (val) => {
				if (this.value === val) return;
				this.value = val;
			},
			disabled: attrs.disabled,
			ariaLabel: attrs.ariaLabel,
			style: { textAlign: "center" },
			onclick: (e) => {
				e.stopImmediatePropagation();
				if (!this.isExpanded) {
					e.target.parentElement?.click();
					this.isExpanded = true;
				}
			},
			onfocus: (event) => {
				this.focused = true;
				if (!this.isExpanded) {
					event.target.parentElement?.click();
					this.isExpanded = true;
				}
			},
			onblur: (e) => {
				if (this.focused) this.onSelected(attrs);
				e.redraw = false;
			},
			type: TextFieldType.Text
		});
	}
	onSelected(attrs) {
		this.focused = false;
		attrs.onTimeSelected(Time.parseFromString(this.value));
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-view/EventTimeEditor.ts
var EventTimeEditor = class {
	view(vnode) {
		const { attrs } = vnode;
		const { startOfTheWeekOffset, editModel, timeFormat, disabled } = attrs;
		const appClasses = isApp() ? ["smaller"] : [];
		return mithril_default(".flex", [mithril_default(".flex.col.flex-grow.gap-vpad-s", [mithril_default(".flex.gap-vpad-s.items-center.pr-vpad-s", [mithril_default(Icon, {
			icon: Icons.Time,
			style: { fill: theme.content_fg },
			title: lang.get("timeSection_label"),
			size: IconSize.Medium
		}), mithril_default(Switch, {
			checked: editModel.isAllDay,
			onclick: (value) => editModel.isAllDay = value,
			ariaLabel: lang.get("allDay_label"),
			disabled,
			variant: "expanded"
		}, lang.get("allDay_label"))]), mithril_default(".flex.col.full-width.flex-grow.gap-vpad-s", { style: { paddingLeft: px(size.icon_size_large + size.vpad_small) } }, [mithril_default(Divider, { color: theme.button_bubble_bg }), mithril_default(".time-selection-grid.pr-vpad-s", [
			mithril_default("", lang.get("dateFrom_label")),
			mithril_default(`${isApp() ? "" : ".pl-vpad-l"}`, mithril_default(DatePicker, {
				classes: appClasses,
				date: attrs.editModel.startDate,
				onDateSelected: (date) => date && (editModel.startDate = date),
				startOfTheWeekOffset,
				label: "dateFrom_label",
				useInputButton: true,
				disabled: attrs.disabled
			})),
			mithril_default("", mithril_default(TimePicker, {
				classes: appClasses,
				time: editModel.startTime,
				onTimeSelected: (time) => editModel.startTime = time,
				timeFormat,
				disabled: attrs.disabled || attrs.editModel.isAllDay,
				ariaLabel: lang.get("startTime_label")
			})),
			mithril_default("", lang.get("dateTo_label")),
			mithril_default(`${isApp() ? "" : ".pl-vpad-l"}`, mithril_default(DatePicker, {
				classes: appClasses,
				date: attrs.editModel.endDate,
				onDateSelected: (date) => date && (editModel.endDate = date),
				startOfTheWeekOffset,
				label: "dateTo_label",
				useInputButton: true,
				disabled: attrs.disabled
			})),
			mithril_default("", mithril_default(TimePicker, {
				classes: appClasses,
				time: editModel.endTime,
				onTimeSelected: (time) => editModel.endTime = time,
				timeFormat,
				disabled: attrs.disabled || attrs.editModel.isAllDay,
				ariaLabel: lang.get("endTime_label")
			}))
		])])])]);
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/RemindersEditor.ts
var import_stream$3 = __toESM(require_stream(), 1);
var RemindersEditor = class {
	view(vnode) {
		const { addAlarm, removeAlarm, alarms, useNewEditor } = vnode.attrs;
		const addNewAlarm = (newAlarm) => {
			const hasAlarm = alarms.find((alarm) => deepEqual(alarm, newAlarm));
			if (hasAlarm) return;
			addAlarm(newAlarm);
		};
		return useNewEditor ? this.renderNewEditor(alarms, removeAlarm, addNewAlarm, addAlarm) : this.renderOldEditor(alarms, removeAlarm, addNewAlarm, vnode);
	}
	renderOldEditor(alarms, removeAlarm, addNewAlarm, vnode) {
		const textFieldAttrs = alarms.map((a) => ({
			value: humanDescriptionForAlarmInterval(a, lang.languageTag),
			label: "emptyString_msg",
			isReadOnly: true,
			injectionsRight: () => mithril_default(IconButton, {
				title: "delete_action",
				icon: Icons.Cancel,
				click: () => removeAlarm(a)
			})
		}));
		textFieldAttrs.push({
			value: lang.get("add_action"),
			label: "emptyString_msg",
			isReadOnly: true,
			injectionsRight: () => mithril_default(IconButton, attachDropdown({
				mainButtonAttrs: {
					title: "add_action",
					icon: Icons.Add
				},
				childAttrs: () => [...createAlarmIntervalItems(lang.languageTag).map((i) => ({
					label: lang.makeTranslation(i.name, i.name),
					click: () => addNewAlarm(i.value)
				})), {
					label: "calendarReminderIntervalDropdownCustomItem_label",
					click: () => {
						this.showCustomReminderIntervalDialog((value, unit) => {
							addNewAlarm({
								value,
								unit
							});
						});
					}
				}]
			}))
		});
		textFieldAttrs[0].label = vnode.attrs.label;
		return mithril_default(".flex.col.flex-half.pl-s", textFieldAttrs.map((a) => mithril_default(TextField, a)));
	}
	renderNewEditor(alarms, removeAlarm, addNewAlarm, addAlarm) {
		const alarmOptions = createAlarmIntervalItems(lang.languageTag).map((alarm) => ({
			text: alarm.name,
			value: alarm.value,
			ariaValue: alarm.name
		}));
		alarmOptions.push({
			text: lang.get("calendarReminderIntervalDropdownCustomItem_label"),
			ariaValue: lang.get("calendarReminderIntervalDropdownCustomItem_label"),
			value: {
				value: -1,
				unit: AlarmIntervalUnit.MINUTE
			}
		});
		const defaultSelected = {
			text: lang.get("addReminder_label"),
			value: {
				value: -2,
				unit: AlarmIntervalUnit.MINUTE
			},
			ariaValue: lang.get("addReminder_label")
		};
		return mithril_default("ul.unstyled-list.flex.col.flex-grow.gap-vpad-s", [alarms.map((alarm) => mithril_default("li.flex.justify-between.flew-grow.items-center.gap-vpad-s", [mithril_default("span.flex.justify-between", humanDescriptionForAlarmInterval(alarm, lang.languageTag)), mithril_default(BaseButton, {
			label: lang.makeTranslation("delete_action", `${lang.get("delete_action")} ${humanDescriptionForAlarmInterval(alarm, lang.languageTag)}`),
			onclick: () => removeAlarm(alarm),
			class: "flex items-center"
		}, mithril_default(Icon, {
			icon: Icons.Cancel,
			size: IconSize.Medium,
			style: { fill: getColors(ButtonColor.Content).button }
		}))])), mithril_default("li.items-center", mithril_default(Select, {
			ariaLabel: lang.get("calendarReminderIntervalValue_label"),
			selected: defaultSelected,
			options: (0, import_stream$3.default)(alarmOptions),
			renderOption: (option) => this.renderReminderOptions(option, false, false),
			renderDisplay: (option) => this.renderReminderOptions(option, alarms.length > 0, true),
			onchange: (newValue) => {
				if (newValue.value.value === -1) return setTimeout(() => {
					this.showCustomReminderIntervalDialog((value, unit) => {
						addNewAlarm({
							value,
							unit
						});
					});
				}, 0);
				addAlarm(newValue.value);
			},
			expanded: true,
			iconColor: getColors(ButtonColor.Content).button,
			noIcon: true
		}))]);
	}
	renderReminderOptions(option, hasAlarms, isDisplay) {
		return mithril_default("button.items-center.flex-grow", {
			tabIndex: isDisplay ? TabIndex.Programmatic : undefined,
			class: isDisplay ? `flex ${hasAlarms ? "text-fade" : ""}` : "state-bg button-content button-min-height dropdown-button pt-s pb-s"
		}, option.text);
	}
	showCustomReminderIntervalDialog(onAddAction) {
		let timeReminderValue = 0;
		let timeReminderUnit = AlarmIntervalUnit.MINUTE;
		Dialog.showActionDialog({
			title: "calendarReminderIntervalCustomDialog_title",
			allowOkWithReturn: true,
			child: { view: () => {
				const unitItems = createCustomRepeatRuleUnitValues() ?? [];
				return mithril_default(".flex full-width pt-s", [mithril_default(TextField, {
					type: TextFieldType.Number,
					min: 0,
					label: "calendarReminderIntervalValue_label",
					value: timeReminderValue.toString(),
					oninput: (v) => {
						const time = Number.parseInt(v);
						const isEmpty = v === "";
						if (!Number.isNaN(time) || isEmpty) timeReminderValue = isEmpty ? 0 : Math.abs(time);
					},
					class: "flex-half no-appearance"
				}), mithril_default(DropDownSelector, {
					label: "emptyString_msg",
					selectedValue: timeReminderUnit,
					items: unitItems,
					class: "flex-half pl-s",
					selectionChangedHandler: (selectedValue) => timeReminderUnit = selectedValue,
					disabled: false
				})]);
			} },
			okActionTextId: "add_action",
			okAction: (dialog) => {
				onAddAction(timeReminderValue, timeReminderUnit);
				dialog.close();
			}
		});
	}
};

//#endregion
//#region ../src/common/gui/base/RadioGroup.ts
var RadioGroup = class {
	view({ attrs }) {
		return mithril_default("ul.unstyled-list.flex.col.gap-vpad", {
			ariaLabel: lang.getTranslationText(attrs.ariaLabel),
			role: AriaRole.RadioGroup
		}, attrs.options.map((option) => this.renderOption(attrs.name, option, attrs.selectedOption, attrs.classes?.join(" "), attrs.onOptionSelected, attrs.injectionMap)));
	}
	renderOption(groupName, option, selectedOption, optionClass, onOptionSelected, injectionMap) {
		const name = lang.getTranslationText(groupName);
		const valueString = String(option.value);
		const isSelected = option.value === selectedOption;
		const optionId = `${name}-${valueString}`;
		return mithril_default("li.flex.gap-vpad.cursor-pointer.full-width.flash", {
			class: optionClass ?? "",
			onclick: () => {
				console.log("Clicked?");
				onOptionSelected(option.value);
			}
		}, [mithril_default("input[type=radio].m-0.big-radio.content-accent-accent", {
			name: lang.getTranslationText(groupName),
			value: valueString,
			id: optionId,
			checked: isSelected ? true : null,
			onkeydown: (event) => {
				if (isKeyPressed(event.key, Keys.RETURN)) onOptionSelected(option.value);
				return true;
			}
		}), mithril_default(".flex.flex-column.full-width", [mithril_default("label.cursor-pointer", { for: optionId }, lang.getTranslationText(option.name)), this.getInjection(String(option.value), injectionMap)])]);
	}
	getInjection(key, injectionMap) {
		if (!injectionMap || !injectionMap.has(key)) return null;
		return injectionMap.get(key);
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-view/RepeatRuleEditor.ts
var import_stream$2 = __toESM(require_stream(), 1);
var RepeatRuleEditor = class {
	repeatRuleType = null;
	repeatInterval = 0;
	intervalOptions = (0, import_stream$2.default)([]);
	intervalExpanded = false;
	numberValues = createIntervalValues();
	occurrencesOptions = (0, import_stream$2.default)([]);
	occurrencesExpanded = false;
	repeatOccurrences;
	constructor({ attrs }) {
		if (attrs.model.repeatPeriod != null) this.repeatRuleType = this.getRepeatType(attrs.model.repeatPeriod, attrs.model.repeatInterval, attrs.model.repeatEndType);
		this.intervalOptions(this.numberValues);
		this.occurrencesOptions(this.numberValues);
		this.repeatInterval = attrs.model.repeatInterval;
		this.repeatOccurrences = attrs.model.repeatEndOccurrences;
	}
	getRepeatType(period, interval, endTime) {
		if (interval > 1 || endTime !== EndType.Never) return "CUSTOM";
		return period;
	}
	view({ attrs }) {
		const customRuleOptions = customFrequenciesOptions.map((option) => ({
			...option,
			name: attrs.model.repeatInterval > 1 ? option.name.plural : option.name.singular
		}));
		return mithril_default(".pb.pt.flex.col.gap-vpad.fit-height", {
			class: this.repeatRuleType === "CUSTOM" ? "box-content" : "",
			style: { width: px(attrs.width) }
		}, [
			mithril_default(Card, { style: { padding: `${size.vpad}px` } }, mithril_default(RadioGroup, {
				ariaLabel: "calendarRepeating_label",
				name: "calendarRepeating_label",
				options: createRepeatRuleOptions(),
				selectedOption: this.repeatRuleType,
				onOptionSelected: (option) => {
					this.repeatRuleType = option;
					if (option === "CUSTOM") attrs.model.repeatPeriod = attrs.model.repeatPeriod ?? RepeatPeriod.DAILY;
else {
						attrs.model.repeatInterval = 1;
						attrs.model.repeatEndType = EndType.Never;
						attrs.model.repeatPeriod = option;
						attrs.backAction();
					}
				},
				classes: ["cursor-pointer"]
			})),
			this.renderFrequencyOptions(attrs, customRuleOptions),
			this.renderEndOptions(attrs)
		]);
	}
	renderEndOptions(attrs) {
		if (this.repeatRuleType !== "CUSTOM") return null;
		return mithril_default(".flex.col", [mithril_default("small.uppercase.pb-s.b.text-ellipsis", { style: { color: theme.navigation_button } }, lang.get("calendarRepeatStopCondition_label")), mithril_default(Card, {
			style: { padding: `${size.vpad}px` },
			classes: [
				"flex",
				"col",
				"gap-vpad-s"
			]
		}, [mithril_default(RadioGroup, {
			ariaLabel: "calendarRepeatStopCondition_label",
			name: "calendarRepeatStopCondition_label",
			options: createCustomEndTypeOptions(),
			selectedOption: attrs.model.repeatEndType,
			onOptionSelected: (option) => {
				attrs.model.repeatEndType = option;
			},
			classes: ["cursor-pointer"],
			injectionMap: this.buildInjections(attrs)
		})])]);
	}
	renderFrequencyOptions(attrs, customRuleOptions) {
		if (this.repeatRuleType !== "CUSTOM") return null;
		return mithril_default(".flex.col", [mithril_default("small.uppercase.pb-s.b.text-ellipsis", { style: { color: theme.navigation_button } }, lang.get("intervalFrequency_label")), mithril_default(Card, {
			style: { padding: `0 0 ${size.vpad}px` },
			classes: ["flex", "col"]
		}, [
			this.renderIntervalPicker(attrs),
			mithril_default(Divider, {
				color: theme.button_bubble_bg,
				style: { margin: `0 0 ${size.vpad}px` }
			}),
			mithril_default(RadioGroup, {
				ariaLabel: "intervalFrequency_label",
				name: "intervalFrequency_label",
				options: customRuleOptions,
				selectedOption: attrs.model.repeatPeriod,
				onOptionSelected: (option) => {
					this.updateCustomRule(attrs.model, { intervalFrequency: option });
				},
				classes: [
					"cursor-pointer",
					"capitalize",
					"pl-vpad-m",
					"pr-vpad-m"
				]
			})
		])]);
	}
	buildInjections(attrs) {
		const injectionMap = new Map();
		injectionMap.set(EndType.Count, this.renderEndsPicker(attrs));
		injectionMap.set(EndType.UntilDate, mithril_default(DatePicker, {
			date: attrs.model.repeatEndDateForDisplay,
			onDateSelected: (date) => date && (attrs.model.repeatEndDateForDisplay = date),
			label: "endDate_label",
			useInputButton: true,
			startOfTheWeekOffset: attrs.startOfTheWeekOffset,
			position: PickerPosition.TOP,
			classes: [
				"full-width",
				"flex-grow",
				attrs.model.repeatEndType !== EndType.UntilDate ? "disabled" : ""
			]
		}));
		return injectionMap;
	}
	updateCustomRule(whenModel, customRule) {
		const { interval, intervalFrequency } = customRule;
		if (interval && !isNaN(interval)) whenModel.repeatInterval = interval;
		if (intervalFrequency) whenModel.repeatPeriod = intervalFrequency;
	}
	renderIntervalPicker(attrs) {
		return mithril_default(Select, {
			onchange: (newValue) => {
				if (this.repeatInterval === newValue.value) return;
				this.repeatInterval = newValue.value;
				this.updateCustomRule(attrs.model, { interval: this.repeatInterval });
				mithril_default.redraw.sync();
			},
			onclose: () => {
				this.intervalExpanded = false;
				this.intervalOptions(this.numberValues);
			},
			selected: {
				value: this.repeatInterval,
				name: this.repeatInterval.toString(),
				ariaValue: this.repeatInterval.toString()
			},
			ariaLabel: lang.get("repeatsEvery_label"),
			options: this.intervalOptions,
			noIcon: true,
			expanded: true,
			tabIndex: isApp() ? Number(TabIndex.Default) : Number(TabIndex.Programmatic),
			classes: ["no-appearance"],
			renderDisplay: () => mithril_default(SingleLineTextField, {
				classes: ["border-radius-bottom-0"],
				value: isNaN(this.repeatInterval) ? "" : this.repeatInterval.toString(),
				inputMode: isApp() ? InputMode.NONE : InputMode.TEXT,
				readonly: isApp(),
				oninput: (val) => {
					if (val !== "" && this.repeatInterval === Number(val)) return;
					this.repeatInterval = val === "" ? NaN : Number(val);
					if (!isNaN(this.repeatInterval)) {
						this.intervalOptions(this.numberValues.filter((opt) => opt.value.toString().startsWith(val)));
						this.updateCustomRule(attrs.model, { interval: this.repeatInterval });
					} else this.intervalOptions(this.numberValues);
				},
				ariaLabel: lang.get("repeatsEvery_label"),
				onclick: (e) => {
					e.stopImmediatePropagation();
					if (!this.intervalExpanded) {
						e.target.parentElement?.click();
						this.intervalExpanded = true;
					}
				},
				onfocus: (event) => {
					if (!this.intervalExpanded) {
						event.target.parentElement?.click();
						this.intervalExpanded = true;
					}
				},
				onblur: (event) => {
					if (isNaN(this.repeatInterval)) {
						this.repeatInterval = this.numberValues[0].value;
						this.updateCustomRule(attrs.model, { interval: this.repeatInterval });
					} else if (this.repeatInterval === 0) {
						this.repeatInterval = this.numberValues[0].value;
						this.updateCustomRule(attrs.model, { interval: this.repeatInterval });
					}
				},
				style: { textAlign: "center" },
				max: 256,
				min: 1,
				type: TextFieldType.Number
			}),
			renderOption: (option) => mithril_default("button.items-center.flex-grow", { class: "state-bg button-content dropdown-button pt-s pb-s button-min-height" }, option.name),
			keepFocus: true
		});
	}
	renderEndsPicker(attrs) {
		return mithril_default(Select, {
			onchange: (newValue) => {
				if (this.repeatOccurrences === newValue.value) return;
				this.repeatOccurrences = newValue.value;
				attrs.model.repeatEndOccurrences = newValue.value;
			},
			onclose: () => {
				this.occurrencesExpanded = false;
				this.occurrencesOptions(this.numberValues);
			},
			selected: {
				value: this.repeatOccurrences,
				name: this.repeatOccurrences.toString(),
				ariaValue: this.repeatOccurrences.toString()
			},
			ariaLabel: lang.get("occurrencesCount_label"),
			options: this.occurrencesOptions,
			noIcon: true,
			expanded: true,
			tabIndex: isApp() ? Number(TabIndex.Default) : Number(TabIndex.Programmatic),
			classes: ["no-appearance"],
			renderDisplay: () => mithril_default(SingleLineTextField, {
				classes: [
					"tutaui-button-outline",
					"text-center",
					"border-content-message-bg"
				],
				value: isNaN(this.repeatOccurrences) ? "" : this.repeatOccurrences.toString(),
				inputMode: isApp() ? InputMode.NONE : InputMode.TEXT,
				readonly: isApp(),
				oninput: (val) => {
					if (val !== "" && this.repeatOccurrences === Number(val)) return;
					this.repeatOccurrences = val === "" ? NaN : Number(val);
					if (!isNaN(this.repeatOccurrences)) {
						this.occurrencesOptions(this.numberValues.filter((opt) => opt.value.toString().startsWith(val)));
						attrs.model.repeatEndOccurrences = this.repeatOccurrences;
					} else this.occurrencesOptions(this.numberValues);
				},
				ariaLabel: lang.get("occurrencesCount_label"),
				style: { textAlign: "center" },
				onclick: (e) => {
					e.stopImmediatePropagation();
					if (!this.occurrencesExpanded) {
						e.target.parentElement?.click();
						this.occurrencesExpanded = true;
					}
				},
				onfocus: (event) => {
					if (!this.occurrencesExpanded) {
						event.target.parentElement?.click();
						this.occurrencesExpanded = true;
					}
				},
				onblur: (event) => {
					if (isNaN(this.repeatOccurrences)) {
						this.repeatOccurrences = this.numberValues[0].value;
						attrs.model.repeatEndOccurrences = this.repeatOccurrences;
					} else if (this.repeatOccurrences === 0) {
						this.repeatOccurrences = this.numberValues[0].value;
						attrs.model.repeatEndOccurrences = this.repeatOccurrences;
					}
				},
				max: 256,
				min: 1,
				type: TextFieldType.Number
			}),
			renderOption: (option) => mithril_default("button.items-center.flex-grow", { class: "state-bg button-content dropdown-button pt-s pb-s button-min-height" }, option.name),
			keepFocus: true
		});
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-view/CalendarEventEditView.ts
var import_stream$1 = __toESM(require_stream(), 1);
let EditorPages = function(EditorPages$1) {
	EditorPages$1[EditorPages$1["MAIN"] = 0] = "MAIN";
	EditorPages$1[EditorPages$1["REPEAT_RULES"] = 1] = "REPEAT_RULES";
	EditorPages$1[EditorPages$1["GUESTS"] = 2] = "GUESTS";
	return EditorPages$1;
}({});
var CalendarEventEditView = class {
	timeFormat;
	startOfTheWeekOffset;
	defaultAlarms;
	transitionPage = null;
	hasAnimationEnded = true;
	pages = new Map();
	pagesWrapperDomElement;
	allowRenderMainPage = (0, import_stream$1.default)(true);
	dialogHeight = null;
	pageWidth = -1;
	translate = 0;
	constructor(vnode) {
		this.timeFormat = vnode.attrs.timeFormat;
		this.startOfTheWeekOffset = vnode.attrs.startOfTheWeekOffset;
		this.defaultAlarms = vnode.attrs.defaultAlarms;
		if (vnode.attrs.model.operation == CalendarOperation.Create) {
			const initialAlarms = vnode.attrs.defaultAlarms.get(vnode.attrs.model.editModels.whoModel.selectedCalendar.group._id) ?? [];
			vnode.attrs.model.editModels.alarmModel.addAll(initialAlarms);
		}
		this.pages.set(EditorPages.REPEAT_RULES, this.renderRepeatRulesPage);
		this.pages.set(EditorPages.GUESTS, this.renderGuestsPage);
		vnode.attrs.currentPage.map((page) => {
			this.hasAnimationEnded = false;
			if (page === EditorPages.MAIN) {
				this.allowRenderMainPage(true);
				this.translate = 0;
			}
		});
		this.allowRenderMainPage.map((allowRendering) => {
			return this.handleEditorStatus(allowRendering, vnode);
		});
	}
	onremove(vnode) {
		vnode.attrs.currentPage.end(true);
		this.allowRenderMainPage.end(true);
	}
	handleEditorStatus(allowRendering, vnode) {
		if (allowRendering && vnode.attrs.currentPage() === EditorPages.MAIN) {
			if (vnode.attrs.descriptionEditor.editor.domElement) vnode.attrs.descriptionEditor.editor.domElement.tabIndex = Number(TabIndex.Default);
			return vnode.attrs.descriptionEditor.setEnabled(true);
		}
		if (vnode.attrs.descriptionEditor.editor.domElement) vnode.attrs.descriptionEditor.editor.domElement.tabIndex = Number(TabIndex.Programmatic);
		vnode.attrs.descriptionEditor.setEnabled(false);
	}
	oncreate(vnode) {
		this.pagesWrapperDomElement = vnode.dom;
		this.pagesWrapperDomElement.addEventListener("transitionend", () => {
			if (vnode.attrs.currentPage() !== EditorPages.MAIN) {
				setTimeout(() => {
					this.allowRenderMainPage(false);
				}, DefaultAnimationTime);
				mithril_default.redraw();
				return;
			}
			this.transitionPage = vnode.attrs.currentPage();
			this.hasAnimationEnded = true;
			setTimeout(() => {
				this.allowRenderMainPage(true);
				mithril_default.redraw();
			}, DefaultAnimationTime);
		});
	}
	onupdate(vnode) {
		const dom = vnode.dom;
		if (this.dialogHeight == null && dom.parentElement) {
			this.dialogHeight = dom.parentElement.clientHeight;
			vnode.dom.style.height = px(this.dialogHeight);
		}
		if (this.pageWidth == -1 && dom.parentElement) {
			this.pageWidth = dom.parentElement.clientWidth - size.hpad_large * 2;
			vnode.dom.style.width = px(this.pageWidth * 2 + size.vpad_xxl);
			mithril_default.redraw();
		}
	}
	view(vnode) {
		return mithril_default(".flex.gap-vpad-xxl.fit-content.transition-transform", { style: { transform: `translateX(${this.translate}px)` } }, [this.renderMainPage(vnode), this.renderPage(vnode)]);
	}
	renderPage(vnode) {
		if (this.hasAnimationEnded || this.transitionPage == null) return this.pages.get(vnode.attrs.currentPage())?.apply(this, [vnode]);
		return this.pages.get(this.transitionPage)?.apply(this, [vnode]);
	}
	renderGuestsPage({ attrs: { model, recipientsSearch } }) {
		return mithril_default(AttendeeListEditor, {
			recipientsSearch,
			logins: locator.logins,
			model,
			width: this.pageWidth
		});
	}
	renderTitle(attrs) {
		const { model } = attrs;
		return mithril_default(Card, { style: { padding: "0" } }, mithril_default(SingleLineTextField, {
			value: model.editModels.summary.content,
			oninput: (newValue) => {
				model.editModels.summary.content = newValue;
			},
			ariaLabel: lang.get("title_placeholder"),
			placeholder: lang.get("title_placeholder"),
			disabled: !model.isFullyWritable(),
			style: { fontSize: px(size.font_size_base * 1.25) },
			type: TextFieldType.Text
		}));
	}
	renderReadonlyMessage(attrs) {
		const { model } = attrs;
		const makeMessage = (message) => mithril_default(InfoBanner, {
			message: () => mithril_default(".small.selectable", lang.get(message)),
			icon: Icons.People,
			type: BannerType.Info,
			buttons: []
		});
		switch (model.getReadonlyReason()) {
			case ReadonlyReason.SHARED: return makeMessage("cannotEditFullEvent_msg");
			case ReadonlyReason.SINGLE_INSTANCE: return makeMessage("cannotEditSingleInstance_msg");
			case ReadonlyReason.NOT_ORGANIZER: return makeMessage("cannotEditNotOrganizer_msg");
			case ReadonlyReason.UNKNOWN: return makeMessage("cannotEditEvent_msg");
			case ReadonlyReason.NONE: return null;
		}
	}
	renderEventTimeEditor(attrs) {
		const padding = px(size.vpad_small);
		return mithril_default(Card, { style: { padding: `${padding} 0 ${padding} ${padding}` } }, mithril_default(EventTimeEditor, {
			editModel: attrs.model.editModels.whenModel,
			timeFormat: this.timeFormat,
			startOfTheWeekOffset: this.startOfTheWeekOffset,
			disabled: !attrs.model.isFullyWritable()
		}));
	}
	renderRepeatRuleNavButton({ model, navigationCallback }) {
		const disabled = !model.canEditSeries();
		return mithril_default(Card, { classes: [
			"button-min-height",
			"flex",
			"items-center"
		] }, mithril_default(".flex.gap-vpad-s.items-center.flex-grow", [mithril_default(".flex.items-center", [mithril_default(Icon, {
			icon: Icons.Sync,
			style: { fill: getColors(ButtonColor.Content).button },
			title: lang.get("calendarRepeating_label"),
			size: IconSize.Medium
		})]), mithril_default("button.flex.items-center.justify-between.flex-grow.flash", {
			onclick: (event) => {
				this.transitionTo(EditorPages.REPEAT_RULES, navigationCallback);
			},
			disabled,
			class: disabled ? "disabled cursor-disabled" : ""
		}, [this.getTranslatedRepeatRule(model.editModels.whenModel.result.repeatRule, model.editModels.whenModel.isAllDay), mithril_default(Icon, {
			icon: Icons.ArrowForward,
			class: "flex items-center",
			style: { fill: getColors(ButtonColor.Content).button },
			title: lang.get("calendarRepeating_label"),
			size: IconSize.Medium
		})])]));
	}
	transitionTo(target, navigationCallback) {
		this.hasAnimationEnded = false;
		this.transitionPage = target;
		this.translate = -(this.pageWidth + size.vpad_xxl);
		navigationCallback(target);
	}
	renderGuestsNavButton({ navigationCallback, model }) {
		return mithril_default(Card, { classes: [
			"button-min-height",
			"flex",
			"items-center"
		] }, mithril_default(".flex.gap-vpad-s.flash.items-center.flex-grow", [mithril_default(".flex.items-center", [mithril_default(Icon, {
			icon: Icons.People,
			style: { fill: getColors(ButtonColor.Content).button },
			title: lang.get("calendarRepeating_label"),
			size: IconSize.Medium
		})]), mithril_default("button.flex.items-center.justify-between.flex-grow.flash", { onclick: (event) => {
			this.transitionTo(EditorPages.GUESTS, navigationCallback);
		} }, [lang.get("guests_label"), mithril_default(".flex", [model.editModels.whoModel.guests.length > 0 ? mithril_default("span", model.editModels.whoModel.guests.length) : null, mithril_default(Icon, {
			icon: Icons.ArrowForward,
			class: "flex items-center",
			style: { fill: getColors(ButtonColor.Content).button },
			title: lang.get("guests_label"),
			size: IconSize.Medium
		})])])]));
	}
	renderCalendarPicker(vnode) {
		const { model, groupColors } = vnode.attrs;
		const availableCalendars = model.editModels.whoModel.getAvailableCalendars();
		const options = availableCalendars.map((calendarInfo) => {
			const name = getSharedGroupName(calendarInfo.groupInfo, model.userController, calendarInfo.shared);
			return {
				name,
				color: "#" + (groupColors.get(calendarInfo.group._id) ?? defaultCalendarColor),
				value: calendarInfo,
				ariaValue: name
			};
		});
		const selectedCalendarInfo = model.editModels.whoModel.selectedCalendar;
		const selectedCalendarName = getSharedGroupName(selectedCalendarInfo.groupInfo, model.userController, selectedCalendarInfo.shared);
		let selected = {
			name: selectedCalendarName,
			color: "#" + (groupColors.get(selectedCalendarInfo.group._id) ?? defaultCalendarColor),
			value: model.editModels.whoModel.selectedCalendar,
			ariaValue: selectedCalendarName
		};
		return mithril_default(Card, { style: { padding: "0" } }, mithril_default(Select, {
			onchange: (val) => {
				model.editModels.alarmModel.removeAll();
				model.editModels.alarmModel.addAll(this.defaultAlarms.get(val.value.group._id) ?? []);
				model.editModels.whoModel.selectedCalendar = val.value;
			},
			options: (0, import_stream$1.default)(options),
			expanded: true,
			selected,
			classes: [
				"button-min-height",
				"pl-vpad-s",
				"pr-vpad-s"
			],
			renderOption: (option) => this.renderCalendarOptions(option, deepEqual(option.value, selected.value), false),
			renderDisplay: (option) => this.renderCalendarOptions(option, false, true),
			ariaLabel: lang.get("calendar_label"),
			disabled: !model.canChangeCalendar() || availableCalendars.length < 2
		}));
	}
	renderCalendarOptions(option, isSelected, isDisplay) {
		return mithril_default(".flex.items-center.gap-vpad-s.flex-grow", { class: `${isDisplay ? "" : "state-bg plr-button button-content dropdown-button pt-s pb-s button-min-height"}` }, [mithril_default("div", { style: {
			width: px(size.hpad_large),
			height: px(size.hpad_large),
			borderRadius: "50%",
			backgroundColor: option.color,
			marginInline: px(size.vpad_xsm / 2)
		} }), mithril_default("span", { style: { color: isSelected ? theme.content_button_selected : undefined } }, option.name)]);
	}
	renderRemindersEditor(vnode) {
		if (!vnode.attrs.model.editModels.alarmModel.canEditReminders) return null;
		const { alarmModel } = vnode.attrs.model.editModels;
		return mithril_default(Card, { classes: [
			"button-min-height",
			"flex",
			"items-center"
		] }, mithril_default(".flex.gap-vpad-s.items-start.flex-grow", [mithril_default(".flex", { class: alarmModel.alarms.length === 0 ? "items-center" : "items-start" }, [mithril_default(Icon, {
			icon: Icons.Clock,
			style: { fill: getColors(ButtonColor.Content).button },
			title: lang.get("reminderBeforeEvent_label"),
			size: IconSize.Medium
		})]), mithril_default(RemindersEditor, {
			alarms: alarmModel.alarms,
			addAlarm: alarmModel.addAlarm.bind(alarmModel),
			removeAlarm: alarmModel.removeAlarm.bind(alarmModel),
			label: "reminderBeforeEvent_label",
			useNewEditor: true
		})]));
	}
	renderLocationField(vnode) {
		const { model } = vnode.attrs;
		return mithril_default(Card, { style: { padding: "0" } }, mithril_default(".flex.gap-vpad-s.items-center", mithril_default(SingleLineTextField, {
			value: model.editModels.location.content,
			oninput: (newValue) => {
				model.editModels.location.content = newValue;
			},
			classes: ["button-min-height"],
			ariaLabel: lang.get("location_label"),
			placeholder: lang.get("location_label"),
			disabled: !model.isFullyWritable(),
			leadingIcon: {
				icon: Icons.Pin,
				color: getColors(ButtonColor.Content).button
			},
			type: TextFieldType.Text
		})));
	}
	renderDescriptionEditor(vnode) {
		return mithril_default(Card, {
			classes: ["child-text-editor", "rel"],
			style: { padding: "0" }
		}, [vnode.attrs.descriptionEditor.isEmpty() && !vnode.attrs.descriptionEditor.isActive() ? mithril_default("span.text-editor-placeholder", lang.get("description_label")) : null, mithril_default(vnode.attrs.descriptionEditor)]);
	}
	renderMainPage(vnode) {
		return mithril_default(".pb.pt.flex.col.gap-vpad.fit-height.box-content", { style: {
			transform: "translate(0)",
			color: theme.button_bubble_fg,
			"pointer-events": `${this.allowRenderMainPage() ? "auto" : "none"}`,
			width: px(this.pageWidth)
		} }, [this.allowRenderMainPage() ? mithril_default.fragment({}, [
			this.renderReadonlyMessage(vnode.attrs),
			this.renderTitle(vnode.attrs),
			this.renderEventTimeEditor(vnode.attrs),
			this.renderCalendarPicker(vnode),
			this.renderRepeatRuleNavButton(vnode.attrs),
			this.renderRemindersEditor(vnode),
			this.renderGuestsNavButton(vnode.attrs),
			this.renderLocationField(vnode)
		]) : null, this.renderDescriptionEditor(vnode)]);
	}
	renderRepeatRulesPage({ attrs: { model, navigationCallback } }) {
		const { whenModel } = model.editModels;
		return mithril_default(RepeatRuleEditor, {
			model: whenModel,
			startOfTheWeekOffset: this.startOfTheWeekOffset,
			width: this.pageWidth,
			backAction: () => navigationCallback(EditorPages.MAIN)
		});
	}
	getTranslatedRepeatRule(rule, isAllDay) {
		if (rule == null) return lang.get("calendarRepeatIntervalNoRepeat_label");
		const frequency = formatRepetitionFrequency(rule);
		return frequency ? frequency + formatRepetitionEnd(rule, isAllDay) : lang.get("unknownRepetition_msg");
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventeditor-view/CalendarEventEditDialog.ts
var import_stream = __toESM(require_stream(), 1);
var ConfirmationResult = function(ConfirmationResult$1) {
	ConfirmationResult$1[ConfirmationResult$1["Cancel"] = 0] = "Cancel";
	ConfirmationResult$1[ConfirmationResult$1["Continue"] = 1] = "Continue";
	return ConfirmationResult$1;
}(ConfirmationResult || {});
var EventEditorDialog = class {
	currentPage = (0, import_stream.default)(EditorPages.MAIN);
	dialog = null;
	headerDom = null;
	constructor() {}
	left() {
		if (this.currentPage() === EditorPages.MAIN) return [{
			label: "cancel_action",
			click: () => this.dialog?.close(),
			type: ButtonType.Secondary
		}];
		return [{
			label: "back_action",
			click: () => this.currentPage(EditorPages.MAIN),
			type: ButtonType.Secondary
		}];
	}
	right(okAction) {
		if (this.currentPage() === EditorPages.MAIN) return [{
			label: "save_action",
			click: (event, dom) => okAction(dom),
			type: ButtonType.Primary
		}];
		return [];
	}
	/**
	* the generic way to open any calendar edit dialog. the caller should know what to do after the
	* dialog is closed.
	*/
	async showCalendarEventEditDialog(model, responseMail, handler) {
		const recipientsSearch = await locator.recipientsSearchModel();
		const { HtmlEditor } = await import("./HtmlEditor-hXJhB7P2.js");
		const groupSettings = locator.logins.getUserController().userSettingsGroupRoot.groupSettings;
		const groupColors = groupSettings.reduce((acc, gc) => {
			acc.set(gc.group, gc.color);
			return acc;
		}, new Map());
		const defaultAlarms = groupSettings.reduce((acc, gc) => {
			acc.set(gc.group, gc.defaultAlarmsList.map((alarm) => parseAlarmInterval(alarm.trigger)));
			return acc;
		}, new Map());
		const descriptionText = convertTextToHtml(model.editModels.description.content);
		const descriptionEditor = new HtmlEditor().setShowOutline(true).setMinHeight(200).setEnabled(true).setValue(descriptionText);
		const okAction = (dom) => {
			model.editModels.description.content = descriptionEditor.getTrimmedValue();
			handler(dom.getBoundingClientRect(), () => dialog.close());
		};
		const summary = model.editModels.summary.content;
		const heading = summary.trim().length > 0 ? lang.makeTranslation("summary", summary) : "createEvent_label";
		const navigationCallback = (targetPage) => {
			this.currentPage(targetPage);
		};
		const dialog = Dialog.editMediumDialog({
			left: this.left.bind(this),
			middle: heading,
			right: this.right.bind(this, okAction),
			create: (dom) => {
				this.headerDom = dom;
			}
		}, CalendarEventEditView, {
			model,
			recipientsSearch,
			descriptionEditor,
			startOfTheWeekOffset: getStartOfTheWeekOffsetForUser(locator.logins.getUserController().userSettingsGroupRoot),
			timeFormat: getTimeFormatForUser(locator.logins.getUserController().userSettingsGroupRoot),
			groupColors,
			defaultAlarms,
			navigationCallback,
			currentPage: this.currentPage
		}, {
			height: "100%",
			"background-color": theme.navigation_bg
		}).addShortcut({
			key: Keys.ESC,
			exec: () => dialog.close(),
			help: "close_alt"
		}).addShortcut({
			key: Keys.S,
			ctrlOrCmd: true,
			exec: () => okAction(assertNotNull(this.headerDom, "headerDom was null")),
			help: "save_action"
		});
		if (client.isMobileDevice()) dialog.setFocusOnLoadFunction(noOp);
		this.dialog = dialog;
		dialog.show();
	}
	/**
	* show an edit dialog for an event that does not exist on the server yet (or anywhere else)
	*
	* will unconditionally send invites on save.
	* @param model the calendar event model used to edit and save the event
	*/
	async showNewCalendarEventEditDialog(model) {
		let finished = false;
		const okAction = async (posRect, finish) => {
			/** new event, so we always want to send invites. */
			model.editModels.whoModel.shouldSendUpdates = true;
			if (finished) return;
			try {
				const result = await model.apply();
				if (result === EventSaveResult.Saved) {
					finished = true;
					finish();
					await handleRatingByEvent();
				}
			} catch (e) {
				if (e instanceof UserError) showUserError(e);
else if (e instanceof UpgradeRequiredError) await showPlanUpgradeRequiredDialog(e.plans);
else throw e;
			}
		};
		return this.showCalendarEventEditDialog(model, null, okAction);
	}
	/**
	* show a dialog that allows to edit a calendar event that already exists.
	*
	* on save, will validate external passwords, account type and user intent before actually saving and sending updates/invites/cancellations.
	*
	* @param model the calendar event model used to edit & save the event
	* @param identity the identity of the event to edit
	* @param responseMail a mail containing an invite and/or update for this event in case we need to reply to the organizer
	*/
	async showExistingCalendarEventEditDialog(model, identity, responseMail = null) {
		let finished = false;
		if (identity.uid == null) throw new ProgrammingError("tried to edit existing event without uid, this is impossible for certain edit operations.");
		const okAction = async (posRect, finish) => {
			if (finished || await this.askUserIfUpdatesAreNeededOrCancel(model) === ConfirmationResult.Cancel) return;
			try {
				const result = await model.apply();
				if (result === EventSaveResult.Saved || result === EventSaveResult.NotFound) {
					finished = true;
					finish();
					if (result === EventSaveResult.NotFound) Dialog.message("eventNoLongerExists_msg");
				}
			} catch (e) {
				if (e instanceof UserError) showUserError(e);
else if (e instanceof UpgradeRequiredError) await showPlanUpgradeRequiredDialog(e.plans);
else throw e;
			}
		};
		await this.showCalendarEventEditDialog(model, responseMail, okAction);
	}
	/** if there are update worthy changes on the model, ask the user what to do with them.
	* @returns {ConfirmationResult} Cancel if the whole process should be cancelled, Continue if the user selected whether to send updates and the saving
	* should proceed.
	* */
	async askUserIfUpdatesAreNeededOrCancel(model) {
		if (model.isAskingForUpdatesNeeded()) switch (await askIfShouldSendCalendarUpdatesToAttendees()) {
			case "yes":
				model.editModels.whoModel.shouldSendUpdates = true;
				break;
			case "no": break;
			case "cancel":
				console.log("not saving event: user cancelled update sending.");
				return ConfirmationResult.Cancel;
		}
		return ConfirmationResult.Continue;
	}
};

//#endregion
//#region ../src/calendar-app/calendar/gui/eventpopup/CalendarEventPreviewViewModel.ts
var CalendarEventPreviewViewModel = class {
	canEdit;
	canDelete;
	canSendUpdates;
	/** for editing, an event that has only one non-deleted instance is still considered repeating
	* because we might reschedule that instance and then unexclude some deleted instances.
	*
	* the ability to edit a single instance also depends on the event type:
	*    * OWN -> I can do what I want
	*    * SHARED_RW -> can edit single instance as if it was my own (since single instance editing locks attendees anyway)
	*    * SHARED_RO, LOCKED, EXTERNAL -> cannot edit at all
	*    * INVITE -> we're not the organizer, we can only set our own attendance globally and send it back to the organizer.
	*          probably the best reason to make single-instance attendee editing possible asap.
	*/
	isRepeatingForEditing;
	sanitizedDescription = null;
	processing = false;
	_ownAttendee;
	/**
	*
	* @param calendarEvent the event to display in the popup
	* @param calendarModel the calendar model where the event can be updated/deleted
	* @param eventType
	* @param hasBusinessFeature if the current user is allowed to do certain operations.
	* @param ownAttendee will be cloned to have a copy that's not influencing the actual event but can be changed to quickly update the UI
	* @param lazyIndexEntry async function to resolve the progenitor of the shown event
	* @param eventModelFactory
	* @param uiUpdateCallback
	*/
	constructor(calendarEvent, calendarModel, eventType, hasBusinessFeature, ownAttendee, lazyIndexEntry, eventModelFactory, uiUpdateCallback = mithril_default.redraw) {
		this.calendarEvent = calendarEvent;
		this.calendarModel = calendarModel;
		this.eventType = eventType;
		this.hasBusinessFeature = hasBusinessFeature;
		this.lazyIndexEntry = lazyIndexEntry;
		this.eventModelFactory = eventModelFactory;
		this.uiUpdateCallback = uiUpdateCallback;
		this._ownAttendee = clone(ownAttendee);
		if (this.calendarEvent._ownerGroup == null) {
			this.canEdit = false;
			this.canDelete = false;
			this.canSendUpdates = false;
		} else {
			this.canEdit = this.eventType === EventType.OWN || this.eventType === EventType.SHARED_RW || this.eventType === EventType.LOCKED || this.eventType === EventType.INVITE;
			this.canDelete = this.canEdit || this.eventType === EventType.INVITE;
			this.canSendUpdates = hasBusinessFeature && this.eventType === EventType.OWN && getNonOrganizerAttendees(calendarEvent).length > 0;
		}
		this.isRepeatingForEditing = (calendarEvent.repeatRule != null || calendarEvent.recurrenceId != null) && (eventType === EventType.OWN || eventType === EventType.SHARED_RW);
	}
	/** for deleting, an event that has only one non-deleted instance behaves as if it wasn't repeating
	* because deleting the last instance is the same as deleting the whole event from the pov of the user.
	*/
	async isRepeatingForDeleting() {
		const index = await this.lazyIndexEntry();
		if (index == null) return false;
		return calendarEventHasMoreThanOneOccurrencesLeft(index);
	}
	get ownAttendee() {
		return this._ownAttendee;
	}
	/** return an object enabling us to set and display the participation correctly if this is an event we're invited to, null otherwise.
	* note that the Promise<unknown> type on setParticipation prevents us from leaking errors when consumers call it and try to catch errors without
	* awaiting it (they get an async call without await warning) */
	getParticipationSetterAndThen(action) {
		if (this.ownAttendee == null || this.eventType !== EventType.INVITE) return null;
		return {
			ownAttendee: this.ownAttendee,
			setParticipation: async (status) => {
				await this.setOwnAttendance(status);
				action();
			}
		};
	}
	async setOwnAttendance(status) {
		if (this.calendarEvent.organizer == null || this.ownAttendee == null || this.processing || this._ownAttendee?.status === status) return;
		const oldStatus = this.ownAttendee.status;
		this.processing = true;
		try {
			this.ownAttendee.status = status;
			this.uiUpdateCallback();
			const model = await this.eventModelFactory(CalendarOperation.EditAll);
			if (model) {
				model.editModels.whoModel.setOwnAttendance(status);
				model.editModels.whoModel.isConfidential = this.calendarEvent.invitedConfidentially ?? false;
				await model.apply();
			} else this.ownAttendee.status = oldStatus;
		} catch (e) {
			this.ownAttendee.status = oldStatus;
			throw e;
		} finally {
			this.processing = false;
		}
	}
	/** add an exclusion for this event instances start time on the original event.
	* if this is a rescheduled instance, we will just delete the event because the progenitor already
	* has an exclusion for this time.
	* */
	async deleteSingle() {
		try {
			const model = await this.eventModelFactory(CalendarOperation.DeleteThis);
			await model?.apply();
		} catch (e) {
			if (!(e instanceof NotFoundError)) throw e;
		}
	}
	async deleteAll() {
		try {
			const model = await this.eventModelFactory(CalendarOperation.DeleteAll);
			await model?.apply();
		} catch (e) {
			if (!(e instanceof NotFoundError)) throw e;
		}
	}
	async editSingle() {
		const model = await this.eventModelFactory(CalendarOperation.EditThis);
		if (model == null) return;
		try {
			const eventEditor = new EventEditorDialog();
			return await eventEditor.showExistingCalendarEventEditDialog(model, {
				uid: this.calendarEvent.uid,
				sequence: this.calendarEvent.sequence,
				recurrenceId: this.calendarEvent.startTime
			});
		} catch (err) {
			if (err instanceof NotFoundError) console.log("occurrence not found when clicking on the event");
else throw err;
		}
		throw new ProgrammingError("not implemented");
	}
	async editAll() {
		const model = await this.eventModelFactory(CalendarOperation.EditAll);
		if (model == null) return;
		try {
			const eventEditor = new EventEditorDialog();
			return await eventEditor.showExistingCalendarEventEditDialog(model, {
				uid: this.calendarEvent.uid,
				sequence: this.calendarEvent.sequence,
				recurrenceId: null
			});
		} catch (err) {
			if (err instanceof NotFoundError) console.log("calendar event not found when clicking on the event");
else throw err;
		}
	}
	async sendUpdates() {
		const model = await this.eventModelFactory(CalendarOperation.EditAll);
		if (model == null) return EventSaveResult.Failed;
		try {
			model.editModels.whoModel.shouldSendUpdates = true;
			await model.apply();
			return EventSaveResult.Saved;
		} finally {
			model.editModels.whoModel.shouldSendUpdates = false;
		}
	}
	async sanitizeDescription() {
		const { htmlSanitizer } = await import("./HtmlSanitizer-DJqF9m1z.js");
		this.sanitizedDescription = htmlSanitizer.sanitizeHTML(this.calendarEvent.description, { blockExternalContent: true }).html;
	}
	getSanitizedDescription() {
		return this.sanitizedDescription;
	}
};

//#endregion
export { CalendarEventPreviewViewModel };
//# sourceMappingURL=CalendarEventPreviewViewModel-CWG_-5I4.js.map