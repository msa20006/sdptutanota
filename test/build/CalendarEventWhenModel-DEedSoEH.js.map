{"version":3,"file":"CalendarEventWhenModel-DEedSoEH.js","names":["hour: number","minute: number","date: Date","timeString: string","baseDate?: Date","baseDate: Date","zone: string","otherTime: Time","amPmFormat: boolean","initialValues: Partial<Stripped<CalendarEvent>>","zone: string","uiUpdateCallback: () => void","initialTimes: CalendarEventTimes","value: boolean","v: Time | null","value: { minutes: number }","value: Date","repeatPeriod: RepeatPeriod | null","interval: number","endType: EndType","endValue: number","newRepeatEndDate: Date","date: Date","diff: DurationLikeObject","repeatRule: RepeatRule | null","newRepeat: RepeatRule | null","timeZone: string","progenitor: CalendarEvent","recurrenceIds: ReadonlyArray<Date>"],"sources":["../../src/common/calendar/date/Time.ts","../../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventWhenModel.ts"],"sourcesContent":["import { pad } from \"@tutao/tutanota-utils\"\nimport { DateTime } from \"luxon\"\n\n/**\n * A wrapper around time handling for the calendar stuff, mostly for the CalendarEventWhenModel\n */\nexport class Time {\n\treadonly hour: number\n\treadonly minute: number\n\n\tconstructor(hour: number, minute: number) {\n\t\tthis.hour = Math.floor(hour) % 24\n\t\tthis.minute = Math.floor(minute) % 60\n\t}\n\n\t/**\n\t * create a time by extracting hour and minute from a date object.\n\t * @param date the date to extract the time from\n\t * NOTE: all calculations are done in local time.\n\t */\n\tstatic fromDate(date: Date): Time {\n\t\treturn new Time(date.getHours(), date.getMinutes())\n\t}\n\n\tstatic fromDateTime({ hour, minute }: DateTime): Time {\n\t\treturn new Time(hour, minute)\n\t}\n\n\t/**\n\t * Accepts 2, 2:30, 2:5, 02:05, 02:30, 24:30, 2430, 12:30pm, 12:30 p.m.\n\t */\n\tstatic parseFromString(timeString: string): Time | null {\n\t\tlet suffix // am/pm indicator or undefined\n\n\t\tlet hours // numeric hours\n\n\t\tlet minutes // numeric minutes\n\n\t\t// See if the time includes a colon separating hh:mm\n\t\tlet mt = timeString.match(/^(\\d{1,2}):(\\d{1,2})\\s*(am|pm|a\\.m\\.|p\\.m\\.)?$/i)\n\n\t\tif (mt != null) {\n\t\t\tsuffix = mt[3]\n\t\t\thours = parseInt(mt[1], 10)\n\t\t\tminutes = parseInt(mt[2], 10)\n\t\t} else {\n\t\t\t// Interpret 127am as 1:27am or 2311 as 11:11pm, e.g.\n\t\t\tmt = timeString.match(/^(\\d{1,4})\\s*(am|pm|a\\.m\\.|p\\.m\\.)?$/i)\n\n\t\t\tif (mt != null) {\n\t\t\t\tsuffix = mt[2]\n\t\t\t\tconst digits = mt[1]\n\n\t\t\t\t// Hours only?\n\t\t\t\tif (digits.length <= 2) {\n\t\t\t\t\thours = parseInt(digits, 10)\n\t\t\t\t\tminutes = 0\n\t\t\t\t} else {\n\t\t\t\t\thours = parseInt(digits.substring(0, digits.length - 2), 10)\n\t\t\t\t\tminutes = parseInt(digits.slice(-2), 10)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(hours) || isNaN(minutes) || minutes > 59) {\n\t\t\treturn null\n\t\t}\n\n\t\tif (suffix) {\n\t\t\tsuffix = suffix.toUpperCase()\n\t\t}\n\n\t\tif (suffix === \"PM\" || suffix === \"P.M.\") {\n\t\t\tif (hours > 12) return null\n\t\t\tif (hours !== 12) hours = hours + 12\n\t\t} else if (suffix === \"AM\" || suffix === \"A.M.\") {\n\t\t\tif (hours > 12) return null\n\t\t\tif (hours === 12) hours = 0\n\t\t} else if (hours > 23) {\n\t\t\treturn null\n\t\t}\n\n\t\treturn new Time(hours, minutes)\n\t}\n\n\t/**\n\t * convert into a date\n\t * if base date is set it will use the date values from that,\n\t * otherwise it will use the current date.\n\t *\n\t * NOTE: calculations are done in the local time.\n\t */\n\ttoDate(baseDate?: Date): Date {\n\t\tconst date = baseDate ? new Date(baseDate) : new Date()\n\t\tdate.setHours(this.hour)\n\t\tdate.setMinutes(this.minute)\n\t\tdate.setSeconds(0)\n\t\tdate.setMilliseconds(0)\n\t\treturn date\n\t}\n\n\ttoDateTime(baseDate: Date, zone: string): DateTime {\n\t\treturn DateTime.fromJSDate(baseDate, { zone }).set(this)\n\t}\n\n\tequals(otherTime: Time): boolean {\n\t\treturn this.hour === otherTime.hour && this.minute === otherTime.minute\n\t}\n\n\ttoString(amPmFormat: boolean): string {\n\t\treturn amPmFormat ? this.to12HourString() : this.to24HourString()\n\t}\n\n\tto12HourString(): string {\n\t\tconst minutesString = pad(this.minute, 2)\n\n\t\tif (this.hour === 0) {\n\t\t\treturn `12:${minutesString} am`\n\t\t} else if (this.hour === 12) {\n\t\t\treturn `12:${minutesString} pm`\n\t\t} else if (this.hour > 12) {\n\t\t\treturn `${this.hour - 12}:${minutesString} pm`\n\t\t} else {\n\t\t\treturn `${this.hour}:${minutesString} am`\n\t\t}\n\t}\n\n\tto24HourString(): string {\n\t\tconst hours = pad(this.hour, 2)\n\t\tconst minutes = pad(this.minute, 2)\n\t\treturn `${hours}:${minutes}`\n\t}\n\n\ttoObject(): {\n\t\thours: number\n\t\tminutes: number\n\t} {\n\t\treturn {\n\t\t\thours: this.hour,\n\t\t\tminutes: this.minute,\n\t\t}\n\t}\n}\n","import { CalendarEventTimes, getAllDayDateUTC, getEventWithDefaultTimes, isAllDayEvent } from \"../../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { Time } from \"../../../../common/calendar/date/Time.js\"\nimport { DateTime, DurationLikeObject } from \"luxon\"\nimport {\n\tareExcludedDatesEqual,\n\tareRepeatRulesEqual,\n\tgetAllDayDateUTCFromZone,\n\tgetEventEnd,\n\tgetEventStart,\n\tgetRepeatEndTimeForDisplay,\n\tgetStartOfDayWithZone,\n\tgetStartOfNextDayWithZone,\n\tincrementByRepeatPeriod,\n} from \"../../../../common/calendar/date/CalendarUtils.js\"\nimport { assertNotNull, clone, filterInt, incrementDate, noOp, TIMESTAMP_ZERO_YEAR } from \"@tutao/tutanota-utils\"\nimport { CalendarEvent, CalendarRepeatRule } from \"../../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { Stripped } from \"../../../../common/api/common/utils/EntityUtils.js\"\nimport { EndType, RepeatPeriod } from \"../../../../common/api/common/TutanotaConstants.js\"\nimport { createDateWrapper, createRepeatRule, RepeatRule } from \"../../../../common/api/entities/sys/TypeRefs.js\"\nimport { UserError } from \"../../../../common/api/main/UserError.js\"\n\nexport type CalendarEventWhenModelResult = CalendarEventTimes & {\n\trepeatRule: CalendarRepeatRule | null\n}\n\n/*\n * start, end, repeat, exclusions, reschedulings\n */\nexport class CalendarEventWhenModel {\n\tprivate repeatRule: CalendarRepeatRule | null = null\n\tprivate _isAllDay: boolean\n\n\t/** represents the start of day of the start date in local time. */\n\tprivate _startDate: Date\n\t/** represents the start of day of the end date in local time. */\n\tprivate _endDate: Date\n\n\t/** we're setting time to null on all-day events to be able to have the default time set when someone unsets the all-day flag. */\n\tprivate _startTime: Time | null\n\tprivate _endTime: Time | null\n\n\tconstructor(private readonly initialValues: Partial<Stripped<CalendarEvent>>, readonly zone: string, private readonly uiUpdateCallback: () => void = noOp) {\n\t\tlet initialTimes: CalendarEventTimes\n\t\tif (initialValues.startTime == null || initialValues.endTime == null) {\n\t\t\tconst defaultTimes = getEventWithDefaultTimes(initialValues.startTime)\n\t\t\tinitialTimes = {\n\t\t\t\tstartTime: initialValues.startTime ?? defaultTimes.startTime,\n\t\t\t\tendTime: initialValues.endTime ?? defaultTimes.endTime,\n\t\t\t}\n\t\t} else {\n\t\t\tinitialTimes = {\n\t\t\t\tstartTime: initialValues.startTime,\n\t\t\t\tendTime: initialValues.endTime,\n\t\t\t}\n\t\t}\n\n\t\t// zero out the second and millisecond part of start/end time. can't use the getters for startTime and endTime\n\t\t// because they depend on all-day status.\n\t\tinitialTimes.startTime = DateTime.fromJSDate(initialTimes.startTime, { zone }).set({ second: 0, millisecond: 0 }).toJSDate()\n\t\tinitialTimes.endTime = DateTime.fromJSDate(initialTimes.endTime, { zone }).set({ second: 0, millisecond: 0 }).toJSDate()\n\n\t\tthis._isAllDay = isAllDayEvent(initialTimes)\n\t\tthis.repeatRule = clone(initialValues.repeatRule ?? null)\n\n\t\tconst start = getEventStart(initialTimes, this.zone)\n\t\tconst end = getEventEnd(initialTimes, this.zone)\n\t\tif (this._isAllDay) {\n\t\t\tthis._startTime = null\n\t\t\tthis._endTime = null\n\t\t\tthis._startDate = getStartOfDayWithZone(DateTime.fromJSDate(start, { zone }).toJSDate(), zone)\n\t\t\tthis._endDate = incrementDate(end, -1)\n\t\t} else {\n\t\t\tthis._startTime = Time.fromDateTime(DateTime.fromJSDate(start, { zone }))\n\t\t\tthis._endTime = Time.fromDateTime(DateTime.fromJSDate(end, { zone }))\n\t\t\tthis._startDate = getStartOfDayWithZone(DateTime.fromJSDate(start, { zone }).toJSDate(), zone)\n\t\t\tthis._endDate = getStartOfDayWithZone(DateTime.fromJSDate(end, { zone }).toJSDate(), zone)\n\t\t}\n\t}\n\n\t/**\n\t * set whether this event should be considered all-day\n\t *\n\t * will also modify the excluded dates if there are any to still exclude the\n\t * same occurrence dates.\n\t */\n\tset isAllDay(value: boolean) {\n\t\tif (this._isAllDay === value) return\n\n\t\tif ((!value && this._startTime == null) || this._endTime == null) {\n\t\t\tconst defaultTimes = getEventWithDefaultTimes()\n\t\t\tthis._startTime = Time.fromDateTime(DateTime.fromJSDate(defaultTimes.startTime, this))\n\t\t\tthis._endTime = Time.fromDateTime(DateTime.fromJSDate(defaultTimes.endTime, this))\n\t\t}\n\n\t\tif (this.repeatRule == null) {\n\t\t\tthis._isAllDay = value\n\t\t} else {\n\t\t\tconst previousEndDate = this.repeatEndDateForDisplay\n\t\t\tthis._isAllDay = value\n\t\t\tthis.repeatEndDateForDisplay = previousEndDate\n\n\t\t\tif (value) {\n\t\t\t\t// we want to keep excluded dates if all we do is switching between all-day and normal event\n\t\t\t\tthis.repeatRule.excludedDates = this.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateUTC(date) }))\n\t\t\t} else {\n\t\t\t\tconst startTime = this.startTime\n\t\t\t\tthis.repeatRule.excludedDates = this.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date: startTime.toDate(date) }))\n\t\t\t}\n\t\t}\n\n\t\tthis.uiUpdateCallback()\n\t}\n\n\tget isAllDay() {\n\t\treturn this._isAllDay\n\t}\n\n\t/**\n\t * the current start time (hour:minutes) of the event in the local time zone.\n\t * will return 00:00 for all-day events.\n\t */\n\tget startTime(): Time {\n\t\treturn this._isAllDay ? new Time(0, 0) : this._startTime!\n\t}\n\n\t/**\n\t * set the time portion of the events start time. the date portion will not be modified.\n\t * will also adjust the end time accordingly to keep the event length the same.\n\t *  */\n\tset startTime(v: Time | null) {\n\t\tif (v == null || this._isAllDay) return\n\t\tconst startTime = this._startTime!\n\t\tconst delta = ((v.hour - startTime.hour) * 60 + (v.minute - startTime.minute)) * 60000\n\t\tif (delta === 0) return\n\t\tthis.rescheduleEvent({ millisecond: delta })\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * the current end time (hour:minutes) of the event in the local time zone.\n\t * will return 00:00 for all-day events independently of the time zone.\n\t */\n\tget endTime(): Time {\n\t\treturn this._isAllDay ? new Time(0, 0) : this._endTime!\n\t}\n\n\t/**\n\t * set the time portion of the events end time. the date portion will not be modified.\n\t *\n\t */\n\tset endTime(v: Time | null) {\n\t\tif (v == null || this._isAllDay) return\n\t\tconst startTime = this._startTime!\n\t\tconst currentStart = startTime.toDate(this._startDate)\n\t\tconst newEnd = v.toDate(this._endDate)\n\t\tif (newEnd < currentStart) return\n\t\tthis._endTime = v\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/** return the duration of the event in minutes */\n\tget duration(): { minutes: number } {\n\t\tconst { startTime, endTime } = this.getTimes()\n\t\tconst duration = DateTime.fromJSDate(endTime).diff(DateTime.fromJSDate(startTime))\n\t\treturn { minutes: duration.as(\"minutes\") }\n\t}\n\n\t/** set the duration of the event in minutes, effectively setting the endDate and endTime. */\n\tset duration(value: { minutes: number }) {\n\t\tif (value.minutes < 1) return\n\t\tconst diff = { minutes: this.duration.minutes - value.minutes }\n\t\tconst oldEndTime = this.endTime.toDateTime(this.endDate, this.zone)\n\t\tconst newEndTime = oldEndTime.plus(diff)\n\t\tthis._endDate = getStartOfDayWithZone(newEndTime.toJSDate(), this.zone)\n\t\tif (!this._isAllDay) {\n\t\t\tthis._endTime = Time.fromDateTime(newEndTime)\n\t\t}\n\t}\n\n\t/**\n\t * get the start time of the day this event currently starts in UTC, in local time\n\t * for display purposes.\n\t *\n\t * will always be a start of day in local time.\n\t */\n\tget startDate(): Date {\n\t\treturn this._startDate\n\t}\n\n\t/**\n\t * set the date portion of the events start time (value's time component is ignored)\n\t * will also update the end date and move it the same amount of days as the start date was moved.\n\t *\n\t * setting a date before 1970 will result in the date being set to CURRENT_YEAR\n\t * */\n\tset startDate(value: Date) {\n\t\tif (value.getTime() === this._startDate.getTime()) {\n\t\t\treturn\n\t\t}\n\n\t\t// The custom ID for events is derived from the unix timestamp, and sorting\n\t\t// the negative ids is a challenge we decided not to\n\t\t// tackle because it is a rare case and only getting rarer.\n\t\tif (value.getTime() < TIMESTAMP_ZERO_YEAR) {\n\t\t\tconst thisYear = new Date().getFullYear()\n\t\t\tvalue.setFullYear(thisYear)\n\t\t}\n\t\tconst valueDateTime = DateTime.fromJSDate(value, { zone: this.zone })\n\t\t// asking for the rest in milliseconds causes luxon to give us an integer number of\n\t\t// days in the duration which is what we want.\n\t\tconst diff = valueDateTime.diff(DateTime.fromJSDate(this._startDate, this), [\"day\", \"millisecond\"])\n\t\tif (diff.as(\"millisecond\") === 0) return\n\t\t// we only want to add days, not milliseconds.\n\t\tthis.rescheduleEvent({ days: diff.days })\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * for display purposes.\n\t *\n\t * will always be a start of day in local time.\n\t */\n\tget endDate(): Date {\n\t\treturn this._endDate\n\t}\n\n\t/**\n\t * set the date portion of the events end time (value's time component is ignored)\n\t *\n\t * */\n\tset endDate(value: Date) {\n\t\tif (value.getTime() === this._endDate.getTime()) {\n\t\t\treturn\n\t\t}\n\t\tconst startTime = this._startTime ?? new Time(0, 0)\n\t\tconst endTime = this._endTime ?? new Time(0, 0)\n\t\tconst currentStart = startTime.toDate(this._startDate)\n\t\tconst newEnd = endTime.toDate(value)\n\t\tif (newEnd < currentStart) {\n\t\t\tconsole.log(\"tried to set the end date to before the start date\")\n\t\t\treturn\n\t\t}\n\t\tthis._endDate = DateTime.fromJSDate(value, this).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }).toJSDate()\n\t\tthis.uiUpdateCallback()\n\t}\n\n\tget repeatPeriod(): RepeatPeriod | null {\n\t\treturn this.repeatRule ? (this.repeatRule.frequency as RepeatPeriod) : null\n\t}\n\n\tset repeatPeriod(repeatPeriod: RepeatPeriod | null) {\n\t\tif (this.repeatRule?.frequency === repeatPeriod) {\n\t\t\t// repeat null => we will return if repeatPeriod is null\n\t\t\t// repeat not null => we return if the repeat period did not change.\n\t\t\treturn\n\t\t} else if (repeatPeriod == null) {\n\t\t\tthis.repeatRule = null\n\t\t} else if (this.repeatRule != null) {\n\t\t\tthis.repeatRule.frequency = repeatPeriod\n\t\t} else {\n\t\t\t// new repeat rule, populate with default values.\n\t\t\tthis.repeatRule = this.initialValues.repeatRule\n\t\t\t\t? clone(this.initialValues.repeatRule)\n\t\t\t\t: createRepeatRule({\n\t\t\t\t\t\tinterval: \"1\",\n\t\t\t\t\t\tendType: EndType.Never,\n\t\t\t\t\t\tendValue: \"1\",\n\t\t\t\t\t\tfrequency: RepeatPeriod.DAILY,\n\t\t\t\t\t\texcludedDates: [],\n\t\t\t\t\t\ttimeZone: \"\",\n\t\t\t\t\t\tadvancedRules: [],\n\t\t\t\t  })\n\t\t\tthis.repeatRule.frequency = repeatPeriod\n\t\t}\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * get the current interval this series repeats in.\n\t *\n\t * if the event is not set to\n\t */\n\tget repeatInterval(): number {\n\t\tif (!this.repeatRule?.interval) return 1\n\t\treturn filterInt(this.repeatRule?.interval)\n\t}\n\n\t/**\n\t * set the event to occur on every nth of its repeat period (ie every second, third, fourth day/month/year...).\n\t * setting it to something less than 1 will set the interval to 1\n\t * @param interval\n\t */\n\tset repeatInterval(interval: number) {\n\t\tif (interval < 1) interval = 1\n\t\tconst stringInterval = String(interval)\n\t\tif (this.repeatRule && this.repeatRule?.interval !== stringInterval) {\n\t\t\tthis.repeatRule.interval = stringInterval\n\t\t}\n\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * get the current way for the event series to end.\n\t */\n\tget repeatEndType(): EndType {\n\t\treturn (this.repeatRule?.endType ?? EndType.Never) as EndType\n\t}\n\n\t/**\n\t * set the way the event series will stop repeating. if this causes a change in the event,\n\t * the endValue will be set to the default for the selected EndType.\n\t *\n\t * @param endType\n\t */\n\tset repeatEndType(endType: EndType) {\n\t\tif (!this.repeatRule) {\n\t\t\t// event does not repeat, no changes necessary\n\t\t\treturn\n\t\t}\n\n\t\tif (this.repeatRule.endType === endType) {\n\t\t\t// event series end is already set to the requested value\n\t\t\treturn\n\t\t}\n\n\t\tthis.repeatRule.endType = endType\n\n\t\tswitch (endType) {\n\t\t\tcase EndType.UntilDate:\n\t\t\t\tthis.repeatRule.endValue = getDefaultEndDateEndValue({ startTime: this._startDate, endTime: this._endDate }, this.zone)\n\t\t\t\treturn\n\t\t\tcase EndType.Count:\n\t\t\tcase EndType.Never:\n\t\t\t\tthis.repeatRule.endValue = getDefaultEndCountValue()\n\t\t}\n\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * get the current maximum number of repeats. if the event is not set to repeat or\n\t * end after number of occurrences, returns the default max repeat number.\n\t */\n\tget repeatEndOccurrences(): number {\n\t\tif (this.repeatRule?.endType === EndType.Count && this.repeatRule?.endValue) {\n\t\t\treturn filterInt(this.repeatRule?.endValue)\n\t\t} else {\n\t\t\treturn filterInt(getDefaultEndCountValue())\n\t\t}\n\t}\n\n\t/**\n\t * set the max number of repeats for the event series. if the event is not set to repeat or\n\t * not set to repeat a maximum number of times, this is a no-op.\n\t * @param endValue\n\t */\n\tset repeatEndOccurrences(endValue: number) {\n\t\tconst stringEndValue = String(endValue)\n\t\tif (this.repeatRule && this.repeatRule.endType === EndType.Count && this.repeatRule.endValue !== stringEndValue) {\n\t\t\tthis.repeatRule.endValue = stringEndValue\n\t\t}\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * get the date after which the event series will stop repeating.\n\t *\n\t * returns the default value of a month after the start date if the event is not\n\t * set to stop repeating after a certain date.\n\t */\n\tget repeatEndDateForDisplay(): Date {\n\t\tif (this.repeatRule?.endType === EndType.UntilDate) {\n\t\t\treturn getRepeatEndTimeForDisplay(this.repeatRule, this.isAllDay, this.zone)\n\t\t} else {\n\t\t\treturn new Date(filterInt(getDefaultEndDateEndValue({ startTime: this._startDate, endTime: this._endDate }, this.zone)))\n\t\t}\n\t}\n\n\t/**\n\t * set the date after which the event series ends. if the event does not repeat or the series is\n\t * not set to end after a date, this is a no-op.\n\t *\n\t * @param newRepeatEndDate the new end date, as displayed in local time zone.\n\t */\n\tset repeatEndDateForDisplay(newRepeatEndDate: Date) {\n\t\tif (this.repeatRule == null || this.repeatRule.endType !== EndType.UntilDate) {\n\t\t\treturn\n\t\t}\n\n\t\tconst repeatEndDate = incrementByRepeatPeriod(newRepeatEndDate, RepeatPeriod.DAILY, 1, this.zone)\n\t\tconst times = this.getTimes()\n\t\tif (repeatEndDate < getEventStart(times, this.zone)) {\n\t\t\tthrow new UserError(\"startAfterEnd_label\")\n\t\t}\n\n\t\t// We have to save repeatEndDate in the same way we save start/end times because if one is timezone\n\t\t// dependent and one is not then we have interesting bugs in edge cases (event created in -11 could\n\t\t// end on another date in +12). So for all day events end date is UTC-encoded all day event and for\n\t\t// regular events it is just a timestamp.\n\t\tconst numberEndDate = (this.isAllDay ? getAllDayDateUTCFromZone(repeatEndDate, this.zone) : repeatEndDate).getTime()\n\t\tthis.repeatRule.endValue = String(numberEndDate)\n\t\tthis.uiUpdateCallback()\n\t}\n\n\tget excludedDates(): ReadonlyArray<Date> {\n\t\treturn this.repeatRule?.excludedDates.map(({ date }) => date) ?? []\n\t}\n\n\t/**\n\t * calling this adds an exclusion for the event instance starting at dateToExclude to the repeat rule of the event,\n\t * which will cause the instance to not be rendered or fire alarms.\n\t * Exclusions are the start date/time of the event (as a utc timestamp)\n\t *\n\t * the list of exclusions is maintained sorted from earliest to latest.\n\t */\n\texcludeDate(date: Date): void {\n\t\tif (this.repeatRule == null) {\n\t\t\tconsole.log(\"tried to add an exclusion for an event without a repeat rule. should probably delete the event.\")\n\t\t\treturn\n\t\t}\n\t\tconst timeToInsert = date.getTime()\n\t\tlet insertionIndex = -1\n\t\tfor (const [index, { date }] of this.repeatRule.excludedDates.entries()) {\n\t\t\t// the date is already excluded, no need to do anything\n\t\t\tif (date.getTime() === timeToInsert) {\n\t\t\t\treturn\n\t\t\t} else if (date.getTime() > timeToInsert) {\n\t\t\t\tinsertionIndex = index\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// as of now, our maximum repeat frequency is 1/day. this means that we could truncate this to the current day (no time)\n\t\t// but then we run into problems with time zones, since we'd like to delete the n-th occurrence of an event, but detect\n\t\t// if an event is excluded by the start of the utc day it falls on, which may depend on time zone if it's truncated to the local start of day\n\t\t// on which the exclusion is created.\n\t\tconst wrapperToInsert = createDateWrapper({ date })\n\t\tif (insertionIndex < 0) {\n\t\t\tthis.repeatRule.excludedDates.push(wrapperToInsert)\n\t\t} else {\n\t\t\tthis.repeatRule.excludedDates.splice(insertionIndex, 0, wrapperToInsert)\n\t\t}\n\t}\n\n\t/**\n\t * completely delete all exclusions. will cause the event to be rendered and fire alarms on all\n\t * occurrences as dictated by its repeat rule.\n\t */\n\tdeleteExcludedDates(): void {\n\t\tif (!this.repeatRule) return\n\t\tthis.repeatRule.excludedDates.length = 0\n\t}\n\n\t/**\n\t * change start and end time and dates of the event by a fixed amount.\n\t * @param diff an object containing a duration in luxons year/quarter/... format\n\t */\n\trescheduleEvent(diff: DurationLikeObject): void {\n\t\tconst oldStartTime = this.startTime.toDateTime(this.startDate, this.zone)\n\t\tconst oldEndTime = this.endTime.toDateTime(this.endDate, this.zone)\n\t\tconst newStartDate = oldStartTime.plus(diff)\n\t\tconst newEndDate = oldEndTime.plus(diff)\n\n\t\tthis._startDate = getStartOfDayWithZone(newStartDate.toJSDate(), this.zone)\n\t\tthis._endDate = getStartOfDayWithZone(newEndDate.toJSDate(), this.zone)\n\t\tif (!this._isAllDay) {\n\t\t\tthis._startTime = Time.fromDateTime(newStartDate)\n\t\t\tthis._endTime = Time.fromDateTime(newEndDate)\n\t\t}\n\t}\n\n\tget result(): CalendarEventWhenModelResult {\n\t\t// we got a stripped repeat rule, so we re-create a fresh one with all fields but overwrite it with our values.\n\t\tconst repeatRule: RepeatRule | null = this.repeatRule\n\t\t\t? {\n\t\t\t\t\t...createRepeatRule({\n\t\t\t\t\t\ttimeZone: \"\",\n\t\t\t\t\t\texcludedDates: [],\n\t\t\t\t\t\tendType: \"0\",\n\t\t\t\t\t\tendValue: null,\n\t\t\t\t\t\tinterval: \"0\",\n\t\t\t\t\t\tfrequency: \"0\",\n\t\t\t\t\t\tadvancedRules: [],\n\t\t\t\t\t}),\n\t\t\t\t\t...this.repeatRule,\n\t\t\t\t\ttimeZone: this.zone,\n\t\t\t  }\n\t\t\t: null\n\t\tthis.deleteExcludedDatesIfNecessary(repeatRule)\n\t\tconst { startTime, endTime } = this.getTimes()\n\t\treturn { startTime, endTime, repeatRule }\n\t}\n\n\t/**\n\t * get the JS dates where the event starts and ends as they would be saved on the server (display may vary)\n\t * @param startDate base date to use for the start date\n\t * @param endDate base date to use for the end date.\n\t * @private\n\t */\n\tprivate getTimes(\n\t\t{ startDate, endDate }: { startDate: Date; endDate: Date } = {\n\t\t\tstartDate: this._startDate,\n\t\t\tendDate: this._endDate,\n\t\t},\n\t): CalendarEventTimes {\n\t\tif (this._isAllDay) {\n\t\t\tconst startTime = getAllDayDateUTCFromZone(startDate, this.zone)\n\t\t\tconst endTime = getAllDayDateUTCFromZone(getStartOfNextDayWithZone(endDate, this.zone), this.zone)\n\t\t\treturn { startTime, endTime }\n\t\t} else {\n\t\t\tconst startTime = this._startTime!.toDateTime(getStartOfDayWithZone(startDate, this.zone), this.zone).toJSDate()\n\t\t\tconst endTime = this._endTime!.toDateTime(getStartOfDayWithZone(endDate, this.zone), this.zone).toJSDate()\n\t\t\treturn { startTime, endTime }\n\t\t}\n\t}\n\n\t/**\n\t * ideally, we want to delete exclusions after an edit operation only when necessary.\n\t * @private\n\t */\n\tprivate deleteExcludedDatesIfNecessary(newRepeat: RepeatRule | null) {\n\t\tif (newRepeat == null) return\n\t\tconst oldRepeat = this.initialValues.repeatRule ?? null\n\t\t// if excluded dates have changed,\n\t\tif (!areRepeatRulesEqual(newRepeat, oldRepeat) && areExcludedDatesEqual(newRepeat?.excludedDates ?? [], oldRepeat?.excludedDates ?? [])) {\n\t\t\tnewRepeat.excludedDates = []\n\t\t\treturn\n\t\t}\n\t\tif (this.initialValues.startTime == null) {\n\t\t\treturn\n\t\t}\n\t\tconst { startTime } = this.getTimes()\n\t\tif (startTime.getTime() !== this.initialValues.startTime.getTime()) {\n\t\t\tnewRepeat.excludedDates = []\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * create the default repeat end for an event series that ends on a date\n */\nexport function getDefaultEndDateEndValue({ startTime }: CalendarEventTimes, timeZone: string): string {\n\t// one month after the event's start time in the local time zone.\n\treturn String(incrementByRepeatPeriod(startTime, RepeatPeriod.MONTHLY, 1, timeZone).getTime())\n}\n\n/**\n * get the default repeat end for an event series that ends after number of repeats\n */\nexport function getDefaultEndCountValue(): string {\n\treturn \"10\"\n}\n\nexport function repeatRuleWithExcludedAlteredInstances(progenitor: CalendarEvent, recurrenceIds: ReadonlyArray<Date>, timeZone: string): CalendarRepeatRule {\n\tconst whenModel = new CalendarEventWhenModel(progenitor, timeZone)\n\tfor (const recurrenceId of recurrenceIds) {\n\t\twhenModel.excludeDate(recurrenceId)\n\t}\n\treturn assertNotNull(whenModel.result.repeatRule, \"tried to exclude altered instance on progenitor without repeat rule!\")\n}\n"],"mappings":"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"}