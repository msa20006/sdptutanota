
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, compare, promiseFilter } from "./dist-CJHwsXKY.js";
import { assertMainOrNode } from "./Env-D5xGlXfw.js";
import { MailSetKind, OperationType } from "./TutanotaConstants-3bwAESYA.js";
import { isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { CUSTOM_MAX_ID, customIdToUint8array, deconstructMailSetEntryId, elementIdPart, getElementId, isSameId, listIdPart } from "./EntityUtils-RQxXZlcV.js";
import { MailFolderTypeRef, MailSetEntryTypeRef, MailTypeRef } from "./TypeRefs-CR3TLWn0.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { ListModel } from "./ListModel-jYF3dysm.js";

//#region ../src/mail-app/mail/model/MailListModel.ts
assertMainOrNode();
var MailListModel = class {
	listModel;
	mailMap = new Map();
	constructor(mailSet, conversationPrefProvider, entityClient, mailModel, inboxRuleHandler, cacheStorage) {
		this.mailSet = mailSet;
		this.conversationPrefProvider = conversationPrefProvider;
		this.entityClient = entityClient;
		this.mailModel = mailModel;
		this.inboxRuleHandler = inboxRuleHandler;
		this.cacheStorage = cacheStorage;
		this.listModel = new ListModel({
			fetch: (lastFetchedItem, count) => {
				const lastFetchedId = lastFetchedItem?.mailSetEntry?._id ?? [mailSet.entries, CUSTOM_MAX_ID];
				return this.loadMails(lastFetchedId, count);
			},
			sortCompare: (item1, item2) => {
				const item1Id = getElementId(item1.mailSetEntry);
				const item2Id = getElementId(item2.mailSetEntry);
				return compare(customIdToUint8array(item2Id), customIdToUint8array(item1Id));
			},
			getItemId: (item) => getElementId(item.mailSetEntry),
			isSameId: (id1, id2) => id1 === id2,
			autoSelectBehavior: () => this.conversationPrefProvider.getMailAutoSelectBehavior()
		});
	}
	get items() {
		return this._loadedMails().map((mail) => mail.mail);
	}
	get loadingStatus() {
		return this.listModel.state.loadingStatus;
	}
	get stateStream() {
		return this.listModel.stateStream.map((state) => {
			const items = state.items.map((item) => item.mail);
			const selectedItems = new Set();
			for (const item of state.selectedItems) selectedItems.add(item.mail);
			const newState = {
				...state,
				items,
				selectedItems
			};
			return newState;
		});
	}
	isLoadingAll() {
		return this.listModel.state.loadingAll;
	}
	isItemSelected(mailId) {
		const loadedMail = this.mailMap.get(mailId);
		if (loadedMail == null) return false;
		return this.listModel.isItemSelected(getElementId(loadedMail.mailSetEntry));
	}
	getMail(mailElementId) {
		return this.getLoadedMailByMailId(mailElementId)?.mail ?? null;
	}
	getLabelsForMail(mail) {
		return this.getLoadedMailByMailInstance(mail)?.labels ?? [];
	}
	getMailSetEntry(mailSetEntryId) {
		return this.getLoadedMailByMailSetId(mailSetEntryId)?.mailSetEntry ?? null;
	}
	async loadAndSelect(mailId, shouldStop) {
		const mailFinder = (loadedMail) => isSameId(getElementId(loadedMail.mail), mailId);
		const mail = await this.listModel.loadAndSelect(mailFinder, shouldStop);
		return mail?.mail ?? null;
	}
	onSingleSelection(mail) {
		this.listModel.onSingleSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)));
	}
	selectNone() {
		this.listModel.selectNone();
	}
	cancelLoadAll() {
		this.listModel.cancelLoadAll();
	}
	async loadInitial() {
		await this.listModel.loadInitial();
	}
	getSelectedAsArray() {
		return this.listModel.getSelectedAsArray().map(({ mail }) => mail);
	}
	async handleEntityUpdate(update) {
		if (isUpdateForTypeRef(MailFolderTypeRef, update)) {
			if (update.operation === OperationType.UPDATE) {
				const mailSetId = [update.instanceListId, update.instanceId];
				for (const loadedMail of this.mailMap.values()) {
					const hasMailSet = loadedMail.labels.some((label) => isSameId(mailSetId, label._id));
					if (!hasMailSet) continue;
					const labels = this.mailModel.getLabelsForMail(loadedMail.mail);
					const newMailEntry = {
						...loadedMail,
						labels
					};
					this._updateSingleMail(newMailEntry);
				}
			}
		} else if (isUpdateForTypeRef(MailSetEntryTypeRef, update) && isSameId(this.mailSet.entries, update.instanceListId)) {
			if (update.operation === OperationType.DELETE) {
				const mail = this.getLoadedMailByMailSetId(update.instanceId);
				if (mail) this.mailMap.delete(getElementId(mail.mail));
				await this.listModel.deleteLoadedItem(update.instanceId);
			} else if (update.operation === OperationType.CREATE) {
				const loadedMail = await this.loadSingleMail([update.instanceListId, update.instanceId]);
				await this.listModel.waitLoad(async () => {
					if (this.listModel.canInsertItem(loadedMail)) this.listModel.insertLoadedItem(loadedMail);
				});
			}
		} else if (isUpdateForTypeRef(MailTypeRef, update)) {
			const mailItem = this.mailMap.get(update.instanceId);
			if (mailItem != null && update.operation === OperationType.UPDATE) {
				const newMailData = await this.entityClient.load(MailTypeRef, [update.instanceListId, update.instanceId]);
				const labels = this.mailModel.getLabelsForMail(newMailData);
				const newMailItem = {
					...mailItem,
					labels,
					mail: newMailData
				};
				this._updateSingleMail(newMailItem);
			}
		}
	}
	areAllSelected() {
		return this.listModel.areAllSelected();
	}
	selectAll() {
		this.listModel.selectAll();
	}
	onSingleInclusiveSelection(mail, clearSelectionOnMultiSelectStart) {
		this.listModel.onSingleInclusiveSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)), clearSelectionOnMultiSelectStart);
	}
	selectRangeTowards(mail) {
		this.listModel.selectRangeTowards(assertNotNull(this.getLoadedMailByMailInstance(mail)));
	}
	selectPrevious(multiselect) {
		this.listModel.selectPrevious(multiselect);
	}
	selectNext(multiselect) {
		this.listModel.selectNext(multiselect);
	}
	onSingleExclusiveSelection(mail) {
		this.listModel.onSingleExclusiveSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)));
	}
	isInMultiselect() {
		return this.listModel.state.inMultiselect;
	}
	enterMultiselect() {
		this.listModel.enterMultiselect();
	}
	async loadAll() {
		await this.listModel.loadAll();
	}
	setFilter(filter) {
		this.listModel.setFilter(filter && ((loadedMail) => filter(loadedMail.mail)));
	}
	isEmptyAndDone() {
		return this.listModel.isEmptyAndDone();
	}
	async loadMore() {
		await this.listModel.loadMore();
	}
	async retryLoading() {
		await this.listModel.retryLoading();
	}
	stopLoading() {
		this.listModel.stopLoading();
	}
	getLoadedMailByMailId(mailId) {
		return this.mailMap.get(mailId) ?? null;
	}
	getLoadedMailByMailSetId(mailId) {
		return this.mailMap.get(deconstructMailSetEntryId(mailId).mailId) ?? null;
	}
	getLoadedMailByMailInstance(mail) {
		return this.getLoadedMailByMailId(getElementId(mail));
	}
	/**
	* Load mails, applying inbox rules as needed
	*/
	async loadMails(startingId, count) {
		let items = [];
		let complete = false;
		try {
			const mailSetEntries = await this.entityClient.loadRange(MailSetEntryTypeRef, listIdPart(startingId), elementIdPart(startingId), count, true);
			complete = mailSetEntries.length < count;
			if (mailSetEntries.length > 0) {
				items = await this.resolveMailSetEntries(mailSetEntries, this.defaultMailProvider);
				items = await this.applyInboxRulesToEntries(items);
			}
		} catch (e) {
			if (isOfflineError(e)) {
				if (items.length === 0) {
					complete = false;
					items = await this.loadMailsFromCache(startingId, count);
					if (items.length === 0) throw e;
				}
			} else throw e;
		}
		this.updateMailMap(items);
		return {
			items,
			complete
		};
	}
	/**
	* Load mails from the cache rather than remotely
	*/
	async loadMailsFromCache(startId, count) {
		const mailSetEntries = await this.cacheStorage.provideFromRange(MailSetEntryTypeRef, listIdPart(startId), elementIdPart(startId), count, true);
		return await this.resolveMailSetEntries(mailSetEntries, (list, elements) => this.cacheStorage.provideMultiple(MailTypeRef, list, elements));
	}
	/**
	* Apply inbox rules to an array of mails, returning all mails that were not moved
	*/
	async applyInboxRulesToEntries(entries) {
		if (this.mailSet.folderType !== MailSetKind.INBOX || entries.length === 0) return entries;
		const mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(this.mailSet);
		if (!mailboxDetail) return entries;
		return await promiseFilter(entries, async (entry) => {
			const ruleApplied = await this.inboxRuleHandler.findAndApplyMatchingRule(mailboxDetail, entry.mail, true);
			return ruleApplied == null;
		});
	}
	async loadSingleMail(id) {
		const mailSetEntry = await this.entityClient.load(MailSetEntryTypeRef, id);
		const loadedMails = await this.resolveMailSetEntries([mailSetEntry], this.defaultMailProvider);
		this.updateMailMap(loadedMails);
		return assertNotNull(loadedMails[0]);
	}
	/**
	* Loads all Mail instances for each MailSetEntry, returning a tuple of each
	*/
	async resolveMailSetEntries(mailSetEntries, mailProvider) {
		const mailListMap = new Map();
		for (const entry of mailSetEntries) {
			const mailBag = listIdPart(entry.mail);
			const mailElementId = elementIdPart(entry.mail);
			let mailIds = mailListMap.get(mailBag);
			if (!mailIds) {
				mailIds = [];
				mailListMap.set(mailBag, mailIds);
			}
			mailIds.push(mailElementId);
		}
		const allMails = new Map();
		for (const [list, elements] of mailListMap) {
			const mails = await mailProvider(list, elements);
			for (const mail of mails) allMails.set(getElementId(mail), mail);
		}
		const loadedMails = [];
		for (const mailSetEntry of mailSetEntries) {
			const mail = allMails.get(elementIdPart(mailSetEntry.mail));
			if (!mail) continue;
			const labels = this.mailModel.getLabelsForMail(mail);
			loadedMails.push({
				mailSetEntry,
				mail,
				labels
			});
		}
		return loadedMails;
	}
	updateMailMap(mails) {
		for (const mail of mails) this.mailMap.set(getElementId(mail.mail), mail);
	}
	_updateSingleMail(mail) {
		this.updateMailMap([mail]);
		this.listModel.updateLoadedItem(mail);
	}
	_loadedMails() {
		return this.listModel.state.items;
	}
	defaultMailProvider = (listId, elements) => {
		return this.entityClient.loadMultiple(MailTypeRef, listId, elements);
	};
};

//#endregion
export { MailListModel };
//# sourceMappingURL=MailListModel-BwcGCBzp.js.map