
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { LazyLoaded, NBSP, assertNotNull, clear, defer, delay, downcast, getFirstOrThrow, noOp, ofClass, resolveMaybeLazy, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import { assertMainOrNode, isApp, isIOSApp } from "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { AlphaEnum, TransformEnum, alpha, animations, ease, getSafeAreaInsetLeft, inputLineHeight, px, size, stateBgHover, styles, theme, transform } from "./HtmlUtils-C-ecR7U7.js";
import { client } from "./ClientDetector-D0v6Vqu6.js";
import { ContactAddressType, ContactMergeAction, FeatureType, Keys, getContactSocialType } from "./TutanotaConstants-3bwAESYA.js";
import { BootIcons, Button, ButtonColor, ButtonType, Icon, IconSize, progressIcon } from "./Icon-BuqNK7vz.js";
import { Icons } from "./Icons-Dl3nFav5.js";
import { keyManager } from "./KeyManager-B0OGXEyJ.js";
import { windowFacade } from "./WindowFacade-B9kSBKw7.js";
import { LayerType } from "./Modal-g4c-b9IU.js";
import { AriaLandmarks, Dialog, DialogHeaderBar, DialogType, TextField, attachDropdown, createDropdown, landmarkAttrs, pureComponent } from "./Dialog-B6-HFvZd.js";
import "./CountryList-DkVQtcTj.js";
import { ButtonSize, IconButton } from "./IconButton-DsU60HJ_.js";
import { LockedError, NotFoundError } from "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import { require_stream } from "./stream-u2PttBAC.js";
import "./luxon-D6cgmg6Q.js";
import "./EntityUtils-RQxXZlcV.js";
import "./CommonCalendarUtils-DKaO7v1K.js";
import "./Formatter-zB15D6XI.js";
import "./TypeModels-XIXYys8J.js";
import { ContactTypeRef, createContact, createContactMailAddress } from "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import "./TypeRefs-BP1jvX9p.js";
import "./CalendarUtils-C6jeYrj9.js";
import "./ProgressMonitor-HBfOF56H.js";
import "./Notifications-DLibQbV7.js";
import "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./EntityClient-B0RSdk2i.js";
import "./SetupMultipleError-B6uY8P-x.js";
import "./Services-DCx-CeM7.js";
import "./EntityUpdateUtils-B5iTKMk4.js";
import "./GroupUtils-CpT2lvVS.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import "./ImportExportUtils-B1MoOmZ0.js";
import "./FormatValidator-2BBermUe.js";
import "./UserError-DfXlMLTl.js";
import "./MailAddressParser-BgYy6oyp.js";
import { getGroupInfoDisplayName } from "./GroupUtils-0ZkLIAeC.js";
import "./DataFile-CY7uuk9j.js";
import "./FileUtils-W-u2-gZz.js";
import { showProgressDialog } from "./ProgressDialog-CJfJjh62.js";
import "./BlobUtils-D5ADcckZ.js";
import { showFileChooser, showNativeFilePicker } from "./SharedMailUtils-AmFaSJP6.js";
import "./PasswordUtils-C4jlV9GF.js";
import "./Recipient-BFxhfecW.js";
import "./BirthdayUtils-BcCMglSq.js";
import { formatContactDate } from "./ContactUtils-Bbon2oOk.js";
import { showPlanUpgradeRequiredDialog } from "./SubscriptionDialogs-DAlWs68I.js";
import "./ExternalLink-rsCBSC7U.js";
import "./ToggleButton-DxuDa0rS.js";
import "./MailRecipientsTextField-BmI2qlpf.js";
import { ColumnEmptyMessageBox } from "./ColumnEmptyMessageBox-TSIJJX7z.js";
import "./DateParser-DIjdXKhX.js";
import "./ErrorHandler-DbW1lJbv.js";
import { NavButton, NavButtonColor, isNavButtonSelected, isSelectedPrefix } from "./InfoBanner-CobgB3Oz.js";
import "./SnackBar-CoP3lSVs.js";
import "./Credentials-BM35X_na.js";
import "./NotificationOverlay-C-YNCUiT.js";
import "./Checkbox-WCw-l_7A.js";
import "./Expander-Bautb1_0.js";
import "./ClipboardUtils-mz40UK5S.js";
import "./ErrorReporter-7sfLhWZg.js";
import "./Services-CupYet_j.js";
import "./BubbleButton-DGGInJMg.js";
import "./SessionType-rxSDsswH.js";
import "./PasswordField-CPKPoLq8.js";
import "./PasswordRequestDialog-B7ZIVTVw.js";
import "./ErrorHandlerImpl-DRpk8tE9.js";
import "./DeviceConfig-payZM407.js";
import "./InAppRatingUtils-DwsFPPTC.js";
import "./InAppRatingDialog-Cp5yqAc1.js";
import { List, MultiselectMode, listSelectionKeyboardShortcuts } from "./List-CdKNFQkI.js";
import { SelectableRowContainer, checkboxOpacity, scaleXHide, scaleXShow, selectableRowAnimParams, shouldAlwaysShowMultiselectCheckbox } from "./SelectableRowContainer-CWm9GtOE.js";
import "./CustomerUtils-DmaZpb7Y.js";
import "./EventQueue-c-5UmjJa.js";
import "./EntityRestClient--6dT7ZRF.js";
import "./MessageDispatcher-wJwFhXWv.js";
import "./SqlValue-CkGu32Qd.js";
import "./Sql-C9YhYNym.js";
import "./RestClient-CmoHrId4.js";
import { HtmlEditor, HtmlEditorMode } from "./HtmlEditor-DkqWVGt0.js";
import "./HtmlSanitizer-CA1YjlPp.js";
import { BaseTopLevelView, DesktopBaseHeader } from "./LoginViewModel-BX-8ry63.js";
import { LoginButton } from "./LoginButton-DzCRy0Yt.js";
import "./UsageTestModel-CjGx3RZo.js";
import "./inlineImagesUtils-BekMwI7k.js";
import "./CommonMailUtils-DNufl6ib.js";
import "./PermissionType-Bwii3hCe.js";
import "./AttachmentBubble-CloIefNF.js";
import { CALENDAR_PREFIX, CONTACTLIST_PREFIX, CONTACTS_PREFIX, LogoutUrl, MAIL_PREFIX, SEARCH_PREFIX, SETTINGS_PREFIX } from "./RouteChange-im6yOAT2.js";
import "./SearchUtils-Cu31OiTT.js";
import { OfflineIndicator, ProgressBar, mailLocator } from "./mailLocator-CrvEYt1k.js";
import "./PageContextLoginListener-dgY8O-YX.js";
import "./Scheduler-B2H65_EO.js";
import "./MailUtils-ChhZAFAd.js";
import "./FolderSystem-DLrUB8MO.js";
import "./MailChecks-PhVUoR7f.js";
import "./TemplatePopupModel-Bv3eIGgN.js";
import { CounterBadge, newMailEditorFromTemplate } from "./MailEditor-Dm804Ukq.js";
import "./MailViewerViewModel-D_nVDgz3.js";
import { appendEmailSignature } from "./Signature-nc-d4UDo.js";
import "./KnowledgeBaseSearchFilter-D7VhMtlv.js";
import "./emlUtils-afBEUvhM.js";
import "./LoadingState-DqrMrOAm.js";
import { getContactAddressTypeLabel, getContactPhoneNumberTypeLabel, getContactSocialTypeLabel } from "./ContactGuiUtils-BOj2qfyh.js";
import { ContactEditor } from "./ContactEditor-qV5wi7tT.js";
import { ContactListView, ListColumnWrapper, shiftByForCheckbox, translateXHide, translateXShow } from "./ContactListView-A76nls8J.js";
import { SelectAllCheckbox } from "./SelectAllCheckbox-KzgVj7Zg.js";
import { selectionAttrsForList } from "./ListModel-jYF3dysm.js";
import { ContactCardViewer, MainCreateButton, exportContacts, getMergeableContacts, mergeContacts, responsiveCardHMargin, showContactListEditor, showContactListNameEditor } from "./ContactListEditor-5LX_1ENd.js";

//#region ../src/common/gui/base/ViewColumn.ts
assertMainOrNode();
let ColumnType = function(ColumnType$1) {
	ColumnType$1[ColumnType$1["Background"] = 1] = "Background";
	ColumnType$1[ColumnType$1["Foreground"] = 0] = "Foreground";
	return ColumnType$1;
}({});
var ViewColumn = class {
	component;
	columnType;
	minWidth;
	maxWidth;
	headerCenter;
	ariaLabel;
	width;
	offset;
	domColumn = null;
	isInForeground;
	isVisible;
	ariaRole = null;
	/**
	* Create a view column.
	* @param component The component that is rendered as this column
	* @param columnType The type of the view column.
	* @param minWidth The minimum allowed width for the view column.
	* @param headerCenter returned in {@link getTitle}. Used in ARIA landmark unless overriden by {@link ariaLabel}
	* @param ariaLabel used in ARIA landmark
	* @param maxWidth The maximum allowed width for the view column.
	* @param headerCenter The title of the view column.
	* @param ariaLabel The label of the view column to be read by screen readers. Defaults to headerCenter if not specified.
	*/
	constructor(component, columnType, { minWidth, maxWidth, headerCenter, ariaLabel = () => lang.getTranslationText(this.getTitle()) }) {
		this.component = component;
		this.columnType = columnType;
		this.minWidth = minWidth;
		this.maxWidth = maxWidth;
		this.headerCenter = headerCenter || "emptyString_msg";
		this.ariaLabel = ariaLabel ?? null;
		this.width = minWidth;
		this.offset = 0;
		this.isInForeground = false;
		this.isVisible = false;
		this.view = this.view.bind(this);
	}
	view() {
		const zIndex = !this.isVisible && this.columnType === ColumnType.Foreground ? LayerType.ForegroundMenu + 1 : "";
		const landmark = this.ariaRole ? landmarkAttrs(this.ariaRole, this.ariaLabel ? this.ariaLabel() : lang.getTranslationText(this.getTitle())) : {};
		return mithril_default(".view-column.fill-absolute", {
			...landmark,
			"data-testid": lang.getTranslationText(this.getTitle()),
			inert: !this.isVisible && !this.isInForeground,
			oncreate: (vnode) => {
				this.domColumn = vnode.dom;
				this.domColumn.style.transform = this.columnType === ColumnType.Foreground ? "translateX(" + this.getOffsetForeground(this.isInForeground) + "px)" : "";
				if (this.ariaRole === AriaLandmarks.Main) this.focus();
			},
			style: {
				zIndex,
				width: this.width + "px",
				left: this.offset + "px"
			}
		}, mithril_default(this.component));
	}
	getTitle() {
		return resolveMaybeLazy(this.headerCenter);
	}
	getOffsetForeground(foregroundState) {
		if (this.isVisible || foregroundState) return 0;
else return -this.width;
	}
	focus() {
		this.domColumn?.focus();
	}
};

//#endregion
//#region ../src/common/gui/nav/ViewSlider.ts
assertMainOrNode();
const gestureInfoFromTouch = (touch) => ({
	x: touch.pageX,
	y: touch.pageY,
	time: performance.now(),
	identifier: touch.identifier
});
var ViewSlider = class {
	mainColumn;
	focusedColumn;
	visibleBackgroundColumns;
	domSlidingPart;
	view;
	busy;
	isModalBackgroundVisible;
	resizeListener = () => this.updateVisibleBackgroundColumns();
	handleHistoryEvent = () => {
		const prev = this.getPreviousColumn();
		if (prev != null && prev.columnType !== ColumnType.Foreground) {
			this.focusPreviousColumn();
			return false;
		} else if (this.isForegroundColumnFocused()) {
			this.focusNextColumn();
			return false;
		}
		return true;
	};
	/** Creates the event listeners as soon as this component is loaded (invoked by mithril)*/
	oncreate = () => {
		this.updateVisibleBackgroundColumns();
		windowFacade.addResizeListener(this.resizeListener);
		windowFacade.addHistoryEventListener(this.handleHistoryEvent);
	};
	/** Removes the registered event listeners as soon as this component is unloaded (invoked by mithril)*/
	onremove = () => {
		windowFacade.removeResizeListener(this.resizeListener);
		windowFacade.removeHistoryEventListener(this.handleHistoryEvent);
	};
	getSideColDom = () => this.viewColumns[0].domColumn;
	constructor(viewColumns, enableDrawer = true) {
		this.viewColumns = viewColumns;
		this.enableDrawer = enableDrawer;
		this.mainColumn = assertNotNull(viewColumns.find((column) => column.columnType === ColumnType.Background), "there was no backgroung column passed to viewslider");
		this.focusedColumn = this.mainColumn;
		this.visibleBackgroundColumns = [];
		this.updateVisibleBackgroundColumns();
		this.busy = Promise.resolve();
		this.isModalBackgroundVisible = false;
		for (const column of this.viewColumns) column.ariaRole = this.getColumnRole(column);
		this.view = ({ attrs }) => {
			const mainSliderColumns = this.getColumnsForMainSlider();
			const allBackgroundColumnsAreVisible = this.visibleBackgroundColumns.length === mainSliderColumns.length;
			return mithril_default(".fill-absolute.flex.col", {
				oncreate: (vnode) => {
					if (this.enableDrawer) this.attachTouchHandler(vnode.dom);
				},
				onremove: () => {
					if (this.viewColumns[0].columnType === ColumnType.Foreground && this.viewColumns[0].isInForeground) {
						this.viewColumns[0].isInForeground = false;
						this.isModalBackgroundVisible = false;
					}
				}
			}, [
				styles.isUsingBottomNavigation() ? null : attrs.header,
				mithril_default(".view-columns.flex-grow.rel", {
					oncreate: (vnode) => {
						this.domSlidingPart = vnode.dom;
					},
					style: {
						width: this.getWidth() + "px",
						transform: "translateX(" + this.getOffset(this.visibleBackgroundColumns[0]) + "px)"
					}
				}, mainSliderColumns.map((column, index) => mithril_default(column, { rightBorder: allBackgroundColumnsAreVisible && index !== mainSliderColumns.length - 1 }))),
				styles.isUsingBottomNavigation() && !client.isCalendarApp() ? attrs.bottomNav : null,
				this.getColumnsForOverlay().map((c) => mithril_default(c, {})),
				this.enableDrawer ? this.createModalBackground() : null
			]);
		};
	}
	getColumnRole(column) {
		if (column.columnType === ColumnType.Foreground) return null;
		return this.mainColumn === column ? AriaLandmarks.Main : AriaLandmarks.Region;
	}
	getMainColumn() {
		return this.mainColumn;
	}
	getColumnsForMainSlider() {
		return this.viewColumns.filter((c) => c.columnType === ColumnType.Background || c.isVisible);
	}
	getColumnsForOverlay() {
		return this.viewColumns.filter((c) => c.columnType === ColumnType.Foreground && !c.isVisible);
	}
	createModalBackground() {
		if (this.isModalBackgroundVisible) return [mithril_default(".fill-absolute.will-change-alpha", {
			style: { zIndex: LayerType.ForegroundMenu },
			oncreate: (vnode) => {
				this.busy.then(() => animations.add(vnode.dom, alpha(AlphaEnum.BackgroundColor, theme.modal_bg, 0, .5)));
			},
			onbeforeremove: (vnode) => {
				return this.busy.then(() => animations.add(vnode.dom, alpha(AlphaEnum.BackgroundColor, theme.modal_bg, .5, 0)));
			},
			onclick: () => {
				this.focus(this.visibleBackgroundColumns[0]);
			}
		})];
else return [];
	}
	updateVisibleBackgroundColumns() {
		this.focusedColumn = this.focusedColumn || this.mainColumn;
		let visibleColumns = [this.focusedColumn.columnType === ColumnType.Background ? this.focusedColumn : this.mainColumn];
		let remainingSpace = window.innerWidth - visibleColumns[0].minWidth;
		let nextVisibleColumn = this.getNextVisibleColumn(visibleColumns, this.viewColumns);
		while (nextVisibleColumn && remainingSpace >= nextVisibleColumn.minWidth) {
			visibleColumns.push(nextVisibleColumn);
			remainingSpace -= nextVisibleColumn.minWidth;
			nextVisibleColumn = this.getNextVisibleColumn(visibleColumns, this.viewColumns);
		}
		visibleColumns.sort((a, b) => this.viewColumns.indexOf(a) - this.viewColumns.indexOf(b));
		this.distributeRemainingSpace(visibleColumns, remainingSpace);
		this.setWidthForHiddenColumns(visibleColumns);
		for (const column of this.viewColumns) column.isVisible = visibleColumns.includes(column);
		this.updateOffsets();
		this.visibleBackgroundColumns = visibleColumns;
		if (this.allColumnsVisible()) {
			this.focusedColumn.isInForeground = false;
			this.isModalBackgroundVisible = false;
			if (this.viewColumns[0].domColumn) this.viewColumns[0].domColumn.style.transform = "";
		}
		window.requestAnimationFrame(() => mithril_default.redraw());
	}
	getVisibleBackgroundColumns() {
		return this.visibleBackgroundColumns.slice();
	}
	isUsingOverlayColumns() {
		return this.viewColumns.every((c) => c.columnType !== ColumnType.Foreground || c.isVisible);
	}
	/**
	* Returns the next column which should become visible
	* @param visibleColumns All columns that will definitely be visible
	* @param allColumns All columns*
	*/
	getNextVisibleColumn(visibleColumns, allColumns) {
		let nextColumn = allColumns.find((column) => {
			return column.columnType === ColumnType.Background && visibleColumns.indexOf(column) < 0;
		});
		if (!nextColumn) nextColumn = allColumns.find((column) => {
			return column.columnType === ColumnType.Foreground && visibleColumns.indexOf(column) < 0;
		});
		return nextColumn ?? null;
	}
	getBackgroundColumns() {
		return this.viewColumns.filter((c) => c.columnType === ColumnType.Background);
	}
	/**
	* distributes the remaining space to all visible columns
	* @param visibleColumns
	* @param remainingSpace
	*/
	distributeRemainingSpace(visibleColumns, remainingSpace) {
		let spacePerColumn = remainingSpace / visibleColumns.length;
		for (const [index, visibleColumn] of visibleColumns.entries()) if (visibleColumns.length - 1 === index) visibleColumn.width = visibleColumn.minWidth + remainingSpace;
else {
			let spaceForThisColumn = Math.min(spacePerColumn, visibleColumn.maxWidth - visibleColumn.minWidth);
			remainingSpace -= spaceForThisColumn;
			visibleColumn.width = visibleColumn.minWidth + spaceForThisColumn;
		}
	}
	setWidthForHiddenColumns(visibleColumns) {
		if (this.viewColumns.length === visibleColumns.length) return;
		if (visibleColumns.length === 1) for (const column of this.viewColumns) column.width = visibleColumns[0].width;
		let foreGroundColumn = this.viewColumns.find((column) => column.columnType === ColumnType.Foreground);
		if (foreGroundColumn) {
			let remainingSpace = window.innerWidth - foreGroundColumn.minWidth - size.hpad_large;
			let additionalSpaceForColumn = Math.min(remainingSpace, foreGroundColumn.maxWidth - foreGroundColumn.minWidth);
			foreGroundColumn.width = foreGroundColumn.minWidth + additionalSpaceForColumn;
		}
	}
	async focus(viewColumn) {
		try {
			await this.busy;
			if (this.focusedColumn === viewColumn) return;
			if (this.focusedColumn.isInForeground) {
				this.busy = this.slideForegroundColumn(this.focusedColumn, false);
				await this.busy;
			}
			this.focusedColumn = viewColumn;
			if (viewColumn.columnType === ColumnType.Background && this.visibleBackgroundColumns.length === 1 && this.visibleBackgroundColumns.indexOf(viewColumn) < 0) {
				const currentOffset = this.domSlidingPart.getBoundingClientRect().left;
				this.busy = this.slideBackgroundColumns(viewColumn, currentOffset, this.getOffset(viewColumn));
			} else if (viewColumn.columnType === ColumnType.Foreground && this.visibleBackgroundColumns.indexOf(viewColumn) < 0) this.busy = this.slideForegroundColumn(viewColumn, true);
			await this.busy;
		} finally {
			mithril_default.redraw();
			viewColumn.focus();
		}
	}
	waitForAnimation() {
		return this.busy;
	}
	/**
	* Executes a slide animation for the background buttons.
	*/
	slideBackgroundColumns(nextVisibleViewColumn, oldOffset, newOffset) {
		return animations.add(this.domSlidingPart, transform(TransformEnum.TranslateX, oldOffset, newOffset), { easing: ease.inOut }).finally(() => {
			const [removed] = this.visibleBackgroundColumns.splice(0, 1, nextVisibleViewColumn);
			removed.isVisible = false;
			nextVisibleViewColumn.isVisible = true;
		});
	}
	/**
	* Executes a slide animation for the foreground button.
	*/
	slideForegroundColumn(foregroundColumn, toForeground) {
		if (!foregroundColumn.domColumn) return Promise.resolve();
		foregroundColumn.domColumn.style.visibility = "visible";
		const colRect = foregroundColumn.domColumn.getBoundingClientRect();
		const oldOffset = colRect.left;
		let newOffset = foregroundColumn.getOffsetForeground(toForeground);
		this.isModalBackgroundVisible = toForeground;
		return animations.add(assertNotNull(foregroundColumn.domColumn, "foreground column has no domcolumn"), transform(TransformEnum.TranslateX, oldOffset, newOffset), { easing: ease.in }).finally(() => {
			foregroundColumn.isInForeground = toForeground;
		});
	}
	updateOffsets() {
		let offset = 0;
		for (let column of this.viewColumns) if (column.columnType === ColumnType.Background || column.isVisible) {
			column.offset = offset;
			offset += column.width;
		}
	}
	getWidth() {
		let lastColumn = this.viewColumns[this.viewColumns.length - 1];
		return lastColumn.offset + lastColumn.width;
	}
	getOffset(column) {
		return 0 - column.offset;
	}
	isFocusPreviousPossible() {
		return this.getPreviousColumn() != null;
	}
	focusPreviousColumn() {
		if (this.isFocusPreviousPossible()) {
			window.getSelection()?.empty();
			return this.focus(assertNotNull(this.getPreviousColumn(), "previous column was null!"));
		} else return Promise.resolve();
	}
	focusNextColumn() {
		const indexOfCurrent = this.viewColumns.indexOf(this.focusedColumn);
		if (indexOfCurrent + 1 < this.viewColumns.length) this.focus(this.viewColumns[indexOfCurrent + 1]);
	}
	getPreviousColumn() {
		if (this.viewColumns.indexOf(this.visibleBackgroundColumns[0]) > 0 && !this.focusedColumn.isInForeground) {
			let visibleColumnIndex = this.viewColumns.indexOf(this.visibleBackgroundColumns[0]);
			return this.viewColumns[visibleColumnIndex - 1];
		}
		return null;
	}
	isFirstBackgroundColumnFocused() {
		return this.viewColumns.filter((column) => column.columnType === ColumnType.Background).indexOf(this.focusedColumn) === 0;
	}
	isForegroundColumnFocused() {
		return this.focusedColumn && this.focusedColumn.columnType === ColumnType.Foreground;
	}
	allColumnsVisible() {
		return this.visibleBackgroundColumns.length === this.viewColumns.length;
	}
	attachTouchHandler(element) {
		let lastGestureInfo;
		let oldGestureInfo;
		let initialGestureInfo;
		const VERTICAL = 1;
		const HORIZONTAL = 2;
		let directionLock = 0;
		const gestureEnd = (event) => {
			const safeLastGestureInfo = lastGestureInfo;
			const safeOldGestureInfo = oldGestureInfo;
			if (safeLastGestureInfo && safeOldGestureInfo && !this.allColumnsVisible()) {
				const touch = event.changedTouches[0];
				const mainCol = this.mainColumn.domColumn;
				const sideCol = this.getSideColDom();
				if (!mainCol || !sideCol) return;
				const mainColRect = mainCol.getBoundingClientRect();
				const velocity = (safeLastGestureInfo.x - safeOldGestureInfo.x) / (safeLastGestureInfo.time - safeOldGestureInfo.time);
				const show = () => {
					this.focusedColumn = this.viewColumns[0];
					this.busy = this.slideForegroundColumn(this.viewColumns[0], true);
					this.isModalBackgroundVisible = true;
				};
				const hide = () => {
					this.focusedColumn = this.viewColumns[1];
					this.busy = this.slideForegroundColumn(this.viewColumns[0], false);
					this.isModalBackgroundVisible = false;
				};
				if (this.getBackgroundColumns()[0].isVisible || this.focusedColumn.isInForeground) {
					if (velocity > .8) show();
else if (velocity < -.8 && directionLock !== VERTICAL) hide();
else if (touch.pageX > mainColRect.left + 100) show();
else if (directionLock !== VERTICAL) hide();
				} else if ((safeLastGestureInfo.x > window.innerWidth / 3 || velocity > .8) && directionLock !== VERTICAL) this.focusPreviousColumn();
else {
					const colRect = this.domSlidingPart.getBoundingClientRect();
					this.busy = this.slideBackgroundColumns(this.focusedColumn, colRect.left, -this.focusedColumn.offset);
					this.focus(this.focusedColumn);
				}
				this.busy.then(() => mithril_default.redraw());
			}
			if (safeLastGestureInfo && safeLastGestureInfo.identifier === event.changedTouches[0].identifier) {
				lastGestureInfo = null;
				oldGestureInfo = null;
				initialGestureInfo = null;
				directionLock = 0;
			}
		};
		const listeners = {
			touchstart: (event) => {
				if (lastGestureInfo) return;
				const mainCol = this.mainColumn.domColumn;
				const sideCol = this.getSideColDom();
				if (!mainCol || !sideCol || this.allColumnsVisible()) {
					lastGestureInfo = null;
					return;
				}
				if (event.touches.length === 1 && (this.viewColumns[0].isInForeground || event.touches[0].pageX < 40)) {
					if (!this.viewColumns[0].isInForeground) event.stopPropagation();
					lastGestureInfo = initialGestureInfo = gestureInfoFromTouch(event.touches[0]);
				}
			},
			touchmove: (event) => {
				const sideCol = this.getSideColDom();
				if (!sideCol || !this.mainColumn || this.allColumnsVisible()) return;
				const gestureInfo = lastGestureInfo;
				const safeInitialGestureInfo = initialGestureInfo;
				if (gestureInfo && safeInitialGestureInfo && event.touches.length === 1) {
					const touch = event.touches[0];
					const newTouchPos = touch.pageX;
					const sideColRect = sideCol.getBoundingClientRect();
					oldGestureInfo = lastGestureInfo;
					const safeLastInfo = lastGestureInfo = gestureInfoFromTouch(touch);
					if (directionLock === HORIZONTAL || directionLock !== VERTICAL && Math.abs(safeLastInfo.x - safeInitialGestureInfo.x) > 30) {
						directionLock = HORIZONTAL;
						if (this.getBackgroundColumns()[0].isVisible || this.focusedColumn.isInForeground) {
							const newTranslate = Math.min(sideColRect.left - (gestureInfo.x - newTouchPos), 0);
							sideCol.style.transform = `translateX(${newTranslate}px)`;
						} else {
							const slidingDomRect = this.domSlidingPart.getBoundingClientRect();
							const newTranslate = Math.max(slidingDomRect.left - (gestureInfo.x - newTouchPos), -this.focusedColumn.offset);
							this.domSlidingPart.style.transform = `translateX(${newTranslate}px)`;
						}
						if (event.cancelable !== false) event.preventDefault();
					} else if (directionLock !== VERTICAL && Math.abs(safeLastInfo.y - safeInitialGestureInfo.y) > 30) directionLock = VERTICAL;
					event.stopPropagation();
				}
			},
			touchend: gestureEnd,
			touchcancel: gestureEnd
		};
		for (let [name, listener] of Object.entries(listeners)) element.addEventListener(name, listener, true);
	}
};

//#endregion
//#region ../src/common/gui/base/NavBar.ts
assertMainOrNode();
var NavBar = class {
	view({ children }) {
		return mithril_default("nav.nav-bar.flex-end", landmarkAttrs(AriaLandmarks.Navigation, "top"), children.map((child) => mithril_default(".plr-nav-button", child)));
	}
};

//#endregion
//#region ../src/common/gui/Header.ts
assertMainOrNode();
var Header = class {
	view({ attrs }) {
		return mithril_default(DesktopBaseHeader, [mithril_default(ProgressBar, { progress: attrs.offlineIndicatorModel.getProgress() }), this.renderNavigation(attrs)]);
	}
	/**
	* render the search and navigation bar in three-column layouts. if there is a navigation, also render an offline indicator.
	* @private
	*/
	renderNavigation(attrs) {
		return mithril_default(".flex-grow.flex.justify-end.items-center", [
			attrs.searchBar ? attrs.searchBar() : null,
			mithril_default(OfflineIndicator, attrs.offlineIndicatorModel.getCurrentAttrs()),
			mithril_default(".nav-bar-spacer"),
			mithril_default(NavBar, this.renderButtons())
		]);
	}
	renderButtons() {
		return [
			mithril_default(NavButton, {
				label: "emails_label",
				icon: () => BootIcons.Mail,
				href: MAIL_PREFIX,
				isSelectedPrefix: MAIL_PREFIX,
				colors: NavButtonColor.Header
			}),
			locator.logins.isInternalUserLoggedIn() && !locator.logins.isEnabled(FeatureType.DisableContacts) ? mithril_default(NavButton, {
				label: "contacts_label",
				icon: () => BootIcons.Contacts,
				href: CONTACTS_PREFIX,
				isSelectedPrefix: isSelectedPrefix(CONTACTS_PREFIX) || isSelectedPrefix(CONTACTLIST_PREFIX),
				colors: NavButtonColor.Header
			}) : null,
			locator.logins.isInternalUserLoggedIn() && !locator.logins.isEnabled(FeatureType.DisableCalendar) ? mithril_default(NavButton, {
				label: "calendar_label",
				icon: () => BootIcons.Calendar,
				href: CALENDAR_PREFIX,
				colors: NavButtonColor.Header,
				click: () => mithril_default.route.get().startsWith(CALENDAR_PREFIX)
			}) : null
		];
	}
};

//#endregion
//#region ../src/mail-app/contacts/view/MultiContactViewer.ts
assertMainOrNode();
var MultiContactViewer = class {
	view({ attrs }) {
		return [mithril_default(ColumnEmptyMessageBox, {
			message: getContactSelectionMessage(attrs.selectedEntities.length),
			icon: BootIcons.Contacts,
			color: theme.content_message_bg,
			bottomContent: attrs.selectedEntities.length > 0 ? mithril_default(Button, {
				label: "cancel_action",
				type: ButtonType.Secondary,
				click: () => attrs.selectNone()
			}) : undefined,
			backgroundColor: theme.navigation_bg
		})];
	}
};
function getContactSelectionMessage(numberEntities) {
	if (numberEntities === 0) return lang.getTranslation("noContact_msg");
else return lang.getTranslation("nbrOfContactsSelected_msg", { "{1}": numberEntities });
}

//#endregion
//#region ../src/common/gui/base/TextDisplayArea.ts
var TextDisplayArea = class {
	view(vnode) {
		return mithril_default(".flex.flex-grow.flex-column.text.pt", [mithril_default("label.text-ellipsis.noselect.z1.i.pr-s", { style: { fontSize: px(size.font_size_small) } }, lang.getTranslationText(vnode.attrs.label)), mithril_default(".text-pre.flex-grow", {
			style: {
				borderBottom: `1px solid ${theme.content_border}`,
				lineHeight: px(inputLineHeight),
				minHeight: px(inputLineHeight)
			},
			isReadOnly: true
		}, vnode.attrs.value)]);
	}
};

//#endregion
//#region ../src/mail-app/contacts/view/ContactMergeView.ts
var ContactMergeView = class {
	dialog;
	contact1;
	contact2;
	resolveFunction = null;
	windowCloseUnsubscribe = null;
	constructor(contact1, contact2) {
		this.contact1 = contact1;
		this.contact2 = contact2;
		const cancelAction = () => {
			this._close(ContactMergeAction.Cancel);
		};
		const headerBarAttrs = {
			left: [{
				label: "cancel_action",
				click: cancelAction,
				type: ButtonType.Secondary
			}],
			right: [{
				label: "skip_action",
				click: () => this._close(ContactMergeAction.Skip),
				type: ButtonType.Primary
			}],
			middle: "merge_action"
		};
		this.dialog = Dialog.largeDialog(headerBarAttrs, this).setCloseHandler(cancelAction).addShortcut({
			key: Keys.ESC,
			exec: () => {
				this._close(ContactMergeAction.Cancel);
				return false;
			},
			help: "close_alt"
		});
	}
	view() {
		const { mailAddresses: mailAddresses1, phones: phones1, addresses: addresses1, socials: socials1 } = this._createContactFields(this.contact1);
		const { mailAddresses: mailAddresses2, phones: phones2, addresses: addresses2, socials: socials2 } = this._createContactFields(this.contact2);
		let emptyFieldPlaceholder = mithril_default(TextField, {
			label: "emptyString_msg",
			value: "",
			isReadOnly: true
		});
		let emptyHTMLFieldPlaceholder = mithril_default(new HtmlEditor("emptyString_msg").showBorders().setValue("").setReadOnly(false).setMode(HtmlEditorMode.HTML).setHtmlMonospace(false));
		let titleFields = this._createTextFields(this.contact1.title, this.contact2.title, "title_placeholder");
		let firstNameFields = this._createTextFields(this.contact1.firstName, this.contact2.firstName, "firstName_placeholder");
		let lastNameFields = this._createTextFields(this.contact1.lastName, this.contact2.lastName, "lastName_placeholder");
		let nicknameFields = this._createTextFields(this.contact1.nickname, this.contact2.nickname, "nickname_placeholder");
		let companyFields = this._createTextFields(this.contact1.company, this.contact2.company, "company_label");
		let roleFields = this._createTextFields(this.contact1.role, this.contact2.role, "role_placeholder");
		let birthdayFields = this._createTextFields(formatContactDate(this.contact1.birthdayIso), formatContactDate(this.contact2.birthdayIso), "birthday_alt");
		let presharedPasswordFields = this._createTextFields(this.contact1.presharedPassword && this.contact1.presharedPassword.length > 0 ? "***" : "", this.contact2.presharedPassword && this.contact2.presharedPassword.length > 0 ? "***" : "", "presharedPassword_label");
		let commentField1 = null;
		let commentField2 = null;
		if (this.contact1.comment || this.contact2.comment) {
			commentField1 = mithril_default(TextDisplayArea, {
				label: "comment_label",
				value: this.contact1.comment
			});
			commentField2 = mithril_default(TextDisplayArea, {
				label: "comment_label",
				value: this.contact2.comment
			});
		}
		return mithril_default("#contact-editor", {
			oncreate: () => this.windowCloseUnsubscribe = windowFacade.addWindowCloseListener(() => {}),
			onremove: () => this.windowCloseUnsubscribe?.()
		}, [
			mithril_default(".flex-center.mt", [mithril_default(".full-width.max-width-s", [mithril_default(LoginButton, {
				label: "mergeContacts_action",
				onclick: () => this._close(ContactMergeAction.Merge)
			})])]),
			mithril_default(".non-wrapping-row", [mithril_default(
				"",
				/*first contact */
				[mithril_default(".items-center", [mithril_default(".items-base.flex-space-between", [mithril_default(".h4.mt-l", lang.get("firstMergeContact_label")), this._createDeleteContactButton(ContactMergeAction.DeleteFirst)])])]
), mithril_default(
				"",
				/*second contact */
				[mithril_default(".items-center", [mithril_default(".items-base.flex-space-between", [mithril_default(".h4.mt-l", lang.get("secondMergeContact_label")), this._createDeleteContactButton(ContactMergeAction.DeleteSecond)])])]
)]),
			titleFields ? mithril_default(".non-wrapping-row", titleFields) : null,
			firstNameFields ? mithril_default(".non-wrapping-row", firstNameFields) : null,
			lastNameFields ? mithril_default(".non-wrapping-row", lastNameFields) : null,
			nicknameFields ? mithril_default(".non-wrapping-row", nicknameFields) : null,
			companyFields ? mithril_default(".non-wrapping-row", companyFields) : null,
			birthdayFields ? mithril_default(".non-wrapping-row", birthdayFields) : null,
			roleFields ? mithril_default(".non-wrapping-row", roleFields) : null,
			mailAddresses1.length > 0 || mailAddresses2.length > 0 ? mithril_default(".non-wrapping-row", [mithril_default(".mail.mt-l", [mithril_default("", lang.get("email_label")), mailAddresses1.length > 0 ? mailAddresses1 : emptyFieldPlaceholder]), mithril_default(".mail.mt-l", [mithril_default("", lang.get("email_label")), mailAddresses2.length > 0 ? mailAddresses2 : emptyFieldPlaceholder])]) : null,
			phones1.length > 0 || phones2.length > 0 ? mithril_default(".non-wrapping-row", [mithril_default(".phone.mt-l", [mithril_default("", lang.get("phone_label")), mithril_default(".aggregateEditors", [phones1.length > 0 ? phones1 : emptyFieldPlaceholder])]), mithril_default(".phone.mt-l", [mithril_default("", lang.get("phone_label")), mithril_default(".aggregateEditors", [phones2.length > 0 ? phones2 : emptyFieldPlaceholder])])]) : null,
			addresses1.length > 0 || addresses2.length > 0 ? mithril_default(".non-wrapping-row", [mithril_default(".address.mt-l.flex.flex-column", [mithril_default("", lang.get("address_label")), mithril_default(".aggregateEditors.flex.flex-column.flex-grow", [addresses1.length > 0 ? addresses1 : emptyHTMLFieldPlaceholder])]), mithril_default(".address.mt-l", [mithril_default("", lang.get("address_label")), mithril_default(".aggregateEditors.flex.flex-column.flex-grow", [addresses2.length > 0 ? addresses2 : emptyHTMLFieldPlaceholder])])]) : null,
			socials1.length > 0 || socials2.length > 0 ? mithril_default(".non-wrapping-row", [mithril_default(".social.mt-l", [mithril_default("", lang.get("social_label")), mithril_default(".aggregateEditors", socials1.length > 0 ? socials1 : emptyFieldPlaceholder)]), mithril_default(".social.mt-l", [mithril_default("", lang.get("social_label")), mithril_default(".aggregateEditors", socials2.length > 0 ? socials2 : emptyFieldPlaceholder)])]) : null,
			commentField1 && commentField2 ? mithril_default(".non-wrapping-row", [mithril_default(".mt-l.flex.flex-column", [commentField1]), mithril_default(".mt-l.flex.flex-column", [commentField2])]) : null,
			presharedPasswordFields ? mithril_default(".non-wrapping-row", presharedPasswordFields) : null,
			mithril_default(
				"",
				{ style: { height: "5px" } }
				/*Used as spacer so the last gui-element is not touching the window border*/
)
		]);
	}
	_createContactFields(contact) {
		const mailAddresses = contact.mailAddresses.map((element) => {
			return mithril_default(TextField, {
				label: getContactAddressTypeLabel(element.type, element.customTypeName),
				value: element.address,
				isReadOnly: true
			});
		});
		const phones = contact.phoneNumbers.map((element) => {
			return mithril_default(TextField, {
				label: getContactPhoneNumberTypeLabel(element.type, element.customTypeName),
				value: element.number,
				isReadOnly: true
			});
		});
		const addresses = contact.addresses.map((element) => {
			return mithril_default(TextDisplayArea, {
				value: element.address,
				label: getContactAddressTypeLabel(downcast(element.type), element.customTypeName)
			});
		});
		const socials = contact.socialIds.map((element) => {
			return mithril_default(TextField, {
				label: getContactSocialTypeLabel(getContactSocialType(element), element.customTypeName),
				value: element.socialId,
				isReadOnly: true
			});
		});
		return {
			mailAddresses,
			phones,
			addresses,
			socials
		};
	}
	_createTextFields(value1, value2, labelTextId) {
		if (value1 || value2) return [mithril_default(TextField, {
			label: labelTextId,
			value: value1 || "",
			isReadOnly: true
		}), mithril_default(TextField, {
			label: labelTextId,
			value: value2 || "",
			isReadOnly: true
		})];
else return null;
	}
	_createDeleteContactButton(action) {
		return mithril_default(IconButton, {
			title: "delete_action",
			click: () => {
				Dialog.confirm("deleteContact_msg").then((confirmed) => {
					if (confirmed) this._close(action);
				});
			},
			icon: Icons.Trash
		});
	}
	show() {
		this.dialog.show();
		let d = defer();
		this.resolveFunction = d.resolve;
		return d.promise;
	}
	_close(action) {
		this.dialog.close();
		delay(200).then(() => {
			this.resolveFunction?.(action);
		});
	}
};

//#endregion
//#region ../src/common/gui/nav/NavFunctions.ts
function showUpgradeDialog() {
	import("./UpgradeSubscriptionWizard-CBu6JZbq.js").then((upgradeWizard) => upgradeWizard.showUpgradeWizard(locator.logins));
}
function showSupportDialog(logins) {
	import("./SupportDialog-eddmFGRG.js").then((supportModule) => supportModule.showSupportDialog(logins));
}

//#endregion
//#region ../src/common/misc/news/NewsList.ts
var NewsList = class {
	view(vnode) {
		if (vnode.attrs.liveNewsIds.length === 0) return mithril_default(ColumnEmptyMessageBox, {
			message: "noNews_msg",
			icon: Icons.Bulb,
			color: theme.content_message_bg
		});
		return mithril_default("", vnode.attrs.liveNewsIds.map((liveNewsId) => {
			const newsListItem = vnode.attrs.liveNewsListItems[liveNewsId.newsItemName];
			return mithril_default(".pt.pl-l.pr-l.flex.fill.border-grey.left.list-border-bottom", { key: liveNewsId.newsItemId }, newsListItem.render(liveNewsId));
		}));
	}
};

//#endregion
//#region ../src/common/misc/news/NewsDialog.ts
function showNewsDialog(newsModel) {
	const closeButton = {
		label: "close_alt",
		type: ButtonType.Secondary,
		click: () => {
			closeAction();
		}
	};
	const closeAction = () => {
		dialog.close();
	};
	const header = {
		left: [closeButton],
		middle: "news_label"
	};
	let loaded = false;
	newsModel.loadNewsIds().then(() => {
		loaded = true;
		mithril_default.redraw();
	});
	const child = { view: () => {
		return [mithril_default("", [loaded ? mithril_default(NewsList, {
			liveNewsIds: newsModel.liveNewsIds,
			liveNewsListItems: newsModel.liveNewsListItems
		}) : mithril_default(".flex-center.mt-l", mithril_default(".flex-v-center", [mithril_default(".full-width.flex-center", progressIcon()), mithril_default("p", lang.getTranslationText("pleaseWait_msg"))]))])];
	} };
	const dialog = new Dialog(DialogType.EditLarge, { view: () => {
		return mithril_default("", [mithril_default(DialogHeaderBar, header), mithril_default(".dialog-container.scroll", mithril_default(".fill-absolute", mithril_default(child)))]);
	} }).addShortcut({
		key: Keys.ESC,
		exec: () => {
			closeAction();
		},
		help: "close_alt"
	});
	dialog.show();
}

//#endregion
//#region ../src/common/gui/nav/DrawerMenu.ts
var DrawerMenu = class {
	view(vnode) {
		const { logins, newsModel, desktopSystemFacade } = vnode.attrs;
		const liveNewsCount = newsModel.liveNewsIds.length;
		const isInternalUser = logins.isInternalUserLoggedIn();
		const isLoggedIn = logins.isUserLoggedIn();
		const userController = logins.getUserController();
		return mithril_default("drawer-menu.flex.col.items-center.pt.pb", {
			...landmarkAttrs(AriaLandmarks.Contentinfo, "drawer menu"),
			style: {
				"padding-left": getSafeAreaInsetLeft(),
				"border-top-right-radius": styles.isDesktopLayout() ? px(size.border_radius_larger) : ""
			}
		}, [
			mithril_default(".flex-grow"),
			isInternalUser && isLoggedIn ? mithril_default(".news-button", [mithril_default(IconButton, {
				icon: Icons.Bulb,
				title: "news_label",
				click: () => showNewsDialog(newsModel),
				colors: ButtonColor.DrawerNav
			}), liveNewsCount > 0 ? mithril_default(CounterBadge, {
				count: liveNewsCount,
				position: {
					top: px(0),
					right: px(3)
				},
				color: "white",
				background: theme.list_accent_fg
			}) : null]) : null,
			logins.isGlobalAdminUserLoggedIn() && userController.isPremiumAccount() ? mithril_default(IconButton, {
				icon: Icons.Gift,
				title: "buyGiftCard_label",
				click: () => {
					mithril_default.route.set("/settings/subscription");
					import("./PurchaseGiftCardDialog-DeBqCvPo.js").then(({ showPurchaseGiftCardDialog }) => {
						return showPurchaseGiftCardDialog();
					});
				},
				colors: ButtonColor.DrawerNav
			}) : null,
			desktopSystemFacade ? mithril_default(IconButton, {
				icon: Icons.NewWindow,
				title: "openNewWindow_action",
				click: () => {
					desktopSystemFacade.openNewWindow();
				},
				colors: ButtonColor.DrawerNav
			}) : null,
			!isIOSApp() && isLoggedIn && userController.isFreeAccount() ? mithril_default(IconButton, {
				icon: BootIcons.Premium,
				title: "upgradePremium_label",
				click: () => showUpgradeDialog(),
				colors: ButtonColor.DrawerNav
			}) : null,
			mithril_default(IconButton, {
				title: "showHelp_action",
				icon: BootIcons.Help,
				click: (e, dom) => createDropdown({
					width: 300,
					lazyButtons: () => [{
						label: "supportMenu_label",
						click: () => showSupportDialog(logins)
					}, {
						label: "keyboardShortcuts_title",
						click: () => keyManager.openF1Help(true)
					}]
				})(e, dom),
				colors: ButtonColor.DrawerNav
			}),
			isInternalUser ? mithril_default(IconButton, {
				icon: BootIcons.Settings,
				title: "settings_label",
				click: () => mithril_default.route.set(SETTINGS_PREFIX),
				colors: ButtonColor.DrawerNav
			}) : null,
			mithril_default(IconButton, {
				icon: BootIcons.Logout,
				title: "switchAccount_action",
				click: () => mithril_default.route.set(LogoutUrl),
				colors: ButtonColor.DrawerNav
			})
		]);
	}
};

//#endregion
//#region ../src/common/gui/FolderColumnView.ts
var FolderColumnView = class {
	view({ attrs }) {
		return mithril_default(".flex.height-100p.nav-bg", [mithril_default(DrawerMenu, attrs.drawer), mithril_default(".folder-column.flex-grow.overflow-x-hidden.flex.col", landmarkAttrs(AriaLandmarks.Navigation, lang.getTranslationText(attrs.ariaLabel)), [this.renderMainButton(attrs), mithril_default(".scroll.scrollbar-gutter-stable-or-fallback.visible-scrollbar.overflow-x-hidden.flex.col.flex-grow", { onscroll: (e) => {
			e.redraw = false;
			const target = e.target;
			if (attrs.button == null || target.scrollTop === 0) target.style.borderTop = "";
else target.style.borderTop = `1px solid ${theme.content_border}`;
		} }, attrs.content)])]);
	}
	renderMainButton(attrs) {
		if (attrs.button) return mithril_default(".plr-button-double.scrollbar-gutter-stable-or-fallback.scroll", mithril_default(MainCreateButton, {
			label: attrs.button.label,
			click: attrs.button.click
		}));
else return null;
	}
};

//#endregion
//#region ../src/common/gui/SidebarSection.ts
var import_stream = __toESM(require_stream(), 1);
var SidebarSection = class {
	expanded = (0, import_stream.default)(true);
	view(vnode) {
		const { name, button, hideIfEmpty } = vnode.attrs;
		const content = vnode.children;
		if (hideIfEmpty && content == false) return null;
		return mithril_default(".sidebar-section", {
			"data-testid": `section:${lang.getTestId(name)}`,
			style: { color: theme.navigation_button }
		}, [mithril_default(".folder-row.flex-space-between.plr-button.pt-s.button-height", [mithril_default("small.b.align-self-center.text-ellipsis.plr-button", lang.getTranslationText(name).toLocaleUpperCase()), button ?? null]), content]);
	}
};

//#endregion
//#region ../src/common/gui/MobileActionBar.ts
var MobileActionBar = class {
	view(vnode) {
		const { attrs } = vnode;
		return mithril_default(".bottom-nav.bottom-action-bar.flex.items-center.plr-l", { style: { justifyContent: "space-around" } }, attrs.actions.map((action) => mithril_default(IconButton, {
			title: action.title,
			icon: action.icon,
			click: action.action
		})));
	}
};

//#endregion
//#region ../src/common/gui/BackgroundColumnLayout.ts
var BackgroundColumnLayout = class {
	view({ attrs }) {
		return mithril_default(".list-column.flex.col.fill-absolute", {
			style: { backgroundColor: attrs.backgroundColor },
			class: attrs.classes ?? ""
		}, [
			styles.isUsingBottomNavigation() ? attrs.mobileHeader() : attrs.desktopToolbar(),
			mithril_default(".flex-grow.rel", attrs.columnLayout),
			attrs.floatingActionButton?.()
		]);
	}
};

//#endregion
//#region ../src/common/gui/DesktopToolbars.ts
const DesktopListToolbar = pureComponent((__, children) => {
	return mithril_default(".flex.pt-xs.pb-xs.items-center.list-bg", { style: {
		"border-radius": `${size.border_radius}px 0 0 ${size.border_radius}px`,
		marginLeft: `5px`,
		marginBottom: px(size.hpad_large)
	} }, children);
});
const DesktopViewerToolbar = pureComponent((__, children) => {
	return mithril_default(".scrollbar-gutter-stable-or-fallback.overflow-y-hidden.noprint", {
		class: responsiveCardHMargin(),
		style: {
			marginLeft: 0,
			marginBottom: px(size.hpad_large)
		}
	}, mithril_default(".flex.list-bg.pt-xs.pb-xs.plr-m", { style: { "border-radius": `0 ${size.border_radius_larger}px ${size.border_radius_larger}px 0` } }, [mithril_default(".flex-grow", { style: { height: px(size.button_height) } }), children]));
});

//#endregion
//#region ../src/mail-app/contacts/view/ContactViewerActions.ts
var ContactViewerActions = class {
	shortcuts = [];
	view({ attrs }) {
		const { contacts, onDelete, onEdit, onMerge, onExport } = attrs;
		const actionButtons = [];
		if (this.canEdit(contacts)) actionButtons.push(mithril_default(IconButton, {
			title: "edit_action",
			click: () => onEdit(contacts[0]),
			icon: Icons.Edit
		}));
else if (this.canMerge(contacts)) actionButtons.push(mithril_default(IconButton, {
			title: "merge_action",
			click: () => onMerge(contacts[0], contacts[1]),
			icon: Icons.People
		}));
		if (this.canExport(contacts)) actionButtons.push(mithril_default(IconButton, {
			title: "export_action",
			click: () => onExport(contacts),
			icon: Icons.Export
		}));
		if (this.canDelete(contacts)) actionButtons.push(mithril_default(IconButton, {
			title: "delete_action",
			click: () => onDelete(contacts),
			icon: Icons.Trash
		}));
		return actionButtons;
	}
	onupdate(vnode) {
		keyManager.unregisterShortcuts(this.shortcuts);
		this.shortcuts.length = 0;
		const { contacts, onEdit, onDelete, onMerge, onExport } = vnode.attrs;
		if (this.canEdit(contacts)) this.shortcuts.push({
			key: Keys.E,
			exec: () => {
				onEdit(contacts[0]);
			},
			help: "edit_action"
		});
		if (this.canMerge(contacts)) this.shortcuts.push({
			key: Keys.M,
			ctrlOrCmd: true,
			exec: () => {
				onMerge(contacts[0], contacts[1]);
			},
			help: "merge_action"
		});
		if (this.canExport(contacts)) this.shortcuts.push({
			key: Keys.E,
			ctrlOrCmd: true,
			exec: () => {
				onExport(contacts);
			},
			help: "export_action"
		});
		keyManager.registerShortcuts(this.shortcuts);
	}
	onremove() {
		keyManager.unregisterShortcuts(this.shortcuts);
	}
	canExport(contacts) {
		return contacts.length > 0;
	}
	canMerge(contacts) {
		return contacts.length === 2;
	}
	canDelete(contacts) {
		return contacts.length > 0;
	}
	canEdit(contacts) {
		return contacts.length === 1;
	}
};

//#endregion
//#region ../src/common/gui/MobileBottomActionBar.ts
const MobileBottomActionBar = pureComponent((_, children) => {
	return mithril_default(".bottom-nav.flex.items-center.plr-l.justify-between", children);
});

//#endregion
//#region ../src/mail-app/contacts/view/ImportAsVCard.ts
async function importAsVCard() {
	const allowedExtensions = ["vcf"];
	const contactFiles = isApp() ? await showNativeFilePicker(allowedExtensions, true) : await showFileChooser(true, allowedExtensions);
	if (contactFiles.length <= 0) return;
	return showProgressDialog("pleaseWait_msg", (async () => {
		const contactImporter = await mailLocator.contactImporter();
		const contactListId = await locator.contactModel.getContactListId();
		const vCardList = contactFiles.flatMap((contactFile) => {
			return utf8Uint8ArrayToString(contactFile.data);
		});
		await contactImporter.importContactsFromFile(vCardList, contactListId);
	})());
}
function exportAsVCard(contactModel) {
	return showProgressDialog("pleaseWait_msg", contactModel.getContactListId().then((contactListId) => {
		if (!contactListId) return 0;
		return locator.entityClient.loadAll(ContactTypeRef, contactListId).then((allContacts) => {
			if (allContacts.length === 0) return 0;
else return exportContacts(allContacts).then(() => allContacts.length);
		});
	})).then((nbrOfContacts) => {
		if (nbrOfContacts === 0) Dialog.message("noContacts_msg");
	});
}

//#endregion
//#region ../src/common/gui/BaseMobileHeader.ts
const BaseMobileHeader = pureComponent(({ left, center, right, injections }) => {
	return mithril_default(".flex.items-center.rel.button-height.mt-safe-inset.plr-safe-inset", { style: { height: px(size.navbar_height_mobile) } }, [
		left ?? null,
		mithril_default(".flex-grow.flex.items-center.min-width-0", { class: !left ? "ml-hpad_small" : "" }, center ?? null),
		right ?? null,
		injections ?? null
	]);
});

//#endregion
//#region ../src/common/gui/MobileHeader.ts
var MobileHeader = class {
	view({ attrs }) {
		const firstVisibleColumn = attrs.columnType === "first" || styles.isSingleColumnLayout();
		return mithril_default(BaseMobileHeader, {
			left: this.renderLeftAction(attrs),
			center: firstVisibleColumn ? mithril_default(MobileHeaderTitle, {
				title: attrs.title ? lang.getTranslationText(attrs.title) : undefined,
				bottom: mithril_default(OfflineIndicator, attrs.offlineIndicatorModel.getCurrentAttrs())
			}) : null,
			right: [
				styles.isSingleColumnLayout() ? null : attrs.multicolumnActions?.(),
				attrs.actions,
				styles.isSingleColumnLayout() || attrs.columnType === "other" ? attrs.primaryAction() : null
			],
			injections: firstVisibleColumn ? mithril_default(ProgressBar, { progress: attrs.offlineIndicatorModel.getProgress() }) : null
		});
	}
	renderLeftAction(attrs) {
		if (attrs.columnType === "first" && !attrs.useBackButton) return mithril_default(MobileHeaderMenuButton, {
			newsModel: attrs.newsModel,
			backAction: attrs.backAction
		});
else if (styles.isSingleColumnLayout() || attrs.useBackButton) return mithril_default(MobileHeaderBackButton, { backAction: attrs.backAction });
		return null;
	}
};
const MobileHeaderBackButton = pureComponent(({ backAction }) => {
	return mithril_default(IconButton, {
		title: "back_action",
		icon: BootIcons.Back,
		click: () => {
			backAction();
		}
	});
});
const MobileHeaderTitle = pureComponent(({ title, bottom, onTap }) => {
	return mithril_default(".flex.col.items-start.min-width-0", [mithril_default((onTap ? "button" : "") + ".font-weight-600.text-ellipsis.align-self-stretch", { onclick: (event) => onTap?.(event, event.target) }, title ?? NBSP), bottom]);
});
const MobileHeaderMenuButton = pureComponent(({ newsModel, backAction }) => {
	return mithril_default(".rel", [mithril_default(IconButton, {
		title: "menu_label",
		icon: BootIcons.MoreVertical,
		click: () => {
			backAction();
		}
	}), mithril_default(CounterBadge, {
		count: newsModel.liveNewsIds.length,
		position: {
			top: px(4),
			right: px(5)
		},
		color: "white",
		background: theme.list_accent_fg
	})]);
});

//#endregion
//#region ../src/mail-app/LazySearchBar.ts
var LazySearchBar = class LazySearchBar {
	static searchBar = new LazyLoaded(async () => {
		const { searchBar } = await import("./SearchBar-BqjukxBW.js");
		mithril_default.redraw();
		return searchBar;
	});
	oninit(vnode) {
		LazySearchBar.searchBar.load();
	}
	view(vnode) {
		const searchBar = LazySearchBar.searchBar.getSync();
		if (searchBar) return mithril_default(searchBar, vnode.attrs);
else return null;
	}
};
const lazySearchBar = new LazySearchBar();

//#endregion
//#region ../src/common/gui/MultiselectMobileHeader.ts
const MultiselectMobileHeader = pureComponent((attrs) => {
	const { selectAll, selectNone, selected, message } = attrs;
	return mithril_default(BaseMobileHeader, {
		left: mithril_default(SelectAllCheckbox, {
			selectNone,
			selectAll,
			selected
		}),
		center: mithril_default(".font-weight-600", lang.getTranslationText(message)),
		right: mithril_default(IconButton, {
			icon: Icons.Cancel,
			title: "cancel_action",
			click: () => selectNone()
		})
	});
});

//#endregion
//#region ../src/common/gui/EnterMultiselectIconButton.ts
const EnterMultiselectIconButton = pureComponent(({ clickAction }) => mithril_default(IconButton, {
	icon: Icons.AddCheckCirle,
	title: "selectMultiple_action",
	click: () => {
		clickAction();
	}
}));

//#endregion
//#region ../src/mail-app/contacts/view/ContactListRecipientView.ts
assertMainOrNode();
var ContactListRecipientView = class {
	viewModel = null;
	view({ attrs: { viewModel, focusDetailsViewer } }) {
		this.viewModel = viewModel;
		const listModel = this.viewModel.listModel;
		return mithril_default(ListColumnWrapper, { headerContent: null }, listModel == null || listModel.isEmptyAndDone() ? mithril_default(ColumnEmptyMessageBox, {
			color: theme.list_message_bg,
			message: "noEntries_msg",
			icon: Icons.People
		}) : mithril_default(List, {
			renderConfig: this.renderConfig,
			state: listModel.state,
			onLoadMore: () => listModel.loadMore(),
			onRetryLoading: () => listModel.retryLoading(),
			onStopLoading: () => listModel.stopLoading(),
			onSingleSelection: (item) => {
				listModel.onSingleSelection(item);
				focusDetailsViewer();
			},
			onSingleTogglingMultiselection: (item) => {
				listModel.onSingleInclusiveSelection(item, styles.isSingleColumnLayout());
			},
			onRangeSelectionTowards: (item) => {
				listModel.selectRangeTowards(item);
			}
		}));
	}
	renderConfig = {
		itemHeight: size.list_row_height,
		multiselectionAllowed: MultiselectMode.Enabled,
		swipe: null,
		createElement: (dom) => {
			const recipientEntryRow = new RecipientRow((entity) => this.viewModel?.listModel?.onSingleExclusiveSelection(entity));
			mithril_default.render(dom, recipientEntryRow.render());
			return recipientEntryRow;
		}
	};
};
var RecipientRow = class {
	top = 0;
	domElement = null;
	checkboxDom;
	checkboxWasVisible = shouldAlwaysShowMultiselectCheckbox();
	entity = null;
	selectionUpdater;
	titleDom;
	idDom;
	constructor(onSelected) {
		this.onSelected = onSelected;
	}
	update(entry, selected, isInMultiSelect) {
		this.entity = entry;
		this.selectionUpdater(selected, false);
		this.showCheckboxAnimated(shouldAlwaysShowMultiselectCheckbox() || isInMultiSelect);
		checkboxOpacity(this.checkboxDom, selected);
		this.checkboxDom.checked = selected && isInMultiSelect;
		this.titleDom.textContent = entry.emailAddress;
	}
	showCheckboxAnimated(show) {
		if (this.checkboxWasVisible === show) return;
		if (show) {
			this.titleDom.style.paddingRight = shiftByForCheckbox;
			const addressAnim = this.titleDom.animate({ transform: [translateXHide, translateXShow] }, selectableRowAnimParams);
			const checkboxAnim = this.checkboxDom.animate({ transform: [scaleXHide, scaleXShow] }, selectableRowAnimParams);
			Promise.all([addressAnim.finished, checkboxAnim.finished]).then(() => {
				addressAnim.cancel();
				checkboxAnim.cancel();
				this.showCheckbox(show);
			}, noOp);
		} else {
			this.titleDom.style.paddingRight = "0";
			const addressAnim = this.titleDom.animate({ transform: [translateXShow, translateXHide] }, selectableRowAnimParams);
			const checkboxAnim = this.checkboxDom.animate({ transform: [scaleXShow, scaleXHide] }, selectableRowAnimParams);
			Promise.all([addressAnim.finished, checkboxAnim.finished]).then(() => {
				addressAnim.cancel();
				checkboxAnim.cancel();
				this.showCheckbox(show);
			}, noOp);
		}
		this.checkboxWasVisible = show;
	}
	render() {
		return mithril_default(SelectableRowContainer, {
			oncreate: (vnode) => {
				Promise.resolve().then(() => this.showCheckbox(shouldAlwaysShowMultiselectCheckbox()));
			},
			onSelectedChangeRef: (updater) => this.selectionUpdater = updater
		}, mithril_default(".mt-xs.abs", [
			mithril_default(".text-ellipsis.smaller.mt-xxs", { style: { height: px(9) } }),
			mithril_default("input.checkbox.list-checkbox", {
				type: "checkbox",
				style: { transformOrigin: "left" },
				onclick: (e) => {
					e.stopPropagation();
				},
				onchange: () => {
					if (this.entity) this.onSelected(this.entity, this.checkboxDom.checked);
				},
				oncreate: (vnode) => {
					this.checkboxDom = vnode.dom;
					checkboxOpacity(this.checkboxDom, false);
				}
			}),
			mithril_default(".text-ellipsis.smaller.mt-xxs", { style: { height: px(9) } })
		]), mithril_default(".flex.col.overflow-hidden.flex-grow", [mithril_default("", [
			mithril_default(".text-ellipsis.smaller.mt-xxs", { style: { height: px(9) } }),
			mithril_default(".text-ellipsis.badge-line-height", { oncreate: (vnode) => this.titleDom = vnode.dom }),
			mithril_default(".text-ellipsis.smaller.mt-xxs", { style: { height: px(9) } })
		])]));
	}
	showCheckbox(show) {
		let translate;
		let scale;
		let padding;
		if (show) {
			translate = translateXShow;
			scale = scaleXShow;
			padding = shiftByForCheckbox;
		} else {
			translate = translateXHide;
			scale = scaleXHide;
			padding = "0";
		}
		this.titleDom.style.transform = translate;
		this.titleDom.style.paddingRight = padding;
		this.checkboxDom.style.transform = scale;
		this.checkboxDom.style.display = show ? "" : "none";
	}
};

//#endregion
//#region ../src/mail-app/contacts/view/ContactListEntryViewer.ts
var ContactListEntryViewer = class {
	view({ attrs }) {
		return mithril_default(".flex.flex-column", [
			mithril_default(".border-radius-big.rel", {
				class: responsiveCardHMargin(),
				style: { backgroundColor: theme.content_bg }
			}, mithril_default(".plr-l.pt.pb.mlr-safe-inset", mithril_default(".h2.selectable.text-break", attrs.entry.emailAddress))),
			mithril_default(".mt-l"),
			attrs.contacts.length >= 1 ? attrs.contacts.map((contact) => mithril_default(ContactCardViewer, {
				contact,
				onWriteMail: attrs.onWriteMail,
				editAction: attrs.contactEdit,
				deleteAction: attrs.contactDelete
			})) : mithril_default(".border-radius-big.rel", {
				class: responsiveCardHMargin(),
				style: { backgroundColor: theme.content_bg }
			}, mithril_default(".plr-l.pt.pb.mlr-safe-inset", lang.get("noContactFound_msg"), mithril_default(Button, {
				label: "createContact_action",
				click: () => {
					let newContact = createContact({
						mailAddresses: [createContactMailAddress({
							type: ContactAddressType.WORK,
							customTypeName: "",
							address: attrs.entry.emailAddress
						})],
						oldBirthdayAggregate: null,
						addresses: [],
						birthdayIso: null,
						comment: "",
						company: "",
						firstName: "",
						lastName: "",
						nickname: null,
						oldBirthdayDate: null,
						phoneNumbers: [],
						photo: null,
						role: "",
						presharedPassword: null,
						socialIds: [],
						title: null,
						department: null,
						middleName: null,
						nameSuffix: null,
						phoneticFirst: null,
						phoneticLast: null,
						phoneticMiddle: null,
						customDate: [],
						messengerHandles: [],
						pronouns: [],
						relationships: [],
						websites: []
					});
					attrs.contactCreate(newContact);
				},
				type: ButtonType.Primary
			})))
		]);
	}
};
function getContactListEntriesSelectionMessage(selectedEntities) {
	if (selectedEntities && selectedEntities.length > 0) return lang.getTranslation("nbrOfEntriesSelected_msg", { "{nbr}": selectedEntities.length });
else return lang.getTranslation("noSelection_msg");
}

//#endregion
//#region ../src/mail-app/gui/BottomNav.ts
const fontSize = size.font_size_small;
function getHrefForSearch() {
	const route = mithril_default.route.get();
	if (route.startsWith(SEARCH_PREFIX)) return route;
else if (route.startsWith(CONTACTS_PREFIX)) return "/search/contact";
else if (route.startsWith(CALENDAR_PREFIX)) return "/search/calendar";
else return "/search/mail";
}
var BottomNav = class {
	view(vnode) {
		return mithril_default("nav.bottom-nav.flex.items-center.z1", [
			mithril_default(NavButton, {
				label: "emails_label",
				icon: () => BootIcons.Mail,
				href: MAIL_PREFIX,
				vertical: true,
				fontSize
			}),
			locator.logins.isInternalUserLoggedIn() ? mithril_default(NavButton, {
				label: "search_label",
				icon: () => BootIcons.Search,
				href: () => getHrefForSearch(),
				isSelectedPrefix: SEARCH_PREFIX,
				vertical: true,
				fontSize
			}) : null,
			locator.logins.isInternalUserLoggedIn() && !locator.logins.isEnabled(FeatureType.DisableContacts) ? mithril_default(NavButton, {
				label: "contacts_label",
				icon: () => BootIcons.Contacts,
				href: () => CONTACTS_PREFIX,
				isSelectedPrefix: CONTACTS_PREFIX,
				vertical: true,
				fontSize
			}) : null,
			locator.logins.isInternalUserLoggedIn() && !locator.logins.isEnabled(FeatureType.DisableCalendar) ? mithril_default(NavButton, {
				label: "calendar_label",
				icon: () => BootIcons.Calendar,
				href: CALENDAR_PREFIX,
				vertical: true,
				fontSize
			}) : null
		]);
	}
};

//#endregion
//#region ../src/common/gui/base/SidebarSectionRow.ts
var SidebarSectionRow = class {
	hovered = false;
	view({ attrs }) {
		const onHover = () => {
			this.hovered = true;
		};
		const handleForwardsTab = (event) => {
			if (event.key === "Tab" && !event.shiftKey) this.hovered = false;
		};
		const handleBackwardsTab = (event) => {
			if (event.key === "Tab" && event.shiftKey) this.hovered = false;
		};
		const navButtonAttrs = {
			label: attrs.label,
			href: () => attrs.path,
			disableHoverBackground: true,
			click: attrs.onClick,
			onfocus: onHover,
			onkeydown: handleBackwardsTab,
			isSelectedPrefix: attrs.isSelectedPrefix,
			disabled: attrs.disabled
		};
		return mithril_default(".folder-row.flex.flex-row.mlr-button.border-radius-small.state-bg.border-radius-small", {
			style: { background: isNavButtonSelected(navButtonAttrs) ? stateBgHover : "" },
			onmouseenter: onHover,
			onmouseleave: () => {
				this.hovered = false;
			}
		}, [
			mithril_default(".button-height.flex.items-center.plr-button", mithril_default(Icon, {
				icon: attrs.icon,
				size: IconSize.Medium,
				style: { fill: attrs.iconColor ?? (isNavButtonSelected(navButtonAttrs) ? theme.navigation_button_selected : theme.navigation_button) }
			})),
			mithril_default(NavButton, navButtonAttrs),
			attrs.alwaysShowMoreButton || !client.isMobileDevice() && this.hovered ? mithril_default(IconButton, {
				...attrs.moreButton,
				click: (event, dom) => {
					attrs.moreButton.click(event, dom);
				},
				onkeydown: handleForwardsTab
			}) : null
		]);
	}
};

//#endregion
//#region ../src/mail-app/contacts/view/ContactView.ts
assertMainOrNode();
var ContactView = class extends BaseTopLevelView {
	listColumn;
	folderColumn;
	viewSlider;
	contactViewModel;
	contactListViewModel;
	detailsColumn;
	invitationRows;
	oncreate;
	onremove;
	constructor(vnode) {
		super();
		this.contactViewModel = vnode.attrs.contactViewModel;
		this.contactListViewModel = vnode.attrs.contactListViewModel;
		this.contactListViewModel.init();
		this.folderColumn = new ViewColumn({ view: () => mithril_default(FolderColumnView, {
			drawer: vnode.attrs.drawerAttrs,
			button: styles.isUsingBottomNavigation() ? null : {
				label: "newContact_action",
				click: () => this.createNewContact()
			},
			content: [mithril_default(SidebarSection, { name: lang.makeTranslation("group_info", getGroupInfoDisplayName(locator.logins.getUserController().userGroupInfo)) }, this.renderSidebarElements())],
			ariaLabel: "folderTitle_label"
		}) }, ColumnType.Foreground, {
			minWidth: size.first_col_min_width,
			maxWidth: size.first_col_max_width,
			headerCenter: "folderTitle_label"
		});
		this.listColumn = new ViewColumn({ view: () => this.inContactListView() ? this.renderContactListRecipientColumn(vnode.attrs.header) : this.renderContactListColumn(vnode.attrs.header) }, ColumnType.Background, {
			minWidth: size.second_col_min_width,
			maxWidth: size.second_col_max_width,
			headerCenter: this.getHeaderLabel()
		});
		this.detailsColumn = new ViewColumn({ view: () => mithril_default(BackgroundColumnLayout, {
			backgroundColor: theme.navigation_bg,
			desktopToolbar: () => mithril_default(DesktopViewerToolbar, this.detailsViewerActions()),
			mobileHeader: () => mithril_default(MobileHeader, {
				...vnode.attrs.header,
				backAction: () => this.viewSlider.focusPreviousColumn(),
				actions: null,
				multicolumnActions: () => this.detailsViewerActions(),
				primaryAction: () => {
					return this.inContactListView() ? null : this.renderHeaderRightView();
				},
				title: this.getHeaderLabel(),
				columnType: "other"
			}),
			columnLayout: mithril_default(".fill-absolute.flex.col.overflow-y-scroll", this.renderDetailsViewer())
		}) }, ColumnType.Background, {
			minWidth: size.third_col_min_width,
			maxWidth: size.third_col_max_width,
			ariaLabel: () => this.getHeaderLabel()
		});
		this.viewSlider = new ViewSlider([
			this.folderColumn,
			this.listColumn,
			this.detailsColumn
		]);
		const shortcuts = this.getShortcuts();
		this.oncreate = (vnode$1) => {
			keyManager.registerShortcuts(shortcuts);
		};
		this.onremove = () => {
			keyManager.unregisterShortcuts(shortcuts);
		};
	}
	renderContactListColumn(header) {
		return mithril_default(BackgroundColumnLayout, {
			backgroundColor: theme.navigation_bg,
			columnLayout: mithril_default(ContactListView, {
				contactViewModel: this.contactViewModel,
				onSingleSelection: () => {
					this.viewSlider.focus(this.detailsColumn);
				}
			}),
			desktopToolbar: () => this.renderListToolbar(),
			mobileHeader: () => this.contactViewModel.listModel.state.inMultiselect ? mithril_default(MultiselectMobileHeader, {
				...selectionAttrsForList(this.contactViewModel.listModel),
				message: getContactSelectionMessage(this.getSelectedContacts().length)
			}) : mithril_default(MobileHeader, {
				...header,
				backAction: () => this.viewSlider.focusPreviousColumn(),
				columnType: "first",
				title: this.listColumn.getTitle(),
				actions: mithril_default(".flex", [this.renderSortByButton(), mithril_default(EnterMultiselectIconButton, { clickAction: () => {
					this.contactViewModel.listModel.enterMultiselect();
				} })]),
				primaryAction: () => this.renderHeaderRightView()
			})
		});
	}
	renderContactListRecipientColumn(header) {
		return mithril_default(BackgroundColumnLayout, {
			backgroundColor: theme.navigation_bg,
			columnLayout: mithril_default(ContactListRecipientView, {
				viewModel: this.contactListViewModel,
				focusDetailsViewer: () => {
					this.viewSlider.focus(this.detailsColumn);
				}
			}),
			desktopToolbar: () => this.renderListToolbar(),
			mobileHeader: () => this.contactListViewModel.listModel?.state.inMultiselect ? mithril_default(MultiselectMobileHeader, {
				...selectionAttrsForList(this.contactListViewModel.listModel),
				message: getContactSelectionMessage(this.contactListViewModel.listModel?.getSelectedAsArray().length)
			}) : mithril_default(MobileHeader, {
				...header,
				backAction: () => this.viewSlider.focusPreviousColumn(),
				columnType: "first",
				title: this.listColumn.getTitle(),
				actions: mithril_default(".flex", [mithril_default(EnterMultiselectIconButton, { clickAction: () => {
					this.contactListViewModel.listModel?.enterMultiselect();
				} })]),
				primaryAction: () => {
					if (this.canEditSelectedContactList()) return mithril_default(IconButton, {
						title: "addEntries_action",
						click: () => this.addAddressesToContactList(),
						icon: Icons.Add
					});
else return null;
				}
			})
		});
	}
	canEditSelectedContactList() {
		const contactListInfo = this.contactListViewModel.getSelectedContactListInfo();
		return contactListInfo != null && contactListInfo.canEdit;
	}
	detailsViewerActions() {
		if (this.inContactListView()) {
			const recipients = this.contactListViewModel.getSelectedContactListEntries();
			if (recipients && recipients.length > 0 && this.canEditSelectedContactList()) return mithril_default(IconButton, {
				title: "delete_action",
				icon: Icons.Trash,
				click: () => this.contactListViewModel.deleteContactListEntries(recipients)
			});
		} else {
			const contacts = this.getSelectedContacts();
			return mithril_default(ContactViewerActions, {
				contacts,
				onEdit: (c) => this.editContact(c),
				onExport: exportContacts,
				onDelete: (contacts$1) => deleteContacts(contacts$1, () => this.contactViewModel.listModel.selectNone()),
				onMerge: confirmMerge
			});
		}
	}
	inContactListView() {
		return mithril_default.route.get().startsWith(CONTACTLIST_PREFIX);
	}
	showingListView() {
		return this.inContactListView() ? this.contactListViewModel.getSelectedContactListEntries()?.length === 0 || this.contactListViewModel.listModel?.state.inMultiselect : this.getSelectedContacts().length === 0 || this.contactViewModel.listModel.state.inMultiselect;
	}
	view({ attrs }) {
		this.getContactListInvitationRows();
		return mithril_default("#contact.main-view", mithril_default(this.viewSlider, {
			header: styles.isSingleColumnLayout() ? null : mithril_default(Header, {
				searchBar: () => this.inContactListView() ? null : mithril_default(LazySearchBar, {
					placeholder: lang.get("searchContacts_placeholder"),
					disabled: !locator.logins.isFullyLoggedIn()
				}),
				...attrs.header
			}),
			bottomNav: styles.isSingleColumnLayout() && this.viewSlider.focusedColumn === this.detailsColumn && !this.showingListView() ? this.inContactListView() ? mithril_default(MobileActionBar, { actions: this.canEditSelectedContactList() ? [{
				icon: Icons.Trash,
				title: "delete_action",
				action: () => this.contactListViewModel.deleteSelectedEntries()
			}] : [] }) : mithril_default(MobileActionBar, { actions: [{
				icon: Icons.Edit,
				title: "edit_action",
				action: () => this.editSelectedContact()
			}, {
				icon: Icons.Trash,
				title: "delete_action",
				action: () => this.deleteSelectedContacts()
			}] }) : styles.isSingleColumnLayout() && this.viewSlider.focusedColumn === this.listColumn && this.contactViewModel.listModel.state.inMultiselect || this.contactListViewModel.listModel?.state.inMultiselect ? mithril_default(MobileBottomActionBar, this.detailsViewerActions()) : mithril_default(BottomNav)
		}));
	}
	getHeaderLabel() {
		if (this.inContactListView()) return "contactLists_label";
else return "contacts_label";
	}
	getSelectedContacts() {
		return this.contactViewModel.listModel.getSelectedAsArray();
	}
	async getContactListId() {
		if (this.inContactListView()) return assertNotNull(await this.contactListViewModel.getContactListId());
else return this.contactViewModel.contactListId;
	}
	async createNewContact() {
		const listId = await this.getContactListId();
		if (listId) new ContactEditor(locator.entityClient, null, listId).show();
	}
	editSelectedContact() {
		const firstSelected = this.getSelectedContacts()[0];
		if (!firstSelected) return;
		this.editContact(firstSelected);
	}
	editContact(contact, listId) {
		new ContactEditor(locator.entityClient, contact, listId).show();
	}
	renderHeaderRightView() {
		return mithril_default(IconButton, {
			title: "newContact_action",
			click: () => this.createNewContact(),
			icon: Icons.Add
		});
	}
	renderDetailsViewer() {
		if (this.inContactListView()) {
			const entries = this.contactListViewModel.getSelectedContactListEntries() ?? [];
			return this.contactListViewModel.listModel == null || this.showingListView() ? mithril_default(ColumnEmptyMessageBox, {
				message: getContactListEntriesSelectionMessage(entries),
				icon: Icons.People,
				color: theme.content_message_bg,
				bottomContent: entries.length > 0 ? mithril_default(Button, {
					label: "cancel_action",
					type: ButtonType.Secondary,
					click: () => this.contactListViewModel.listModel?.selectNone()
				}) : null,
				backgroundColor: theme.navigation_bg
			}) : mithril_default(ContactListEntryViewer, {
				entry: getFirstOrThrow(entries),
				contacts: this.contactListViewModel.contactsForSelectedEntry,
				contactEdit: (c) => this.editContact(c),
				contactDelete: deleteContacts,
				contactCreate: async (c) => {
					const listId = await this.getContactListId();
					if (listId) this.editContact(c, listId);
				},
				onWriteMail: writeMail,
				selectNone: () => this.contactListViewModel.listModel?.selectNone()
			});
		} else {
			const contacts = this.getSelectedContacts();
			return this.showingListView() ? mithril_default(MultiContactViewer, {
				selectedEntities: contacts,
				selectNone: () => this.contactViewModel.listModel.selectNone()
			}) : mithril_default(ContactCardViewer, {
				contact: contacts[0],
				onWriteMail: writeMail
			});
		}
	}
	getShortcuts() {
		let shortcuts = [
			...listSelectionKeyboardShortcuts(MultiselectMode.Enabled, () => {
				return this.inContactListView() ? this.contactListViewModel.listModel : this.contactViewModel.listModel;
			}),
			{
				key: Keys.DELETE,
				exec: () => {
					if (this.inContactListView()) this.contactListViewModel.deleteSelectedEntries();
else this.deleteSelectedContacts();
					return true;
				},
				help: "deleteContacts_action"
			},
			{
				key: Keys.BACKSPACE,
				exec: () => {
					if (this.inContactListView()) this.contactListViewModel.deleteSelectedEntries();
else this.deleteSelectedContacts();
					return true;
				},
				help: "deleteContacts_action"
			},
			{
				key: Keys.N,
				exec: () => {
					this.createNewContact();
				},
				help: "newContact_action"
			}
		];
		return shortcuts;
	}
	renderSidebarElements() {
		return [
			mithril_default(SidebarSectionRow, {
				icon: BootIcons.Contacts,
				label: "all_contacts_label",
				path: `/contact`,
				onClick: () => this.viewSlider.focus(this.listColumn),
				moreButton: this.createMoreButtonAttrs(),
				alwaysShowMoreButton: client.isMobileDevice()
			}),
			mithril_default(SidebarSection, {
				name: "contactLists_label",
				button: mithril_default(IconButton, {
					icon: Icons.Add,
					size: ButtonSize.Compact,
					title: "addContactList_action",
					click: () => {
						this.addContactList();
					}
				})
			}, [this.contactListViewModel.getOwnContactListInfos().map((cl) => {
				return this.renderContactListRow(cl, false);
			})]),
			this.contactListViewModel.getSharedContactListInfos().length > 0 ? mithril_default("", mithril_default(SidebarSection, { name: "sharedContactLists_label" }, this.contactListViewModel.getSharedContactListInfos().map((cl) => {
				return this.renderContactListRow(cl, true);
			}))) : null,
			this.contactListViewModel.getContactListInvitations().length > 0 ? mithril_default(SidebarSection, { name: "contactListInvitations_label" }, this.invitationRows) : null
		];
	}
	getContactListInvitationRows() {
		import("./GroupInvitationFolderRow-B23UU1rf.js").then(({ GroupInvitationFolderRow }) => {
			this.invitationRows = this.contactListViewModel.getContactListInvitations().map((invitation) => mithril_default(GroupInvitationFolderRow, { invitation }));
		}).then(mithril_default.redraw);
	}
	renderFolderMoreButton() {
		return mithril_default(IconButton, this.createMoreButtonAttrs());
	}
	createMoreButtonAttrs() {
		return attachDropdown({
			mainButtonAttrs: {
				title: "more_label",
				icon: Icons.More,
				size: ButtonSize.Compact,
				colors: ButtonColor.Nav
			},
			childAttrs: () => {
				const vcardButtons = isApp() ? [{
					label: "importContacts_label",
					click: () => importContacts(),
					icon: Icons.ContactImport
				}] : [{
					label: "exportVCard_action",
					click: () => exportAsVCard(locator.contactModel),
					icon: Icons.Export
				}];
				return vcardButtons.concat([{
					label: "importVCard_action",
					click: () => importAsVCard(),
					icon: Icons.ContactImport
				}, {
					label: "merge_action",
					icon: Icons.People,
					click: () => this._mergeAction()
				}]);
			},
			width: 250
		});
	}
	renderContactListRow(contactListInfo, shared) {
		const contactListButton = {
			label: lang.makeTranslation("contactListName_label", contactListInfo.name),
			icon: () => Icons.People,
			href: () => `${CONTACTLIST_PREFIX}/${contactListInfo.groupRoot.entries}`,
			disableHoverBackground: true,
			click: () => {
				this.contactListViewModel.updateSelectedContactList(contactListInfo.groupRoot.entries);
				this.viewSlider.focus(this.listColumn);
			}
		};
		const moreButton = this.createContactListMoreButton(contactListInfo, shared);
		return mithril_default(SidebarSectionRow, {
			icon: Icons.People,
			label: lang.makeTranslation("contactlist_name", contactListInfo.name),
			path: `${CONTACTLIST_PREFIX}/${contactListInfo.groupRoot.entries}`,
			onClick: () => {
				this.contactListViewModel.updateSelectedContactList(contactListInfo.groupRoot.entries);
				this.viewSlider.focus(this.listColumn);
			},
			moreButton
		});
	}
	createContactListMoreButton(contactListInfo, shared) {
		return attachDropdown({
			mainButtonAttrs: {
				title: "more_label",
				icon: Icons.More,
				colors: ButtonColor.Nav,
				size: ButtonSize.Compact
			},
			childAttrs: () => {
				return [
					{
						label: "edit_action",
						icon: Icons.Edit,
						click: () => {
							showContactListNameEditor(contactListInfo.name, (newName) => {
								if (shared) this.editSharedContactList(contactListInfo, newName);
else this.contactListViewModel.updateContactList(contactListInfo, newName, []);
							});
						}
					},
					{
						label: "sharing_label",
						icon: Icons.ContactImport,
						click: async () => {
							const { showGroupSharingDialog } = await import("./GroupSharingDialog-CpANc1Ap.js");
							showGroupSharingDialog(contactListInfo.groupInfo, true);
						}
					},
					contactListInfo.isOwner ? {
						label: "delete_action",
						icon: Icons.Trash,
						click: async () => {
							if (await Dialog.confirm("confirmDeleteContactList_msg")) this.contactListViewModel.deleteContactList(contactListInfo);
						}
					} : {
						label: "leaveGroup_action",
						icon: Icons.Trash,
						click: async () => {
							if (await Dialog.confirm(lang.makeTranslation("confirm_msg", lang.get("confirmLeaveSharedGroup_msg", { "{groupName}": contactListInfo.name })))) return this.contactListViewModel.removeUserFromContactList(contactListInfo);
						}
					}
				];
			}
		});
	}
	editSharedContactList(contactListInfo, newName) {
		const { userSettingsGroupRoot } = locator.logins.getUserController();
		const existingGroupSettings = userSettingsGroupRoot.groupSettings.find((gc) => gc.group === contactListInfo.groupInfo.group) ?? null;
		if (existingGroupSettings) existingGroupSettings.name = newName;
		locator.entityClient.update(userSettingsGroupRoot);
		contactListInfo.name = newName;
	}
	_mergeAction() {
		return showProgressDialog("pleaseWait_msg", locator.contactModel.getContactListId().then((contactListId) => {
			return contactListId ? locator.entityClient.loadAll(ContactTypeRef, contactListId) : [];
		})).then((allContacts) => {
			if (allContacts.length === 0) Dialog.message("noContacts_msg");
else {
				let mergeableAndDuplicates = getMergeableContacts(allContacts);
				let deletePromise = Promise.resolve();
				if (mergeableAndDuplicates.deletable.length > 0) deletePromise = Dialog.confirm(lang.makeTranslation("confirm_msg", lang.get("duplicatesNotification_msg", { "{1}": mergeableAndDuplicates.deletable.length }))).then((confirmed) => {
					if (confirmed) for (const dc of mergeableAndDuplicates.deletable) locator.entityClient.erase(dc);
				});
				deletePromise.then(() => {
					if (mergeableAndDuplicates.mergeable.length === 0) Dialog.message(lang.makeTranslation("confirm_msg", lang.get("noSimilarContacts_msg")));
else this._showMergeDialogs(mergeableAndDuplicates.mergeable).then((canceled) => {
						if (!canceled) Dialog.message("noMoreSimilarContacts_msg");
					});
				});
			}
		});
	}
	/**
	* @returns True if the merging was canceled by the user, false otherwise
	*/
	_showMergeDialogs(mergable) {
		let canceled = false;
		if (mergable.length > 0) {
			let contact1 = mergable[0][0];
			let contact2 = mergable[0][1];
			let mergeDialog = new ContactMergeView(contact1, contact2);
			return mergeDialog.show().then((action) => {
				if (action === ContactMergeAction.Merge) {
					this._removeFromMergableContacts(mergable, contact2);
					mergeContacts(contact1, contact2);
					return showProgressDialog("pleaseWait_msg", locator.entityClient.update(contact1).then(() => locator.entityClient.erase(contact2))).catch(ofClass(NotFoundError, noOp));
				} else if (action === ContactMergeAction.DeleteFirst) {
					this._removeFromMergableContacts(mergable, contact1);
					return locator.entityClient.erase(contact1);
				} else if (action === ContactMergeAction.DeleteSecond) {
					this._removeFromMergableContacts(mergable, contact2);
					return locator.entityClient.erase(contact2);
				} else if (action === ContactMergeAction.Skip) this._removeFromMergableContacts(mergable, contact2);
else if (action === ContactMergeAction.Cancel) {
					clear(mergable);
					canceled = true;
				}
			}).then(() => {
				if (!canceled && mergable.length > 0) return this._showMergeDialogs(mergable);
else return canceled;
			});
		} else return Promise.resolve(canceled);
	}
	/**
	* removes the given contact from the given mergable arrays first entry (first or second element)
	*/
	_removeFromMergableContacts(mergable, contact) {
		if (mergable[0][0] === contact) mergable[0].splice(0, 1);
else if (mergable[0][1] === contact) mergable[0].splice(1, 1);
		if (mergable[0].length <= 1) mergable.splice(0, 1);
	}
	onNewUrl(args) {
		if (this.inContactListView()) this.contactListViewModel.showListAndEntry(args.listId, args.Id).then(mithril_default.redraw);
else this.contactViewModel.init(args.listId).then(() => this.contactViewModel.selectContact(args.contactId));
		if (args.focusItem) this.viewSlider.focus(this.detailsColumn);
	}
	deleteSelectedContacts() {
		return deleteContacts(this.getSelectedContacts(), () => this.contactViewModel.listModel.selectNone());
	}
	getViewSlider() {
		return this.viewSlider;
	}
	handleBackButton() {
		if (this.viewSlider.focusedColumn === this.detailsColumn) {
			this.viewSlider.focus(this.listColumn);
			return true;
		} else if (this.showingListView() && (this.contactViewModel.listModel.state.inMultiselect || this.contactListViewModel.listModel && this.contactListViewModel.listModel?.state.inMultiselect)) {
			this.contactViewModel.listModel.selectNone();
			this.contactListViewModel.listModel?.selectNone();
			return true;
		}
		return false;
	}
	renderListToolbar() {
		if (this.inContactListView()) {
			const selectedList = this.contactListViewModel.getSelectedContactListInfo();
			return mithril_default(DesktopListToolbar, mithril_default(SelectAllCheckbox, selectionAttrsForList(this.contactListViewModel.listModel)), mithril_default(".flex-grow"), this.canEditSelectedContactList() ? mithril_default(IconButton, {
				title: "addEntries_action",
				icon: Icons.Add,
				click: () => {
					this.addAddressesToContactList();
				}
			}) : null);
		} else return mithril_default(DesktopListToolbar, mithril_default(SelectAllCheckbox, selectionAttrsForList(this.contactViewModel.listModel)), this.renderSortByButton());
	}
	addAddressesToContactList() {
		const groupRoot = this.contactListViewModel.getSelectedContactListInfo()?.groupRoot;
		if (!groupRoot) return;
		showContactListEditor(groupRoot, "addEntries_action", (_, addresses) => {
			this.contactListViewModel.addRecipientstoContactList(addresses, assertNotNull(groupRoot));
		}, this.contactListViewModel.listModel?.getUnfilteredAsArray().map((entry) => entry.emailAddress));
	}
	renderSortByButton() {
		return mithril_default(IconButton, {
			title: "sortBy_label",
			icon: Icons.ListOrdered,
			click: (e, dom) => {
				createDropdown({ lazyButtons: () => [{
					label: "firstName_placeholder",
					click: () => {
						this.contactViewModel.setSortByFirstName(true);
					}
				}, {
					label: "lastName_placeholder",
					click: () => {
						this.contactViewModel.setSortByFirstName(false);
					}
				}] })(e, dom);
			}
		});
	}
	async addContactList() {
		if (await this.contactListViewModel.canCreateContactList()) await showContactListEditor(null, "createContactList_action", (name, recipients) => {
			this.contactListViewModel.addContactList(name, recipients);
		});
else if (locator.logins.getUserController().isGlobalAdmin()) {
			const { getAvailablePlansWithContactList } = await import("./SubscriptionUtils-j-oFQxhJ.js");
			const plans = await getAvailablePlansWithContactList();
			await showPlanUpgradeRequiredDialog(plans);
		} else Dialog.message("contactAdmin_msg");
	}
};
function writeMail(to, subject = "") {
	return locator.mailboxModel.getUserMailboxDetails().then((mailboxDetails) => {
		return newMailEditorFromTemplate(mailboxDetails, { to: [to] }, subject, appendEmailSignature("", locator.logins.getUserController().props)).then((editor) => editor.show());
	});
}
function deleteContacts(contactList, onConfirm = noOp) {
	return Dialog.confirm("deleteContacts_msg").then((confirmed) => {
		if (confirmed) {
			onConfirm();
			for (const contact of contactList) locator.entityClient.erase(contact).catch(ofClass(NotFoundError, noOp)).catch(ofClass(LockedError, noOp));
		}
	});
}
function confirmMerge(keptContact, goodbyeContact) {
	if (!keptContact.presharedPassword || !goodbyeContact.presharedPassword || keptContact.presharedPassword === goodbyeContact.presharedPassword) return Dialog.confirm("mergeAllSelectedContacts_msg").then((confirmed) => {
		if (confirmed) {
			mergeContacts(keptContact, goodbyeContact);
			return showProgressDialog("pleaseWait_msg", locator.entityClient.update(keptContact).then(() => locator.entityClient.erase(goodbyeContact))).catch(ofClass(NotFoundError, noOp));
		}
	});
else return Dialog.message("presharedPasswordsUnequal_msg");
}
async function importContacts() {
	const importer = await mailLocator.contactImporter();
	await importer.importContactsFromDeviceSafely();
}

//#endregion
export { ContactView, confirmMerge, deleteContacts, importContacts, writeMail };
//# sourceMappingURL=ContactView-D8FqOa_D.js.map