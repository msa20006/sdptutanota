{"version":3,"file":"MailViewerViewModel-D_nVDgz3.js","names":["mailModel: MailModel","mailboxDetails: MailboxDetail","areMailsReported: boolean","yesButton: ButtonAttrs","noButton: ButtonAttrs","mailReportType: MailReportType","mailboxModel: MailboxModel","mails: ReadonlyArray<Mail>","zoomable: HTMLElement","viewport: HTMLElement","initiallyZoomToViewportWidth: boolean","singleClickAction: (e: Event, target: EventTarget | null) => void","e","ev: TouchEvent","point1: CoordinatePair","point2: CoordinatePair","elem: HTMLElement","absoluteZoomPosition: CoordinatePair","targetCoordinates: CoordinatePair","currentZoomablePositionWithoutTransformation: CoordinatePair","sessionTranslation: CoordinatePair","scale: number","event: TouchEvent","target: EventTarget | null","singleClickAction: (e: TouchEvent, target: EventTarget | null) => void","doubleClickAction: (e: TouchEvent) => void","newTransformOrigin: CoordinatePair","newPinchSessionTranslation: CoordinatePair","newScale: number","currentOriginalPosition: CoordinatePair","originalWidth: number","originalHeight: number","transformOrigin: CoordinatePair","translation: CoordinatePair","mails: ReadonlyArray<Mail>","trashMails: Mail[]","moveMails: Mail[]","confirmationTextId: TranslationKey | null","moveMails","mailModel: MailModel","onConfirm: () => void","folderType: MailSetKind","folder: MailFolder","mail: Mail","dom: HTMLElement","inlineImages: InlineImages","onContext: (cid: string, arg1: MouseEvent | TouchEvent, arg2: HTMLElement) => unknown","imageElements: Array<HTMLElement>","shadowImageElements: Array<HTMLElement>","elementsWithCid: HTMLElement[]","timeoutId: TimeoutID | null","startCoords:\n\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\tx: number\n\t\t\t\t\t\t\t\ty: number\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t| null\n\t\t\t\t\t\t| undefined","e: TouchEvent","e: MouseEvent","inlineImages: Array<HTMLElement>","file: DataFile","cid: string","fileController: FileController","attachments: Array<TutanotaFile>","referencedCids: Array<string>","address: string","editorDom: ParentNode","mailFacade: MailFacade","mail: Mail","address: string","preferNameOnly: boolean","filter: MailFilterType | null","sanitizer: HtmlSanitizer","mail: Mail","mailDetails: MailDetails","attachments: Array<DataFile>","mailFacade: MailFacade","entityClient: EntityClient","fileController: FileController","cryptoFacade: CryptoFacade","bundle: MailBundle","fileName: string","mode: MailExportMode","mails: Array<Mail>","mailFacade: MailFacade","entityClient: EntityClient","fileController: FileController","cryptoFacade: CryptoFacade","operationId?: OperationId","signal?: AbortSignal","errorMails: Mail[]","dataFiles: DataFile[]","_mail: Mail","showFolder: boolean","entityClient: EntityClient","mailboxModel: MailboxModel","mailModel: MailModel","contactModel: ContactModel","configFacade: ConfigurationDatabase","fileController: FileController","logins: LoginController","sendMailModelFactory: (mailboxDetails: MailboxDetail) => Promise<SendMailModel>","eventController: EventController","workerFacade: WorkerFacade","searchModel: SearchModel","mailFacade: MailFacade","cryptoFacade: CryptoFacade","contactImporter: lazyAsync<ContactImporter>","events: EntityUpdateData[]","delay: Promise<unknown>","status: MailPhishingStatus","status: MailAuthenticationStatus","dismissed: boolean","status: ContentBlockingStatus","reportType: MailReportType","unread: boolean","mail: Mail","delayBodyRenderingUntil: Promise<unknown>","isDraft","inlineCids: string[]","links: Array<HTMLElement>","files: Array<TutanotaFile>","addressesInMail: MailAddress[]","recipients: MailAddress[]","replyTos: EncryptedMailAddress[]","addSignature: boolean","replyAll: boolean","toRecipients: MailAddress[]","ccRecipients: MailAddress[]","bccRecipients: MailAddress[]","blockExternalContent: boolean","file: TutanotaFile","open: boolean","delayBodyRendering: Promise<unknown>"],"sources":["../../src/mail-app/mail/view/MailReportDialog.ts","../../src/common/gui/PinchZoom.ts","../../src/common/gui/base/icons/FontIcons.ts","../../src/mail-app/mail/view/MailGuiUtils.ts","../../src/mail-app/mail/view/MailViewerUtils.ts","../../src/mail-app/mail/export/Bundler.ts","../../src/mail-app/mail/export/Exporter.ts","../../src/mail-app/mail/view/MailViewerViewModel.ts"],"sourcesContent":["import type { Mail, MailboxProperties } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { Checkbox } from \"../../../common/gui/base/Checkbox.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel\"\nimport m from \"mithril\"\nimport { MailReportType, ReportMovedMailsType } from \"../../../common/api/common/TutanotaConstants\"\nimport { ButtonAttrs, ButtonType } from \"../../../common/gui/base/Button.js\"\nimport { Dialog } from \"../../../common/gui/base/Dialog\"\nimport type { MailboxDetail, MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { showSnackBar } from \"../../../common/gui/base/SnackBar\"\nimport { MailModel } from \"../model/MailModel.js\"\n\nfunction confirmMailReportDialog(mailModel: MailModel, mailboxDetails: MailboxDetail): Promise<boolean> {\n\treturn new Promise((resolve) => {\n\t\tlet shallRememberDecision = false\n\t\tconst child = () =>\n\t\t\tm(Checkbox, {\n\t\t\t\tlabel: () => lang.get(\"rememberDecision_msg\"),\n\t\t\t\tchecked: shallRememberDecision,\n\t\t\t\tonChecked: (v) => (shallRememberDecision = v),\n\t\t\t\thelpLabel: \"changeMailSettings_msg\",\n\t\t\t})\n\n\t\tasync function updateSpamReportSetting(areMailsReported: boolean) {\n\t\t\tif (shallRememberDecision) {\n\t\t\t\tconst reportMovedMails = areMailsReported ? ReportMovedMailsType.AUTOMATICALLY_ONLY_SPAM : ReportMovedMailsType.NEVER\n\t\t\t\tawait mailModel.saveReportMovedMails(mailboxDetails.mailboxGroupRoot, reportMovedMails)\n\t\t\t}\n\n\t\t\tresolve(areMailsReported)\n\t\t\tdialog.close()\n\t\t}\n\n\t\tconst yesButton: ButtonAttrs = {\n\t\t\tlabel: \"yes_label\",\n\t\t\tclick: () => updateSpamReportSetting(true),\n\t\t\ttype: ButtonType.Primary,\n\t\t}\n\t\tconst noButton: ButtonAttrs = {\n\t\t\tlabel: \"no_label\",\n\t\t\tclick: () => updateSpamReportSetting(false),\n\t\t\ttype: ButtonType.Secondary,\n\t\t}\n\n\t\t// onclose is called when dialog is closed by ESC or back button. In this case we don't want to report spam.\n\t\tconst onclose = () => {\n\t\t\tresolve(false)\n\t\t}\n\n\t\tconst dialog = Dialog.confirmMultiple(\n\t\t\tlang.makeTranslation(\"unencryptedTransmission_msg\", lang.get(\"unencryptedTransmission_msg\") + \" \" + lang.get(\"allowOperation_msg\")),\n\t\t\t[noButton, yesButton],\n\t\t\tonclose,\n\t\t\tchild,\n\t\t)\n\t})\n}\n\n/**\n * Check if the user wants to report mails as spam when they are moved to the spam folder and report them.\n * May open a dialog for confirmation and otherwise shows a Snackbar before reporting to the server.\n */\nexport async function reportMailsAutomatically(\n\tmailReportType: MailReportType,\n\tmailboxModel: MailboxModel,\n\tmailModel: MailModel,\n\tmailboxDetails: MailboxDetail,\n\tmails: ReadonlyArray<Mail>,\n): Promise<void> {\n\tif (mailReportType !== MailReportType.SPAM) {\n\t\treturn\n\t}\n\n\tconst mailboxProperties = await mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot)\n\tlet allowUndoing = true // decides if a snackbar is shown to prevent the server request\n\n\tlet isReportable = false\n\n\tif (!mailboxProperties || mailboxProperties.reportMovedMails === ReportMovedMailsType.ALWAYS_ASK) {\n\t\tisReportable = await confirmMailReportDialog(mailModel, mailboxDetails)\n\t\tallowUndoing = false\n\t} else if (mailboxProperties.reportMovedMails === ReportMovedMailsType.AUTOMATICALLY_ONLY_SPAM) {\n\t\tisReportable = true\n\t} else if (mailboxProperties.reportMovedMails === ReportMovedMailsType.NEVER) {\n\t\t// no report\n\t}\n\n\tif (isReportable) {\n\t\t// only show the snackbar to undo the report if the user was not asked already\n\t\tif (allowUndoing) {\n\t\t\tlet undoClicked = false\n\t\t\tshowSnackBar({\n\t\t\t\tmessage: \"undoMailReport_msg\",\n\t\t\t\tbutton: {\n\t\t\t\t\tlabel: \"cancel_action\",\n\t\t\t\t\tclick: () => (undoClicked = true),\n\t\t\t\t},\n\t\t\t\tonClose: () => {\n\t\t\t\t\tif (!undoClicked) {\n\t\t\t\t\t\tmailModel.reportMails(mailReportType, mails)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\tmailModel.reportMails(mailReportType, mails)\n\t\t}\n\t}\n}\n","type CoordinatePair = {\n\tx: number\n\ty: number\n}\n\n/**\n * This class handles pinch of a given HTMLElement (zoomable) inside another HTMLElement (viewport). If that zoomable HTMLElement is zoomed in it is possible to drag it (with a new finger gesture)\n * up to the viewport borders.\n * Center of the zoom is always the center of the fingers, even when these are moved during zooming.\n * The maximum zoom factor is 3.\n *\n * This class also supports:\n * * Initially zooming out to match the viewport width\n * * Double tap to zoom in (when not zoomed in) to half of the possible zoom factor\n * * Double tap to zoom out (when zoomed in by some factor) to the minimal zoom factor\n *\n * Not supported:\n * * Dragging while pinch zooming\n * * Resizing of the zoomable HTMLElement. If the size changes it is required to create a new PinchZoom object.\n *\n * __Important__:\n * * call remove() before creating a new PinchZoom object and throwing away the reference of the old one to deregister the listeners!\n */\nexport class PinchZoom {\n\t/// listener\n\tprivate readonly onTouchEndListener: EventListener | null = null\n\tprivate readonly onTouchStartListener: EventListener | null = null\n\tprivate readonly onTouchCancelListener: EventListener | null = null\n\tprivate readonly onTouchMoveListener: EventListener | null = null\n\n\t/// provide the current state of the pinch zoom object for external access\n\tprivate draggingOrZooming: boolean = false\n\tprivate currentTouchStart: {\n\t\tx: number\n\t\ty: number\n\t\tstartTime: number\n\t} = { x: 0, y: 0, startTime: 0 }\n\t// dragging below this threshold is not considered dragging, but noise\n\tstatic DRAG_THRESHOLD = 10\n\n\t/// zooming\n\tprivate pinchTouchIDs: Set<number> = new Set<number>()\n\tprivate lastPinchTouchPositions: { pointer1: CoordinatePair; pointer2: CoordinatePair } = { pointer1: { x: 0, y: 0 }, pointer2: { x: 0, y: 0 } }\n\tprivate initialZoomablePosition = { x: 0, y: 0 }\n\tprivate initialViewportPosition = { x: 0, y: 0 }\n\tprivate pinchSessionTranslation: CoordinatePair = { x: 0, y: 0 }\n\tprivate initialZoomableSize = { width: 0, height: 0 }\n\tprivate zoomBoundaries = { min: 1, max: 3 }\n\t// values of this variable should only be the result of the calculateSafeScaleValue function (except from the initial value the value must never be 1 due to division by 1-scale). Never set values directly!\n\tprivate currentScale = 1\n\n\t/// dragging\n\t// null if there was no previous touch position related to dragging\n\tprivate lastDragTouchPosition: CoordinatePair | null = null\n\n\t// Apple considers that a press event is a long press after 500ms\n\t// Google considers after 400ms\n\t// https://developer.apple.com/documentation/uikit/uilongpressgesturerecognizer/1616423-minimumpressduration\n\t// https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewConfiguration.java\n\tprivate readonly LONG_PRESS_MIN_MS = 400\n\n\t/// double tap\n\t// Two consecutive taps are recognized as double tap if they occur within this time span\n\tprivate DOUBLE_TAP_TIME_MS = 350\n\t// the radius in which we recognize a second tap or single click (and not drag)\n\tprivate SAME_POSITION_RADIUS = 40\n\tprivate lastDoubleTapTouchStart: {\n\t\tx: number\n\t\ty: number\n\t} = { x: 0, y: 0 }\n\tprivate firstTapTime = 0\n\n\t/**\n\t * Creates a PinchZoom object and immediately starts recognizing and reacting to zoom, drag and tab gestures.\n\t * @precondition zoomable.x <= viewport.x && zoomable.y <= viewport.y && zoomable.x2 >= viewport.x2 && zoomable.y2 >= viewport.y2\n\t * @precondition zoomable must have been rendered already at least once.\n\t * @param zoomable The HTMLElement that shall be zoomed inside the viewport.\n\t * @param viewport The HTMLElement in which the zoomable is zoomed and dragged.\n\t * @param initiallyZoomToViewportWidth If true and the width of the zoomable is bigger than the viewport width, the zoomable is zoomed out to match the viewport __width__ and not the height! the viewport height is adapted to match the zoomed zoomable height (calling PinchZoom.remove() resets the height)\n\t * @param singleClickAction This function is called whenever a single click on the zoomable is detected, e.g. on a link. Since the PinchZoom class prevents all default actions these clicks need to be handled outside of this class.\n\t */\n\tconstructor(\n\t\tprivate readonly zoomable: HTMLElement,\n\t\tprivate readonly viewport: HTMLElement,\n\t\tprivate readonly initiallyZoomToViewportWidth: boolean,\n\t\tprivate readonly singleClickAction: (e: Event, target: EventTarget | null) => void,\n\t) {\n\t\tthis.viewport.style.overflow = \"hidden\" // disable default scroll behavior\n\t\tthis.update({ x: 0, y: 0 }) // transform origin needs to be initially set. can lead to wrong transform origins otherwise\n\t\tthis.zoomable.style.touchAction = \"pan-y pan-x\" // makes zooming smooth\n\t\tthis.zoomable.style.minWidth = \"100%\" // for correct zooming behavior the content of the zoomable should match the zoomable\n\t\tthis.zoomable.style.width = \"fit-content\" // prevents overflowing issues\n\n\t\tconst initialZoomableCoords = this.getCoords(this.zoomable) // already needs to be rendered\n\t\t// the content of the zoomable rect can be bigger than the rect itself due to overflow\n\t\tthis.initialZoomableSize = {\n\t\t\twidth: this.zoomable.scrollWidth,\n\t\t\theight: this.zoomable.scrollHeight,\n\t\t}\n\t\tthis.initialZoomablePosition = { x: initialZoomableCoords.x, y: initialZoomableCoords.y }\n\n\t\tconst initialViewportCoords = this.getCoords(this.viewport)\n\t\tthis.initialViewportPosition = { x: initialViewportCoords.x, y: initialViewportCoords.y }\n\n\t\t// for the double tap\n\t\tthis.onTouchEndListener = this.zoomable.ontouchend = (e) => {\n\t\t\tthis.removeTouches(e)\n\t\t\tconst eventTarget = e.target // it is necessary to save the target because otherwise it changes and is not accurate anymore after the bubbling phase\n\t\t\tif (e.touches.length === 0 && e.changedTouches.length === 1) {\n\t\t\t\t//LATER: when pinching and then right after leaving the display tap again -> double tap (if evaluates to true because of the last finger leaving the display after pinching)\n\t\t\t\tthis.handleDoubleTap(\n\t\t\t\t\te,\n\t\t\t\t\teventTarget,\n\t\t\t\t\t(e, target) => singleClickAction(e, target),\n\t\t\t\t\t(e) => {\n\t\t\t\t\t\tlet scale = 1\n\t\t\t\t\t\tif (this.currentScale > this.zoomBoundaries.min) {\n\t\t\t\t\t\t\tscale = this.zoomBoundaries.min // zoom out\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscale = (this.zoomBoundaries.min + this.zoomBoundaries.max) / 2\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst translationAndOrigin = this.calculateSessionsTranslationAndTransformOrigin({\n\t\t\t\t\t\t\tx: e.changedTouches[0].clientX,\n\t\t\t\t\t\t\ty: e.changedTouches[0].clientY,\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tconst newTransformOrigin = this.setCurrentSafePosition(\n\t\t\t\t\t\t\ttranslationAndOrigin.newTransformOrigin,\n\t\t\t\t\t\t\ttranslationAndOrigin.sessionTranslation,\n\t\t\t\t\t\t\tthis.getCurrentZoomablePositionWithoutTransformation(),\n\t\t\t\t\t\t\tscale,\n\t\t\t\t\t\t).newTransformOrigin\n\t\t\t\t\t\tthis.update(newTransformOrigin)\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\tthis.onTouchStartListener = this.zoomable.ontouchstart = (e) => {\n\t\t\tconst touch = e.touches[0]\n\n\t\t\tthis.currentTouchStart = { x: touch.clientX, y: touch.clientY, startTime: Date.now() }\n\n\t\t\tif (e.touches.length >= 2) {\n\t\t\t\tthis.draggingOrZooming = true\n\t\t\t}\n\n\t\t\tif (e.touches.length === 1) {\n\t\t\t\tthis.lastDragTouchPosition = { x: touch.clientX, y: touch.clientY }\n\t\t\t} else {\n\t\t\t\tthis.lastDragTouchPosition = null\n\t\t\t}\n\t\t}\n\t\tthis.onTouchMoveListener = this.zoomable.ontouchmove = (e) => {\n\t\t\tthis.touchmove_handler(e)\n\t\t}\n\t\tthis.onTouchCancelListener = this.zoomable.ontouchcancel = (e) => {\n\t\t\tthis.removeTouches(e)\n\t\t}\n\n\t\tif (this.initiallyZoomToViewportWidth) {\n\t\t\tthis.rescale()\n\t\t}\n\t}\n\n\tgetViewport() {\n\t\treturn this.viewport\n\t}\n\n\tgetZoomable() {\n\t\treturn this.zoomable\n\t}\n\n\tisDraggingOrZooming() {\n\t\treturn this.draggingOrZooming\n\t}\n\n\t/**\n\t * call this method before throwing away the reference to the pinch zoom object\n\t * changes to the viewport needs to be reverted. Otherwise, future operations would be influenced\n\t */\n\tremove() {\n\t\tif (this.onTouchEndListener) {\n\t\t\tthis.zoomable.removeEventListener(\"ontouchend\", this.onTouchEndListener)\n\t\t}\n\t\tif (this.onTouchStartListener) {\n\t\t\tthis.zoomable.removeEventListener(\"ontouchstart\", this.onTouchStartListener)\n\t\t}\n\t\tif (this.onTouchCancelListener) {\n\t\t\tthis.zoomable.removeEventListener(\"ontouchcancel\", this.onTouchCancelListener)\n\t\t}\n\t\tif (this.onTouchMoveListener) {\n\t\t\tthis.zoomable.removeEventListener(\"ontouchmove\", this.onTouchMoveListener)\n\t\t}\n\t\tthis.currentScale = this.zoomBoundaries.min\n\t\tthis.update({ x: 0, y: 0 })\n\t\tthis.viewport.style.height = \"auto\"\n\t}\n\n\tprivate touchmove_handler(ev: TouchEvent) {\n\t\tswitch (ev.touches.length) {\n\t\t\tcase 1:\n\t\t\t\tthis.dragHandling(ev)\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\tthis.pinchHandling(ev)\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\tprivate removeTouches(ev: TouchEvent) {\n\t\tif (ev.touches.length === 0) {\n\t\t\tthis.draggingOrZooming = false\n\t\t}\n\t\tthis.pinchTouchIDs.clear()\n\t}\n\n\tprivate pointDistance(point1: CoordinatePair, point2: CoordinatePair): number {\n\t\treturn Math.round(Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)))\n\t}\n\n\tprivate centerOfPoints(...points: CoordinatePair[]): CoordinatePair {\n\t\tlet x = 0\n\t\tlet y = 0\n\t\tfor (let point of points) {\n\t\t\tx += point.x\n\t\t\ty += point.y\n\t\t}\n\t\treturn { x: Math.round(x / points.length), y: Math.round(y / points.length) }\n\t}\n\n\t/**\n\t * returns the absolute coordinates of the rendered object (includes CSS transformations)\n\t */\n\tprivate getCoords(elem: HTMLElement) {\n\t\t// crossbrowser version\n\t\tlet box = elem.getBoundingClientRect()\n\n\t\tlet body = document.body\n\t\tlet docEl = document.documentElement\n\n\t\tlet scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop\n\t\tlet scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft\n\n\t\tlet clientTop = docEl.clientTop || body.clientTop || 0\n\t\tlet clientLeft = docEl.clientLeft || body.clientLeft || 0\n\n\t\tlet top = box.top + scrollTop - clientTop\n\t\tlet left = box.left + scrollLeft - clientLeft\n\t\tlet bottom = box.bottom + scrollTop - clientTop\n\t\tlet right = box.right + scrollLeft - clientLeft\n\n\t\t// return { x: Math.round(left), y: Math.round(top), x2: Math.round(right), y2: Math.round(bottom) }\n\t\treturn { x: left, y: top, x2: right, y2: bottom }\n\t}\n\n\tprivate getCurrentlyAppliedTransformOriginOfZoomable(): CoordinatePair {\n\t\tconst computedStyle = getComputedStyle(this.zoomable)\n\t\tlet transformOrigin = computedStyle.transformOrigin\n\n\t\tlet numberPattern = /-?\\d+\\.?\\d*/g\n\t\tlet transformOriginValues = transformOrigin.match(numberPattern) //relative\n\t\tif (transformOriginValues) {\n\t\t\treturn { x: Number(transformOriginValues[0]), y: Number(transformOriginValues[1]) }\n\t\t}\n\t\treturn { x: 0, y: 0 }\n\t}\n\n\t/**\n\t * Returns the current position of the original (without CSS transformation) zoomable\n\t * the transformOrigin is relative to this point\n\t */\n\tprivate getCurrentZoomablePositionWithoutTransformation() {\n\t\tlet currentScrollOffset = this.getOffsetFromInitialToCurrentViewportPosition()\n\t\treturn {\n\t\t\tx: this.initialZoomablePosition.x - currentScrollOffset.x,\n\t\t\ty: this.initialZoomablePosition.y - currentScrollOffset.y,\n\t\t}\n\t}\n\n\t/**\n\t * Returns the current offset of the viewport compared to the original position. E.g. if the viewport was scrolled this scroll offset is returned.\n\t **/\n\tprivate getOffsetFromInitialToCurrentViewportPosition() {\n\t\tlet currentViewport = this.getCoords(this.viewport)\n\t\treturn {\n\t\t\tx: this.initialViewportPosition.x - currentViewport.x,\n\t\t\ty: this.initialViewportPosition.y - currentViewport.y,\n\t\t}\n\t}\n\n\t/// zooming\n\n\t/**\n\t * Scales the zoomable to match the viewport width if the zoomable width is bigger.\n\t */\n\tprivate rescale() {\n\t\tconst containerWidth = this.viewport.offsetWidth\n\n\t\tif (containerWidth >= this.zoomable.scrollWidth) {\n\t\t\tthis.zoomable.style.transform = \"\"\n\t\t\tthis.zoomable.style.marginBottom = \"\"\n\t\t} else {\n\t\t\t// zoom out to match the size\n\t\t\tconst width = this.zoomable.scrollWidth\n\t\t\tconst scale = containerWidth / width\n\n\t\t\tthis.viewport.style.height = `${this.viewport.scrollHeight * scale}px`\n\n\t\t\tthis.zoomBoundaries = { min: scale, max: this.zoomBoundaries.max } // allow value <1 for minimum scale\n\t\t\tconst newTransformOrigin = this.setCurrentSafePosition(\n\t\t\t\t{ x: 0, y: 0 },\n\t\t\t\t{\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0,\n\t\t\t\t},\n\t\t\t\tthis.getCurrentZoomablePositionWithoutTransformation(),\n\t\t\t\tscale,\n\t\t\t).newTransformOrigin\n\t\t\tthis.update(newTransformOrigin)\n\t\t}\n\t}\n\n\t/**\n\t * Calculate the nw sessionTranslation and transformOrigin dependent on the new finger position for flawless zooming behavior.\n\t * Dependent on the new position of the fingers the sessionTranslation is calculated so that the transformOrigin is in the center of the touch points\n\t * The session translation is the offset by which the original/initial zoomable is moved inside the viewport in a non-scaled state, so that when scaling to the current scale factor (this.currentScale) at the\n\t * calculated transform origin we get the current position and size of the zoomable inside the viewport.\n\t * The transform origin is the position relative to the original/initial zoomable position (non-scaled) at which we need to zoom in so that we get the current  position and size of the zoomable inside the viewport (with applied session translation).\n\t * @param absoluteZoomPosition The position in which the user wants to zoom, i.e. the center between the two fingers. This position is relative to the screen coordinates.\n\t */\n\tprivate calculateSessionsTranslationAndTransformOrigin(absoluteZoomPosition: CoordinatePair): {\n\t\tsessionTranslation: CoordinatePair\n\t\tnewTransformOrigin: CoordinatePair\n\t} {\n\t\tlet currentZoomable = this.getCoords(this.zoomable)\n\t\tlet scrollOffset = this.getOffsetFromInitialToCurrentViewportPosition()\n\n\t\t// We want to use the new absoluteZoomPosition as the new transformOrigin. This is needed for expected zooming behavior.\n\t\t// Since we know the current position and the new desired transformOrigin we can calculate the new zoomable position from which the\n\t\t// transformation would be correct.\n\t\t// intuitive formula\n\t\t// currentZoomable = absoluteTransformOrigin - (relativeTransformOrigin * this.currentScale)\t| substitute unknown values\n\t\t// currentZoomable = absoluteZoomPosition - ((absoluteZoomPosition - newPosition) * this.currentScale)\t| solve for newPosition\n\t\t//\n\t\t// newPosition = (currentZoomable.x + absoluteZoomPosition.x * (this.currentScale - 1)) / this.currentScale\n\t\tlet transformedInitialZoomable = {\n\t\t\tx: (currentZoomable.x + absoluteZoomPosition.x * (this.currentScale - 1)) / this.currentScale,\n\t\t\ty: (currentZoomable.y + absoluteZoomPosition.y * (this.currentScale - 1)) / this.currentScale,\n\t\t}\n\n\t\t// the vector to get to the desired new position from the original position\n\t\t// newPosition - originalPosition\n\t\tlet sessionTranslation = {\n\t\t\tx: transformedInitialZoomable.x - this.initialZoomablePosition.x + scrollOffset.x,\n\t\t\ty: transformedInitialZoomable.y - this.initialZoomablePosition.y + scrollOffset.y,\n\t\t}\n\n\t\t// transform origin\n\t\t// is relative to the new transformed zoomable\n\t\tlet transformOrigin = {\n\t\t\tx: absoluteZoomPosition.x - transformedInitialZoomable.x,\n\t\t\ty: absoluteZoomPosition.y - transformedInitialZoomable.y,\n\t\t}\n\n\t\treturn { sessionTranslation: sessionTranslation, newTransformOrigin: transformOrigin }\n\t}\n\n\t/**\n\t * Calculate the transform origin that is needed to the desired targetCoordinates of the zoomable, given the session translation, the targetCoordinates and the scale\n\t */\n\tprivate calculateTransformOriginFromTarget(\n\t\ttargetCoordinates: CoordinatePair,\n\t\tcurrentZoomablePositionWithoutTransformation: CoordinatePair,\n\t\tsessionTranslation: CoordinatePair,\n\t\tscale: number,\n\t): CoordinatePair {\n\t\treturn {\n\t\t\tx: (currentZoomablePositionWithoutTransformation.x + sessionTranslation.x - targetCoordinates.x) / (scale - 1),\n\t\t\ty: (currentZoomablePositionWithoutTransformation.y + sessionTranslation.y - targetCoordinates.y) / (scale - 1),\n\t\t}\n\t}\n\n\tprivate pinchHandling(ev: TouchEvent) {\n\t\tthis.draggingOrZooming = true\n\n\t\t// new pinch gesture?\n\t\tlet transformOrigin = this.getCurrentlyAppliedTransformOriginOfZoomable()\n\t\tlet pinchSessionTranslation = this.pinchSessionTranslation\n\n\t\tconst newTouches = !(this.pinchTouchIDs.has(ev.touches[0].identifier) && this.pinchTouchIDs.has(ev.touches[1].identifier))\n\n\t\tif (newTouches) {\n\t\t\tthis.lastPinchTouchPositions = {\n\t\t\t\tpointer1: { x: ev.touches[0].clientX, y: ev.touches[0].clientY },\n\t\t\t\tpointer2: { x: ev.touches[1].clientX, y: ev.touches[1].clientY },\n\t\t\t}\n\t\t}\n\n\t\t// Calculate the scaleDifference (1 = no scaleDifference, 0 = maximum pinched in, <1 pinching in -> zoom out, >1 pinching out -> zoom in\n\t\tconst scaleDifference =\n\t\t\tthis.pointDistance({ x: ev.touches[0].clientX, y: ev.touches[0].clientY }, { x: ev.touches[1].clientX, y: ev.touches[1].clientY }) /\n\t\t\tthis.pointDistance(this.lastPinchTouchPositions.pointer1, this.lastPinchTouchPositions.pointer2)\n\t\tconst newAbsoluteScale = this.currentScale + (scaleDifference - 1)\n\n\t\tthis.lastPinchTouchPositions = {\n\t\t\tpointer1: { x: ev.touches[0].clientX, y: ev.touches[0].clientY },\n\t\t\tpointer2: { x: ev.touches[1].clientX, y: ev.touches[1].clientY },\n\t\t}\n\n\t\t// calculate new session (in theory it is not necessary to calculate a new sessionsTranslation every time, but there are a few edge cases ->\n\t\t// since it doesn't hurt we decided to recalculate it always)\n\t\tconst pinchCenter = this.centerOfPoints({ x: ev.touches[0].clientX, y: ev.touches[0].clientY }, { x: ev.touches[1].clientX, y: ev.touches[1].clientY })\n\t\tconst startedPinchSession = this.calculateSessionsTranslationAndTransformOrigin(pinchCenter)\n\t\ttransformOrigin = startedPinchSession.newTransformOrigin\n\t\tpinchSessionTranslation = startedPinchSession.sessionTranslation\n\n\t\t//update current touches\n\t\tthis.pinchTouchIDs = new Set<number>([ev.touches[0].identifier, ev.touches[1].identifier])\n\n\t\tconst newTransformOrigin = this.setCurrentSafePosition(\n\t\t\ttransformOrigin,\n\t\t\tpinchSessionTranslation,\n\t\t\tthis.getCurrentZoomablePositionWithoutTransformation(),\n\t\t\tnewAbsoluteScale,\n\t\t).newTransformOrigin\n\t\tthis.update(newTransformOrigin)\n\t}\n\n\tprivate dragHandling(ev: TouchEvent) {\n\t\tif (this.currentScale > this.zoomBoundaries.min && this.lastDragTouchPosition) {\n\t\t\tif (\n\t\t\t\tMath.abs(ev.touches[0].clientX - this.currentTouchStart.x) >= PinchZoom.DRAG_THRESHOLD ||\n\t\t\t\tMath.abs(ev.touches[0].clientY - this.currentTouchStart.y) >= PinchZoom.DRAG_THRESHOLD\n\t\t\t) {\n\t\t\t\tthis.draggingOrZooming = true\n\t\t\t}\n\t\t\tlet delta = { x: ev.touches[0].clientX - this.lastDragTouchPosition.x, y: ev.touches[0].clientY - this.lastDragTouchPosition.y }\n\t\t\tthis.lastDragTouchPosition = { x: ev.touches[0].clientX, y: ev.touches[0].clientY }\n\n\t\t\tlet currentRect = this.getCoords(this.zoomable)\n\t\t\tlet currentOriginalRect = this.getCurrentZoomablePositionWithoutTransformation()\n\n\t\t\t// intuitive formula:\n\t\t\t// newPosition = transformOriginAbsolutePosition - relativeTransformOrigin * scaling\t| substitute unknown values\n\t\t\t// currentRect.x + delta.x = (currentOriginalRect + this.pinchSessionTranslation + newTransformOrigin) - (newTransformOrigin * this.currentScale)\t| solve for newTransformOrigin\n\t\t\t//\n\t\t\t// newTransformOrigin = (currentRect.x + delta.x - (currentOriginalRect.x + this.pinchSessionTranslation.x)) / (1 - this.currentScale)\n\t\t\tlet newTransformOrigin = {\n\t\t\t\tx: (currentRect.x + delta.x - (currentOriginalRect.x + this.pinchSessionTranslation.x)) / (1 - this.currentScale), // zoom is never 1\n\t\t\t\ty: (currentRect.y + delta.y - (currentOriginalRect.y + this.pinchSessionTranslation.y)) / (1 - this.currentScale),\n\t\t\t}\n\t\t\tlet newPinchSessionTranslation = this.pinchSessionTranslation\n\t\t\t// for too large emails and scale 1 we manually need to set the sessionTranslation to allow dragging\n\t\t\t// dragging via adjusting the transform origin does not work for scale=1\n\t\t\tif (this.currentScale === 1) {\n\t\t\t\tnewTransformOrigin = { x: 0, y: 0 } // otherwise NaN but the value does not have any impact\n\t\t\t\tnewPinchSessionTranslation = { x: newPinchSessionTranslation.x + delta.x, y: newPinchSessionTranslation.y + delta.y }\n\t\t\t}\n\n\t\t\tlet result = this.setCurrentSafePosition(\n\t\t\t\tnewTransformOrigin,\n\t\t\t\tnewPinchSessionTranslation,\n\t\t\t\tthis.getCurrentZoomablePositionWithoutTransformation(),\n\t\t\t\tthis.currentScale,\n\t\t\t)\n\t\t\t// default behavior is allowed if vertical dragging is not detected/ possible\n\t\t\t// horizontal behavior is ignored\n\t\t\tif (ev.cancelable && result.verticalTransformationAllowed) {\n\t\t\t\tev.preventDefault() // should prevent the default behavior of the parent elements (e.g. scrolling)\n\t\t\t}\n\n\t\t\tthis.update(result.newTransformOrigin)\n\t\t}\n\t}\n\n\tprivate handleDoubleTap(\n\t\tevent: TouchEvent,\n\t\ttarget: EventTarget | null,\n\t\tsingleClickAction: (e: TouchEvent, target: EventTarget | null) => void,\n\t\tdoubleClickAction: (e: TouchEvent) => void,\n\t) {\n\t\tconst now = Date.now()\n\t\tconst touch = event.changedTouches[0]\n\n\t\t// If there are no touches or it's not cancellable event (e.g. scroll)\n\t\tif (!touch || !event.cancelable) {\n\t\t\treturn\n\t\t}\n\n\t\tevent.preventDefault()\n\n\t\tif (\n\t\t\tnow - this.firstTapTime < this.DOUBLE_TAP_TIME_MS &&\n\t\t\tMath.abs(touch.clientX - this.lastDoubleTapTouchStart.x) < this.SAME_POSITION_RADIUS && // make sure that the double tap stays within the right radius\n\t\t\tMath.abs(touch.clientY - this.lastDoubleTapTouchStart.y) < this.SAME_POSITION_RADIUS\n\t\t) {\n\t\t\tthis.firstTapTime = 0\n\t\t\tdoubleClickAction(event)\n\t\t} else {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (\n\t\t\t\t\tthis.firstTapTime === now && // same touch, if a second tap was performed this condition is false\n\t\t\t\t\tMath.abs(touch.clientX - this.currentTouchStart.x) < this.SAME_POSITION_RADIUS && // otherwise single fast drag is recognized as a click\n\t\t\t\t\tMath.abs(touch.clientY - this.currentTouchStart.y) < this.SAME_POSITION_RADIUS\n\t\t\t\t) {\n\t\t\t\t\t// at this point we are sure that there is no second tap for a double tap\n\n\t\t\t\t\t// We need to verify if it was a long press, so we don't clear the text selection in this case\n\t\t\t\t\tif (now - this.currentTouchStart.startTime < this.LONG_PRESS_MIN_MS) window.getSelection()?.empty() // deselect any selected text\n\n\t\t\t\t\tsingleClickAction(event, target)\n\t\t\t\t}\n\t\t\t}, this.DOUBLE_TAP_TIME_MS)\n\t\t}\n\t\tthis.lastDoubleTapTouchStart = this.currentTouchStart\n\t\tthis.firstTapTime = now\n\t}\n\n\t/**\n\t * Applies the current session translation and scale to the zoomable, so it becomes visible.\n\t */\n\tprivate update(newTransformOrigin: CoordinatePair) {\n\t\tthis.zoomable.style.transformOrigin = `${newTransformOrigin.x}px ${newTransformOrigin.y}px`\n\t\tthis.zoomable.style.transform = `translate3d(${this.pinchSessionTranslation.x}px, ${this.pinchSessionTranslation.y}px, 0) scale(${this.currentScale})`\n\t}\n\n\t/**\n\t * Checks whether the zoomable is still in the allowed are (viewport) after applying the transformations\n\t * if not allowed -> adjust the transformOrigin to keep the transformed zoomable in an allowed state\n\t * apply changes to sessionTranslation, zoom and transformOrigin\n\t */\n\tprivate setCurrentSafePosition(\n\t\tnewTransformOrigin: CoordinatePair,\n\t\tnewPinchSessionTranslation: CoordinatePair,\n\t\tcurrentZoomablePositionWithoutTransformation: CoordinatePair,\n\t\tnewScale: number,\n\t) {\n\t\tthis.getOffsetFromInitialToCurrentViewportPosition()\n\t\tlet currentViewport = this.getCoords(this.viewport)\n\t\t// Since we don't round the screen coordinates, without adding a small tolerance (+-1) unwanted behavior shows up (e.g. tiny differences in the coordinates)\n\t\tlet borders = {\n\t\t\tx: currentViewport.x + 1,\n\t\t\ty: currentViewport.y + 1,\n\t\t\tx2: currentViewport.x2 - 1,\n\t\t\ty2: currentViewport.y2 - 1,\n\t\t}\n\n\t\t// keep the zooming factor within the defined boundaries\n\t\tnewScale = Math.max(this.zoomBoundaries.min, Math.min(this.zoomBoundaries.max, newScale))\n\t\tconst targetedOutcome = this.simulateTransformation(\n\t\t\tcurrentZoomablePositionWithoutTransformation,\n\t\t\tthis.initialZoomableSize.width,\n\t\t\tthis.initialZoomableSize.height,\n\t\t\tnewTransformOrigin,\n\t\t\tnewPinchSessionTranslation,\n\t\t\tnewScale,\n\t\t)\n\t\tconst targetedHeight = targetedOutcome.y2 - targetedOutcome.y\n\t\tconst targetedWidth = targetedOutcome.x2 - targetedOutcome.x\n\n\t\tconst horizontal1Allowed = targetedOutcome.x <= borders.x\n\t\tconst horizontal2Allowed = targetedOutcome.x2 >= borders.x2\n\n\t\tconst vertical1Allowed = targetedOutcome.y <= borders.y\n\t\tconst vertical2Allowed = targetedOutcome.y2 >= borders.y2\n\n\t\tconst horizontalTransformationAllowed = horizontal1Allowed && horizontal2Allowed\n\t\tconst verticalTransformationAllowed = vertical1Allowed && vertical2Allowed\n\n\t\t// find out which operation would be illegal and calculate the adjusted transformOrigin\n\t\tconst targetX = !horizontal1Allowed ? borders.x : !horizontal2Allowed ? borders.x2 - targetedWidth : targetedOutcome.x\n\t\tconst targetY = !vertical1Allowed ? borders.y : !vertical2Allowed ? borders.y2 - targetedHeight : targetedOutcome.y\n\t\tif (targetX !== targetedOutcome.x || targetY !== targetedOutcome.y) {\n\t\t\tnewTransformOrigin = this.calculateTransformOriginFromTarget(\n\t\t\t\t{\n\t\t\t\t\tx: targetX,\n\t\t\t\t\ty: targetY,\n\t\t\t\t},\n\t\t\t\tcurrentZoomablePositionWithoutTransformation,\n\t\t\t\tnewPinchSessionTranslation,\n\t\t\t\tnewScale,\n\t\t\t)\n\t\t}\n\t\tif (newScale === 1 && this.zoomBoundaries.min === 1) {\n\t\t\t// not initially scaled email is back in the original state\n\t\t\tthis.pinchSessionTranslation = { x: 0, y: 0 }\n\t\t} else {\n\t\t\tthis.pinchSessionTranslation = newPinchSessionTranslation\n\t\t}\n\t\tthis.currentScale = newScale\n\n\t\treturn {\n\t\t\tverticalTransformationAllowed,\n\t\t\thorizontalTransformationAllowed,\n\t\t\tnewTransformOrigin,\n\t\t}\n\t}\n\n\t/**\n\t * calculate the outcome of the css transformation\n\t * this is used to check the boundaries before actually applying the transformation\n\t */\n\tprivate simulateTransformation(\n\t\tcurrentOriginalPosition: CoordinatePair,\n\t\toriginalWidth: number,\n\t\toriginalHeight: number,\n\t\ttransformOrigin: CoordinatePair,\n\t\ttranslation: CoordinatePair,\n\t\tscale: number,\n\t): { x: number; y: number; x2: number; y2: number } {\n\t\treturn {\n\t\t\tx: currentOriginalPosition.x + transformOrigin.x - transformOrigin.x * scale + translation.x,\n\t\t\ty: currentOriginalPosition.y + transformOrigin.y - transformOrigin.y * scale + translation.y,\n\t\t\tx2: currentOriginalPosition.x + transformOrigin.x + (originalWidth - transformOrigin.x) * scale + translation.x,\n\t\t\ty2: currentOriginalPosition.y + transformOrigin.y + (originalHeight - transformOrigin.y) * scale + translation.y,\n\t\t}\n\t}\n}\n","// DO NOT EDIT: generated by update-icons script\nexport const FontIcons = Object.freeze({\n\tReply: `\\uea01`,\n\tReplyAll: `\\uea02`,\n\tWarning: `\\uea03`,\n\tForward: `\\uea04`,\n\tAttach: `\\uea05`,\n\tFolder: `\\uea06`,\n\tInbox: `\\uea07`,\n\tSent: `\\uea08`,\n\tTrash: `\\uea09`,\n\tArchive: `\\uea0a`,\n\tSpam: `\\uea0b`,\n\tDraft: `\\uea0c`,\n\tEdit: `\\uea0d`,\n\tConfidential: `\\uea0e`,\n\tPQConfidential: `\\uea0f`,\n\tCheckbox: `\\uea10`,\n} as const)\n","import type { MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { createMail, File as TutanotaFile, Mail, MailFolder } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { LockedError, PreconditionFailedError } from \"../../../common/api/common/error/RestError\"\nimport { Dialog } from \"../../../common/gui/base/Dialog\"\nimport { locator } from \"../../../common/api/main/CommonLocator\"\nimport { AllIcons } from \"../../../common/gui/base/Icon\"\nimport { Icons } from \"../../../common/gui/base/icons/Icons\"\nimport { isApp, isDesktop } from \"../../../common/api/common/Env\"\nimport { assertNotNull, endsWith, neverNull, noOp, promiseMap } from \"@tutao/tutanota-utils\"\nimport {\n\tEncryptionAuthStatus,\n\tgetMailFolderType,\n\tMailReportType,\n\tMailSetKind,\n\tMailState,\n\tSYSTEM_GROUP_MAIL_ADDRESS,\n} from \"../../../common/api/common/TutanotaConstants\"\nimport { getElementId } from \"../../../common/api/common/utils/EntityUtils\"\nimport { reportMailsAutomatically } from \"./MailReportDialog\"\nimport { DataFile } from \"../../../common/api/common/DataFile\"\nimport { lang, Translation, TranslationKey } from \"../../../common/misc/LanguageViewModel\"\nimport { FileController } from \"../../../common/file/FileController\"\nimport { DomRectReadOnlyPolyfilled, Dropdown, DropdownChildAttrs, PosRect } from \"../../../common/gui/base/Dropdown.js\"\nimport { modal } from \"../../../common/gui/base/Modal.js\"\nimport { ConversationViewModel } from \"./ConversationViewModel.js\"\nimport { size } from \"../../../common/gui/size.js\"\nimport { PinchZoom } from \"../../../common/gui/PinchZoom.js\"\nimport { InlineImageReference, InlineImages } from \"../../../common/mailFunctionality/inlineImagesUtils.js\"\nimport { MailModel } from \"../model/MailModel.js\"\nimport { hasValidEncryptionAuthForTeamOrSystemMail } from \"../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { mailLocator } from \"../../mailLocator.js\"\nimport { assertSystemFolderOfType, FolderInfo, getFolderName, getIndentedFolderNameForDropdown, getMoveTargetFolderSystems } from \"../model/MailUtils.js\"\nimport { FontIcons } from \"../../../common/gui/base/icons/FontIcons.js\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError.js\"\nimport { isOfTypeOrSubfolderOf, isSpamOrTrashFolder } from \"../model/MailChecks.js\"\nimport type { FolderSystem, IndentedFolder } from \"../../../common/api/common/mail/FolderSystem.js\"\n\nexport async function showDeleteConfirmationDialog(mails: ReadonlyArray<Mail>): Promise<boolean> {\n\tlet trashMails: Mail[] = []\n\tlet moveMails: Mail[] = []\n\tfor (let mail of mails) {\n\t\tconst folder = mailLocator.mailModel.getMailFolderForMail(mail)\n\t\tconst folders = await mailLocator.mailModel.getMailboxFoldersForMail(mail)\n\t\tif (folders == null) {\n\t\t\tcontinue\n\t\t}\n\t\tconst isFinalDelete = folder && isSpamOrTrashFolder(folders, folder)\n\t\tif (isFinalDelete) {\n\t\t\ttrashMails.push(mail)\n\t\t} else {\n\t\t\tmoveMails.push(mail)\n\t\t}\n\t}\n\n\tlet confirmationTextId: TranslationKey | null = null\n\n\tif (trashMails.length > 0) {\n\t\tif (moveMails.length > 0) {\n\t\t\tconfirmationTextId = \"finallyDeleteSelectedEmails_msg\"\n\t\t} else {\n\t\t\tconfirmationTextId = \"finallyDeleteEmails_msg\"\n\t\t}\n\t}\n\n\tif (confirmationTextId != null) {\n\t\treturn Dialog.confirm(confirmationTextId, \"ok_action\")\n\t} else {\n\t\treturn Promise.resolve(true)\n\t}\n}\n\n/**\n * @return whether emails were deleted\n */\nexport function promptAndDeleteMails(mailModel: MailModel, mails: ReadonlyArray<Mail>, onConfirm: () => void): Promise<boolean> {\n\treturn showDeleteConfirmationDialog(mails).then((confirmed) => {\n\t\tif (confirmed) {\n\t\t\tonConfirm()\n\t\t\treturn mailModel\n\t\t\t\t.deleteMails(mails)\n\t\t\t\t.then(() => true)\n\t\t\t\t.catch((e) => {\n\t\t\t\t\t//LockedError should no longer be thrown!?!\n\t\t\t\t\tif (e instanceof PreconditionFailedError || e instanceof LockedError) {\n\t\t\t\t\t\treturn Dialog.message(\"operationStillActive_msg\").then(() => false)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t} else {\n\t\t\treturn Promise.resolve(false)\n\t\t}\n\t})\n}\n\ninterface MoveMailsParams {\n\tmailboxModel: MailboxModel\n\tmailModel: MailModel\n\tmails: ReadonlyArray<Mail>\n\ttargetMailFolder: MailFolder\n\tisReportable?: boolean\n}\n\n/**\n * Moves the mails and reports them as spam if the user or settings allow it.\n * @return whether mails were actually moved\n */\nexport async function moveMails({ mailboxModel, mailModel, mails, targetMailFolder, isReportable = true }: MoveMailsParams): Promise<boolean> {\n\tconst details = await mailModel.getMailboxDetailsForMailFolder(targetMailFolder)\n\tif (details == null || details.mailbox.folders == null) {\n\t\treturn false\n\t}\n\tconst system = await mailModel.getMailboxFoldersForId(details.mailbox.folders._id)\n\treturn mailModel\n\t\t.moveMails(mails, targetMailFolder)\n\t\t.then(async () => {\n\t\t\tif (isOfTypeOrSubfolderOf(system, targetMailFolder, MailSetKind.SPAM) && isReportable) {\n\t\t\t\tconst reportableMails = mails.map((mail) => {\n\t\t\t\t\t// mails have just been moved\n\t\t\t\t\tconst reportableMail = createMail(mail)\n\t\t\t\t\treportableMail._id = targetMailFolder.isMailSet ? mail._id : [targetMailFolder.mails, getElementId(mail)]\n\t\t\t\t\treturn reportableMail\n\t\t\t\t})\n\t\t\t\tconst mailboxDetails = await mailboxModel.getMailboxDetailsForMailGroup(assertNotNull(targetMailFolder._ownerGroup))\n\t\t\t\tawait reportMailsAutomatically(MailReportType.SPAM, mailboxModel, mailModel, mailboxDetails, reportableMails)\n\t\t\t}\n\n\t\t\treturn true\n\t\t})\n\t\t.catch((e) => {\n\t\t\t//LockedError should no longer be thrown!?!\n\t\t\tif (e instanceof LockedError || e instanceof PreconditionFailedError) {\n\t\t\t\treturn Dialog.message(\"operationStillActive_msg\").then(() => false)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t})\n}\n\nexport function archiveMails(mails: Mail[]): Promise<void> {\n\tif (mails.length > 0) {\n\t\t// assume all mails in the array belong to the same Mailbox\n\t\treturn mailLocator.mailModel.getMailboxFoldersForMail(mails[0]).then((folders: FolderSystem) => {\n\t\t\tif (folders) {\n\t\t\t\tmoveMails({\n\t\t\t\t\tmailboxModel: locator.mailboxModel,\n\t\t\t\t\tmailModel: mailLocator.mailModel,\n\t\t\t\t\tmails: mails,\n\t\t\t\t\ttargetMailFolder: assertSystemFolderOfType(folders, MailSetKind.ARCHIVE),\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t} else {\n\t\treturn Promise.resolve()\n\t}\n}\n\nexport function moveToInbox(mails: Mail[]): Promise<any> {\n\tif (mails.length > 0) {\n\t\t// assume all mails in the array belong to the same Mailbox\n\t\treturn mailLocator.mailModel.getMailboxFoldersForMail(mails[0]).then((folders: FolderSystem) => {\n\t\t\tif (folders) {\n\t\t\t\tmoveMails({\n\t\t\t\t\tmailboxModel: locator.mailboxModel,\n\t\t\t\t\tmailModel: mailLocator.mailModel,\n\t\t\t\t\tmails: mails,\n\t\t\t\t\ttargetMailFolder: assertSystemFolderOfType(folders, MailSetKind.INBOX),\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t} else {\n\t\treturn Promise.resolve()\n\t}\n}\n\nexport function getFolderIconByType(folderType: MailSetKind): AllIcons {\n\tswitch (folderType) {\n\t\tcase MailSetKind.CUSTOM:\n\t\t\treturn Icons.Folder\n\n\t\tcase MailSetKind.INBOX:\n\t\t\treturn Icons.Inbox\n\n\t\tcase MailSetKind.SENT:\n\t\t\treturn Icons.Send\n\n\t\tcase MailSetKind.TRASH:\n\t\t\treturn Icons.TrashBin\n\n\t\tcase MailSetKind.ARCHIVE:\n\t\t\treturn Icons.Archive\n\n\t\tcase MailSetKind.SPAM:\n\t\t\treturn Icons.Spam\n\n\t\tcase MailSetKind.DRAFT:\n\t\t\treturn Icons.Draft\n\n\t\tdefault:\n\t\t\treturn Icons.Folder\n\t}\n}\n\nexport function getFolderIcon(folder: MailFolder): AllIcons {\n\treturn getFolderIconByType(getMailFolderType(folder))\n}\n\nexport function getMailFolderIcon(mail: Mail): AllIcons {\n\tlet folder = mailLocator.mailModel.getMailFolderForMail(mail)\n\n\tif (folder) {\n\t\treturn getFolderIcon(folder)\n\t} else {\n\t\treturn Icons.Folder\n\t}\n}\n\nexport function replaceCidsWithInlineImages(\n\tdom: HTMLElement,\n\tinlineImages: InlineImages,\n\tonContext: (cid: string, arg1: MouseEvent | TouchEvent, arg2: HTMLElement) => unknown,\n): Array<HTMLElement> {\n\t// all image tags which have cid attribute. The cid attribute has been set by the sanitizer for adding a default image.\n\tconst imageElements: Array<HTMLElement> = Array.from(dom.querySelectorAll(\"img[cid]\"))\n\tif (dom.shadowRoot) {\n\t\tconst shadowImageElements: Array<HTMLElement> = Array.from(dom.shadowRoot.querySelectorAll(\"img[cid]\"))\n\t\timageElements.push(...shadowImageElements)\n\t}\n\tconst elementsWithCid: HTMLElement[] = []\n\tfor (const imageElement of imageElements) {\n\t\tconst cid = imageElement.getAttribute(\"cid\")\n\n\t\tif (cid) {\n\t\t\tconst inlineImage = inlineImages.get(cid)\n\n\t\t\tif (inlineImage) {\n\t\t\t\telementsWithCid.push(imageElement)\n\t\t\t\timageElement.setAttribute(\"src\", inlineImage.objectUrl)\n\t\t\t\timageElement.classList.remove(\"tutanota-placeholder\")\n\n\t\t\t\tif (isApp()) {\n\t\t\t\t\t// Add long press action for apps\n\t\t\t\t\tlet timeoutId: TimeoutID | null\n\t\t\t\t\tlet startCoords:\n\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\tx: number\n\t\t\t\t\t\t\t\ty: number\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t| null\n\t\t\t\t\t\t| undefined\n\t\t\t\t\timageElement.addEventListener(\"touchstart\", (e: TouchEvent) => {\n\t\t\t\t\t\tconst touch = e.touches[0]\n\t\t\t\t\t\tif (!touch) return\n\t\t\t\t\t\tstartCoords = {\n\t\t\t\t\t\t\tx: touch.clientX,\n\t\t\t\t\t\t\ty: touch.clientY,\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (timeoutId) clearTimeout(timeoutId)\n\t\t\t\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\t\t\t\tonContext(inlineImage.cid, e, imageElement)\n\t\t\t\t\t\t}, 800)\n\t\t\t\t\t})\n\t\t\t\t\timageElement.addEventListener(\"touchmove\", (e: TouchEvent) => {\n\t\t\t\t\t\tconst touch = e.touches[0]\n\t\t\t\t\t\tif (!touch || !startCoords || !timeoutId) return\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tMath.abs(touch.clientX - startCoords.x) > PinchZoom.DRAG_THRESHOLD ||\n\t\t\t\t\t\t\tMath.abs(touch.clientY - startCoords.y) > PinchZoom.DRAG_THRESHOLD\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tclearTimeout(timeoutId)\n\t\t\t\t\t\t\ttimeoutId = null\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\timageElement.addEventListener(\"touchend\", () => {\n\t\t\t\t\t\tif (timeoutId) {\n\t\t\t\t\t\t\tclearTimeout(timeoutId)\n\t\t\t\t\t\t\ttimeoutId = null\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (isDesktop()) {\n\t\t\t\t\t// add right click action for desktop apps\n\t\t\t\t\timageElement.addEventListener(\"contextmenu\", (e: MouseEvent) => {\n\t\t\t\t\t\tonContext(inlineImage.cid, e, imageElement)\n\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn elementsWithCid\n}\n\nexport function replaceInlineImagesWithCids(dom: HTMLElement): HTMLElement {\n\tconst domClone = dom.cloneNode(true) as HTMLElement\n\tconst inlineImages: Array<HTMLElement> = Array.from(domClone.querySelectorAll(\"img[cid]\"))\n\tfor (const inlineImage of inlineImages) {\n\t\tconst cid = inlineImage.getAttribute(\"cid\")\n\t\tinlineImage.setAttribute(\"src\", \"cid:\" + (cid || \"\"))\n\t\tinlineImage.removeAttribute(\"cid\")\n\t}\n\treturn domClone\n}\n\nexport function createInlineImage(file: DataFile): InlineImageReference {\n\tconst cid = Math.random().toString(30).substring(2)\n\tfile.cid = cid\n\treturn createInlineImageReference(file, cid)\n}\n\nfunction createInlineImageReference(file: DataFile, cid: string): InlineImageReference {\n\tconst blob = new Blob([file.data], {\n\t\ttype: file.mimeType,\n\t})\n\tconst objectUrl = URL.createObjectURL(blob)\n\treturn {\n\t\tcid,\n\t\tobjectUrl,\n\t\tblob,\n\t}\n}\n\nexport async function loadInlineImages(fileController: FileController, attachments: Array<TutanotaFile>, referencedCids: Array<string>): Promise<InlineImages> {\n\tconst filesToLoad = getReferencedAttachments(attachments, referencedCids)\n\tconst inlineImages = new Map()\n\treturn promiseMap(filesToLoad, async (file) => {\n\t\tlet dataFile = await fileController.getAsDataFile(file)\n\t\tconst { htmlSanitizer } = await import(\"../../../common/misc/HtmlSanitizer\")\n\t\tdataFile = htmlSanitizer.sanitizeInlineAttachment(dataFile)\n\t\tconst inlineImageReference = createInlineImageReference(dataFile, neverNull(file.cid))\n\t\tinlineImages.set(inlineImageReference.cid, inlineImageReference)\n\t}).then(() => inlineImages)\n}\n\nexport function getReferencedAttachments(attachments: Array<TutanotaFile>, referencedCids: Array<string>): Array<TutanotaFile> {\n\treturn attachments.filter((file) => referencedCids.find((rcid) => file.cid === rcid))\n}\n\nexport async function showMoveMailsDropdown(\n\tmailboxModel: MailboxModel,\n\tmodel: MailModel,\n\torigin: PosRect,\n\tmails: readonly Mail[],\n\topts?: { width?: number; withBackground?: boolean; onSelected?: () => unknown },\n): Promise<void> {\n\tconst folders = await getMoveTargetFolderSystems(model, mails)\n\tawait showMailFolderDropdown(\n\t\torigin,\n\t\tfolders,\n\t\t(f) =>\n\t\t\tmoveMails({\n\t\t\t\tmailboxModel,\n\t\t\t\tmailModel: model,\n\t\t\t\tmails: mails,\n\t\t\t\ttargetMailFolder: f.folder,\n\t\t\t}),\n\t\topts,\n\t)\n}\n\nexport async function showMailFolderDropdown(\n\torigin: PosRect,\n\tfolders: readonly FolderInfo[],\n\tonClick: (folder: IndentedFolder) => unknown,\n\topts?: { width?: number; withBackground?: boolean; onSelected?: () => unknown },\n): Promise<void> {\n\tconst { width = 300, withBackground = false, onSelected = noOp } = opts ?? {}\n\n\tif (folders.length === 0) return\n\tconst folderButtons = folders.map(\n\t\t(f) =>\n\t\t\t({\n\t\t\t\t// We need to pass in the raw folder name to avoid including it in searches\n\t\t\t\tlabel: lang.makeTranslation(\n\t\t\t\t\t`dropdown-folder:${getFolderName(f.folder)}`,\n\t\t\t\t\tlang.get(\"folderDepth_label\", {\n\t\t\t\t\t\t\"{folderName}\": getFolderName(f.folder),\n\t\t\t\t\t\t\"{depth}\": f.level,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t\ttext: lang.makeTranslation(\"folder_name\", getIndentedFolderNameForDropdown(f)),\n\t\t\t\tclick: () => {\n\t\t\t\t\tonSelected()\n\t\t\t\t\tonClick(f)\n\t\t\t\t},\n\t\t\t\ticon: getFolderIcon(f.folder),\n\t\t\t} satisfies DropdownChildAttrs),\n\t)\n\n\tconst dropdown = new Dropdown(() => folderButtons, width)\n\tdropdown.setOrigin(new DomRectReadOnlyPolyfilled(origin.left, origin.top, origin.width, origin.height))\n\tmodal.displayUnique(dropdown, withBackground)\n}\n\nexport function getConversationTitle(conversationViewModel: ConversationViewModel): Translation {\n\tif (!conversationViewModel.isFinished()) {\n\t\treturn lang.getTranslation(\"loading_msg\")\n\t}\n\tconst numberOfEmails = conversationViewModel.conversationItems().length\n\tif (numberOfEmails === 1) {\n\t\treturn lang.getTranslation(\"oneEmail_label\")\n\t} else {\n\t\treturn lang.getTranslation(\"nbrOrEmails_label\", { \"{number}\": numberOfEmails })\n\t}\n}\n\nexport function getMoveMailBounds(): PosRect {\n\t// just putting the move mail dropdown in the left side of the viewport with a bit of margin\n\treturn new DomRectReadOnlyPolyfilled(size.hpad_large, size.vpad_large, 0, 0)\n}\n\n/**\n * NOTE: DOES NOT VERIFY IF THE MESSAGE IS AUTHENTIC - DO NOT USE THIS OUTSIDE OF THIS FILE OR FOR TESTING\n * @VisibleForTesting\n */\nexport function isTutanotaTeamAddress(address: string): boolean {\n\treturn endsWith(address, \"@tutao.de\") || address === \"no-reply@tutanota.de\"\n}\n\n/**\n * Is this a tutao team member email or a system notification\n */\nexport function isTutanotaTeamMail(mail: Mail): boolean {\n\tconst { confidential, sender, state } = mail\n\treturn (\n\t\tconfidential &&\n\t\tstate === MailState.RECEIVED &&\n\t\thasValidEncryptionAuthForTeamOrSystemMail(mail) &&\n\t\t(sender.address === SYSTEM_GROUP_MAIL_ADDRESS || isTutanotaTeamAddress(sender.address))\n\t)\n}\n\n/**\n * Returns the confidential icon for the given mail which indicates either RSA or PQ encryption.\n * The caller must ensure that the mail is in a confidential state.\n */\nexport function getConfidentialIcon(mail: Mail): Icons {\n\tif (!mail.confidential) throw new ProgrammingError(\"mail is not confidential\")\n\tif (\n\t\tmail.encryptionAuthStatus == EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED ||\n\t\tmail.encryptionAuthStatus == EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED ||\n\t\tmail.encryptionAuthStatus == EncryptionAuthStatus.TUTACRYPT_SENDER\n\t) {\n\t\treturn Icons.PQLock\n\t} else {\n\t\treturn Icons.Lock\n\t}\n}\n\n/**\n * Returns the confidential font icon for the given mail which indicates either RSA or PQ encryption.\n * The caller must ensure that the mail is in a confidential state.\n */\nexport function getConfidentialFontIcon(mail: Mail): string {\n\tconst confidentialIcon = getConfidentialIcon(mail)\n\treturn confidentialIcon === Icons.PQLock ? FontIcons.PQConfidential : FontIcons.Confidential\n}\n\nexport function isMailContrastFixNeeded(editorDom: ParentNode): boolean {\n\treturn (\n\t\tArray.from(editorDom.querySelectorAll(\"*[style]\"), (e) => (e as HTMLElement).style).some(\n\t\t\t(s) => (s.color && s.color !== \"inherit\") || (s.backgroundColor && s.backgroundColor !== \"inherit\"),\n\t\t) || editorDom.querySelectorAll(\"font[color]\").length > 0\n\t)\n}\n","import { Keys, MailReportType, MailState, ReplyType, SYSTEM_GROUP_MAIL_ADDRESS } from \"../../../common/api/common/TutanotaConstants\"\nimport { assertNotNull, neverNull, ofClass } from \"@tutao/tutanota-utils\"\nimport { InfoLink, lang } from \"../../../common/misc/LanguageViewModel\"\nimport { Dialog } from \"../../../common/gui/base/Dialog\"\nimport m from \"mithril\"\nimport { Button, ButtonType } from \"../../../common/gui/base/Button.js\"\nimport { progressIcon } from \"../../../common/gui/base/Icon.js\"\nimport { checkApprovalStatus } from \"../../../common/misc/LoginUtils.js\"\nimport { locator } from \"../../../common/api/main/CommonLocator.js\"\nimport { UserError } from \"../../../common/api/main/UserError.js\"\nimport { showUserError } from \"../../../common/misc/ErrorHandlerImpl.js\"\nimport { ContentBlockingStatus, MailViewerViewModel } from \"./MailViewerViewModel.js\"\nimport { DropdownButtonAttrs } from \"../../../common/gui/base/Dropdown.js\"\nimport { Icons } from \"../../../common/gui/base/icons/Icons.js\"\nimport { client } from \"../../../common/misc/ClientDetector.js\"\nimport { showProgressDialog } from \"../../../common/gui/dialogs/ProgressDialog.js\"\nimport { LockedError } from \"../../../common/api/common/error/RestError.js\"\nimport { ifAllowedTutaLinks } from \"../../../common/gui/base/GuiUtils.js\"\nimport { ExternalLink } from \"../../../common/gui/base/ExternalLink.js\"\nimport { SourceCodeViewer } from \"./SourceCodeViewer.js\"\nimport { getMailAddressDisplayText, hasValidEncryptionAuthForTeamOrSystemMail } from \"../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { mailLocator } from \"../../mailLocator.js\"\nimport { Mail, MailDetails } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { getDisplayedSender } from \"../../../common/api/common/CommonMailUtils.js\"\nimport { MailFacade } from \"../../../common/api/worker/facades/lazy/MailFacade.js\"\n\nimport { ListFilter } from \"../../../common/misc/ListModel.js\"\nimport { isDesktop } from \"../../../common/api/common/Env.js\"\nimport { isDraft } from \"../model/MailChecks.js\"\n\nexport async function showHeaderDialog(headersPromise: Promise<string | null>) {\n\tlet state: { state: \"loading\" } | { state: \"loaded\"; headers: string | null } = { state: \"loading\" }\n\n\theadersPromise.then((headers) => {\n\t\tstate = { state: \"loaded\", headers }\n\t\tm.redraw()\n\t})\n\n\tlet mailHeadersDialog: Dialog\n\tconst closeHeadersAction = () => {\n\t\tmailHeadersDialog?.close()\n\t}\n\n\tmailHeadersDialog = Dialog.largeDialog(\n\t\t{\n\t\t\tright: [\n\t\t\t\t{\n\t\t\t\t\tlabel: \"ok_action\",\n\t\t\t\t\tclick: closeHeadersAction,\n\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t},\n\t\t\t],\n\t\t\tmiddle: \"mailHeaders_title\",\n\t\t},\n\t\t{\n\t\t\tview: () =>\n\t\t\t\tm(\n\t\t\t\t\t\".white-space-pre.pt.pb.selectable\",\n\t\t\t\t\tstate.state === \"loading\" ? m(\".center\", progressIcon()) : state.headers ?? m(\".center\", lang.get(\"noEntries_msg\")),\n\t\t\t\t),\n\t\t},\n\t)\n\t\t.addShortcut({\n\t\t\tkey: Keys.ESC,\n\t\t\texec: closeHeadersAction,\n\t\t\thelp: \"close_alt\",\n\t\t})\n\t\t.setCloseHandler(closeHeadersAction)\n\t\t.show()\n}\n\nexport async function loadMailDetails(mailFacade: MailFacade, mail: Mail): Promise<MailDetails> {\n\tif (isDraft(mail)) {\n\t\tconst detailsDraftId = assertNotNull(mail.mailDetailsDraft)\n\t\treturn mailFacade.loadMailDetailsDraft(mail)\n\t} else {\n\t\tconst mailDetailsId = neverNull(mail.mailDetails)\n\t\treturn mailFacade.loadMailDetailsBlob(mail)\n\t}\n}\n\nexport async function editDraft(viewModel: MailViewerViewModel): Promise<void> {\n\tconst sendAllowed = await checkApprovalStatus(locator.logins, false)\n\tif (sendAllowed) {\n\t\t// check if to be opened draft has already been minimized, iff that is the case, re-open it\n\t\tconst minimizedEditor = mailLocator.minimizedMailModel.getEditorForDraft(viewModel.mail)\n\n\t\tif (minimizedEditor) {\n\t\t\tmailLocator.minimizedMailModel.reopenMinimizedEditor(minimizedEditor)\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tconst [mailboxDetails, { newMailEditorFromDraft }] = await Promise.all([\n\t\t\t\t\tviewModel.mailModel.getMailboxDetailsForMail(viewModel.mail),\n\t\t\t\t\timport(\"../editor/MailEditor\"),\n\t\t\t\t])\n\t\t\t\tif (mailboxDetails == null) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst editorDialog = await newMailEditorFromDraft(\n\t\t\t\t\tviewModel.mail,\n\t\t\t\t\tawait loadMailDetails(locator.mailFacade, viewModel.mail),\n\t\t\t\t\tviewModel.getAttachments(),\n\t\t\t\t\tviewModel.getLoadedInlineImages(),\n\t\t\t\t\tviewModel.isBlockingExternalImages(),\n\t\t\t\t\tmailboxDetails,\n\t\t\t\t)\n\t\t\t\teditorDialog.show()\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof UserError) {\n\t\t\t\t\tawait showUserError(e)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function showSourceDialog(rawHtml: string) {\n\treturn Dialog.viewerDialog(\"emailSourceCode_title\", SourceCodeViewer, { rawHtml })\n}\n\nexport function mailViewerMoreActions(viewModel: MailViewerViewModel, showReadButton: boolean = true): Array<DropdownButtonAttrs> {\n\tconst moreButtons: Array<DropdownButtonAttrs> = []\n\tif (showReadButton) {\n\t\tif (viewModel.isUnread()) {\n\t\t\tmoreButtons.push({\n\t\t\t\tlabel: \"markRead_action\",\n\t\t\t\tclick: () => viewModel.setUnread(false),\n\t\t\t\ticon: Icons.Eye,\n\t\t\t})\n\t\t} else {\n\t\t\tmoreButtons.push({\n\t\t\t\tlabel: \"markUnread_action\",\n\t\t\t\tclick: () => viewModel.setUnread(true),\n\t\t\t\ticon: Icons.NoEye,\n\t\t\t})\n\t\t}\n\t}\n\n\tif (viewModel.canPersistBlockingStatus() && viewModel.isShowingExternalContent()) {\n\t\tmoreButtons.push({\n\t\t\tlabel: \"disallowExternalContent_action\",\n\t\t\tclick: () => viewModel.setContentBlockingStatus(ContentBlockingStatus.Block),\n\t\t\ticon: Icons.Picture,\n\t\t})\n\t}\n\n\tif (viewModel.canPersistBlockingStatus() && viewModel.isBlockingExternalImages()) {\n\t\tmoreButtons.push({\n\t\t\tlabel: \"showImages_action\",\n\t\t\tclick: () => viewModel.setContentBlockingStatus(ContentBlockingStatus.Show),\n\t\t\ticon: Icons.Picture,\n\t\t})\n\t}\n\n\tif (viewModel.isListUnsubscribe()) {\n\t\tmoreButtons.push({\n\t\t\tlabel: \"unsubscribe_action\",\n\t\t\tclick: () => unsubscribe(viewModel),\n\t\t\ticon: Icons.Cancel,\n\t\t})\n\t}\n\n\tif (!client.isMobileDevice() && viewModel.canExport()) {\n\t\tmoreButtons.push({\n\t\t\tlabel: \"export_action\",\n\t\t\tclick: () => showProgressDialog(\"pleaseWait_msg\", viewModel.exportMail()),\n\t\t\ticon: Icons.Export,\n\t\t})\n\t}\n\n\tif (!client.isMobileDevice() && typeof window.print === \"function\" && viewModel.canPrint()) {\n\t\tmoreButtons.push({\n\t\t\tlabel: \"print_action\",\n\t\t\tclick: () => window.print(),\n\t\t\ticon: Icons.Print,\n\t\t})\n\t}\n\n\tif (viewModel.canShowHeaders()) {\n\t\tmoreButtons.push({\n\t\t\tlabel: \"showHeaders_action\",\n\t\t\tclick: () => showHeaderDialog(viewModel.getHeaders()),\n\t\t\ticon: Icons.ListUnordered,\n\t\t})\n\t}\n\n\tif (viewModel.canReport()) {\n\t\tmoreButtons.push({\n\t\t\tlabel: \"reportEmail_action\",\n\t\t\tclick: () => reportMail(viewModel),\n\t\t\ticon: Icons.Warning,\n\t\t})\n\t}\n\n\t// adding more optional buttons? put them above the report action so the new button\n\t// is not sometimes where the report action usually sits.\n\n\treturn moreButtons\n}\n\nfunction unsubscribe(viewModel: MailViewerViewModel): Promise<void> {\n\treturn showProgressDialog(\"pleaseWait_msg\", viewModel.unsubscribe())\n\t\t.then((success) => {\n\t\t\tif (success) {\n\t\t\t\treturn Dialog.message(\"unsubscribeSuccessful_msg\")\n\t\t\t}\n\t\t})\n\t\t.catch((e) => {\n\t\t\tif (e instanceof LockedError) {\n\t\t\t\treturn Dialog.message(\"operationStillActive_msg\")\n\t\t\t} else {\n\t\t\t\treturn Dialog.message(\"unsubscribeFailed_msg\")\n\t\t\t}\n\t\t})\n}\n\nfunction reportMail(viewModel: MailViewerViewModel) {\n\tconst sendReport = (reportType: MailReportType) => {\n\t\tviewModel\n\t\t\t.reportMail(reportType)\n\t\t\t.catch(ofClass(LockedError, () => Dialog.message(\"operationStillActive_msg\")))\n\t\t\t.finally(m.redraw)\n\t}\n\n\tconst dialog = Dialog.showActionDialog({\n\t\ttitle: \"reportEmail_action\",\n\t\tchild: () =>\n\t\t\tm(\n\t\t\t\t\".flex.col.mt-m\",\n\t\t\t\t{\n\t\t\t\t\t// So that space below buttons doesn't look huge\n\t\t\t\t\tstyle: {\n\t\t\t\t\t\tmarginBottom: \"-10px\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t[\n\t\t\t\t\tm(\"div\", lang.get(\"phishingReport_msg\")),\n\t\t\t\t\tifAllowedTutaLinks(locator.logins, InfoLink.Phishing, (link) =>\n\t\t\t\t\t\tm(ExternalLink, {\n\t\t\t\t\t\t\thref: link,\n\t\t\t\t\t\t\ttext: lang.get(\"whatIsPhishing_msg\"),\n\t\t\t\t\t\t\tisCompanySite: true,\n\t\t\t\t\t\t\tclass: \"mt-s\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t\tm(\".flex-wrap.flex-end\", [\n\t\t\t\t\t\tm(Button, {\n\t\t\t\t\t\t\tlabel: \"reportPhishing_action\",\n\t\t\t\t\t\t\tclick: () => {\n\t\t\t\t\t\t\t\tsendReport(MailReportType.PHISHING)\n\t\t\t\t\t\t\t\tdialog.close()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tm(Button, {\n\t\t\t\t\t\t\tlabel: \"reportSpam_action\",\n\t\t\t\t\t\t\tclick: () => {\n\t\t\t\t\t\t\t\tsendReport(MailReportType.SPAM)\n\t\t\t\t\t\t\t\tdialog.close()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t\t}),\n\t\t\t\t\t]),\n\t\t\t\t],\n\t\t\t),\n\t\tokAction: null,\n\t})\n}\n\nexport function isNoReplyTeamAddress(address: string): boolean {\n\treturn address === \"no-reply@tutao.de\" || address === \"no-reply@tutanota.de\"\n}\n\n/**\n * Is this a system notification?\n */\nexport function isSystemNotification(mail: Mail): boolean {\n\tconst { confidential, sender, state } = mail\n\treturn (\n\t\tstate === MailState.RECEIVED &&\n\t\tconfidential &&\n\t\thasValidEncryptionAuthForTeamOrSystemMail(mail) &&\n\t\t(sender.address === SYSTEM_GROUP_MAIL_ADDRESS ||\n\t\t\t// New emails will have sender set to system and will only have replyTo set to no-reply\n\t\t\t// but we should keep displaying old emails correctly.\n\t\t\tisNoReplyTeamAddress(sender.address))\n\t)\n}\n\nexport function getRecipientHeading(mail: Mail, preferNameOnly: boolean) {\n\tlet recipientCount = parseInt(mail.recipientCount)\n\tif (recipientCount > 0) {\n\t\tlet recipient = neverNull(mail.firstRecipient)\n\t\treturn getMailAddressDisplayText(recipient.name, recipient.address, preferNameOnly) + (recipientCount > 1 ? \", ...\" : \"\")\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nexport function getSenderOrRecipientHeading(mail: Mail, preferNameOnly: boolean): string {\n\tif (isSystemNotification(mail)) {\n\t\treturn \"\"\n\t} else if (mail.state === MailState.RECEIVED) {\n\t\tconst sender = getDisplayedSender(mail)\n\t\treturn getMailAddressDisplayText(sender.name, sender.address, preferNameOnly)\n\t} else {\n\t\treturn getRecipientHeading(mail, preferNameOnly)\n\t}\n}\n\nexport enum MailFilterType {\n\tUnread,\n\tRead,\n\tWithAttachments,\n}\n\nexport function getMailFilterForType(filter: MailFilterType | null): ListFilter<Mail> | null {\n\tswitch (filter) {\n\t\tcase MailFilterType.Read:\n\t\t\treturn (mail) => !mail.unread\n\t\tcase MailFilterType.Unread:\n\t\t\treturn (mail) => mail.unread\n\t\tcase MailFilterType.WithAttachments:\n\t\t\treturn (mail) => mail.attachments.length > 0\n\t\tcase null:\n\t\t\treturn null\n\t}\n}\n\n/**\n * @returns {boolean} true if the given mail was already replied to. Otherwise false.\n * Note that it also returns true if the mail was replied to AND forwarded.\n */\nexport function isRepliedTo(mail: Mail): boolean {\n\treturn mail.replyType === ReplyType.REPLY || mail.replyType === ReplyType.REPLY_FORWARD\n}\n\nexport function canDoDragAndDropExport(): boolean {\n\treturn isDesktop()\n}\n","import type { Mail, MailDetails } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { FileTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport type { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport { MailState } from \"../../../common/api/common/TutanotaConstants\"\nimport { getLetId } from \"../../../common/api/common/utils/EntityUtils\"\nimport type { HtmlSanitizer } from \"../../../common/misc/HtmlSanitizer\"\nimport { promiseMap } from \"@tutao/tutanota-utils\"\nimport { FileController } from \"../../../common/file/FileController\"\nimport { MailFacade } from \"../../../common/api/worker/facades/lazy/MailFacade.js\"\nimport { CryptoFacade } from \"../../../common/api/worker/crypto/CryptoFacade.js\"\nimport { getDisplayedSender, getMailBodyText, MailAddressAndName } from \"../../../common/api/common/CommonMailUtils.js\"\nimport { loadMailDetails } from \"../view/MailViewerUtils.js\"\nimport { MailBundle } from \"../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { DataFile } from \"../../../common/api/common/DataFile.js\"\n\nexport function makeMailBundle(sanitizer: HtmlSanitizer, mail: Mail, mailDetails: MailDetails, attachments: Array<DataFile>): MailBundle {\n\tconst recipientMapper = ({ address, name }: MailAddressAndName) => ({ address, name })\n\tconst body = sanitizer.sanitizeHTML(getMailBodyText(mailDetails.body), {\n\t\tblockExternalContent: false,\n\t\tallowRelativeLinks: false,\n\t\tusePlaceholderForInlineImages: false,\n\t}).html\n\n\treturn {\n\t\tmailId: getLetId(mail),\n\t\tsubject: mail.subject,\n\t\tbody,\n\t\tsender: recipientMapper(getDisplayedSender(mail)),\n\t\tto: mailDetails.recipients.toRecipients.map(recipientMapper),\n\t\tcc: mailDetails.recipients.ccRecipients.map(recipientMapper),\n\t\tbcc: mailDetails.recipients.bccRecipients.map(recipientMapper),\n\t\treplyTo: mailDetails.replyTos.map(recipientMapper),\n\t\tisDraft: mail.state === MailState.DRAFT,\n\t\tisRead: !mail.unread,\n\t\tsentOn: mailDetails.sentDate.getTime(),\n\t\treceivedOn: mail.receivedDate.getTime(),\n\t\theaders: mailDetails.headers?.compressedHeaders ?? mailDetails.headers?.headers ?? null,\n\t\tattachments,\n\t}\n}\n\n/**\n * Downloads the mail body and the attachments for an email, to prepare for exporting\n */\nexport async function downloadMailBundle(\n\tmail: Mail,\n\tmailFacade: MailFacade,\n\tentityClient: EntityClient,\n\tfileController: FileController,\n\tsanitizer: HtmlSanitizer,\n\tcryptoFacade: CryptoFacade,\n): Promise<MailBundle> {\n\tconst mailDetails = await loadMailDetails(mailFacade, mail)\n\n\tconst files = await promiseMap(mail.attachments, async (fileId) => await entityClient.load(FileTypeRef, fileId))\n\tconst attachments = await promiseMap(\n\t\tawait cryptoFacade.enforceSessionKeyUpdateIfNeeded(mail, files),\n\t\tasync (file) => await fileController.getAsDataFile(file),\n\t)\n\treturn makeMailBundle(sanitizer, mail, mailDetails, attachments)\n}\n","import { noOp, promiseMap, sortableTimestamp } from \"@tutao/tutanota-utils\"\nimport { DataFile } from \"../../../common/api/common/DataFile\"\nimport { downloadMailBundle } from \"./Bundler\"\nimport { isDesktop } from \"../../../common/api/common/Env\"\nimport type { Mail } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport type { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport { locator } from \"../../../common/api/main/CommonLocator\"\nimport { FileController, zipDataFiles } from \"../../../common/file/FileController\"\nimport { MailFacade } from \"../../../common/api/worker/facades/lazy/MailFacade.js\"\nimport { OperationId } from \"../../../common/api/main/OperationProgressTracker.js\"\nimport { CancelledError } from \"../../../common/api/common/error/CancelledError.js\"\nimport { CryptoFacade } from \"../../../common/api/worker/crypto/CryptoFacade.js\"\nimport { MailBundle, MailExportMode } from \"../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { generateExportFileName, mailToEmlFile } from \"./emlUtils.js\"\nimport { elementIdPart } from \"../../../common/api/common/utils/EntityUtils\"\n\nexport async function generateMailFile(bundle: MailBundle, fileName: string, mode: MailExportMode): Promise<DataFile> {\n\treturn mode === \"eml\" ? mailToEmlFile(bundle, fileName) : locator.fileApp.mailToMsg(bundle, fileName)\n}\n\nexport async function getMailExportMode(): Promise<MailExportMode> {\n\tif (isDesktop()) {\n\t\tconst ConfigKeys = await import(\"../../../common/desktop/config/ConfigKeys\")\n\t\tconst mailExportMode = (await locator.desktopSettingsFacade\n\t\t\t.getStringConfigValue(ConfigKeys.DesktopConfigKey.mailExportMode)\n\t\t\t.catch(noOp)) as MailExportMode\n\t\treturn mailExportMode ?? \"eml\"\n\t} else {\n\t\treturn \"eml\"\n\t}\n}\n\n/**\n * export mails. a single one will be exported as is, multiple will be put into a zip file\n * a save dialog will then be shown\n * @returns {Promise<Mail[]>} resolved with failed mails or empty after the fileController\n * was instructed to open the new zip File containing the exported files\n */\nexport async function exportMails(\n\tmails: Array<Mail>,\n\tmailFacade: MailFacade,\n\tentityClient: EntityClient,\n\tfileController: FileController,\n\tcryptoFacade: CryptoFacade,\n\toperationId?: OperationId,\n\tsignal?: AbortSignal,\n): Promise<{ failed: Mail[] }> {\n\tlet cancelled = false\n\n\tconst onAbort = () => {\n\t\tcancelled = true\n\t}\n\n\ttry {\n\t\t// Considering that the effort for generating the bundle is higher\n\t\t// than generating the files, we need to consider it twice, so the\n\t\t// total effort would be (mailsToBundle * 2) + filesToGenerate\n\t\tconst totalMails = mails.length * 3\n\t\tlet doneMails = 0\n\t\tconst errorMails: Mail[] = []\n\n\t\tsignal?.addEventListener(\"abort\", onAbort)\n\t\tconst updateProgress =\n\t\t\toperationId !== undefined ? () => locator.operationProgressTracker.onProgress(operationId, (++doneMails / totalMails) * 100) : noOp\n\n\t\t//The only way to skip a Promise is throwing an error.\n\t\t//this throws just a CancelledError to be handled by the try/catch statement.\n\n\t\t//This function must be called in each iteration across all promises since\n\t\t//throwing it inside the onAbort function doesn't interrupt the pending promises.\n\t\tconst checkAbortSignal = () => {\n\t\t\tif (cancelled) throw new CancelledError(\"export cancelled\")\n\t\t}\n\n\t\tconst downloadPromise = promiseMap(mails, async (mail) => {\n\t\t\tcheckAbortSignal()\n\t\t\ttry {\n\t\t\t\tconst { htmlSanitizer } = await import(\"../../../common/misc/HtmlSanitizer\")\n\t\t\t\treturn await downloadMailBundle(mail, mailFacade, entityClient, fileController, htmlSanitizer, cryptoFacade)\n\t\t\t} catch (e) {\n\t\t\t\terrorMails.push(mail)\n\t\t\t} finally {\n\t\t\t\tupdateProgress()\n\t\t\t\tupdateProgress()\n\t\t\t}\n\t\t})\n\n\t\tconst [mode, bundles] = await Promise.all([getMailExportMode(), downloadPromise])\n\t\tconst dataFiles: DataFile[] = []\n\t\tfor (const bundle of bundles) {\n\t\t\tif (!bundle) continue\n\n\t\t\tcheckAbortSignal()\n\t\t\tconst mailFile = await generateMailFile(\n\t\t\t\tbundle,\n\t\t\t\tgenerateExportFileName(elementIdPart(bundle.mailId), bundle.subject, new Date(bundle.receivedOn), mode),\n\t\t\t\tmode,\n\t\t\t)\n\t\t\tdataFiles.push(mailFile)\n\t\t\tupdateProgress()\n\t\t}\n\n\t\tconst zipName = `${sortableTimestamp()}-${mode}-mail-export.zip`\n\t\tconst outputFile = await (dataFiles.length === 1 ? dataFiles[0] : zipDataFiles(dataFiles, zipName))\n\t\tawait fileController.saveDataFile(outputFile)\n\n\t\treturn {\n\t\t\tfailed: errorMails,\n\t\t}\n\t} catch (e) {\n\t\tif (e.name !== \"CancelledError\") throw e\n\t} finally {\n\t\tsignal?.removeEventListener(\"abort\", onAbort)\n\t}\n\n\treturn { failed: [] }\n}\n","import {\n\tConversationEntryTypeRef,\n\tcreateMailAddress,\n\tEncryptedMailAddress,\n\tFile as TutanotaFile,\n\tMail,\n\tMailAddress,\n\tMailDetails,\n\tMailFolder,\n\tMailTypeRef,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport {\n\tConversationType,\n\tExternalImageRule,\n\tFeatureType,\n\tMailAuthenticationStatus,\n\tMailMethod,\n\tMailPhishingStatus,\n\tMailReportType,\n\tMailSetKind,\n\tMailState,\n\tOperationType,\n} from \"../../../common/api/common/TutanotaConstants\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport { MailboxDetail, MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { ContactModel } from \"../../../common/contactsFunctionality/ContactModel.js\"\nimport { ConfigurationDatabase } from \"../../../common/api/worker/facades/lazy/ConfigurationDatabase.js\"\nimport stream from \"mithril/stream\"\nimport {\n\taddAll,\n\tassertNonNull,\n\tcontains,\n\tdowncast,\n\tfilterInt,\n\tfirst,\n\tlazyAsync,\n\tnoOp,\n\tofClass,\n\tstartsWith,\n\tutf8Uint8ArrayToString,\n} from \"@tutao/tutanota-utils\"\nimport { lang } from \"../../../common/misc/LanguageViewModel\"\nimport { LoginController } from \"../../../common/api/main/LoginController\"\nimport m from \"mithril\"\nimport { LockedError, NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError\"\nimport { haveSameId, isSameId } from \"../../../common/api/common/utils/EntityUtils\"\nimport { getReferencedAttachments, isMailContrastFixNeeded, isTutanotaTeamMail, loadInlineImages, moveMails } from \"./MailGuiUtils\"\nimport { SanitizedFragment } from \"../../../common/misc/HtmlSanitizer\"\nimport { CALENDAR_MIME_TYPE, FileController } from \"../../../common/file/FileController\"\nimport { exportMails } from \"../export/Exporter.js\"\nimport { IndexingNotSupportedError } from \"../../../common/api/common/error/IndexingNotSupportedError\"\nimport { FileOpenError } from \"../../../common/api/common/error/FileOpenError\"\nimport { Dialog } from \"../../../common/gui/base/Dialog\"\nimport { checkApprovalStatus } from \"../../../common/misc/LoginUtils\"\nimport { formatDateTime, urlEncodeHtmlTags } from \"../../../common/misc/Formatter\"\nimport { UserError } from \"../../../common/api/main/UserError\"\nimport { showUserError } from \"../../../common/misc/ErrorHandlerImpl\"\nimport { LoadingStateTracker } from \"../../../common/offline/LoadingState\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError\"\nimport { InitAsResponseArgs, SendMailModel } from \"../../../common/mailFunctionality/SendMailModel.js\"\nimport { EventController } from \"../../../common/api/main/EventController.js\"\nimport { WorkerFacade } from \"../../../common/api/worker/facades/WorkerFacade.js\"\nimport { SearchModel } from \"../../search/model/SearchModel.js\"\nimport { ParsedIcalFileContent } from \"../../../calendar-app/calendar/view/CalendarInvites.js\"\nimport { MailFacade } from \"../../../common/api/worker/facades/lazy/MailFacade.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport { isOfflineError } from \"../../../common/api/common/utils/ErrorUtils.js\"\nimport { CryptoFacade } from \"../../../common/api/worker/crypto/CryptoFacade.js\"\nimport { AttachmentType, getAttachmentType } from \"../../../common/gui/AttachmentBubble.js\"\nimport type { ContactImporter } from \"../../contacts/ContactImporter.js\"\nimport { InlineImages, revokeInlineImages } from \"../../../common/mailFunctionality/inlineImagesUtils.js\"\nimport { getDefaultSender, getEnabledMailAddressesWithUser, getMailboxName } from \"../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { getDisplayedSender, getMailBodyText, MailAddressAndName } from \"../../../common/api/common/CommonMailUtils.js\"\nimport { MailModel } from \"../model/MailModel.js\"\nimport { isNoReplyTeamAddress, isSystemNotification, loadMailDetails } from \"./MailViewerUtils.js\"\nimport { assertSystemFolderOfType, getFolderName, getPathToFolderString, loadMailHeaders } from \"../model/MailUtils.js\"\nimport { mailLocator } from \"../../mailLocator.js\"\n\nexport const enum ContentBlockingStatus {\n\tBlock = \"0\",\n\tShow = \"1\",\n\tAlwaysShow = \"2\",\n\tNoExternalContent = \"3\",\n\tAlwaysBlock = \"4\",\n}\n\nexport class MailViewerViewModel {\n\tprivate contrastFixNeeded: boolean = false\n\t// always sanitized in this.sanitizeMailBody\n\n\tprivate sanitizeResult: SanitizedFragment | null = null\n\tprivate loadingAttachments: boolean = false\n\tprivate attachments: TutanotaFile[] = []\n\n\tprivate contentBlockingStatus: ContentBlockingStatus | null = null\n\n\tprivate errorOccurred: boolean = false\n\tprivate loadedInlineImages: InlineImages | null = null\n\t/** only loaded when showFolder is set to true */\n\tprivate folderMailboxText: string | null\n\n\t/** @see getRelevantRecipient */\n\tprivate relevantRecipient: MailAddress | null = null\n\tprivate warningDismissed: boolean = false\n\n\tprivate calendarEventAttachment: {\n\t\tcontents: ParsedIcalFileContent\n\t\trecipient: string\n\t} | null = null\n\n\tprivate readonly loadingState = new LoadingStateTracker()\n\n\tprivate renderIsDelayed: boolean = true\n\n\treadonly loadCompleteNotification = stream<null>()\n\n\tprivate renderedMail: Mail | null = null\n\tprivate loading: Promise<void> | null = null\n\n\tprivate collapsed: boolean = true\n\n\tget mail(): Mail {\n\t\treturn this._mail\n\t}\n\n\tprivate mailDetails: MailDetails | null = null\n\n\tconstructor(\n\t\tprivate _mail: Mail,\n\t\tshowFolder: boolean,\n\t\treadonly entityClient: EntityClient,\n\t\tpublic readonly mailboxModel: MailboxModel,\n\t\tpublic readonly mailModel: MailModel,\n\t\treadonly contactModel: ContactModel,\n\t\tprivate readonly configFacade: ConfigurationDatabase,\n\t\tprivate readonly fileController: FileController,\n\t\treadonly logins: LoginController,\n\t\tprivate sendMailModelFactory: (mailboxDetails: MailboxDetail) => Promise<SendMailModel>,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly workerFacade: WorkerFacade,\n\t\tprivate readonly searchModel: SearchModel,\n\t\tprivate readonly mailFacade: MailFacade,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly contactImporter: lazyAsync<ContactImporter>,\n\t) {\n\t\tthis.folderMailboxText = null\n\t\tif (showFolder) {\n\t\t\tthis.showFolder()\n\t\t}\n\t\tthis.eventController.addEntityListener(this.entityListener)\n\t}\n\n\tprivate readonly entityListener = async (events: EntityUpdateData[]) => {\n\t\tfor (const update of events) {\n\t\t\tif (isUpdateForTypeRef(MailTypeRef, update)) {\n\t\t\t\tconst { instanceListId, instanceId, operation } = update\n\t\t\t\tif (operation === OperationType.UPDATE && isSameId(this.mail._id, [instanceListId, instanceId])) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst updatedMail = await this.entityClient.load(MailTypeRef, this.mail._id)\n\t\t\t\t\t\tthis.updateMail({ mail: updatedMail })\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\t\tconsole.log(`Could not find updated mail ${JSON.stringify([instanceListId, instanceId])}`)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async determineRelevantRecipient() {\n\t\t// The idea is that if there are multiple recipients then we should display the one which belongs to one of our mailboxes and then fall back to any\n\t\t// other one\n\t\tconst mailboxDetails = await this.mailModel.getMailboxDetailsForMail(this.mail)\n\t\tif (mailboxDetails == null) {\n\t\t\treturn\n\t\t}\n\t\tconst enabledMailAddresses = new Set(getEnabledMailAddressesWithUser(mailboxDetails, this.logins.getUserController().userGroupInfo))\n\t\tif (this.mailDetails == null) {\n\t\t\t// we could not load the mailDetails for some reason\n\t\t\treturn\n\t\t}\n\t\tthis.relevantRecipient =\n\t\t\tthis.mailDetails.recipients.toRecipients.find((r) => enabledMailAddresses.has(r.address)) ??\n\t\t\tthis.mailDetails.recipients.ccRecipients.find((r) => enabledMailAddresses.has(r.address)) ??\n\t\t\tthis.mailDetails.recipients.bccRecipients.find((r) => enabledMailAddresses.has(r.address)) ??\n\t\t\tfirst(this.mailDetails.recipients.toRecipients) ??\n\t\t\tfirst(this.mailDetails.recipients.ccRecipients) ??\n\t\t\tfirst(this.mailDetails.recipients.bccRecipients)\n\t\tm.redraw()\n\t}\n\n\tprivate showFolder() {\n\t\tthis.folderMailboxText = null\n\t\tconst folder = this.mailModel.getMailFolderForMail(this.mail)\n\n\t\tif (folder) {\n\t\t\tthis.mailModel.getMailboxDetailsForMail(this.mail).then(async (mailboxDetails) => {\n\t\t\t\tif (mailboxDetails == null || mailboxDetails.mailbox.folders == null) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst folders = await this.mailModel.getMailboxFoldersForId(mailboxDetails.mailbox.folders._id)\n\t\t\t\tconst name = getPathToFolderString(folders, folder)\n\t\t\t\tthis.folderMailboxText = `${getMailboxName(this.logins, mailboxDetails)} / ${name}`\n\t\t\t\tm.redraw()\n\t\t\t})\n\t\t}\n\t}\n\n\tdispose() {\n\t\t// currently, the conversation view disposes us twice if our mail is deleted because it's getting disposed itself\n\t\t// (from the list selecting a different element) and because it disposes the mailViewerViewModel that got updated\n\t\t// this silences the warning about leaking entity event listeners when the listener is removed twice.\n\t\tthis.dispose = () => console.log(\"disposed MailViewerViewModel a second time, ignoring\")\n\t\tthis.eventController.removeEntityListener(this.entityListener)\n\t\tconst inlineImages = this.getLoadedInlineImages()\n\t\trevokeInlineImages(inlineImages)\n\t}\n\n\tasync loadAll(\n\t\tdelay: Promise<unknown>,\n\t\t{\n\t\t\tnotify,\n\t\t}: {\n\t\t\tnotify: boolean\n\t\t} = { notify: true },\n\t) {\n\t\tthis.renderIsDelayed = true\n\t\ttry {\n\t\t\tawait this.loading\n\t\t\ttry {\n\t\t\t\tthis.loading = this.loadAndProcessAdditionalMailInfo(this.mail, delay)\n\t\t\t\t\t.then((inlineImageCids) => {\n\t\t\t\t\t\tthis.determineRelevantRecipient()\n\t\t\t\t\t\treturn inlineImageCids\n\t\t\t\t\t})\n\t\t\t\t\t.then((inlineImageCids) => this.loadAttachments(this.mail, inlineImageCids))\n\t\t\t\tawait this.loadingState.trackPromise(this.loading)\n\n\t\t\t\tif (notify) this.loadCompleteNotification(null)\n\t\t\t} catch (e) {\n\t\t\t\tthis.loading = null\n\n\t\t\t\tif (!isOfflineError(e)) {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm.redraw()\n\n\t\t\t// We need the conversation entry in order to reply to the message.\n\t\t\t// We don't want the user to have to wait for it to load when they click reply,\n\t\t\t// So we load it here pre-emptively to make sure it is in the cache.\n\t\t\tthis.entityClient.load(ConversationEntryTypeRef, this.mail.conversationEntry).catch((e) => {\n\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\tconsole.log(\"could load conversation entry as it has been moved/deleted already\", e)\n\t\t\t\t} else if (isOfflineError(e)) {\n\t\t\t\t\tconsole.log(\"failed to load conversation entry, because of a lost connection\", e)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t})\n\t\t} finally {\n\t\t\tthis.renderIsDelayed = false\n\t\t}\n\t}\n\n\tisLoading(): boolean {\n\t\treturn this.loadingState.isLoading()\n\t}\n\n\tisConnectionLost(): boolean {\n\t\treturn this.loadingState.isConnectionLost()\n\t}\n\n\tgetAttachments(): Array<TutanotaFile> {\n\t\treturn this.attachments\n\t}\n\n\tgetInlineCids(): Array<string> {\n\t\treturn this.sanitizeResult?.inlineImageCids ?? []\n\t}\n\n\tgetLoadedInlineImages(): InlineImages {\n\t\treturn this.loadedInlineImages ?? new Map()\n\t}\n\n\tisContrastFixNeeded(): boolean {\n\t\treturn this.contrastFixNeeded\n\t}\n\n\tisDraftMail() {\n\t\treturn this.mail.state === MailState.DRAFT\n\t}\n\n\tisReceivedMail() {\n\t\treturn this.mail.state === MailState.RECEIVED\n\t}\n\n\tisLoadingAttachments(): boolean {\n\t\treturn this.loadingAttachments\n\t}\n\n\tgetFolderMailboxText(): string | null {\n\t\treturn this.folderMailboxText\n\t}\n\n\tgetFolderInfo(): { folderType: MailSetKind; name: string } | null {\n\t\tconst folder = this.mailModel.getMailFolderForMail(this.mail)\n\t\tif (!folder) return null\n\t\treturn { folderType: folder.folderType as MailSetKind, name: getFolderName(folder) }\n\t}\n\n\tgetSubject(): string {\n\t\treturn this.mail.subject\n\t}\n\n\tisConfidential(): boolean {\n\t\treturn this.mail.confidential\n\t}\n\n\tisMailSuspicious(): boolean {\n\t\treturn this.mail.phishingStatus === MailPhishingStatus.SUSPICIOUS\n\t}\n\n\tgetMailId(): IdTuple {\n\t\treturn this.mail._id\n\t}\n\n\tgetSanitizedMailBody(): DocumentFragment | null {\n\t\treturn this.sanitizeResult?.fragment ?? null\n\t}\n\n\tgetMailBody(): string {\n\t\tif (this.mailDetails) {\n\t\t\treturn getMailBodyText(this.mailDetails.body)\n\t\t} else {\n\t\t\treturn \"\"\n\t\t}\n\t}\n\n\tgetDate(): Date {\n\t\treturn this.mail.receivedDate\n\t}\n\n\tgetToRecipients(): Array<MailAddress> {\n\t\tif (this.mailDetails === null) {\n\t\t\treturn []\n\t\t}\n\t\treturn this.mailDetails.recipients.toRecipients\n\t}\n\n\tgetCcRecipients(): Array<MailAddress> {\n\t\tif (this.mailDetails === null) {\n\t\t\treturn []\n\t\t}\n\t\treturn this.mailDetails.recipients.ccRecipients\n\t}\n\n\tgetBccRecipients(): Array<MailAddress> {\n\t\tif (this.mailDetails === null) {\n\t\t\treturn []\n\t\t}\n\t\treturn this.mailDetails.recipients.bccRecipients\n\t}\n\n\t/** Get the recipient which is relevant the most for the current mailboxes. */\n\tgetRelevantRecipient(): MailAddress | null {\n\t\treturn this.relevantRecipient\n\t}\n\n\tgetNumberOfRecipients(): number {\n\t\treturn filterInt(this.mail.recipientCount)\n\t}\n\n\tgetReplyTos(): Array<EncryptedMailAddress> {\n\t\tif (this.mailDetails === null) {\n\t\t\treturn []\n\t\t}\n\t\treturn this.mailDetails.replyTos\n\t}\n\n\tgetSender(): MailAddress {\n\t\treturn this.mail.sender\n\t}\n\n\t/**\n\t * Can be {@code null} if sender should not be displayed e.g. for system notifications.\n\t */\n\tgetDisplayedSender(): MailAddressAndName | null {\n\t\tif (isSystemNotification(this.mail)) {\n\t\t\treturn null\n\t\t} else {\n\t\t\treturn getDisplayedSender(this.mail)\n\t\t}\n\t}\n\n\tgetPhishingStatus(): MailPhishingStatus {\n\t\treturn this.mail.phishingStatus as MailPhishingStatus\n\t}\n\n\tsetPhishingStatus(status: MailPhishingStatus) {\n\t\tthis.mail.phishingStatus = status\n\t}\n\n\tcheckMailAuthenticationStatus(status: MailAuthenticationStatus): boolean {\n\t\tif (this.mail.authStatus != null) {\n\t\t\treturn this.mail.authStatus === status\n\t\t} else if (this.mailDetails) {\n\t\t\treturn this.mailDetails.authStatus === status\n\t\t} else {\n\t\t\t// mailDetails not loaded yet\n\t\t\treturn false\n\t\t}\n\t}\n\n\tcanCreateSpamRule(): boolean {\n\t\treturn this.logins.isGlobalAdminUserLoggedIn() && !this.logins.isEnabled(FeatureType.InternalCommunication)\n\t}\n\n\tdidErrorsOccur(): boolean {\n\t\tlet bodyErrors = false\n\t\tif (this.mailDetails) {\n\t\t\tbodyErrors = typeof downcast(this.mailDetails.body)._errors !== \"undefined\"\n\t\t}\n\t\treturn this.errorOccurred || typeof this.mail._errors !== \"undefined\" || bodyErrors\n\t}\n\n\tisTutanotaTeamMail(): boolean {\n\t\treturn isTutanotaTeamMail(this.mail)\n\t}\n\n\tisShowingExternalContent(): boolean {\n\t\treturn this.contentBlockingStatus === ContentBlockingStatus.Show || this.contentBlockingStatus === ContentBlockingStatus.AlwaysShow\n\t}\n\n\tisBlockingExternalImages(): boolean {\n\t\treturn this.contentBlockingStatus === ContentBlockingStatus.Block || this.contentBlockingStatus === ContentBlockingStatus.AlwaysBlock\n\t}\n\n\tgetDifferentEnvelopeSender(): string | null {\n\t\treturn this.mail.differentEnvelopeSender\n\t}\n\n\tgetCalendarEventAttachment(): MailViewerViewModel[\"calendarEventAttachment\"] {\n\t\treturn this.calendarEventAttachment\n\t}\n\n\tgetContentBlockingStatus(): ContentBlockingStatus | null {\n\t\treturn this.contentBlockingStatus\n\t}\n\n\tisWarningDismissed() {\n\t\treturn this.warningDismissed\n\t}\n\n\tsetWarningDismissed(dismissed: boolean) {\n\t\tthis.warningDismissed = dismissed\n\t}\n\n\tasync setContentBlockingStatus(status: ContentBlockingStatus): Promise<void> {\n\t\t// We can only be set to NoExternalContent when initially loading the mailbody (_loadMailBody)\n\t\t// so we ignore it here, and don't do anything if we were already set to NoExternalContent\n\t\tif (\n\t\t\tstatus === ContentBlockingStatus.NoExternalContent ||\n\t\t\tthis.contentBlockingStatus === ContentBlockingStatus.NoExternalContent ||\n\t\t\tthis.contentBlockingStatus === status\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tif (status === ContentBlockingStatus.AlwaysShow) {\n\t\t\tthis.configFacade.addExternalImageRule(this.getSender().address, ExternalImageRule.Allow).catch(ofClass(IndexingNotSupportedError, noOp))\n\t\t} else if (status === ContentBlockingStatus.AlwaysBlock) {\n\t\t\tthis.configFacade.addExternalImageRule(this.getSender().address, ExternalImageRule.Block).catch(ofClass(IndexingNotSupportedError, noOp))\n\t\t} else {\n\t\t\t// we are going from allow or block to something else it means we're resetting to the default rule for the given sender\n\t\t\tthis.configFacade.addExternalImageRule(this.getSender().address, ExternalImageRule.None).catch(ofClass(IndexingNotSupportedError, noOp))\n\t\t}\n\n\t\t// We don't check mail authentication status here because the user has manually called this\n\t\tthis.sanitizeResult = await this.sanitizeMailBody(this.mail, status === ContentBlockingStatus.Block || status === ContentBlockingStatus.AlwaysBlock)\n\t\t//follow-up actions resulting from a changed blocking status must start after sanitization finished\n\t\tthis.contentBlockingStatus = status\n\t}\n\n\tasync markAsNotPhishing(): Promise<void> {\n\t\tconst oldStatus = this.getPhishingStatus()\n\n\t\tif (oldStatus === MailPhishingStatus.WHITELISTED) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.setPhishingStatus(MailPhishingStatus.WHITELISTED)\n\n\t\tawait this.entityClient.update(this.mail).catch(() => this.setPhishingStatus(oldStatus))\n\t}\n\n\tasync reportMail(reportType: MailReportType): Promise<void> {\n\t\ttry {\n\t\t\tawait this.mailModel.reportMails(reportType, [this.mail])\n\t\t\tif (reportType === MailReportType.PHISHING) {\n\t\t\t\tthis.setPhishingStatus(MailPhishingStatus.SUSPICIOUS)\n\t\t\t\tawait this.entityClient.update(this.mail)\n\t\t\t}\n\t\t\tconst mailboxDetail = await this.mailModel.getMailboxDetailsForMail(this.mail)\n\t\t\tif (mailboxDetail == null || mailboxDetail.mailbox.folders == null) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id)\n\t\t\tconst spamFolder = assertSystemFolderOfType(folders, MailSetKind.SPAM)\n\t\t\t// do not report moved mails again\n\t\t\tawait moveMails({\n\t\t\t\tmailboxModel: this.mailboxModel,\n\t\t\t\tmailModel: this.mailModel,\n\t\t\t\tmails: [this.mail],\n\t\t\t\ttargetMailFolder: spamFolder,\n\t\t\t\tisReportable: false,\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\tconsole.log(\"mail already moved\")\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tcanExport(): boolean {\n\t\treturn !this.isAnnouncement() && !this.logins.isEnabled(FeatureType.DisableMailExport)\n\t}\n\n\tcanPrint(): boolean {\n\t\treturn !this.logins.isEnabled(FeatureType.DisableMailExport)\n\t}\n\n\tcanReport(): boolean {\n\t\treturn this.getPhishingStatus() === MailPhishingStatus.UNKNOWN && !this.isTutanotaTeamMail() && this.logins.isInternalUserLoggedIn()\n\t}\n\n\tcanShowHeaders(): boolean {\n\t\treturn this.logins.isInternalUserLoggedIn()\n\t}\n\n\tcanPersistBlockingStatus(): boolean {\n\t\treturn this.searchModel.indexingSupported\n\t}\n\n\tasync exportMail(): Promise<void> {\n\t\tawait exportMails([this.mail], this.mailFacade, this.entityClient, this.fileController, this.cryptoFacade)\n\t}\n\n\tasync getHeaders(): Promise<string | null> {\n\t\t// make sure that the mailDetails are loaded\n\t\tconst mailDetails = await loadMailDetails(this.mailFacade, this.mail)\n\t\treturn loadMailHeaders(mailDetails)\n\t}\n\n\tisUnread(): boolean {\n\t\treturn this.mail.unread\n\t}\n\n\tasync setUnread(unread: boolean) {\n\t\tif (this.mail.unread !== unread) {\n\t\t\tthis.mail.unread = unread\n\n\t\t\tawait this.entityClient\n\t\t\t\t.update(this.mail)\n\t\t\t\t.catch(ofClass(LockedError, () => console.log(\"could not update mail read state: \", lang.get(\"operationStillActive_msg\"))))\n\t\t\t\t.catch(ofClass(NotFoundError, noOp))\n\t\t}\n\t}\n\n\tisListUnsubscribe(): boolean {\n\t\treturn this.mail.listUnsubscribe\n\t}\n\n\tisAnnouncement(): boolean {\n\t\tconst replyTos = this.mailDetails?.replyTos\n\t\treturn (\n\t\t\tisSystemNotification(this.mail) &&\n\t\t\t// hide the actions until mailDetails are loaded rather than showing them quickly and then hiding them\n\t\t\t(replyTos == null || replyTos?.length === 0 || (replyTos?.length === 1 && isNoReplyTeamAddress(replyTos[0].address)))\n\t\t)\n\t}\n\n\tasync unsubscribe(): Promise<boolean> {\n\t\tif (!this.isListUnsubscribe()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst mailHeaders = await this.getHeaders()\n\t\tif (!mailHeaders) {\n\t\t\treturn false\n\t\t}\n\t\tconst unsubHeaders = mailHeaders\n\t\t\t.replaceAll(/\\r\\n/g, \"\\n\") // replace all CR LF with LF\n\t\t\t.replaceAll(/\\n[ \\t]/g, \"\") // join multiline headers to a single line\n\t\t\t.split(\"\\n\") // split headers\n\t\t\t.filter((headerLine) => headerLine.toLowerCase().startsWith(\"list-unsubscribe\"))\n\t\tif (unsubHeaders.length > 0) {\n\t\t\tconst recipient = await this.getSenderOfResponseMail()\n\t\t\tawait this.mailModel.unsubscribe(this.mail, recipient, unsubHeaders)\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tprivate getMailboxDetails(): Promise<MailboxDetail | null> {\n\t\treturn this.mailModel.getMailboxDetailsForMail(this.mail)\n\t}\n\n\t/** @return list of inline referenced cid */\n\tprivate async loadAndProcessAdditionalMailInfo(mail: Mail, delayBodyRenderingUntil: Promise<unknown>): Promise<string[]> {\n\t\t// If the mail is a non-draft and we have loaded it before, we don't need to reload it because it cannot have been edited, so we return early\n\t\t// drafts however can be edited, and we want to receive the changes, so for drafts we will always reload\n\t\tlet isDraft = mail.state === MailState.DRAFT\n\t\tif (this.renderedMail != null && haveSameId(mail, this.renderedMail) && !isDraft && this.sanitizeResult != null) {\n\t\t\treturn this.sanitizeResult.inlineImageCids\n\t\t}\n\n\t\ttry {\n\t\t\tthis.mailDetails = await loadMailDetails(this.mailFacade, this.mail)\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\tconsole.log(\"could load mail body as it has been moved/deleted already\", e)\n\t\t\t\tthis.errorOccurred = true\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\tconsole.log(\"could load mail body as the permission is missing\", e)\n\t\t\t\tthis.errorOccurred = true\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\tthrow e\n\t\t}\n\n\t\tconst externalImageRule = await this.configFacade.getExternalImageRule(mail.sender.address).catch((e) => {\n\t\t\tconsole.log(\"Error getting external image rule:\", e)\n\t\t\treturn ExternalImageRule.None\n\t\t})\n\t\tconst isAllowedAndAuthenticatedExternalSender =\n\t\t\texternalImageRule === ExternalImageRule.Allow && this.checkMailAuthenticationStatus(MailAuthenticationStatus.AUTHENTICATED)\n\t\t// We should not try to sanitize body while we still animate because it's a heavy operation.\n\t\tawait delayBodyRenderingUntil\n\t\tthis.renderIsDelayed = false\n\n\t\tthis.sanitizeResult = await this.sanitizeMailBody(mail, !isAllowedAndAuthenticatedExternalSender)\n\n\t\tif (!isDraft) {\n\t\t\tthis.checkMailForPhishing(mail, this.sanitizeResult.links)\n\t\t}\n\n\t\tthis.contentBlockingStatus =\n\t\t\texternalImageRule === ExternalImageRule.Block\n\t\t\t\t? ContentBlockingStatus.AlwaysBlock\n\t\t\t\t: isAllowedAndAuthenticatedExternalSender\n\t\t\t\t? ContentBlockingStatus.AlwaysShow\n\t\t\t\t: this.sanitizeResult.blockedExternalContent > 0\n\t\t\t\t? ContentBlockingStatus.Block\n\t\t\t\t: ContentBlockingStatus.NoExternalContent\n\t\tm.redraw()\n\t\tthis.renderedMail = this.mail\n\t\treturn this.sanitizeResult.inlineImageCids\n\t}\n\n\tprivate async loadAttachments(mail: Mail, inlineCids: string[]): Promise<void> {\n\t\tif (mail.attachments.length === 0) {\n\t\t\tthis.loadingAttachments = false\n\t\t\tm.redraw()\n\t\t} else {\n\t\t\tthis.loadingAttachments = true\n\n\t\t\ttry {\n\t\t\t\tconst files = await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, await this.mailFacade.loadAttachments(mail))\n\n\t\t\t\tthis.handleCalendarFile(files, mail)\n\n\t\t\t\tthis.attachments = files\n\t\t\t\tthis.loadingAttachments = false\n\t\t\t\tm.redraw()\n\n\t\t\t\t// We can load any other part again because they are cached but inline images are fileData e.g. binary blobs so we don't cache them like\n\t\t\t\t// entities. So instead we check here whether we need to load them.\n\t\t\t\tif (this.loadedInlineImages == null) {\n\t\t\t\t\tthis.loadedInlineImages = await loadInlineImages(this.fileController, files, inlineCids)\n\t\t\t\t}\n\t\t\t\tm.redraw()\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\tconsole.log(\"could load attachments as they have been moved/deleted already\", e)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate checkMailForPhishing(mail: Mail, links: Array<HTMLElement>) {\n\t\tif (mail.phishingStatus === MailPhishingStatus.UNKNOWN) {\n\t\t\tconst linkObjects = links.map((link) => {\n\t\t\t\treturn {\n\t\t\t\t\thref: link.getAttribute(\"href\") || \"\",\n\t\t\t\t\tinnerHTML: link.innerHTML,\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis.mailModel.checkMailForPhishing(mail, linkObjects).then((isSuspicious) => {\n\t\t\t\tif (isSuspicious) {\n\t\t\t\t\tmail.phishingStatus = MailPhishingStatus.SUSPICIOUS\n\n\t\t\t\t\tthis.entityClient\n\t\t\t\t\t\t.update(mail)\n\t\t\t\t\t\t.catch(ofClass(LockedError, (e) => console.log(\"could not update mail phishing status as mail is locked\")))\n\t\t\t\t\t\t.catch(ofClass(NotFoundError, (e) => console.log(\"mail already moved\")))\n\n\t\t\t\t\tm.redraw()\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Check if the list of files contain an iCal file which we can then load and display details for. A calendar notification\n\t * should contain only one iCal attachment, so we only process the first matching one.\n\t *\n\t * (this is not true for ie google calendar, they send the invite twice in each mail, but it's always the same file twice)\n\t */\n\tprivate handleCalendarFile(files: Array<TutanotaFile>, mail: Mail): void {\n\t\tconst calendarFile = files.find((a) => a.mimeType && a.mimeType.startsWith(CALENDAR_MIME_TYPE))\n\n\t\tif (calendarFile && (mail.method === MailMethod.ICAL_REQUEST || mail.method === MailMethod.ICAL_REPLY) && mail.state === MailState.RECEIVED) {\n\t\t\tPromise.all([\n\t\t\t\timport(\"../../../calendar-app/calendar/view/CalendarInvites.js\").then(({ getEventsFromFile }) =>\n\t\t\t\t\tgetEventsFromFile(calendarFile, mail.confidential),\n\t\t\t\t),\n\t\t\t\tthis.getSenderOfResponseMail(),\n\t\t\t]).then(([contents, recipient]) => {\n\t\t\t\tthis.calendarEventAttachment =\n\t\t\t\t\tcontents != null\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tcontents,\n\t\t\t\t\t\t\t\trecipient,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: null\n\t\t\t\tm.redraw()\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate getSenderOfResponseMail(): Promise<string> {\n\t\treturn this.mailModel.getMailboxDetailsForMail(this.mail).then(async (mailboxDetails) => {\n\t\t\tassertNonNull(mailboxDetails, \"Mail list does not exist anymore\")\n\t\t\tconst myMailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, this.logins.getUserController().userGroupInfo)\n\t\t\tconst addressesInMail: MailAddress[] = []\n\t\t\tconst mailDetails = await loadMailDetails(this.mailFacade, this.mail)\n\t\t\taddressesInMail.push(...mailDetails.recipients.toRecipients)\n\t\t\taddressesInMail.push(...mailDetails.recipients.ccRecipients)\n\t\t\taddressesInMail.push(...mailDetails.recipients.bccRecipients)\n\n\t\t\tconst mailAddressAndName = this.getDisplayedSender()\n\t\t\tif (mailAddressAndName) {\n\t\t\t\taddressesInMail.push(\n\t\t\t\t\tcreateMailAddress({\n\t\t\t\t\t\tname: mailAddressAndName.name,\n\t\t\t\t\t\taddress: mailAddressAndName.address,\n\t\t\t\t\t\tcontact: null,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t}\n\t\t\tconst foundAddress = addressesInMail.find((address) => contains(myMailAddresses, address.address.toLowerCase()))\n\t\t\tif (foundAddress) {\n\t\t\t\treturn foundAddress.address.toLowerCase()\n\t\t\t} else {\n\t\t\t\treturn getDefaultSender(this.logins, mailboxDetails)\n\t\t\t}\n\t\t})\n\t}\n\n\t/** @throws UserError */\n\tasync forward(): Promise<void> {\n\t\tconst sendAllowed = await checkApprovalStatus(this.logins, false)\n\t\tif (sendAllowed) {\n\t\t\tconst args = await this.createResponseMailArgsForForwarding([], [], true)\n\t\t\tconst [mailboxDetails, { newMailEditorAsResponse }] = await Promise.all([this.getMailboxDetails(), import(\"../editor/MailEditor\")])\n\t\t\tif (mailboxDetails == null) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst isReloadNeeded = !this.sanitizeResult || this.mail.attachments.length !== this.attachments.length\n\t\t\tif (isReloadNeeded) {\n\t\t\t\t// Call this again to make sure everything is loaded, including inline images because this can be called earlier than all the parts are loaded.\n\t\t\t\tawait this.loadAll(Promise.resolve(), { notify: true })\n\t\t\t}\n\t\t\tconst editor = await newMailEditorAsResponse(args, this.isBlockingExternalImages(), this.getLoadedInlineImages(), mailboxDetails)\n\t\t\teditor.show()\n\t\t}\n\t}\n\n\tprivate async createResponseMailArgsForForwarding(\n\t\trecipients: MailAddress[],\n\t\treplyTos: EncryptedMailAddress[],\n\t\taddSignature: boolean,\n\t): Promise<InitAsResponseArgs> {\n\t\tlet infoLine = lang.get(\"date_label\") + \": \" + formatDateTime(this.mail.receivedDate) + \"<br>\"\n\t\tconst senderAddress = this.getDisplayedSender()?.address\n\t\tif (senderAddress) {\n\t\t\tinfoLine += lang.get(\"from_label\") + \": \" + senderAddress + \"<br>\"\n\t\t}\n\n\t\tif (this.getToRecipients().length > 0) {\n\t\t\tinfoLine +=\n\t\t\t\tlang.get(\"to_label\") +\n\t\t\t\t\": \" +\n\t\t\t\tthis.getToRecipients()\n\t\t\t\t\t.map((recipient) => recipient.address)\n\t\t\t\t\t.join(\", \")\n\t\t\tinfoLine += \"<br>\"\n\t\t}\n\n\t\tif (this.getCcRecipients().length > 0) {\n\t\t\tinfoLine +=\n\t\t\t\tlang.get(\"cc_label\") +\n\t\t\t\t\": \" +\n\t\t\t\tthis.getCcRecipients()\n\t\t\t\t\t.map((recipient) => recipient.address)\n\t\t\t\t\t.join(\", \")\n\t\t\tinfoLine += \"<br>\"\n\t\t}\n\n\t\tconst mailSubject = this.getSubject() || \"\"\n\t\tinfoLine += lang.get(\"subject_label\") + \": \" + urlEncodeHtmlTags(mailSubject)\n\t\tlet body = infoLine + '<br><br><blockquote class=\"tutanota_quote\">' + this.getMailBody() + \"</blockquote>\"\n\t\tconst { prependEmailSignature } = await import(\"../signature/Signature\")\n\t\tconst senderMailAddress = await this.getSenderOfResponseMail()\n\t\treturn {\n\t\t\tpreviousMail: this.mail,\n\t\t\tconversationType: ConversationType.FORWARD,\n\t\t\tsenderMailAddress,\n\t\t\trecipients,\n\t\t\tattachments: this.attachments.slice(),\n\t\t\tsubject: \"FWD: \" + mailSubject,\n\t\t\tbodyText: addSignature ? prependEmailSignature(body, this.logins) : body,\n\t\t\treplyTos,\n\t\t}\n\t}\n\n\tasync reply(replyAll: boolean): Promise<void> {\n\t\tif (this.isAnnouncement()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst sendAllowed = await checkApprovalStatus(this.logins, false)\n\n\t\tif (sendAllowed) {\n\t\t\tconst mailboxDetails = await this.mailModel.getMailboxDetailsForMail(this.mail)\n\t\t\tif (mailboxDetails == null) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// We already know it is not an announcement email and we want to get the sender even if it\n\t\t\t// is hidden. It will be replaced with replyTo() anyway\n\t\t\tconst mailAddressAndName = getDisplayedSender(this.mail)\n\t\t\tconst sender = createMailAddress({\n\t\t\t\tname: mailAddressAndName.name,\n\t\t\t\taddress: mailAddressAndName.address,\n\t\t\t\tcontact: null,\n\t\t\t})\n\t\t\tlet prefix = \"Re: \"\n\t\t\tconst mailSubject = this.getSubject()\n\t\t\tlet subject = mailSubject ? (startsWith(mailSubject.toUpperCase(), prefix.toUpperCase()) ? mailSubject : prefix + mailSubject) : \"\"\n\t\t\tlet infoLine = formatDateTime(this.getDate()) + \" \" + lang.get(\"by_label\") + \" \" + sender.address + \":\"\n\t\t\tlet body = infoLine + '<br><blockquote class=\"tutanota_quote\">' + this.getMailBody() + \"</blockquote>\"\n\t\t\tlet toRecipients: MailAddress[] = []\n\t\t\tlet ccRecipients: MailAddress[] = []\n\t\t\tlet bccRecipients: MailAddress[] = []\n\n\t\t\tif (!this.logins.getUserController().isInternalUser() && this.isReceivedMail()) {\n\t\t\t\ttoRecipients.push(sender)\n\t\t\t} else if (this.isReceivedMail()) {\n\t\t\t\tif (this.getReplyTos().some((address) => !downcast(address)._errors)) {\n\t\t\t\t\taddAll(toRecipients, this.getReplyTos())\n\t\t\t\t} else {\n\t\t\t\t\ttoRecipients.push(sender)\n\t\t\t\t}\n\n\t\t\t\tif (replyAll) {\n\t\t\t\t\tlet myMailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, this.logins.getUserController().userGroupInfo)\n\t\t\t\t\taddAll(\n\t\t\t\t\t\tccRecipients,\n\t\t\t\t\t\tthis.getToRecipients().filter((recipient) => !contains(myMailAddresses, recipient.address.toLowerCase())),\n\t\t\t\t\t)\n\t\t\t\t\taddAll(\n\t\t\t\t\t\tccRecipients,\n\t\t\t\t\t\tthis.getCcRecipients().filter((recipient) => !contains(myMailAddresses, recipient.address.toLowerCase())),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// this is a sent email, so use the to recipients as new recipients\n\t\t\t\taddAll(toRecipients, this.getToRecipients())\n\n\t\t\t\tif (replyAll) {\n\t\t\t\t\taddAll(ccRecipients, this.getCcRecipients())\n\t\t\t\t\taddAll(bccRecipients, this.getBccRecipients())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst { prependEmailSignature } = await import(\"../signature/Signature.js\")\n\t\t\tconst { newMailEditorAsResponse } = await import(\"../editor/MailEditor\")\n\n\t\t\tconst isReloadNeeded = !this.sanitizeResult || this.mail.attachments.length !== this.attachments.length\n\t\t\tif (isReloadNeeded) {\n\t\t\t\tawait this.loadAll(Promise.resolve(), { notify: true })\n\t\t\t}\n\t\t\t// It should be there after loadAll() but if not we just give up\n\t\t\tconst inlineImageCids = this.sanitizeResult?.inlineImageCids ?? []\n\n\t\t\tconst [senderMailAddress, referencedCids] = await Promise.all([this.getSenderOfResponseMail(), inlineImageCids])\n\n\t\t\tconst attachmentsForReply = getReferencedAttachments(this.attachments, referencedCids)\n\t\t\ttry {\n\t\t\t\tconst editor = await newMailEditorAsResponse(\n\t\t\t\t\t{\n\t\t\t\t\t\tpreviousMail: this.mail,\n\t\t\t\t\t\tconversationType: ConversationType.REPLY,\n\t\t\t\t\t\tsenderMailAddress,\n\t\t\t\t\t\trecipients: {\n\t\t\t\t\t\t\tto: toRecipients,\n\t\t\t\t\t\t\tcc: ccRecipients,\n\t\t\t\t\t\t\tbcc: bccRecipients,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tattachments: attachmentsForReply,\n\t\t\t\t\t\tsubject,\n\t\t\t\t\t\tbodyText: prependEmailSignature(body, this.logins),\n\t\t\t\t\t\treplyTos: [],\n\t\t\t\t\t},\n\t\t\t\t\tthis.isBlockingExternalImages() || !this.isShowingExternalContent(),\n\t\t\t\t\tthis.getLoadedInlineImages(),\n\t\t\t\t\tmailboxDetails,\n\t\t\t\t)\n\t\t\t\teditor.show()\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof UserError) {\n\t\t\t\t\tshowUserError(e)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sanitizeMailBody(mail: Mail, blockExternalContent: boolean): Promise<SanitizedFragment> {\n\t\tconst { htmlSanitizer } = await import(\"../../../common/misc/HtmlSanitizer\")\n\t\tconst rawBody = this.getMailBody()\n\t\t// Keeping this commented out because we want see the response\n\t\t// const urlified = await this.workerFacade.urlify(rawBody).catch((e) => {\n\t\t// \tconsole.warn(\"Failed to urlify mail body!\", e)\n\t\t// \treturn rawBody\n\t\t// })\n\t\tconst sanitizeResult = htmlSanitizer.sanitizeFragment(rawBody, {\n\t\t\tblockExternalContent,\n\t\t\tallowRelativeLinks: isTutanotaTeamMail(mail),\n\t\t})\n\t\tconst { fragment, inlineImageCids, links, blockedExternalContent } = sanitizeResult\n\n\t\t/**\n\t\t * Check if we need to improve contrast for dark theme. We apply the contrast fix if any of the following is contained in\n\t\t * the html body of the mail\n\t\t *  * any tag with a style attribute that has the color property set (besides \"inherit\")\n\t\t *  * any tag with a style attribute that has the background-color set (besides \"inherit\")\n\t\t *  * any font tag with the color attribute set\n\t\t */\n\t\tthis.contrastFixNeeded = isMailContrastFixNeeded(fragment)\n\n\t\tm.redraw()\n\t\treturn {\n\t\t\t// We want to stringify and return the fragment here, because once a fragment is appended to a DOM Node, it's children are moved\n\t\t\t// and the fragment is left empty. If we cache the fragment and then append that directly to the DOM tree when rendering, there are cases where\n\t\t\t// we would try to do so twice, and on the second pass the mail body will be left blank\n\t\t\tfragment,\n\t\t\tinlineImageCids,\n\t\t\tlinks,\n\t\t\tblockedExternalContent,\n\t\t}\n\t}\n\n\tgetNonInlineAttachments(): TutanotaFile[] {\n\t\t// If we have attachments it is safe to assume that we already have body and referenced cids from it\n\t\tconst inlineFileIds = this.sanitizeResult?.inlineImageCids ?? []\n\t\treturn this.attachments.filter((a) => a.cid == null || !inlineFileIds.includes(a.cid))\n\t}\n\n\tasync downloadAll(): Promise<void> {\n\t\tconst nonInlineAttachments = await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, this.getNonInlineAttachments())\n\t\ttry {\n\t\t\tawait this.fileController.downloadAll(nonInlineAttachments)\n\t\t} catch (e) {\n\t\t\tif (e instanceof FileOpenError) {\n\t\t\t\tconsole.warn(\"FileOpenError\", e)\n\t\t\t\tawait Dialog.message(\"canNotOpenFileOnDevice_msg\")\n\t\t\t} else {\n\t\t\t\tconsole.error(\"could not open file:\", e.message ?? \"unknown error\")\n\t\t\t\tawait Dialog.message(\"errorDuringFileOpen_msg\")\n\t\t\t}\n\t\t}\n\t}\n\n\tasync downloadAndOpenAttachment(file: TutanotaFile, open: boolean) {\n\t\tfile = (await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, [file]))[0]\n\t\ttry {\n\t\t\tif (open) {\n\t\t\t\tawait this.fileController.open(file)\n\t\t\t} else {\n\t\t\t\tawait this.fileController.download(file)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof FileOpenError) {\n\t\t\t\tconsole.warn(\"FileOpenError\", e)\n\t\t\t\tawait Dialog.message(\"canNotOpenFileOnDevice_msg\")\n\t\t\t} else {\n\t\t\t\tconsole.error(\"could not open file:\", e.message ?? \"unknown error\")\n\t\t\t\tawait Dialog.message(\"errorDuringFileOpen_msg\")\n\t\t\t}\n\t\t}\n\t}\n\n\tasync importAttachment(file: TutanotaFile) {\n\t\tconst attachmentType = getAttachmentType(file.mimeType ?? \"\")\n\t\tif (attachmentType === AttachmentType.CONTACT) {\n\t\t\tawait this.importContacts(file)\n\t\t} else if (attachmentType === AttachmentType.CALENDAR) {\n\t\t\tawait this.importCalendar(file)\n\t\t}\n\t}\n\n\tprivate async importContacts(file: TutanotaFile) {\n\t\tfile = (await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, [file]))[0]\n\t\ttry {\n\t\t\tconst dataFile = await this.fileController.getAsDataFile(file)\n\t\t\tconst contactListId = await this.contactModel.getContactListId()\n\t\t\t// this shouldn't happen but if it did we can just bail\n\t\t\tif (contactListId == null) return\n\t\t\tconst contactImporter = await this.contactImporter()\n\t\t\tawait contactImporter.importContactsFromFile(utf8Uint8ArrayToString(dataFile.data), contactListId)\n\t\t} catch (e) {\n\t\t\tconsole.log(e)\n\t\t\tthrow new UserError(\"errorDuringFileOpen_msg\")\n\t\t}\n\t}\n\n\tprivate async importCalendar(file: TutanotaFile) {\n\t\tfile = (await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(this._mail, [file]))[0]\n\t\ttry {\n\t\t\tconst { importCalendarFile, parseCalendarFile } = await import(\"../../../common/calendar/import/CalendarImporter.js\")\n\t\t\tconst dataFile = await this.fileController.getAsDataFile(file)\n\t\t\tconst data = parseCalendarFile(dataFile)\n\t\t\tawait importCalendarFile(await mailLocator.calendarModel(), this.logins.getUserController(), data.contents)\n\t\t} catch (e) {\n\t\t\tconsole.log(e)\n\t\t\tthrow new UserError(\"errorDuringFileOpen_msg\")\n\t\t}\n\t}\n\n\tcanImportFile(file: TutanotaFile): boolean {\n\t\tif (!this.logins.isInternalUserLoggedIn() || file.mimeType == null) {\n\t\t\treturn false\n\t\t}\n\t\tconst attachmentType = getAttachmentType(file.mimeType)\n\t\treturn attachmentType === AttachmentType.CONTACT || attachmentType === AttachmentType.CALENDAR\n\t}\n\n\tcanReplyAll(): boolean {\n\t\treturn (\n\t\t\tthis.logins.getUserController().isInternalUser() &&\n\t\t\tthis.getToRecipients().length + this.getCcRecipients().length + this.getBccRecipients().length > 1\n\t\t)\n\t}\n\n\tcanForwardOrMove(): boolean {\n\t\treturn this.logins.getUserController().isInternalUser()\n\t}\n\n\tshouldDelayRendering(): boolean {\n\t\treturn this.renderIsDelayed\n\t}\n\n\tisCollapsed(): boolean {\n\t\treturn this.collapsed\n\t}\n\n\texpandMail(delayBodyRendering: Promise<unknown>): void {\n\t\tthis.loadAll(delayBodyRendering, { notify: true })\n\t\tif (this.isUnread()) {\n\t\t\t// When we automatically mark email as read (e.g. opening it from notification) we don't want to run into offline errors, but we still want to mark\n\t\t\t// the email as read once we log in.l\n\t\t\t// It is appropriate to show the error when the user marks the email as unread explicitly but less so when they open it and just didn't reach the\n\t\t\t// full login yet.\n\t\t\tthis.logins.waitForFullLogin().then(() => this.setUnread(false))\n\t\t}\n\t\tthis.collapsed = false\n\t}\n\n\tcollapseMail(): void {\n\t\tthis.collapsed = true\n\t}\n\n\tgetLabels(): readonly MailFolder[] {\n\t\treturn this.mailModel.getLabelsForMail(this.mail)\n\t}\n\n\tprivate getMailOwnerGroup(): Id | null {\n\t\treturn this.mail._ownerGroup\n\t}\n\n\tprivate updateMail({ mail, showFolder }: { mail: Mail; showFolder?: boolean }) {\n\t\tif (!isSameId(mail._id, this.mail._id)) {\n\t\t\tthrow new ProgrammingError(\n\t\t\t\t`Trying to update MailViewerViewModel with unrelated email ${JSON.stringify(this.mail._id)} ${JSON.stringify(mail._id)} ${m.route.get()}`,\n\t\t\t)\n\t\t}\n\t\tthis._mail = mail\n\n\t\tthis.folderMailboxText = null\n\t\tif (showFolder) {\n\t\t\tthis.showFolder()\n\t\t}\n\n\t\tthis.relevantRecipient = null\n\t\tthis.determineRelevantRecipient()\n\n\t\tthis.loadAll(Promise.resolve(), { notify: true })\n\t}\n}\n"],"mappings":"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"}