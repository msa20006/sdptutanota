{"version":3,"file":"EntityUtils-RQxXZlcV.js","names":["firstId: Id","secondId: Id","typeModel?: TypeModel","id: Id","id1: Id | IdTuple","id2: Id | IdTuple","entity1: T","entity2: T","id1: (Id | IdTuple) | null","id2: (Id | IdTuple) | null","entity1: SomeEntity","entity2: SomeEntity","ids: ReadonlyArray<Id | IdTuple>","id: Id | IdTuple","entity: Element","entity: ListElement","entity: T","id: IdTuple","string: string","array: Uint8Array","customId: string","typeModel: TypeModel","typeRef: TypeRef<T>","createDefaultValue: (name: string, value: ModelValue) => any","i: Record<string, any>","valueName: string","value: ModelValue","timestamp: number","serverBytes: number","base64Ext: Id","entity: SomeEntity","type: TypeRef<T>","entity: E","erased: Record<string, any>","entity: StrippedEntity<E>","receiveDate: Date","mailId: Id","timestamp: bigint"],"sources":["../../src/common/api/common/EntityConstants.js","../../src/common/api/common/utils/EntityUtils.ts"],"sourcesContent":["// We cannot use TS types here because it's used during build. Types for these things are still inferred.\n\nexport const Type = Object.freeze({\n\tElement: \"ELEMENT_TYPE\",\n\tListElement: \"LIST_ELEMENT_TYPE\",\n\tDataTransfer: \"DATA_TRANSFER_TYPE\",\n\tAggregated: \"AGGREGATED_TYPE\",\n\tBlobElement: \"BLOB_ELEMENT_TYPE\",\n})\n\nexport const Cardinality = Object.freeze({\n\tZeroOrOne: \"ZeroOrOne\",\n\tAny: \"Any\",\n\tOne: \"One\",\n})\n\nexport const AssociationType = Object.freeze({\n\tElementAssociation: \"ELEMENT_ASSOCIATION\",\n\tListAssociation: \"LIST_ASSOCIATION\",\n\tListElementAssociationGenerated: \"LIST_ELEMENT_ASSOCIATION_GENERATED\",\n\tAggregation: \"AGGREGATION\",\n\tBlobElementAssociation: \"BLOB_ELEMENT_ASSOCIATION\",\n\tListElementAssociationCustom: \"LIST_ELEMENT_ASSOCIATION_CUSTOM\",\n})\n\nexport const ValueType = Object.freeze({\n\tString: \"String\",\n\tNumber: \"Number\",\n\tBytes: \"Bytes\",\n\tDate: \"Date\",\n\tBoolean: \"Boolean\",\n\tGeneratedId: \"GeneratedId\",\n\tCustomId: \"CustomId\",\n\tCompressedString: \"CompressedString\",\n})\n\nexport const ResourceType = Object.freeze({\n\tPersistence: \"Persistence\",\n\tService: \"Service\",\n})\n","import {\n\tbase64ExtToBase64,\n\tbase64ToBase64Ext,\n\tbase64ToBase64Url,\n\tbase64ToUint8Array,\n\tbase64UrlToBase64,\n\tclone,\n\tcompare,\n\tHex,\n\thexToBase64,\n\tisSameTypeRef,\n\tpad,\n\trepeat,\n\tstringToUtf8Uint8Array,\n\tTypeRef,\n\tuint8ArrayToBase64,\n\tutf8Uint8ArrayToString,\n} from \"@tutao/tutanota-utils\"\nimport { Cardinality, ValueType } from \"../EntityConstants.js\"\nimport type { ElementEntity, Entity, ModelValue, SomeEntity, TypeModel } from \"../EntityTypes\"\n\n/**\n * the maximum ID for elements stored on the server (number with the length of 10 bytes) => 2^80 - 1\n */\nexport const GENERATED_MAX_ID = \"zzzzzzzzzzzz\"\n/**\n * we support creation of customIds for mailset entries until around this date.\n *\n * this is intended to be after any reasonable real custom id we generate for mail set entries.\n *\n * current mailSetEntry maximum date is: 2019-05-15 -ish ( see MailFolderHelper.java: makeMailSetEntryCustomId )\n */\nexport const DEFAULT_MAILSET_ENTRY_CUSTOM_CUTOFF_TIMESTAMP = new Date(\"2109-05-16T15:00Z\").getTime()\n\n/**\n * The minimum ID for elements with generated id stored on the server\n */\nexport const GENERATED_MIN_ID = \"------------\"\n\n/**\n * The byte length of a generated id\n */\nexport const GENERATED_ID_BYTES_LENGTH = 9\n\n/**\n * The byte length of a custom Id used by mail set entries\n * 4 bytes timestamp (1024ms resolution)\n * 9 bytes mail element Id\n */\nexport const MAIL_SET_ENTRY_ID_BYTE_LENGTH = 13\n\n/**\n * The minimum ID for elements with custom id stored on the server\n */\nexport const CUSTOM_MIN_ID = \"\"\n/**\n * the maximum custom element id is enforced to be less than 256 bytes on the server. decoding this as Base64Url gives 255 bytes.\n *\n * NOTE: this is currently only used as a marker value when caching CalenderEvent and MailSetEntry.\n */\nexport const CUSTOM_MAX_ID = repeat(\"_\", 340)\nexport const RANGE_ITEM_LIMIT = 1000\nexport const LOAD_MULTIPLE_LIMIT = 100\nexport const POST_MULTIPLE_LIMIT = 100\n\n/**\n * an entity that only contains the actual user data and can not be used to refer to any existing entity.\n */\nexport type Stripped<T extends Partial<SomeEntity>> = Omit<\n\tT,\n\t| \"_id\"\n\t| \"_area\"\n\t| \"_owner\"\n\t| \"_ownerGroup\"\n\t| \"_ownerEncSessionKey\"\n\t| \"_ownerKeyVersion\"\n\t| \"_permissions\"\n\t| \"_errors\"\n\t| \"_format\"\n\t| \"_type\"\n\t| `_finalEncrypted${string}`\n\t| `_defaultEncrypted${string}`\n>\n\ntype OptionalEntity<T extends Entity> = T & {\n\t_id?: Id | IdTuple\n\t_ownerGroup?: Id\n}\n\nexport type StrippedEntity<T extends Entity> =\n\t| Omit<\n\t\t\tT,\n\t\t\t| \"_id\"\n\t\t\t| \"_ownerGroup\"\n\t\t\t| \"_ownerEncSessionKey\"\n\t\t\t| \"_ownerKeyVersion\"\n\t\t\t| \"_permissions\"\n\t\t\t| \"_errors\"\n\t\t\t| \"_format\"\n\t\t\t| \"_type\"\n\t\t\t| \"_area\"\n\t\t\t| \"_owner\"\n\t\t\t| `_finalEncrypted${string}`\n\t\t\t| `_defaultEncrypted${string}`\n\t  >\n\t| OptionalEntity<T>\n\n/**\n * Tests if one id is bigger than another.\n * For generated IDs we use base64ext which is sortable.\n * For custom IDs we use base64url which is not sortable, so we convert them to string before comparing.\n * Important: using this for custom IDs works only with custom IDs which are derived from strings.\n *\n * @param firstId The element id that is tested if it is bigger.\n * @param secondId The element id that is tested against.\n * @param typeModel optional - the type the Ids belong to. this can be used to compare custom IDs.\n * @return True if firstId is bigger than secondId, false otherwise.\n */\nexport function firstBiggerThanSecond(firstId: Id, secondId: Id, typeModel?: TypeModel): boolean {\n\tif (typeModel?.values._id.type === ValueType.CustomId) {\n\t\treturn firstBiggerThanSecondCustomId(firstId, secondId)\n\t} else {\n\t\t// if the number of digits is bigger, then the id is bigger, otherwise we can use the lexicographical comparison\n\t\tif (firstId.length > secondId.length) {\n\t\t\treturn true\n\t\t} else if (secondId.length > firstId.length) {\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn firstId > secondId\n\t\t}\n\t}\n}\n\nexport function firstBiggerThanSecondCustomId(firstId: Id, secondId: Id): boolean {\n\treturn compare(customIdToUint8array(firstId), customIdToUint8array(secondId)) === 1\n}\n\nexport function customIdToUint8array(id: Id): Uint8Array {\n\tif (id === \"\") {\n\t\treturn new Uint8Array()\n\t}\n\treturn base64ToUint8Array(base64UrlToBase64(id))\n}\n\nexport function compareNewestFirst(id1: Id | IdTuple, id2: Id | IdTuple): number {\n\tlet firstId = id1 instanceof Array ? id1[1] : id1\n\tlet secondId = id2 instanceof Array ? id2[1] : id2\n\n\tif (firstId === secondId) {\n\t\treturn 0\n\t} else {\n\t\treturn firstBiggerThanSecond(firstId, secondId) ? -1 : 1\n\t}\n}\n\nexport function compareOldestFirst(id1: Id | IdTuple, id2: Id | IdTuple): number {\n\tlet firstId = id1 instanceof Array ? id1[1] : id1\n\tlet secondId = id2 instanceof Array ? id2[1] : id2\n\n\tif (firstId === secondId) {\n\t\treturn 0\n\t} else {\n\t\treturn firstBiggerThanSecond(firstId, secondId) ? 1 : -1\n\t}\n}\n\nexport function sortCompareByReverseId<T extends ListElement>(entity1: T, entity2: T): number {\n\treturn compareNewestFirst(getElementId(entity1), getElementId(entity2))\n}\n\nexport function sortCompareById<T extends ListElement>(entity1: T, entity2: T): number {\n\treturn compareOldestFirst(getElementId(entity1), getElementId(entity2))\n}\n\n/**\n * Compares the ids of two elements.\n * @pre Both entities are either ElementTypes or ListElementTypes\n * @param id1\n * @param id2\n * @returns True if the ids are the same, false otherwise\n */\nexport function isSameId(id1: (Id | IdTuple) | null, id2: (Id | IdTuple) | null): boolean {\n\tif (id1 === null || id2 === null) {\n\t\treturn false\n\t} else if (id1 instanceof Array && id2 instanceof Array) {\n\t\treturn id1[0] === id2[0] && id1[1] === id2[1]\n\t} else {\n\t\treturn id1 === id2\n\t}\n}\n\nexport function haveSameId(entity1: SomeEntity, entity2: SomeEntity): boolean {\n\treturn isSameId(entity1._id, entity2._id)\n}\n\nexport function containsId(ids: ReadonlyArray<Id | IdTuple>, id: Id | IdTuple): boolean {\n\treturn ids.some((idInArray) => isSameId(idInArray, id))\n}\n\nexport interface Element {\n\t_id: Id\n}\n\nexport interface ListElement {\n\t_id: IdTuple\n}\n\nexport interface BlobElement {\n\t_id: IdTuple\n}\n\nexport function getEtId(entity: Element): Id {\n\treturn entity._id\n}\n\nexport function getLetId(entity: ListElement): IdTuple {\n\tif (typeof entity._id === \"undefined\") {\n\t\tthrow new Error(\"listId is not defined for \" + (typeof (entity as any)._type === \"undefined\" ? JSON.stringify(entity) : (entity as any)))\n\t}\n\n\treturn entity._id\n}\n\nexport function getElementId<T extends ListElement>(entity: T): Id {\n\treturn elementIdPart(getLetId(entity))\n}\n\nexport function getListId<T extends ListElement>(entity: T): Id {\n\treturn listIdPart(getLetId(entity))\n}\n\nexport function listIdPart(id: IdTuple): Id {\n\treturn id[0]\n}\n\nexport function elementIdPart(id: IdTuple): Id {\n\treturn id[1]\n}\n\n/**\n * Converts a string to a custom id. Attention: the custom id must be intended to be derived from a string.\n */\nexport function stringToCustomId(string: string): string {\n\treturn uint8arrayToCustomId(stringToUtf8Uint8Array(string))\n}\n\nexport function uint8arrayToCustomId(array: Uint8Array): string {\n\treturn base64ToBase64Url(uint8ArrayToBase64(array))\n}\n\n/**\n * Converts a custom id to a string. Attention: the custom id must be intended to be derived from a string.\n */\nexport function customIdToString(customId: string): string {\n\treturn utf8Uint8ArrayToString(base64ToUint8Array(base64UrlToBase64(customId)))\n}\n\nexport function create<T>(typeModel: TypeModel, typeRef: TypeRef<T>, createDefaultValue: (name: string, value: ModelValue) => any = _getDefaultValue): T {\n\tlet i: Record<string, any> = {\n\t\t_type: typeRef,\n\t}\n\n\tfor (let valueName of Object.keys(typeModel.values)) {\n\t\tlet value = typeModel.values[valueName]\n\t\ti[valueName] = createDefaultValue(valueName, value)\n\t}\n\n\tfor (let associationName of Object.keys(typeModel.associations)) {\n\t\tlet association = typeModel.associations[associationName]\n\n\t\tif (association.cardinality === Cardinality.Any) {\n\t\t\ti[associationName] = []\n\t\t} else {\n\t\t\t// set to null even if the cardinality is One. we could think about calling create recursively,\n\t\t\t// but that would require us to resolve type refs (async) and recursively merge the result with\n\t\t\t// the provided values\n\t\t\ti[associationName] = null\n\t\t}\n\t}\n\n\treturn i as any\n}\n\nfunction _getDefaultValue(valueName: string, value: ModelValue): any {\n\tif (valueName === \"_format\") {\n\t\treturn \"0\"\n\t} else if (valueName === \"_id\") {\n\t\treturn null // aggregate ids are set in the worker, list ids must be set explicitely and element ids are created on the server\n\t} else if (valueName === \"_permissions\") {\n\t\treturn null\n\t} else if (value.cardinality === Cardinality.ZeroOrOne) {\n\t\treturn null\n\t} else {\n\t\tswitch (value.type) {\n\t\t\tcase ValueType.Bytes:\n\t\t\t\treturn new Uint8Array(0)\n\n\t\t\tcase ValueType.Date:\n\t\t\t\treturn new Date()\n\n\t\t\tcase ValueType.Number:\n\t\t\t\treturn \"0\"\n\n\t\t\tcase ValueType.String:\n\t\t\t\treturn \"\"\n\n\t\t\tcase ValueType.Boolean:\n\t\t\t\treturn false\n\n\t\t\tcase ValueType.CustomId:\n\t\t\tcase ValueType.GeneratedId:\n\t\t\t\treturn null\n\t\t\t// we have to use null although the value must be set to something different\n\t\t}\n\t}\n\n\tthrow new Error(`no default value for ${JSON.stringify(value)}`)\n}\n\n/**\n * Converts a timestamp number to a GeneratedId (the counter is set to zero) in hex format.\n *\n * @param timestamp The timestamp of the GeneratedId\n * @return The GeneratedId as hex string.\n */\nexport function timestampToHexGeneratedId(timestamp: number, serverBytes: number): Hex {\n\tlet id = timestamp * 4 // shifted 2 bits left, so the value covers 44 bits overall (42 timestamp + 2 shifted)\n\n\tlet hex = id.toString(16) + \"00000\" + pad(serverBytes, 2) // add one zero for the missing 4 bits plus 4 more (2 bytes) plus 2 more for the server id to get 9 bytes\n\n\t// add leading zeros to reach 9 bytes (GeneratedId length) = 18 hex\n\tfor (let length = hex.length; length < 18; length++) {\n\t\thex = \"0\" + hex\n\t}\n\n\treturn hex\n}\n\n/**\n * Converts a timestamp number to a GeneratedId (the counter and server bits are set to zero).\n *\n * @param timestamp The timestamp of the GeneratedId\n * @return The GeneratedId.\n */\nexport function timestampToGeneratedId(timestamp: number, serverBytes: number = 0): Id {\n\tlet hex = timestampToHexGeneratedId(timestamp, serverBytes)\n\treturn base64ToBase64Ext(hexToBase64(hex))\n}\n\n/**\n * Extracts the timestamp from a GeneratedId\n * @param base64Ext The id as base64Ext\n * @returns The timestamp of the GeneratedId\n */\nexport function generatedIdToTimestamp(base64Ext: Id): number {\n\tconst base64 = base64ExtToBase64(base64Ext)\n\tconst decodedbB4 = atob(base64)\n\tlet numberResult = 0\n\n\t// Timestamp is in the first 42 bits\n\tfor (let i = 0; i < 5; i++) {\n\t\t// We \"shift\" each number by 8 bits to the left: numberResult << 8\n\t\tnumberResult = numberResult * 256\n\t\tnumberResult += decodedbB4.charCodeAt(i)\n\t}\n\n\t// We need to shift the whole number to the left by 2 bits (because 42 bits is encoded in 6 bytes)\n\tnumberResult = numberResult * 4\n\t// We take only last two highest bits from the last byte\n\tnumberResult += decodedbB4.charCodeAt(5) >>> 6\n\treturn numberResult\n}\n\nconst base64extEncodedIdLength = GENERATED_MAX_ID.length\nconst base64extAlphabet = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\"\n\nexport function isValidGeneratedId(id: Id | IdTuple): boolean {\n\tconst test = (id: string) => id.length === base64extEncodedIdLength && Array.from(id).every((char) => base64extAlphabet.includes(char))\n\n\treturn typeof id === \"string\" ? test(id) : id.every(test)\n}\n\nexport function isElementEntity(e: SomeEntity): e is ElementEntity {\n\treturn typeof e._id === \"string\"\n}\n\nexport function assertIsEntity<T extends SomeEntity>(entity: SomeEntity, type: TypeRef<T>): entity is T {\n\tif (isSameTypeRef(entity._type, type)) {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nexport function assertIsEntity2<T extends SomeEntity>(type: TypeRef<T>): (entity: SomeEntity) => entity is T {\n\treturn (e): e is T => assertIsEntity(e, type)\n}\n\n/**\n * Remove some hidden technical fields from the entity.\n *\n * Only use for new entities, the {@param entity} won't be usable for updates anymore after this.\n */\nexport function removeTechnicalFields<E extends Partial<SomeEntity>>(entity: E) {\n\t// we want to restrict outer function to entity types but internally we also want to handle aggregates\n\tfunction _removeTechnicalFields(erased: Record<string, any>) {\n\t\tfor (const key of Object.keys(erased)) {\n\t\t\tif (key.startsWith(\"_finalEncrypted\") || key.startsWith(\"_defaultEncrypted\") || key.startsWith(\"_errors\")) {\n\t\t\t\tdelete erased[key]\n\t\t\t} else {\n\t\t\t\tconst value = erased[key]\n\t\t\t\tif (value instanceof Object) {\n\t\t\t\t\t_removeTechnicalFields(value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_removeTechnicalFields(entity)\n}\n\n/**\n * get a clone of a (partial) entity that does not contain any fields that would indicate that it was ever persisted anywhere.\n * @param entity the entity to strip\n */\nexport function getStrippedClone<E extends SomeEntity>(entity: StrippedEntity<E>): StrippedEntity<E> {\n\tconst cloned = clone(entity)\n\tremoveTechnicalFields(cloned)\n\tremoveIdentityFields(cloned)\n\treturn cloned\n}\n\n/**\n * remove fields that do not contain user defined data but are related to finding/accessing the entity on the server\n */\nfunction removeIdentityFields<E extends Partial<SomeEntity>>(entity: E) {\n\tconst keysToDelete = [\"_id\", \"_ownerGroup\", \"_ownerEncSessionKey\", \"_ownerKeyVersion\", \"_permissions\"]\n\n\tfunction _removeIdentityFields(erased: Record<string, any>) {\n\t\tfor (const key of Object.keys(erased)) {\n\t\t\tif (keysToDelete.includes(key)) {\n\t\t\t\tdelete erased[key]\n\t\t\t} else {\n\t\t\t\tconst value = erased[key]\n\t\t\t\tif (value instanceof Object) {\n\t\t\t\t\t_removeIdentityFields(value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_removeIdentityFields(entity)\n}\n\n/** construct a mail set entry Id for a given mail. see MailFolderHelper.java */\nexport function constructMailSetEntryId(receiveDate: Date, mailId: Id): Id {\n\tconst buffer = new DataView(new ArrayBuffer(MAIL_SET_ENTRY_ID_BYTE_LENGTH))\n\tconst mailIdBytes = base64ToUint8Array(base64ExtToBase64(mailId))\n\n\t// shifting the received timestamp by 10 bit reduces the resolution from 1ms to 1024ms.\n\t// truncating to 4 bytes leaves us with enough space for epoch + 4_294_967_295 not-quite-seconds\n\t// (until around 2109-05-15 15:00)\n\tconst timestamp: bigint = BigInt(Math.trunc(receiveDate.getTime()))\n\n\tconst truncatedReceiveDate = (timestamp >> 10n) & 0x00000000ffffffffn\n\n\t// we don't need the leading zeroes\n\tbuffer.setBigUint64(0, truncatedReceiveDate << 32n)\n\n\tfor (let i = 0; i < mailIdBytes.length; i++) {\n\t\tbuffer.setUint8(i + 4, mailIdBytes[i])\n\t}\n\n\treturn uint8arrayToCustomId(new Uint8Array(buffer.buffer))\n}\n\nexport function deconstructMailSetEntryId(id: Id): { receiveDate: Date; mailId: Id } {\n\tconst buffer = customIdToUint8array(id)\n\tconst timestampBytes = buffer.slice(0, 4)\n\tconst generatedIdBytes = buffer.slice(4)\n\n\tconst timestamp1024 = (timestampBytes[0] << 24) | (timestampBytes[1] << 16) | (timestampBytes[2] << 8) | timestampBytes[3]\n\tconst timestamp = timestamp1024 * 1024\n\n\tconst mailId = base64ToBase64Ext(uint8ArrayToBase64(generatedIdBytes))\n\n\treturn { receiveDate: new Date(timestamp), mailId }\n}\n\nexport const LEGACY_TO_RECIPIENTS_ID = 112\nexport const LEGACY_CC_RECIPIENTS_ID = 113\nexport const LEGACY_BCC_RECIPIENTS_ID = 114\nexport const LEGACY_BODY_ID = 116\n"],"mappings":"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"}