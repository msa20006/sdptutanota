{"version":3,"file":"Scheduler-B2H65_EO.js","names":["hostname: string","protocol: string","port?: string","dateProvider: DateProvider","systemTimeout: SystemTimeout","systemInterval: SystemInterval","callback: Thunk","date: Date","timeoutId: TimeoutID","thunk: Thunk","after: number","id: ScheduledTimeoutId","ms: number","id: ScheduledPeriodicId"],"sources":["../../src/common/api/common/utils/NoZoneDateProvider.ts","../../src/common/api/common/DomainConfigProvider.ts","../../src/common/api/common/utils/Scheduler.ts"],"sourcesContent":["import { ProgrammingError } from \"../error/ProgrammingError.js\"\nimport { DateProvider } from \"../DateProvider.js\"\n\nexport class NoZoneDateProvider implements DateProvider {\n\tnow(): number {\n\t\treturn Date.now()\n\t}\n\n\ttimeZone(): string {\n\t\tthrow new ProgrammingError(\"timeZone is not available in worker\")\n\t}\n}\n","export class DomainConfigProvider {\n\t/** Get domain config for the current domain (staticUrl or the one the app is running on). */\n\tgetCurrentDomainConfig(): DomainConfig {\n\t\t// It is ambiguous what to do when we run website on one domain but have static URL for another\n\t\t// one but this actually shouldn't happen.\n\t\tconst url = new URL(env.staticUrl ?? location.href)\n\t\tconst port = url.port\n\t\tconst hostname = url.hostname\n\t\tconst protocol = url.protocol\n\t\treturn this.getDomainConfigForHostname(hostname, protocol, port)\n\t}\n\n\tgetDomainConfigForHostname(hostname: string, protocol: string = \"https:\", port?: string): DomainConfig {\n\t\tconst staticConfig = env.domainConfigs[hostname]\n\t\tif (staticConfig) {\n\t\t\treturn staticConfig\n\t\t} else {\n\t\t\tconst fullHostName = hostname + (port ? `:${port}` : \"\")\n\t\t\tconst dynamicConfig = env.domainConfigs[\"{hostname}\"]\n\t\t\tconst entries = Object.entries(dynamicConfig).map(([key, value]) => {\n\t\t\t\tconst replacedValue = typeof value === \"string\" ? value.replace(\"{hostname}\", fullHostName).replace(\"{protocol}\", protocol) : value\n\t\t\t\treturn [key, replacedValue]\n\t\t\t})\n\t\t\treturn Object.fromEntries(entries)\n\t\t}\n\t}\n}\n","import type { Thunk } from \"@tutao/tutanota-utils\"\nimport { DateProvider } from \"../DateProvider.js\"\n\nexport type ScheduledTimeoutId = TimeoutID\nexport type ScheduledPeriodicId = TimeoutID\n\nexport interface Scheduler {\n\tscheduleAt(thunk: Thunk, date: Date): ScheduledTimeoutId\n\n\tunscheduleTimeout(id: ScheduledTimeoutId): void\n\n\tscheduleAfter(thunk: Thunk, after: number): ScheduledTimeoutId\n\n\tschedulePeriodic(thunk: Thunk, period: number): ScheduledPeriodicId\n\n\tunschedulePeriodic(id: ScheduledPeriodicId): void\n}\n\n/**\n * setTimeout() only works on 32bit integers, it doesn't do what you expect on longer intervals. If you use Scheduler you should not\n * worry about it, mainly exported for tests.\n * */\nexport const SET_TIMEOUT_LIMIT = 0x7fffffff\n\n/** Default impl of timeout functions, useful for testing */\nexport type SystemTimeout = {\n\t// Copying it because ts has some weird properties attach to it in node tslib.\n\t// no-arg version because lambadas exist.\n\tsetTimeout(callback: () => void, ms: number): number\n\tclearTimeout: typeof clearTimeout\n}\n\n/** Default impl of interval functions, useful for testing */\nexport type SystemInterval = {\n\t// Copying it because ts has some weird properties attach to it in node tslib.\n\t// no-arg version because lambadas exist.\n\tsetInterval(callback: () => void, ms: number): number\n\tclearInterval: typeof clearInterval\n}\n\nexport class SchedulerImpl implements Scheduler {\n\t/**\n\t * This points from the originally scheduled timeout to the most recent timeout\n\t */\n\tprivate readonly bridgedTimeouts: Map<ScheduledTimeoutId, ScheduledTimeoutId>\n\n\tconstructor(private readonly dateProvider: DateProvider, private readonly systemTimeout: SystemTimeout, private readonly systemInterval: SystemInterval) {\n\t\tthis.bridgedTimeouts = new Map()\n\t}\n\n\tscheduleAt(callback: Thunk, date: Date): ScheduledTimeoutId {\n\t\tlet timeoutId: TimeoutID\n\n\t\t// Call the thunk and clean up timeout in the map\n\t\tconst wrappedCallback = () => {\n\t\t\tthis.bridgedTimeouts.delete(timeoutId)\n\n\t\t\tcallback()\n\t\t}\n\n\t\ttimeoutId = this.scheduleAtInternal(wrappedCallback, date)\n\t\treturn timeoutId\n\t}\n\n\tscheduleAfter(thunk: Thunk, after: number): ScheduledTimeoutId {\n\t\tconst date = new Date(this.dateProvider.now() + after)\n\t\treturn this.scheduleAt(thunk, date)\n\t}\n\n\t/** We have separate internal version which does not re-wrap the thunk. */\n\tprivate scheduleAtInternal(thunk: Thunk, date: Date): ScheduledTimeoutId {\n\t\tconst now = this.dateProvider.now()\n\n\t\tconst then = date.getTime()\n\t\tconst diff = Math.max(then - now, 0)\n\t\tlet timeoutId: TimeoutID\n\n\t\tif (diff > SET_TIMEOUT_LIMIT) {\n\t\t\ttimeoutId = this.systemTimeout.setTimeout(() => {\n\t\t\t\tconst newTimeoutId = this.scheduleAtInternal(thunk, date)\n\n\t\t\t\tthis.bridgedTimeouts.set(timeoutId, newTimeoutId)\n\t\t\t}, SET_TIMEOUT_LIMIT)\n\t\t} else {\n\t\t\ttimeoutId = this.systemTimeout.setTimeout(thunk, diff)\n\t\t}\n\n\t\treturn timeoutId\n\t}\n\n\tunscheduleTimeout(id: ScheduledTimeoutId): void {\n\t\tconst rescheduledId = this.bridgedTimeouts.get(id) || id\n\n\t\tthis.bridgedTimeouts.delete(rescheduledId)\n\n\t\treturn this.systemTimeout.clearTimeout(rescheduledId)\n\t}\n\n\tschedulePeriodic(thunk: Thunk, ms: number): ScheduledPeriodicId {\n\t\t// Intervals bigger than 32 bit int will not work out-of-the-box and we do not want to implement bridging for them as this is a very rare case and is\n\t\t// usually a bug.\n\t\tif (ms > SET_TIMEOUT_LIMIT) {\n\t\t\tthrow new Error(\"Attempting to schedule periodic task but the period is too big: \" + ms)\n\t\t}\n\t\treturn this.systemInterval.setInterval(thunk, ms)\n\t}\n\n\tunschedulePeriodic(id: ScheduledPeriodicId) {\n\t\tthis.systemInterval.clearInterval(id)\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAGa,qBAAN,MAAiD;CACvD,MAAc;AACb,SAAO,KAAK,KAAK;CACjB;CAED,WAAmB;AAClB,QAAM,IAAI,iBAAiB;CAC3B;AACD;;;;ICXY,uBAAN,MAA2B;;CAEjC,yBAAuC;EAGtC,MAAM,MAAM,IAAI,IAAI,IAAI,aAAa,SAAS;EAC9C,MAAM,OAAO,IAAI;EACjB,MAAM,WAAW,IAAI;EACrB,MAAM,WAAW,IAAI;AACrB,SAAO,KAAK,2BAA2B,UAAU,UAAU,KAAK;CAChE;CAED,2BAA2BA,UAAkBC,WAAmB,UAAUC,MAA6B;EACtG,MAAM,eAAe,IAAI,cAAc;AACvC,MAAI,aACH,QAAO;KACD;GACN,MAAM,eAAe,YAAY,QAAQ,GAAG,KAAK,IAAI;GACrD,MAAM,gBAAgB,IAAI,cAAc;GACxC,MAAM,UAAU,OAAO,QAAQ,cAAc,CAAC,IAAI,CAAC,CAAC,KAAK,MAAM,KAAK;IACnE,MAAM,uBAAuB,UAAU,WAAW,MAAM,QAAQ,cAAc,aAAa,CAAC,QAAQ,cAAc,SAAS,GAAG;AAC9H,WAAO,CAAC,KAAK,aAAc;GAC3B,EAAC;AACF,UAAO,OAAO,YAAY,QAAQ;EAClC;CACD;AACD;;;;MCJY,oBAAoB;IAkBpB,gBAAN,MAAyC;;;;CAI/C,AAAiB;CAEjB,YAA6BC,cAA6CC,eAA+CC,gBAAgC;EAiEzJ,KAjE6B;EAiE5B,KAjEyE;EAiExE,KAjEuH;AACxH,OAAK,kBAAkB,IAAI;CAC3B;CAED,WAAWC,UAAiBC,MAAgC;EAC3D,IAAIC;EAGJ,MAAM,kBAAkB,MAAM;AAC7B,QAAK,gBAAgB,OAAO,UAAU;AAEtC,aAAU;EACV;AAED,cAAY,KAAK,mBAAmB,iBAAiB,KAAK;AAC1D,SAAO;CACP;CAED,cAAcC,OAAcC,OAAmC;EAC9D,MAAM,OAAO,IAAI,KAAK,KAAK,aAAa,KAAK,GAAG;AAChD,SAAO,KAAK,WAAW,OAAO,KAAK;CACnC;;CAGD,AAAQ,mBAAmBD,OAAcF,MAAgC;EACxE,MAAM,MAAM,KAAK,aAAa,KAAK;EAEnC,MAAM,OAAO,KAAK,SAAS;EAC3B,MAAM,OAAO,KAAK,IAAI,OAAO,KAAK,EAAE;EACpC,IAAIC;AAEJ,MAAI,OAAO,kBACV,aAAY,KAAK,cAAc,WAAW,MAAM;GAC/C,MAAM,eAAe,KAAK,mBAAmB,OAAO,KAAK;AAEzD,QAAK,gBAAgB,IAAI,WAAW,aAAa;EACjD,GAAE,kBAAkB;IAErB,aAAY,KAAK,cAAc,WAAW,OAAO,KAAK;AAGvD,SAAO;CACP;CAED,kBAAkBG,IAA8B;EAC/C,MAAM,gBAAgB,KAAK,gBAAgB,IAAI,GAAG,IAAI;AAEtD,OAAK,gBAAgB,OAAO,cAAc;AAE1C,SAAO,KAAK,cAAc,aAAa,cAAc;CACrD;CAED,iBAAiBF,OAAcG,IAAiC;AAG/D,MAAI,KAAK,kBACR,OAAM,IAAI,MAAM,qEAAqE;AAEtF,SAAO,KAAK,eAAe,YAAY,OAAO,GAAG;CACjD;CAED,mBAAmBC,IAAyB;AAC3C,OAAK,eAAe,cAAc,GAAG;CACrC;AACD"}