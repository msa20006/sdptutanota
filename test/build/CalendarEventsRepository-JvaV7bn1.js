
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { findAllAndRemove, incrementDate, stringToBase64 } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import { CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID, OperationType, RepeatPeriod } from "./TutanotaConstants-3bwAESYA.js";
import { NotAuthorizedError, NotFoundError } from "./RestError-D17JEBMr.js";
import "./ParserCombinator-D38ofgFx.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { DateTime } from "./luxon-D6cgmg6Q.js";
import { getListId, isSameId, listIdPart } from "./EntityUtils-RQxXZlcV.js";
import { generateLocalEventElementId, getAllDayDateUTC } from "./CommonCalendarUtils-DKaO7v1K.js";
import "./TypeModels-XIXYys8J.js";
import { CalendarEventTypeRef, ContactTypeRef, createCalendarEvent } from "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import "./TypeRefs-BP1jvX9p.js";
import { addDaysForRecurringEvent, calculateContactsAge, createRepeatRuleWithValues, extractYearFromBirthday, generateUid, getEventEnd, getEventStart, getMonthRange, isBirthdayEvent, isClientOnlyCalendar } from "./CalendarUtils-C6jeYrj9.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { isoDateToBirthday } from "./BirthdayUtils-BcCMglSq.js";

//#region ../src/common/calendar/date/CalendarEventsRepository.ts
var import_stream = __toESM(require_stream(), 1);
const LIMIT_PAST_EVENTS_YEARS = 100;
const TAG = "[CalendarEventRepository]";
var CalendarEventsRepository = class {
	/** timestamps of the beginning of months that we already loaded */
	loadedMonths = new Set();
	daysToEvents = (0, import_stream.default)(new Map());
	pendingLoadRequest = Promise.resolve();
	clientOnlyEvents = new Map();
	constructor(calendarModel, calendarFacade, zone, entityClient, eventController, contactModel, logins) {
		this.calendarModel = calendarModel;
		this.calendarFacade = calendarFacade;
		this.zone = zone;
		this.entityClient = entityClient;
		this.eventController = eventController;
		this.contactModel = contactModel;
		this.logins = logins;
		eventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId));
		this.calendarModel.getCalendarInfosStream().map((infos) => {
			if (infos.size === 0) {
				this.loadedMonths.clear();
				this.daysToEvents(new Map());
			}
		});
	}
	getEventsForMonths() {
		return this.daysToEvents;
	}
	getBirthdayEvents() {
		return this.clientOnlyEvents;
	}
	async canLoadBirthdaysCalendar() {
		return await this.logins.getUserController().isNewPaidPlan();
	}
	async loadMonthsIfNeeded(daysInMonths, progressMonitor, canceled) {
		const promiseForThisLoadRequest = this.pendingLoadRequest.then(async () => {
			for (const dayInMonth of daysInMonths) {
				if (canceled()) return;
				const monthRange = getMonthRange(dayInMonth, this.zone);
				if (!this.loadedMonths.has(monthRange.start)) {
					this.loadedMonths.add(monthRange.start);
					try {
						const calendarInfos = await this.calendarModel.getCalendarInfos();
						const eventsMap = await this.calendarFacade.updateEventMap(monthRange, calendarInfos, this.daysToEvents(), this.zone);
						this.replaceEvents(eventsMap);
						this.addBirthdaysEventsIfNeeded(dayInMonth, monthRange);
					} catch (e) {
						this.loadedMonths.delete(monthRange.start);
						throw e;
					}
				}
				progressMonitor.workDone(1);
			}
		});
		this.pendingLoadRequest = promiseForThisLoadRequest;
		await promiseForThisLoadRequest;
	}
	async addOrUpdateEvent(calendarInfo, event) {
		if (calendarInfo == null) return;
		const eventListId = getListId(event);
		if (isSameId(calendarInfo.groupRoot.shortEvents, eventListId)) {
			const eventStartMonth = getMonthRange(getEventStart(event, this.zone), this.zone);
			const eventEndMonth = getMonthRange(getEventEnd(event, this.zone), this.zone);
			if (this.loadedMonths.has(eventStartMonth.start)) await this.addDaysForEvent(event, eventStartMonth);
			if (eventEndMonth.start != eventStartMonth.start && this.loadedMonths.has(eventEndMonth.start)) await this.addDaysForEvent(event, eventEndMonth);
		} else if (isSameId(calendarInfo.groupRoot.longEvents, eventListId)) {
			this.removeExistingEvent(event);
			for (const firstDayTimestamp of this.loadedMonths) {
				const loadedMonth = getMonthRange(new Date(firstDayTimestamp), this.zone);
				if (event.repeatRule != null) await this.addDaysForRecurringEvent(event, loadedMonth);
else await this.addDaysForEvent(event, loadedMonth);
			}
		}
	}
	replaceEvents(newMap) {
		this.daysToEvents(newMap);
	}
	cloneEvents() {
		return new Map(Array.from(this.daysToEvents().entries()).map(([day, events]) => [day, events.slice()]));
	}
	addDaysForRecurringEvent(event, month) {
		if (!isClientOnlyCalendar(listIdPart(event._id)) && -DateTime.fromJSDate(event.startTime).diffNow("year").years > LIMIT_PAST_EVENTS_YEARS) {
			console.log("repeating event is too far into the past", event);
			return;
		}
		const newMap = this.cloneEvents();
		addDaysForRecurringEvent(newMap, event, month, this.zone);
		this.replaceEvents(newMap);
	}
	removeDaysForEvent(id) {
		const newMap = this.cloneEvents();
		for (const dayEvents of newMap.values()) findAllAndRemove(dayEvents, (e) => isSameId(e._id, id));
		this.replaceEvents(newMap);
	}
	/**
	* Removes {@param eventToRemove} from {@param events} using isSameEvent()
	*/
	removeExistingEvent(eventToRemove) {
		const newMap = this.cloneEvents();
		for (const dayEvents of newMap.values()) findAllAndRemove(dayEvents, (e) => isSameId(e._id, eventToRemove._id));
		this.replaceEvents(newMap);
	}
	async addDaysForEvent(event, month) {
		const { addDaysForEventInstance } = await import("./CalendarUtils-DwR144gS.js");
		const newMap = this.cloneEvents();
		addDaysForEventInstance(newMap, event, month, this.zone);
		this.replaceEvents(newMap);
	}
	async entityEventsReceived(updates, eventOwnerGroupId) {
		const calendarInfos = await this.calendarModel.getCalendarInfos();
		for (const update of updates) if (isUpdateForTypeRef(CalendarEventTypeRef, update)) {
			if (update.operation === OperationType.CREATE || update.operation === OperationType.UPDATE) try {
				const event = await this.entityClient.load(CalendarEventTypeRef, [update.instanceListId, update.instanceId]);
				await this.addOrUpdateEvent(calendarInfos.get(eventOwnerGroupId) ?? null, event);
			} catch (e) {
				if (e instanceof NotFoundError || e instanceof NotAuthorizedError) console.log(TAG, e.name, "updated event is not accessible anymore");
				throw e;
			}
else if (update.operation === OperationType.DELETE) this.removeDaysForEvent([update.instanceListId, update.instanceId]);
		}
	}
	pushClientOnlyEvent(month, newEvent, baseYear) {
		let clientOnlyEventsOfThisMonth = this.clientOnlyEvents.get(month) ?? [];
		clientOnlyEventsOfThisMonth.push({
			baseYear,
			event: newEvent
		});
		this.clientOnlyEvents.set(month, clientOnlyEventsOfThisMonth);
	}
	createClientOnlyBirthdayEvent(contact, userId) {
		const encodedContactId = stringToBase64(contact._id.join("/"));
		const calendarId = `${userId}#${CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID}`;
		const uid = generateUid(calendarId, Date.now());
		const eventTitle = this.calendarModel.getBirthdayEventTitle(contact.firstName);
		let fullDateIso = contact.birthdayIso;
		if (contact.birthdayIso?.startsWith("--")) fullDateIso = contact.birthdayIso.replace("-", "1970");
		const birthday = new Date(fullDateIso);
		const startDate = getAllDayDateUTC(new Date(birthday));
		const endDate = getAllDayDateUTC(incrementDate(new Date(startDate), 1));
		const newEvent = createCalendarEvent({
			sequence: "0",
			recurrenceId: null,
			hashedUid: null,
			summary: eventTitle,
			startTime: startDate,
			endTime: endDate,
			location: "",
			description: "",
			alarmInfos: [],
			organizer: null,
			attendees: [],
			invitedConfidentially: null,
			repeatRule: createRepeatRuleWithValues(RepeatPeriod.ANNUALLY, 1),
			uid
		});
		newEvent._id = [calendarId, `${generateLocalEventElementId(newEvent.startTime.getTime(), contact._id.join("/"))}#${encodedContactId}`];
		newEvent._ownerGroup = calendarId;
		return newEvent;
	}
	async loadContactsBirthdays(forceReload = false) {
		if (this.clientOnlyEvents.size > 0 && !forceReload) return;
		this.clientOnlyEvents.clear();
		const listId = await this.contactModel.getContactListId();
		if (listId == null) return [];
		const contacts = await this.entityClient.loadAll(ContactTypeRef, listId);
		const filteredContacts = contacts.filter((contact) => contact.birthdayIso).sort((a, b) => {
			const birthdayContactA = isoDateToBirthday(a.birthdayIso);
			const birthdayContactB = isoDateToBirthday(b.birthdayIso);
			return new Date(`${birthdayContactA.month}/${birthdayContactA.day}`).getTime() - new Date(`${birthdayContactB.month}/${birthdayContactB.day}`).getTime();
		});
		for (const contact of filteredContacts) {
			const newEvent = this.createClientOnlyBirthdayEvent(contact, this.logins.getUserController().userId);
			this.pushClientOnlyEvent(newEvent.startTime.getMonth(), newEvent, extractYearFromBirthday(contact.birthdayIso));
		}
		return filteredContacts;
	}
	refreshBirthdayCalendar(date) {
		const month = getMonthRange(date, this.zone);
		this.addBirthdaysEventsIfNeeded(date, month, true);
	}
	addBirthdaysEventsIfNeeded(selectedDate, monthRangeForRecurrence, removeEventOccurrences = false) {
		const clientOnlyEventsThisMonth = this.clientOnlyEvents.get(selectedDate.getMonth());
		const birthdaysOfThisMonth = clientOnlyEventsThisMonth?.filter((birthdayEvent) => isBirthdayEvent(birthdayEvent.event.uid));
		if (birthdaysOfThisMonth) for (const calendarEvent of birthdaysOfThisMonth) {
			const age = calculateContactsAge(calendarEvent.baseYear, selectedDate.getFullYear());
			const ageString = age ? `(${this.calendarModel.getAgeString(age)})` : "";
			if (removeEventOccurrences) this.removeDaysForEvent(calendarEvent.event._id);
			this.addDaysForRecurringEvent({
				...calendarEvent.event,
				summary: `${calendarEvent.event.summary} ${ageString}`
			}, monthRangeForRecurrence);
		}
	}
};

//#endregion
export { CalendarEventsRepository };
//# sourceMappingURL=CalendarEventsRepository-JvaV7bn1.js.map