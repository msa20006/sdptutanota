{"version":3,"file":"dist-Ci1bEzYU.js","names":["o"],"sources":["../../packages/otest/dist/fancy.js","../../packages/otest/dist/Assertion.js","../../packages/otest/dist/otest.js","../../packages/otest/dist/index.js"],"sourcesContent":["export const ansiSequences = Object.freeze({\n    redFg: \"\\x1b[31m\",\n    greenBg: \"\\x1b[42m\",\n    redBg: \"\\x1b[41m\",\n    yellowBg: \"\\x1b[43m\",\n    reset: \"\\x1b[0m\",\n    bold: \"\\x1b[0;1m\",\n    faint: \"\\x1b[0;2m\",\n});\nexport function fancy(text, code) {\n    if (typeof process !== \"undefined\" && process.stdout.isTTY) {\n        return `${code}${text}${ansiSequences.reset}`;\n    }\n    else {\n        return text;\n    }\n}\n","let asString;\nif (typeof process !== \"undefined\") {\n    const { inspect } = await import(\"node:util\");\n    asString = function (thing) {\n        return inspect(thing, { depth: 5 });\n    };\n}\nelse {\n    asString = function (thing) {\n        return JSON.stringify(thing);\n    };\n}\n/**\n * A started assertion.\n */\nexport class Assertion {\n    actual;\n    testResult;\n    constructor(actual, testResult) {\n        this.actual = actual;\n        this.testResult = testResult;\n    }\n    /**\n     * Verify that two items are deeply equal.\n     * For arrays length and each element must be deeply equal.\n     * For objects the key sets must match and each property must be deeply equal.\n     */\n    deepEquals(expected) {\n        if (!deepEqual(this.actual, expected)) {\n            return this.addError(`expected \"${asString(this.actual)}\" to be deep equal to \"${asString(expected)}\"`);\n        }\n        return noop;\n    }\n    /**\n     * Verify that two items are referentially equal.\n     */\n    equals(expected) {\n        if (this.actual !== expected) {\n            return this.addError(`expected \"${asString(this.actual)}\" to be equal to \"${asString(expected)}\"`);\n        }\n        return noop;\n    }\n    /** {@see deepEquals} */\n    notDeepEquals(value) {\n        if (deepEqual(this.actual, value)) {\n            return this.addError(`expected to \"${asString(this.actual)}\" NOT deep equal to \"${asString(value)}\"`);\n        }\n        return noop;\n    }\n    /** {@see equals} */\n    notEquals(value) {\n        if (this.actual === value) {\n            return this.addError(`expected \"${asString(this.actual)}\" to NOT be equal to \"${asString(value)}\"`);\n        }\n        return noop;\n    }\n    /**\n     * Verify that the value satisfies the {@param check}.\n     */\n    satisfies(check) {\n        const result = check(this.actual);\n        if (!result.pass) {\n            return this.addError(`expected \"${asString(this.actual)}\" to satisfy condition: \"${result.message}\"`);\n        }\n        return noop;\n    }\n    /**\n     * Same as {@link satisfies} but the check function is async.\n     */\n    async asyncSatisfies(check) {\n        const result = await check(this.actual);\n        if (!result.pass) {\n            return this.addError(`expected \"${asString(this.actual)}\" to satisfy condition: \"${result.message}\"`);\n        }\n        return noop;\n    }\n    /** {@see satisfies} */\n    notSatisfies(check) {\n        const result = check(this.actual);\n        if (result.pass) {\n            return this.addError(`expected \"${asString(this.actual)}\" to NOT satisfy condition: \"${result.message}\"`);\n        }\n        return noop;\n    }\n    /**\n     * Verify that the value returned by the subject function matches the description.\n     * In case of a string description the message is matched, otherwise the error is checked by instanceof.\n     */\n    throws(errorDescription) {\n        if (typeof this.actual !== \"function\") {\n            throw new Error(`Value for throws() call is not a function! ${errorDescription}`);\n        }\n        try {\n            this.actual();\n            return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but nothing was thrown`);\n        }\n        catch (e) {\n            if (errorMatchesDescription(e, errorDescription)) {\n                return noop;\n            }\n            else {\n                return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but instead was thrown: ${this.errorName(e)}`);\n            }\n        }\n    }\n    /**\n     * Verity that the value returned by the subject function matches the description.\n     * In case of a string description the message is matched, otherwise the error is checked by instanceof.\n     */\n    async asyncThrows(errorDescription) {\n        if (typeof this.actual !== \"function\") {\n            throw new Error(`Value for throws() call is not a function! ${errorDescription}`);\n        }\n        try {\n            await this.actual();\n            return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but nothing was thrown`);\n        }\n        catch (e) {\n            if (errorMatchesDescription(e, errorDescription)) {\n                return noop;\n            }\n            else {\n                return this.addError(`Expected to be thrown: ${this.errorName(errorDescription)} but instead was thrown: ${this.errorName(e)}`);\n            }\n        }\n    }\n    addError(assertionDescription) {\n        const testError = { error: new AssertionError(assertionDescription), userMessage: null };\n        this.testResult.errors.push(testError);\n        return (userMessage) => {\n            testError.userMessage = userMessage;\n        };\n    }\n    errorName(error) {\n        return typeof error === \"string\" ? error : typeof error === \"function\" ? error.name : String(error);\n    }\n}\n/**\n * modified deepEquals from ospec is only needed as long as we use custom classes (TypeRef) and Date is not properly handled\n */\nfunction deepEqual(a, b) {\n    if (a === b)\n        return true;\n    if (xor(a === null, b === null) || xor(a === undefined, b === undefined))\n        return false;\n    if (typeof a === \"object\" && typeof b === \"object\") {\n        const aIsArgs = isArguments(a), bIsArgs = isArguments(b);\n        if (a.length === b.length && ((a instanceof Array && b instanceof Array) || (aIsArgs && bIsArgs))) {\n            const aKeys = Object.getOwnPropertyNames(a), bKeys = Object.getOwnPropertyNames(b);\n            if (aKeys.length !== bKeys.length)\n                return false;\n            for (let i = 0; i < aKeys.length; i++) {\n                if (!Object.hasOwn(b, aKeys[i]) || !deepEqual(a[aKeys[i]], b[aKeys[i]]))\n                    return false;\n            }\n            return true;\n        }\n        if (a instanceof Date && b instanceof Date)\n            return a.getTime() === b.getTime();\n        if (a instanceof Uint8Array && b instanceof Uint8Array) {\n            if (a.length != b.length)\n                return false;\n            for (let i = 0; i < a.length; i++) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        }\n        if (a instanceof Object && b instanceof Object && !aIsArgs && !bIsArgs) {\n            for (let i in a) {\n                if (!(i in b) || !deepEqual(a[i], b[i]))\n                    return false;\n            }\n            for (let i in b) {\n                if (!(i in a))\n                    return false;\n            }\n            return true;\n        }\n        // @ts-ignore: we would need to include all @types/node for this to work or import it explicitly. Should probably be rewritten for all typed arrays.\n        if (typeof Buffer === \"function\" && a instanceof Buffer && b instanceof Buffer) {\n            if (a.length != b.length)\n                return false;\n            for (let i = 0; i < a.length; i++) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        }\n        if (a.valueOf() === b.valueOf())\n            return true;\n    }\n    return false;\n}\nclass AssertionError extends Error {\n}\nfunction xor(a, b) {\n    return (a && !b) || (b && !a);\n}\nfunction isArguments(a) {\n    if (\"callee\" in a) {\n        for (const i in a)\n            if (i === \"callee\")\n                return false;\n        return true;\n    }\n}\nfunction errorMatchesDescription(e, errorDescription) {\n    if (e == null)\n        return false;\n    // make ts shut up, we know what we are doing here, we are ✨ professionals ✨ here\n    const erased = e;\n    return ((typeof errorDescription === \"string\" && typeof erased.message === \"string\" && erased.message === errorDescription) ||\n        e instanceof errorDescription);\n}\nfunction noop() { }\n","import { ansiSequences, fancy } from \"./fancy.js\";\nimport { Assertion } from \"./Assertion.js\";\nclass OTest {\n    static DEFAULT_TIMEOUT_MS = 200;\n    taskTree = { name: \"O\", specs: [], tests: [], before: [], after: [], beforeEach: [], afterEach: [] };\n    currentSpec = this.taskTree;\n    currentTest = null;\n    /**\n     * Define a group of tests.\n     * Spec may contain:\n     *  * tests\n     *  * before/beforeEach/after/afterEach clauses\n     *  * other specs\n     *\n     *  Example:\n     *  ```ts\n     *  o.spec(\"testableFunction\", () => {\n     *      o.test(\"it works\", () => {\n     *          o.check(testableFunction(1)).equals(2)\n     *      })\n     *  })\n     *  ```\n     */\n    spec(name, definition) {\n        const previousCurrentSpec = this.currentSpec;\n        const newSpec = (this.currentSpec = {\n            name,\n            tests: [],\n            specs: [],\n            before: [],\n            after: [],\n            beforeEach: [],\n            afterEach: [],\n        });\n        Object.defineProperty(definition, \"name\", { value: name, writable: false });\n        const definitionResult = definition();\n        if (typeof definitionResult !== \"undefined\") {\n            throw new Error(`Invalid spec definition for \"${previousCurrentSpec.name} > ${name}\"! Is it async by any chance?`);\n        }\n        this.currentSpec = previousCurrentSpec;\n        this.currentSpec.specs.push(newSpec);\n    }\n    /**\n     * Define a test.\n     * Tests may be async in which case they should either await or return a promise.\n     * Timeouts apply and can be changed with {@link timeout}.\n     */\n    test(name, definition) {\n        Object.defineProperty(definition, \"name\", { value: name, writable: false });\n        this.currentSpec.tests.push({ name, task: definition });\n    }\n    /**\n     * Start an assertion.\n     */\n    check(value) {\n        if (this.currentTest == null) {\n            throw new Error(\"Assertion outside of running test!\");\n        }\n        return new Assertion(value, this.currentTest);\n    }\n    /**\n     * Define a task to be executed before any test in the spec (once per spec).\n     */\n    before(task) {\n        this.currentSpec.before.push(task);\n    }\n    /**\n     * Define a task to be executed after all test in the spec (once per spec).\n     */\n    after(task) {\n        this.currentSpec.after.push(task);\n    }\n    /**\n     * Define a task to be executed before each test in the spec (once per test).\n     * Also applies to tests in nested specs.\n     */\n    beforeEach(task) {\n        this.currentSpec.beforeEach.push(task);\n    }\n    /**\n     * Define a task to be executed after each test in the spec (once per test).\n     * Also applies to tests in nested specs.\n     */\n    afterEach(task) {\n        this.currentSpec.afterEach.push(task);\n    }\n    /**\n     * Set a timeout (in ms) for the currently running test.\n     */\n    timeout(ms) {\n        if (this.currentTest === null) {\n            throw new Error(\"timeout() call outside of test\");\n        }\n        else if (this.currentTest.timeout != null) {\n            throw new Error(`timeout is already set! ${this.currentTest}`);\n        }\n        else {\n            this.currentTest.timeout = ms;\n        }\n    }\n    /**\n     * Run the tests that were previously defined.\n     * @param {string} filter: only run tests that match the filter string in either spec name or a test name.\n     */\n    async run({ filter } = {}) {\n        const runResult = { passedTests: [], failingTests: [], skippedTests: [] };\n        function processSpecResult(spec, path) {\n            const pathNames = path.map((s) => s.name).concat(spec.name);\n            for (const test of spec.testResults) {\n                if (test.errors.length) {\n                    runResult.failingTests.push({ path: pathNames, result: test });\n                }\n                else if (test.skipped) {\n                    runResult.skippedTests.push({ path: pathNames, result: test });\n                }\n                else {\n                    runResult.passedTests.push({ path: pathNames, result: test });\n                }\n            }\n            for (const subspec of spec.specResults) {\n                processSpecResult(subspec, [...path, spec]);\n            }\n        }\n        const topSpecResult = await this.runSpec(this.currentSpec, [], filter ?? \"\");\n        processSpecResult(topSpecResult, []);\n        return runResult;\n    }\n    async runSpec(spec, path, filter) {\n        const newPath = [...path, spec];\n        const newPathSerialized = newPath.map((s) => s.name).join(\" > \");\n        let printSpecOnce = () => {\n            printSpecOnce = () => { };\n            console.log(fancy(\"SPEC\", ansiSequences.greenBg), newPathSerialized);\n        };\n        for (const before of spec.before) {\n            try {\n                await before();\n            }\n            catch (e) {\n                console.error(\"Spec before() failed!\", newPathSerialized, e);\n                throw e;\n            }\n        }\n        const specMatches = filter === \"\" || spec.name.includes(filter);\n        const result = {\n            name: spec.name,\n            specResults: await promiseMap(spec.specs, (nestedSpec) => this.runSpec(nestedSpec, newPath, specMatches ? \"\" : filter)),\n            testResults: await promiseMap(spec.tests, async (test) => {\n                if (specMatches || test.name.includes(filter)) {\n                    printSpecOnce();\n                    printSpecOnce = () => { };\n                    const allBeforeEach = [...path.flatMap((s) => s.beforeEach), ...spec.beforeEach];\n                    for (const beforeEach of allBeforeEach) {\n                        await beforeEach();\n                    }\n                    console.log(\"  \", fancy(\"TEST\", ansiSequences.greenBg), test.name);\n                    const testResult = await this.runTest(test);\n                    const allAfterEach = [...path.flatMap((s) => s.afterEach), ...spec.afterEach];\n                    for (const afterEach of allAfterEach) {\n                        await afterEach();\n                    }\n                    return testResult;\n                }\n                else {\n                    return { name: test.name, errors: [], timeout: null, skipped: true };\n                }\n            }),\n        };\n        for (const after of spec.after) {\n            try {\n                await after();\n            }\n            catch (e) {\n                console.error(\"Spec after() failed!\", newPathSerialized, e);\n                throw e;\n            }\n        }\n        return result;\n    }\n    /**\n     * Output the result of the test run.\n     * @param result\n     */\n    printReport(result) {\n        console.log(`\n\n${fancy(\"TEST FINISHED\", ansiSequences.bold)}\n\n${result.filter ? `filter: \"${result.filter}\"` : \"\"}\n\n${fancy(\"passing\", ansiSequences.greenBg)}: ${result.passedTests.length} ${fancy(\"failing\", ansiSequences.redBg)}: ${result.failingTests.length} ${fancy(\"skipped\", ansiSequences.yellowBg)}: ${result.skippedTests.length}`, \"\\n\");\n        for (const test of result.failingTests) {\n            console.error(fancy(\"FAIL\", ansiSequences.redBg), test.path.join(\" > \"), \"|\", test.result.name);\n            for (const error of test.result.errors) {\n                if (error.userMessage) {\n                    console.error(fancy(error.userMessage, ansiSequences.redFg));\n                }\n                console.error(error.error);\n                console.log();\n            }\n        }\n    }\n    /**\n     * A utility to exit the process with the appropriate exit code.\n     * only runs in node, no-op otherwise.\n     */\n    terminateProcess(result) {\n        if (typeof process !== \"undefined\") {\n            process.exit(result.failingTests.length ? 1 : 0);\n        }\n    }\n    async runTest(test) {\n        const currentTestResult = (this.currentTest = { name: test.name, errors: [], timeout: null, skipped: false });\n        let testResolved = false;\n        async function startTimeoutTask() {\n            await new Promise((resolve) => {\n                if (currentTestResult.timeout == null)\n                    throw new Error(\"timeout not set while running timeout task!\");\n                setTimeout(resolve, currentTestResult.timeout);\n            });\n            if (!testResolved) {\n                throw new Error(\"timed out!\");\n            }\n        }\n        async function runTask() {\n            try {\n                const p = test.task();\n                currentTestResult.timeout = currentTestResult.timeout ?? OTest.DEFAULT_TIMEOUT_MS;\n                await p;\n            }\n            finally {\n                testResolved = true;\n            }\n        }\n        try {\n            // run task and timeout in parallel, if timeout counter comes first, we are timeout out\n            // the test task should set the timeout immediately or we will not pick it up.\n            await Promise.race([runTask(), startTimeoutTask()]);\n        }\n        catch (e) {\n            currentTestResult.errors.push({ error: wrapError(e), userMessage: null });\n        }\n        finally {\n            this.currentTest = null;\n        }\n        return currentTestResult;\n    }\n}\nfunction wrapError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nasync function promiseMap(array, mapper) {\n    const result = [];\n    for (const el of array) {\n        result.push(await mapper(el));\n    }\n    return result;\n}\nconst otest = new OTest();\nfunction o(item, definition) {\n    // we need to do these tricks otherwise \"this\" reference will be lost\n    const oo = o;\n    if (typeof definition === \"undefined\") {\n        return oo.check(item);\n    }\n    else {\n        oo.test(item, definition);\n    }\n}\nObject.assign(o, otest);\nObject.setPrototypeOf(o, Object.getPrototypeOf(otest));\nexport default o;\n","import o from \"./otest.js\";\nexport default o;\n"],"mappings":"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"}