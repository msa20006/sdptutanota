
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { typedValues, uint8ArrayToBase64 } from "./dist-CJHwsXKY.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { getColorLuminance, isMonochrome, theme } from "./HtmlUtils-C-ecR7U7.js";
import { ButtonType } from "./Icon-BuqNK7vz.js";
import { Dialog, DialogHeaderBar, DialogType, TextField } from "./Dialog-B6-HFvZd.js";
import { AccessDeactivatedError, AccessExpiredError, InvalidDataError } from "./RestError-D17JEBMr.js";
import { createCreditCard, createRegistrationCaptchaServiceData, createRegistrationCaptchaServiceGetData } from "./TypeRefs-BP1jvX9p.js";
import { RegistrationCaptchaService } from "./Services-CZFE0084.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { isValidCreditCardNumber } from "./FormatValidator-2BBermUe.js";
import { deviceConfig } from "./DeviceConfig-payZM407.js";

//#region ../src/common/subscription/SimplifiedCreditCardInputModel.ts
let CardType = function(CardType$1) {
	CardType$1["Amex"] = "Amex";
	CardType$1["Visa"] = "Visa";
	CardType$1["Mastercard"] = "Mastercard";
	CardType$1["Maestro"] = "Maestro";
	CardType$1["Discover"] = "Discover";
	CardType$1["Other"] = "Other";
	return CardType$1;
}({});
function getCardTypeRange(cc) {
	for (let cardType of typedValues(CardType)) {
		if (cardType === CardType.Other) continue;
		for (let range of CardPrefixRanges[cardType]) {
			const lowestRange = range[0].padEnd(8, "0");
			const highestRange = range[1].padEnd(8, "9");
			const lowestCC = cc.slice(0, 8).padEnd(8, "0");
			const highestCC = cc.slice(0, 8).padEnd(8, "9");
			if (lowestRange <= lowestCC && highestCC <= highestRange) return cardType;
		}
	}
	return CardType.Other;
}
const CardSpecs = Object.freeze({
	[CardType.Visa]: {
		cvvLength: 3,
		cvvName: "CVV",
		name: "Visa"
	},
	[CardType.Mastercard]: {
		cvvLength: 3,
		cvvName: "CVC",
		name: "Mastercard"
	},
	[CardType.Maestro]: {
		cvvLength: 3,
		cvvName: "CVV",
		name: "Maestro"
	},
	[CardType.Amex]: {
		cvvLength: 4,
		cvvName: "CSC",
		name: "American Express"
	},
	[CardType.Discover]: {
		cvvLength: 3,
		cvvName: "CVD",
		name: "Discover"
	},
	[CardType.Other]: {
		cvvLength: null,
		cvvName: "CVV",
		name: null
	}
});
const CardPrefixRanges = Object.freeze({
	[CardType.Visa]: [["4", "4"]],
	[CardType.Mastercard]: [["51", "55"], ["2221", "2720"]],
	[CardType.Maestro]: [
		["6759", "6759"],
		["676770", "676770"],
		["676774", "676774"],
		["5018", "5018"],
		["5020", "5020"],
		["5038", "5038"],
		["5893", "5893"],
		["6304", "6304"],
		["6759", "6759"],
		["6761", "6763"]
	],
	[CardType.Amex]: [["34", "34"], ["37", "37"]],
	[CardType.Discover]: [
		["6011", "6011"],
		["644", "649"],
		["65", "65"],
		["622126", "622925"]
	],
	[CardType.Other]: [[]]
});
const allDigits = [
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9"
];
const definiteMonthDigits = [
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9"
];
const secondMonthDigits = [
	"0",
	"1",
	"2"
];
const separator = "/";
const niceSeparator = ` ${separator} `;
/**
* completely strip all whitespace from a string
* @param s the string to clean up
*/
function stripWhitespace(s) {
	return s.replace(/\s/g, "");
}
function stripNonDigits(s) {
	return s.replace(/\D/g, "");
}
function isDigitString(s) {
	if (s.length === 0) return false;
	const matches = s.match(/\d/g);
	return matches != null && matches.length === s.length;
}
/**
* take a function that corrects whitespace on input that does not contain whitespace
* and return one that does the same on input that contains arbitrary whitespace.
* @param fn a function that does not deal with whitespace-containing or empty input
*/
function normalizeInput(fn) {
	return (v, ov = "") => {
		v = stripWhitespace(v);
		if (v === "") return v;
		ov = stripWhitespace(ov);
		return fn(v, ov);
	};
}
function nomDigitsUntilLength(rest, ret, length) {
	while (rest.length > 0 && ret.length < length) {
		const next = rest[0];
		rest = rest.slice(1);
		if (allDigits.includes(next)) ret += next;
else {
			rest = "";
			break;
		}
	}
	return {
		rest,
		ret
	};
}
const inferExpirationDate = normalizeInput(inferNormalizedExpirationDate);
/**
*
* @param value non-empty string without whitespace specifying a (potentially partial) date as a sequence of 0 to 6 digits.
* @param oldDate previous value
*/
function inferNormalizedExpirationDate(value, oldDate) {
	if (oldDate.startsWith(value) && value.endsWith(separator)) return value.slice(0, -1);
	if (!allDigits.includes(value[0])) return "";
	let rest = value;
	let ret = "";
	if (definiteMonthDigits.includes(rest[0])) {
		ret = "0" + rest[0];
		rest = rest.slice(1);
	} else if (rest[0] === "0") {
		ret = "0";
		rest = rest.slice(1);
		if (rest[0] === "0") return "0";
else if (allDigits.includes(rest[0])) {
			ret = "0" + rest[0];
			rest = rest.slice(1);
		} else return "0";
	} else if (value.length > 1) {
		rest = rest.slice(1);
		if (secondMonthDigits.includes(rest[0])) {
			ret = "1" + rest[0];
			rest = rest.slice(1);
		} else if (allDigits.includes(rest[0])) ret = "01";
else if (rest[0] === separator) ret = "01";
else return "1";
	} else return "1";
	let hadSlash = false;
	while (rest.startsWith(separator)) {
		hadSlash = true;
		rest = rest.slice(1);
	}
	if (ret.length === 2 && rest.length > 0 || hadSlash || value.length > oldDate.length) ret += separator;
	({rest, ret} = nomDigitsUntilLength(rest, ret, "xx/xx".length));
	if (!ret.endsWith("/20")) return ret.replace(separator, niceSeparator);
	({ret} = nomDigitsUntilLength(rest, ret, "xx/xxxx".length));
	return ret.replace(separator, niceSeparator);
}
/**
* take a sequence of digits and other characters, strip non-digits and group the rest into space-separated groups.
* @param value non-empty string without whitespace specifying a (potentially partial) credit card number
* @param groups most credit card number digits are grouped in groups of 4, but there are exceptions
*/
function groupCreditCardNumber(value, groups = [
	4,
	4,
	4,
	4,
	4
]) {
	value = stripNonDigits(value);
	value = value.slice(0, 20);
	let ret = value.slice(0, groups[0]);
	value = value.slice(groups[0]);
	for (let i = 1; i < groups.length && value.length > 0; i++) {
		ret += " ";
		ret += value.slice(0, groups[i]);
		value = value.slice(groups[i]);
	}
	return ret;
}
function getExpirationMonthAndYear(expirationDate) {
	if (expirationDate.length < "xx / xx".length || !expirationDate.includes(" / ")) return null;
	const [monthString, yearString] = expirationDate.split(" / ").map((p) => p.trim());
	if (!isDigitString(monthString) || !isDigitString(yearString)) return null;
	const monthNumber = Number(monthString);
	if (monthNumber < 1 || monthNumber > 12) return null;
	const yearNumber = Number(yearString);
	if (yearString.length === 4 && yearString.startsWith("20")) return {
		year: Math.floor(yearNumber) - 2e3,
		month: Math.floor(monthNumber)
	};
else if (yearString.length === 2) return {
		year: Math.floor(yearNumber),
		month: Math.floor(monthNumber)
	};
else return null;
}
var SimplifiedCreditCardViewModel = class {
	_cardHolderName = "";
	_creditCardNumber = "";
	_cvv = "";
	_expirationDate = "";
	creditCardType = CardType.Other;
	constructor(lang$1) {
		this.lang = lang$1;
	}
	get expirationDate() {
		return this._expirationDate;
	}
	set expirationDate(value) {
		this._expirationDate = inferExpirationDate(value, this._expirationDate);
	}
	get cvv() {
		return this._cvv;
	}
	set cvv(value) {
		const correctedCvv = stripWhitespace(stripNonDigits(value));
		this._cvv = correctedCvv.slice(0, 4);
	}
	get creditCardNumber() {
		return this._creditCardNumber;
	}
	set creditCardNumber(value) {
		let cleanedNumber = stripNonDigits(stripWhitespace(value));
		this.creditCardType = getCardTypeRange(cleanedNumber);
		this._creditCardNumber = this.creditCardType === CardType.Amex ? groupCreditCardNumber(cleanedNumber, [
			4,
			6,
			5,
			5
		]) : groupCreditCardNumber(cleanedNumber);
	}
	get cardHolderName() {
		return this._cardHolderName;
	}
	set cardHolderName(value) {}
	validateCreditCardPaymentData() {
		const cc = this.getCreditCardData();
		const invalidNumber = this.validateCreditCardNumber(cc.number);
		if (invalidNumber) return invalidNumber;
		const invalidCVV = this.validateCVV(cc.cvv);
		if (invalidCVV) return invalidCVV;
		const invalidExpirationDate = this.getExpirationDateErrorHint();
		if (invalidExpirationDate) return invalidExpirationDate;
		return null;
	}
	validateCreditCardNumber(number) {
		if (number === "") return "creditCardNumberFormat_msg";
else if (!isValidCreditCardNumber(number)) return "creditCardNumberInvalid_msg";
		return null;
	}
	validateCVV(cvv) {
		if (cvv.length < 3 || cvv.length > 4) return "creditCardCVVFormat_label";
		return null;
	}
	getCreditCardNumberHint() {
		const spec = CardSpecs[this.creditCardType];
		if (this.creditCardType === CardType.Other) return null;
		return spec.name;
	}
	getCreditCardNumberErrorHint() {
		return this.validateCreditCardNumber(this._creditCardNumber) ? this.lang.get("creditCardNumberInvalid_msg") : null;
	}
	/**
	* return a translation string detailing what's wrong with the
	* contents of the expiration date field, if any.
	*/
	getExpirationDateErrorHint() {
		const expiration = getExpirationMonthAndYear(this._expirationDate);
		if (expiration == null) return "creditCardExprationDateInvalid_msg";
		const today = new Date();
		const currentYear = today.getFullYear() - 2e3;
		const currentMonth = today.getMonth() + 1;
		const { year, month } = expiration;
		if (year > currentYear || year === currentYear && month >= currentMonth) return null;
		return "creditCardExpired_msg";
	}
	getCvvHint() {
		if (this.creditCardType === CardType.Other) return null;
else {
			const spec = CardSpecs[this.creditCardType];
			return this.lang.get("creditCardCvvHint_msg", {
				"{currentDigits}": this.cvv.length,
				"{totalDigits}": spec.cvvLength
			});
		}
	}
	getCvvErrorHint() {
		const spec = CardSpecs[this.creditCardType];
		return this.validateCVV(this.cvv) ? this.lang.get("creditCardSpecificCVVInvalid_msg", { "{securityCode}": spec.cvvName }) : null;
	}
	getCvvLabel() {
		if (this.creditCardType === CardType.Other) return this.lang.get("creditCardCvvLabelLong_label", { "{cvvName}": CardSpecs[CardType.Other].cvvName });
else {
			const spec = CardSpecs[this.creditCardType];
			return this.lang.get("creditCardCvvLabelLong_label", { "{cvvName}": spec.cvvName });
		}
	}
	getCreditCardData() {
		const expiration = getExpirationMonthAndYear(this._expirationDate);
		let cc = createCreditCard({
			number: stripWhitespace(this._creditCardNumber),
			cardHolderName: this._cardHolderName,
			cvv: this._cvv,
			expirationMonth: expiration ? String(expiration.month) : "",
			expirationYear: expiration ? String(expiration.year) : ""
		});
		return cc;
	}
	setCreditCardData(data) {
		if (data) {
			this.creditCardNumber = data.number;
			this.cvv = data.cvv;
			if (data.expirationMonth && data.expirationYear) this.expirationDate = data.expirationMonth + " / " + data.expirationYear;
		} else {
			this._creditCardNumber = "";
			this._cvv = "";
			this._expirationDate = "";
		}
	}
};

//#endregion
//#region ../src/common/subscription/Captcha.ts
function parseCaptchaInput(captchaInput) {
	if (captchaInput.match(/^[0-2]?[0-9]:[0-5]?[0-9]$/)) {
		let [h, m] = captchaInput.trim().split(":").map((t) => Number(t));
		if (h > 24) return null;
		return [h % 12, m].map((a) => String(a).padStart(2, "0")).join(":");
	} else return null;
}
async function runCaptchaFlow(mailAddress, isBusinessUse, isPaidSubscription, campaignToken) {
	try {
		const captchaReturn = await locator.serviceExecutor.get(RegistrationCaptchaService, createRegistrationCaptchaServiceGetData({
			token: campaignToken,
			mailAddress,
			signupToken: deviceConfig.getSignupToken(),
			businessUseSelected: isBusinessUse,
			paidSubscriptionSelected: isPaidSubscription
		}));
		if (captchaReturn.challenge) try {
			return await showCaptchaDialog(captchaReturn.challenge, captchaReturn.token);
		} catch (e) {
			if (e instanceof InvalidDataError) {
				await Dialog.message("createAccountInvalidCaptcha_msg");
				return runCaptchaFlow(mailAddress, isBusinessUse, isPaidSubscription, campaignToken);
			} else if (e instanceof AccessExpiredError) {
				await Dialog.message("createAccountAccessDeactivated_msg");
				return null;
			} else throw e;
		}
else return captchaReturn.token;
	} catch (e) {
		if (e instanceof AccessDeactivatedError) {
			await Dialog.message("createAccountAccessDeactivated_msg");
			return null;
		} else throw e;
	}
}
function showCaptchaDialog(challenge, token) {
	return new Promise((resolve, reject) => {
		let dialog;
		let captchaInput = "";
		const cancelAction = () => {
			dialog.close();
			resolve(null);
		};
		const okAction = () => {
			let parsedInput = parseCaptchaInput(captchaInput);
			if (parsedInput == null) {
				Dialog.message("captchaEnter_msg");
				return;
			}
			const minuteOnesPlace = parsedInput[parsedInput.length - 1];
			if (minuteOnesPlace !== "0" && minuteOnesPlace !== "5") {
				Dialog.message("createAccountInvalidCaptcha_msg");
				return;
			}
			dialog.close();
			locator.serviceExecutor.post(RegistrationCaptchaService, createRegistrationCaptchaServiceData({
				token,
				response: parsedInput
			})).then(() => {
				resolve(token);
			}).catch((e) => {
				reject(e);
			});
		};
		let actionBarAttrs = {
			left: [{
				label: "cancel_action",
				click: cancelAction,
				type: ButtonType.Secondary
			}],
			right: [{
				label: "ok_action",
				click: okAction,
				type: ButtonType.Primary
			}],
			middle: "captchaDisplay_label"
		};
		const imageData = `data:image/png;base64,${uint8ArrayToBase64(challenge)}`;
		dialog = new Dialog(DialogType.EditSmall, { view: () => {
			let captchaFilter = {};
			if (theme.elevated_bg != null && isMonochrome(theme.elevated_bg)) captchaFilter = { filter: `invert(${1 - getColorLuminance(theme.elevated_bg)}` };
			return [mithril_default(DialogHeaderBar, actionBarAttrs), mithril_default(".plr-l.pb", [mithril_default("img.pt-ml.center-h.block", {
				src: imageData,
				alt: lang.get("captchaDisplay_label"),
				style: captchaFilter
			}), mithril_default(TextField, {
				label: lang.makeTranslation("captcha_input", lang.get("captchaInput_label") + " (hh:mm)"),
				helpLabel: () => lang.get("captchaInfo_msg"),
				value: captchaInput,
				oninput: (value) => captchaInput = value
			})])];
		} }).setCloseHandler(cancelAction).show();
	});
}

//#endregion
export { CardType, SimplifiedCreditCardViewModel, getCardTypeRange, inferExpirationDate, parseCaptchaInput, runCaptchaFlow };
//# sourceMappingURL=Captcha-BgtCMZz1.js.map