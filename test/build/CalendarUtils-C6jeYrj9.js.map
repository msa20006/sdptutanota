{"version":3,"file":"CalendarUtils-C6jeYrj9.js","names":["currentDate: Date","zone: string","event: CalendarEvent","date: Date","groupId: Id","timestamp: number","uid?: string | null","interval: AlarmInterval","ianaTimeZone?: string","utcDate: Date","repeatPeriod: RepeatPeriod","interval: number","ianaTimeZone: string","fallback?: string","frequency: RepeatPeriod","timeZone: string","a: Date","b: Date","zone?: string","firstDayOfWeekFromOffset: number","startDay: Date","numDays: number","days: Date[]","weekStart: WeekStart","userSettingsGroupRoot: UserSettingsGroupRoot","startOfTheWeek: Date","event: CalendarEventTimes","startTime: Date","endTime: Date","groupRoot: CalendarGroupRoot","left: Pick<CalendarEvent, \"_id\" | \"startTime\">","right: Pick<CalendarEvent, \"_id\" | \"startTime\">","user: User","l: CalendarEvent","r: CalendarEvent","daysToEvents: Map<number, Array<CalendarEvent>>","range: CalendarTimeRange","progenitors: ReadonlyArray<CalendarEvent>","max: number","ret: Array<CalendarEvent>","previousCandidate: CalendarEvent","generator: Generator<{\n\t\t\tstartTime: Date\n\t\t\tendTime: Date\n\t\t}>","excludedDates: Array<DateWrapper>","generators: Array<{\n\t\tgenerator: Generator<{ startTime: Date; endTime: Date }>\n\t\texcludedDates: Array<DateWrapper>\n\t\tnextCandidate: CalendarEvent\n\t}>","repeatRule: RepeatRule","isAllDay: boolean","repeatEndTime: Date | null","endOccurrences: number | null","excludedDates: ReadonlyArray<DateWrapper>","now: Date","eventStart: Date","eventEnd: Date","endType: EndType","endValue: number","exclusions: Array<Date>","alarmTrigger: AlarmInterval","localTimeZone: string","isAllDayEvent","sequence: string","calendarInfo: ReadonlyMap<Id, CalendarInfo>","description: string","sanitizer: (s: string) => string","day: Date","selectedDate: Date | null","ev: CalendarEvent","endDay: Date","time: Time","firstDay: Date","lastDay: Date","d: Date","calendarEvent: CalendarEvent","entityClient: EntityClient","start: number","end: number","min: number","alarmInterval: AlarmInterval","e1: ReadonlyArray<DateWrapper>","e2: ReadonlyArray<DateWrapper>","r1: CalendarRepeatRule | null","r2: CalendarRepeatRule | null","serialized: string","calendarId: Id","calendarType: CalendarType","groupSettings: GroupSettings | null | undefined","groupSettings: GroupSettings | null","groupInfo: GroupInfo","birthday: string | null","logins: LoginController","events: IdTuple[]","localEvents: Map<number, BirthdayEventRegistry[]>","retrievedEvents: CalendarEvent[]","birthYear: number | null","currentYear: number","id: string | null | undefined"],"sources":["../../src/common/calendar/date/CalendarUtils.ts"],"sourcesContent":["import {\n\tassert,\n\tclone,\n\tdecodeBase64,\n\tdeepEqual,\n\tdowncast,\n\tfilterInt,\n\tfindAllAndRemove,\n\tgetFirstOrThrow,\n\tgetFromMap,\n\tgetStartOfDay,\n\tincrementDate,\n\tinsertIntoSortedArray,\n\tisNotNull,\n\tisSameDayOfDate,\n\tisValidDate,\n\tneverNull,\n\tTIMESTAMP_ZERO_YEAR,\n} from \"@tutao/tutanota-utils\"\nimport {\n\tCLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID,\n\tCLIENT_ONLY_CALENDARS,\n\tEndType,\n\tEventTextTimeOption,\n\tgetWeekStart,\n\tRepeatPeriod,\n\tTimeFormat,\n\tWeekStart,\n} from \"../../api/common/TutanotaConstants\"\nimport { DateTime, DurationLikeObject, FixedOffsetZone, IANAZone } from \"luxon\"\nimport {\n\tCalendarEvent,\n\tCalendarEventTypeRef,\n\tCalendarGroupRoot,\n\tCalendarRepeatRule,\n\tcreateCalendarRepeatRule,\n\tGroupSettings,\n\tUserSettingsGroupRoot,\n} from \"../../api/entities/tutanota/TypeRefs.js\"\nimport { CalendarEventTimes, DAYS_SHIFTED_MS, generateEventElementId, isAllDayEvent, isAllDayEventByTimes } from \"../../api/common/utils/CommonCalendarUtils\"\nimport { createDateWrapper, DateWrapper, GroupInfo, RepeatRule, User } from \"../../api/entities/sys/TypeRefs.js\"\nimport { isSameId } from \"../../api/common/utils/EntityUtils\"\nimport type { Time } from \"./Time.js\"\nimport { CalendarInfo } from \"../../../calendar-app/calendar/model/CalendarModel\"\nimport { DateProvider } from \"../../api/common/DateProvider\"\nimport { EntityClient } from \"../../api/common/EntityClient.js\"\nimport { CalendarEventUidIndexEntry } from \"../../api/worker/facades/lazy/CalendarFacade.js\"\nimport { ParserError } from \"../../misc/parsing/ParserCombinator.js\"\nimport { LoginController } from \"../../api/main/LoginController.js\"\nimport { BirthdayEventRegistry } from \"./CalendarEventsRepository.js\"\n\nexport type CalendarTimeRange = {\n\tstart: number\n\tend: number\n}\n\nexport function eventStartsBefore(currentDate: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventStart(event, zone).getTime() < currentDate.getTime()\n}\n\nexport function eventEndsBefore(date: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventEnd(event, zone).getTime() < date.getTime()\n}\n\nexport function eventStartsAfter(date: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventStart(event, zone).getTime() > date.getTime()\n}\n\nexport function eventEndsAfterDay(currentDate: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventEnd(event, zone).getTime() > getStartOfNextDayWithZone(currentDate, zone).getTime()\n}\n\nexport function eventEndsAfterOrOn(currentDate: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventEnd(event, zone).getTime() >= getStartOfNextDayWithZone(currentDate, zone).getTime()\n}\n\nexport function generateUid(groupId: Id, timestamp: number): string {\n\treturn `${groupId}${timestamp}@tuta.com`\n}\n\nexport function isBirthdayEvent(uid?: string | null) {\n\treturn uid?.includes(CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID) ?? false\n}\n\n/** get the timestamps of the start date and end date of the month the given date is in. */\nexport function getMonthRange(date: Date, zone: string): CalendarTimeRange {\n\tconst startDateTime = DateTime.fromJSDate(date, {\n\t\tzone,\n\t}).set({\n\t\tday: 1,\n\t\thour: 0,\n\t\tminute: 0,\n\t\tsecond: 0,\n\t\tmillisecond: 0,\n\t})\n\tconst start = startDateTime.toJSDate().getTime()\n\tconst end = startDateTime\n\t\t.plus({\n\t\t\tmonth: 1,\n\t\t})\n\t\t.toJSDate()\n\t\t.getTime()\n\treturn {\n\t\tstart,\n\t\tend,\n\t}\n}\n\nexport function getDayRange(date: Date, zone: string): CalendarTimeRange {\n\tconst startDateTime = DateTime.fromJSDate(date, {\n\t\tzone,\n\t}).set({\n\t\thour: 0,\n\t\tminute: 0,\n\t\tsecond: 0,\n\t\tmillisecond: 0,\n\t})\n\tconst start = startDateTime.toJSDate().getTime()\n\tconst end = startDateTime\n\t\t.plus({\n\t\t\tday: 1,\n\t\t})\n\t\t.toJSDate()\n\t\t.getTime()\n\treturn {\n\t\tstart,\n\t\tend,\n\t}\n}\n\n/**\n * @param date a date object representing a calendar date (like 1st of May 2023 15:15) in {@param zone}\n * @param zone the time zone to calculate which calendar date {@param date} represents.\n * @returns a date object representing the beginning of the given day in local time, like 1st of May 2023 00:00)\n */\nexport function getStartOfDayWithZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }).toJSDate()\n}\n\n/** @param date a date object representing some time on some calendar date (like 1st of May 2023) in {@param zone}\n * @param zone the time zone for which to calculate the calendar date that {@param date} represents\n * @returns a date object representing the start of the next calendar date (2nd of May 2023 00:00) in {@param zone} */\nexport function getStartOfNextDayWithZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }).plus({ day: 1 }).toJSDate()\n}\n\nexport function getEndOfDayWithZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).set({ hour: 23, minute: 59, second: 59, millisecond: 0 }).toJSDate()\n}\n\nexport function calculateAlarmTime(date: Date, interval: AlarmInterval, ianaTimeZone?: string): Date {\n\tconst diff = alarmIntervalToLuxonDurationLikeObject(interval)\n\n\treturn DateTime.fromJSDate(date, {\n\t\tzone: ianaTimeZone,\n\t})\n\t\t.minus(diff)\n\t\t.toJSDate()\n}\n\n/** takes a date which encodes the day in UTC and produces a date that encodes the same date but in local time zone. All times must be 0. */\nexport function getAllDayDateForTimezone(utcDate: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(utcDate, { zone: \"utc\" })\n\t\t.setZone(zone, { keepLocalTime: true })\n\t\t.set({ hour: 0, minute: 0, second: 0, millisecond: 0 })\n\t\t.toJSDate()\n}\n\nexport function incrementByRepeatPeriod(date: Date, repeatPeriod: RepeatPeriod, interval: number, ianaTimeZone: string): Date {\n\tswitch (repeatPeriod) {\n\t\tcase RepeatPeriod.DAILY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tdays: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tcase RepeatPeriod.WEEKLY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tweeks: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tcase RepeatPeriod.MONTHLY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tmonths: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tcase RepeatPeriod.ANNUALLY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tyears: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tdefault:\n\t\t\tthrow new Error(\"Unknown repeat period\")\n\t}\n}\n\nexport function getValidTimeZone(zone: string, fallback?: string): string {\n\tif (IANAZone.isValidZone(zone)) {\n\t\treturn zone\n\t} else {\n\t\tif (fallback && IANAZone.isValidZone(fallback)) {\n\t\t\tconsole.warn(`Time zone ${zone} is not valid, falling back to ${fallback}`)\n\t\t\treturn fallback\n\t\t} else {\n\t\t\tconst actualFallback = FixedOffsetZone.instance(new Date().getTimezoneOffset()).name\n\t\t\tconsole.warn(`Fallback time zone ${zone} is not valid, falling back to ${actualFallback}`)\n\t\t\treturn actualFallback\n\t\t}\n\t}\n}\n\nexport function getTimeZone(): string {\n\treturn DateTime.local().zoneName\n}\n\nexport class DefaultDateProvider implements DateProvider {\n\tnow(): number {\n\t\treturn Date.now()\n\t}\n\n\ttimeZone(): string {\n\t\treturn getTimeZone()\n\t}\n}\n\nexport function createRepeatRuleWithValues(frequency: RepeatPeriod, interval: number, timeZone: string = getTimeZone()): CalendarRepeatRule {\n\treturn createCalendarRepeatRule({\n\t\ttimeZone: timeZone,\n\t\tfrequency: frequency,\n\t\tinterval: String(interval),\n\t\tendValue: null,\n\t\tendType: \"0\",\n\t\texcludedDates: [],\n\t\tadvancedRules: [],\n\t})\n}\n\n/**\n * difference in whole 24-hour-intervals between two dates, not anticommutative.\n * Result is positive or 0 if b > a, result is negative or 0 otherwise\n */\nexport function getDiffIn24hIntervals(a: Date, b: Date, zone?: string): number {\n\treturn Math.floor(DateTime.fromJSDate(b, { zone }).diff(DateTime.fromJSDate(a, { zone }), \"day\").days)\n}\n\n/**\n * difference in whole 60 minute intervals between two dates\n * result is 0 if the diff is less than 60 minutes, otherwise\n * positive if b is after a, otherwise negative.\n *\n * not anticommutative.\n */\nexport function getDiffIn60mIntervals(a: Date, b: Date): number {\n\treturn Math.floor(DateTime.fromJSDate(b).diff(DateTime.fromJSDate(a), \"hours\").hours)\n}\n\nexport function getStartOfWeek(date: Date, firstDayOfWeekFromOffset: number): Date {\n\tlet firstDay\n\n\tif (firstDayOfWeekFromOffset > date.getDay()) {\n\t\tfirstDay = date.getDay() + 7 - firstDayOfWeekFromOffset\n\t} else {\n\t\tfirstDay = date.getDay() - firstDayOfWeekFromOffset\n\t}\n\n\treturn incrementDate(getStartOfDay(date), -firstDay)\n}\n\nexport function getRangeOfDays(startDay: Date, numDays: number): Array<Date> {\n\tlet calculationDate = startDay\n\tconst days: Date[] = []\n\n\tfor (let i = 0; i < numDays; i++) {\n\t\tdays.push(calculationDate)\n\t\tcalculationDate = incrementDate(new Date(calculationDate), 1)\n\t}\n\n\treturn days\n}\n\n/** Start of the week offset relative to Sunday (forward). */\nexport function getStartOfTheWeekOffset(weekStart: WeekStart): number {\n\tswitch (weekStart) {\n\t\tcase WeekStart.SUNDAY:\n\t\t\treturn 0\n\n\t\tcase WeekStart.SATURDAY:\n\t\t\treturn 6\n\n\t\tcase WeekStart.MONDAY:\n\t\tdefault:\n\t\t\treturn 1\n\t}\n}\n\n/** {@see getStartOfTheWeekOffset} */\nexport function getStartOfTheWeekOffsetForUser(userSettingsGroupRoot: UserSettingsGroupRoot): number {\n\treturn getStartOfTheWeekOffset(getWeekStart(userSettingsGroupRoot))\n}\n\nexport function getTimeFormatForUser(userSettingsGroupRoot: UserSettingsGroupRoot): TimeFormat {\n\t// it's saved as a string, but is a const enum.\n\treturn userSettingsGroupRoot.timeFormat as TimeFormat\n}\n\nexport function getWeekNumber(startOfTheWeek: Date): number {\n\t// Currently it doesn't support US-based week numbering system with partial weeks.\n\treturn DateTime.fromJSDate(startOfTheWeek).weekNumber\n}\n\nexport function getEventEnd(event: CalendarEventTimes, timeZone: string): Date {\n\tif (isAllDayEvent(event)) {\n\t\treturn getAllDayDateForTimezone(event.endTime, timeZone)\n\t} else {\n\t\treturn event.endTime\n\t}\n}\n\nexport function getEventStart({ startTime, endTime }: CalendarEventTimes, timeZone: string): Date {\n\treturn getEventStartByTimes(startTime, endTime, timeZone)\n}\n\nexport function getEventStartByTimes(startTime: Date, endTime: Date, timeZone: string): Date {\n\tif (isAllDayEventByTimes(startTime, endTime)) {\n\t\treturn getAllDayDateForTimezone(startTime, timeZone)\n\t} else {\n\t\treturn startTime\n\t}\n}\n\n/** @param date encodes some calendar date in {@param zone} (like the 1st of May 2023)\n * @returns {Date} encodes the same calendar date in UTC */\nexport function getAllDayDateUTCFromZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).setZone(\"utc\", { keepLocalTime: true }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }).toJSDate()\n}\n\nexport function isLongEvent(event: CalendarEvent, zone: string): boolean {\n\t// long events are longer than the event ID randomization range. we need to distinguish them\n\t// to be able to still load and display the ones overlapping the query range even though their\n\t// id might not be contained in the query timerange +- randomization range.\n\t// this also applies to events that repeat.\n\treturn event.repeatRule != null || getEventEnd(event, zone).getTime() - getEventStart(event, zone).getTime() > DAYS_SHIFTED_MS\n}\n\n/** create an event id depending on the calendar it is in and on its length */\nexport function assignEventId(event: CalendarEvent, zone: string, groupRoot: CalendarGroupRoot): void {\n\tconst listId = isLongEvent(event, zone) ? groupRoot.longEvents : groupRoot.shortEvents\n\tevent._id = [listId, generateEventElementId(event.startTime.getTime())]\n}\n\n/** predicate that tells us if two CalendarEvent objects refer to the same instance or different ones.*/\nexport function isSameEventInstance(left: Pick<CalendarEvent, \"_id\" | \"startTime\">, right: Pick<CalendarEvent, \"_id\" | \"startTime\">): boolean {\n\t// in addition to the id we compare the start time equality to be able to distinguish repeating events. They have the same id but different start time.\n\t// altered events with recurrenceId never have the same Id as another event instance, but might start at the same time.\n\treturn isSameId(left._id, right._id) && left.startTime.getTime() === right.startTime.getTime()\n}\n\nexport function hasAlarmsForTheUser(user: User, event: CalendarEvent): boolean {\n\tconst useAlarmList = neverNull(user.alarmInfoList).alarms\n\treturn event.alarmInfos.some(([listId]) => isSameId(listId, useAlarmList))\n}\n\nexport function eventComparator(l: CalendarEvent, r: CalendarEvent): number {\n\treturn l.startTime.getTime() - r.startTime.getTime()\n}\n\nfunction assertDateIsValid(date: Date) {\n\tif (!isValidDate(date)) {\n\t\tthrow new Error(\"Date is invalid!\")\n\t}\n}\n\n/**\n * we don't want to deal with some calendar event edge cases,\n * like pre-1970 events that would have negative timestamps.\n * during import, we can also get faulty events that are\n * impossible to create through the interface.\n */\nexport const enum CalendarEventValidity {\n\tInvalidContainsInvalidDate,\n\tInvalidEndBeforeStart,\n\tInvalidPre1970,\n\tValid,\n}\n\n/**\n * check if a given event should be allowed to be created in a tutanota calendar.\n * @param event\n * @returns Enum describing the reason to reject the event, if any.\n */\nexport function checkEventValidity(event: CalendarEvent): CalendarEventValidity {\n\tif (!isValidDate(event.startTime) || !isValidDate(event.endTime)) {\n\t\treturn CalendarEventValidity.InvalidContainsInvalidDate\n\t} else if (event.endTime.getTime() <= event.startTime.getTime()) {\n\t\treturn CalendarEventValidity.InvalidEndBeforeStart\n\t} else if (event.startTime.getTime() < TIMESTAMP_ZERO_YEAR) {\n\t\treturn CalendarEventValidity.InvalidPre1970\n\t}\n\treturn CalendarEventValidity.Valid\n}\n\nconst MAX_EVENT_ITERATIONS = 10000\n\n/**\n * add the days the given {@param event} is happening on during the given {@param range} to {@param daysToEvents}.\n *\n * ignores repeat rules.\n * @param zone\n */\nexport function addDaysForEventInstance(daysToEvents: Map<number, Array<CalendarEvent>>, event: CalendarEvent, range: CalendarTimeRange, zone: string) {\n\tconst { start: rangeStart, end: rangeEnd } = range\n\tconst clippedRange = clipRanges(getEventStart(event, zone).getTime(), getEventEnd(event, zone).getTime(), rangeStart, rangeEnd)\n\t// the event and range do not intersect\n\tif (clippedRange == null) return\n\tconst { start: eventStartInRange, end: eventEndInRange } = clippedRange\n\tlet calculationDate = getStartOfDayWithZone(new Date(eventStartInRange), zone)\n\tlet calculationTime = calculationDate.getTime()\n\tlet iterations = 0\n\n\twhile (calculationTime < rangeEnd) {\n\t\tassertDateIsValid(calculationDate)\n\t\tassert(iterations <= MAX_EVENT_ITERATIONS, \"Run into the infinite loop, addDaysForEvent\")\n\t\tif (calculationTime < eventEndInRange) {\n\t\t\tconst eventsForCalculationDate = getFromMap(daysToEvents, calculationTime, () => [])\n\t\t\tinsertIntoSortedArray(event, eventsForCalculationDate, eventComparator, isSameEventInstance)\n\t\t} else {\n\t\t\t// If the duration of the original event instance was reduced, we also have to delete the remaining days of the previous event instance.\n\t\t\tconst removed = findAllAndRemove(\n\t\t\t\tgetFromMap(daysToEvents, calculationTime, () => []),\n\t\t\t\t(e) => isSameEventInstance(e, event),\n\t\t\t)\n\t\t\tif (!removed) {\n\t\t\t\t// no further days this event instance occurred on\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tcalculationDate = incrementByRepeatPeriod(calculationDate, RepeatPeriod.DAILY, 1, zone)\n\t\tcalculationTime = calculationDate.getTime()\n\t\titerations++\n\t}\n}\n\n/** add the days a repeating {@param event} occurs on during {@param range} to {@param daysToEvents} by calling addDaysForEventInstance() for each of its\n * non-excluded instances.\n * @param timeZone\n */\nexport function addDaysForRecurringEvent(\n\tdaysToEvents: Map<number, Array<CalendarEvent>>,\n\tevent: CalendarEvent,\n\trange: CalendarTimeRange,\n\ttimeZone: string = getTimeZone(),\n) {\n\tconst repeatRule = event.repeatRule\n\n\tif (repeatRule == null) {\n\t\tthrow new Error(\"Invalid argument: event doesn't have a repeatRule\" + JSON.stringify(event))\n\t}\n\tconst allDay = isAllDayEvent(event)\n\tconst exclusions = allDay\n\t\t? repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateForTimezone(date, timeZone) }))\n\t\t: repeatRule.excludedDates\n\n\tfor (const { startTime, endTime } of generateEventOccurrences(event, timeZone)) {\n\t\tif (startTime.getTime() > range.end) break\n\t\tif (endTime.getTime() < range.start) continue\n\t\tif (isExcludedDate(startTime, exclusions)) {\n\t\t\tconst eventsOnExcludedDay = daysToEvents.get(getStartOfDayWithZone(startTime, timeZone).getTime())\n\t\t\tif (!eventsOnExcludedDay) continue\n\t\t} else {\n\t\t\tconst eventClone = clone(event)\n\t\t\tif (allDay) {\n\t\t\t\teventClone.startTime = getAllDayDateUTCFromZone(startTime, timeZone)\n\t\t\t\teventClone.endTime = getAllDayDateUTCFromZone(endTime, timeZone)\n\t\t\t} else {\n\t\t\t\teventClone.startTime = new Date(startTime)\n\t\t\t\teventClone.endTime = new Date(endTime)\n\t\t\t}\n\t\t\taddDaysForEventInstance(daysToEvents, eventClone, range, timeZone)\n\t\t}\n\t}\n}\n\n/**\n * get all instances of all series in a list of event series progenitors that intersect with the given range.\n * will return a sorted array of instances (by start time), interleaving the series if necessary.\n *\n */\nexport function generateCalendarInstancesInRange(\n\tprogenitors: ReadonlyArray<CalendarEvent>,\n\trange: CalendarTimeRange,\n\tmax: number = Infinity,\n\ttimeZone: string = getTimeZone(),\n): Array<CalendarEvent> {\n\tconst ret: Array<CalendarEvent> = []\n\n\tconst getNextCandidate = (\n\t\tpreviousCandidate: CalendarEvent,\n\t\tgenerator: Generator<{\n\t\t\tstartTime: Date\n\t\t\tendTime: Date\n\t\t}>,\n\t\texcludedDates: Array<DateWrapper>,\n\t) => {\n\t\tconst allDay = isAllDayEvent(previousCandidate)\n\t\tconst exclusions = allDay ? excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateForTimezone(date, timeZone) })) : excludedDates\n\t\tlet current\n\n\t\t// not using for-of because that automatically closes the generator\n\t\t// when breaking or returning, and we want to suspend and resume iteration.\n\t\twhile (ret.length < max) {\n\t\t\tcurrent = generator.next()\n\n\t\t\tif (current.done) break\n\n\t\t\tlet { startTime, endTime } = current.value\n\t\t\tif (startTime.getTime() > range.end) break\n\t\t\t// using \"<=\" because an all-day-event that lasts n days spans n+1 days,\n\t\t\t// ending at midnight utc on the day after. So they seem to intersect\n\t\t\t// the range if it starts on the day after the event ends.\n\t\t\tif (endTime.getTime() <= range.start) continue\n\n\t\t\tif (!isExcludedDate(startTime, exclusions)) {\n\t\t\t\tconst nextCandidate = clone(previousCandidate)\n\t\t\t\tif (allDay) {\n\t\t\t\t\tnextCandidate.startTime = getAllDayDateUTCFromZone(startTime, timeZone)\n\t\t\t\t\tnextCandidate.endTime = getAllDayDateUTCFromZone(endTime, timeZone)\n\t\t\t\t} else {\n\t\t\t\t\tnextCandidate.startTime = new Date(startTime)\n\t\t\t\t\tnextCandidate.endTime = new Date(endTime)\n\t\t\t\t}\n\t\t\t\treturn nextCandidate\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\t// we need to have one candidate for each series and then check which one gets added first.\n\t// if we added one, we advance the generator that generated it to the next candidate and repeat.\n\tconst generators: Array<{\n\t\tgenerator: Generator<{ startTime: Date; endTime: Date }>\n\t\texcludedDates: Array<DateWrapper>\n\t\tnextCandidate: CalendarEvent\n\t}> = progenitors\n\t\t.map((p) => {\n\t\t\tconst generator = generateEventOccurrences(p, timeZone)\n\t\t\tconst excludedDates = p.repeatRule?.excludedDates ?? []\n\t\t\tconst nextCandidate = getNextCandidate(p, generator, excludedDates)\n\t\t\tif (nextCandidate == null) return null\n\t\t\treturn {\n\t\t\t\texcludedDates,\n\t\t\t\tgenerator,\n\t\t\t\tnextCandidate,\n\t\t\t}\n\t\t})\n\t\t.filter(isNotNull)\n\n\twhile (generators.length > 0) {\n\t\t// performance: put the smallest nextCandidate in front. we only change the first item in each iteration, so this should be quick to re-sort.\n\t\t// still O(n²) in the best case >:(\n\t\t// we might improve runtime here by re-inserting the new nextCandidate into the list manually using a linear or binary search instead of invoking\n\t\t// sort.\n\t\t// we can then also maintain an index to the first still-open generator instead of splicing out the first generator when it stops yielding instances.\n\t\tgenerators.sort((a, b) => (a.nextCandidate?.startTime.getTime() ?? 0) - (b.nextCandidate?.startTime.getTime() ?? 0))\n\t\tconst first = getFirstOrThrow(generators)\n\t\tconst newNext = getNextCandidate(first.nextCandidate, first.generator, first.excludedDates)\n\n\t\tret.push(first.nextCandidate)\n\n\t\tif (newNext == null) {\n\t\t\tgenerators.splice(0, 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tfirst.nextCandidate = newNext\n\t}\n\treturn ret\n}\n\n/**\n * Returns the end date of a repeating rule that can be used to display in the ui.\n *\n * The actual end date that is stored on the repeat rule is always one day behind the displayed end date:\n * * for all-day events:\n *   - displayed end date: 2023-05-18\n *   - last occurrence can be: 2023-05-18\n *   - exported end date: 2023-05-18\n *   - actual timestamp on the entity: Midnight UTC 2023-05-19 (start of day)\n * * normal events behave the same except:\n *   - actual timestamp on the entity is Midnight local timezone 2023-05-19 (start of day)\n * @returns {Date}\n */\nexport function getRepeatEndTimeForDisplay(repeatRule: RepeatRule, isAllDay: boolean, timeZone: string): Date {\n\tif (repeatRule.endType !== EndType.UntilDate) {\n\t\tthrow new Error(\"Event has no repeat rule end type is not UntilDate: \" + JSON.stringify(repeatRule))\n\t}\n\n\tconst rawEndDate = new Date(filterInt(repeatRule.endValue ?? \"0\"))\n\tconst localDate = isAllDay ? getAllDayDateForTimezone(rawEndDate, timeZone) : rawEndDate\n\t// Shown date is one day behind the actual end (but it is still excluded)\n\treturn incrementByRepeatPeriod(localDate, RepeatPeriod.DAILY, -1, timeZone)\n}\n\n/**\n * generates all event occurrences in chronological order, including the progenitor.\n * terminates once the end condition of the repeat rule is hit.\n * @param event the event to iterate occurrences on.\n * @param timeZone\n */\nfunction* generateEventOccurrences(event: CalendarEvent, timeZone: string): Generator<{ startTime: Date; endTime: Date }> {\n\tconst { repeatRule } = event\n\n\tif (repeatRule == null) {\n\t\tyield event\n\t\treturn\n\t}\n\n\tconst frequency: RepeatPeriod = downcast(repeatRule.frequency)\n\tconst interval = Number(repeatRule.interval)\n\tlet eventStartTime = getEventStart(event, timeZone)\n\tlet eventEndTime = getEventEnd(event, timeZone)\n\t// Loop by the frequency step\n\tlet repeatEndTime: Date | null = null\n\tlet endOccurrences: number | null = null\n\tconst allDay = isAllDayEvent(event)\n\t// For all-day events we should rely on the local time zone or at least we must use the same zone as in getAllDayDateUTCFromZone\n\t// below. If they are not in sync, then daylight saving shifts may cause us to extract wrong UTC date (day in repeat rule zone and in\n\t// local zone may be different).\n\tconst repeatTimeZone = allDay ? timeZone : getValidTimeZone(repeatRule.timeZone)\n\n\tif (repeatRule.endType === EndType.Count) {\n\t\tendOccurrences = Number(repeatRule.endValue)\n\t} else if (repeatRule.endType === EndType.UntilDate) {\n\t\t// See CalendarEventDialog for an explanation why it's needed\n\t\tif (allDay) {\n\t\t\trepeatEndTime = getAllDayDateForTimezone(new Date(Number(repeatRule.endValue)), timeZone)\n\t\t} else {\n\t\t\trepeatEndTime = new Date(Number(repeatRule.endValue))\n\t\t}\n\t}\n\n\tlet calcStartTime = eventStartTime\n\tconst calcDuration = allDay ? getDiffIn24hIntervals(eventStartTime, eventEndTime, timeZone) : eventEndTime.getTime() - eventStartTime.getTime()\n\tlet calcEndTime = eventEndTime\n\tlet iteration = 1\n\n\twhile ((endOccurrences == null || iteration <= endOccurrences) && (repeatEndTime == null || calcStartTime.getTime() < repeatEndTime.getTime())) {\n\t\tassertDateIsValid(calcStartTime)\n\t\tassertDateIsValid(calcEndTime)\n\t\tyield { startTime: calcStartTime, endTime: calcEndTime }\n\n\t\tcalcStartTime = incrementByRepeatPeriod(eventStartTime, frequency, interval * iteration, repeatTimeZone)\n\t\tcalcEndTime = allDay\n\t\t\t? incrementByRepeatPeriod(calcStartTime, RepeatPeriod.DAILY, calcDuration, repeatTimeZone)\n\t\t\t: DateTime.fromJSDate(calcStartTime).plus(calcDuration).toJSDate()\n\t\titeration++\n\t}\n}\n\n/**\n * return true if an event has more than one visible occurrence according to its repeat rule and excluded dates\n *\n * will compare exclusion time stamps with the exact date-time value of the occurrences startTime\n *\n * @param event the calendar event to check. to get correct results, this must be the progenitor.\n */\nexport function calendarEventHasMoreThanOneOccurrencesLeft({ progenitor, alteredInstances }: CalendarEventUidIndexEntry): boolean {\n\tif (progenitor == null) {\n\t\t// this may happen if we accept multiple invites to altered instances without ever getting the progenitor.\n\t\treturn alteredInstances.length > 1\n\t}\n\tconst { repeatRule } = progenitor\n\tif (repeatRule == null) {\n\t\treturn false\n\t}\n\n\tconst { endType, endValue, excludedDates } = repeatRule\n\tif (endType === EndType.Never) {\n\t\t// there are infinite occurrences\n\t\treturn true\n\t} else if (endType === EndType.Count && Number(endValue ?? \"0\") + alteredInstances.length > excludedDates.length + 1) {\n\t\t// if there are not enough exclusions to delete all but one occurrence, we can return true\n\t\treturn true\n\t} else if (alteredInstances.length > 1) {\n\t\treturn true\n\t} else {\n\t\t// we need to count occurrences and match them up against altered instances & exclusions.\n\t\tconst excludedTimestamps = excludedDates.map(({ date }) => date.getTime())\n\t\tlet i = 0\n\t\t// in our model, we have an extra exclusion for each altered instance. this code\n\t\t// assumes that this invariant is upheld here and does not match each recurrenceId\n\t\t// against an exclusion, but only tallies them up.\n\t\tlet occurrencesFound = alteredInstances.length\n\t\tfor (const { startTime } of generateEventOccurrences(progenitor, getTimeZone())) {\n\t\t\tconst startTimestamp = startTime.getTime()\n\t\t\twhile (i < excludedTimestamps.length && startTimestamp > excludedTimestamps[i]) {\n\t\t\t\t// exclusions are sorted\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\tif (startTimestamp !== excludedTimestamps[i]) {\n\t\t\t\t// we found the place in the array where the startTimestamp would\n\t\t\t\t// be if it were in the array\n\t\t\t\toccurrencesFound += 1\n\t\t\t\tif (occurrencesFound > 1) return true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n}\n\n/**\n * find out if a given date is in a list of excluded dates\n * @param currentDate the date to check\n * @param excludedDates a sorted list of excluded dates, earliest to latest\n */\nfunction isExcludedDate(currentDate: Date, excludedDates: ReadonlyArray<DateWrapper> = []): boolean {\n\treturn excludedDates.some((dw) => dw.date.getTime() === currentDate.getTime())\n}\n\nexport type AlarmOccurrence = {\n\talarmTime: Date\n\toccurrenceNumber: number\n\teventTime: Date\n}\n\nexport function findNextAlarmOccurrence(\n\tnow: Date,\n\ttimeZone: string,\n\teventStart: Date,\n\teventEnd: Date,\n\tfrequency: RepeatPeriod,\n\tinterval: number,\n\tendType: EndType,\n\tendValue: number,\n\texclusions: Array<Date>,\n\talarmTrigger: AlarmInterval,\n\tlocalTimeZone: string,\n): AlarmOccurrence | null {\n\tlet occurrenceNumber = 0\n\tconst isAllDayEvent = isAllDayEventByTimes(eventStart, eventEnd)\n\tconst calcEventStart = isAllDayEvent ? getAllDayDateForTimezone(eventStart, localTimeZone) : eventStart\n\tassertDateIsValid(calcEventStart)\n\tconst endDate = endType === EndType.UntilDate ? (isAllDayEvent ? getAllDayDateForTimezone(new Date(endValue), localTimeZone) : new Date(endValue)) : null\n\n\twhile (endType !== EndType.Count || occurrenceNumber < endValue) {\n\t\tconst occurrenceDate = incrementByRepeatPeriod(calcEventStart, frequency, interval * occurrenceNumber, isAllDayEvent ? localTimeZone : timeZone)\n\t\tif (endDate && occurrenceDate.getTime() >= endDate.getTime()) {\n\t\t\treturn null\n\t\t}\n\n\t\tif (!exclusions.some((d) => d.getTime() === occurrenceDate.getTime())) {\n\t\t\tconst alarmTime = calculateAlarmTime(occurrenceDate, alarmTrigger, localTimeZone)\n\n\t\t\tif (alarmTime >= now) {\n\t\t\t\treturn {\n\t\t\t\t\talarmTime,\n\t\t\t\t\toccurrenceNumber: occurrenceNumber,\n\t\t\t\t\teventTime: occurrenceDate,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toccurrenceNumber++\n\t}\n\treturn null\n}\n\n/** */\nexport type CalendarDay = {\n\tdate: Date\n\tyear: number\n\tmonth: number\n\tday: number\n\t/** days that are technically not part of the current month, but are shown to fill the grid. */\n\tisPaddingDay: boolean\n}\n\nexport type CalendarMonth = {\n\tweekdays: ReadonlyArray<string>\n\tweeks: ReadonlyArray<ReadonlyArray<CalendarDay>>\n\t/** the 1st of the month, might not be the first date in {@link weeks} because of the padding days. */\n\tbeginningOfMonth: Date\n}\n\n/**\n *\n * https://www.kanzaki.com/docs/ical/sequence.html\n * The \"Organizer\" includes this property in an iCalendar object that it sends to an\n * \"Attendee\" to specify the current version of the calendar component.\n *\n * The \"Attendee\" includes this property in an iCalendar object that it sends to the \"Organizer\"\n * to specify the version of the calendar component that the \"Attendee\" is referring to.\n *\n * @param sequence\n */\nexport function incrementSequence(sequence: string): string {\n\tconst current = filterInt(sequence) || 0\n\t// Only the organizer should increase sequence numbers\n\treturn String(current + 1)\n}\n\nexport function findFirstPrivateCalendar(calendarInfo: ReadonlyMap<Id, CalendarInfo>): CalendarInfo | null {\n\tfor (const calendar of calendarInfo.values()) {\n\t\tif (calendar.userIsOwner && !calendar.isExternal) return calendar\n\t}\n\treturn null\n}\n\n/**\n * Prepare calendar event description to be shown to the user.\n *\n * It is needed to fix special format of links from Outlook which otherwise disappear during sanitizing.\n * They look like this:\n * ```\n * text<https://example.com>\n * ```\n *\n * @param description description to clean up\n * @param sanitizer optional sanitizer to apply after preparing the description\n */\nexport function prepareCalendarDescription(description: string, sanitizer: (s: string) => string): string {\n\tconst prepared = description.replace(/<(http|https):\\/\\/[A-z0-9$-_.+!*‘(),/?]+>/gi, (possiblyLink) => {\n\t\ttry {\n\t\t\tconst withoutBrackets = possiblyLink.slice(1, -1)\n\t\t\tconst url = new URL(withoutBrackets)\n\t\t\treturn `<a href=\"${url.toString()}\">${withoutBrackets}</a>`\n\t\t} catch (e) {\n\t\t\treturn possiblyLink\n\t\t}\n\t})\n\n\treturn sanitizer(prepared)\n}\n\nexport const DEFAULT_HOUR_OF_DAY = 6\n\n/** Get CSS class for the date element. */\nexport function getDateIndicator(day: Date, selectedDate: Date | null): string {\n\tif (isSameDayOfDate(day, selectedDate)) {\n\t\treturn \".accent-bg.circle\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\n/**\n * Determine what format the time of an event should be rendered in given a surrounding time period\n */\nexport function getTimeTextFormatForLongEvent(ev: CalendarEvent, startDay: Date, endDay: Date, zone: string): EventTextTimeOption | null {\n\tconst startsBefore = eventStartsBefore(startDay, zone, ev)\n\tconst endsAfter = eventEndsAfterOrOn(endDay, zone, ev)\n\n\tif ((startsBefore && endsAfter) || isAllDayEvent(ev)) {\n\t\treturn null\n\t} else if (startsBefore && !endsAfter) {\n\t\treturn EventTextTimeOption.END_TIME\n\t} else if (!startsBefore && endsAfter) {\n\t\treturn EventTextTimeOption.START_TIME\n\t} else {\n\t\treturn EventTextTimeOption.START_END_TIME\n\t}\n}\n\n/**\n * Creates a new date with the year, month and day from the Date and the hours and minutes from the Time\n * @param date\n * @param time\n */\nexport function combineDateWithTime(date: Date, time: Time): Date {\n\tconst newDate = new Date(date)\n\tnewDate.setHours(time.hour)\n\tnewDate.setMinutes(time.minute)\n\treturn newDate\n}\n\n/**\n * Check if an event occurs during some time period of days, either partially or entirely\n * Expects that firstDayOfWeek is before lastDayOfWeek, and that event starts before it ends, otherwise result is invalid\n */\nexport function isEventBetweenDays(event: CalendarEvent, firstDay: Date, lastDay: Date, zone: string): boolean {\n\tconst endOfDay = DateTime.fromJSDate(lastDay, { zone }).endOf(\"day\").toJSDate()\n\treturn !(eventEndsBefore(firstDay, zone, event) || eventStartsAfter(endOfDay, zone, event))\n}\n\nexport function getFirstDayOfMonth(d: Date): Date {\n\tconst date = new Date(d)\n\tdate.setDate(1)\n\treturn date\n}\n\n/**\n * get the \"primary\" event of a series - the one that contains the repeat rule and is not a repeated or a rescheduled instance.\n * @param calendarEvent\n * @param entityClient\n */\nexport async function resolveCalendarEventProgenitor(calendarEvent: CalendarEvent, entityClient: EntityClient): Promise<CalendarEvent> {\n\treturn calendarEvent.repeatRule ? await entityClient.load(CalendarEventTypeRef, calendarEvent._id) : calendarEvent\n}\n\n/** clip the range start-end to the range given by min-max. if the result would have length 0, null is returned. */\nexport function clipRanges(start: number, end: number, min: number, max: number): CalendarTimeRange | null {\n\tconst res = {\n\t\tstart: Math.max(start, min),\n\t\tend: Math.min(end, max),\n\t}\n\treturn res.start < res.end ? res : null\n}\n\nexport enum AlarmIntervalUnit {\n\tMINUTE = \"M\",\n\tHOUR = \"H\",\n\tDAY = \"D\",\n\tWEEK = \"W\",\n}\n\nexport const StandardAlarmInterval = Object.freeze({\n\tZERO_MINUTES: { value: 0, unit: AlarmIntervalUnit.MINUTE },\n\tFIVE_MINUTES: { value: 5, unit: AlarmIntervalUnit.MINUTE },\n\tTEN_MINUTES: { value: 10, unit: AlarmIntervalUnit.MINUTE },\n\tTHIRTY_MINUTES: { value: 30, unit: AlarmIntervalUnit.MINUTE },\n\tONE_HOUR: { value: 1, unit: AlarmIntervalUnit.HOUR },\n\tONE_DAY: { value: 1, unit: AlarmIntervalUnit.DAY },\n\tTWO_DAYS: { value: 2, unit: AlarmIntervalUnit.DAY },\n\tTHREE_DAYS: { value: 3, unit: AlarmIntervalUnit.DAY },\n\tONE_WEEK: { value: 1, unit: AlarmIntervalUnit.WEEK },\n} as const satisfies Record<string, AlarmInterval>)\n\n/**\n * Runtime representation of an alarm interval/alarm trigger.\n * Unlike iCal we only support one unit and alarms in the past\n * (represented here as non-negative numbers).\n */\nexport type AlarmInterval = Readonly<{\n\tunit: AlarmIntervalUnit\n\tvalue: number\n}>\n\nexport function alarmIntervalToLuxonDurationLikeObject(alarmInterval: AlarmInterval): DurationLikeObject {\n\tswitch (alarmInterval.unit) {\n\t\tcase AlarmIntervalUnit.MINUTE:\n\t\t\treturn { minutes: alarmInterval.value }\n\t\tcase AlarmIntervalUnit.HOUR:\n\t\t\treturn { hours: alarmInterval.value }\n\t\tcase AlarmIntervalUnit.DAY:\n\t\t\treturn { days: alarmInterval.value }\n\t\tcase AlarmIntervalUnit.WEEK:\n\t\t\treturn { weeks: alarmInterval.value }\n\t}\n}\n\n/**\n * compare two lists of dates that are sorted from earliest to latest. return true if they are equivalent.\n */\nexport function areExcludedDatesEqual(e1: ReadonlyArray<DateWrapper>, e2: ReadonlyArray<DateWrapper>): boolean {\n\tif (e1.length !== e2.length) return false\n\treturn e1.every(({ date }, i) => e2[i].date.getTime() === date.getTime())\n}\n\nexport function areRepeatRulesEqual(r1: CalendarRepeatRule | null, r2: CalendarRepeatRule | null): boolean {\n\treturn (\n\t\tr1 === r2 ||\n\t\t(r1?.endType === r2?.endType &&\n\t\t\tr1?.endValue === r2?.endValue &&\n\t\t\tr1?.frequency === r2?.frequency &&\n\t\t\tr1?.interval === r2?.interval &&\n\t\t\t/** r1?.timeZone === r2?.timeZone && we're ignoring time zone because it's not an observable change. */\n\t\t\tareExcludedDatesEqual(r1?.excludedDates ?? [], r2?.excludedDates ?? []) &&\n\t\t\tdeepEqual(r1?.advancedRules, r2?.advancedRules))\n\t)\n}\n\n/**\n * Converts db representation of alarm to a runtime one.\n */\nexport function parseAlarmInterval(serialized: string): AlarmInterval {\n\tconst matched = serialized.match(/^(\\d+)([MHDW])$/)\n\tif (matched) {\n\t\tconst [_, digits, unit] = matched\n\t\tconst value = filterInt(digits)\n\t\tif (isNaN(value)) {\n\t\t\tthrow new ParserError(`Invalid value: ${value}`)\n\t\t} else {\n\t\t\treturn { value, unit: unit as AlarmIntervalUnit }\n\t\t}\n\t} else {\n\t\tthrow new ParserError(`Invalid alarm interval: ${serialized}`)\n\t}\n}\n\nexport enum CalendarType {\n\tNORMAL,\n\tURL, // External calendar\n\tCLIENT_ONLY,\n}\n\nexport function isClientOnlyCalendar(calendarId: Id) {\n\tconst clientOnlyId = calendarId.match(/#(.*)/)?.[1]!\n\treturn CLIENT_ONLY_CALENDARS.has(clientOnlyId)\n}\n\nexport function isClientOnlyCalendarType(calendarType: CalendarType) {\n\treturn calendarType === CalendarType.CLIENT_ONLY\n}\n\nexport function isNormalCalendarType(calendarType: CalendarType) {\n\treturn calendarType === CalendarType.NORMAL\n}\n\nexport function isExternalCalendarType(calendarType: CalendarType) {\n\treturn calendarType === CalendarType.URL\n}\n\nexport function hasSourceUrl(groupSettings: GroupSettings | null | undefined) {\n\treturn isNotNull(groupSettings?.sourceUrl) && groupSettings?.sourceUrl !== \"\"\n}\n\nexport function getCalendarType(groupSettings: GroupSettings | null, groupInfo: GroupInfo): CalendarType {\n\tif (hasSourceUrl(groupSettings)) return CalendarType.URL\n\tif (isClientOnlyCalendar(groupSettings ? groupSettings._id : groupInfo.group)) return CalendarType.CLIENT_ONLY\n\treturn CalendarType.NORMAL\n}\n\nexport function extractYearFromBirthday(birthday: string | null): number | null {\n\tif (!birthday) {\n\t\treturn null\n\t}\n\n\tconst dateParts = birthday.split(\"-\")\n\tconst partsLength = dateParts.length\n\n\t// A valid ISO date should contain 3 parts:\n\t// YYYY-mm-dd => [yyyy, mm, dd]\n\tif (partsLength !== 3) {\n\t\treturn null\n\t}\n\n\treturn Number.parseInt(dateParts[0])\n}\n\nexport async function retrieveClientOnlyEventsForUser(logins: LoginController, events: IdTuple[], localEvents: Map<number, BirthdayEventRegistry[]>) {\n\tif (!(await logins.getUserController().isNewPaidPlan())) {\n\t\treturn []\n\t}\n\n\tconst clientOnlyEvents = events.filter(([calendarId, _]) => isClientOnlyCalendar(calendarId)).flatMap((event) => event.join(\"/\"))\n\tconst retrievedEvents: CalendarEvent[] = []\n\n\tfor (const event of Array.from(localEvents.values()).flat()) {\n\t\tif (clientOnlyEvents.includes(event.event._id.join(\"/\"))) {\n\t\t\tretrievedEvents.push(event.event)\n\t\t}\n\t}\n\n\treturn retrievedEvents\n}\n\nexport function calculateContactsAge(birthYear: number | null, currentYear: number): number | null {\n\tif (!birthYear) {\n\t\treturn null\n\t}\n\n\treturn currentYear - birthYear\n}\n\nexport function extractContactIdFromEvent(id: string | null | undefined): string | null {\n\tif (id == null) {\n\t\treturn null\n\t}\n\n\treturn decodeBase64(\"utf-8\", id)\n}\n"],"mappings":"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"}