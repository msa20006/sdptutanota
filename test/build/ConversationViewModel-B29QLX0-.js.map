{"version":3,"file":"ConversationViewModel-B29QLX0-.js","names":["options: CreateMailViewerOptions","viewModelFactory: MailViewerViewModelFactory","entityClient: EntityClient","eventController: EventController","conversationPrefProvider: ConversationPrefProvider","mailModel: MailModel","onUiUpdate: () => unknown","delayBodyRendering: Promise<unknown>","update: EntityUpdateData","id: IdTuple","ceId: IdTuple","conversationEntry: ConversationEntry","mail: Mail | null","conversationEntries: ConversationEntry[]","allMails: Map<Id, Mail>","newConversation: ConversationItem[]","mail: Mail"],"sources":["../../src/mail-app/mail/view/ConversationViewModel.ts"],"sourcesContent":["import { ConversationEntry, ConversationEntryTypeRef, Mail, MailTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { MailViewerViewModel } from \"./MailViewerViewModel.js\"\nimport { CreateMailViewerOptions } from \"./MailViewer.js\"\nimport { elementIdPart, firstBiggerThanSecond, getElementId, haveSameId, isSameId, listIdPart } from \"../../../common/api/common/utils/EntityUtils.js\"\nimport { assertNotNull, findLastIndex, groupBy, makeSingleUse, ofClass } from \"@tutao/tutanota-utils\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport { LoadingStateTracker } from \"../../../common/offline/LoadingState.js\"\nimport { EntityEventsListener, EventController } from \"../../../common/api/main/EventController.js\"\nimport { ConversationType, MailSetKind, MailState, OperationType } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError.js\"\nimport { MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport { ListAutoSelectBehavior } from \"../../../common/misc/DeviceConfig.js\"\n\nimport { MailModel } from \"../model/MailModel.js\"\n\nimport { isOfTypeOrSubfolderOf } from \"../model/MailChecks.js\"\n\nexport type MailViewerViewModelFactory = (options: CreateMailViewerOptions) => MailViewerViewModel\n\nexport type MailItem = { type: \"mail\"; viewModel: MailViewerViewModel; entryId: IdTuple }\nexport type ConversationItem = MailItem\n\nexport interface ConversationPrefProvider {\n\tgetConversationViewShowOnlySelectedMail(): boolean\n\n\tgetMailAutoSelectBehavior(): ListAutoSelectBehavior\n}\n\nexport type ConversationViewModelFactory = (options: CreateMailViewerOptions) => ConversationViewModel\n\nexport class ConversationViewModel {\n\t/** Primary viewModel is for the mail that was selected from the list. */\n\tprivate readonly _primaryViewModel: MailViewerViewModel\n\tprivate loadingState = new LoadingStateTracker()\n\tprivate loadingPromise: Promise<void> | null = null\n\t/** Is not set until {@link loadConversation is finished. Until it is finished we display primary mail and subject. */\n\tprivate conversation: ConversationItem[] | null = null\n\n\tconstructor(\n\t\tprivate options: CreateMailViewerOptions,\n\t\tprivate readonly viewModelFactory: MailViewerViewModelFactory,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly conversationPrefProvider: ConversationPrefProvider,\n\t\tprivate readonly mailModel: MailModel,\n\t\tprivate readonly onUiUpdate: () => unknown,\n\t) {\n\t\tthis._primaryViewModel = viewModelFactory(options)\n\t}\n\n\treadonly init = makeSingleUse((delayBodyRendering: Promise<unknown>) => {\n\t\tthis.loadingPromise = this.loadingState.trackPromise(this.loadConversation())\n\t\tthis.eventController.addEntityListener(this.onEntityEvent)\n\t\tthis._primaryViewModel.expandMail(delayBodyRendering)\n\t})\n\n\tprivate readonly onEntityEvent: EntityEventsListener = async (updates, eventOwnerGroupId) => {\n\t\t// conversation entry can be created when new email arrives\n\t\t// conversation entry can be updated when email is moved around or deleted\n\t\t// conversation entry is deleted only when every email in the conversation is deleted (the whole conversation list will be deleted)\n\t\tfor (const update of updates) {\n\t\t\tif (isUpdateForTypeRef(ConversationEntryTypeRef, update) && update.instanceListId === this.conversationListId()) {\n\t\t\t\tif (this.conversationPrefProvider.getConversationViewShowOnlySelectedMail()) {\n\t\t\t\t\t// no need to handle CREATE because we only show a single item and we don't want to add new ones\n\t\t\t\t\t// no need to handle UPDATE because the only update that can happen is when email gets deleted and then we should be closed from the\n\t\t\t\t\t// outside anyway\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tswitch (update.operation) {\n\t\t\t\t\tcase OperationType.CREATE:\n\t\t\t\t\t\tawait this.processCreateConversationEntry(update)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase OperationType.UPDATE:\n\t\t\t\t\t\tawait this.processUpdateConversationEntry(update)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// don't process DELETE because the primary email (selected from the mail list) will be deleted first anyway\n\t\t\t\t\t// and we should be closed when it happens\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async processCreateConversationEntry(update: EntityUpdateData) {\n\t\tconst id: IdTuple = [update.instanceListId, update.instanceId]\n\t\ttry {\n\t\t\tconst entry = await this.entityClient.load(ConversationEntryTypeRef, id)\n\t\t\tif (entry.mail) {\n\t\t\t\ttry {\n\t\t\t\t\t// first wait that we load the conversation, otherwise we might already have the email\n\t\t\t\t\tawait this.loadingPromise\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst conversation = assertNotNull(this.conversation)\n\t\t\t\tif (conversation.some((item) => item.type === \"mail\" && isSameId(item.viewModel.mail.conversationEntry, id))) {\n\t\t\t\t\t// already loaded\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst mail = await this.entityClient.load(MailTypeRef, entry.mail)\n\t\t\t\tlet index = findLastIndex(conversation, (i) => firstBiggerThanSecond(getElementId(entry), elementIdPart(i.entryId)))\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tindex = conversation.length\n\t\t\t\t} else {\n\t\t\t\t\tindex = index + 1\n\t\t\t\t}\n\t\t\t\tconversation.splice(index, 0, { type: \"mail\", viewModel: this.viewModelFactory({ ...this.options, mail }), entryId: entry._id })\n\t\t\t\tthis.onUiUpdate()\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t// Ignore, something was already deleted\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async processUpdateConversationEntry(update: EntityUpdateData) {\n\t\ttry {\n\t\t\t// first wait that we load the conversation, otherwise we might already have the email\n\t\t\tawait this.loadingPromise\n\t\t} catch (e) {\n\t\t\treturn\n\t\t}\n\t\tconst conversation = assertNotNull(this.conversation)\n\t\tconst ceId: IdTuple = [update.instanceListId, update.instanceId]\n\t\tlet conversationEntry: ConversationEntry\n\t\tlet mail: Mail | null\n\t\ttry {\n\t\t\tconversationEntry = await this.entityClient.load(ConversationEntryTypeRef, ceId)\n\t\t\tmail =\n\t\t\t\t// ideally checking the `mail` ref should be enough but we sometimes get an update with UNKNOWN and non-existing email but still with the ref\n\t\t\t\tconversationEntry.conversationType !== ConversationType.UNKNOWN && conversationEntry.mail\n\t\t\t\t\t? await this.entityClient.load(MailTypeRef, conversationEntry.mail).catch(\n\t\t\t\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\t\t\t\tconsole.log(`Could not find updated mail ${JSON.stringify(conversationEntry.mail)}`)\n\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t  )\n\t\t\t\t\t: null\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t// Ignore, something was already deleted\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tconst oldItemIndex = conversation.findIndex((e) => e.type === \"mail\" && isSameId(e.viewModel.mail.conversationEntry, ceId))\n\t\tif (oldItemIndex === -1) {\n\t\t\treturn\n\t\t}\n\t\tconst oldItem = conversation[oldItemIndex]\n\t\tif (mail && oldItem.type === \"mail\" && haveSameId(oldItem.viewModel.mail, mail)) {\n\t\t\tconsole.log(\"Noop entry update?\", oldItem.viewModel.mail)\n\t\t\t// nothing to do really, why do we get this update again?\n\t\t} else {\n\t\t\tif (oldItem.type === \"mail\") {\n\t\t\t\toldItem.viewModel.dispose()\n\t\t\t}\n\n\t\t\tif (mail) {\n\t\t\t\t// We do not show trashed drafts\n\t\t\t\tif (mail.state === MailState.DRAFT && (await this.isInTrash(mail))) {\n\t\t\t\t\tconversation.splice(oldItemIndex, 1)\n\t\t\t\t} else {\n\t\t\t\t\tconversation[oldItemIndex] = {\n\t\t\t\t\t\ttype: \"mail\",\n\t\t\t\t\t\tviewModel: this.viewModelFactory({ ...this.options, mail }),\n\t\t\t\t\t\tentryId: conversationEntry._id,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// When DELETED conversation status type is added, replace entry with deleted entry instead of splicing out\n\t\t\t\tconversation.splice(oldItemIndex, 1)\n\t\t\t}\n\t\t\tthis.onUiUpdate()\n\t\t}\n\t}\n\n\tprivate conversationListId() {\n\t\treturn listIdPart(this._primaryViewModel.mail.conversationEntry)\n\t}\n\n\tprivate async loadConversation() {\n\t\ttry {\n\t\t\tif (this.conversationPrefProvider.getConversationViewShowOnlySelectedMail()) {\n\t\t\t\tthis.conversation = this.conversationItemsForSelectedMailOnly()\n\t\t\t} else {\n\t\t\t\t// Catch errors but only for loading conversation entries.\n\t\t\t\t// if success, proceed with loading mails\n\t\t\t\t// otherwise do the error handling\n\t\t\t\tthis.conversation = await this.entityClient.loadAll(ConversationEntryTypeRef, listIdPart(this.primaryMail.conversationEntry)).then(\n\t\t\t\t\tasync (entries) => {\n\t\t\t\t\t\t// if the primary mail is not along conversation then only display the primary mail\n\t\t\t\t\t\tif (!entries.some((entry) => isSameId(entry.mail, this.primaryMail._id))) {\n\t\t\t\t\t\t\treturn this.conversationItemsForSelectedMailOnly()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst allMails = await this.loadMails(entries)\n\t\t\t\t\t\t\treturn this.createConversationItems(entries, allMails)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tasync (e) => {\n\t\t\t\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\t\t\t\t// Most likely the conversation entry list does not exist anymore. The server does not distinguish between the case when the\n\t\t\t\t\t\t\t// list does not exist and when we have no permission on it (and for good reasons, it prevents enumeration).\n\t\t\t\t\t\t\t// Most often it happens when we are not fully synced with the server yet and the primary mail does not even exist.\n\t\t\t\t\t\t\treturn this.conversationItemsForSelectedMailOnly()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.onUiUpdate()\n\t\t}\n\t}\n\n\tprivate createConversationItems(conversationEntries: ConversationEntry[], allMails: Map<Id, Mail>) {\n\t\tconst newConversation: ConversationItem[] = []\n\t\tfor (const c of conversationEntries) {\n\t\t\tconst mail = c.mail && allMails.get(elementIdPart(c.mail))\n\n\t\t\tif (mail) {\n\t\t\t\tnewConversation.push({\n\t\t\t\t\ttype: \"mail\",\n\t\t\t\t\tviewModel: isSameId(mail._id, this.options.mail._id) ? this._primaryViewModel : this.viewModelFactory({ ...this.options, mail }),\n\t\t\t\t\tentryId: c._id,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treturn newConversation\n\t}\n\n\tprivate async loadMails(conversationEntries: ConversationEntry[]) {\n\t\tconst byList = groupBy(conversationEntries, (c) => c.mail && listIdPart(c.mail))\n\t\tconst allMails: Map<Id, Mail> = new Map()\n\t\tfor (const [listId, conversations] of byList.entries()) {\n\t\t\tif (!listId) continue\n\t\t\tconst loaded = await this.entityClient.loadMultiple(\n\t\t\t\tMailTypeRef,\n\t\t\t\tlistId,\n\t\t\t\tconversations.map((c) => elementIdPart(assertNotNull(c.mail))),\n\t\t\t)\n\n\t\t\tfor (const mail of loaded) {\n\t\t\t\t// If the mail is a draft and is the primary mail, we will show it no matter what\n\t\t\t\t// otherwise, if a draft is in trash we will not show it\n\t\t\t\tif (isSameId(mail._id, this.primaryMail._id) || mail.state !== MailState.DRAFT || !(await this.isInTrash(mail))) {\n\t\t\t\t\tallMails.set(getElementId(mail), mail)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn allMails\n\t}\n\n\tprivate async isInTrash(mail: Mail) {\n\t\tconst mailboxDetail = await this.mailModel.getMailboxDetailsForMail(mail)\n\t\tconst mailFolder = this.mailModel.getMailFolderForMail(mail)\n\t\tif (mailFolder == null || mailboxDetail == null || mailboxDetail.mailbox.folders == null) {\n\t\t\treturn\n\t\t}\n\t\tconst folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id)\n\t\treturn isOfTypeOrSubfolderOf(folders, mailFolder, MailSetKind.TRASH)\n\t}\n\n\tconversationItems(): ReadonlyArray<ConversationItem> {\n\t\treturn this.conversation ?? this.conversationItemsForSelectedMailOnly()\n\t}\n\n\tprivate conversationItemsForSelectedMailOnly(): ConversationItem[] {\n\t\treturn [{ type: \"mail\", viewModel: this._primaryViewModel, entryId: this._primaryViewModel.mail.conversationEntry }]\n\t}\n\n\tget primaryMail(): Mail {\n\t\treturn this._primaryViewModel.mail\n\t}\n\n\tprimaryViewModel(): MailViewerViewModel {\n\t\treturn this._primaryViewModel\n\t}\n\n\tisFinished(): boolean {\n\t\treturn this.loadingState.isIdle()\n\t}\n\n\tisConnectionLost(): boolean {\n\t\treturn this.loadingState.isConnectionLost()\n\t}\n\n\tretry() {\n\t\tif (this.loadingState.isConnectionLost()) {\n\t\t\tthis.loadingState.trackPromise(\n\t\t\t\tthis.loadConversation().then(async () => {\n\t\t\t\t\tconst mails = (this.conversation?.filter((e) => e.type === \"mail\") ?? []) as Array<MailItem>\n\t\t\t\t\tawait Promise.all(mails.map((m) => m.viewModel.loadAll(Promise.resolve())))\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n\n\tdispose() {\n\t\t// hack: init has been called if loadingPromise is set\n\t\tif (this.loadingPromise != null) {\n\t\t\tthis.eventController.removeEntityListener(this.onEntityEvent)\n\t\t\tfor (const item of this.conversationItems()) {\n\t\t\t\tif (item.type === \"mail\") {\n\t\t\t\t\titem.viewModel.dispose()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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"}