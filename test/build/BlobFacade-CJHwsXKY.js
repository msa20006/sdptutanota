
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNonNull, base64ToBase64Ext, clear, concat, getFirstOrThrow, groupBy, isEmpty, mapMap, neverNull, pMap, splitUint8ArrayInChunks, uint8ArrayToBase64, uint8ArrayToString } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertWorkerOrNode, isApp, isDesktop } from "./Env-D5xGlXfw.js";
import { MAX_BLOB_SIZE_BYTES } from "./TutanotaConstants-3bwAESYA.js";
import { handleRestError } from "./RestError-D17JEBMr.js";
import { CryptoError } from "./CryptoError-PqdvQky4.js";
import { createBlobReferenceTokenWrapper } from "./TypeRefs-BP1jvX9p.js";
import { HttpMethod, MediaType, resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import { aesDecrypt, sha256Hash } from "./dist-DcZ1Y4qd.js";
import { doBlobRequestWithRetry, tryServers } from "./EntityRestClient--6dT7ZRF.js";
import { addParamsToUrl, isSuspensionResponse } from "./RestClient-CmoHrId4.js";
import { BlobGetInTypeRef, BlobPostOutTypeRef, BlobService, createBlobGetIn, createBlobId } from "./Services-CtomUk-n.js";
import { encryptBytes } from "./CryptoWrapper-BTtEczdP.js";

//#region ../src/common/api/worker/facades/lazy/BlobFacade.ts
assertWorkerOrNode();
const BLOB_SERVICE_REST_PATH = `/rest/${BlobService.app}/${BlobService.name.toLowerCase()}`;
const TAG = "BlobFacade";
var BlobFacade = class {
	constructor(restClient, suspensionHandler, fileApp, aesApp, instanceMapper, cryptoFacade, blobAccessTokenFacade) {
		this.restClient = restClient;
		this.suspensionHandler = suspensionHandler;
		this.fileApp = fileApp;
		this.aesApp = aesApp;
		this.instanceMapper = instanceMapper;
		this.cryptoFacade = cryptoFacade;
		this.blobAccessTokenFacade = blobAccessTokenFacade;
	}
	/**
	* Encrypts and uploads binary data to the blob store. The binary data is split into multiple blobs in case it
	* is too big.
	*
	* @returns blobReferenceToken that must be used to reference a blobs from an instance. Only to be used once.
	*/
	async encryptAndUpload(archiveDataType, blobData, ownerGroupId, sessionKey) {
		const chunks = splitUint8ArrayInChunks(MAX_BLOB_SIZE_BYTES, blobData);
		const doBlobRequest = async () => {
			const blobServerAccessInfo = await this.blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroupId);
			return pMap(chunks, async (chunk) => await this.encryptAndUploadChunk(chunk, blobServerAccessInfo, sessionKey));
		};
		const doEvictToken = () => this.blobAccessTokenFacade.evictWriteToken(archiveDataType, ownerGroupId);
		return doBlobRequestWithRetry(doBlobRequest, doEvictToken);
	}
	/**
	* Encrypts and uploads binary data stored as a file to the blob store. The binary data is split into multiple blobs in case it
	* is too big.
	*
	* @returns blobReferenceToken that must be used to reference a blobs from an instance. Only to be used once.
	*/
	async encryptAndUploadNative(archiveDataType, fileUri, ownerGroupId, sessionKey) {
		if (!isApp() && !isDesktop()) throw new ProgrammingError("Environment is not app or Desktop!");
		const chunkUris = await this.fileApp.splitFile(fileUri, MAX_BLOB_SIZE_BYTES);
		const doEvictToken = () => this.blobAccessTokenFacade.evictWriteToken(archiveDataType, ownerGroupId);
		const doBlobRequest = async () => {
			const blobServerAccessInfo = await this.blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroupId);
			return pMap(chunkUris, async (chunkUri) => {
				return this.encryptAndUploadNativeChunk(chunkUri, blobServerAccessInfo, sessionKey);
			});
		};
		return doBlobRequestWithRetry(doBlobRequest, doEvictToken);
	}
	/**
	* Downloads multiple blobs, decrypts and joins them to unencrypted binary data.
	*
	* @param archiveDataType
	* @param referencingInstance that directly references the blobs
	* @returns Uint8Array unencrypted binary data
	*/
	async downloadAndDecrypt(archiveDataType, referencingInstance, blobLoadOptions = {}) {
		const sessionKey = await this.resolveSessionKey(referencingInstance.entity);
		const doBlobRequest = async () => {
			const blobServerAccessInfo = await this.blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, blobLoadOptions);
			return this.downloadAndDecryptMultipleBlobsOfArchive(referencingInstance.blobs, blobServerAccessInfo, sessionKey, blobLoadOptions);
		};
		const doEvictToken = () => this.blobAccessTokenFacade.evictReadBlobsToken(referencingInstance);
		const blobChunks = await doBlobRequestWithRetry(doBlobRequest, doEvictToken);
		return this.concatenateBlobChunks(referencingInstance, blobChunks);
	}
	concatenateBlobChunks(referencingInstance, blobChunks) {
		const resultSize = Array.from(blobChunks.values()).reduce((sum, blob) => blob.length + sum, 0);
		const resultBuffer = new Uint8Array(resultSize);
		let offset = 0;
		for (const blob of referencingInstance.blobs) {
			const data = blobChunks.get(blob.blobId);
			assertNonNull(data, `Server did not return blob for id : ${blob.blobId}`);
			resultBuffer.set(data, offset);
			offset += data.length;
		}
		return resultBuffer;
	}
	/**
	* Downloads blobs of all {@param referencingInstances}, decrypts them and joins them to unencrypted binaries.
	* If some blobs are not found the result will contain {@code null}.
	* @returns Map from instance id to the decrypted and concatenated contents of the referenced blobs
	*/
	async downloadAndDecryptBlobsOfMultipleInstances(archiveDataType, referencingInstances, blobLoadOptions = {}) {
		const instancesByArchive = groupBy(referencingInstances, (instance) => getFirstOrThrow(instance.blobs).archiveId);
		const result = new Map();
		for (const [_, instances] of instancesByArchive.entries()) {
			const allBlobs = instances.flatMap((instance) => instance.blobs);
			const doBlobRequest = async () => {
				const accessInfo = await this.blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, instances, blobLoadOptions);
				return this.downloadBlobsOfOneArchive(allBlobs, accessInfo, blobLoadOptions);
			};
			const doEvictToken = () => {
				for (const instance of instances) this.blobAccessTokenFacade.evictReadBlobsToken(instance);
			};
			const encryptedBlobsOfAllInstances = await doBlobRequestWithRetry(doBlobRequest, doEvictToken);
			for (const instance of instances) {
				const decryptedData = await this.decryptInstanceData(instance, encryptedBlobsOfAllInstances);
				result.set(instance.elementId, decryptedData);
			}
		}
		return result;
	}
	async decryptInstanceData(instance, blobs) {
		const sessionKey = await this.resolveSessionKey(instance.entity);
		const decryptedChunks = [];
		for (const blob of instance.blobs) {
			const encryptedChunk = blobs.get(blob.blobId);
			if (encryptedChunk == null) {
				console.log(TAG, `Did not find blob of the instance. blobId: ${blob.blobId}, instance: ${instance}`);
				return null;
			}
			try {
				decryptedChunks.push(aesDecrypt(sessionKey, encryptedChunk));
			} catch (e) {
				if (e instanceof CryptoError) {
					console.log(TAG, `Could not decrypt blob of the instance. blobId: ${blob.blobId}, instance: ${instance}`, e);
					return null;
				} else throw e;
			}
		}
		return concat(...decryptedChunks);
	}
	/**
	* Downloads multiple blobs, decrypts and joins them to unencrypted binary data which will be stored as a file on the
	* device.
	*
	* @param archiveDataType
	* @param referencingInstance that directly references the blobs
	* @param fileName is written to the returned FileReference
	* @param mimeType is written to the returned FileReference
	* @returns FileReference to the unencrypted binary data
	*/
	async downloadAndDecryptNative(archiveDataType, referencingInstance, fileName, mimeType) {
		if (!isApp() && !isDesktop()) throw new ProgrammingError("Environment is not app or Desktop!");
		const sessionKey = await this.resolveSessionKey(referencingInstance.entity);
		const decryptedChunkFileUris = [];
		const doBlobRequest = async () => {
			clear(decryptedChunkFileUris);
			const blobServerAccessInfo = await this.blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, {});
			return pMap(referencingInstance.blobs, async (blob) => {
				decryptedChunkFileUris.push(await this.downloadAndDecryptChunkNative(blob, blobServerAccessInfo, sessionKey));
			}).catch(async (e) => {
				for (const decryptedChunkFileUri of decryptedChunkFileUris) await this.fileApp.deleteFile(decryptedChunkFileUri);
				throw e;
			});
		};
		const doEvictToken = () => this.blobAccessTokenFacade.evictReadBlobsToken(referencingInstance);
		await doBlobRequestWithRetry(doBlobRequest, doEvictToken);
		try {
			const decryptedFileUri = await this.fileApp.joinFiles(fileName, decryptedChunkFileUris);
			const size = await this.fileApp.getSize(decryptedFileUri);
			return {
				_type: "FileReference",
				name: fileName,
				mimeType,
				size,
				location: decryptedFileUri
			};
		} finally {
			for (const tmpBlobFile of decryptedChunkFileUris) await this.fileApp.deleteFile(tmpBlobFile);
		}
	}
	async resolveSessionKey(entity) {
		return neverNull(await this.cryptoFacade.resolveSessionKeyForInstance(entity));
	}
	async encryptAndUploadChunk(chunk, blobServerAccessInfo, sessionKey) {
		const encryptedData = encryptBytes(sessionKey, chunk);
		const blobHash = uint8ArrayToBase64(sha256Hash(encryptedData).slice(0, 6));
		const queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, { blobHash }, BlobGetInTypeRef);
		return tryServers(blobServerAccessInfo.servers, async (serverUrl) => {
			const response = await this.restClient.request(BLOB_SERVICE_REST_PATH, HttpMethod.POST, {
				queryParams,
				body: encryptedData,
				responseType: MediaType.Json,
				baseUrl: serverUrl
			});
			return await this.parseBlobPostOutResponse(response);
		}, `can't upload to server`);
	}
	async encryptAndUploadNativeChunk(fileUri, blobServerAccessInfo, sessionKey) {
		const encryptedFileInfo = await this.aesApp.aesEncryptFile(sessionKey, fileUri);
		const encryptedChunkUri = encryptedFileInfo.uri;
		const blobHash = await this.fileApp.hashFile(encryptedChunkUri);
		return tryServers(blobServerAccessInfo.servers, async (serverUrl) => {
			return await this.uploadNative(encryptedChunkUri, blobServerAccessInfo, serverUrl, blobHash);
		}, `can't upload to server from native`);
	}
	async uploadNative(location, blobServerAccessInfo, serverUrl, blobHash) {
		if (this.suspensionHandler.isSuspended()) return this.suspensionHandler.deferRequest(() => this.uploadNative(location, blobServerAccessInfo, serverUrl, blobHash));
		const queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, { blobHash }, BlobGetInTypeRef);
		const serviceUrl = new URL(BLOB_SERVICE_REST_PATH, serverUrl);
		const fullUrl = addParamsToUrl(serviceUrl, queryParams);
		const { suspensionTime, responseBody, statusCode, errorId, precondition } = await this.fileApp.upload(location, fullUrl.toString(), HttpMethod.POST, {});
		if (statusCode === 201 && responseBody != null) return this.parseBlobPostOutResponse(uint8ArrayToString("utf-8", responseBody));
else if (responseBody == null) throw new Error("no response body");
else if (isSuspensionResponse(statusCode, suspensionTime)) {
			this.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), serviceUrl);
			return this.suspensionHandler.deferRequest(() => this.uploadNative(location, blobServerAccessInfo, serverUrl, blobHash));
		} else throw handleRestError(statusCode, ` | ${HttpMethod.POST} ${fullUrl.toString()} failed to natively upload blob`, errorId, precondition);
	}
	async parseBlobPostOutResponse(jsonData) {
		const responseTypeModel = await resolveTypeReference(BlobPostOutTypeRef);
		const instance = JSON.parse(jsonData);
		const { blobReferenceToken } = await this.instanceMapper.decryptAndMapToInstance(responseTypeModel, instance, null);
		if (blobReferenceToken == null) throw new ProgrammingError("empty blobReferenceToken not allowed for post single blob");
		return createBlobReferenceTokenWrapper({ blobReferenceToken });
	}
	async downloadAndDecryptMultipleBlobsOfArchive(blobs, blobServerAccessInfo, sessionKey, blobLoadOptions) {
		const mapWithEncryptedBlobs = await this.downloadBlobsOfOneArchive(blobs, blobServerAccessInfo, blobLoadOptions);
		return mapMap(mapWithEncryptedBlobs, (blob) => aesDecrypt(sessionKey, blob));
	}
	/**
	* Download blobs of a single archive in a single request
	* @return map from blob id to the data
	*/
	async downloadBlobsOfOneArchive(blobs, blobServerAccessInfo, blobLoadOptions) {
		if (isEmpty(blobs)) throw new ProgrammingError("Blobs are empty");
		const archiveId = getFirstOrThrow(blobs).archiveId;
		if (blobs.some((blob) => blob.archiveId !== archiveId)) throw new ProgrammingError("Must only request blobs of the same archive together");
		const getData = createBlobGetIn({
			archiveId,
			blobId: null,
			blobIds: blobs.map(({ blobId }) => createBlobId({ blobId }))
		});
		const BlobGetInTypeModel = await resolveTypeReference(BlobGetInTypeRef);
		const literalGetData = await this.instanceMapper.encryptAndMapToLiteral(BlobGetInTypeModel, getData, null);
		const body = JSON.stringify(literalGetData);
		const queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, {}, BlobGetInTypeRef);
		const concatBinaryData = await tryServers(blobServerAccessInfo.servers, async (serverUrl) => {
			return await this.restClient.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, {
				queryParams,
				body,
				responseType: MediaType.Binary,
				baseUrl: serverUrl,
				noCORS: true,
				headers: blobLoadOptions.extraHeaders,
				suspensionBehavior: blobLoadOptions.suspensionBehavior
			});
		}, `can't download from server `);
		return parseMultipleBlobsResponse(concatBinaryData);
	}
	async downloadAndDecryptChunkNative(blob, blobServerAccessInfo, sessionKey) {
		const { archiveId, blobId } = blob;
		const getData = createBlobGetIn({
			archiveId,
			blobId,
			blobIds: []
		});
		const BlobGetInTypeModel = await resolveTypeReference(BlobGetInTypeRef);
		const literalGetData = await this.instanceMapper.encryptAndMapToLiteral(BlobGetInTypeModel, getData, null);
		const _body = JSON.stringify(literalGetData);
		const blobFilename = blobId + ".blob";
		return tryServers(blobServerAccessInfo.servers, async (serverUrl) => {
			return await this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, blobFilename, { _body });
		}, `can't download native from server `);
	}
	/**
	* @return the uri of the decrypted blob
	*/
	async downloadNative(serverUrl, blobServerAccessInfo, sessionKey, fileName, additionalParams) {
		if (this.suspensionHandler.isSuspended()) return this.suspensionHandler.deferRequest(() => this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, fileName, additionalParams));
		const serviceUrl = new URL(BLOB_SERVICE_REST_PATH, serverUrl);
		const url = addParamsToUrl(serviceUrl, await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, additionalParams, BlobGetInTypeRef));
		const { statusCode, encryptedFileUri, suspensionTime, errorId, precondition } = await this.fileApp.download(url.toString(), fileName, {});
		if (statusCode == 200 && encryptedFileUri != null) {
			const decryptedFileUrl = await this.aesApp.aesDecryptFile(sessionKey, encryptedFileUri);
			try {
				await this.fileApp.deleteFile(encryptedFileUri);
			} catch {
				console.log("Failed to delete encrypted file", encryptedFileUri);
			}
			return decryptedFileUrl;
		} else if (isSuspensionResponse(statusCode, suspensionTime)) {
			this.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), serviceUrl);
			return this.suspensionHandler.deferRequest(() => this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, fileName, additionalParams));
		} else throw handleRestError(statusCode, ` | ${HttpMethod.GET} failed to natively download attachment`, errorId, precondition);
	}
};
function parseMultipleBlobsResponse(concatBinaryData) {
	const dataView = new DataView(concatBinaryData.buffer);
	const result = new Map();
	const blobCount = dataView.getInt32(0);
	if (blobCount === 0) return result;
	if (blobCount < 0) throw new Error(`Invalid blob count: ${blobCount}`);
	let offset = 4;
	while (offset < concatBinaryData.length) {
		const blobIdBytes = concatBinaryData.slice(offset, offset + 9);
		const blobId = base64ToBase64Ext(uint8ArrayToBase64(blobIdBytes));
		const blobSize = dataView.getInt32(offset + 15);
		const dataStartOffset = offset + 19;
		if (blobSize < 0 || dataStartOffset + blobSize > concatBinaryData.length) throw new Error(`Invalid blob size: ${blobSize}. Remaining length: ${concatBinaryData.length - dataStartOffset}`);
		const contents = concatBinaryData.slice(dataStartOffset, dataStartOffset + blobSize);
		result.set(blobId, contents);
		offset = dataStartOffset + blobSize;
	}
	if (blobCount !== result.size) throw new Error(`Parsed wrong number of blobs: ${blobCount}. Expected: ${result.size}`);
	return result;
}

//#endregion
export { BLOB_SERVICE_REST_PATH, BlobFacade, TAG, parseMultipleBlobsResponse };
//# sourceMappingURL=BlobFacade-CJHwsXKY.js.map