{"version":3,"file":"BlobFacade-CJHwsXKY.js","names":["restClient: RestClient","suspensionHandler: SuspensionHandler","fileApp: NativeFileApp","aesApp: AesApp","instanceMapper: InstanceMapper","cryptoFacade: CryptoFacade","blobAccessTokenFacade: BlobAccessTokenFacade","archiveDataType: ArchiveDataType","blobData: Uint8Array","ownerGroupId: Id","sessionKey: AesKey","fileUri: FileUri","referencingInstance: BlobReferencingInstance","blobLoadOptions: BlobLoadOptions","blobChunks: Map<Id, Uint8Array>","referencingInstances: BlobReferencingInstance[]","result: Map<Id, Uint8Array | null>","instance: BlobReferencingInstance","blobs: Map<Id, Uint8Array>","decryptedChunks: Uint8Array[]","fileName: string","mimeType: string","decryptedChunkFileUris: FileUri[]","e: Error","entity: SomeEntity","chunk: Uint8Array","blobServerAccessInfo: BlobServerAccessInfo","location: string","serverUrl: string","blobHash: string","jsonData: string","blobs: readonly Blob[]","blob: Blob","additionalParams: Dict","concatBinaryData: Uint8Array"],"sources":["../../src/common/api/worker/facades/lazy/BlobFacade.ts"],"sourcesContent":["import { addParamsToUrl, isSuspensionResponse, RestClient, SuspensionBehavior } from \"../../rest/RestClient.js\"\nimport { CryptoFacade } from \"../../crypto/CryptoFacade.js\"\nimport {\n\tassertNonNull,\n\tbase64ToBase64Ext,\n\tclear,\n\tconcat,\n\tgetFirstOrThrow,\n\tgroupBy,\n\tisEmpty,\n\tmapMap,\n\tneverNull,\n\tpromiseMap,\n\tsplitUint8ArrayInChunks,\n\tuint8ArrayToBase64,\n\tuint8ArrayToString,\n} from \"@tutao/tutanota-utils\"\nimport { ArchiveDataType, MAX_BLOB_SIZE_BYTES } from \"../../../common/TutanotaConstants.js\"\n\nimport { HttpMethod, MediaType, resolveTypeReference } from \"../../../common/EntityFunctions.js\"\nimport { assertWorkerOrNode, isApp, isDesktop } from \"../../../common/Env.js\"\nimport type { SuspensionHandler } from \"../../SuspensionHandler.js\"\nimport { BlobService } from \"../../../entities/storage/Services.js\"\nimport { aesDecrypt, AesKey, sha256Hash } from \"@tutao/tutanota-crypto\"\nimport type { FileUri, NativeFileApp } from \"../../../../native/common/FileApp.js\"\nimport type { AesApp } from \"../../../../native/worker/AesApp.js\"\nimport { InstanceMapper } from \"../../crypto/InstanceMapper.js\"\nimport { Blob, BlobReferenceTokenWrapper, createBlobReferenceTokenWrapper } from \"../../../entities/sys/TypeRefs.js\"\nimport { FileReference } from \"../../../common/utils/FileUtils.js\"\nimport { handleRestError } from \"../../../common/error/RestError.js\"\nimport { ProgrammingError } from \"../../../common/error/ProgrammingError.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { BlobGetInTypeRef, BlobPostOut, BlobPostOutTypeRef, BlobServerAccessInfo, createBlobGetIn, createBlobId } from \"../../../entities/storage/TypeRefs.js\"\nimport { AuthDataProvider } from \"../UserFacade.js\"\nimport { doBlobRequestWithRetry, tryServers } from \"../../rest/EntityRestClient.js\"\nimport { BlobAccessTokenFacade } from \"../BlobAccessTokenFacade.js\"\nimport { DefaultEntityRestCache } from \"../../rest/DefaultEntityRestCache.js\"\nimport { SomeEntity } from \"../../../common/EntityTypes.js\"\nimport { encryptBytes } from \"../../crypto/CryptoWrapper.js\"\nimport { BlobReferencingInstance } from \"../../../common/utils/BlobUtils.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\n\nassertWorkerOrNode()\nexport const BLOB_SERVICE_REST_PATH = `/rest/${BlobService.app}/${BlobService.name.toLowerCase()}`\nexport const TAG = \"BlobFacade\"\n\nexport interface BlobLoadOptions {\n\textraHeaders?: Dict\n\tsuspensionBehavior?: SuspensionBehavior\n\t/** override origin for the request */\n\tbaseUrl?: string\n}\n\n/**\n * The BlobFacade uploads and downloads blobs to/from the blob store.\n *\n * It requests tokens from the BlobAccessTokenService and download and uploads the blobs to/from the BlobService.\n *\n * In case of upload it is necessary to make a request to the BlobReferenceService or use the referenceTokens returned by the BlobService PUT in some other service call.\n * Otherwise, the blobs will automatically be deleted after some time. It is not allowed to reference blobs manually in some instance.\n */\nexport class BlobFacade {\n\tconstructor(\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly suspensionHandler: SuspensionHandler,\n\t\tprivate readonly fileApp: NativeFileApp,\n\t\tprivate readonly aesApp: AesApp,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly blobAccessTokenFacade: BlobAccessTokenFacade,\n\t) {}\n\n\t/**\n\t * Encrypts and uploads binary data to the blob store. The binary data is split into multiple blobs in case it\n\t * is too big.\n\t *\n\t * @returns blobReferenceToken that must be used to reference a blobs from an instance. Only to be used once.\n\t */\n\tasync encryptAndUpload(archiveDataType: ArchiveDataType, blobData: Uint8Array, ownerGroupId: Id, sessionKey: AesKey): Promise<BlobReferenceTokenWrapper[]> {\n\t\tconst chunks = splitUint8ArrayInChunks(MAX_BLOB_SIZE_BYTES, blobData)\n\t\tconst doBlobRequest = async () => {\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroupId)\n\t\t\treturn promiseMap(chunks, async (chunk) => await this.encryptAndUploadChunk(chunk, blobServerAccessInfo, sessionKey))\n\t\t}\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictWriteToken(archiveDataType, ownerGroupId)\n\n\t\treturn doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t}\n\n\t/**\n\t * Encrypts and uploads binary data stored as a file to the blob store. The binary data is split into multiple blobs in case it\n\t * is too big.\n\t *\n\t * @returns blobReferenceToken that must be used to reference a blobs from an instance. Only to be used once.\n\t */\n\tasync encryptAndUploadNative(\n\t\tarchiveDataType: ArchiveDataType,\n\t\tfileUri: FileUri,\n\t\townerGroupId: Id,\n\t\tsessionKey: AesKey,\n\t): Promise<BlobReferenceTokenWrapper[]> {\n\t\tif (!isApp() && !isDesktop()) {\n\t\t\tthrow new ProgrammingError(\"Environment is not app or Desktop!\")\n\t\t}\n\t\tconst chunkUris = await this.fileApp.splitFile(fileUri, MAX_BLOB_SIZE_BYTES)\n\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictWriteToken(archiveDataType, ownerGroupId)\n\t\tconst doBlobRequest = async () => {\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroupId)\n\t\t\treturn promiseMap(chunkUris, async (chunkUri) => {\n\t\t\t\treturn this.encryptAndUploadNativeChunk(chunkUri, blobServerAccessInfo, sessionKey)\n\t\t\t})\n\t\t}\n\t\treturn doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t}\n\n\t/**\n\t * Downloads multiple blobs, decrypts and joins them to unencrypted binary data.\n\t *\n\t * @param archiveDataType\n\t * @param referencingInstance that directly references the blobs\n\t * @returns Uint8Array unencrypted binary data\n\t */\n\tasync downloadAndDecrypt(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstance: BlobReferencingInstance,\n\t\tblobLoadOptions: BlobLoadOptions = {},\n\t): Promise<Uint8Array> {\n\t\tconst sessionKey = await this.resolveSessionKey(referencingInstance.entity)\n\t\t// Currently assumes that all the blobs of the instance are in the same archive.\n\t\t// If this changes we need to group by archive and do request for each archive and then concatenate all the chunks.\n\t\tconst doBlobRequest = async () => {\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, blobLoadOptions)\n\t\t\treturn this.downloadAndDecryptMultipleBlobsOfArchive(referencingInstance.blobs, blobServerAccessInfo, sessionKey, blobLoadOptions)\n\t\t}\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictReadBlobsToken(referencingInstance)\n\n\t\tconst blobChunks = await doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t\treturn this.concatenateBlobChunks(referencingInstance, blobChunks)\n\t}\n\n\tprivate concatenateBlobChunks(referencingInstance: BlobReferencingInstance, blobChunks: Map<Id, Uint8Array>) {\n\t\tconst resultSize = Array.from(blobChunks.values()).reduce((sum, blob) => blob.length + sum, 0)\n\t\tconst resultBuffer = new Uint8Array(resultSize)\n\t\tlet offset = 0\n\t\tfor (const blob of referencingInstance.blobs) {\n\t\t\tconst data = blobChunks.get(blob.blobId)\n\t\t\tassertNonNull(data, `Server did not return blob for id : ${blob.blobId}`)\n\t\t\tresultBuffer.set(data, offset)\n\t\t\toffset += data.length\n\t\t}\n\t\treturn resultBuffer\n\t}\n\n\t/**\n\t * Downloads blobs of all {@param referencingInstances}, decrypts them and joins them to unencrypted binaries.\n\t * If some blobs are not found the result will contain {@code null}.\n\t * @returns Map from instance id to the decrypted and concatenated contents of the referenced blobs\n\t */\n\tasync downloadAndDecryptBlobsOfMultipleInstances(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstances: BlobReferencingInstance[],\n\t\tblobLoadOptions: BlobLoadOptions = {},\n\t): Promise<Map<Id, Uint8Array | null>> {\n\t\t// If a mail has multiple attachments, we cannot assume they are all on the same archive.\n\t\t// But all blobs of a single attachment should be in the same archive\n\t\tconst instancesByArchive = groupBy(referencingInstances, (instance) => getFirstOrThrow(instance.blobs).archiveId)\n\n\t\t// instance id to data\n\t\tconst result: Map<Id, Uint8Array | null> = new Map()\n\n\t\tfor (const [_, instances] of instancesByArchive.entries()) {\n\t\t\t// request a token for all instances of the archive\n\t\t\t// download all blobs from all instances for this archive\n\t\t\tconst allBlobs = instances.flatMap((instance) => instance.blobs)\n\t\t\tconst doBlobRequest = async () => {\n\t\t\t\tconst accessInfo = await this.blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, instances, blobLoadOptions)\n\t\t\t\treturn this.downloadBlobsOfOneArchive(allBlobs, accessInfo, blobLoadOptions)\n\t\t\t}\n\t\t\tconst doEvictToken = () => {\n\t\t\t\tfor (const instance of instances) {\n\t\t\t\t\tthis.blobAccessTokenFacade.evictReadBlobsToken(instance)\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst encryptedBlobsOfAllInstances = await doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t\t\t// sort blobs by the instance\n\t\t\tfor (const instance of instances) {\n\t\t\t\tconst decryptedData = await this.decryptInstanceData(instance, encryptedBlobsOfAllInstances)\n\t\t\t\t// return Map of instance id -> blob data\n\t\t\t\tresult.set(instance.elementId, decryptedData)\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\tprivate async decryptInstanceData(instance: BlobReferencingInstance, blobs: Map<Id, Uint8Array>): Promise<Uint8Array | null> {\n\t\t// get the key of the instance\n\t\tconst sessionKey = await this.resolveSessionKey(instance.entity)\n\t\t// decrypt blobs of the instance and concatenate them\n\t\tconst decryptedChunks: Uint8Array[] = []\n\t\tfor (const blob of instance.blobs) {\n\t\t\tconst encryptedChunk = blobs.get(blob.blobId)\n\t\t\tif (encryptedChunk == null) {\n\t\t\t\tconsole.log(TAG, `Did not find blob of the instance. blobId: ${blob.blobId}, instance: ${instance}`)\n\t\t\t\treturn null\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tdecryptedChunks.push(aesDecrypt(sessionKey, encryptedChunk))\n\t\t\t} catch (e) {\n\t\t\t\t// If decrypting one chunk of an instance fails it doesn't make sense to return any data for\n\t\t\t\t// that instance\n\t\t\t\tif (e instanceof CryptoError) {\n\t\t\t\t\tconsole.log(TAG, `Could not decrypt blob of the instance. blobId: ${blob.blobId}, instance: ${instance}`, e)\n\t\t\t\t\treturn null\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn concat(...decryptedChunks)\n\t}\n\n\t/**\n\t * Downloads multiple blobs, decrypts and joins them to unencrypted binary data which will be stored as a file on the\n\t * device.\n\t *\n\t * @param archiveDataType\n\t * @param referencingInstance that directly references the blobs\n\t * @param fileName is written to the returned FileReference\n\t * @param mimeType is written to the returned FileReference\n\t * @returns FileReference to the unencrypted binary data\n\t */\n\tasync downloadAndDecryptNative(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstance: BlobReferencingInstance,\n\t\tfileName: string,\n\t\tmimeType: string,\n\t): Promise<FileReference> {\n\t\tif (!isApp() && !isDesktop()) {\n\t\t\tthrow new ProgrammingError(\"Environment is not app or Desktop!\")\n\t\t}\n\t\tconst sessionKey = await this.resolveSessionKey(referencingInstance.entity)\n\t\tconst decryptedChunkFileUris: FileUri[] = []\n\t\tconst doBlobRequest = async () => {\n\t\t\tclear(decryptedChunkFileUris) // ensure that the decrypted file uris are emtpy in case we retry because of NotAuthorized error\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, {})\n\t\t\treturn promiseMap(referencingInstance.blobs, async (blob) => {\n\t\t\t\tdecryptedChunkFileUris.push(await this.downloadAndDecryptChunkNative(blob, blobServerAccessInfo, sessionKey))\n\t\t\t}).catch(async (e: Error) => {\n\t\t\t\t// cleanup every temporary file in the native part in case an error occured when downloading chun\n\t\t\t\tfor (const decryptedChunkFileUri of decryptedChunkFileUris) {\n\t\t\t\t\tawait this.fileApp.deleteFile(decryptedChunkFileUri)\n\t\t\t\t}\n\t\t\t\tthrow e\n\t\t\t})\n\t\t}\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictReadBlobsToken(referencingInstance)\n\n\t\tawait doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\n\t\t// now decryptedChunkFileUris has the correct order of downloaded blobs, and we need to tell native to join them\n\t\t// check if output already exists and return cached?\n\t\ttry {\n\t\t\tconst decryptedFileUri = await this.fileApp.joinFiles(fileName, decryptedChunkFileUris)\n\t\t\tconst size = await this.fileApp.getSize(decryptedFileUri)\n\t\t\treturn {\n\t\t\t\t_type: \"FileReference\",\n\t\t\t\tname: fileName,\n\t\t\t\tmimeType,\n\t\t\t\tsize,\n\t\t\t\tlocation: decryptedFileUri,\n\t\t\t}\n\t\t} finally {\n\t\t\tfor (const tmpBlobFile of decryptedChunkFileUris) {\n\t\t\t\tawait this.fileApp.deleteFile(tmpBlobFile)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async resolveSessionKey(entity: SomeEntity): Promise<AesKey> {\n\t\treturn neverNull(await this.cryptoFacade.resolveSessionKeyForInstance(entity))\n\t}\n\n\tprivate async encryptAndUploadChunk(chunk: Uint8Array, blobServerAccessInfo: BlobServerAccessInfo, sessionKey: AesKey): Promise<BlobReferenceTokenWrapper> {\n\t\tconst encryptedData = encryptBytes(sessionKey, chunk)\n\t\tconst blobHash = uint8ArrayToBase64(sha256Hash(encryptedData).slice(0, 6))\n\t\tconst queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, { blobHash }, BlobGetInTypeRef)\n\n\t\treturn tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\tconst response = await this.restClient.request(BLOB_SERVICE_REST_PATH, HttpMethod.POST, {\n\t\t\t\t\tqueryParams: queryParams,\n\t\t\t\t\tbody: encryptedData,\n\t\t\t\t\tresponseType: MediaType.Json,\n\t\t\t\t\tbaseUrl: serverUrl,\n\t\t\t\t})\n\t\t\t\treturn await this.parseBlobPostOutResponse(response)\n\t\t\t},\n\t\t\t`can't upload to server`,\n\t\t)\n\t}\n\n\tprivate async encryptAndUploadNativeChunk(\n\t\tfileUri: FileUri,\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tsessionKey: AesKey,\n\t): Promise<BlobReferenceTokenWrapper> {\n\t\tconst encryptedFileInfo = await this.aesApp.aesEncryptFile(sessionKey, fileUri)\n\t\tconst encryptedChunkUri = encryptedFileInfo.uri\n\t\tconst blobHash = await this.fileApp.hashFile(encryptedChunkUri)\n\n\t\treturn tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\treturn await this.uploadNative(encryptedChunkUri, blobServerAccessInfo, serverUrl, blobHash)\n\t\t\t},\n\t\t\t`can't upload to server from native`,\n\t\t)\n\t}\n\n\tprivate async uploadNative(\n\t\tlocation: string,\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tserverUrl: string,\n\t\tblobHash: string,\n\t): Promise<BlobReferenceTokenWrapper> {\n\t\tif (this.suspensionHandler.isSuspended()) {\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.uploadNative(location, blobServerAccessInfo, serverUrl, blobHash))\n\t\t}\n\t\tconst queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, { blobHash }, BlobGetInTypeRef)\n\t\tconst serviceUrl = new URL(BLOB_SERVICE_REST_PATH, serverUrl)\n\t\tconst fullUrl = addParamsToUrl(serviceUrl, queryParams)\n\t\tconst { suspensionTime, responseBody, statusCode, errorId, precondition } = await this.fileApp.upload(location, fullUrl.toString(), HttpMethod.POST, {}) // blobReferenceToken in the response body\n\n\t\tif (statusCode === 201 && responseBody != null) {\n\t\t\treturn this.parseBlobPostOutResponse(uint8ArrayToString(\"utf-8\", responseBody))\n\t\t} else if (responseBody == null) {\n\t\t\tthrow new Error(\"no response body\")\n\t\t} else if (isSuspensionResponse(statusCode, suspensionTime)) {\n\t\t\tthis.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), serviceUrl)\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.uploadNative(location, blobServerAccessInfo, serverUrl, blobHash))\n\t\t} else {\n\t\t\tthrow handleRestError(statusCode, ` | ${HttpMethod.POST} ${fullUrl.toString()} failed to natively upload blob`, errorId, precondition)\n\t\t}\n\t}\n\n\tprivate async parseBlobPostOutResponse(jsonData: string): Promise<BlobReferenceTokenWrapper> {\n\t\tconst responseTypeModel = await resolveTypeReference(BlobPostOutTypeRef)\n\t\tconst instance = JSON.parse(jsonData)\n\t\tconst { blobReferenceToken } = await this.instanceMapper.decryptAndMapToInstance<BlobPostOut>(responseTypeModel, instance, null)\n\t\t// is null in case of post multiple to the BlobService, currently only supported in the rust-sdk\n\t\t// post single always has a valid blobRefernceToken with cardinality one.\n\t\tif (blobReferenceToken == null) {\n\t\t\tthrow new ProgrammingError(\"empty blobReferenceToken not allowed for post single blob\")\n\t\t}\n\t\treturn createBlobReferenceTokenWrapper({ blobReferenceToken })\n\t}\n\n\tprivate async downloadAndDecryptMultipleBlobsOfArchive(\n\t\tblobs: readonly Blob[],\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tsessionKey: AesKey,\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<Map<Id, Uint8Array>> {\n\t\tconst mapWithEncryptedBlobs = await this.downloadBlobsOfOneArchive(blobs, blobServerAccessInfo, blobLoadOptions)\n\t\treturn mapMap(mapWithEncryptedBlobs, (blob) => aesDecrypt(sessionKey, blob))\n\t}\n\n\t/**\n\t * Download blobs of a single archive in a single request\n\t * @return map from blob id to the data\n\t */\n\tprivate async downloadBlobsOfOneArchive(\n\t\tblobs: readonly Blob[],\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<Map<Id, Uint8Array>> {\n\t\tif (isEmpty(blobs)) {\n\t\t\tthrow new ProgrammingError(\"Blobs are empty\")\n\t\t}\n\t\tconst archiveId = getFirstOrThrow(blobs).archiveId\n\t\tif (blobs.some((blob) => blob.archiveId !== archiveId)) {\n\t\t\tthrow new ProgrammingError(\"Must only request blobs of the same archive together\")\n\t\t}\n\t\tconst getData = createBlobGetIn({\n\t\t\tarchiveId,\n\t\t\tblobId: null,\n\t\t\tblobIds: blobs.map(({ blobId }) => createBlobId({ blobId: blobId })),\n\t\t})\n\t\tconst BlobGetInTypeModel = await resolveTypeReference(BlobGetInTypeRef)\n\t\tconst literalGetData = await this.instanceMapper.encryptAndMapToLiteral(BlobGetInTypeModel, getData, null)\n\t\tconst body = JSON.stringify(literalGetData)\n\t\tconst queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, {}, BlobGetInTypeRef)\n\t\tconst concatBinaryData = await tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\treturn await this.restClient.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, {\n\t\t\t\t\tqueryParams: queryParams,\n\t\t\t\t\tbody,\n\t\t\t\t\tresponseType: MediaType.Binary,\n\t\t\t\t\tbaseUrl: serverUrl,\n\t\t\t\t\tnoCORS: true,\n\t\t\t\t\theaders: blobLoadOptions.extraHeaders,\n\t\t\t\t\tsuspensionBehavior: blobLoadOptions.suspensionBehavior,\n\t\t\t\t})\n\t\t\t},\n\t\t\t`can't download from server `,\n\t\t)\n\t\treturn parseMultipleBlobsResponse(concatBinaryData)\n\t}\n\n\tprivate async downloadAndDecryptChunkNative(blob: Blob, blobServerAccessInfo: BlobServerAccessInfo, sessionKey: AesKey): Promise<FileUri> {\n\t\tconst { archiveId, blobId } = blob\n\t\tconst getData = createBlobGetIn({\n\t\t\tarchiveId,\n\t\t\tblobId,\n\t\t\tblobIds: [],\n\t\t})\n\t\tconst BlobGetInTypeModel = await resolveTypeReference(BlobGetInTypeRef)\n\t\tconst literalGetData = await this.instanceMapper.encryptAndMapToLiteral(BlobGetInTypeModel, getData, null)\n\t\tconst _body = JSON.stringify(literalGetData)\n\n\t\tconst blobFilename = blobId + \".blob\"\n\n\t\treturn tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\treturn await this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, blobFilename, { _body })\n\t\t\t},\n\t\t\t`can't download native from server `,\n\t\t)\n\t}\n\n\t/**\n\t * @return the uri of the decrypted blob\n\t */\n\tprivate async downloadNative(\n\t\tserverUrl: string,\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tsessionKey: AesKey,\n\t\tfileName: string,\n\t\tadditionalParams: Dict,\n\t): Promise<FileUri> {\n\t\tif (this.suspensionHandler.isSuspended()) {\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, fileName, additionalParams))\n\t\t}\n\t\tconst serviceUrl = new URL(BLOB_SERVICE_REST_PATH, serverUrl)\n\t\tconst url = addParamsToUrl(serviceUrl, await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, additionalParams, BlobGetInTypeRef))\n\t\tconst { statusCode, encryptedFileUri, suspensionTime, errorId, precondition } = await this.fileApp.download(url.toString(), fileName, {})\n\t\tif (statusCode == 200 && encryptedFileUri != null) {\n\t\t\tconst decryptedFileUrl = await this.aesApp.aesDecryptFile(sessionKey, encryptedFileUri)\n\t\t\ttry {\n\t\t\t\tawait this.fileApp.deleteFile(encryptedFileUri)\n\t\t\t} catch {\n\t\t\t\tconsole.log(\"Failed to delete encrypted file\", encryptedFileUri)\n\t\t\t}\n\t\t\treturn decryptedFileUrl\n\t\t} else if (isSuspensionResponse(statusCode, suspensionTime)) {\n\t\t\tthis.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), serviceUrl)\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, fileName, additionalParams))\n\t\t} else {\n\t\t\tthrow handleRestError(statusCode, ` | ${HttpMethod.GET} failed to natively download attachment`, errorId, precondition)\n\t\t}\n\t}\n}\n\n/**\n * Deserializes a list of BlobWrappers that are in the following binary format\n * element [ #blobs ] [ blobId ] [ blobHash ] [blobSize] [blob]     [ . . . ]    [ blobNId ] [ blobNHash ] [blobNSize] [blobN]\n * bytes     4          9          6           4          blobSize                  9          6            4           blobSize\n *\n * @return a map from blobId to the binary data\n */\nexport function parseMultipleBlobsResponse(concatBinaryData: Uint8Array): Map<Id, Uint8Array> {\n\tconst dataView = new DataView(concatBinaryData.buffer)\n\tconst result = new Map<Id, Uint8Array>()\n\tconst blobCount = dataView.getInt32(0)\n\tif (blobCount === 0) {\n\t\treturn result\n\t}\n\tif (blobCount < 0) {\n\t\tthrow new Error(`Invalid blob count: ${blobCount}`)\n\t}\n\tlet offset = 4\n\twhile (offset < concatBinaryData.length) {\n\t\tconst blobIdBytes = concatBinaryData.slice(offset, offset + 9)\n\t\tconst blobId = base64ToBase64Ext(uint8ArrayToBase64(blobIdBytes))\n\n\t\tconst blobSize = dataView.getInt32(offset + 15)\n\t\tconst dataStartOffset = offset + 19\n\t\tif (blobSize < 0 || dataStartOffset + blobSize > concatBinaryData.length) {\n\t\t\tthrow new Error(`Invalid blob size: ${blobSize}. Remaining length: ${concatBinaryData.length - dataStartOffset}`)\n\t\t}\n\t\tconst contents = concatBinaryData.slice(dataStartOffset, dataStartOffset + blobSize)\n\t\tresult.set(blobId, contents)\n\t\toffset = dataStartOffset + blobSize\n\t}\n\tif (blobCount !== result.size) {\n\t\tthrow new Error(`Parsed wrong number of blobs: ${blobCount}. Expected: ${result.size}`)\n\t}\n\treturn result\n}\n"],"mappings":"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"}