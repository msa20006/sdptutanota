
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { stringToUtf8Uint8Array } from "./dist-CJHwsXKY.js";
import { Deflater, PdfStreamEncoding, boldFontWidths, regularFontWidths } from "./Deflater-VR1UiLhC.js";
import { InvoiceItemType, InvoiceTexts_default, InvoiceType, PaymentMethod, VatType, countryUsesGerman, getInvoiceItemTypeName } from "./InvoiceUtils-3xBqh6rg.js";

//#region ../src/common/api/worker/pdf/PdfDocument.ts
let PDF_FONTS = function(PDF_FONTS$1) {
	PDF_FONTS$1[PDF_FONTS$1["REGULAR"] = 1] = "REGULAR";
	PDF_FONTS$1[PDF_FONTS$1["BOLD"] = 2] = "BOLD";
	PDF_FONTS$1[PDF_FONTS$1["INVISIBLE_CID"] = 3] = "INVISIBLE_CID";
	return PDF_FONTS$1;
}({});
let PDF_IMAGES = function(PDF_IMAGES$1) {
	PDF_IMAGES$1[PDF_IMAGES$1["TUTA_LOGO"] = 1] = "TUTA_LOGO";
	PDF_IMAGES$1[PDF_IMAGES$1["ADDRESS"] = 2] = "ADDRESS";
	return PDF_IMAGES$1;
}({});
let TEXT_RENDERING_MODE = function(TEXT_RENDERING_MODE$1) {
	TEXT_RENDERING_MODE$1[TEXT_RENDERING_MODE$1["NORMAL"] = 0] = "NORMAL";
	TEXT_RENDERING_MODE$1[TEXT_RENDERING_MODE$1["INVISIBLE"] = 3] = "INVISIBLE";
	return TEXT_RENDERING_MODE$1;
}({});
const MARGIN_TOP = 20;
const MARGIN_LEFT = 25;
const TABLE_VERTICAL_SPACING = 5;
const TEXT_VERTICAL_SPACING = 2;
const PAPER_HEIGHT = 297;
const PAPER_WIDTH = 210;
const ORIGIN_POSITION = [0, 0];
const TRANSFORM_MATRIX = `1 0 0 -1 0 ${mmToPSPoint(PAPER_HEIGHT)}`;
const ROWS_FIRST_PAGE_MULTIPLE = 24;
const ROWS_N_PAGE = 50;
const ADDRESS_FIELD_WIDTH = 800;
const ADDRESS_FIELD_HEIGHT = 320;
var PdfDocument = class {
	pdfWriter;
	deflater;
	pageCount = 0;
	textStream = "";
	graphicsStream = "";
	currentFont = PDF_FONTS.REGULAR;
	currentFontSize = 12;
	pageList = [];
	constructor(pdfWriter) {
		this.pdfWriter = pdfWriter;
		this.pdfWriter.setupDefaultObjects();
		this.deflater = new Deflater();
	}
	/**
	* Create the document: commit all streams to objects and let the PdfWriter write the file
	*/
	async create() {
		await this.renderText();
		await this.renderGraphics();
		this.pdfWriter.createObject(new Map([
			["Type", "/Pages"],
			["Parent", { refId: "CATALOG" }],
			["Kids", this.pageList],
			["Count", `${this.pageCount}`]
		]), "PAGES");
		return await this.pdfWriter.writePdfFile();
	}
	/**
	* Closes the current textStream and writes it into an object
	*/
	async renderText() {
		const encodedTextStream = await this.deflater.deflate(stringToUtf8Uint8Array(`BT q ${TRANSFORM_MATRIX} cm /F${this.currentFont} ${this.currentFontSize} Tf ` + this.textStream + ` Q ET`));
		this.pdfWriter.createStreamObject(new Map(), encodedTextStream, PdfStreamEncoding.FLATE, `TEXT_${this.pageCount}`);
		this.textStream = "";
	}
	/**
	* Closes the current graphicsStream and writes it into an object
	*/
	async renderGraphics() {
		const encodedGraphicsStream = await this.deflater.deflate(stringToUtf8Uint8Array(`q ${TRANSFORM_MATRIX} cm ` + this.graphicsStream + ` Q`));
		this.pdfWriter.createStreamObject(new Map(), encodedGraphicsStream, PdfStreamEncoding.FLATE, `GRAPHICS_${this.pageCount}`);
		this.graphicsStream = "";
	}
	/**
	* Append a new page to the PDF document
	*/
	async addPage() {
		if (this.pageCount > 0) {
			await this.renderText();
			await this.renderGraphics();
		}
		this.pageCount++;
		const pageRefId = `PAGE_${this.pageCount}`;
		this.pdfWriter.createObject(new Map([
			["Type", "/Page"],
			["Parent", { refId: "PAGES" }],
			["MediaBox", `[ 0 0 ${mmToPSPoint(PAPER_WIDTH)} ${mmToPSPoint(PAPER_HEIGHT)}]`],
			["Resources", { refId: "RESOURCES" }],
			["Contents", [{ refId: `TEXT_${this.pageCount}` }, { refId: `GRAPHICS_${this.pageCount}` }]]
		]), pageRefId);
		this.pageList.push({ refId: pageRefId });
		return this;
	}
	/**
	* Add a text string at the given coordinates in millimeters
	* The coordinate field is in the fourth quadrant, i.e. the point of origin is top-left
	* @param text The text to place
	* @param position Coordinates [x,y] where to place the text, can be omitted to keep the current position
	* @param byteLength The byteLength of every character in the string. By default, this is 1 byte = 2 nibbles = "XX" e.g. "20" = "SPACE".
	* Do not change it to more than 1 byte unless you can verify any text printed this way will be displayed correctly on the PDF.
	*/
	addText(text, position = ORIGIN_POSITION, byteLength = 1) {
		if (text === "") return this;
		if (position !== ORIGIN_POSITION) this.textStream += `1 0 0 -1 ${mmToPSPoint(position[0])} ${mmToPSPoint(position[1]) + this.currentFontSize} Tm <${toUnicodePoint(text, byteLength).join("")}> Tj `;
else this.textStream += `<${toUnicodePoint(text, byteLength).join("")}> Tj `;
		return this;
	}
	/**
	*
	*
	* Add a text string at the given coordinates in millimeters and align it to the right of its "container"
	* The container is specified by a width in millimeters.
	* @param text The text to place
	* @param position Coordinates [x,y] where to place the text, can be omitted to keep the current position
	* @param containerWidth The width in millimeters of the "container" in which the text is to be right aligned in
	*/
	addTextRightAlign(text, position, containerWidth) {
		if (text === "") return this;
		const unicodePoints = toUnicodePoint(text);
		this.textStream += `1 0 0 -1 ${mmToPSPoint(position[0]) + mmToPSPoint(containerWidth) - getWordLengthInPoints(unicodePoints, this.currentFont, this.currentFontSize)} ${mmToPSPoint(position[1]) + this.currentFontSize} Tm <${unicodePoints.join("")}> Tj `;
		return this;
	}
	/**
	* Add a linebreak in the text
	*/
	addLineBreak() {
		this.textStream += "T* ";
		return this;
	}
	/**
	* Add an image at the given coordinates in millimeters
	* The coordinate field is in the fourth quadrant, i.e. the point of origin is top-left
	* @param image The image to add which is an enum of readily embeddable images
	* @param position Coordinates [x,y] where to place the image
	* @param dimensions Dimensions [width, height] of the image. Image will be stretched to fit the given dimensions
	*/
	addImage(image, position, dimensions) {
		this.graphicsStream += `Q q ${TRANSFORM_MATRIX} cm ${mmToPSPoint(dimensions[0])} 0 0 -${mmToPSPoint(dimensions[1])} ${mmToPSPoint(position[0])} ${mmToPSPoint(position[1])} cm /Im${image} Do Q q ${TRANSFORM_MATRIX} cm `;
		return this;
	}
	/**
	* Draw black line "fromPos" "toPos"
	* @param fromPos Starting point of the line [x,y]
	* @param toPos Ending point of the line [x,y]
	*/
	addDrawnLine(fromPos, toPos) {
		this.graphicsStream += `${mmToPSPoint(fromPos[0])} ${mmToPSPoint(fromPos[1])} m ${mmToPSPoint(toPos[0])} ${mmToPSPoint(toPos[1])} l s `;
		return this;
	}
	/**
	* Change the currently used text font
	* @param font Font to change to which is an enum of readily embeddable fonts
	* @param points Font size in PostScript points
	*/
	changeFont(font, points) {
		this.textStream += `/F${font} ${points} Tf ${points + TEXT_VERTICAL_SPACING} TL `;
		this.currentFont = font;
		this.currentFontSize = points;
		return this;
	}
	/**
	* Changes the current text cursor position to the specified position
	* @param position The position to place the cursor at
	*/
	changeTextCursorPosition(position) {
		this.textStream += `1 0 0 -1 ${mmToPSPoint(position[0])} ${mmToPSPoint(position[1]) + this.currentFontSize} Tm `;
		return this;
	}
	/**
	* Change font size of the currently used font
	* @param points Font size in PostScript points
	*/
	changeFontSize(points) {
		this.textStream += `/F${this.currentFont} ${points} Tf ${points + TEXT_VERTICAL_SPACING} TL `;
		this.currentFontSize = points;
		return this;
	}
	/**
	* Change the grayscale of the current text
	* @param grayScale Float between 0 and 1 by which the text lightness shall be adjusted. 1 = white, 0 = black
	*/
	changeTextGrayscale(grayScale) {
		grayScale = Math.max(Math.min(grayScale, 1), 0);
		this.textStream += `${grayScale} g `;
		return this;
	}
	/**
	* Change the rendering mode of the current text. The rendering mode values and their effect are the same as the PDF standard describes
	* @param renderingMode Rendering mode (number) to set
	*/
	changeTextRenderingMode(renderingMode) {
		this.textStream += `${renderingMode} Tr `;
		return this;
	}
	/**
	* Render a table with the input of a two-dimensional array. Produces automatic page breaks.
	* Returns the table's height on the last page where it is still rendered, allowing that value to be used to continue placing objects after the table
	* @param position Coordinates [x,y] where to place the table's origin point
	* @param tableWidth The width of the table
	* @param columns Array of ColumnObjects, specifying the header name and width of each column in percent of the total tableWidth { headerName: string, columnWidth: number  }
	* @param data Two-dimensional array of strings, specifying the data for every row : [ //row1 [a,b,c] //row2 [x,y,z]...   ]. The inner arrays (rows) must have the same length as the columns array!
	* @param rowsOnFirstPage How many rows can fit on the first page. This is dynamically decided by the amount of text that should follow after the table
	*/
	async addTable(position, tableWidth, columns, data, rowsOnFirstPage = 4) {
		this.addTableHeader(position, tableWidth, columns);
		const entriesOnFirstPage = data.length > rowsOnFirstPage ? ROWS_FIRST_PAGE_MULTIPLE : rowsOnFirstPage;
		let tableHeight = this.addTablePage(position, tableWidth, columns, data.slice(0, entriesOnFirstPage));
		let entryCounter = entriesOnFirstPage;
		while (entryCounter < data.length) {
			await this.addPage();
			position = [position[0], MARGIN_TOP];
			tableHeight = this.addTablePage(position, tableWidth, columns, data.slice(entryCounter, entryCounter + ROWS_N_PAGE));
			entryCounter += ROWS_N_PAGE;
		}
		const lastPageCannotFitRemainingRows = (entryCounter - entriesOnFirstPage) % ROWS_N_PAGE <= ROWS_FIRST_PAGE_MULTIPLE;
		const insufficientSpaceBelowTable = entryCounter == ROWS_FIRST_PAGE_MULTIPLE;
		if (!lastPageCannotFitRemainingRows || insufficientSpaceBelowTable) {
			await this.addPage();
			tableHeight = MARGIN_TOP;
		}
		this.addDrawnLine([position[0], tableHeight], [position[0] + tableWidth, tableHeight]);
		return tableHeight;
	}
	/**
	* Render the actual visible table, starting with a header and all subsequent entries inside the "chunk"
	*/
	addTablePage(position, tableWidth, columns, chunk) {
		this.addTableHeader(position, tableWidth, columns);
		let previousRowOffset = TABLE_VERTICAL_SPACING;
		for (const row of chunk) {
			this.addTableRow([position[0], position[1] + previousRowOffset], columns, row);
			previousRowOffset += TABLE_VERTICAL_SPACING;
		}
		return position[1] + previousRowOffset;
	}
	/**
	* Render the table header
	*/
	addTableHeader(position, tableWidth, columns) {
		this.changeFont(PDF_FONTS.BOLD, 11);
		this.addTableRow(position, columns, columns.flatMap((column) => column.headerName));
		this.addDrawnLine([position[0], position[1] + 5], [position[0] + tableWidth, position[1] + 5]);
		this.changeFont(PDF_FONTS.REGULAR, 11);
	}
	/**
	* Render a table row
	*/
	addTableRow(position, columnInfo, rowItems) {
		if (rowItems.length !== columnInfo.length) console.error("Amount of items in table row not equal to amount of columns!");
		let previousWidthOffset = 0;
		for (let i = 0; i < rowItems.length; i++) {
			if (i >= 2) this.addTextRightAlign(rowItems[i], [position[0] + previousWidthOffset, position[1]], columnInfo[i].columnWidth);
else this.addText(rowItems[i], [position[0] + previousWidthOffset, position[1]]);
			previousWidthOffset += columnInfo[i].columnWidth;
		}
	}
	/**
	* Renders an address field, allowing the inclusion of any character inside text.
	* If any multibyte character outside the defined encoding is detected, the text will be written as an image via the canvas API.
	* The image will then be attached be inserted into the PDF. If the image generation fails (missing canvas support) fallback text will be rendered
	* @param position Coordinates [x,y] where to place the field's origin point
	* @param address String containing the address (expected to hold multiple newlines)
	*/
	async addAddressField(position, address) {
		const addressParts = address.split("\n");
		let imageBuffer = new ArrayBuffer(0);
		let byteLengthForAddress = 1;
		try {
			if (!areStringPartsOneByteLength(addressParts)) {
				const canvas = new OffscreenCanvas(ADDRESS_FIELD_WIDTH, ADDRESS_FIELD_HEIGHT);
				const context = canvas.getContext("2d");
				if (context) {
					context.font = "36px serif";
					context.fillStyle = "white";
					context.fillRect(0, 0, canvas.width, canvas.height);
					context.fillStyle = "black";
					for (let i = 0; i < addressParts.length; i++) context.fillText(addressParts[i], 0, 40 * (i + 1));
					const dataUrl = await canvas.convertToBlob({ type: "image/jpeg" });
					imageBuffer = await dataUrl.arrayBuffer();
					this.addImage(PDF_IMAGES.ADDRESS, position, [ADDRESS_FIELD_WIDTH / 8, ADDRESS_FIELD_HEIGHT / 8]);
					byteLengthForAddress = 2;
					this.changeTextRenderingMode(TEXT_RENDERING_MODE.INVISIBLE);
					this.changeFont(PDF_FONTS.INVISIBLE_CID, 12);
				} else throw new Error("PDF Canvas Error - Could not access OffscreenCanvasContext2D.");
			}
		} catch (err) {
			console.warn(`PDF Error - Cannot render canvas. This is likely because the browser does not support OffscreenCanvas. The error was:\n"${err}"`);
		}
		this.pdfWriter.createStreamObject(new Map([
			["Name", "/Im2"],
			["Type", "/XObject"],
			["Subtype", "/Image"],
			["Width", `${ADDRESS_FIELD_WIDTH}`],
			["Height", `${ADDRESS_FIELD_HEIGHT}`],
			["BitsPerComponent", "8"],
			["ColorSpace", "/DeviceRGB"]
		]), new Uint8Array(imageBuffer), PdfStreamEncoding.DCT, "IMG_ADDRESS");
		for (const addressPart of addressParts) this.addText(addressPart, ORIGIN_POSITION, byteLengthForAddress).addLineBreak();
		this.changeFont(PDF_FONTS.REGULAR, 12);
		this.changeTextRenderingMode(TEXT_RENDERING_MODE.NORMAL);
	}
};
function toUnicodePoint(input, byteLength = 1) {
	if (byteLength === 1) {
		const out = [];
		for (let i = 0; i < input.length; i++) {
			const codePoint = input.codePointAt(i);
			if (codePoint && isCodePointOneByteLength(codePoint)) out.push(codePoint.toString(16));
else console.warn(`Attempted to render a character longer than one byte. Character was ${input[i]} with a code of ${codePoint}.`);
		}
		return out;
	} else return input.split("").map((c) => c.charCodeAt(0).toString(16).padStart(4, "0"));
}
function isCodePointOneByteLength(codePoint) {
	return codePoint < 256;
}
function areStringPartsOneByteLength(stringParts) {
	for (const addressPart of stringParts) for (let i = 0; i < addressPart.length; i++) {
		const codePoint = addressPart.codePointAt(i);
		if (codePoint && !isCodePointOneByteLength(codePoint)) return false;
	}
	return true;
}
function getWordLengthInPoints(codePoints, font, fontSize) {
	const widthsArray = font === PDF_FONTS.REGULAR ? regularFontWidths : boldFontWidths;
	let total = 0;
	for (let i = 0; i < codePoints.length; i++) {
		let index = parseInt(codePoints[i], 16) - 32;
		total += 1 / (1e3 / widthsArray[index]);
	}
	return total * fontSize;
}
/**
* Convert millimeters to PostScript points
*/
function mmToPSPoint(mm) {
	return mm * 2.834645688;
}

//#endregion
//#region ../src/common/api/worker/invoicegen/PdfInvoiceGenerator.ts
var PdfInvoiceGenerator = class {
	doc;
	languageCode = "en";
	invoiceNumber;
	customerId;
	invoice;
	constructor(pdfWriter, invoice, invoiceNumber, customerId) {
		this.invoice = invoice;
		this.invoiceNumber = invoiceNumber;
		this.customerId = customerId;
		this.languageCode = countryUsesGerman(this.invoice.country);
		this.doc = new PdfDocument(pdfWriter);
	}
	/**
	* Generate the PDF document
	*/
	async generate() {
		await this.doc.addPage();
		this.doc.addImage(PDF_IMAGES.TUTA_LOGO, [25, MARGIN_TOP + 15.7], [45, 15.7]);
		this.renderSideBarInfo();
		await this.renderAddressField();
		this.renderInvoiceInfo();
		await this.renderInvoiceTable();
		this.renderAdditional();
		this.renderLegalDisclaimer();
		return await this.doc.create();
	}
	/**
	* The sidebar on the document in the top-right corner
	*/
	renderSideBarInfo() {
		this.doc.changeFont(PDF_FONTS.BOLD, 11).addText(InvoiceTexts_default.universal.companyName, [MARGIN_LEFT + 125, MARGIN_TOP]).changeFont(PDF_FONTS.REGULAR, 11).addLineBreak().addText(InvoiceTexts_default.universal.addressStreet).addLineBreak().addText(InvoiceTexts_default[this.languageCode].addressPostal).addLineBreak().addText(InvoiceTexts_default[this.languageCode].addressCountry).addLineBreak().addLineBreak().addText(InvoiceTexts_default[this.languageCode].tutaPhone).addLineBreak().addText(InvoiceTexts_default.universal.tutaFax).addLineBreak().addText(InvoiceTexts_default.universal.tutaEmail).addLineBreak().addText(InvoiceTexts_default.universal.tutaWebsite).addLineBreak().addLineBreak().addText(InvoiceTexts_default[this.languageCode].yourCustomerId).addLineBreak().addText(this.customerId).changeFontSize(12).addText(`${InvoiceTexts_default[this.languageCode].addressCity}, ${this.formatInvoiceDate(this.invoice.date)}`, [MARGIN_LEFT + 125, MARGIN_TOP + 70]);
	}
	/**
	* The short address field of Tuta and the address field of the customer below the image
	*/
	async renderAddressField() {
		this.doc.changeFontSize(9).addText(`${InvoiceTexts_default.universal.companyName} - ${InvoiceTexts_default.universal.addressStreet} - ${InvoiceTexts_default[this.languageCode].addressPostal}`, [MARGIN_LEFT, MARGIN_TOP + 35]).addLineBreak().changeFontSize(11).addLineBreak();
		await this.doc.addAddressField([MARGIN_LEFT, MARGIN_TOP + 82], this.invoice.address);
	}
	/**
	* The basic invoice info above the invoice table
	*/
	renderInvoiceInfo() {
		this.doc.changeFontSize(18).addText(this.getInvoiceTypeName(this.invoice.invoiceType, this.invoice.grandTotal), [MARGIN_LEFT, MARGIN_TOP + 90]).changeFont(PDF_FONTS.BOLD, 12).addText(`${InvoiceTexts_default[this.languageCode].invoiceNumber} ${this.invoiceNumber}`, [MARGIN_LEFT, MARGIN_TOP + 100]).changeFont(PDF_FONTS.REGULAR, 11);
		if (this.invoice.invoiceType === InvoiceType.INVOICE) this.doc.addText(InvoiceTexts_default[this.languageCode].asAgreedBlock, [MARGIN_LEFT, MARGIN_TOP + 110]);
	}
	/**
	* The table with all invoice items
	*/
	async renderInvoiceTable() {
		const columns = [
			{
				headerName: InvoiceTexts_default[this.languageCode].quantity,
				columnWidth: 19.8
			},
			{
				headerName: InvoiceTexts_default[this.languageCode].item,
				columnWidth: 95.7
			},
			{
				headerName: InvoiceTexts_default[this.languageCode].singlePrice,
				columnWidth: 24.75
			},
			{
				headerName: InvoiceTexts_default[this.languageCode].totalPrice,
				columnWidth: 24.75
			}
		];
		const tableData = [];
		for (const invoiceItem of this.invoice.items) {
			tableData.push([
				this.formatAmount(invoiceItem.itemType, invoiceItem.amount),
				getInvoiceItemTypeName(invoiceItem.itemType, this.languageCode),
				invoiceItem.singlePrice == null ? "" : this.formatInvoiceCurrency(invoiceItem.singlePrice),
				this.formatInvoiceCurrency(invoiceItem.totalPrice)
			]);
			tableData.push([
				"",
				`${this.formatInvoiceDate(invoiceItem.startDate)} - ${this.formatInvoiceDate(invoiceItem.endDate)}`,
				"",
				""
			]);
		}
		const tableEndPoint = await this.doc.addTable([MARGIN_LEFT, MARGIN_TOP + 120], 165, columns, tableData, this.getTableRowsForFirstPage());
		this.renderTableSummary(tableEndPoint, columns);
		this.doc.changeTextCursorPosition([MARGIN_LEFT, tableEndPoint + 4 * TABLE_VERTICAL_SPACING]);
	}
	/**
	* Summary of totals and applied VAT below the rendered table
	*/
	renderTableSummary(tableEndPoint, columns) {
		let additionalVerticalSpace = 1;
		this.doc.changeFont(PDF_FONTS.REGULAR, 11);
		this.doc.addTableRow([MARGIN_LEFT, tableEndPoint], columns, [
			"",
			"",
			InvoiceTexts_default[this.languageCode].subTotal,
			this.formatInvoiceCurrency(this.invoice.subTotal)
		]);
		if (this.invoice.vatType === VatType.ADD_VAT) this.doc.addTableRow([MARGIN_LEFT, tableEndPoint + TABLE_VERTICAL_SPACING], columns, [
			"",
			"",
			`${InvoiceTexts_default[this.languageCode].addedVat} ${this.invoice.vatRate}${InvoiceTexts_default[this.languageCode].vatPercent}`,
			this.formatInvoiceCurrency(this.invoice.vat)
		]);
else if (this.invoice.vatType === VatType.VAT_INCLUDED_SHOWN) this.doc.addTableRow([MARGIN_LEFT, tableEndPoint + TABLE_VERTICAL_SPACING], columns, [
			"",
			"",
			`${InvoiceTexts_default[this.languageCode].includedVat} ${this.invoice.vatRate}${InvoiceTexts_default[this.languageCode].vatPercent}`,
			this.formatInvoiceCurrency(this.invoice.vat)
		]);
else additionalVerticalSpace -= 1;
		this.doc.changeFont(PDF_FONTS.BOLD, 11);
		this.doc.addTableRow([MARGIN_LEFT, tableEndPoint + (additionalVerticalSpace + 1) * TABLE_VERTICAL_SPACING], columns, [
			"",
			"",
			InvoiceTexts_default[this.languageCode].grandTotal,
			this.formatInvoiceCurrency(this.invoice.vatType == VatType.NO_VAT_CHARGE_TUTAO ? this.invoice.subTotal : this.invoice.grandTotal)
		]);
	}
	/**
	* Additional blocks displayed below the table depending on invoice type, vat type and payment method
	*/
	renderAdditional() {
		this.doc.changeFont(PDF_FONTS.REGULAR, 11);
		switch (this.invoice.vatType) {
			case VatType.ADD_VAT:
			case VatType.VAT_INCLUDED_SHOWN: break;
			case VatType.NO_VAT:
				if (this.invoice.vatIdNumber != null) this.doc.addText(InvoiceTexts_default[this.languageCode].reverseChargeVatIdNumber1).addLineBreak().addText(InvoiceTexts_default[this.languageCode].reverseChargeVatIdNumber2).addLineBreak().addText(`${InvoiceTexts_default[this.languageCode].yourVatId} `).changeFont(PDF_FONTS.BOLD, 11).addText(`${this.invoice.vatIdNumber}`).changeFont(PDF_FONTS.REGULAR, 11);
else this.doc.addText(InvoiceTexts_default[this.languageCode].netPricesNoVatInGermany);
				break;
			case VatType.NO_VAT_CHARGE_TUTAO:
				this.doc.addText(InvoiceTexts_default[this.languageCode].reverseChargeAffiliate).addLineBreak().addText(InvoiceTexts_default[this.languageCode].reverseChargeVatIdNumber2);
				if (this.invoice.vatIdNumber != null) this.doc.addLineBreak().addText(`${InvoiceTexts_default[this.languageCode].yourVatId} `).changeFont(PDF_FONTS.BOLD, 11).addText(`${this.invoice.vatIdNumber}`);
				break;
			case VatType.VAT_INCLUDED_HIDDEN:
				this.doc.addText(InvoiceTexts_default[this.languageCode].noVatInGermany);
				break;
			default: throw new Error("Unknown VatType " + this.invoice.vatType);
		}
		this.doc.addLineBreak();
		this.doc.addLineBreak();
		if (this.invoice.invoiceType === InvoiceType.INVOICE) {
			switch (this.invoice.paymentMethod) {
				case PaymentMethod.INVOICE:
					this.doc.addText(InvoiceTexts_default[this.languageCode].paymentInvoiceDue1).addLineBreak().addText(InvoiceTexts_default[this.languageCode].paymentInvoiceDue2).addLineBreak().addLineBreak().addText(InvoiceTexts_default[this.languageCode].paymentInvoiceHolder).addLineBreak().addText(InvoiceTexts_default[this.languageCode].paymentInvoiceBank).addLineBreak().addText(InvoiceTexts_default[this.languageCode].paymentInvoiceIBAN).addLineBreak().addText(InvoiceTexts_default[this.languageCode].paymentInvoiceBIC).addLineBreak().addText(InvoiceTexts_default[this.languageCode].paymentInvoiceProvideNumber1).changeFont(PDF_FONTS.BOLD, 11).addText(` ${this.invoiceNumber} `).changeFont(PDF_FONTS.REGULAR, 11).addLineBreak().addText(InvoiceTexts_default[this.languageCode].paymentInvoiceProvideNumber2);
					break;
				case PaymentMethod.CREDIT_CARD:
					this.doc.addText(InvoiceTexts_default[this.languageCode].paymentCreditCard);
					break;
				case PaymentMethod.PAYPAL:
					this.doc.addText(InvoiceTexts_default[this.languageCode].paymentPaypal);
					break;
				case PaymentMethod.ACCOUNT_BALANCE:
					this.doc.addText(InvoiceTexts_default[this.languageCode].paymentAccountBalance);
					break;
			}
			this.doc.addLineBreak().addLineBreak().addText(InvoiceTexts_default[this.languageCode].thankYou);
		}
	}
	/**
	* The legal disclaimer info at the bottom of the last page
	*/
	renderLegalDisclaimer() {
		this.doc.changeFont(PDF_FONTS.REGULAR, 10).addText(InvoiceTexts_default[this.languageCode].legalNoSigned, [MARGIN_LEFT, MARGIN_TOP + 240]).addLineBreak().addLineBreak().changeTextGrayscale(.5).addText(InvoiceTexts_default[this.languageCode].legalRepresented, [MARGIN_LEFT, MARGIN_TOP + 250]).addLineBreak().addText(InvoiceTexts_default[this.languageCode].legalRegistration).addLineBreak().addText(InvoiceTexts_default[this.languageCode].legalVatIdentification).addLineBreak().addText(InvoiceTexts_default[this.languageCode].legalBankAccount);
	}
	/**
	* Determines how many table rows (invoice items) can be rendered on the first page depending on the texts that follow after the table
	*/
	getTableRowsForFirstPage() {
		if (this.invoice.paymentMethod === PaymentMethod.INVOICE && this.invoice.vatIdNumber != null && (this.invoice.vatType === VatType.NO_VAT || this.invoice.vatType === VatType.NO_VAT_CHARGE_TUTAO)) return 4;
else return 8;
	}
	/**
	* Get the name of a given InvoiceType
	*/
	getInvoiceTypeName(type, amount) {
		switch (type) {
			case InvoiceType.INVOICE: return InvoiceTexts_default[this.languageCode].invoice;
			case InvoiceType.CREDIT: return InvoiceTexts_default[this.languageCode].credit;
			case InvoiceType.REFERRAL_CREDIT: if (parseFloat(amount) >= 0) return InvoiceTexts_default[this.languageCode].credit;
else return InvoiceTexts_default[this.languageCode].cancelCredit;
			default: throw new Error("Invalid InvoiceType " + type);
		}
	}
	/**
	* Format the date depending on document language (dd.mm.yyyy) / (dd. Mon yyyy)
	*/
	formatInvoiceDate(date) {
		if (date == null) return "";
		if (this.languageCode === "de") return date.toLocaleDateString("de-DE", {
			day: "2-digit",
			month: "2-digit",
			year: "numeric"
		});
else return date.toLocaleDateString("en-UK", {
			day: "2-digit",
			month: "short",
			year: "numeric"
		});
	}
	/**
	* Format the currency separator (dot, comma) depending on the country
	*/
	formatInvoiceCurrency(price) {
		price = `${price} EUR`;
		return this.languageCode === "de" ? price.replace(".", ",") : price;
	}
	/**
	* Format the amount of storage into the appropriate byte unit if the item is a legacy storage package. Otherwise, return as is
	*/
	formatAmount(itemType, amount) {
		if (itemType === InvoiceItemType.StoragePackage || itemType === InvoiceItemType.StoragePackageUpgrade) {
			const numAmount = Number(amount);
			return numAmount < 1e3 ? `${amount} GB` : `${numAmount / 1e3} TB`;
		} else return amount;
	}
};

//#endregion
export { PdfInvoiceGenerator, areStringPartsOneByteLength };
//# sourceMappingURL=PdfInvoiceGenerator-DretJohb.js.map