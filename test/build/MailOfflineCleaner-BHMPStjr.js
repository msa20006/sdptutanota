
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { DAY_IN_MILLIS, assertNotNull, groupByAndMap } from "./dist-CJHwsXKY.js";
import { AccountType, OFFLINE_STORAGE_DEFAULT_TIME_RANGE_DAYS } from "./TutanotaConstants-3bwAESYA.js";
import { DEFAULT_MAILSET_ENTRY_CUSTOM_CUTOFF_TIMESTAMP, GENERATED_MAX_ID, constructMailSetEntryId, elementIdPart, firstBiggerThanSecond, getElementId, listIdPart, timestampToGeneratedId } from "./EntityUtils-RQxXZlcV.js";
import { FileTypeRef, MailBoxTypeRef, MailDetailsBlobTypeRef, MailDetailsDraftTypeRef, MailFolderTypeRef, MailSetEntryTypeRef, MailTypeRef } from "./TypeRefs-CR3TLWn0.js";
import { UserTypeRef } from "./TypeRefs-BP1jvX9p.js";
import { FolderSystem } from "./FolderSystem-DLrUB8MO.js";
import { isDraft, isSpamOrTrashFolder } from "./MailChecks-PhVUoR7f.js";

//#region ../src/mail-app/workerUtils/offline/MailOfflineCleaner.ts
var MailOfflineCleaner = class {
	async cleanOfflineDb(offlineStorage, timeRangeDays, userId, now) {
		const user = await offlineStorage.get(UserTypeRef, null, userId);
		const isFreeUser = user?.accountType === AccountType.FREE;
		const timeRange = isFreeUser || timeRangeDays == null ? OFFLINE_STORAGE_DEFAULT_TIME_RANGE_DAYS : timeRangeDays;
		const daysSinceDayAfterEpoch = now / DAY_IN_MILLIS - 1;
		const timeRangeMillisSafe = Math.min(daysSinceDayAfterEpoch, timeRange) * DAY_IN_MILLIS;
		const cutoffTimestamp = now - timeRangeMillisSafe;
		const mailBoxes = await offlineStorage.getElementsOfType(MailBoxTypeRef);
		const cutoffId = timestampToGeneratedId(cutoffTimestamp);
		for (const mailBox of mailBoxes) {
			const isMailsetMigrated = mailBox.currentMailBag != null;
			const folders = await offlineStorage.getWholeList(MailFolderTypeRef, mailBox.folders.folders);
			if (isMailsetMigrated) {
				const folderSystem = new FolderSystem(folders);
				for (const mailSet of folders) if (isSpamOrTrashFolder(folderSystem, mailSet)) await this.deleteMailSetEntries(offlineStorage, mailSet.entries, DEFAULT_MAILSET_ENTRY_CUSTOM_CUTOFF_TIMESTAMP);
else await this.deleteMailSetEntries(offlineStorage, mailSet.entries, cutoffTimestamp);
				const mailListIds = [mailBox.currentMailBag, ...mailBox.archivedMailBags].map((mailbag) => mailbag.mails);
				for (const mailListId of mailListIds) await this.deleteMailListLegacy(offlineStorage, mailListId, cutoffId);
			} else {
				const folderSystem = new FolderSystem(folders);
				for (const folder of folders) if (isSpamOrTrashFolder(folderSystem, folder)) await this.deleteMailListLegacy(offlineStorage, folder.mails, GENERATED_MAX_ID);
else await this.deleteMailListLegacy(offlineStorage, folder.mails, cutoffId);
			}
		}
	}
	/**
	* This method deletes mails from {@param listId} what are older than {@param cutoffId} as well as associated data.
	*
	* it's considered legacy because once we start importing mail into mail bags, maintaining mail list ranges doesn't make
	* sense anymore - mail order in a list is arbitrary at that point.
	*
	* For each mail we delete the mail, its body, headers, all references mail set entries and all referenced attachments.
	*
	* When we delete the Files, we also delete the whole range for the user's File list. We need to delete the whole
	* range because we only have one file list per mailbox, so if we delete something from the middle of it, the range
	* will no longer be valid. (this is future proofing, because as of now there is not going to be a Range set for the
	* File list anyway, since we currently do not do range requests for Files.
	*
	* 	We do not delete ConversationEntries because:
	* 	1. They are in the same list for the whole conversation so we can't adjust the range
	* 	2. We might need them in the future for showing the whole thread
	*/
	async deleteMailListLegacy(offlineStorage, listId, cutoffId) {
		await offlineStorage.lockRangesDbAccess(listId);
		try {
			await offlineStorage.updateRangeForListAndDeleteObsoleteData(MailTypeRef, listId, cutoffId);
		} finally {
			await offlineStorage.unlockRangesDbAccess(listId);
		}
		const mailsToDelete = [];
		const attachmentsToDelete = [];
		const mailDetailsBlobToDelete = [];
		const mailDetailsDraftToDelete = [];
		const mails = await offlineStorage.getWholeList(MailTypeRef, listId);
		for (let mail of mails) if (firstBiggerThanSecond(cutoffId, getElementId(mail))) {
			mailsToDelete.push(mail._id);
			for (const id of mail.attachments) attachmentsToDelete.push(id);
			if (isDraft(mail)) {
				const mailDetailsId = assertNotNull(mail.mailDetailsDraft);
				mailDetailsDraftToDelete.push(mailDetailsId);
			} else {
				const mailDetailsId = assertNotNull(mail.mailDetails);
				mailDetailsBlobToDelete.push(mailDetailsId);
			}
		}
		for (let [listId$1, elementIds] of groupByAndMap(mailDetailsBlobToDelete, listIdPart, elementIdPart).entries()) await offlineStorage.deleteIn(MailDetailsBlobTypeRef, listId$1, elementIds);
		for (let [listId$1, elementIds] of groupByAndMap(mailDetailsDraftToDelete, listIdPart, elementIdPart).entries()) await offlineStorage.deleteIn(MailDetailsDraftTypeRef, listId$1, elementIds);
		for (let [listId$1, elementIds] of groupByAndMap(attachmentsToDelete, listIdPart, elementIdPart).entries()) {
			await offlineStorage.deleteIn(FileTypeRef, listId$1, elementIds);
			await offlineStorage.deleteRange(FileTypeRef, listId$1);
		}
		await offlineStorage.deleteIn(MailTypeRef, listId, mailsToDelete.map(elementIdPart));
	}
	/**
	* delete all mail set entries of a mail set that reference some mail with a receivedDate older than
	* cutoffTimestamp. this doesn't clean up mails or their associated data because we could be breaking the
	* offline list range invariant by deleting data from the middle of a mail range. cleaning up mails is done
	* the legacy way currently even for mailset users.
	*/
	async deleteMailSetEntries(offlineStorage, entriesListId, cutoffTimestamp) {
		const cutoffId = constructMailSetEntryId(new Date(cutoffTimestamp), GENERATED_MAX_ID);
		await offlineStorage.lockRangesDbAccess(entriesListId);
		try {
			await offlineStorage.updateRangeForListAndDeleteObsoleteData(MailSetEntryTypeRef, entriesListId, cutoffId);
		} finally {
			await offlineStorage.unlockRangesDbAccess(entriesListId);
		}
		const mailSetEntriesToDelete = [];
		const mailSetEntries = await offlineStorage.getWholeList(MailSetEntryTypeRef, entriesListId);
		for (let mailSetEntry of mailSetEntries) if (firstBiggerThanSecond(cutoffId, getElementId(mailSetEntry))) mailSetEntriesToDelete.push(mailSetEntry._id);
		await offlineStorage.deleteIn(MailSetEntryTypeRef, entriesListId, mailSetEntriesToDelete.map(elementIdPart));
	}
};

//#endregion
export { MailOfflineCleaner };
//# sourceMappingURL=MailOfflineCleaner-BHMPStjr.js.map