{"version":3,"file":"MailListModel-BwcGCBzp.js","names":["mailSet: MailFolder","conversationPrefProvider: ConversationPrefProvider","entityClient: EntityClient","mailModel: MailModel","inboxRuleHandler: InboxRuleHandler","cacheStorage: ExposedCacheStorage","selectedItems: Set<Mail>","newState: ListState<Mail>","mailId: Id","mailElementId: Id","mail: Mail","mailSetEntryId: Id","shouldStop: () => boolean","loadedMail: LoadedMail","update: EntityUpdateData","mailSetId: IdTuple","clearSelectionOnMultiSelectStart?: boolean","multiselect: boolean","filter: ListFilter<Mail> | null","startingId: IdTuple","count: number","items: LoadedMail[]","startId: IdTuple","entries: LoadedMail[]","id: IdTuple","mailSetEntries: MailSetEntry[]","mailProvider: (listId: Id, elementIds: Id[]) => Promise<Mail[]>","mailListMap: Map<Id, Id[]>","allMails: Map<Id, Mail>","loadedMails: LoadedMail[]","labels: MailFolder[]","mails: LoadedMail[]","mail: LoadedMail","listId: Id","elements: Id[]"],"sources":["../../src/mail-app/mail/model/MailListModel.ts"],"sourcesContent":["import { ListFilter, ListModel } from \"../../../common/misc/ListModel\"\nimport { Mail, MailFolder, MailFolderTypeRef, MailSetEntry, MailSetEntryTypeRef, MailTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs\"\nimport {\n\tCUSTOM_MAX_ID,\n\tcustomIdToUint8array,\n\tdeconstructMailSetEntryId,\n\telementIdPart,\n\tgetElementId,\n\tisSameId,\n\tlistIdPart,\n} from \"../../../common/api/common/utils/EntityUtils\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport { ConversationPrefProvider } from \"../view/ConversationViewModel\"\nimport { assertMainOrNode } from \"../../../common/api/common/Env\"\nimport { assertNotNull, compare, promiseFilter } from \"@tutao/tutanota-utils\"\nimport { ListLoadingState, ListState } from \"../../../common/gui/base/List\"\nimport Stream from \"mithril/stream\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils\"\nimport { MailSetKind, OperationType } from \"../../../common/api/common/TutanotaConstants\"\nimport { InboxRuleHandler } from \"./InboxRuleHandler\"\nimport { MailModel } from \"./MailModel\"\nimport { ListFetchResult } from \"../../../common/gui/base/ListUtils\"\nimport { isOfflineError } from \"../../../common/api/common/utils/ErrorUtils\"\nimport { ExposedCacheStorage } from \"../../../common/api/worker/rest/DefaultEntityRestCache\"\n\nassertMainOrNode()\n\n/**\n * Internal representation of a loaded mail\n *\n * @VisibleForTesting\n */\nexport interface LoadedMail {\n\treadonly mail: Mail\n\treadonly mailSetEntry: MailSetEntry\n\treadonly labels: ReadonlyArray<MailFolder>\n}\n\n/**\n * Handles fetching and resolving mail set entries into mails as well as handling sorting.\n */\nexport class MailListModel {\n\t// Id = MailSetEntry element id\n\tprivate readonly listModel: ListModel<LoadedMail, Id>\n\n\t// keep a reverse map for going from Mail element id -> LoadedMail\n\tprivate readonly mailMap: Map<Id, LoadedMail> = new Map()\n\n\tconstructor(\n\t\tprivate readonly mailSet: MailFolder,\n\t\tprivate readonly conversationPrefProvider: ConversationPrefProvider,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly mailModel: MailModel,\n\t\tprivate readonly inboxRuleHandler: InboxRuleHandler,\n\t\tprivate readonly cacheStorage: ExposedCacheStorage,\n\t) {\n\t\tthis.listModel = new ListModel({\n\t\t\tfetch: (lastFetchedItem, count) => {\n\t\t\t\tconst lastFetchedId = lastFetchedItem?.mailSetEntry?._id ?? [mailSet.entries, CUSTOM_MAX_ID]\n\t\t\t\treturn this.loadMails(lastFetchedId, count)\n\t\t\t},\n\n\t\t\tsortCompare: (item1, item2) => {\n\t\t\t\t// Mail set entry ID has the timestamp and mail element ID\n\t\t\t\tconst item1Id = getElementId(item1.mailSetEntry)\n\t\t\t\tconst item2Id = getElementId(item2.mailSetEntry)\n\n\t\t\t\t// Sort in reverse order to ensure newer mails are first\n\t\t\t\treturn compare(customIdToUint8array(item2Id), customIdToUint8array(item1Id))\n\t\t\t},\n\n\t\t\tgetItemId: (item) => getElementId(item.mailSetEntry),\n\n\t\t\tisSameId: (id1, id2) => id1 === id2,\n\n\t\t\tautoSelectBehavior: () => this.conversationPrefProvider.getMailAutoSelectBehavior(),\n\t\t})\n\t}\n\n\tget items(): Mail[] {\n\t\treturn this._loadedMails().map((mail) => mail.mail)\n\t}\n\n\tget loadingStatus(): ListLoadingState {\n\t\treturn this.listModel.state.loadingStatus\n\t}\n\n\tget stateStream(): Stream<ListState<Mail>> {\n\t\treturn this.listModel.stateStream.map((state) => {\n\t\t\tconst items = state.items.map((item) => item.mail)\n\t\t\tconst selectedItems: Set<Mail> = new Set()\n\t\t\tfor (const item of state.selectedItems) {\n\t\t\t\tselectedItems.add(item.mail)\n\t\t\t}\n\t\t\tconst newState: ListState<Mail> = {\n\t\t\t\t...state,\n\t\t\t\titems,\n\t\t\t\tselectedItems,\n\t\t\t}\n\t\t\treturn newState\n\t\t})\n\t}\n\n\tisLoadingAll(): boolean {\n\t\treturn this.listModel.state.loadingAll\n\t}\n\n\tisItemSelected(mailId: Id): boolean {\n\t\tconst loadedMail = this.mailMap.get(mailId)\n\t\tif (loadedMail == null) {\n\t\t\treturn false\n\t\t}\n\t\treturn this.listModel.isItemSelected(getElementId(loadedMail.mailSetEntry))\n\t}\n\n\tgetMail(mailElementId: Id): Mail | null {\n\t\treturn this.getLoadedMailByMailId(mailElementId)?.mail ?? null\n\t}\n\n\tgetLabelsForMail(mail: Mail): ReadonlyArray<MailFolder> {\n\t\treturn this.getLoadedMailByMailInstance(mail)?.labels ?? []\n\t}\n\n\tgetMailSetEntry(mailSetEntryId: Id): MailSetEntry | null {\n\t\treturn this.getLoadedMailByMailSetId(mailSetEntryId)?.mailSetEntry ?? null\n\t}\n\n\tasync loadAndSelect(mailId: Id, shouldStop: () => boolean): Promise<Mail | null> {\n\t\tconst mailFinder = (loadedMail: LoadedMail) => isSameId(getElementId(loadedMail.mail), mailId)\n\t\tconst mail = await this.listModel.loadAndSelect(mailFinder, shouldStop)\n\t\treturn mail?.mail ?? null\n\t}\n\n\tonSingleSelection(mail: Mail) {\n\t\tthis.listModel.onSingleSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)))\n\t}\n\n\tselectNone() {\n\t\tthis.listModel.selectNone()\n\t}\n\n\tcancelLoadAll() {\n\t\tthis.listModel.cancelLoadAll()\n\t}\n\n\tasync loadInitial() {\n\t\tawait this.listModel.loadInitial()\n\t}\n\n\tgetSelectedAsArray(): Array<Mail> {\n\t\treturn this.listModel.getSelectedAsArray().map(({ mail }) => mail)\n\t}\n\n\tasync handleEntityUpdate(update: EntityUpdateData) {\n\t\tif (isUpdateForTypeRef(MailFolderTypeRef, update)) {\n\t\t\t// If a label is modified, we want to update all mails that reference it, which requires linearly iterating\n\t\t\t// through all mails. There are more efficient ways we could do this, such as by keeping track of each label\n\t\t\t// we've retrieved from the database and just update that, but we want to avoid adding more maps that we\n\t\t\t// have to maintain.\n\t\t\tif (update.operation === OperationType.UPDATE) {\n\t\t\t\tconst mailSetId: IdTuple = [update.instanceListId, update.instanceId]\n\t\t\t\tfor (const loadedMail of this.mailMap.values()) {\n\t\t\t\t\tconst hasMailSet = loadedMail.labels.some((label) => isSameId(mailSetId, label._id))\n\t\t\t\t\tif (!hasMailSet) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// MailModel's entity event listener should have been fired first\n\t\t\t\t\tconst labels = this.mailModel.getLabelsForMail(loadedMail.mail)\n\t\t\t\t\tconst newMailEntry = {\n\t\t\t\t\t\t...loadedMail,\n\t\t\t\t\t\tlabels,\n\t\t\t\t\t}\n\t\t\t\t\tthis._updateSingleMail(newMailEntry)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isUpdateForTypeRef(MailSetEntryTypeRef, update) && isSameId(this.mailSet.entries, update.instanceListId)) {\n\t\t\t// Adding/removing to this list (MailSetEntry doesn't have any fields to update, so we don't need to handle this)\n\t\t\tif (update.operation === OperationType.DELETE) {\n\t\t\t\tconst mail = this.getLoadedMailByMailSetId(update.instanceId)\n\t\t\t\tif (mail) {\n\t\t\t\t\tthis.mailMap.delete(getElementId(mail.mail))\n\t\t\t\t}\n\t\t\t\tawait this.listModel.deleteLoadedItem(update.instanceId)\n\t\t\t} else if (update.operation === OperationType.CREATE) {\n\t\t\t\tconst loadedMail = await this.loadSingleMail([update.instanceListId, update.instanceId])\n\t\t\t\tawait this.listModel.waitLoad(async () => {\n\t\t\t\t\tif (this.listModel.canInsertItem(loadedMail)) {\n\t\t\t\t\t\tthis.listModel.insertLoadedItem(loadedMail)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t} else if (isUpdateForTypeRef(MailTypeRef, update)) {\n\t\t\t// We only need to handle updates for Mail.\n\t\t\t// Mail deletion will also be handled in MailSetEntry delete/create.\n\t\t\tconst mailItem = this.mailMap.get(update.instanceId)\n\t\t\tif (mailItem != null && update.operation === OperationType.UPDATE) {\n\t\t\t\tconst newMailData = await this.entityClient.load(MailTypeRef, [update.instanceListId, update.instanceId])\n\t\t\t\tconst labels = this.mailModel.getLabelsForMail(newMailData) // in case labels were added/removed\n\t\t\t\tconst newMailItem = {\n\t\t\t\t\t...mailItem,\n\t\t\t\t\tlabels,\n\t\t\t\t\tmail: newMailData,\n\t\t\t\t}\n\t\t\t\tthis._updateSingleMail(newMailItem)\n\t\t\t}\n\t\t}\n\t}\n\n\tareAllSelected(): boolean {\n\t\treturn this.listModel.areAllSelected()\n\t}\n\n\tselectAll() {\n\t\tthis.listModel.selectAll()\n\t}\n\n\tonSingleInclusiveSelection(mail: Mail, clearSelectionOnMultiSelectStart?: boolean) {\n\t\tthis.listModel.onSingleInclusiveSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)), clearSelectionOnMultiSelectStart)\n\t}\n\n\tselectRangeTowards(mail: Mail) {\n\t\tthis.listModel.selectRangeTowards(assertNotNull(this.getLoadedMailByMailInstance(mail)))\n\t}\n\n\tselectPrevious(multiselect: boolean) {\n\t\tthis.listModel.selectPrevious(multiselect)\n\t}\n\n\tselectNext(multiselect: boolean) {\n\t\tthis.listModel.selectNext(multiselect)\n\t}\n\n\tonSingleExclusiveSelection(mail: Mail) {\n\t\tthis.listModel.onSingleExclusiveSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)))\n\t}\n\n\tisInMultiselect(): boolean {\n\t\treturn this.listModel.state.inMultiselect\n\t}\n\n\tenterMultiselect() {\n\t\tthis.listModel.enterMultiselect()\n\t}\n\n\tasync loadAll() {\n\t\tawait this.listModel.loadAll()\n\t}\n\n\tsetFilter(filter: ListFilter<Mail> | null) {\n\t\tthis.listModel.setFilter(filter && ((loadedMail: LoadedMail) => filter(loadedMail.mail)))\n\t}\n\n\tisEmptyAndDone(): boolean {\n\t\treturn this.listModel.isEmptyAndDone()\n\t}\n\n\tasync loadMore() {\n\t\tawait this.listModel.loadMore()\n\t}\n\n\tasync retryLoading() {\n\t\tawait this.listModel.retryLoading()\n\t}\n\n\tstopLoading() {\n\t\tthis.listModel.stopLoading()\n\t}\n\n\tprivate getLoadedMailByMailId(mailId: Id): LoadedMail | null {\n\t\treturn this.mailMap.get(mailId) ?? null\n\t}\n\n\tprivate getLoadedMailByMailSetId(mailId: Id): LoadedMail | null {\n\t\treturn this.mailMap.get(deconstructMailSetEntryId(mailId).mailId) ?? null\n\t}\n\n\tprivate getLoadedMailByMailInstance(mail: Mail): LoadedMail | null {\n\t\treturn this.getLoadedMailByMailId(getElementId(mail))\n\t}\n\n\t/**\n\t * Load mails, applying inbox rules as needed\n\t */\n\tprivate async loadMails(startingId: IdTuple, count: number): Promise<ListFetchResult<LoadedMail>> {\n\t\tlet items: LoadedMail[] = []\n\t\tlet complete = false\n\n\t\ttry {\n\t\t\tconst mailSetEntries = await this.entityClient.loadRange(MailSetEntryTypeRef, listIdPart(startingId), elementIdPart(startingId), count, true)\n\n\t\t\t// Check for completeness before loading/filtering mails, as we may end up with even fewer mails than retrieved in either case\n\t\t\tcomplete = mailSetEntries.length < count\n\t\t\tif (mailSetEntries.length > 0) {\n\t\t\t\titems = await this.resolveMailSetEntries(mailSetEntries, this.defaultMailProvider)\n\t\t\t\titems = await this.applyInboxRulesToEntries(items)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (isOfflineError(e)) {\n\t\t\t\t// Attempt loading from the cache if we failed to get mails and/or mailset entries\n\t\t\t\t// Note that we may have items if it was just inbox rules that failed\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\t// Set the request as incomplete so that we make another request later (see `loadMailsFromCache` comment)\n\t\t\t\t\tcomplete = false\n\t\t\t\t\titems = await this.loadMailsFromCache(startingId, count)\n\t\t\t\t\tif (items.length === 0) {\n\t\t\t\t\t\tthrow e // we couldn't get anything from the cache!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tthis.updateMailMap(items)\n\t\treturn {\n\t\t\titems,\n\t\t\tcomplete,\n\t\t}\n\t}\n\n\t/**\n\t * Load mails from the cache rather than remotely\n\t */\n\tprivate async loadMailsFromCache(startId: IdTuple, count: number): Promise<LoadedMail[]> {\n\t\t// The way the cache works is that it tries to fulfill the API contract of returning as many items as requested as long as it can.\n\t\t// This is problematic for offline where we might not have the full page of emails loaded (e.g. we delete part as it's too old, or we move emails\n\t\t// around). Because of that cache will try to load additional items from the server in order to return `count` items. If it fails to load them,\n\t\t// it will not return anything and instead will throw an error.\n\t\t// This is generally fine but in case of offline we want to display everything that we have cached. For that we fetch directly from the cache,\n\t\t// give it to the list and let list make another request (and almost certainly fail that request) to show a retry button. This way we both show\n\t\t// the items we have and also show that we couldn't load everything.\n\t\tconst mailSetEntries = await this.cacheStorage.provideFromRange(MailSetEntryTypeRef, listIdPart(startId), elementIdPart(startId), count, true)\n\t\treturn await this.resolveMailSetEntries(mailSetEntries, (list, elements) => this.cacheStorage.provideMultiple(MailTypeRef, list, elements))\n\t}\n\n\t/**\n\t * Apply inbox rules to an array of mails, returning all mails that were not moved\n\t */\n\tprivate async applyInboxRulesToEntries(entries: LoadedMail[]): Promise<LoadedMail[]> {\n\t\tif (this.mailSet.folderType !== MailSetKind.INBOX || entries.length === 0) {\n\t\t\treturn entries\n\t\t}\n\t\tconst mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(this.mailSet)\n\t\tif (!mailboxDetail) {\n\t\t\treturn entries\n\t\t}\n\t\treturn await promiseFilter(entries, async (entry) => {\n\t\t\tconst ruleApplied = await this.inboxRuleHandler.findAndApplyMatchingRule(mailboxDetail, entry.mail, true)\n\t\t\treturn ruleApplied == null\n\t\t})\n\t}\n\n\tprivate async loadSingleMail(id: IdTuple): Promise<LoadedMail> {\n\t\tconst mailSetEntry = await this.entityClient.load(MailSetEntryTypeRef, id)\n\t\tconst loadedMails = await this.resolveMailSetEntries([mailSetEntry], this.defaultMailProvider)\n\t\tthis.updateMailMap(loadedMails)\n\t\treturn assertNotNull(loadedMails[0])\n\t}\n\n\t/**\n\t * Loads all Mail instances for each MailSetEntry, returning a tuple of each\n\t */\n\tprivate async resolveMailSetEntries(\n\t\tmailSetEntries: MailSetEntry[],\n\t\tmailProvider: (listId: Id, elementIds: Id[]) => Promise<Mail[]>,\n\t): Promise<LoadedMail[]> {\n\t\t// Sort all mails into mailbags so we can retrieve them with loadMultiple\n\t\tconst mailListMap: Map<Id, Id[]> = new Map()\n\t\tfor (const entry of mailSetEntries) {\n\t\t\tconst mailBag = listIdPart(entry.mail)\n\t\t\tconst mailElementId = elementIdPart(entry.mail)\n\t\t\tlet mailIds = mailListMap.get(mailBag)\n\t\t\tif (!mailIds) {\n\t\t\t\tmailIds = []\n\t\t\t\tmailListMap.set(mailBag, mailIds)\n\t\t\t}\n\t\t\tmailIds.push(mailElementId)\n\t\t}\n\n\t\t// Retrieve all mails by mailbag\n\t\tconst allMails: Map<Id, Mail> = new Map()\n\t\tfor (const [list, elements] of mailListMap) {\n\t\t\tconst mails = await mailProvider(list, elements)\n\t\t\tfor (const mail of mails) {\n\t\t\t\tallMails.set(getElementId(mail), mail)\n\t\t\t}\n\t\t}\n\n\t\t// Build our array\n\t\tconst loadedMails: LoadedMail[] = []\n\t\tfor (const mailSetEntry of mailSetEntries) {\n\t\t\tconst mail = allMails.get(elementIdPart(mailSetEntry.mail))\n\n\t\t\t// Mail may have been deleted in the meantime\n\t\t\tif (!mail) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Resolve labels\n\t\t\tconst labels: MailFolder[] = this.mailModel.getLabelsForMail(mail)\n\t\t\tloadedMails.push({ mailSetEntry, mail, labels })\n\t\t}\n\n\t\treturn loadedMails\n\t}\n\n\tprivate updateMailMap(mails: LoadedMail[]) {\n\t\tfor (const mail of mails) {\n\t\t\tthis.mailMap.set(getElementId(mail.mail), mail)\n\t\t}\n\t}\n\n\t// @VisibleForTesting\n\t_updateSingleMail(mail: LoadedMail) {\n\t\tthis.updateMailMap([mail])\n\t\tthis.listModel.updateLoadedItem(mail)\n\t}\n\n\t// @VisibleForTesting\n\t_loadedMails(): readonly LoadedMail[] {\n\t\treturn this.listModel.state.items\n\t}\n\n\tprivate readonly defaultMailProvider = (listId: Id, elements: Id[]): Promise<Mail[]> => {\n\t\treturn this.entityClient.loadMultiple(MailTypeRef, listId, elements)\n\t}\n}\n"],"mappings":"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"}