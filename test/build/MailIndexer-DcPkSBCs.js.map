{"version":3,"file":"MailIndexer-DcPkSBCs.js","names":["core: IndexerCore","db: Db","infoMessageHandler: InfoMessageHandler","bulkLoaderFactory: () => BulkMailLoader","entityClient: EntityClient","dateProvider: DateProvider","mailFacade: MailFacade","mail: Mail","mailDetails: MailDetails","files: TutanotaFile[]","senderToIndex: MailAddressAndName","mailId: IdTuple","event: EntityUpdate","indexUpdate: IndexUpdate","user: User","userId: Id","newOldestTimestamp: number","oldestTimestamp: number","mailBoxes: Array<{ mbox: MailBox; newestTimestamp: number }>","mailBoxes: Array<{\n\t\t\tmbox: MailBox\n\t\t\tnewestTimestamp: number\n\t\t}>","progress","dataPerMailbox: Array<MboxIndexData>","timeRange: TimeRange","progress: ProgressMonitor","indexLoader: BulkMailLoader","mboxDataList: Array<MboxIndexData>","mails: Array<Mail>","dataPerGroup: Array<{\n\t\t\tgroupId: Id\n\t\t\tindexTimestamp: number\n\t\t}>","groupData: GroupData | null","mailbox: MailBox","mailGroup: GroupMembership","events: EntityUpdate[]","groupId: Id","batchId: Id","mailIds: IdTuple[]","mailIds","importStateId: IdTuple","groupIndexTimestamps: number[]"],"sources":["../../src/mail-app/workerUtils/index/MailIndexer.ts"],"sourcesContent":["import {\n\tFULL_INDEXED_TIMESTAMP,\n\tImportStatus,\n\tMailSetKind,\n\tMailState,\n\tNOTHING_INDEXED_TIMESTAMP,\n\tOperationType,\n} from \"../../../common/api/common/TutanotaConstants\"\nimport {\n\tFile as TutanotaFile,\n\tImportedMailTypeRef,\n\tImportMailStateTypeRef,\n\tMail,\n\tMailBox,\n\tMailboxGroupRootTypeRef,\n\tMailBoxTypeRef,\n\tMailDetails,\n\tMailDetailsBlobTypeRef,\n\tMailDetailsDraftTypeRef,\n\tMailFolder,\n\tMailFolderTypeRef,\n\tMailSetEntryTypeRef,\n\tMailTypeRef,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { ConnectionError, NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError.js\"\nimport { typeModels } from \"../../../common/api/entities/tutanota/TypeModels.js\"\nimport { assertNotNull, first, groupBy, isEmpty, isNotNull, neverNull, noOp, ofClass, promiseMap } from \"@tutao/tutanota-utils\"\nimport {\n\tdeconstructMailSetEntryId,\n\telementIdPart,\n\tisSameId,\n\tLEGACY_BCC_RECIPIENTS_ID,\n\tLEGACY_BODY_ID,\n\tLEGACY_CC_RECIPIENTS_ID,\n\tLEGACY_TO_RECIPIENTS_ID,\n\tlistIdPart,\n} from \"../../../common/api/common/utils/EntityUtils.js\"\nimport {\n\t_createNewIndexUpdate,\n\tencryptIndexKeyBase64,\n\tfilterMailMemberships,\n\tgetPerformanceTimestamp,\n\thtmlToText,\n\ttypeRefToTypeInfo,\n} from \"../../../common/api/worker/search/IndexUtils.js\"\nimport { Db, GroupData, IndexingErrorReason, IndexUpdate, SearchIndexEntry } from \"../../../common/api/worker/search/SearchTypes.js\"\nimport { CancelledError } from \"../../../common/api/common/error/CancelledError.js\"\nimport { IndexerCore } from \"./IndexerCore.js\"\nimport { DbError } from \"../../../common/api/common/error/DbError.js\"\nimport type { DateProvider } from \"../../../common/api/worker/DateProvider.js\"\nimport type { EntityUpdate, GroupMembership, User } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport { ProgressMonitor } from \"../../../common/api/common/utils/ProgressMonitor.js\"\nimport { InfoMessageHandler } from \"../../../common/gui/InfoMessageHandler.js\"\nimport { ElementDataOS, GroupDataOS, Metadata, MetaDataOS } from \"../../../common/api/worker/search/IndexTables.js\"\nimport { MailFacade } from \"../../../common/api/worker/facades/lazy/MailFacade.js\"\nimport { containsEventOfType, EntityUpdateData } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport { b64UserIdHash } from \"../../../common/api/worker/search/DbFacade.js\"\nimport { hasError } from \"../../../common/api/common/utils/ErrorUtils.js\"\nimport { getDisplayedSender, getMailBodyText, MailAddressAndName } from \"../../../common/api/common/CommonMailUtils.js\"\nimport { isDraft } from \"../../mail/model/MailChecks.js\"\nimport { BulkMailLoader } from \"./BulkMailLoader.js\"\n\nexport const INITIAL_MAIL_INDEX_INTERVAL_DAYS = 28\nconst MAIL_INDEX_BATCH_INTERVAL = 1000 * 60 * 60 * 24 // one day\n\nexport class MailIndexer {\n\t// {@link currentIndexTimestamp}: the **oldest** timestamp that has been indexed for all mail lists\n\t// There are two scenarios in which new mails are indexed:\n\t// a) a new mail (internal/external) is received from our mail server\n\t// \t  * mail timestamp is guaranteed to be newer than the currentIndexTimestamp\n\t//    \t=> mail will be indexed\n\t// b) an old mail is imported to our tutadb server\n\t// \t  * mail timestamp is newer than currentIndexTimestamp\n\t//    \t=> mail will be indexed\n\t//    * mail timestamp is older than currentIndexTimestamp\n\t//    \t=> mail will not be indexed\n\tcurrentIndexTimestamp: number\n\n\tmailIndexingEnabled: boolean\n\tmailboxIndexingPromise: Promise<void>\n\tisIndexing: boolean = false\n\t_indexingCancelled: boolean\n\t_core: IndexerCore\n\t_db: Db\n\t_dateProvider: DateProvider\n\n\tconstructor(\n\t\tcore: IndexerCore,\n\t\tdb: Db,\n\t\tprivate readonly infoMessageHandler: InfoMessageHandler,\n\t\tprivate readonly bulkLoaderFactory: () => BulkMailLoader,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tdateProvider: DateProvider,\n\t\tprivate readonly mailFacade: MailFacade,\n\t) {\n\t\tthis._core = core\n\t\tthis._db = db\n\t\tthis.currentIndexTimestamp = NOTHING_INDEXED_TIMESTAMP\n\t\tthis.mailIndexingEnabled = false\n\t\tthis.mailboxIndexingPromise = Promise.resolve()\n\t\tthis._indexingCancelled = false\n\t\tthis._dateProvider = dateProvider\n\t}\n\n\tcreateMailIndexEntries(mail: Mail, mailDetails: MailDetails, files: TutanotaFile[]): Map<string, SearchIndexEntry[]> {\n\t\tlet startTimeIndex = getPerformanceTimestamp()\n\n\t\t// avoid caching system@tutanota.de since the user wouldn't be searching for this\n\t\tlet senderToIndex: MailAddressAndName\n\n\t\tconst hasSender = mail.sender != null\n\t\tif (hasSender) senderToIndex = getDisplayedSender(mail)\n\n\t\tconst MailModel = typeModels.Mail\n\t\tconst MailDetailsModel = typeModels.MailDetails\n\t\tconst RecipientModel = typeModels.Recipients\n\t\tlet keyToIndexEntries = this._core.createIndexEntriesForAttributes(mail, [\n\t\t\t{\n\t\t\t\tattribute: MailModel.values[\"subject\"],\n\t\t\t\tvalue: () => mail.subject,\n\t\t\t},\n\t\t\t{\n\t\t\t\t// allows old index entries (pre-maildetails) to be used with new clients.\n\t\t\t\tattribute: Object.assign({}, RecipientModel.associations[\"toRecipients\"], { id: LEGACY_TO_RECIPIENTS_ID }),\n\t\t\t\tvalue: () => mailDetails.recipients.toRecipients.map((r) => r.name + \" <\" + r.address + \">\").join(\",\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\t// allows old index entries (pre-maildetails) to be used with new clients.\n\t\t\t\tattribute: Object.assign({}, RecipientModel.associations[\"ccRecipients\"], { id: LEGACY_CC_RECIPIENTS_ID }),\n\t\t\t\tvalue: () => mailDetails.recipients.ccRecipients.map((r) => r.name + \" <\" + r.address + \">\").join(\",\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\t// allows old index entries (pre-maildetails) to be used with new clients.\n\t\t\t\tattribute: Object.assign({}, RecipientModel.associations[\"bccRecipients\"], { id: LEGACY_BCC_RECIPIENTS_ID }),\n\t\t\t\tvalue: () => mailDetails.recipients.bccRecipients.map((r) => r.name + \" <\" + r.address + \">\").join(\",\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: MailModel.associations[\"sender\"],\n\t\t\t\tvalue: () => (hasSender ? senderToIndex.name + \" <\" + senderToIndex.address + \">\" : \"\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\t// allows old index entries (pre-maildetails) to be used with new clients.\n\t\t\t\tattribute: Object.assign({}, MailDetailsModel.associations[\"body\"], { id: LEGACY_BODY_ID }),\n\t\t\t\tvalue: () => htmlToText(getMailBodyText(mailDetails.body)),\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: MailModel.associations[\"attachments\"],\n\t\t\t\tvalue: () => files.map((file) => file.name).join(\" \"),\n\t\t\t},\n\t\t])\n\n\t\tthis._core._stats.indexingTime += getPerformanceTimestamp() - startTimeIndex\n\t\treturn keyToIndexEntries\n\t}\n\n\tprocessNewMail(mailId: IdTuple): Promise<{\n\t\tmail: Mail\n\t\tkeyToIndexEntries: Map<string, SearchIndexEntry[]>\n\t} | null> {\n\t\treturn this.entityClient\n\t\t\t.load(MailTypeRef, mailId)\n\t\t\t.then(async (mail) => {\n\t\t\t\tlet mailDetails: MailDetails\n\t\t\t\tif (isDraft(mail)) {\n\t\t\t\t\t// Will be always there, if it was not updated yet, it will still be set by CryptoFacade\n\t\t\t\t\tconst mailOwnerEncSessionKey = assertNotNull(mail._ownerEncSessionKey)\n\t\t\t\t\tconst mailDetailsDraftId = assertNotNull(mail.mailDetailsDraft)\n\t\t\t\t\tmailDetails = await this.entityClient\n\t\t\t\t\t\t.loadMultiple(MailDetailsDraftTypeRef, listIdPart(mailDetailsDraftId), [elementIdPart(mailDetailsDraftId)], async () => ({\n\t\t\t\t\t\t\tkey: mailOwnerEncSessionKey,\n\t\t\t\t\t\t\tencryptingKeyVersion: Number(mail._ownerKeyVersion ?? 0),\n\t\t\t\t\t\t}))\n\t\t\t\t\t\t.then((d) => {\n\t\t\t\t\t\t\tconst draft = first(d)\n\t\t\t\t\t\t\tif (draft == null) {\n\t\t\t\t\t\t\t\tthrow new NotFoundError(`MailDetailsDraft ${mailDetailsDraftId}`)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn draft.details\n\t\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\t// Will be always there, if it was not updated yet it will still be set by CryptoFacade\n\t\t\t\t\tconst mailOwnerEncSessionKey = assertNotNull(mail._ownerEncSessionKey)\n\t\t\t\t\tconst mailDetailsBlobId = neverNull(mail.mailDetails)\n\t\t\t\t\tmailDetails = await this.entityClient\n\t\t\t\t\t\t.loadMultiple(MailDetailsBlobTypeRef, listIdPart(mailDetailsBlobId), [elementIdPart(mailDetailsBlobId)], async () => ({\n\t\t\t\t\t\t\tkey: mailOwnerEncSessionKey,\n\t\t\t\t\t\t\tencryptingKeyVersion: Number(mail._ownerKeyVersion ?? 0),\n\t\t\t\t\t\t}))\n\t\t\t\t\t\t.then((d) => {\n\t\t\t\t\t\t\tconst blob = first(d)\n\t\t\t\t\t\t\tif (blob == null) {\n\t\t\t\t\t\t\t\tthrow new NotFoundError(`MailDetailsBlob ${mailDetailsBlobId}`)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn blob.details\n\t\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tconst files = await this.mailFacade.loadAttachments(mail)\n\t\t\t\tlet keyToIndexEntries = this.createMailIndexEntries(mail, mailDetails, files)\n\t\t\t\treturn {\n\t\t\t\t\tmail,\n\t\t\t\t\tkeyToIndexEntries,\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\tconsole.log(\"tried to index non existing mail\")\n\t\t\t\t\treturn null\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(NotAuthorizedError, () => {\n\t\t\t\t\tconsole.log(\"tried to index contact without permission\")\n\t\t\t\t\treturn null\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\tprocessMovedMail(event: EntityUpdate, indexUpdate: IndexUpdate): Promise<void> {\n\t\tlet encInstanceId = encryptIndexKeyBase64(this._db.key, event.instanceId, this._db.iv)\n\t\treturn this._db.dbFacade.createTransaction(true, [ElementDataOS]).then((transaction) => {\n\t\t\treturn transaction.get(ElementDataOS, encInstanceId).then((elementData) => {\n\t\t\t\tif (elementData) {\n\t\t\t\t\tindexUpdate.move.push({\n\t\t\t\t\t\tencInstanceId,\n\t\t\t\t\t\tnewListId: event.instanceListId,\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\t// instance is moved but not yet indexed: handle as new for example moving a mail from non indexed folder like spam to indexed folder\n\t\t\t\t\treturn this.processNewMail([event.instanceListId, event.instanceId]).then((result) => {\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tthis._core.encryptSearchIndexEntries(result.mail._id, neverNull(result.mail._ownerGroup), result.keyToIndexEntries, indexUpdate)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\tasync enableMailIndexing(user: User): Promise<void> {\n\t\tconst t = await this._db.dbFacade.createTransaction(true, [MetaDataOS])\n\t\tconst enabled = await t.get(MetaDataOS, Metadata.mailIndexingEnabled)\n\t\tif (!enabled) {\n\t\t\tthis.mailIndexingEnabled = true\n\t\t\tconst t2 = await this._db.dbFacade.createTransaction(false, [MetaDataOS])\n\t\t\tt2.put(MetaDataOS, Metadata.mailIndexingEnabled, true)\n\t\t\tt2.put(MetaDataOS, Metadata.excludedListIds, [])\n\n\t\t\t// create index in background, termination is handled in Indexer.enableMailIndexing\n\t\t\tconst oldestTimestamp = this._dateProvider.getStartOfDayShiftedBy(-INITIAL_MAIL_INDEX_INTERVAL_DAYS).getTime()\n\n\t\t\tthis.indexMailboxes(user, oldestTimestamp).catch(\n\t\t\t\tofClass(CancelledError, (e) => {\n\t\t\t\t\tconsole.log(\"cancelled initial indexing\", e)\n\t\t\t\t}),\n\t\t\t)\n\t\t\treturn t2.wait()\n\t\t} else {\n\t\t\treturn t.get(MetaDataOS, Metadata.excludedListIds).then((excludedListIds) => {\n\t\t\t\tthis.mailIndexingEnabled = true\n\t\t\t})\n\t\t}\n\t}\n\n\tdisableMailIndexing(userId: Id): Promise<void> {\n\t\tthis.mailIndexingEnabled = false\n\t\tthis._indexingCancelled = true\n\t\treturn this._db.dbFacade.deleteDatabase(b64UserIdHash(userId))\n\t}\n\n\tcancelMailIndexing(): Promise<void> {\n\t\tthis._indexingCancelled = true\n\t\treturn Promise.resolve()\n\t}\n\n\t/**\n\t * Extend mail index if not indexed this range yet.\n\t * newOldestTimestamp should be aligned to the start of the day up until which you want to index, we don't do rounding inside here.\n\t */\n\tasync extendIndexIfNeeded(user: User, newOldestTimestamp: number): Promise<void> {\n\t\tif (this.currentIndexTimestamp > FULL_INDEXED_TIMESTAMP && this.currentIndexTimestamp > newOldestTimestamp) {\n\t\t\tthis.mailboxIndexingPromise = this.mailboxIndexingPromise\n\t\t\t\t.then(() => this.indexMailboxes(user, newOldestTimestamp))\n\t\t\t\t.catch(\n\t\t\t\t\tofClass(CancelledError, (e) => {\n\t\t\t\t\t\tconsole.log(\"extend mail index has been cancelled\", e)\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\treturn this.mailboxIndexingPromise\n\t\t}\n\t}\n\n\t/**\n\t * Indexes all mailboxes of the given user up to the endIndexTimestamp if mail indexing is enabled.\n\t * If the mailboxes are already fully indexed, they are not indexed again.\n\t */\n\tasync indexMailboxes(user: User, oldestTimestamp: number): Promise<void> {\n\t\tif (!this.mailIndexingEnabled) {\n\t\t\treturn Promise.resolve()\n\t\t}\n\n\t\tthis.isIndexing = true\n\t\tthis._indexingCancelled = false\n\n\t\tthis._core.resetStats()\n\n\t\tawait this.infoMessageHandler.onSearchIndexStateUpdate({\n\t\t\tinitializing: false,\n\t\t\tmailIndexEnabled: this.mailIndexingEnabled,\n\t\t\tprogress: 1,\n\t\t\tcurrentMailIndexTimestamp: this.currentIndexTimestamp,\n\t\t\taimedMailIndexTimestamp: oldestTimestamp,\n\t\t\tindexedMailCount: 0,\n\t\t\tfailedIndexingUpTo: null,\n\t\t})\n\n\t\tlet memberships = filterMailMemberships(user)\n\n\t\tthis._core.queue.pause()\n\n\t\ttry {\n\t\t\tconst mailBoxes: Array<{ mbox: MailBox; newestTimestamp: number }> = []\n\n\t\t\tfor (let mailGroupMembership of memberships) {\n\t\t\t\tlet mailGroupId = mailGroupMembership.group\n\t\t\t\tconst mailboxGroupRoot = await this.entityClient.load(MailboxGroupRootTypeRef, mailGroupId)\n\t\t\t\tconst mailbox = await this.entityClient.load(MailBoxTypeRef, mailboxGroupRoot.mailbox)\n\n\t\t\t\tconst transaction = await this._db.dbFacade.createTransaction(true, [GroupDataOS])\n\t\t\t\tconst groupData = await transaction.get(GroupDataOS, mailGroupId)\n\n\t\t\t\t// group data is not available if group has been added. group will be indexed after login.\n\t\t\t\tif (groupData) {\n\t\t\t\t\tconst newestTimestamp =\n\t\t\t\t\t\tgroupData.indexTimestamp === NOTHING_INDEXED_TIMESTAMP\n\t\t\t\t\t\t\t? this._dateProvider.getStartOfDayShiftedBy(1).getTime()\n\t\t\t\t\t\t\t: groupData.indexTimestamp\n\n\t\t\t\t\tif (newestTimestamp > oldestTimestamp) {\n\t\t\t\t\t\tmailBoxes.push({\n\t\t\t\t\t\t\tmbox: mailbox,\n\t\t\t\t\t\t\tnewestTimestamp,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mailBoxes.length > 0) {\n\t\t\t\tawait this._indexMailLists(mailBoxes, oldestTimestamp)\n\t\t\t}\n\n\t\t\tthis._core.printStatus()\n\n\t\t\tawait this.updateCurrentIndexTimestamp(user)\n\n\t\t\tawait this.infoMessageHandler.onSearchIndexStateUpdate({\n\t\t\t\tinitializing: false,\n\t\t\t\tmailIndexEnabled: this.mailIndexingEnabled,\n\t\t\t\tprogress: 0,\n\t\t\t\tcurrentMailIndexTimestamp: this.currentIndexTimestamp,\n\t\t\t\taimedMailIndexTimestamp: oldestTimestamp,\n\t\t\t\tindexedMailCount: this._core._stats.mailcount,\n\t\t\t\tfailedIndexingUpTo: null,\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tconsole.warn(\"Mail indexing failed: \", e)\n\t\t\t// avoid that a rejected promise is stored\n\t\t\tthis.mailboxIndexingPromise = Promise.resolve()\n\t\t\tawait this.updateCurrentIndexTimestamp(user)\n\n\t\t\tconst success = this._core.isStoppedProcessing() || e instanceof CancelledError\n\n\t\t\tconst failedIndexingUpTo = success ? null : oldestTimestamp\n\n\t\t\tconst error = success ? null : e instanceof ConnectionError ? IndexingErrorReason.ConnectionLost : IndexingErrorReason.Unknown\n\n\t\t\tawait this.infoMessageHandler.onSearchIndexStateUpdate({\n\t\t\t\tinitializing: false,\n\t\t\t\tmailIndexEnabled: this.mailIndexingEnabled,\n\t\t\t\tprogress: 0,\n\t\t\t\tcurrentMailIndexTimestamp: this.currentIndexTimestamp,\n\t\t\t\taimedMailIndexTimestamp: oldestTimestamp,\n\t\t\t\tindexedMailCount: this._core._stats.mailcount,\n\t\t\t\tfailedIndexingUpTo,\n\t\t\t\terror,\n\t\t\t})\n\t\t} finally {\n\t\t\tthis._core.queue.resume()\n\t\t\tthis.isIndexing = false\n\t\t}\n\t}\n\n\t_indexMailLists(\n\t\tmailBoxes: Array<{\n\t\t\tmbox: MailBox\n\t\t\tnewestTimestamp: number\n\t\t}>,\n\t\toldestTimestamp: number,\n\t): Promise<void> {\n\t\tconst newestTimestamp = mailBoxes.reduce((acc, data) => Math.max(acc, data.newestTimestamp), 0)\n\t\tconst progress = new ProgressMonitor(newestTimestamp - oldestTimestamp, (progress) => {\n\t\t\tthis.infoMessageHandler.onSearchIndexStateUpdate({\n\t\t\t\tinitializing: false,\n\t\t\t\tmailIndexEnabled: this.mailIndexingEnabled,\n\t\t\t\tprogress,\n\t\t\t\tcurrentMailIndexTimestamp: this.currentIndexTimestamp,\n\t\t\t\taimedMailIndexTimestamp: oldestTimestamp,\n\t\t\t\tindexedMailCount: this._core._stats.mailcount,\n\t\t\t\tfailedIndexingUpTo: null,\n\t\t\t})\n\t\t})\n\n\t\tconst indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(MailTypeRef))\n\n\t\tconst indexLoader = this.bulkLoaderFactory()\n\n\t\treturn promiseMap(mailBoxes, (mBoxData) => {\n\t\t\treturn this._loadMailListIds(mBoxData.mbox).then((mailListIds) => {\n\t\t\t\treturn {\n\t\t\t\t\tmailListIds,\n\t\t\t\t\tnewestTimestamp: mBoxData.newestTimestamp,\n\t\t\t\t\townerGroup: neverNull(mBoxData.mbox._ownerGroup),\n\t\t\t\t}\n\t\t\t})\n\t\t}).then((mailboxData) => this._indexMailListsInTimeBatches(mailboxData, [newestTimestamp, oldestTimestamp], indexUpdate, progress, indexLoader))\n\t}\n\n\t_processedEnough(indexUpdate: IndexUpdate): boolean {\n\t\treturn indexUpdate.create.encInstanceIdToElementData.size > 500\n\t}\n\n\t_indexMailListsInTimeBatches(\n\t\tdataPerMailbox: Array<MboxIndexData>,\n\t\ttimeRange: TimeRange,\n\t\tindexUpdate: IndexUpdate,\n\t\tprogress: ProgressMonitor,\n\t\tindexLoader: BulkMailLoader,\n\t): Promise<void> {\n\t\tconst [rangeStart, rangeEnd] = timeRange\n\t\tlet batchEnd = rangeStart - MAIL_INDEX_BATCH_INTERVAL\n\n\t\t// Make sure that we index up until aligned date and not more, otherwise it stays misaligned for user after changing the time zone once\n\t\tif (batchEnd < rangeEnd) {\n\t\t\tbatchEnd = rangeEnd\n\t\t}\n\n\t\tconst mailboxesToWrite = dataPerMailbox.filter((mboxData) => batchEnd < mboxData.newestTimestamp)\n\t\tconst batchRange = [rangeStart, batchEnd] as TimeRange\n\n\t\t// rangeStart is what we have indexed at the previous step. If it's equals to rangeEnd then we're done.\n\t\t// If it's less then we overdid a little bit but we've covered the range and we will write down rangeStart so\n\t\t// we will continue from it next time.\n\t\tif (rangeStart <= rangeEnd) {\n\t\t\t// all ranges have been processed\n\t\t\tconst indexTimestampPerGroup = mailboxesToWrite.map((data) => ({\n\t\t\t\tgroupId: data.ownerGroup,\n\t\t\t\tindexTimestamp: data.mailListIds.length === 0 ? FULL_INDEXED_TIMESTAMP : rangeStart,\n\t\t\t}))\n\t\t\treturn this._writeIndexUpdate(indexTimestampPerGroup, indexUpdate).then(() => {\n\t\t\t\tprogress.workDone(rangeStart - batchEnd)\n\t\t\t})\n\t\t}\n\n\t\treturn this._prepareMailDataForTimeBatch(mailboxesToWrite, batchRange, indexUpdate, indexLoader).then(() => {\n\t\t\tconst nextRange = [batchEnd, rangeEnd] as TimeRange\n\n\t\t\tif (this._processedEnough(indexUpdate)) {\n\t\t\t\t// only write to database if we have collected enough entities\n\t\t\t\tconst indexTimestampPerGroup = mailboxesToWrite.map((data) => ({\n\t\t\t\t\tgroupId: data.ownerGroup,\n\t\t\t\t\tindexTimestamp: data.mailListIds.length === 0 ? FULL_INDEXED_TIMESTAMP : batchEnd,\n\t\t\t\t}))\n\t\t\t\treturn this._writeIndexUpdate(indexTimestampPerGroup, indexUpdate).then(() => {\n\t\t\t\t\tprogress.workDone(rangeStart - batchEnd)\n\n\t\t\t\t\tconst newIndexUpdate = _createNewIndexUpdate(indexUpdate.typeInfo)\n\n\t\t\t\t\treturn this._indexMailListsInTimeBatches(dataPerMailbox, nextRange, newIndexUpdate, progress, indexLoader)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tprogress.workDone(rangeStart - batchEnd)\n\t\t\t\treturn this._indexMailListsInTimeBatches(dataPerMailbox, nextRange, indexUpdate, progress, indexLoader)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * @return Number of processed emails?\n\t * @private\n\t */\n\tasync _prepareMailDataForTimeBatch(\n\t\tmboxDataList: Array<MboxIndexData>,\n\t\ttimeRange: TimeRange,\n\t\tindexUpdate: IndexUpdate,\n\t\tindexLoader: BulkMailLoader,\n\t): Promise<void> {\n\t\tconst startTimeLoad = getPerformanceTimestamp()\n\t\treturn promiseMap(\n\t\t\tmboxDataList,\n\t\t\t(mboxData) => {\n\t\t\t\treturn promiseMap(\n\t\t\t\t\tmboxData.mailListIds.slice(),\n\t\t\t\t\tasync (listId) => {\n\t\t\t\t\t\t// We use caching here because we may load same emails twice\n\t\t\t\t\t\tconst { elements: mails, loadedCompletely } = await indexLoader.loadMailsInRangeWithCache(listId, timeRange)\n\t\t\t\t\t\t// If we loaded mail list completely, don't try to load from it anymore\n\t\t\t\t\t\tif (loadedCompletely) {\n\t\t\t\t\t\t\tmboxData.mailListIds.splice(mboxData.mailListIds.indexOf(listId), 1)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._core._stats.mailcount += mails.length\n\t\t\t\t\t\t// Remove all processed entities from cache\n\t\t\t\t\t\tawait Promise.all(mails.map((m) => indexLoader.removeFromCache(m._id)))\n\t\t\t\t\t\treturn this._processIndexMails(mails, indexUpdate, indexLoader)\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tconcurrency: 2,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t},\n\t\t\t{\n\t\t\t\tconcurrency: 5,\n\t\t\t},\n\t\t).then(() => {\n\t\t\tthis._core._stats.preparingTime += getPerformanceTimestamp() - startTimeLoad\n\t\t})\n\t}\n\n\tasync _processIndexMails(mails: Array<Mail>, indexUpdate: IndexUpdate, indexLoader: BulkMailLoader): Promise<number> {\n\t\tif (this._indexingCancelled) throw new CancelledError(\"cancelled indexing in processing index mails\")\n\t\tlet mailsWithoutErros = mails.filter((m) => !hasError(m))\n\t\tconst mailsWithMailDetails = await indexLoader.loadMailDetails(mailsWithoutErros)\n\t\tconst files = await indexLoader.loadAttachments(mailsWithoutErros)\n\t\tconst mailsWithMailDetailsAndFiles = mailsWithMailDetails\n\t\t\t.map((mailTuples) => {\n\t\t\t\treturn {\n\t\t\t\t\tmail: mailTuples.mail,\n\t\t\t\t\tmailDetails: mailTuples.mailDetails,\n\t\t\t\t\tfiles: files.filter((file) => mailTuples.mail.attachments.find((a) => isSameId(a, file._id))),\n\t\t\t\t}\n\t\t\t})\n\t\t\t.filter(isNotNull)\n\t\tfor (const element of mailsWithMailDetailsAndFiles) {\n\t\t\tlet keyToIndexEntries = this.createMailIndexEntries(element.mail, element.mailDetails, element.files)\n\n\t\t\tthis._core.encryptSearchIndexEntries(element.mail._id, neverNull(element.mail._ownerGroup), keyToIndexEntries, indexUpdate)\n\t\t}\n\t\treturn mailsWithMailDetailsAndFiles.length\n\t}\n\n\t_writeIndexUpdate(\n\t\tdataPerGroup: Array<{\n\t\t\tgroupId: Id\n\t\t\tindexTimestamp: number\n\t\t}>,\n\t\tindexUpdate: IndexUpdate,\n\t): Promise<void> {\n\t\treturn this._core.writeIndexUpdate(dataPerGroup, indexUpdate)\n\t}\n\n\tupdateCurrentIndexTimestamp(user: User): Promise<void> {\n\t\treturn this._db.dbFacade\n\t\t\t.createTransaction(true, [GroupDataOS])\n\t\t\t.then((t) => {\n\t\t\t\treturn Promise.all(\n\t\t\t\t\tfilterMailMemberships(user).map((mailGroupMembership) => {\n\t\t\t\t\t\treturn t.get(GroupDataOS, mailGroupMembership.group).then((groupData: GroupData | null) => {\n\t\t\t\t\t\t\tif (!groupData) {\n\t\t\t\t\t\t\t\treturn NOTHING_INDEXED_TIMESTAMP\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn groupData.indexTimestamp\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}),\n\t\t\t\t).then((groupIndexTimestamps) => {\n\t\t\t\t\tthis.currentIndexTimestamp = _getCurrentIndexTimestamp(groupIndexTimestamps)\n\t\t\t\t})\n\t\t\t})\n\t\t\t.catch((err) => {\n\t\t\t\tif (err instanceof DbError && this._core.isStoppedProcessing()) {\n\t\t\t\t\tconsole.log(\"The database was closed, do not write currentIndexTimestamp\")\n\t\t\t\t}\n\t\t\t})\n\t}\n\n\t/**\n\t * Provides all mail list ids of the given mailbox\n\t */\n\tasync _loadMailListIds(mailbox: MailBox): Promise<Id[]> {\n\t\tconst isMailsetMigrated = mailbox.currentMailBag != null\n\t\tif (isMailsetMigrated) {\n\t\t\treturn [mailbox.currentMailBag!, ...mailbox.archivedMailBags].map((mailbag) => mailbag.mails)\n\t\t} else {\n\t\t\tconst folders = await this.entityClient.loadAll(MailFolderTypeRef, neverNull(mailbox.folders).folders)\n\t\t\treturn folders.map((f) => f.mails)\n\t\t}\n\t}\n\n\t_getSpamFolder(mailGroup: GroupMembership): Promise<MailFolder> {\n\t\treturn this.entityClient\n\t\t\t.load(MailboxGroupRootTypeRef, mailGroup.group)\n\t\t\t.then((mailGroupRoot) => this.entityClient.load(MailBoxTypeRef, mailGroupRoot.mailbox))\n\t\t\t.then((mbox) => {\n\t\t\t\treturn this.entityClient\n\t\t\t\t\t.loadAll(MailFolderTypeRef, neverNull(mbox.folders).folders)\n\t\t\t\t\t.then((folders) => neverNull(folders.find((folder) => folder.folderType === MailSetKind.SPAM)))\n\t\t\t})\n\t}\n\n\tasync processImportStateEntityEvents(events: EntityUpdate[], groupId: Id, batchId: Id, indexUpdate: IndexUpdate): Promise<void> {\n\t\tif (!this.mailIndexingEnabled) return Promise.resolve()\n\t\tawait promiseMap(events, async (event) => {\n\t\t\t// we can only process create and update events (create is because of EntityEvent optimization\n\t\t\t// (CREATE + UPDATE = CREATE) which requires us to process CREATE events with imported mails)\n\t\t\tif (event.operation === OperationType.CREATE || event.operation === OperationType.UPDATE) {\n\t\t\t\tlet mailIds: IdTuple[] = await this.loadImportedMailIdsInIndexDateRange([event.instanceListId, event.instanceId])\n\n\t\t\t\tawait this.preloadMails(mailIds)\n\n\t\t\t\treturn await promiseMap(mailIds, (mailId) =>\n\t\t\t\t\tthis.processNewMail(mailId).then((result) => {\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tthis._core.encryptSearchIndexEntries(result.mail._id, neverNull(result.mail._ownerGroup), result.keyToIndexEntries, indexUpdate)\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * We preload all mails and mail details into the cache in order to prevent loading mails one by one\n\t * after importing lots of mails...\n\t */\n\tprivate async preloadMails(mailIds: IdTuple[]) {\n\t\tconst mailsByList = groupBy(mailIds, (m) => listIdPart(m))\n\t\tlet mails: Array<Mail> = []\n\t\tfor (const [listId, mailIds] of mailsByList.entries()) {\n\t\t\tconst mailElementIds = mailIds.map((m) => elementIdPart(m))\n\t\t\tmails = mails.concat(await this.entityClient.loadMultiple(MailTypeRef, listId, mailElementIds))\n\t\t}\n\t\tconst indexLoader = this.bulkLoaderFactory()\n\t\tawait indexLoader.loadMailDetails(mails)\n\t\tawait indexLoader.loadAttachments(mails)\n\t}\n\n\tasync loadImportedMailIdsInIndexDateRange(importStateId: IdTuple): Promise<IdTuple[]> {\n\t\tconst importMailState = await this.entityClient.load(ImportMailStateTypeRef, importStateId)\n\t\tlet status = parseInt(importMailState.status) as ImportStatus\n\t\tif (status !== ImportStatus.Finished && status !== ImportStatus.Canceled) {\n\t\t\treturn Promise.resolve([])\n\t\t}\n\t\tlet importedMailEntries = await this.entityClient.loadAll(ImportedMailTypeRef, importMailState.importedMails)\n\n\t\tif (isEmpty(importedMailEntries)) {\n\t\t\treturn Promise.resolve([])\n\t\t}\n\n\t\tlet importedMailSetEntryListId = listIdPart(importedMailEntries[0].mailSetEntry)\n\t\t// we only want to index mails with a receivedDate newer than the currentIndexTimestamp\n\t\tlet dateRangeFilteredMailSetEntryIds = importedMailEntries\n\t\t\t.map((importedMail) => elementIdPart(importedMail.mailSetEntry))\n\t\t\t.filter((importedEntry) => deconstructMailSetEntryId(importedEntry).receiveDate.getTime() >= this.currentIndexTimestamp)\n\t\treturn this.entityClient\n\t\t\t.loadMultiple(MailSetEntryTypeRef, importedMailSetEntryListId, dateRangeFilteredMailSetEntryIds)\n\t\t\t.then((entries) => entries.map((entry) => entry.mail))\n\t}\n\n\t/**\n\t * Prepare IndexUpdate in response to the new entity events.\n\t * {@see MailIndexerTest.js}\n\t * @param events Events from one batch\n\t * @param groupId\n\t * @param batchId\n\t * @param indexUpdate which will be populated with operations\n\t * @returns {Promise<*>} Indication that we're done.\n\t */\n\tprocessEntityEvents(events: EntityUpdate[], groupId: Id, batchId: Id, indexUpdate: IndexUpdate): Promise<void> {\n\t\tif (!this.mailIndexingEnabled) return Promise.resolve()\n\t\treturn promiseMap(events, (event) => {\n\t\t\tconst mailId: IdTuple = [event.instanceListId, event.instanceId]\n\t\t\tif (event.operation === OperationType.CREATE) {\n\t\t\t\tif (containsEventOfType(events as readonly EntityUpdateData[], OperationType.DELETE, event.instanceId)) {\n\t\t\t\t\t// do not execute move operation if there is a delete event or another move event.\n\t\t\t\t\treturn this.processMovedMail(event, indexUpdate)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.processNewMail(mailId).then((result) => {\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tthis._core.encryptSearchIndexEntries(result.mail._id, neverNull(result.mail._ownerGroup), result.keyToIndexEntries, indexUpdate)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if (event.operation === OperationType.UPDATE) {\n\t\t\t\treturn this.entityClient\n\t\t\t\t\t.load(MailTypeRef, [event.instanceListId, event.instanceId])\n\t\t\t\t\t.then((mail) => {\n\t\t\t\t\t\tif (mail.state === MailState.DRAFT) {\n\t\t\t\t\t\t\treturn Promise.all([\n\t\t\t\t\t\t\t\tthis._core._processDeleted(event, indexUpdate),\n\t\t\t\t\t\t\t\tthis.processNewMail(mailId).then((result) => {\n\t\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\t\tthis._core.encryptSearchIndexEntries(\n\t\t\t\t\t\t\t\t\t\t\tresult.mail._id,\n\t\t\t\t\t\t\t\t\t\t\tneverNull(result.mail._ownerGroup),\n\t\t\t\t\t\t\t\t\t\t\tresult.keyToIndexEntries,\n\t\t\t\t\t\t\t\t\t\t\tindexUpdate,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(ofClass(NotFoundError, () => console.log(\"tried to index update event for non existing mail\")))\n\t\t\t} else if (event.operation === OperationType.DELETE) {\n\t\t\t\tif (!containsEventOfType(events as readonly EntityUpdateData[], OperationType.CREATE, event.instanceId)) {\n\t\t\t\t\t// Check that this is *not* a move event. Move events are handled separately.\n\t\t\t\t\treturn this._core._processDeleted(event, indexUpdate)\n\t\t\t\t}\n\t\t\t}\n\t\t}).then(noOp)\n\t}\n}\n\n// export just for testing\nexport function _getCurrentIndexTimestamp(groupIndexTimestamps: number[]): number {\n\tlet currentIndexTimestamp = NOTHING_INDEXED_TIMESTAMP\n\tfor (const [index, t] of groupIndexTimestamps.entries()) {\n\t\tif (index === 0) {\n\t\t\tcurrentIndexTimestamp = t\n\t\t} else if (t === NOTHING_INDEXED_TIMESTAMP) {\n\t\t\t// skip new group memberships\n\t\t} else if (t === FULL_INDEXED_TIMESTAMP && currentIndexTimestamp !== FULL_INDEXED_TIMESTAMP && currentIndexTimestamp !== NOTHING_INDEXED_TIMESTAMP) {\n\t\t\t// skip full index timestamp if this is not the first mail group\n\t\t} else if (currentIndexTimestamp === FULL_INDEXED_TIMESTAMP && t !== currentIndexTimestamp) {\n\t\t\t// find the oldest timestamp\n\t\t\t// mail index ist not fully indexed if one of the mailboxes is not fully indexed\n\t\t\tcurrentIndexTimestamp = t\n\t\t} else if (t < currentIndexTimestamp) {\n\t\t\t// set the oldest index timestamp as current timestamp so all mailboxes can index to this timestamp during log in.\n\t\t\tcurrentIndexTimestamp = t\n\t\t}\n\t}\n\treturn currentIndexTimestamp\n}\n\ntype TimeRange = [number, number]\ntype MboxIndexData = {\n\tmailListIds: Array<Id>\n\tnewestTimestamp: number\n\townerGroup: Id\n}\n"],"mappings":"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"}