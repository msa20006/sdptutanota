{"version":3,"file":"MessageDispatcher-wJwFhXWv.js","names":["type: T","args: ReadonlyArray<unknown>","id: string","value: any","error: Error","transport: Transport<OutgoingRequestType, IncomingRequestType>","commands: Commands<IncomingRequestType>","idPrefix: string","msg: Request<OutgoingRequestType>","message: Message<IncomingRequestType>","prefix: string"],"sources":["../../src/common/api/common/threading/MessageDispatcher.ts"],"sourcesContent":["/**\n * <ul>\n *   <li>The client sends {WorkerRequest}s to the worker and the worker answers with either an {WorkerResponse} or a {WorkerError}.\n *   <li>The worker sends {ClientCommands}s to the client. The commands are executed by the client (without any response to the worker).\n * </ul>\n */\nimport { isWorker } from \"../Env.js\"\nimport { Transport } from \"./Transport.js\"\nimport { objToError } from \"../utils/ErrorUtils.js\"\n\nexport type Command<T> = (msg: Request<T>) => Promise<any>\nexport type Commands<T extends string> = Record<T, Command<T>>\nexport type Message<Type> = Request<Type> | Response<Type> | RequestError<Type>\n\nexport class Request<T> {\n\treadonly type: \"request\"\n\treadonly requestType: T\n\t/** should be selected and assigned by the message dispatcher or on deserialization only. */\n\tid: string | null = null\n\n\treadonly args: any[]\n\n\tconstructor(type: T, args: ReadonlyArray<unknown>) {\n\t\tthis.type = \"request\"\n\t\tthis.requestType = type\n\t\tthis.id = null\n\t\tthis.args = args.slice()\n\t}\n}\n\nexport class Response<T> {\n\treadonly type: \"response\"\n\treadonly id: string\n\treadonly value: any\n\n\tconstructor(id: string, value: any) {\n\t\tthis.type = \"response\"\n\t\tthis.id = id\n\t\tthis.value = value\n\t}\n}\n\nexport class RequestError<T> {\n\treadonly type: \"requestError\"\n\treadonly id: string\n\treadonly error: Record<string, any>\n\n\tconstructor(id: string, error: Error) {\n\t\tthis.type = \"requestError\"\n\t\tthis.id = id\n\t\tthis.error = errorToObj(error) // the structured clone algorithm is not able to clone errors\n\t}\n}\n\ntype MessageCallbacks = {\n\tresolve: (value: any) => void\n\treject: (error: Error) => void\n}\n\n/**\n * Handles remote invocations (e.g. worker or native calls).\n */\nexport class MessageDispatcher<OutgoingRequestType extends string, IncomingRequestType extends string> {\n\t/**\n\t * Map from request id that have been sent to the callback that will be\n\t * executed on the results sent by the worker.\n\t */\n\tprivate readonly _messages: Record<string, MessageCallbacks>\n\tprivate readonly nextId: () => string\n\n\tconstructor(\n\t\tprivate readonly transport: Transport<OutgoingRequestType, IncomingRequestType>,\n\t\tprivate readonly commands: Commands<IncomingRequestType>,\n\t\tprivate idPrefix: string,\n\t) {\n\t\tthis._messages = {}\n\t\tthis.nextId = makeRequestIdGenerator(idPrefix)\n\t\tthis.transport.setMessageHandler((msg) => this.handleMessage(msg))\n\t}\n\n\tpostRequest(msg: Request<OutgoingRequestType>): Promise<any> {\n\t\tmsg.id = this.nextId()\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._messages[msg.id!] = {\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis.transport.postMessage(msg)\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"error payload:\", msg)\n\t\t\t\tthrow e\n\t\t\t}\n\t\t})\n\t}\n\n\thandleMessage(message: Message<IncomingRequestType>) {\n\t\tif (message.type === \"response\") {\n\t\t\tconst pendingRequest = this._messages[message.id]\n\t\t\tif (pendingRequest != null) {\n\t\t\t\tpendingRequest.resolve(message.value)\n\t\t\t\tdelete this._messages[message.id]\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Unexpected response: ${message.id} (was the page reloaded?)`)\n\t\t\t}\n\t\t} else if (message.type === \"requestError\") {\n\t\t\tconst pendingRequest = this._messages[message.id]\n\t\t\tif (pendingRequest != null) {\n\t\t\t\tpendingRequest.reject(objToError(message.error))\n\t\t\t\tdelete this._messages[message.id]\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Unexpected error response: ${message.id} (was the page reloaded?)`)\n\t\t\t}\n\t\t} else if (message.type === \"request\") {\n\t\t\tconst command = this.commands[message.requestType]\n\n\t\t\tif (command != null) {\n\t\t\t\tconst commandResult = command(message)\n\n\t\t\t\t// Every method exposed via worker protocol must return a promise. Failure to do so is a violation of contract so we\n\t\t\t\t// try to catch it early and throw an error.\n\t\t\t\tif (commandResult == null || typeof commandResult.then !== \"function\") {\n\t\t\t\t\tthrow new Error(`Handler returned non-promise result: ${message.requestType}`)\n\t\t\t\t}\n\n\t\t\t\tcommandResult.then(\n\t\t\t\t\t(value) => {\n\t\t\t\t\t\tthis.transport.postMessage(new Response(message.id!, value))\n\t\t\t\t\t},\n\t\t\t\t\t(error) => {\n\t\t\t\t\t\tthis.transport.postMessage(new RequestError(message.id!, error))\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tlet error = new Error(`unexpected request: ${message.id}, ${message.requestType}`)\n\n\t\t\t\tif (isWorker()) {\n\t\t\t\t\tthis.transport.postMessage(new RequestError(message.id!, error))\n\t\t\t\t} else {\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Unexpected request type: ${JSON.stringify(message)}`)\n\t\t}\n\t}\n}\n\nexport function makeRequestIdGenerator(prefix: string): () => string {\n\tlet requestId = 0\n\treturn () => {\n\t\tif (requestId >= Number.MAX_SAFE_INTEGER) {\n\t\t\trequestId = 0\n\t\t}\n\t\treturn prefix + requestId++\n\t}\n}\n\n// Serialize error stack traces, when they are sent via the websocket.\nexport function errorToObj(error: Error): {\n\tdata: any\n\tmessage: any\n\tname: any\n\tstack: any\n} {\n\tconst errorErased = error as any\n\treturn {\n\t\tname: errorErased.name,\n\t\tmessage: errorErased.message,\n\t\tstack: errorErased.stack,\n\t\tdata: errorErased.data,\n\t}\n}\n"],"mappings":"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"}