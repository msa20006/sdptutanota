
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { LazyLoaded, SortedArray, assertNotNull, cleanMatch, debounce, downcast, findAllAndRemove, getFirstOrThrow, isNotNull, memoized, neverNull, noOp, ofClass, pMap, remove, resolveMaybeLazy, startsWith, typedValues } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { Mode, assertMainOrNode, isApp, isBrowser, isDesktop } from "./Env-D5xGlXfw.js";
import { InfoLink, lang, languageByCode } from "./LanguageViewModel-BNC5ekpO.js";
import { DefaultAnimationTime, animations, getNavButtonIconBackground, height, inputLineHeight, opacity, px, size, styles, theme } from "./HtmlUtils-C-ecR7U7.js";
import { client } from "./ClientDetector-D0v6Vqu6.js";
import { ALLOWED_IMAGE_FORMATS, ConversationType, ExternalImageRule, FeatureType, Keys, MailAuthenticationStatus, MailMethod, OperationType, ShareCapability } from "./TutanotaConstants-3bwAESYA.js";
import { BootIcons, Button, ButtonColor, ButtonType, Icon } from "./Icon-BuqNK7vz.js";
import { Icons } from "./Icons-Dl3nFav5.js";
import { isKeyPressed, keyboardEventToKeyPress } from "./KeyManager-B0OGXEyJ.js";
import { windowFacade } from "./WindowFacade-B9kSBKw7.js";
import { LayerType, displayOverlay, modal } from "./Modal-g4c-b9IU.js";
import { Autocomplete, Dialog, DomRectReadOnlyPolyfilled, DropDownSelector, Dropdown, TextField, attachDropdown, canSeeTutaLinks, createDropdown, getConfirmation, makeListSelectionChangedScrollHandler } from "./Dialog-B6-HFvZd.js";
import { ButtonSize, IconButton } from "./IconButton-DsU60HJ_.js";
import { NotFoundError, TooManyRequestsError } from "./RestError-D17JEBMr.js";
import { FileNotFoundError, isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { FileOpenError } from "./FileOpenError-C1_8yoXr.js";
import { PermissionError } from "./PermissionError-BGDsHuAh.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { getElementId, getEtId, getLetId, isSameId } from "./EntityUtils-RQxXZlcV.js";
import { ContactTypeRef, EmailTemplateTypeRef, KnowledgeBaseEntryTypeRef, MailTypeRef, TemplateGroupRootTypeRef, createTranslationGetIn } from "./TypeRefs-CR3TLWn0.js";
import { TranslationService } from "./Services-DCx-CeM7.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { getSharedGroupName, hasCapabilityOnGroup } from "./GroupUtils-CpT2lvVS.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import { parseMailtoUrl } from "./MailAddressParser-BgYy6oyp.js";
import { createDataFile } from "./DataFile-CY7uuk9j.js";
import { fileListToArray, isDataFile, isFileReference, isTutanotaFile } from "./FileUtils-W-u2-gZz.js";
import { showProgressDialog } from "./ProgressDialog-CJfJjh62.js";
import { LINE_BREAK, RecipientField, checkAttachmentSize, createNewContact, dialogTitleTranslationKey, getEnabledMailAddressesWithUser, getMailAddressDisplayText, readLocalFiles, showFileChooser } from "./SharedMailUtils-AmFaSJP6.js";
import { RecipientType } from "./Recipient-BFxhfecW.js";
import { getContactDisplayName } from "./ContactUtils-Bbon2oOk.js";
import { showPlanUpgradeRequiredDialog } from "./SubscriptionDialogs-DAlWs68I.js";
import { ToggleButton } from "./ToggleButton-DxuDa0rS.js";
import { MailRecipientsTextField } from "./MailRecipientsTextField-BmI2qlpf.js";
import { InfoBanner } from "./InfoBanner-CobgB3Oz.js";
import { ExpanderPanel } from "./Expander-Bautb1_0.js";
import { PasswordField } from "./PasswordField-CPKPoLq8.js";
import { showUserError } from "./ErrorHandlerImpl-DRpk8tE9.js";
import { handleRatingByEvent } from "./InAppRatingDialog-Cp5yqAc1.js";
import { isCustomizationEnabledForCustomer } from "./CustomerUtils-DmaZpb7Y.js";
import { Editor, RichTextToolbar, animateToolbar } from "./HtmlEditor-DkqWVGt0.js";
import { htmlSanitizer } from "./HtmlSanitizer-CA1YjlPp.js";
import { checkApprovalStatus } from "./LoginViewModel-BX-8ry63.js";
import { AttachmentBubble, AttachmentType } from "./AttachmentBubble-CloIefNF.js";
import { SaveErrorReason, SaveStatusEnum, mailLocator } from "./mailLocator-CrvEYt1k.js";
import { SELECT_NEXT_TEMPLATE, SELECT_PREV_TEMPLATE, TEMPLATE_SHORTCUT_PREFIX, TemplatePopupModel, loadTemplateGroupInstance } from "./TemplatePopupModel-Bv3eIGgN.js";
import { ContentBlockingStatus, createInlineImage, isMailContrastFixNeeded, promptAndDeleteMails, replaceCidsWithInlineImages, replaceInlineImagesWithCids } from "./MailViewerViewModel-D_nVDgz3.js";
import { appendEmailSignature } from "./Signature-nc-d4UDo.js";
import { knowledgeBaseSearch } from "./KnowledgeBaseSearchFilter-D7VhMtlv.js";

//#region ../src/mail-app/mail/editor/MailEditorViewModel.ts
async function chooseAndAttachFile(model, boundingRect, fileTypes) {
	boundingRect.height = Math.round(boundingRect.height);
	boundingRect.width = Math.round(boundingRect.width);
	boundingRect.x = Math.round(boundingRect.x);
	boundingRect.y = Math.round(boundingRect.y);
	try {
		const files = await showFileChooserForAttachments(boundingRect, fileTypes);
		if (!files || files.length === 0) return;
		switch (env.mode) {
			case Mode.App:
				model.attachFiles(files);
				return files;
			case Mode.Desktop: {
				const dataFiles = (await Promise.all(files.map(async (f) => locator.fileApp.readDataFile(f.location)))).filter(isNotNull);
				model.attachFiles(dataFiles);
				return dataFiles;
			}
			default:
				model.attachFiles(files);
				return files;
		}
	} catch (e) {
		if (e instanceof UserError) await showUserError(e);
else {
			const msg = e.message || "unknown error";
			console.error("could not attach files:", msg);
		}
	}
}
function showFileChooserForAttachments(boundingRect, fileTypes) {
	const fileSelector = [Mode.App, Mode.Desktop].includes(env.mode) ? locator.fileApp.openFileChooser(boundingRect, fileTypes) : showFileChooser(true, fileTypes);
	return fileSelector.catch(ofClass(PermissionError, () => {
		Dialog.message("fileAccessDeniedMobile_msg");
	})).catch(ofClass(FileNotFoundError, () => {
		Dialog.message("couldNotAttachFile_msg");
	}));
}
function createAttachmentBubbleAttrs(model, inlineImageElements) {
	return model.getAttachments().map((attachment) => ({
		attachment,
		open: null,
		download: () => _downloadAttachment(attachment),
		remove: () => {
			model.removeAttachment(attachment);
			if (attachment.cid) {
				const imageElement = inlineImageElements.find((e) => e.getAttribute("cid") === attachment.cid);
				if (imageElement) {
					imageElement.remove();
					remove(inlineImageElements, imageElement);
				}
			}
			mithril_default.redraw();
		},
		fileImport: null,
		type: AttachmentType.GENERIC
	}));
}
async function _downloadAttachment(attachment) {
	try {
		if (isFileReference(attachment)) await locator.fileApp.open(attachment);
else if (isDataFile(attachment)) await locator.fileController.saveDataFile(attachment);
else if (isTutanotaFile(attachment)) await locator.fileController.download(attachment);
else throw new ProgrammingError("attachment is neither reference, datafile nor tutanotafile!");
	} catch (e) {
		if (e instanceof FileOpenError) return Dialog.message("canNotOpenFileOnDevice_msg");
else {
			const msg = e.message || "unknown error";
			console.error("could not open file:", msg);
			return Dialog.message("errorDuringFileOpen_msg");
		}
	}
}
const cleanupInlineAttachments = debounce(50, (domElement, inlineImageElements, attachments) => {
	const elementsToRemove = [];
	for (const inlineImage of inlineImageElements) if (domElement && !domElement.contains(inlineImage)) {
		const cid = inlineImage.getAttribute("cid");
		const attachmentIndex = attachments.findIndex((a) => a.cid === cid);
		if (attachmentIndex !== -1) {
			attachments.splice(attachmentIndex, 1);
			elementsToRemove.push(inlineImage);
			mithril_default.redraw();
		}
	}
	findAllAndRemove(inlineImageElements, (imageElement) => elementsToRemove.includes(imageElement));
});
function getConfidentialStateMessage(isConfidential) {
	return isConfidential ? lang.get("confidentialStatus_msg") : lang.get("nonConfidentialStatus_msg");
}

//#endregion
//#region ../src/mail-app/templates/view/TemplateConstants.ts
const TEMPLATE_POPUP_HEIGHT = 340;
const TEMPLATE_POPUP_TWO_COLUMN_MIN_WIDTH = 600;
const TEMPLATE_LIST_ENTRY_HEIGHT = 47;
const TEMPLATE_LIST_ENTRY_WIDTH = 354;

//#endregion
//#region ../src/mail-app/templates/view/TemplatePopupResultRow.ts
var TemplatePopupResultRow = class {
	view(vnode) {
		const { title, tag } = vnode.attrs.template;
		return mithril_default(".flex.flex-column.overflow-hidden.full-width.ml-s", {
			style: { height: px(TEMPLATE_LIST_ENTRY_HEIGHT) },
			title
		}, [mithril_default(".text-ellipsis.smaller", { style: { marginLeft: "4px" } }, title), mithril_default(".flex.badge-line-height.text-ellipsis", [tag ? mithril_default(".small.keyword-bubble-no-padding.pl-s.pr-s.border-radius.no-wrap.small.min-content", TEMPLATE_SHORTCUT_PREFIX + tag.toLowerCase()) : null])]);
	}
};

//#endregion
//#region ../src/mail-app/templates/view/TemplateExpander.ts
var TemplateExpander = class {
	sanitizedText = memoized((text) => htmlSanitizer.sanitizeHTML(text, {
		blockExternalContent: false,
		allowRelativeLinks: true
	}).html);
	view({ attrs }) {
		const { model, template } = attrs;
		const selectedContent = model.getSelectedContent();
		return mithril_default(".flex.flex-column.flex-grow.scroll.ml-s", {
			style: { maxHeight: px(TEMPLATE_POPUP_HEIGHT - size.button_height) },
			onkeydown: (e) => {
				if (isKeyPressed(e.key, Keys.TAB)) e.preventDefault();
			}
		}, [mithril_default(".text-break.smaller.b.text-center", { style: { "border-bottom": `1px solid ${theme.content_border}` } }, template.title), mithril_default(".text-break.flex-grow.pr.overflow-y-visible.pt", selectedContent ? mithril_default.trust(this.sanitizedText(selectedContent.text)) : null)]);
	}
};

//#endregion
//#region ../src/mail-app/templates/view/TemplateSearchBar.ts
var TemplateSearchBar = class {
	domInput = null;
	view(vnode) {
		const a = vnode.attrs;
		return mithril_default(".inputWrapper.pt-xs.pb-xs", { style: { "border-bottom": `1px solid ${theme.content_border}` } }, this._getInputField(a));
	}
	_getInputField(a) {
		return mithril_default("input.input", {
			placeholder: a.placeholder && lang.getTranslationText(a.placeholder),
			oncreate: (vnode) => {
				this.domInput = vnode.dom;
				this.domInput.value = a.value();
				this.domInput.focus();
			},
			onkeydown: (e) => {
				const key = keyboardEventToKeyPress(e);
				return a.keyHandler != null ? a.keyHandler(key) : true;
			},
			oninput: () => {
				const domInput = assertNotNull(this.domInput);
				a.value(domInput.value);
				a.oninput?.(domInput.value, domInput);
			},
			style: { lineHeight: px(inputLineHeight) }
		});
	}
};

//#endregion
//#region ../src/mail-app/templates/TemplateGroupUtils.ts
async function createInitialTemplateListIfAllowed() {
	const userController = locator.logins.getUserController();
	const customer = await userController.loadCustomer();
	const { getAvailablePlansWithTemplates } = await import("./SubscriptionUtils-j-oFQxhJ.js");
	let allowed = (await userController.getPlanConfig()).templates || isCustomizationEnabledForCustomer(customer, FeatureType.BusinessFeatureEnabled);
	if (!allowed) if (userController.isGlobalAdmin()) allowed = await showPlanUpgradeRequiredDialog(await getAvailablePlansWithTemplates());
else Dialog.message("contactAdmin_msg");
	if (allowed) {
		const groupId = await locator.groupManagementFacade.createTemplateGroup("");
		return locator.entityClient.load(TemplateGroupRootTypeRef, groupId);
	} else return null;
}

//#endregion
//#region ../src/common/gui/ScrollSelectList.ts
var ScrollSelectList = class {
	selectedItem = null;
	view(vnode) {
		const a = vnode.attrs;
		return mithril_default(".flex.flex-column.scroll-no-overlay", a.items.length > 0 ? a.items.map((item) => this.renderRow(item, vnode)) : mithril_default(".row-selected.text-center.pt", lang.get(resolveMaybeLazy(a.emptyListMessage))));
	}
	onupdate(vnode) {
		const newSelectedItem = vnode.attrs.selectedItem;
		if (newSelectedItem !== this.selectedItem) {
			this._onSelectionChanged(newSelectedItem, vnode.attrs.items, vnode.dom);
			mithril_default.redraw();
		}
	}
	renderRow(item, vnode) {
		const a = vnode.attrs;
		const isSelected = a.selectedItem === item;
		return mithril_default(".flex.flex-column.click", { style: { maxWidth: a.width } }, [mithril_default(".flex.template-list-row" + (isSelected ? ".row-selected" : ""), {
			onclick: (e) => {
				a.onItemSelected(item);
				e.stopPropagation();
			},
			ondblclick: (e) => {
				a.onItemSelected(item);
				a.onItemDoubleClicked(item);
				e.stopPropagation();
			}
		}, [a.renderItem(item), isSelected ? mithril_default(Icon, {
			icon: Icons.ArrowForward,
			style: {
				marginTop: "auto",
				marginBottom: "auto"
			}
		}) : mithril_default("", { style: {
			width: "17.1px",
			height: "16px"
		} })])]);
	}
	_onSelectionChanged(selectedItem, items, scrollDom) {
		this.selectedItem = selectedItem;
		if (selectedItem != null) {
			const selectedIndex = items.indexOf(selectedItem);
			if (selectedIndex !== -1) {
				const selectedDomElement = scrollDom.children.item(selectedIndex);
				if (selectedDomElement) selectedDomElement.scrollIntoView({
					block: "nearest",
					inline: "nearest"
				});
			}
		}
	}
};

//#endregion
//#region ../src/mail-app/templates/view/TemplatePopup.ts
var import_stream$4 = __toESM(require_stream(), 1);
function showTemplatePopupInEditor(templateModel, editor, template, highlightedText) {
	const initialSearchString = template ? TEMPLATE_SHORTCUT_PREFIX + template.tag : highlightedText;
	const cursorRect = editor.getCursorPosition();
	const editorRect = editor.getDOM().getBoundingClientRect();
	const onSelect = (text) => {
		editor.insertHTML(text);
		editor.focus();
	};
	let rect;
	const availableHeightBelowCursor = window.innerHeight - cursorRect.bottom;
	const popUpHeight = TEMPLATE_POPUP_HEIGHT + 10;
	const popUpWidth = editorRect.right - editorRect.left;
	if (availableHeightBelowCursor < popUpHeight) {
		const diff = popUpHeight - availableHeightBelowCursor;
		rect = new DomRectReadOnlyPolyfilled(editorRect.left, cursorRect.bottom - diff, popUpWidth, cursorRect.height);
	} else rect = new DomRectReadOnlyPolyfilled(editorRect.left, cursorRect.bottom, popUpWidth, cursorRect.height);
	const popup = new TemplatePopup(templateModel, rect, onSelect, initialSearchString, () => editor.focus());
	templateModel.search(initialSearchString);
	popup.show();
}
var TemplatePopup = class {
	_rect;
	_shortcuts;
	_onSelect;
	_initialWindowWidth;
	_resizeListener;
	_redrawStream;
	_templateModel;
	_searchBarValue;
	_selectTemplateButtonAttrs;
	_inputDom = null;
	_debounceFilter;
	focusedBeforeShown = null;
	constructor(templateModel, rect, onSelect, initialSearchString, restoreEditorFocus) {
		this.restoreEditorFocus = restoreEditorFocus;
		this._rect = rect;
		this._onSelect = onSelect;
		this._initialWindowWidth = window.innerWidth;
		this._resizeListener = () => {
			this._close();
		};
		this._searchBarValue = (0, import_stream$4.default)(initialSearchString);
		this._templateModel = templateModel;
		this._shortcuts = [
			{
				key: Keys.ESC,
				enabled: () => true,
				exec: () => {
					this.restoreEditorFocus?.();
					this._close();
					mithril_default.redraw();
				},
				help: "closeTemplate_action"
			},
			{
				key: Keys.RETURN,
				enabled: () => true,
				exec: () => {
					const selectedContent = this._templateModel.getSelectedContent();
					if (selectedContent) {
						this._onSelect(selectedContent.text);
						this._close();
					}
				},
				help: "insertTemplate_action"
			},
			{
				key: Keys.UP,
				enabled: () => true,
				exec: () => {
					this._templateModel.selectNextTemplate(SELECT_PREV_TEMPLATE);
				},
				help: "selectPreviousTemplate_action"
			},
			{
				key: Keys.DOWN,
				enabled: () => true,
				exec: () => {
					this._templateModel.selectNextTemplate(SELECT_NEXT_TEMPLATE);
				},
				help: "selectNextTemplate_action"
			}
		];
		this._redrawStream = templateModel.searchResults.map((results) => {
			mithril_default.redraw();
		});
		this._selectTemplateButtonAttrs = {
			label: "selectTemplate_action",
			click: () => {
				const selected = this._templateModel.getSelectedContent();
				if (selected) {
					this._onSelect(selected.text);
					this._close();
				}
			},
			type: ButtonType.Primary
		};
		this._debounceFilter = debounce(200, (value) => {
			templateModel.search(value);
		});
		this._debounceFilter(initialSearchString);
	}
	view = () => {
		const showTwoColumns = this._isScreenWideEnough();
		return mithril_default(".flex.flex-column.abs.elevated-bg.border-radius.dropdown-shadow", {
			style: {
				width: px(this._rect.width),
				height: px(TEMPLATE_POPUP_HEIGHT),
				top: px(this._rect.top),
				left: px(this._rect.left)
			},
			onclick: (e) => {
				this._inputDom?.focus();
				e.stopPropagation();
			},
			oncreate: () => {
				windowFacade.addResizeListener(this._resizeListener);
			},
			onremove: () => {
				windowFacade.removeResizeListener(this._resizeListener);
			}
		}, [this._renderHeader(), mithril_default(".flex.flex-grow.scroll.mb-s", [mithril_default(".flex.flex-column.scroll" + (showTwoColumns ? ".pr" : ""), { style: { flex: "1 1 40%" } }, this._renderList()), showTwoColumns ? mithril_default(".flex.flex-column.flex-grow-shrink-half", { style: { flex: "1 1 60%" } }, this._renderRightColumn()) : null])]);
	};
	_renderHeader() {
		const selectedTemplate = this._templateModel.getSelectedTemplate();
		return mithril_default(".flex-space-between.center-vertically.pl.pr-s", [mithril_default(".flex-start", [mithril_default(".flex.center-vertically", this._renderSearchBar()), this._renderAddButton()]), mithril_default(".flex-end", [selectedTemplate ? this._renderEditButtons(selectedTemplate) : null])]);
	}
	_renderSearchBar = () => {
		return mithril_default(TemplateSearchBar, {
			value: this._searchBarValue,
			placeholder: "filter_label",
			keyHandler: (keyPress) => {
				if (isKeyPressed(keyPress.key, Keys.DOWN, Keys.UP)) {
					this._templateModel.selectNextTemplate(isKeyPressed(keyPress.key, Keys.UP) ? SELECT_PREV_TEMPLATE : SELECT_NEXT_TEMPLATE);
					return false;
				} else return true;
			},
			oninput: (value) => {
				this._debounceFilter(value);
			},
			oncreate: (vnode) => {
				this._inputDom = vnode.dom.firstElementChild;
			}
		});
	};
	_renderAddButton() {
		const attrs = this._createAddButtonAttributes();
		return mithril_default("", { onkeydown: (e) => {
			if (isKeyPressed(e.key, Keys.TAB) && !this._templateModel.getSelectedTemplate()) {
				this._inputDom?.focus();
				e.preventDefault();
			}
		} }, attrs ? mithril_default(IconButton, attrs) : null);
	}
	_createAddButtonAttributes() {
		const templateGroupInstances = this._templateModel.getTemplateGroupInstances();
		const writeableGroups = templateGroupInstances.filter((instance) => hasCapabilityOnGroup(locator.logins.getUserController().user, instance.group, ShareCapability.Write));
		if (templateGroupInstances.length === 0) return {
			title: "createTemplate_action",
			click: () => {
				createInitialTemplateListIfAllowed().then((groupRoot) => {
					if (groupRoot) this.showTemplateEditor(null, groupRoot);
				});
			},
			icon: Icons.Add,
			colors: ButtonColor.DrawerNav
		};
else if (writeableGroups.length === 1) return {
			title: "createTemplate_action",
			click: () => this.showTemplateEditor(null, writeableGroups[0].groupRoot),
			icon: Icons.Add,
			colors: ButtonColor.DrawerNav
		};
else if (writeableGroups.length > 1) return attachDropdown({
			mainButtonAttrs: {
				title: "createTemplate_action",
				icon: Icons.Add,
				colors: ButtonColor.DrawerNav
			},
			childAttrs: () => writeableGroups.map((groupInstances) => {
				return {
					label: lang.makeTranslation("group_name", getSharedGroupName(groupInstances.groupInfo, locator.logins.getUserController(), true)),
					click: () => this.showTemplateEditor(null, groupInstances.groupRoot)
				};
			})
		});
else return null;
	}
	_renderEditButtons(selectedTemplate) {
		const selectedContent = this._templateModel.getSelectedContent();
		const selectedGroup = this._templateModel.getSelectedTemplateGroupInstance();
		const canEdit = !!selectedGroup && hasCapabilityOnGroup(locator.logins.getUserController().user, selectedGroup.group, ShareCapability.Write);
		return [
			mithril_default(".flex.flex-column.justify-center.mr-m", selectedContent ? mithril_default("", lang.get(languageByCode[selectedContent.languageCode].textId)) : ""),
			mithril_default(IconButton, attachDropdown({
				mainButtonAttrs: {
					title: "chooseLanguage_action",
					icon: Icons.Language
				},
				childAttrs: () => selectedTemplate.contents.map((content) => {
					const langCode = downcast(content.languageCode);
					return {
						label: languageByCode[langCode].textId,
						click: (e) => {
							e.stopPropagation();
							this._templateModel.setSelectedContentLanguage(langCode);
							this._inputDom?.focus();
						}
					};
				})
			})),
			canEdit ? [mithril_default(IconButton, {
				title: "editTemplate_action",
				click: () => locator.entityClient.load(TemplateGroupRootTypeRef, neverNull(selectedTemplate._ownerGroup)).then((groupRoot) => this.showTemplateEditor(selectedTemplate, groupRoot)),
				icon: Icons.Edit,
				colors: ButtonColor.DrawerNav
			}), mithril_default(IconButton, {
				title: "remove_action",
				click: () => {
					getConfirmation("deleteTemplate_msg").confirmed(() => locator.entityClient.erase(selectedTemplate));
				},
				icon: Icons.Trash,
				colors: ButtonColor.DrawerNav
			})] : null,
			mithril_default(".pr-s", mithril_default(".nav-bar-spacer")),
			mithril_default("", { onkeydown: (e) => {
				if (isKeyPressed(e.key, Keys.TAB)) {
					this._inputDom?.focus();
					e.preventDefault();
				}
			} }, mithril_default(Button, this._selectTemplateButtonAttrs))
		];
	}
	_renderList() {
		return mithril_default(ScrollSelectList, {
			items: this._templateModel.searchResults(),
			selectedItem: this._templateModel.selectedTemplate(),
			onItemSelected: this._templateModel.selectedTemplate,
			emptyListMessage: () => this._templateModel.isLoaded() ? "nothingFound_label" : "loadingTemplates_label",
			width: TEMPLATE_LIST_ENTRY_WIDTH,
			renderItem: (template) => mithril_default(TemplatePopupResultRow, { template }),
			onItemDoubleClicked: (_) => {
				const selected = this._templateModel.getSelectedContent();
				if (selected) {
					this._onSelect(selected.text);
					this._close();
				}
			}
		});
	}
	_renderRightColumn() {
		const template = this._templateModel.getSelectedTemplate();
		if (template) return [mithril_default(TemplateExpander, {
			template,
			model: this._templateModel
		})];
else return null;
	}
	_isScreenWideEnough() {
		return window.innerWidth > TEMPLATE_POPUP_TWO_COLUMN_MIN_WIDTH;
	}
	_getWindowWidthChange() {
		return window.innerWidth - this._initialWindowWidth;
	}
	show() {
		this.focusedBeforeShown = document.activeElement;
		modal.display(this, false);
	}
	_close() {
		modal.remove(this);
	}
	backgroundClick(e) {
		this.restoreEditorFocus?.();
		this._close();
	}
	hideAnimation() {
		return Promise.resolve();
	}
	onClose() {
		this._redrawStream.end(true);
	}
	shortcuts() {
		return this._shortcuts;
	}
	popState(e) {
		return true;
	}
	callingElement() {
		return this.focusedBeforeShown;
	}
	showTemplateEditor(templateToEdit, groupRoot) {
		import("./TemplateEditor-mLjR6_9p.js").then((editor) => {
			editor.showTemplateEditor(templateToEdit, groupRoot);
		});
	}
};

//#endregion
//#region ../src/mail-app/templates/view/TemplateShortcutListener.ts
function registerTemplateShortcutListener(editor, templateModel) {
	const listener = new TemplateShortcutListener(editor, templateModel, lang);
	editor.addEventListener("keydown", (event) => listener.handleKeyDown(event));
	editor.addEventListener("cursor", (event) => listener.handleCursorChange(event));
	return listener;
}
var TemplateShortcutListener = class {
	_currentCursorPosition;
	_editor;
	_templateModel;
	_lang;
	constructor(editor, templateModel, lang$1) {
		this._editor = editor;
		this._currentCursorPosition = null;
		this._templateModel = templateModel;
		this._lang = lang$1;
	}
	handleKeyDown(event) {
		if (isKeyPressed(event.key, Keys.TAB) && this._currentCursorPosition) {
			const cursorEndPos = this._currentCursorPosition;
			const text = cursorEndPos.startContainer.nodeType === Node.TEXT_NODE ? cursorEndPos.startContainer.textContent ?? "" : "";
			const templateShortcutStartIndex = text.lastIndexOf(TEMPLATE_SHORTCUT_PREFIX);
			const lastWhiteSpaceIndex = text.search(/\s\S*$/);
			if (templateShortcutStartIndex !== -1 && templateShortcutStartIndex < cursorEndPos.startOffset && templateShortcutStartIndex > lastWhiteSpaceIndex) {
				event.stopPropagation();
				event.preventDefault();
				const range = document.createRange();
				range.setStart(cursorEndPos.startContainer, templateShortcutStartIndex);
				range.setEnd(cursorEndPos.startContainer, cursorEndPos.startOffset);
				this._editor.setSelection(range);
				const selectedText = this._editor.getSelectedText();
				const template = this._templateModel.findTemplateWithTag(selectedText);
				if (template) if (template.contents.length > 1) {
					let buttons = template.contents.map((content) => {
						return {
							label: languageByCode[downcast(content.languageCode)].textId,
							click: () => {
								this._editor.insertHTML(content.text);
								this._editor.focus();
							}
						};
					});
					const dropdown = new Dropdown(() => buttons, 200);
					dropdown.setOrigin(this._editor.getCursorPosition());
					modal.displayUnique(dropdown, false);
				} else this._editor.insertHTML(getFirstOrThrow(template.contents).text);
else showTemplatePopupInEditor(this._templateModel, this._editor, null, selectedText);
			}
		}
	}
	handleCursorChange(event) {
		this._currentCursorPosition = event.detail.range;
	}
};

//#endregion
//#region ../src/mail-app/knowledgebase/view/KnowledgeBaseListEntry.ts
const KNOWLEDGEBASE_LIST_ENTRY_HEIGHT = 50;
var KnowledgeBaseListEntry = class {
	view(vnode) {
		const { title, keywords } = vnode.attrs.entry;
		return mithril_default(".flex.flex-column.overflow-hidden.full-width", { style: { height: px(KNOWLEDGEBASE_LIST_ENTRY_HEIGHT) } }, [mithril_default(".text-ellipsis.mb-xs.b", title), mithril_default(".flex.badge-line-height.text-ellipsis", [keywords.map((keyword) => {
			return mithril_default(".b.small.teamLabel.pl-s.pr-s.border-radius.no-wrap.small.mr-s.min-content", keyword.keyword);
		})])]);
	}
};

//#endregion
//#region ../src/mail-app/knowledgebase/view/KnowledgeBaseEntryView.ts
var KnowledgeBaseEntryView = class {
	_sanitizedEntry;
	constructor() {
		this._sanitizedEntry = memoized((entry) => {
			return { content: htmlSanitizer.sanitizeHTML(entry.description, { blockExternalContent: true }).html };
		});
	}
	view({ attrs }) {
		return mithril_default(".flex.flex-column", [this._renderContent(attrs)]);
	}
	_renderContent(attrs) {
		const { entry, readonly } = attrs;
		return mithril_default("", { onclick: (event) => {
			this._handleAnchorClick(event, attrs);
		} }, [mithril_default(".flex.mt-l.center-vertically.selectable", mithril_default(".h4.text-ellipsis", entry.title), !readonly ? [mithril_default(".flex.flex-grow.justify-end", [this.renderEditButton(entry), this.renderRemoveButton(entry)])] : null), mithril_default("", [mithril_default(".mt-s.flex.mt-s.wrap", [entry.keywords.map((entryKeyword) => {
			return mithril_default(".keyword-bubble.selectable", entryKeyword.keyword);
		})]), mithril_default(".flex.flex-column.mt-s", [mithril_default(".editor-border.text-break.selectable", mithril_default.trust(this._sanitizedEntry(entry).content))])])]);
	}
	renderRemoveButton(entry) {
		return mithril_default(IconButton, {
			title: "remove_action",
			icon: Icons.Trash,
			click: () => {
				getConfirmation("deleteEntryConfirm_msg").confirmed(() => locator.entityClient.erase(entry).catch(ofClass(NotFoundError, noOp)));
			}
		});
	}
	renderEditButton(entry) {
		return mithril_default(IconButton, {
			title: "edit_action",
			icon: Icons.Edit,
			click: () => {
				import("./KnowledgeBaseEditor-7OSLD2QV.js").then(({ showKnowledgeBaseEditor: showKnowledgeBaseEditor$1 }) => {
					locator.entityClient.load(TemplateGroupRootTypeRef, neverNull(entry._ownerGroup)).then((groupRoot) => {
						showKnowledgeBaseEditor$1(entry, groupRoot);
					});
				});
			}
		});
	}
	_handleAnchorClick(event, attrs) {
		let target = event.target;
		if (target && target.closest) {
			let anchorElement = target.closest("a");
			if (anchorElement && startsWith(anchorElement.href, "tutatemplate:")) {
				event.preventDefault();
				const [listId, elementId] = new URL(anchorElement.href).pathname.split("/");
				attrs.onTemplateSelected([listId, elementId]);
			}
		}
	}
};

//#endregion
//#region ../src/mail-app/knowledgebase/view/KnowledgeBaseDialogContent.ts
var import_stream$3 = __toESM(require_stream(), 1);
var KnowledgeBaseDialogContent = class {
	_streams;
	filterValue = "";
	_selectionChangedListener;
	constructor() {
		this._streams = [];
	}
	oncreate({ attrs }) {
		const { model } = attrs;
		this._streams.push(import_stream$3.default.combine(() => {
			mithril_default.redraw();
		}, [model.selectedEntry, model.filteredEntries]));
	}
	onremove() {
		for (let stream$5 of this._streams) stream$5.end(true);
	}
	view({ attrs }) {
		const model = attrs.model;
		const selectedEntry = model.selectedEntry();
		return selectedEntry ? mithril_default(KnowledgeBaseEntryView, {
			entry: selectedEntry,
			onTemplateSelected: (templateId) => {
				model.loadTemplate(templateId).then((fetchedTemplate) => {
					attrs.onTemplateSelect(fetchedTemplate);
				}).catch(ofClass(NotFoundError, () => Dialog.message("templateNotExists_msg")));
			},
			readonly: model.isReadOnly(selectedEntry)
		}) : [
			mithril_default(TextField, {
				label: "filter_label",
				value: this.filterValue,
				oninput: (value) => {
					this.filterValue = value;
					model.filter(value);
					mithril_default.redraw();
				}
			}),
			this._renderKeywords(model),
			this._renderList(model, attrs)
		];
	}
	_renderKeywords(model) {
		const matchedKeywords = model.getMatchedKeywordsInContent();
		return mithril_default(".flex.mt-s.wrap", [matchedKeywords.length > 0 ? mithril_default(".small.full-width", lang.get("matchingKeywords_label")) : null, matchedKeywords.map((keyword) => {
			return mithril_default(".keyword-bubble-no-padding.plr-button.pl-s.pr-s.border-radius.no-wrap.mr-s.min-content", keyword);
		})]);
	}
	_renderList(model, attrs) {
		return mithril_default(".mt-s.scroll", {
			oncreate: (vnode) => {
				this._selectionChangedListener = model.selectedEntry.map(makeListSelectionChangedScrollHandler(vnode.dom, KNOWLEDGEBASE_LIST_ENTRY_HEIGHT, model.getSelectedEntryIndex.bind(model)));
			},
			onbeforeremove: () => {
				this._selectionChangedListener.end();
			}
		}, [model.containsResult() ? model.filteredEntries().map((entry) => this._renderListEntry(model, entry)) : mithril_default(".center", lang.get("noEntryFound_label"))]);
	}
	_renderListEntry(model, entry) {
		return mithril_default(".flex.flex-column.click.hoverable-list-item", [mithril_default(".flex", { onclick: () => {
			model.selectedEntry(entry);
		} }, [mithril_default(KnowledgeBaseListEntry, { entry }), mithril_default("", { style: {
			width: "17.1px",
			height: "16px"
		} })])]);
	}
};

//#endregion
//#region ../src/mail-app/knowledgebase/view/KnowledgeBaseDialog.ts
var import_stream$2 = __toESM(require_stream(), 1);
function createKnowledgeBaseDialogInjection(knowledgeBase, templateModel, editor) {
	const knowledgebaseAttrs = {
		onTemplateSelect: (template) => {
			showTemplatePopupInEditor(templateModel, editor, template, "");
		},
		model: knowledgeBase
	};
	const isDialogVisible = (0, import_stream$2.default)(false);
	return {
		visible: isDialogVisible,
		headerAttrs: _createHeaderAttrs(knowledgebaseAttrs, isDialogVisible),
		componentAttrs: knowledgebaseAttrs,
		component: KnowledgeBaseDialogContent
	};
}
function _createHeaderAttrs(attrs, isDialogVisible) {
	return () => {
		const selectedEntry = attrs.model.selectedEntry();
		return selectedEntry ? createEntryViewHeader(selectedEntry, attrs.model) : createListViewHeader(attrs.model, isDialogVisible);
	};
}
function createEntryViewHeader(entry, model) {
	return {
		left: [{
			label: "back_action",
			click: () => model.selectedEntry(null),
			type: ButtonType.Secondary
		}],
		middle: "knowledgebase_label"
	};
}
function createListViewHeader(model, isDialogVisible) {
	return {
		left: () => [{
			label: "close_alt",
			click: () => isDialogVisible(false),
			type: ButtonType.Primary
		}],
		middle: "knowledgebase_label",
		right: [createAddButtonAttrs(model)]
	};
}
function createAddButtonAttrs(model) {
	const templateGroupInstances = model.getTemplateGroupInstances();
	if (templateGroupInstances.length === 1) return {
		label: "add_action",
		click: () => {
			showKnowledgeBaseEditor(null, templateGroupInstances[0].groupRoot);
		},
		type: ButtonType.Primary
	};
else return {
		label: "add_action",
		type: ButtonType.Primary,
		click: createDropdown({ lazyButtons: () => templateGroupInstances.map((groupInstances) => {
			return {
				label: lang.makeTranslation("group_name", getSharedGroupName(groupInstances.groupInfo, model.userController, true)),
				click: () => {
					showKnowledgeBaseEditor(null, groupInstances.groupRoot);
				}
			};
		}) })
	};
}
function showKnowledgeBaseEditor(entryToEdit, groupRoot) {
	import("./KnowledgeBaseEditor-7OSLD2QV.js").then((editor) => {
		editor.showKnowledgeBaseEditor(entryToEdit, groupRoot);
	});
}

//#endregion
//#region ../src/mail-app/knowledgebase/model/KnowledgeBaseModel.ts
var import_stream$1 = __toESM(require_stream(), 1);
const SELECT_NEXT_ENTRY = "next";
function compareKnowledgeBaseEntriesForSort(entry1, entry2) {
	return entry1.title.localeCompare(entry2.title);
}
var KnowledgeBaseModel = class {
	_allEntries;
	filteredEntries;
	selectedEntry;
	_allKeywords;
	_matchedKeywordsInContent;
	_filterValue;
	_eventController;
	_entityClient;
	_entityEventReceived;
	_groupInstances;
	_initialized;
	userController;
	constructor(eventController, entityClient, userController) {
		this._eventController = eventController;
		this._entityClient = entityClient;
		this.userController = userController;
		this._allEntries = SortedArray.empty(compareKnowledgeBaseEntriesForSort);
		this._allKeywords = [];
		this._matchedKeywordsInContent = [];
		this.filteredEntries = (0, import_stream$1.default)(this._allEntries.array);
		this.selectedEntry = (0, import_stream$1.default)(null);
		this._filterValue = "";
		this._entityEventReceived = (updates) => {
			return this._entityUpdate(updates);
		};
		this._eventController.addEntityListener(this._entityEventReceived);
		this._groupInstances = [];
		this._allKeywords = [];
		this.filteredEntries(this._allEntries.array);
		this.selectedEntry(this.containsResult() ? this.filteredEntries()[0] : null);
		this._initialized = new LazyLoaded(() => {
			const templateMemberships = this.userController.getTemplateMemberships();
			let newGroupInstances = [];
			return pMap(templateMemberships, (membership) => loadTemplateGroupInstance(membership, entityClient)).then((groupInstances) => {
				newGroupInstances = groupInstances;
				return loadKnowledgebaseEntries(groupInstances, entityClient);
			}).then((knowledgebaseEntries) => {
				this._allEntries.insertAll(knowledgebaseEntries);
				this._groupInstances = newGroupInstances;
				this.initAllKeywords();
				return this;
			});
		});
	}
	init() {
		return this._initialized.getAsync();
	}
	isInitialized() {
		return this._initialized.isLoaded();
	}
	getTemplateGroupInstances() {
		return this._groupInstances;
	}
	initAllKeywords() {
		this._allKeywords = [];
		this._matchedKeywordsInContent = [];
		for (const entry of this._allEntries.array) for (const keyword of entry.keywords) this._allKeywords.push(keyword.keyword);
	}
	isSelectedEntry(entry) {
		return this.selectedEntry() === entry;
	}
	containsResult() {
		return this.filteredEntries().length > 0;
	}
	getAllKeywords() {
		return this._allKeywords.sort();
	}
	getMatchedKeywordsInContent() {
		return this._matchedKeywordsInContent;
	}
	getLanguageFromTemplate(template) {
		const clientLanguage = lang.code;
		const hasClientLanguage = template.contents.some((content) => content.languageCode === clientLanguage);
		if (hasClientLanguage) return clientLanguage;
		return downcast(template.contents[0].languageCode);
	}
	sortEntriesByMatchingKeywords(emailContent) {
		this._matchedKeywordsInContent = [];
		const emailContentNoTags = emailContent.replace(/(<([^>]+)>)/gi, "");
		for (const keyword of this._allKeywords) if (emailContentNoTags.includes(keyword)) this._matchedKeywordsInContent.push(keyword);
		this._allEntries = SortedArray.from(this._allEntries.array, (a, b) => this._compareEntriesByMatchedKeywords(a, b));
		this._filterValue = "";
		this.filteredEntries(this._allEntries.array);
	}
	_compareEntriesByMatchedKeywords(entry1, entry2) {
		const difference = this._getMatchedKeywordsNumber(entry2) - this._getMatchedKeywordsNumber(entry1);
		return difference === 0 ? compareKnowledgeBaseEntriesForSort(entry1, entry2) : difference;
	}
	_getMatchedKeywordsNumber(entry) {
		let matches = 0;
		for (const k of entry.keywords) if (this._matchedKeywordsInContent.includes(k.keyword)) matches++;
		return matches;
	}
	filter(input) {
		this._filterValue = input;
		const inputTrimmed = input.trim();
		if (inputTrimmed) this.filteredEntries(knowledgeBaseSearch(inputTrimmed, this._allEntries.array));
else this.filteredEntries(this._allEntries.array);
	}
	selectNextEntry(action) {
		const selectedIndex = this.getSelectedEntryIndex();
		const nextIndex = selectedIndex + (action === SELECT_NEXT_ENTRY ? 1 : -1);
		if (nextIndex >= 0 && nextIndex < this.filteredEntries().length) {
			const nextSelectedEntry = this.filteredEntries()[nextIndex];
			this.selectedEntry(nextSelectedEntry);
			return true;
		}
		return false;
	}
	getSelectedEntryIndex() {
		const selectedEntry = this.selectedEntry();
		if (selectedEntry == null) return -1;
		return this.filteredEntries().indexOf(selectedEntry);
	}
	_removeFromAllKeywords(keyword) {
		const index = this._allKeywords.indexOf(keyword);
		if (index > -1) this._allKeywords.splice(index, 1);
	}
	dispose() {
		this._eventController.removeEntityListener(this._entityEventReceived);
	}
	loadTemplate(templateId) {
		return this._entityClient.load(EmailTemplateTypeRef, templateId);
	}
	isReadOnly(entry) {
		const instance = this._groupInstances.find((instance$1) => isSameId(entry._ownerGroup, getEtId(instance$1.group)));
		return !instance || !hasCapabilityOnGroup(this.userController.user, instance.group, ShareCapability.Write);
	}
	_entityUpdate(updates) {
		return pMap(updates, (update) => {
			if (isUpdateForTypeRef(KnowledgeBaseEntryTypeRef, update)) {
				if (update.operation === OperationType.CREATE) return this._entityClient.load(KnowledgeBaseEntryTypeRef, [update.instanceListId, update.instanceId]).then((entry) => {
					this._allEntries.insert(entry);
					this.filter(this._filterValue);
				});
else if (update.operation === OperationType.UPDATE) return this._entityClient.load(KnowledgeBaseEntryTypeRef, [update.instanceListId, update.instanceId]).then((updatedEntry) => {
					this._allEntries.removeFirst((e) => isSameId(getElementId(e), update.instanceId));
					this._allEntries.insert(updatedEntry);
					this.filter(this._filterValue);
					const oldSelectedEntry = this.selectedEntry();
					if (oldSelectedEntry && isSameId(oldSelectedEntry._id, updatedEntry._id)) this.selectedEntry(updatedEntry);
				});
else if (update.operation === OperationType.DELETE) {
					const selected = this.selectedEntry();
					if (selected && isSameId(getLetId(selected), [update.instanceListId, update.instanceId])) this.selectedEntry(null);
					this._allEntries.removeFirst((e) => isSameId(getElementId(e), update.instanceId));
					this.filter(this._filterValue);
				}
			}
		}).then(noOp);
	}
};
function loadKnowledgebaseEntries(templateGroups, entityClient) {
	return pMap(templateGroups, (group) => entityClient.loadAll(KnowledgeBaseEntryTypeRef, group.groupRoot.knowledgeBase)).then((groupedTemplates) => groupedTemplates.flat());
}

//#endregion
//#region ../src/common/gui/base/CounterBadge.ts
var CounterBadge = class {
	_hovered = false;
	constructor(vnode) {
		this._hovered = false;
	}
	view(vnode) {
		const { count, position, background, color, showFullCount } = vnode.attrs;
		return count > 0 ? mithril_default(".counter-badge.z2", {
			class: position ? "abs" : "",
			onmouseenter: () => {
				this._hovered = true;
			},
			onmouseleave: () => {
				this._hovered = false;
			},
			style: {
				width: position?.width,
				top: position?.top,
				bottom: position?.bottom,
				right: position?.right,
				left: position?.left,
				height: position?.height,
				"z-index": position?.zIndex,
				background,
				color
			}
		}, count < 99 || this._hovered || showFullCount ? count : "99+") : null;
	}
};

//#endregion
//#region ../src/mail-app/mail/view/MinimizedEditorOverlay.ts
const COUNTER_POS_OFFSET = px(-8);
var MinimizedEditorOverlay = class {
	_listener;
	_eventController;
	constructor(vnode) {
		const { minimizedEditor, viewModel, eventController } = vnode.attrs;
		this._eventController = eventController;
		this._listener = (updates, eventOwnerGroupId) => {
			return pMap(updates, (update) => {
				if (isUpdateForTypeRef(MailTypeRef, update) && update.operation === OperationType.DELETE) {
					let draft = minimizedEditor.sendMailModel.getDraft();
					if (draft && isSameId(draft._id, [update.instanceListId, update.instanceId])) viewModel.removeMinimizedEditor(minimizedEditor);
				}
			});
		};
		eventController.addEntityListener(this._listener);
	}
	onremove() {
		this._eventController.removeEntityListener(this._listener);
	}
	view(vnode) {
		const { minimizedEditor, viewModel, eventController } = vnode.attrs;
		const subject = minimizedEditor.sendMailModel.getSubject();
		return mithril_default(".elevated-bg.pl.border-radius", [mithril_default(CounterBadge, {
			count: viewModel.getMinimizedEditors().indexOf(minimizedEditor) + 1,
			position: {
				top: COUNTER_POS_OFFSET,
				right: COUNTER_POS_OFFSET
			},
			color: theme.navigation_button_icon,
			background: getNavButtonIconBackground()
		}), mithril_default(".flex.justify-between.pb-xs.pt-xs", [mithril_default(".flex.col.justify-center.min-width-0.flex-grow", { onclick: () => viewModel.reopenMinimizedEditor(minimizedEditor) }, [mithril_default(".b.text-ellipsis", subject ? subject : lang.get("newMail_action")), mithril_default(".small.text-ellipsis", getStatusMessage(minimizedEditor.saveStatus()))]), mithril_default(".flex.items-center.justify-right", [
			!styles.isSingleColumnLayout() ? mithril_default(IconButton, {
				title: "edit_action",
				click: () => viewModel.reopenMinimizedEditor(minimizedEditor),
				icon: Icons.Edit
			}) : null,
			mithril_default(IconButton, {
				title: "delete_action",
				click: () => this._onDeleteClicked(minimizedEditor, viewModel),
				icon: Icons.Trash
			}),
			mithril_default(IconButton, {
				title: "close_alt",
				click: () => viewModel.removeMinimizedEditor(minimizedEditor),
				icon: Icons.Cancel
			})
		])])]);
	}
	_onDeleteClicked(minimizedEditor, viewModel) {
		const model = minimizedEditor.sendMailModel;
		viewModel.removeMinimizedEditor(minimizedEditor);
		minimizedEditor.saveStatus.map(async ({ status }) => {
			if (status !== SaveStatusEnum.Saving) {
				const draft = model.draft;
				if (draft) await promptAndDeleteMails(mailLocator.mailModel, [draft], noOp);
			}
		});
	}
};
function getStatusMessage(saveStatus) {
	switch (saveStatus.status) {
		case SaveStatusEnum.Saving: return lang.get("save_msg");
		case SaveStatusEnum.NotSaved: switch (saveStatus.reason) {
			case SaveErrorReason.ConnectionLost: return lang.get("draftNotSavedConnectionLost_msg");
			default: return lang.get("draftNotSaved_msg");
		}
		case SaveStatusEnum.Saved: return lang.get("draftSaved_msg");
		default: return "";
	}
}

//#endregion
//#region ../src/mail-app/mail/view/MinimizedMailEditorOverlay.ts
assertMainOrNode();
const MINIMIZED_OVERLAY_WIDTH_WIDE = 350;
const MINIMIZED_OVERLAY_WIDTH_SMALL = 220;
function showMinimizedMailEditor(dialog, sendMailModel, viewModel, eventController, dispose, saveStatus) {
	let closeOverlayFunction = noOp;
	const minimizedEditor = viewModel.minimizeMailEditor(dialog, sendMailModel, dispose, saveStatus, () => closeOverlayFunction());
	setTimeout(() => {
		closeOverlayFunction = showMinimizedEditorOverlay(viewModel, minimizedEditor, eventController);
	}, DefaultAnimationTime);
}
function showMinimizedEditorOverlay(viewModel, minimizedEditor, eventController) {
	return displayOverlay(() => getOverlayPosition(), { view: () => mithril_default(MinimizedEditorOverlay, {
		viewModel,
		minimizedEditor,
		eventController
	}) }, "slide-bottom", undefined, "minimized-shadow");
}
function getOverlayPosition() {
	return {
		bottom: styles.isUsingBottomNavigation() ? px(size.hpad) : px(size.vpad),
		right: styles.isUsingBottomNavigation() ? px(size.hpad) : px(size.hpad_medium),
		width: px(styles.isSingleColumnLayout() ? MINIMIZED_OVERLAY_WIDTH_SMALL : MINIMIZED_OVERLAY_WIDTH_WIDE),
		zIndex: LayerType.LowPriorityOverlay
	};
}

//#endregion
//#region ../src/mail-app/mail/editor/MailEditor.ts
var import_stream = __toESM(require_stream(), 1);
function createMailEditorAttrs(model, doBlockExternalContent, doFocusEditorOnLoad, dialog, templateModel, knowledgeBaseInjection, search, alwaysBlockExternalContent) {
	return {
		model,
		doBlockExternalContent: (0, import_stream.default)(doBlockExternalContent),
		doShowToolbar: (0, import_stream.default)(false),
		selectedNotificationLanguage: (0, import_stream.default)(""),
		dialog,
		templateModel,
		knowledgeBaseInjection,
		search,
		alwaysBlockExternalContent
	};
}
var MailEditor = class {
	attrs;
	editor;
	recipientFieldTexts = {
		to: (0, import_stream.default)(""),
		cc: (0, import_stream.default)(""),
		bcc: (0, import_stream.default)("")
	};
	mentionedInlineImages;
	inlineImageElements;
	templateModel;
	knowledgeBaseInjection = null;
	sendMailModel;
	areDetailsExpanded;
	recipientShowConfidential = new Map();
	blockExternalContent;
	alwaysBlockExternalContent = false;
	blockedExternalContent = 0;
	constructor(vnode) {
		const a = vnode.attrs;
		this.attrs = a;
		this.inlineImageElements = [];
		this.mentionedInlineImages = [];
		const model = a.model;
		this.sendMailModel = model;
		this.templateModel = a.templateModel;
		this.blockExternalContent = a.doBlockExternalContent();
		this.alwaysBlockExternalContent = a.alwaysBlockExternalContent;
		this.areDetailsExpanded = model.bccRecipients().length + model.ccRecipients().length > 0;
		this.editor = new Editor(200, (html, isPaste) => {
			const sanitized = htmlSanitizer.sanitizeFragment(html, { blockExternalContent: !isPaste && this.blockExternalContent });
			this.blockedExternalContent = sanitized.blockedExternalContent;
			this.mentionedInlineImages = sanitized.inlineImageCids;
			return sanitized.fragment;
		}, null);
		const onEditorChanged = () => {
			cleanupInlineAttachments(this.editor.getDOM(), this.inlineImageElements, model.getAttachments());
			model.markAsChangedIfNecessary(true);
			mithril_default.redraw();
		};
		this.editor.initialized.promise.then(() => {
			this.editor.setHTML(model.getBody());
			const editorDom = this.editor.getDOM();
			const contrastFixNeeded = isMailContrastFixNeeded(editorDom);
			if (contrastFixNeeded) editorDom.classList.add("bg-fix-quoted");
			this.processInlineImages();
			new MutationObserver(onEditorChanged).observe(this.editor.getDOM(), {
				attributes: false,
				childList: true,
				subtree: true
			});
			this.editor.addChangeListener(() => model.setBody(replaceInlineImagesWithCids(this.editor.getDOM()).innerHTML));
			this.editor.addEventListener("pasteImage", ({ detail }) => {
				const items = Array.from(detail.clipboardData.items);
				const imageItems = items.filter((item) => /image/.test(item.type));
				if (!imageItems.length) return false;
				const file = imageItems[0]?.getAsFile();
				if (file == null) return false;
				const reader = new FileReader();
				reader.onload = () => {
					if (reader.result == null || "string" === typeof reader.result) return;
					const newInlineImages = [createDataFile(file.name, file.type, new Uint8Array(reader.result))];
					model.attachFiles(newInlineImages);
					this.insertInlineImages(model, newInlineImages);
				};
				reader.readAsArrayBuffer(file);
			});
			if (a.templateModel) a.templateModel.init().then((templateModel) => {
				registerTemplateShortcutListener(this.editor, templateModel);
			});
		});
		model.onMailChanged.map(() => mithril_default.redraw());
		model.setOnBeforeSendFunction(() => {
			let invalidText = "";
			for (const leftoverText of typedValues(this.recipientFieldTexts)) if (leftoverText().trim() !== "") invalidText += "\n" + leftoverText().trim();
			if (invalidText !== "") throw new UserError(lang.makeTranslation("invalidRecipients_msg", lang.get("invalidRecipients_msg") + invalidText));
		});
		const dialog = a.dialog();
		if (model.getConversationType() === ConversationType.REPLY || model.toRecipients().length) dialog.setFocusOnLoadFunction(() => {
			this.editor.initialized.promise.then(() => this.editor.focus());
		});
		const shortcuts = [
			{
				key: Keys.SPACE,
				ctrlOrCmd: true,
				exec: () => this.openTemplates(),
				help: "openTemplatePopup_msg"
			},
			{
				key: Keys.B,
				ctrlOrCmd: true,
				exec: noOp,
				help: "formatTextBold_msg"
			},
			{
				key: Keys.I,
				ctrlOrCmd: true,
				exec: noOp,
				help: "formatTextItalic_msg"
			},
			{
				key: Keys.U,
				ctrlOrCmd: true,
				exec: noOp,
				help: "formatTextUnderline_msg"
			}
		];
		for (const shortcut of shortcuts) dialog.addShortcut(shortcut);
		this.editor.initialized.promise.then(() => {
			a.knowledgeBaseInjection(this.editor).then((injection) => {
				this.knowledgeBaseInjection = injection;
				mithril_default.redraw();
			});
		});
	}
	downloadInlineImage(model, cid) {
		const tutanotaFiles = model.getAttachments().filter((attachment) => isTutanotaFile(attachment));
		const inlineAttachment = tutanotaFiles.find((attachment) => attachment.cid === cid);
		if (inlineAttachment && isTutanotaFile(inlineAttachment)) locator.fileController.open(inlineAttachment).catch(ofClass(FileOpenError, () => Dialog.message("canNotOpenFileOnDevice_msg")));
	}
	view(vnode) {
		const a = vnode.attrs;
		this.attrs = a;
		const { model } = a;
		this.sendMailModel = model;
		const showConfidentialButton = model.containsExternalRecipients();
		const isConfidential = model.isConfidential() && showConfidentialButton;
		const confidentialButtonAttrs = {
			title: "confidential_action",
			onToggled: (_, e) => {
				e.stopPropagation();
				model.setConfidential(!model.isConfidential());
			},
			icon: model.isConfidential() ? Icons.Lock : Icons.Unlock,
			toggled: model.isConfidential(),
			size: ButtonSize.Compact
		};
		const attachFilesButtonAttrs = {
			title: "attachFiles_action",
			click: (ev, dom) => chooseAndAttachFile(model, dom.getBoundingClientRect()).then(() => mithril_default.redraw()),
			icon: Icons.Attachment,
			size: ButtonSize.Compact
		};
		const plaintextFormatting = locator.logins.getUserController().props.sendPlaintextOnly;
		this.editor.setCreatesLists(!plaintextFormatting);
		const toolbarButton = () => !plaintextFormatting ? mithril_default(ToggleButton, {
			title: "showRichTextToolbar_action",
			icon: Icons.FontSize,
			size: ButtonSize.Compact,
			toggled: a.doShowToolbar(),
			onToggled: (_, e) => {
				a.doShowToolbar(!a.doShowToolbar());
				e.stopPropagation();
				this.editor.focus();
			}
		}) : null;
		const subjectFieldAttrs = {
			label: "subject_label",
			helpLabel: () => getConfidentialStateMessage(model.isConfidential()),
			value: model.getSubject(),
			oninput: (val) => model.setSubject(val),
			injectionsRight: () => mithril_default(".flex.end.ml-between-s.items-center", [
				showConfidentialButton ? mithril_default(ToggleButton, confidentialButtonAttrs) : null,
				this.knowledgeBaseInjection ? this.renderToggleKnowledgeBase(this.knowledgeBaseInjection) : null,
				mithril_default(IconButton, attachFilesButtonAttrs),
				toolbarButton()
			])
		};
		const attachmentBubbleAttrs = createAttachmentBubbleAttrs(model, this.inlineImageElements);
		let editCustomNotificationMailAttrs = null;
		if (locator.logins.getUserController().isGlobalAdmin()) editCustomNotificationMailAttrs = attachDropdown({
			mainButtonAttrs: {
				title: "more_label",
				icon: Icons.More,
				size: ButtonSize.Compact
			},
			childAttrs: () => [{
				label: "add_action",
				click: () => {
					import("./EditNotificationEmailDialog-CWN6zOB8.js").then(({ showAddOrEditNotificationEmailDialog }) => showAddOrEditNotificationEmailDialog(locator.logins.getUserController()));
				}
			}, {
				label: "edit_action",
				click: () => {
					import("./EditNotificationEmailDialog-CWN6zOB8.js").then(({ showAddOrEditNotificationEmailDialog }) => showAddOrEditNotificationEmailDialog(locator.logins.getUserController(), model.getSelectedNotificationLanguageCode()));
				}
			}]
		});
		return mithril_default("#mail-editor.full-height.text.touch-callout.flex.flex-column", {
			onclick: (e) => {
				if (e.target === this.editor.getDOM()) this.editor.focus();
			},
			ondragover: (ev) => {
				ev.stopPropagation();
				ev.preventDefault();
			},
			ondrop: (ev) => {
				if (ev.dataTransfer?.files && ev.dataTransfer.files.length > 0) {
					let nativeFiles = fileListToArray(ev.dataTransfer.files);
					readLocalFiles(nativeFiles).then((dataFiles) => {
						model.attachFiles(dataFiles);
						mithril_default.redraw();
					}).catch((e) => {
						console.log(e);
						return Dialog.message("couldNotAttachFile_msg");
					});
					ev.stopPropagation();
					ev.preventDefault();
				}
			}
		}, [
			mithril_default(".rel", this.renderRecipientField(RecipientField.TO, this.recipientFieldTexts.to, a.search)),
			mithril_default(".rel", mithril_default(ExpanderPanel, { expanded: this.areDetailsExpanded }, mithril_default(".details", [this.renderRecipientField(RecipientField.CC, this.recipientFieldTexts.cc, a.search), this.renderRecipientField(RecipientField.BCC, this.recipientFieldTexts.bcc, a.search)]))),
			mithril_default(".wrapping-row", [mithril_default("", { style: { "min-width": "250px" } }, mithril_default(DropDownSelector, {
				label: "sender_label",
				items: getEnabledMailAddressesWithUser(model.mailboxDetails, model.user().userGroupInfo).sort().map((mailAddress) => ({
					name: mailAddress,
					value: mailAddress
				})),
				selectedValue: a.model.getSender(),
				selectedValueDisplay: getMailAddressDisplayText(a.model.getSenderName(), a.model.getSender(), false),
				selectionChangedHandler: (selection) => model.setSender(selection),
				dropdownWidth: 250
			})), isConfidential ? mithril_default(".flex", {
				style: { "min-width": "250px" },
				oncreate: (vnode$1) => {
					const htmlDom = vnode$1.dom;
					htmlDom.style.opacity = "0";
					return animations.add(htmlDom, opacity(0, 1, true));
				},
				onbeforeremove: (vnode$1) => {
					const htmlDom = vnode$1.dom;
					htmlDom.style.opacity = "1";
					return animations.add(htmlDom, opacity(1, 0, true));
				}
			}, [mithril_default(".flex-grow", mithril_default(DropDownSelector, {
				label: "notificationMailLanguage_label",
				items: model.getAvailableNotificationTemplateLanguages().map((language) => {
					return {
						name: lang.get(language.textId),
						value: language.code
					};
				}),
				selectedValue: model.getSelectedNotificationLanguageCode(),
				selectionChangedHandler: (v) => model.setSelectedNotificationLanguageCode(v),
				dropdownWidth: 250
			})), editCustomNotificationMailAttrs ? mithril_default(".pt.flex-no-grow.flex-end.border-bottom.flex.items-center", mithril_default(IconButton, editCustomNotificationMailAttrs)) : null]) : null]),
			isConfidential ? this.renderPasswordFields() : null,
			mithril_default(".row", mithril_default(TextField, subjectFieldAttrs)),
			mithril_default(".flex-start.flex-wrap.mt-s.mb-s.gap-hpad", attachmentBubbleAttrs.map((a$1) => mithril_default(AttachmentBubble, a$1))),
			model.getAttachments().length > 0 ? mithril_default("hr.hr") : null,
			this.renderExternalContentBanner(this.attrs),
			a.doShowToolbar() ? this.renderToolbar(model) : null,
			mithril_default(".pt-s.text.scroll-x.break-word-links.flex.flex-column.flex-grow", { onclick: () => this.editor.focus() }, mithril_default(this.editor)),
			mithril_default(".pb")
		]);
	}
	renderExternalContentBanner(attrs) {
		if (!this.blockExternalContent || this.alwaysBlockExternalContent || this.blockedExternalContent === 0) return null;
		const showButton = {
			label: "showBlockedContent_action",
			click: () => {
				this.updateExternalContentStatus(ContentBlockingStatus.Show);
				this.processInlineImages();
			}
		};
		return mithril_default(InfoBanner, {
			message: "contentBlocked_msg",
			icon: Icons.Picture,
			helpLink: canSeeTutaLinks(attrs.model.logins) ? InfoLink.LoadImages : null,
			buttons: [showButton]
		});
	}
	updateExternalContentStatus(status) {
		this.blockExternalContent = status === ContentBlockingStatus.Block || status === ContentBlockingStatus.AlwaysBlock;
		const sanitized = htmlSanitizer.sanitizeHTML(this.editor.getHTML(), { blockExternalContent: this.blockExternalContent });
		this.editor.setHTML(sanitized.html);
	}
	processInlineImages() {
		this.inlineImageElements = replaceCidsWithInlineImages(this.editor.getDOM(), this.sendMailModel.loadedInlineImages, (cid, event, dom) => {
			const downloadClickHandler = createDropdown({ lazyButtons: () => [{
				label: "download_action",
				click: () => this.downloadInlineImage(this.sendMailModel, cid)
			}] });
			downloadClickHandler(downcast(event), dom);
		});
	}
	renderToggleKnowledgeBase(knowledgeBaseInjection) {
		return mithril_default(ToggleButton, {
			title: "openKnowledgebase_action",
			toggled: knowledgeBaseInjection.visible(),
			onToggled: () => {
				if (knowledgeBaseInjection.visible()) knowledgeBaseInjection.visible(false);
else {
					knowledgeBaseInjection.componentAttrs.model.sortEntriesByMatchingKeywords(this.editor.getValue());
					knowledgeBaseInjection.visible(true);
					knowledgeBaseInjection.componentAttrs.model.init();
				}
			},
			icon: Icons.Book,
			size: ButtonSize.Compact
		});
	}
	renderToolbar(model) {
		return mithril_default.fragment({ onbeforeremove: ({ dom }) => animateToolbar(dom.children[0], false) }, [mithril_default(RichTextToolbar, {
			editor: this.editor,
			imageButtonClickHandler: isApp() ? null : (event) => this.imageButtonClickHandler(model, event.target.getBoundingClientRect()),
			customButtonAttrs: this.templateModel ? [{
				title: "openTemplatePopup_msg",
				click: () => {
					this.openTemplates();
				},
				icon: Icons.ListAlt,
				size: ButtonSize.Compact
			}] : []
		}), mithril_default("hr.hr")]);
	}
	async imageButtonClickHandler(model, rect) {
		const files = await chooseAndAttachFile(model, rect, ALLOWED_IMAGE_FORMATS);
		if (!files || files.length === 0) return;
		return await this.insertInlineImages(model, files);
	}
	async insertInlineImages(model, files) {
		for (const file of files) {
			const img = createInlineImage(file);
			model.loadedInlineImages.set(img.cid, img);
			this.inlineImageElements.push(this.editor.insertImage(img.objectUrl, {
				cid: img.cid,
				style: "max-width: 100%"
			}));
		}
		mithril_default.redraw();
	}
	renderPasswordFields() {
		return mithril_default(".external-recipients.overflow-hidden", {
			oncreate: (vnode) => this.animateHeight(vnode.dom, true),
			onbeforeremove: (vnode) => this.animateHeight(vnode.dom, false)
		}, this.sendMailModel.allRecipients().filter((r) => r.type === RecipientType.EXTERNAL).map((recipient) => {
			if (!this.recipientShowConfidential.has(recipient.address)) this.recipientShowConfidential.set(recipient.address, false);
			return mithril_default(PasswordField, {
				oncreate: (vnode) => this.animateHeight(vnode.dom, true),
				onbeforeremove: (vnode) => this.animateHeight(vnode.dom, false),
				label: lang.getTranslation("passwordFor_label", { "{1}": recipient.address }),
				value: this.sendMailModel.getPassword(recipient.address),
				passwordStrength: this.sendMailModel.getPasswordStrength(recipient),
				status: "auto",
				autocompleteAs: Autocomplete.off,
				oninput: (val) => this.sendMailModel.setPassword(recipient.address, val)
			});
		}));
	}
	renderRecipientField(field, fieldText, search) {
		const label = {
			to: "to_label",
			cc: "cc_label",
			bcc: "bcc_label"
		}[field];
		return mithril_default(MailRecipientsTextField, {
			label,
			text: fieldText(),
			onTextChanged: (text) => fieldText(text),
			recipients: this.sendMailModel.getRecipientList(field),
			onRecipientAdded: async (address, name) => {
				try {
					await this.sendMailModel.addRecipient(field, {
						address,
						name
					});
				} catch (e) {
					if (isOfflineError(e)) {} else if (e instanceof TooManyRequestsError) await Dialog.message("tooManyAttempts_msg");
else throw e;
				}
			},
			onRecipientRemoved: (address) => this.sendMailModel.removeRecipientByAddress(address, field),
			getRecipientClickedDropdownAttrs: (address) => {
				const recipient = this.sendMailModel.getRecipient(field, address);
				return this.getRecipientClickedContextButtons(recipient, field);
			},
			disabled: !this.sendMailModel.logins.isInternalUserLoggedIn(),
			injectionsRight: field === RecipientField.TO && this.sendMailModel.logins.isInternalUserLoggedIn() ? mithril_default("", mithril_default(ToggleButton, {
				title: "show_action",
				icon: BootIcons.Expand,
				size: ButtonSize.Compact,
				toggled: this.areDetailsExpanded,
				onToggled: (_, e) => {
					e.stopPropagation();
					this.areDetailsExpanded = !this.areDetailsExpanded;
				}
			})) : null,
			search
		});
	}
	async getRecipientClickedContextButtons(recipient, field) {
		const { entity, contactModel } = this.sendMailModel;
		const canEditBubbleRecipient = locator.logins.getUserController().isInternalUser() && !locator.logins.isEnabled(FeatureType.DisableContacts);
		const canRemoveBubble = locator.logins.getUserController().isInternalUser();
		const createdContactReceiver = (contactElementId) => {
			const mailAddress = recipient.address;
			contactModel.getContactListId().then((contactListId) => {
				if (!contactListId) return;
				const id = [contactListId, contactElementId];
				entity.load(ContactTypeRef, id).then((contact) => {
					if (contact.mailAddresses.some((ma) => cleanMatch(ma.address, mailAddress))) {
						recipient.setName(getContactDisplayName(contact));
						recipient.setContact(contact);
					} else this.sendMailModel.removeRecipient(recipient, field, false);
				});
			});
		};
		const contextButtons = [];
		if (canEditBubbleRecipient) if (recipient.contact && recipient.contact._id) contextButtons.push({
			label: "editContact_label",
			click: () => {
				import("./ContactEditor-BkD_PWvl.js").then(({ ContactEditor }) => new ContactEditor(entity, recipient.contact).show());
			}
		});
else contextButtons.push({
			label: "createContact_action",
			click: () => {
				contactModel.getContactListId().then((contactListId) => {
					const newContact = createNewContact(locator.logins.getUserController().user, recipient.address, recipient.name);
					import("./ContactEditor-BkD_PWvl.js").then(({ ContactEditor }) => {
						new ContactEditor(entity, newContact, assertNotNull(contactListId), createdContactReceiver).show();
					});
				});
			}
		});
		if (canRemoveBubble) contextButtons.push({
			label: "remove_action",
			click: () => this.sendMailModel.removeRecipient(recipient, field, false)
		});
		return contextButtons;
	}
	openTemplates() {
		if (this.templateModel) this.templateModel.init().then((templateModel) => {
			showTemplatePopupInEditor(templateModel, this.editor, null, this.editor.getSelectedText());
		});
	}
	animateHeight(domElement, fadein) {
		let childHeight = domElement.offsetHeight;
		return animations.add(domElement, fadein ? height(0, childHeight) : height(childHeight, 0)).then(() => {
			domElement.style.height = "";
		});
	}
};
/**
* Creates a new Dialog with a MailEditor inside.
* @param model
* @param blockExternalContent
* @param alwaysBlockExternalContent
* @returns {Dialog}
* @private
*/
async function createMailEditorDialog(model, blockExternalContent = false, alwaysBlockExternalContent = false) {
	let dialog;
	let mailEditorAttrs;
	const save = (showProgress = true) => {
		const savePromise = model.saveDraft(true, MailMethod.NONE);
		if (showProgress) return showProgressDialog("save_msg", savePromise);
else return savePromise;
	};
	const send = async () => {
		if (model.isSharedMailbox() && model.containsExternalRecipients() && model.isConfidential()) {
			await Dialog.message("sharedMailboxCanNotSendConfidentialExternal_msg");
			return;
		}
		try {
			const success = await model.send(MailMethod.NONE, Dialog.confirm, showProgressDialog);
			if (success) {
				dispose();
				dialog.close();
				await handleRatingByEvent();
			}
		} catch (e) {
			if (e instanceof UserError) showUserError(e);
else throw e;
		}
	};
	const disposables = [];
	const dispose = () => {
		model.dispose();
		if (templatePopupModel) templatePopupModel.dispose();
		for (const disposable of disposables) disposable.dispose();
	};
	const minimize = () => {
		let saveStatus = (0, import_stream.default)({ status: SaveStatusEnum.Saving });
		if (model.hasMailChanged()) save(false).then(() => saveStatus({ status: SaveStatusEnum.Saved })).catch((e) => {
			const reason = isOfflineError(e) ? SaveErrorReason.ConnectionLost : SaveErrorReason.Unknown;
			saveStatus({
				status: SaveStatusEnum.NotSaved,
				reason
			});
			if (reason === SaveErrorReason.Unknown) if (e instanceof UserError) showUserError(e);
else throw e;
		}).finally(() => mithril_default.redraw());
else if (!model.draft) {
			dispose();
			dialog.close();
			return;
		} else saveStatus = (0, import_stream.default)({ status: SaveStatusEnum.Saved });
		showMinimizedMailEditor(dialog, model, mailLocator.minimizedMailModel, locator.eventController, dispose, saveStatus);
	};
	let windowCloseUnsubscribe = () => {};
	const headerBarAttrs = {
		left: [{
			label: "close_alt",
			click: () => minimize(),
			type: ButtonType.Secondary
		}],
		right: [{
			label: "send_action",
			click: () => {
				send();
			},
			type: ButtonType.Primary
		}],
		middle: dialogTitleTranslationKey(model.getConversationType()),
		create: () => {
			if (isBrowser()) windowCloseUnsubscribe = windowFacade.addWindowCloseListener(() => {});
else if (isDesktop()) windowCloseUnsubscribe = windowFacade.addWindowCloseListener(() => {
				minimize();
			});
		},
		remove: () => {
			windowCloseUnsubscribe();
		}
	};
	const templatePopupModel = locator.logins.isInternalUserLoggedIn() && client.isDesktopDevice() ? new TemplatePopupModel(locator.eventController, locator.logins, locator.entityClient) : null;
	const createKnowledgebaseButtonAttrs = async (editor) => {
		if (locator.logins.isInternalUserLoggedIn()) {
			const customer = await locator.logins.getUserController().loadCustomer();
			if (styles.isDesktopLayout() && templatePopupModel && locator.logins.getUserController().getTemplateMemberships().length > 0 && isCustomizationEnabledForCustomer(customer, FeatureType.KnowledgeBase)) {
				const knowledgebaseModel = new KnowledgeBaseModel(locator.eventController, locator.entityClient, locator.logins.getUserController());
				await knowledgebaseModel.init();
				disposables.push(knowledgebaseModel);
				const knowledgebaseInjection = createKnowledgeBaseDialogInjection(knowledgebaseModel, templatePopupModel, editor);
				dialog.setInjectionRight(knowledgebaseInjection);
				return knowledgebaseInjection;
			} else return null;
		} else return null;
	};
	mailEditorAttrs = createMailEditorAttrs(model, blockExternalContent, model.toRecipients().length !== 0, () => dialog, templatePopupModel, createKnowledgebaseButtonAttrs, await locator.recipientsSearchModel(), alwaysBlockExternalContent);
	const shortcuts = [
		{
			key: Keys.ESC,
			exec: () => {
				minimize();
			},
			help: "close_alt"
		},
		{
			key: Keys.S,
			ctrlOrCmd: true,
			exec: () => {
				save().catch(ofClass(UserError, showUserError));
			},
			help: "save_action"
		},
		{
			key: Keys.S,
			ctrlOrCmd: true,
			shift: true,
			exec: () => {
				send();
			},
			help: "send_action"
		},
		{
			key: Keys.RETURN,
			ctrlOrCmd: true,
			exec: () => {
				send();
			},
			help: "send_action"
		}
	];
	dialog = Dialog.editDialog(headerBarAttrs, MailEditor, mailEditorAttrs);
	dialog.setCloseHandler(() => minimize());
	for (let shortcut of shortcuts) dialog.addShortcut(shortcut);
	return dialog;
}
async function newMailEditor(mailboxDetails) {
	await checkApprovalStatus(locator.logins, false);
	const { appendEmailSignature: appendEmailSignature$1 } = await import("./Signature-BcT8dcyW.js");
	const signature = appendEmailSignature$1("", locator.logins.getUserController().props);
	const detailsProperties = await getMailboxDetailsAndProperties(mailboxDetails);
	return newMailEditorFromTemplate(detailsProperties.mailboxDetails, {}, "", signature);
}
async function getExternalContentRulesForEditor(model, currentStatus) {
	let contentRules;
	const previousMail = model.getPreviousMail();
	if (!previousMail) contentRules = {
		alwaysBlockExternalContent: false,
		blockExternalContent: false
	};
else {
		const externalImageRule = await locator.configFacade.getExternalImageRule(previousMail.sender.address).catch((e) => {
			console.log("Error getting external image rule:", e);
			return ExternalImageRule.None;
		});
		let isAuthenticatedMail;
		if (previousMail.authStatus !== null) isAuthenticatedMail = previousMail.authStatus === MailAuthenticationStatus.AUTHENTICATED;
else {
			const mailDetails = await locator.mailFacade.loadMailDetailsBlob(previousMail);
			isAuthenticatedMail = mailDetails.authStatus === MailAuthenticationStatus.AUTHENTICATED;
		}
		if (externalImageRule === ExternalImageRule.Block || externalImageRule === ExternalImageRule.None && model.isUserPreviousSender()) contentRules = {
			alwaysBlockExternalContent: externalImageRule === ExternalImageRule.Block,
			blockExternalContent: true
		};
else if (externalImageRule === ExternalImageRule.Allow && isAuthenticatedMail) contentRules = {
			alwaysBlockExternalContent: false,
			blockExternalContent: false
		};
else contentRules = {
			alwaysBlockExternalContent: false,
			blockExternalContent: currentStatus
		};
	}
	return contentRules;
}
async function newMailEditorAsResponse(args, blockExternalContent, inlineImages, mailboxDetails) {
	const detailsProperties = await getMailboxDetailsAndProperties(mailboxDetails);
	const model = await locator.sendMailModel(detailsProperties.mailboxDetails, detailsProperties.mailboxProperties);
	await model.initAsResponse(args, inlineImages);
	const externalImageRules = await getExternalContentRulesForEditor(model, blockExternalContent);
	return createMailEditorDialog(model, externalImageRules?.blockExternalContent, externalImageRules?.alwaysBlockExternalContent);
}
async function newMailEditorFromDraft(mail, mailDetails, attachments, inlineImages, blockExternalContent, mailboxDetails) {
	const detailsProperties = await getMailboxDetailsAndProperties(mailboxDetails);
	const model = await locator.sendMailModel(detailsProperties.mailboxDetails, detailsProperties.mailboxProperties);
	await model.initWithDraft(mail, mailDetails, attachments, inlineImages);
	const externalImageRules = await getExternalContentRulesForEditor(model, blockExternalContent);
	return createMailEditorDialog(model, externalImageRules?.blockExternalContent, externalImageRules?.alwaysBlockExternalContent);
}
async function newMailtoUrlMailEditor(mailtoUrl, confidential, mailboxDetails) {
	const detailsProperties = await getMailboxDetailsAndProperties(mailboxDetails);
	const mailTo = parseMailtoUrl(mailtoUrl);
	let dataFiles = [];
	if (mailTo.attach) {
		const attach = mailTo.attach;
		if (isDesktop()) {
			const files = await Promise.all(attach.map((uri) => locator.fileApp.readDataFile(uri)));
			dataFiles = files.filter(isNotNull);
		}
		const keepAttachments = dataFiles.length === 0 || await Dialog.confirm("attachmentWarning_msg", "attachFiles_action", () => dataFiles.map((df, i) => mithril_default(".text-break.selectable.mt-xs", { title: attach[i] }, df.name)));
		if (keepAttachments) {
			const sizeCheckResult = checkAttachmentSize(dataFiles);
			dataFiles = sizeCheckResult.attachableFiles;
			if (sizeCheckResult.tooBigFiles.length > 0) await Dialog.message("tooBigAttachment_msg", () => sizeCheckResult.tooBigFiles.map((file) => mithril_default(".text-break.selectable", file)));
		} else throw new CancelledError("user cancelled opening mail editor with attachments");
	}
	return newMailEditorFromTemplate(detailsProperties.mailboxDetails, mailTo.recipients, mailTo.subject || "", appendEmailSignature(mailTo.body || "", locator.logins.getUserController().props), dataFiles, confidential, undefined, true);
}
async function newMailEditorFromTemplate(mailboxDetails, recipients, subject, bodyText, attachments, confidential, senderMailAddress, initialChangedState) {
	const mailboxProperties = await locator.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot);
	return locator.sendMailModel(mailboxDetails, mailboxProperties).then((model) => model.initWithTemplate(recipients, subject, bodyText, attachments, confidential, senderMailAddress, initialChangedState)).then((model) => createMailEditorDialog(model));
}
function getSupportMailSignature() {
	return import("./CalendarUtils-DwR144gS.js").then(({ getTimeZone }) => {
		return LINE_BREAK + LINE_BREAK + "--" + `<br>Client: ${client.getIdentifier()}` + `<br>Tutanota version: ${env.versionNumber}` + `<br>Time zone: ${getTimeZone()}` + `<br>User agent:<br> ${navigator.userAgent}`;
	});
}
async function writeSupportMail(subject = "", mailboxDetails) {
	if (locator.logins.getUserController().isPremiumAccount()) {
		const detailsProperties = await getMailboxDetailsAndProperties(mailboxDetails);
		const recipients = { to: [{
			name: null,
			address: "premium@tutao.de"
		}] };
		const signature = await getSupportMailSignature();
		const dialog = await newMailEditorFromTemplate(detailsProperties.mailboxDetails, recipients, subject, signature);
		dialog.show();
		return true;
	} else return import("./PriceUtils-BW-wjJnJ.js").then(({ formatPrice }) => {
		const message = lang.get("premiumOffer_msg", { "{1}": formatPrice(1, true) });
		const title = lang.get("upgradeReminderTitle_msg");
		return Dialog.reminder(title, message);
	}).then((confirm) => {
		if (confirm) import("./UpgradeSubscriptionWizard-CBu6JZbq.js").then((utils) => utils.showUpgradeWizard(locator.logins));
	}).then(() => false);
}
async function writeInviteMail(referralLink) {
	const detailsProperties = await getMailboxDetailsAndProperties(null);
	const username = locator.logins.getUserController().userGroupInfo.name;
	const body = lang.get("invitationMailBody_msg", {
		"{registrationLink}": referralLink,
		"{username}": username
	});
	const { invitationSubject } = await locator.serviceExecutor.get(TranslationService, createTranslationGetIn({ lang: lang.code }));
	const dialog = await newMailEditorFromTemplate(detailsProperties.mailboxDetails, {}, invitationSubject, body, [], false);
	dialog.show();
}
async function writeGiftCardMail(link, mailboxDetails) {
	const detailsProperties = await getMailboxDetailsAndProperties(mailboxDetails);
	const bodyText = lang.get("defaultShareGiftCardBody_msg", {
		"{link}": "<a href=\"" + link + "\">" + link + "</a>",
		"{username}": locator.logins.getUserController().userGroupInfo.name
	}).split("\n").join("<br />");
	const { giftCardSubject } = await locator.serviceExecutor.get(TranslationService, createTranslationGetIn({ lang: lang.code }));
	locator.sendMailModel(detailsProperties.mailboxDetails, detailsProperties.mailboxProperties).then((model) => model.initWithTemplate({}, giftCardSubject, appendEmailSignature(bodyText, locator.logins.getUserController().props), [], false)).then((model) => createMailEditorDialog(model, false)).then((dialog) => dialog.show());
}
async function getMailboxDetailsAndProperties(mailboxDetails) {
	mailboxDetails = mailboxDetails ?? await locator.mailboxModel.getUserMailboxDetails();
	const mailboxProperties = await locator.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot);
	return {
		mailboxDetails,
		mailboxProperties
	};
}

//#endregion
export { CounterBadge, MailEditor, createMailEditorAttrs, getSupportMailSignature, newMailEditor, newMailEditorAsResponse, newMailEditorFromDraft, newMailEditorFromTemplate, newMailtoUrlMailEditor, writeGiftCardMail, writeInviteMail, writeSupportMail };
//# sourceMappingURL=MailEditor-Dm804Ukq.js.map