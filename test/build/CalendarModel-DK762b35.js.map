{"version":3,"file":"CalendarModel-DK762b35.js","names":["loadFunction: lazyAsync<T>","defaultValue: T","event: CalendarEvent","monitor: IProgressMonitor","notifications: Notifications","alarmScheduler: () => Promise<AlarmScheduler>","eventController: EventController","serviceExecutor: IServiceExecutor","logins: LoginController","progressTracker: ProgressTracker","entityClient: EntityClient","mailboxModel: MailboxModel","calendarFacade: CalendarFacade","fileController: FileController","zone: string","externalCalendarFacade: ExternalCalendarFacade | null","deviceConfig: DeviceConfig","pushService: NativePushServiceApp | null","alarmInfos: ReadonlyArray<AlarmInfoTemplate>","groupRoot: CalendarGroupRoot","newEvent: CalendarEvent","newAlarms: ReadonlyArray<AlarmInfoTemplate>","existingEvent: CalendarEvent","progressMonitor: IProgressMonitor","notFoundMemberships: GroupMembership[]","groupInstances: Array<[CalendarGroupRoot, GroupInfo, Group]>","calendarInfos: Map<Id, CalendarInfo>","groupSettings","url: string","groupSettings: GroupSettings[] | null","syncInterval: number","longErrorMessage: boolean","forceSync: boolean","groupRootsPromises: Promise<CalendarGroupRoot>[]","calendarGroupRootsList: CalendarGroupRoot[]","skippedCalendars: Map<Id, { calendarName: string; error: Error }>","parsedExternalEvents: ParsedEvent[]","operationsLog: {\n\t\t\t\tskipped: CalendarEvent[]\n\t\t\t\tupdated: CalendarEvent[]\n\t\t\t\tcreated: CalendarEvent[]\n\t\t\t\tdeleted: CalendarEvent[]\n\t\t\t}","a: CalendarEvent","b: CalendarEvent","name: string","color: string | null","alarms: AlarmInterval[]","sourceUrl: string | null","existingEvent?: CalendarEvent","fileId: IdTuple","update: CalendarEventUpdate","uid: string","sender: string","calendarData: ParsedCalendarData","method: string","updateEvent: Require<\"uid\", CalendarEvent>","updateAlarms: Array<AlarmInfoTemplate>","target: CalendarEventUidIndexEntry","sentByOrganizer: boolean","dbTarget: CalendarEventUidIndexEntry","dbEvent: CalendarEventInstance","updateEvent: CalendarEvent","alarms: Array<AlarmInfoTemplate>","dbEvent: CalendarEvent","icsEvent: CalendarEvent","scheduler: AlarmScheduler","alarmInfos: Array<IdTuple>","user: User","calendar: CalendarInfo","updates: ReadonlyArray<EntityUpdateData>","eventOwnerGroupId: Id","alarmEventsToProcess: UserAlarmInfo[]","elementId: string","userAlarmInfo: UserAlarmInfo","userAlarmInfoId: Id","contactName: string","age: number","message: string","userController: UserController","eventTime: Date","summary: string","dateString: string"],"sources":["../../src/common/api/common/utils/ObservableLazyLoaded.ts","../../src/calendar-app/calendar/model/CalendarModel.ts"],"sourcesContent":["import { lazyAsync, LazyLoaded } from \"@tutao/tutanota-utils\"\nimport Stream from \"mithril/stream\"\nimport stream from \"mithril/stream\"\n\nexport class ObservableLazyLoaded<T> {\n\tprivate lazyLoaded: LazyLoaded<T>\n\treadonly stream: Stream<T> = stream()\n\n\tconstructor(loadFunction: lazyAsync<T>, private readonly defaultValue: T) {\n\t\tthis.lazyLoaded = new LazyLoaded<T>(async () => {\n\t\t\tconst value = await loadFunction()\n\t\t\tthis.stream(value)\n\t\t\treturn value\n\t\t}, defaultValue)\n\n\t\tthis.stream(defaultValue)\n\t}\n\n\tgetAsync(): Promise<T> {\n\t\treturn this.lazyLoaded.getAsync()\n\t}\n\n\tisLoaded(): boolean {\n\t\treturn this.lazyLoaded.isLoaded()\n\t}\n\n\tgetLoaded(): T {\n\t\treturn this.lazyLoaded.getLoaded()\n\t}\n\n\t/** reset & reload the inner lazyLoaded without an observable default state unless loading fails */\n\tasync reload(): Promise<T> {\n\t\ttry {\n\t\t\treturn await this.lazyLoaded.reload()\n\t\t} catch (e) {\n\t\t\tthis.lazyLoaded.reset()\n\t\t\tthis.stream(this.defaultValue)\n\t\t\treturn this.defaultValue\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.lazyLoaded.reset()\n\t\tthis.stream(this.defaultValue)\n\t}\n}\n","import {\n\t$Promisable,\n\tassertNotNull,\n\tclone,\n\tdeepEqual,\n\tdefer,\n\tDeferredObject,\n\tdowncast,\n\tfilterInt,\n\tgetFromMap,\n\tisSameDay,\n\tRequire,\n\tsymmetricDifference,\n} from \"@tutao/tutanota-utils\"\nimport { CalendarMethod, EXTERNAL_CALENDAR_SYNC_INTERVAL, FeatureType, OperationType } from \"../../../common/api/common/TutanotaConstants\"\nimport { EventController } from \"../../../common/api/main/EventController\"\nimport {\n\tcreateDateWrapper,\n\tcreateMembershipRemoveData,\n\tGroup,\n\tGroupInfo,\n\tGroupInfoTypeRef,\n\tGroupMembership,\n\tGroupTypeRef,\n\tUser,\n\tUserAlarmInfo,\n\tUserAlarmInfoTypeRef,\n} from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport {\n\tCalendarEvent,\n\tCalendarEventTypeRef,\n\tCalendarEventUpdate,\n\tCalendarEventUpdateTypeRef,\n\tCalendarGroupRoot,\n\tCalendarGroupRootTypeRef,\n\tcreateDefaultAlarmInfo,\n\tcreateGroupSettings,\n\tFileTypeRef,\n\tGroupSettings,\n\tUserSettingsGroupRootTypeRef,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { isApp, isDesktop } from \"../../../common/api/common/Env\"\nimport type { LoginController } from \"../../../common/api/main/LoginController\"\nimport { LockedError, NotAuthorizedError, NotFoundError, PreconditionFailedError } from \"../../../common/api/common/error/RestError\"\nimport type { ParsedCalendarData, ParsedEvent } from \"../../../common/calendar/import/CalendarImporter.js\"\nimport { ParserError } from \"../../../common/misc/parsing/ParserCombinator\"\nimport { ProgressTracker } from \"../../../common/api/main/ProgressTracker\"\nimport type { IProgressMonitor } from \"../../../common/api/common/utils/ProgressMonitor\"\nimport { NoopProgressMonitor } from \"../../../common/api/common/utils/ProgressMonitor\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport type { MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { elementIdPart, getElementId, isSameId, listIdPart, removeTechnicalFields } from \"../../../common/api/common/utils/EntityUtils\"\nimport type { AlarmScheduler } from \"../../../common/calendar/date/AlarmScheduler.js\"\nimport { Notifications, NotificationType } from \"../../../common/gui/Notifications\"\nimport m from \"mithril\"\nimport type { CalendarEventInstance, CalendarEventProgenitor, CalendarFacade } from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport {\n\tAlarmInfoTemplate,\n\tCachingMode,\n\tCalendarEventAlteredInstance,\n\tCalendarEventUidIndexEntry,\n} from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport { IServiceExecutor } from \"../../../common/api/common/ServiceRequest\"\nimport { MembershipService } from \"../../../common/api/entities/sys/Services\"\nimport { FileController } from \"../../../common/file/FileController\"\nimport { findAttendeeInAddresses, serializeAlarmInterval } from \"../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { TutanotaError } from \"@tutao/tutanota-error\"\nimport { SessionKeyNotFoundError } from \"../../../common/api/common/error/SessionKeyNotFoundError.js\"\nimport Stream from \"mithril/stream\"\nimport { ObservableLazyLoaded } from \"../../../common/api/common/utils/ObservableLazyLoaded.js\"\nimport { UserController } from \"../../../common/api/main/UserController.js\"\nimport { formatDateWithWeekdayAndTime, formatTime } from \"../../../common/misc/Formatter.js\"\nimport { EntityUpdateData, isUpdateFor, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport {\n\tAlarmInterval,\n\tassignEventId,\n\tCalendarEventValidity,\n\tcheckEventValidity,\n\tgetTimeZone,\n\thasSourceUrl,\n} from \"../../../common/calendar/date/CalendarUtils.js\"\nimport { isSharedGroupOwner, loadGroupMembers } from \"../../../common/sharing/GroupUtils.js\"\nimport { ExternalCalendarFacade } from \"../../../common/native/common/generatedipc/ExternalCalendarFacade.js\"\nimport { DeviceConfig } from \"../../../common/misc/DeviceConfig.js\"\nimport { locator } from \"../../../common/api/main/CommonLocator.js\"\nimport { EventImportRejectionReason, parseCalendarStringData, sortOutParsedEvents, SyncStatus } from \"../../../common/calendar/import/ImportExportUtils.js\"\nimport { UserError } from \"../../../common/api/main/UserError.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel.js\"\nimport { NativePushServiceApp } from \"../../../common/native/main/NativePushServiceApp.js\"\n\nconst TAG = \"[CalendarModel]\"\nexport type CalendarInfo = {\n\tgroupRoot: CalendarGroupRoot\n\tgroupInfo: GroupInfo\n\tgroup: Group\n\tshared: boolean\n\tuserIsOwner: boolean\n\tisExternal: boolean\n}\n\nexport function assertEventValidity(event: CalendarEvent) {\n\tswitch (checkEventValidity(event)) {\n\t\tcase CalendarEventValidity.InvalidContainsInvalidDate:\n\t\t\tthrow new UserError(\"invalidDate_msg\")\n\t\tcase CalendarEventValidity.InvalidEndBeforeStart:\n\t\t\tthrow new UserError(\"startAfterEnd_label\")\n\t\tcase CalendarEventValidity.InvalidPre1970:\n\t\t\t// shouldn't happen while the check in setStartDate is still there, resetting the date each time\n\t\t\tthrow new UserError(\"pre1970Start_msg\")\n\t\tcase CalendarEventValidity.Valid:\n\t\t// event is valid, nothing to do\n\t}\n}\n\nexport class CalendarModel {\n\t/**\n\t * Map from calendar event element id to the deferred object with a promise of getting CREATE event for this calendar event. We need to do that because\n\t * entity updates for CalendarEvent and UserAlarmInfo come in different batches and we need to wait for the event when we want to process new alarm.\n\t *\n\t * We use the counter to remove the pending request from map when all alarms are processed. We want to do that in case the event gets updated and we need\n\t * to wait for the new version of the event.\n\t */\n\tprivate pendingAlarmRequests: Map<\n\t\tstring,\n\t\t{\n\t\t\tpendingAlarmCounter: number\n\t\t\tdeferred: DeferredObject<void>\n\t\t}\n\t> = new Map()\n\tprivate readonly userAlarmToAlarmInfo: Map<string, string> = new Map()\n\tprivate readonly fileIdToSkippedCalendarEventUpdates: Map<Id, CalendarEventUpdate> = new Map()\n\n\tprivate readProgressMonitor: Generator<IProgressMonitor>\n\n\t/**\n\t * Map from group id to CalendarInfo\n\t */\n\tprivate readonly calendarInfos = new ObservableLazyLoaded<ReadonlyMap<Id, CalendarInfo>>(() => {\n\t\tconst monitor: IProgressMonitor = this.readProgressMonitor.next().value\n\t\tconst calendarInfoPromise = this.loadOrCreateCalendarInfo(monitor)\n\t\tmonitor.completed()\n\t\treturn calendarInfoPromise\n\t}, new Map())\n\n\tconstructor(\n\t\tprivate readonly notifications: Notifications,\n\t\tprivate readonly alarmScheduler: () => Promise<AlarmScheduler>,\n\t\teventController: EventController,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly progressTracker: ProgressTracker,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly mailboxModel: MailboxModel,\n\t\tprivate readonly calendarFacade: CalendarFacade,\n\t\tprivate readonly fileController: FileController,\n\t\tprivate readonly zone: string,\n\t\tprivate readonly externalCalendarFacade: ExternalCalendarFacade | null,\n\t\tprivate readonly deviceConfig: DeviceConfig,\n\t\tprivate readonly pushService: NativePushServiceApp | null,\n\t) {\n\t\tthis.readProgressMonitor = oneShotProgressMonitorGenerator(progressTracker, logins.getUserController())\n\t\teventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId))\n\t}\n\n\tgetCalendarInfos(): Promise<ReadonlyMap<Id, CalendarInfo>> {\n\t\treturn this.calendarInfos.getAsync()\n\t}\n\n\tgetCalendarInfosStream(): Stream<ReadonlyMap<Id, CalendarInfo>> {\n\t\treturn this.calendarInfos.stream\n\t}\n\n\tasync createEvent(event: CalendarEvent, alarmInfos: ReadonlyArray<AlarmInfoTemplate>, zone: string, groupRoot: CalendarGroupRoot): Promise<void> {\n\t\tawait this.doCreate(event, zone, groupRoot, alarmInfos)\n\t}\n\n\t/** Update existing event when time did not change */\n\tasync updateEvent(\n\t\tnewEvent: CalendarEvent,\n\t\tnewAlarms: ReadonlyArray<AlarmInfoTemplate>,\n\t\tzone: string,\n\t\tgroupRoot: CalendarGroupRoot,\n\t\texistingEvent: CalendarEvent,\n\t): Promise<CalendarEvent> {\n\t\tif (existingEvent._id == null) {\n\t\t\tthrow new Error(\"Invalid existing event for update: no id\")\n\t\t}\n\n\t\tif (existingEvent.uid != null && newEvent.uid !== existingEvent.uid) {\n\t\t\tthrow new Error(\"Invalid existing event for update: mismatched uids.\")\n\t\t}\n\n\t\t// in cases where start time or calendar changed, we need to change the event id and so need to delete/recreate.\n\t\t// it's also possible that the event has to be moved from the long event list to the short event list or vice versa.\n\t\tif (\n\t\t\texistingEvent._ownerGroup !== groupRoot._id ||\n\t\t\tnewEvent.startTime.getTime() !== existingEvent.startTime.getTime() ||\n\t\t\t(await didLongStateChange(newEvent, existingEvent, zone))\n\t\t) {\n\t\t\t// We should reload the instance here because session key and permissions are updated when we recreate event.\n\t\t\tawait this.doCreate(newEvent, zone, groupRoot, newAlarms, existingEvent)\n\t\t\treturn await this.entityClient.load<CalendarEvent>(CalendarEventTypeRef, newEvent._id)\n\t\t} else {\n\t\t\tnewEvent._ownerGroup = groupRoot._id\n\t\t\t// We can't load updated event here because cache is not updated yet. We also shouldn't need to load it, we have the latest\n\t\t\t// version\n\t\t\tawait this.calendarFacade.updateCalendarEvent(newEvent, newAlarms, existingEvent)\n\t\t\treturn newEvent\n\t\t}\n\t}\n\n\t/** Load map from group/groupRoot ID to the calendar info */\n\tprivate async loadCalendarInfos(progressMonitor: IProgressMonitor): Promise<ReadonlyMap<Id, CalendarInfo>> {\n\t\tconst userController = this.logins.getUserController()\n\n\t\tconst notFoundMemberships: GroupMembership[] = []\n\t\tconst groupInstances: Array<[CalendarGroupRoot, GroupInfo, Group]> = []\n\t\tfor (const membership of userController.getCalendarMemberships()) {\n\t\t\ttry {\n\t\t\t\tconst result = await Promise.all([\n\t\t\t\t\tthis.entityClient.load(CalendarGroupRootTypeRef, membership.group),\n\t\t\t\t\tthis.entityClient.load(GroupInfoTypeRef, membership.groupInfo),\n\t\t\t\t\tthis.entityClient.load(GroupTypeRef, membership.group),\n\t\t\t\t])\n\t\t\t\tgroupInstances.push(result)\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\tnotFoundMemberships.push(membership)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t\tprogressMonitor.workDone(3)\n\t\t}\n\n\t\tconst calendarInfos: Map<Id, CalendarInfo> = new Map()\n\t\tconst groupSettings = userController.userSettingsGroupRoot.groupSettings\n\t\tfor (const [groupRoot, groupInfo, group] of groupInstances) {\n\t\t\ttry {\n\t\t\t\tconst groupMembers = await loadGroupMembers(group, this.entityClient)\n\t\t\t\tconst shared = groupMembers.length > 1\n\t\t\t\tconst userIsOwner = !shared || isSharedGroupOwner(group, userController.userId)\n\t\t\t\tconst isExternal = hasSourceUrl(groupSettings.find((groupSettings) => groupSettings.group === group._id))\n\t\t\t\tcalendarInfos.set(groupRoot._id, {\n\t\t\t\t\tgroupRoot,\n\t\t\t\t\tgroupInfo,\n\t\t\t\t\tgroup: group,\n\t\t\t\t\tshared,\n\t\t\t\t\tuserIsOwner,\n\t\t\t\t\tisExternal,\n\t\t\t\t})\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\t\tconsole.log(\"NotAuthorizedError when initializing calendar. Calendar has been removed \")\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// cleanup inconsistent memberships\n\t\tfor (const membership of notFoundMemberships) {\n\t\t\t// noinspection ES6MissingAwait\n\t\t\tthis.serviceExecutor\n\t\t\t\t.delete(\n\t\t\t\t\tMembershipService,\n\t\t\t\t\tcreateMembershipRemoveData({\n\t\t\t\t\t\tuser: userController.userId,\n\t\t\t\t\t\tgroup: membership.group,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.catch((e) => console.log(\"error cleaning up membership for group: \", membership.group))\n\t\t}\n\t\treturn calendarInfos\n\t}\n\n\tpublic async fetchExternalCalendar(url: string): Promise<string> {\n\t\tif (!this.externalCalendarFacade) throw new Error(`externalCalendarFacade is ${typeof this.externalCalendarFacade} at CalendarModel`)\n\t\tconst calendarStr = await this.externalCalendarFacade?.fetchExternalCalendar(url)\n\t\treturn calendarStr ?? \"\"\n\t}\n\n\tpublic scheduleExternalCalendarSync() {\n\t\tsetInterval(() => {\n\t\t\tthis.syncExternalCalendars().catch((e) => console.error(e.message))\n\t\t}, EXTERNAL_CALENDAR_SYNC_INTERVAL)\n\t}\n\n\tpublic async syncExternalCalendars(\n\t\tgroupSettings: GroupSettings[] | null = null,\n\t\tsyncInterval: number = EXTERNAL_CALENDAR_SYNC_INTERVAL,\n\t\tlongErrorMessage: boolean = false,\n\t\tforceSync: boolean = false,\n\t) {\n\t\tif (!this.externalCalendarFacade || !locator.logins.isFullyLoggedIn()) {\n\t\t\treturn\n\t\t}\n\n\t\tlet existingGroupSettings = groupSettings\n\t\tconst userController = this.logins.getUserController()\n\n\t\tconst groupRootsPromises: Promise<CalendarGroupRoot>[] = []\n\t\tlet calendarGroupRootsList: CalendarGroupRoot[] = []\n\t\tfor (const membership of userController.getCalendarMemberships()) {\n\t\t\tgroupRootsPromises.push(this.entityClient.load(CalendarGroupRootTypeRef, membership.group))\n\t\t}\n\t\tcalendarGroupRootsList = await Promise.all(groupRootsPromises)\n\n\t\tif (!existingGroupSettings) {\n\t\t\tconst { groupSettings: gSettings } = await locator.entityClient.load(UserSettingsGroupRootTypeRef, userController.user.userGroup.group)\n\t\t\texistingGroupSettings = gSettings\n\t\t}\n\n\t\tconst skippedCalendars: Map<Id, { calendarName: string; error: Error }> = new Map()\n\t\tfor (const { sourceUrl, group, name } of existingGroupSettings) {\n\t\t\tif (!sourceUrl) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst lastSyncEntry = this.deviceConfig.getLastExternalCalendarSync().get(group)\n\t\t\tconst offset = 1000 // Add an offset to account for cpu speed when storing or generating timestamps\n\t\t\tconst shouldSkipSync =\n\t\t\t\t!forceSync &&\n\t\t\t\tlastSyncEntry?.lastSyncStatus === SyncStatus.Success &&\n\t\t\t\tlastSyncEntry.lastSuccessfulSync &&\n\t\t\t\tDate.now() + offset - lastSyncEntry.lastSuccessfulSync < syncInterval\n\t\t\tif (shouldSkipSync) continue\n\n\t\t\tconst currentCalendarGroupRoot = calendarGroupRootsList.find((calendarGroupRoot) => isSameId(calendarGroupRoot._id, group)) ?? null\n\t\t\tif (!currentCalendarGroupRoot) {\n\t\t\t\tconsole.error(`Trying to sync a calendar the user isn't subscribed to anymore: ${group}`)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlet parsedExternalEvents: ParsedEvent[] = []\n\t\t\ttry {\n\t\t\t\tconst externalCalendar = await this.fetchExternalCalendar(sourceUrl)\n\t\t\t\tparsedExternalEvents = parseCalendarStringData(externalCalendar, getTimeZone()).contents\n\t\t\t} catch (error) {\n\t\t\t\tlet calendarName = name\n\t\t\t\tif (!calendarName) {\n\t\t\t\t\tconst calendars = await this.getCalendarInfos()\n\t\t\t\t\tcalendarName = calendars.get(group)?.groupInfo.name!\n\t\t\t\t}\n\t\t\t\tskippedCalendars.set(group, { calendarName, error })\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst existingEventList = await loadAllEvents(currentCalendarGroupRoot)\n\n\t\t\tconst operationsLog: {\n\t\t\t\tskipped: CalendarEvent[]\n\t\t\t\tupdated: CalendarEvent[]\n\t\t\t\tcreated: CalendarEvent[]\n\t\t\t\tdeleted: CalendarEvent[]\n\t\t\t} = {\n\t\t\t\tskipped: [],\n\t\t\t\tupdated: [],\n\t\t\t\tcreated: [],\n\t\t\t\tdeleted: [],\n\t\t\t}\n\t\t\t/**\n\t\t\t * Sync strategy\n\t\t\t * - Replace duplicates\n\t\t\t * - Add new\n\t\t\t * - Remove rest\n\t\t\t */\n\t\t\tconst { rejectedEvents, eventsForCreation } = sortOutParsedEvents(parsedExternalEvents, existingEventList, currentCalendarGroupRoot, getTimeZone())\n\t\t\tconst duplicates = rejectedEvents.get(EventImportRejectionReason.Duplicate) ?? []\n\n\t\t\t// Replacing duplicates with changes\n\t\t\tfor (const duplicatedEvent of duplicates) {\n\t\t\t\tconst existingEvent = existingEventList.find((event) => event.uid === duplicatedEvent.uid)\n\t\t\t\tif (!existingEvent) {\n\t\t\t\t\tconsole.warn(\"Found a duplicate without an existing event!\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif (this.eventHasSameFields(duplicatedEvent, existingEvent)) {\n\t\t\t\t\toperationsLog.skipped.push(duplicatedEvent)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tawait this.updateEventWithExternal(existingEvent, duplicatedEvent)\n\t\t\t\toperationsLog.updated.push(duplicatedEvent)\n\t\t\t}\n\t\t\tconsole.log(TAG, `${operationsLog.skipped.length} events skipped (duplication without changes)`)\n\t\t\tconsole.log(TAG, `${operationsLog.updated.length} events updated (duplication with changes)`)\n\n\t\t\t// Add new event\n\t\t\tfor (const { event } of eventsForCreation) {\n\t\t\t\tassignEventId(event, getTimeZone(), currentCalendarGroupRoot)\n\t\t\t\t// Reset ownerEncSessionKey because it cannot be set for new entity, it will be assigned by the CryptoFacade\n\t\t\t\tevent._ownerEncSessionKey = null\n\n\t\t\t\tif (event.repeatRule != null) {\n\t\t\t\t\tevent.repeatRule.excludedDates = event.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date }))\n\t\t\t\t}\n\t\t\t\t// Reset permissions because server will assign them\n\t\t\t\tdowncast(event)._permissions = null\n\t\t\t\tevent._ownerGroup = currentCalendarGroupRoot._id\n\t\t\t\tassertEventValidity(event)\n\t\t\t\toperationsLog.created.push(event)\n\t\t\t}\n\t\t\tawait this.calendarFacade.saveImportedCalendarEvents(eventsForCreation, 0)\n\t\t\tconsole.log(TAG, `${operationsLog.created.length} events created`)\n\n\t\t\t// Remove rest\n\t\t\tconst eventsToRemove = existingEventList.filter(\n\t\t\t\t(existingEvent) => !parsedExternalEvents.some((externalEvent) => externalEvent.event.uid === existingEvent.uid),\n\t\t\t)\n\t\t\tfor (const event of eventsToRemove) {\n\t\t\t\tawait this.deleteEvent(event).catch((err) => {\n\t\t\t\t\tif (err instanceof NotFoundError) {\n\t\t\t\t\t\treturn console.log(`Already deleted event`, event)\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow err\n\t\t\t\t})\n\t\t\t\toperationsLog.deleted.push(event)\n\t\t\t}\n\t\t\tconsole.log(TAG, `${operationsLog.deleted.length} events removed`)\n\n\t\t\tthis.deviceConfig.updateLastSync(group)\n\t\t}\n\n\t\tif (skippedCalendars.size) {\n\t\t\tlet errorMessage = lang.get(\"iCalSync_error\") + (longErrorMessage ? \"\\n\\n\" : \"\")\n\t\t\tfor (const [group, details] of skippedCalendars.entries()) {\n\t\t\t\tif (longErrorMessage) errorMessage += `${details.calendarName} - ${details.error.message}\\n`\n\t\t\t\tthis.deviceConfig.updateLastSync(group, SyncStatus.Failed)\n\t\t\t}\n\t\t\tthrow new Error(errorMessage)\n\t\t}\n\t}\n\n\tprivate eventHasSameFields(a: CalendarEvent, b: CalendarEvent) {\n\t\treturn (\n\t\t\ta.startTime.valueOf() === b.startTime.valueOf() &&\n\t\t\ta.endTime.valueOf() === b.endTime.valueOf() &&\n\t\t\tdeepEqual({ ...a.attendees }, { ...b.attendees }) &&\n\t\t\ta.summary === b.summary &&\n\t\t\ta.sequence === b.sequence &&\n\t\t\ta.location === b.location &&\n\t\t\ta.description === b.description &&\n\t\t\tdeepEqual(a.organizer, b.organizer) &&\n\t\t\tdeepEqual(a.repeatRule, b.repeatRule) &&\n\t\t\ta.recurrenceId?.valueOf() === b.recurrenceId?.valueOf()\n\t\t)\n\t}\n\n\tprivate async loadOrCreateCalendarInfo(progressMonitor: IProgressMonitor): Promise<ReadonlyMap<Id, CalendarInfo>> {\n\t\tconst { findFirstPrivateCalendar } = await import(\"../../../common/calendar/date/CalendarUtils.js\")\n\t\tconst calendarInfos = await this.loadCalendarInfos(progressMonitor)\n\n\t\tif (!this.logins.isInternalUserLoggedIn() || findFirstPrivateCalendar(calendarInfos)) {\n\t\t\treturn calendarInfos\n\t\t} else {\n\t\t\tawait this.createCalendar(\"\", null, [], null)\n\t\t\treturn await this.loadCalendarInfos(progressMonitor)\n\t\t}\n\t}\n\n\tasync createCalendar(name: string, color: string | null, alarms: AlarmInterval[], sourceUrl: string | null): Promise<Group> {\n\t\t// when a calendar group is added, a group membership is added to the user. we might miss this websocket event\n\t\t// during startup if the websocket is not connected fast enough. Therefore, we explicitly update the user\n\t\t// this should be removed once we handle missed events during startup\n\t\tconst { user, group } = await this.calendarFacade.addCalendar(name)\n\t\tthis.logins.getUserController().user = user\n\n\t\tconst serializedAlarms = alarms.map((alarm) => createDefaultAlarmInfo({ trigger: serializeAlarmInterval(alarm) }))\n\t\tif (color != null) {\n\t\t\tconst { userSettingsGroupRoot } = this.logins.getUserController()\n\t\t\tconst newGroupSettings = createGroupSettings({\n\t\t\t\tgroup: group._id,\n\t\t\t\tcolor: color,\n\t\t\t\tname: null,\n\t\t\t\tdefaultAlarmsList: serializedAlarms,\n\t\t\t\tsourceUrl,\n\t\t\t})\n\n\t\t\tuserSettingsGroupRoot.groupSettings.push(newGroupSettings)\n\t\t\tawait this.entityClient.update(userSettingsGroupRoot)\n\t\t}\n\n\t\treturn group\n\t}\n\n\tprivate async doCreate(\n\t\tevent: CalendarEvent,\n\t\tzone: string,\n\t\tgroupRoot: CalendarGroupRoot,\n\t\talarmInfos: ReadonlyArray<AlarmInfoTemplate>,\n\t\texistingEvent?: CalendarEvent,\n\t): Promise<void> {\n\t\t// If the event was copied it might still carry some fields for re-encryption. We can't reuse them.\n\t\tremoveTechnicalFields(event)\n\t\tconst { assignEventId } = await import(\"../../../common/calendar/date/CalendarUtils\")\n\t\t// if values of the existing events have changed that influence the alarm time then delete the old event and create a new\n\t\t// one.\n\t\tassignEventId(event, zone, groupRoot)\n\t\t// Reset ownerEncSessionKey because it cannot be set for new entity, it will be assigned by the CryptoFacade\n\t\tevent._ownerEncSessionKey = null\n\t\tif (event.repeatRule != null) {\n\t\t\tevent.repeatRule.excludedDates = event.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date }))\n\t\t}\n\t\t// Reset permissions because server will assign them\n\t\tdowncast(event)._permissions = null\n\t\tevent._ownerGroup = groupRoot._id\n\t\treturn await this.calendarFacade.saveCalendarEvent(event, alarmInfos, existingEvent ?? null)\n\t}\n\n\tasync deleteEvent(event: CalendarEvent): Promise<void> {\n\t\treturn await this.entityClient.erase(event)\n\t}\n\n\t/**\n\t * get the \"primary\" event of a series - the one that contains the repeat rule and is not a repeated or a rescheduled instance.\n\t *\n\t * note about recurrenceId in event series https://stackoverflow.com/questions/11456406/recurrence-id-in-icalendar-rfc-5545\n\t */\n\tasync resolveCalendarEventProgenitor({ uid }: Pick<CalendarEvent, \"uid\">): Promise<CalendarEvent | null> {\n\t\treturn (await this.getEventsByUid(assertNotNull(uid, \"could not resolve progenitor: no uid\")))?.progenitor ?? null\n\t}\n\n\tprivate async loadAndProcessCalendarUpdates(): Promise<void> {\n\t\tconst { mailboxGroupRoot } = await this.mailboxModel.getUserMailboxDetails()\n\t\tconst { calendarEventUpdates } = mailboxGroupRoot\n\t\tif (calendarEventUpdates == null) return\n\n\t\tconst invites = await this.entityClient.loadAll(CalendarEventUpdateTypeRef, calendarEventUpdates.list)\n\t\tfor (const invite of invites) {\n\t\t\tawait this.handleCalendarEventUpdate(invite)\n\t\t}\n\t}\n\n\t/**\n\t * Get calendar infos, creating a new calendar info if none exist\n\t * Not async because we want to return the result directly if it is available when called\n\t * otherwise we return a promise\n\t */\n\tgetCalendarInfosCreateIfNeeded(): $Promisable<ReadonlyMap<Id, CalendarInfo>> {\n\t\tif (this.calendarInfos.isLoaded() && this.calendarInfos.getLoaded().size > 0) {\n\t\t\treturn this.calendarInfos.getLoaded()\n\t\t}\n\n\t\treturn Promise.resolve().then(async () => {\n\t\t\tconst calendars = await this.calendarInfos.getAsync()\n\n\t\t\tif (calendars.size > 0) {\n\t\t\t\treturn calendars\n\t\t\t} else {\n\t\t\t\tawait this.createCalendar(\"\", null, [], null)\n\t\t\t\treturn this.calendarInfos.reload()\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate async getCalendarDataForUpdate(fileId: IdTuple): Promise<ParsedCalendarData | null> {\n\t\ttry {\n\t\t\t// We are not supposed to load files without the key provider, but we hope that the key\n\t\t\t// was already resolved and the entity updated.\n\t\t\tconst file = await this.entityClient.load(FileTypeRef, fileId)\n\t\t\tconst dataFile = await this.fileController.getAsDataFile(file)\n\t\t\tconst { parseCalendarFile } = await import(\"../../../common/calendar/import/CalendarImporter.js\")\n\t\t\treturn await parseCalendarFile(dataFile)\n\t\t} catch (e) {\n\t\t\tif (e instanceof SessionKeyNotFoundError) {\n\t\t\t\t// owner enc session key not updated yet - see NoOwnerEncSessionKeyForCalendarEventError's comment\n\t\t\t\tthrow new NoOwnerEncSessionKeyForCalendarEventError(\"no owner enc session key found on the calendar data's file\")\n\t\t\t}\n\t\t\tif (e instanceof ParserError || e instanceof NotFoundError) {\n\t\t\t\tconsole.warn(TAG, \"could not get calendar update data\", e)\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tprivate async handleCalendarEventUpdate(update: CalendarEventUpdate): Promise<void> {\n\t\t// we want to delete the CalendarEventUpdate after we are done, even, in some cases, if something went wrong.\n\t\ttry {\n\t\t\tconst parsedCalendarData = await this.getCalendarDataForUpdate(update.file)\n\t\t\tif (parsedCalendarData != null) {\n\t\t\t\tawait this.processCalendarData(update.sender, parsedCalendarData)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\t// we might be authorized in the near future if some permission is delayed, unlikely to be permanent.\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: not authorized\", e)\n\t\t\t\treturn\n\t\t\t} else if (e instanceof PreconditionFailedError) {\n\t\t\t\t// unclear where precon would be thrown, probably in the blob store?\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: precondition failed\", e)\n\t\t\t\treturn\n\t\t\t} else if (e instanceof LockedError) {\n\t\t\t\t// we can try again after the lock is released\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: locked\", e)\n\t\t\t\treturn\n\t\t\t} else if (e instanceof NotFoundError) {\n\t\t\t\t// either the updated event(s) or the file data could not be found,\n\t\t\t\t// so we should try to delete since the update itself is obsolete.\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: not found\", e)\n\t\t\t} else if (e instanceof NoOwnerEncSessionKeyForCalendarEventError) {\n\t\t\t\t// we will get an update with the mail and sk soon, then we'll be able to finish this.\n\t\t\t\t// we will re-enter this function and erase it then.\n\t\t\t\tthis.fileIdToSkippedCalendarEventUpdates.set(elementIdPart(update.file), update)\n\t\t\t\tconsole.warn(TAG, `could not process calendar update: ${e.message}`, e)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\t// unknown error that may lead to permanently stuck update if not cleared\n\t\t\t\t// this includes CryptoErrors due to #5753 that we want to still monitor\n\t\t\t\t// but now they only occur once\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update:\", e)\n\t\t\t\tawait this.eraseUpdate(update)\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tawait this.eraseUpdate(update)\n\t}\n\n\t/**\n\t * try to delete a calendar update from the server, ignoring errors\n\t * @param update the update to erase\n\t * @private\n\t */\n\tprivate async eraseUpdate(update: CalendarEventUpdate): Promise<void> {\n\t\ttry {\n\t\t\tawait this.entityClient.erase(update)\n\t\t} catch (e) {\n\t\t\tconsole.log(TAG, \"failed to delete update:\", e.name)\n\t\t}\n\t}\n\n\t/** whether the operation could be performed or not */\n\tasync deleteEventsByUid(uid: string): Promise<void> {\n\t\tconst entry = await this.calendarFacade.getEventsByUid(uid)\n\t\tif (entry == null) {\n\t\t\tconsole.log(\"could not find an uid index entry to delete event\")\n\t\t\treturn\n\t\t}\n\t\t// not doing this in parallel because we would get locked errors\n\t\tfor (const e of entry.alteredInstances) {\n\t\t\tawait this.deleteEvent(e)\n\t\t}\n\t\tif (entry.progenitor) {\n\t\t\tawait this.deleteEvent(entry.progenitor)\n\t\t}\n\t}\n\n\t/** process a calendar update retrieved from the server automatically. will not apply updates to event series that do not\n\t *  exist on the server yet (that's being done by calling processCalendarEventMessage manually)\n\t * public for testing */\n\tasync processCalendarData(sender: string, calendarData: ParsedCalendarData): Promise<void> {\n\t\tif (calendarData.contents.length === 0) {\n\t\t\tconsole.log(TAG, `Calendar update with no events, ignoring`)\n\t\t\treturn\n\t\t}\n\n\t\tif (calendarData.contents[0].event.uid == null) {\n\t\t\tconsole.log(TAG, \"invalid event update without UID, ignoring.\")\n\t\t\treturn\n\t\t}\n\n\t\t// we can have multiple cases here:\n\t\t// 1. calendarData has one event and it's the progenitor\n\t\t// 2. calendarData has one event and it's an altered occurrence\n\t\t// 3. it's both (thunderbird sends ical files with multiple events)\n\n\t\t// Load the events bypassing the cache because we might have already processed some updates and they might have changed the events we are about to load.\n\t\t// We want to operate on the latest events only, otherwise we might lose some data.\n\t\tconst dbEvents = await this.calendarFacade.getEventsByUid(calendarData.contents[0].event.uid, CachingMode.Bypass)\n\n\t\tif (dbEvents == null) {\n\t\t\t// if we ever want to display event invites in the calendar before accepting them,\n\t\t\t// we probably need to do something else here.\n\t\t\tconsole.log(TAG, \"received event update for event that has not been saved to the server, ignoring.\")\n\t\t\treturn\n\t\t}\n\t\tconst method = calendarData.method\n\t\tfor (const content of calendarData.contents) {\n\t\t\tconst updateAlarms = content.alarms\n\t\t\tconst updateEvent = content.event\n\t\t\t// this automatically applies REQUESTs for creating parts of the existing event series that do not exist yet\n\t\t\t// like accepting another altered instance invite or accepting the progenitor after accepting only an altered instance.\n\t\t\tawait this.processCalendarEventMessage(sender, method, updateEvent, updateAlarms, dbEvents)\n\t\t}\n\t}\n\n\t/**\n\t * Processing calendar update - bring events in calendar up-to-date with ical data sent via email.\n\t * calendar data are currently processed for\n\t * - REQUEST: here we have two cases:\n\t *     - there is an existing event: we apply the update to that event and do the necessary changes to the other parts of the series that may already exist\n\t *     - there is no existing event: create the event as received, and do the necessary changes to the other parts of the series that may already exist\n\t * - REPLY: update attendee status,\n\t * - CANCEL: we delete existing event instance\n\t *\n\t * @param sender\n\t * @param method\n\t * @param updateEvent the actual instance that needs to be updated\n\t * @param updateAlarms\n\t * @param target either the existing event to update or the calendar group Id to create the event in in case of a new event.\n\t */\n\tasync processCalendarEventMessage(\n\t\tsender: string,\n\t\tmethod: string,\n\t\tupdateEvent: Require<\"uid\", CalendarEvent>,\n\t\tupdateAlarms: Array<AlarmInfoTemplate>,\n\t\ttarget: CalendarEventUidIndexEntry,\n\t): Promise<void> {\n\t\tconst updateEventTime = updateEvent.recurrenceId?.getTime()\n\t\tconst targetDbEvent = updateEventTime == null ? target.progenitor : target.alteredInstances.find((e) => e.recurrenceId.getTime() === updateEventTime)\n\t\tif (targetDbEvent == null) {\n\t\t\tif (method === CalendarMethod.REQUEST) {\n\t\t\t\t// we got a REQUEST for which we do not have a saved version of the particular instance (progenitor or altered)\n\t\t\t\t// it may be\n\t\t\t\t// - a single-instance update that created this altered instance\n\t\t\t\t// - the user got the progenitor invite for a series. it's possible that there's\n\t\t\t\t//   already altered instances of this series on the server.\n\t\t\t\treturn await this.processCalendarAccept(target, updateEvent, updateAlarms)\n\t\t\t} else if (target.progenitor?.repeatRule != null && updateEvent.recurrenceId != null && method === CalendarMethod.CANCEL) {\n\t\t\t\t// some calendaring apps send a cancellation for an altered instance with a RECURRENCE-ID when\n\t\t\t\t// users delete a single instance from a series even though that instance was never published as altered.\n\t\t\t\t// we can just add the exclusion to the progenitor. this would be another argument for marking\n\t\t\t\t// altered-instance-exclusions in some way distinct from \"normal\" exclusions\n\t\t\t\ttarget.alteredInstances.push(updateEvent as CalendarEventAlteredInstance)\n\t\t\t\t// this will now modify the progenitor to have the required exclusions\n\t\t\t\treturn await this.processCalendarUpdate(target, target.progenitor, target.progenitor)\n\t\t\t} else {\n\t\t\t\tconsole.log(TAG, `got something that's not a REQUEST for nonexistent server event on uid:`, method)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tconst sentByOrganizer: boolean = targetDbEvent.organizer != null && targetDbEvent.organizer.address === sender\n\t\tif (method === CalendarMethod.REPLY) {\n\t\t\treturn this.processCalendarReply(sender, targetDbEvent, updateEvent)\n\t\t} else if (sentByOrganizer && method === CalendarMethod.REQUEST) {\n\t\t\treturn await this.processCalendarUpdate(target, targetDbEvent, updateEvent)\n\t\t} else if (sentByOrganizer && method === CalendarMethod.CANCEL) {\n\t\t\treturn await this.processCalendarCancellation(targetDbEvent)\n\t\t} else {\n\t\t\tconsole.log(TAG, `${method} update sent not by organizer, ignoring.`)\n\t\t}\n\t}\n\n\t/** process either a request for an existing progenitor or an existing altered instance.\n\t * @param dbTarget the uid entry containing the other events that are known to us that belong to this event series.\n\t * @param dbEvent the version of updateEvent stored on the server. must be identical to dbTarget.progenitor or one of dbTarget.alteredInstances\n\t * @param updateEvent the event that contains the new version of dbEvent. */\n\tprivate async processCalendarUpdate(dbTarget: CalendarEventUidIndexEntry, dbEvent: CalendarEventInstance, updateEvent: CalendarEvent): Promise<void> {\n\t\tconsole.log(TAG, \"processing request for existing event instance\")\n\t\tconst { repeatRuleWithExcludedAlteredInstances } = await import(\"../gui/eventeditor-model/CalendarEventWhenModel.js\")\n\t\t// some providers do not increment the sequence for all edit operations (like google when changing the summary)\n\t\t// we'd rather apply the same update too often than miss some, and this enables us to update our own status easily\n\t\t// without having to increment the sequence.\n\t\tif (filterInt(dbEvent.sequence) > filterInt(updateEvent.sequence)) {\n\t\t\tconsole.log(TAG, \"got update for outdated event version, ignoring.\")\n\t\t\treturn\n\t\t}\n\t\tif (updateEvent.recurrenceId == null && updateEvent.repeatRule != null) {\n\t\t\t// the update is for a repeating progenitor. we need to exclude all known altered instances from its repeat rule.\n\t\t\tupdateEvent.repeatRule = repeatRuleWithExcludedAlteredInstances(\n\t\t\t\tupdateEvent,\n\t\t\t\tdbTarget.alteredInstances.map((r) => r.recurrenceId),\n\t\t\t\tthis.zone,\n\t\t\t)\n\t\t}\n\t\t// If the update is for the altered occurrence, we do not need to update the progenitor, it already has the exclusion.\n\t\t// If we get into this function we already have the altered occurrence in db.\n\n\t\t// write the progenitor back to the uid index entry so that the subsequent updates from the same file get the updated instance\n\t\tdbTarget.progenitor = (await this.updateEventWithExternal(dbEvent, updateEvent)) as CalendarEventProgenitor\n\t}\n\n\t/**\n\t * do not call this for anything but a REQUEST\n\t * @param dbTarget the progenitor that must have a repeat rule and an exclusion for this event to be accepted, the known altered instances and the ownergroup.\n\t * @param updateEvent the event to create\n\t * @param alarms alarms to set up for this user/event\n\t */\n\tprivate async processCalendarAccept(\n\t\tdbTarget: CalendarEventUidIndexEntry,\n\t\tupdateEvent: Require<\"uid\", CalendarEvent>,\n\t\talarms: Array<AlarmInfoTemplate>,\n\t): Promise<void> {\n\t\tconsole.log(TAG, \"processing new instance request\")\n\t\tconst { repeatRuleWithExcludedAlteredInstances } = await import(\"../gui/eventeditor-model/CalendarEventWhenModel.js\")\n\t\tif (updateEvent.recurrenceId != null && dbTarget.progenitor != null && dbTarget.progenitor.repeatRule != null) {\n\t\t\t// request for a new altered instance. we'll try adding the exclusion for this instance to the progenitor if possible\n\t\t\t// since not all calendar apps add altered instances to the list of exclusions.\n\t\t\tconst updatedProgenitor = clone(dbTarget.progenitor)\n\t\t\tupdatedProgenitor.repeatRule = repeatRuleWithExcludedAlteredInstances(updatedProgenitor, [updateEvent.recurrenceId], this.zone)\n\t\t\tdbTarget.progenitor = (await this.doUpdateEvent(dbTarget.progenitor, updatedProgenitor)) as CalendarEventProgenitor\n\t\t} else if (updateEvent.recurrenceId == null && updateEvent.repeatRule != null && dbTarget.alteredInstances.length > 0) {\n\t\t\t// request to add the progenitor to the calendar. we have to exclude all altered instances that are known to us from it.\n\t\t\tupdateEvent.repeatRule = repeatRuleWithExcludedAlteredInstances(\n\t\t\t\tupdateEvent,\n\t\t\t\tdbTarget.alteredInstances.map((r) => r.recurrenceId),\n\t\t\t\tthis.zone,\n\t\t\t)\n\t\t}\n\t\tlet calendarGroupRoot\n\t\ttry {\n\t\t\tcalendarGroupRoot = await this.entityClient.load(CalendarGroupRootTypeRef, dbTarget.ownerGroup)\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof NotFoundError) && !(e instanceof NotAuthorizedError)) throw e\n\t\t\tconsole.log(TAG, \"tried to create new progenitor or got new altered instance for progenitor in nonexistent/inaccessible calendar, ignoring\")\n\t\t\treturn\n\t\t}\n\t\treturn await this.doCreate(updateEvent, \"\", calendarGroupRoot, alarms)\n\t}\n\n\t/** Someone replied whether they attend an event or not. this MUST be applied to all instances in our\n\t * model since we keep attendee lists in sync for now. */\n\tprivate async processCalendarReply(sender: string, dbEvent: CalendarEvent, updateEvent: CalendarEvent): Promise<void> {\n\t\tconsole.log(\"processing calendar reply\")\n\t\t// first check if the sender of the email is in the attendee list\n\t\tconst replyAttendee = findAttendeeInAddresses(updateEvent.attendees, [sender])\n\n\t\tif (replyAttendee == null) {\n\t\t\tconsole.log(TAG, \"Sender is not among attendees, ignoring\", replyAttendee)\n\t\t\treturn\n\t\t}\n\n\t\tconst newEvent = clone(dbEvent)\n\t\t// check if the attendee is still in the attendee list of the latest event\n\t\tconst dbAttendee = findAttendeeInAddresses(newEvent.attendees, [replyAttendee.address.address])\n\n\t\tif (dbAttendee == null) {\n\t\t\tconsole.log(TAG, \"attendee was not found\", dbEvent._id, replyAttendee)\n\t\t\treturn\n\t\t}\n\n\t\tdbAttendee.status = replyAttendee.status\n\t\tawait this.doUpdateEvent(dbEvent, newEvent)\n\t}\n\n\t/** handle an event cancellation - either the whole series (progenitor got cancelled)\n\t * or the altered occurrence. */\n\tprivate async processCalendarCancellation(dbEvent: CalendarEventInstance): Promise<void> {\n\t\tconsole.log(TAG, \"processing cancellation\")\n\t\t// not having UID is technically an error, but we'll do our best (the event came from the server after all)\n\t\tif (dbEvent.recurrenceId == null && dbEvent.uid != null) {\n\t\t\treturn await this.deleteEventsByUid(dbEvent.uid)\n\t\t} else {\n\t\t\t// either this has a recurrenceId and we only delete that instance\n\t\t\t// or we don't have a uid to get all instances.\n\t\t\treturn await this.entityClient.erase(dbEvent)\n\t\t}\n\t}\n\n\t/**\n\t * Update {@param dbEvent} stored on the server with {@param icsEvent} from the ics file.\n\t */\n\tasync updateEventWithExternal(dbEvent: CalendarEvent, icsEvent: CalendarEvent): Promise<CalendarEvent> {\n\t\tconst newEvent = clone(dbEvent)\n\t\tnewEvent.startTime = icsEvent.startTime\n\t\tnewEvent.endTime = icsEvent.endTime\n\t\tnewEvent.attendees = icsEvent.attendees\n\t\tnewEvent.summary = icsEvent.summary\n\t\tnewEvent.sequence = icsEvent.sequence\n\t\tnewEvent.location = icsEvent.location\n\t\tnewEvent.description = icsEvent.description\n\t\tnewEvent.organizer = icsEvent.organizer\n\t\tnewEvent.repeatRule = icsEvent.repeatRule\n\t\tnewEvent.recurrenceId = icsEvent.recurrenceId\n\t\treturn await this.doUpdateEvent(dbEvent, newEvent)\n\t}\n\n\tasync doUpdateEvent(dbEvent: CalendarEvent, newEvent: CalendarEvent): Promise<CalendarEvent> {\n\t\tconst [alarms, groupRoot] = await Promise.all([\n\t\t\tthis.loadAlarms(dbEvent.alarmInfos, this.logins.getUserController().user),\n\t\t\tthis.entityClient.load<CalendarGroupRoot>(CalendarGroupRootTypeRef, assertNotNull(dbEvent._ownerGroup)),\n\t\t])\n\t\tconst alarmInfos = alarms.map((a) => a.alarmInfo)\n\t\treturn await this.updateEvent(newEvent, alarmInfos, \"\", groupRoot, dbEvent)\n\t}\n\n\tasync init(): Promise<void> {\n\t\tawait this.scheduleAlarmsLocally()\n\t\tawait this.loadAndProcessCalendarUpdates()\n\t}\n\n\tasync scheduleAlarmsLocally(): Promise<void> {\n\t\tif (!this.localAlarmsEnabled()) return\n\n\t\tconst pushIdentifier = this.pushService?.getLoadedPushIdentifier()\n\t\tif (pushIdentifier && pushIdentifier.disabled) {\n\t\t\treturn console.log(\"Push identifier disabled. Skipping alarm schedule\")\n\t\t}\n\n\t\tconst eventsWithInfos = await this.calendarFacade.loadAlarmEvents()\n\t\tconst scheduler: AlarmScheduler = await this.alarmScheduler()\n\t\tfor (let { event, userAlarmInfos } of eventsWithInfos) {\n\t\t\tfor (let userAlarmInfo of userAlarmInfos) {\n\t\t\t\tthis.scheduleUserAlarmInfo(event, userAlarmInfo, scheduler)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync loadAlarms(alarmInfos: Array<IdTuple>, user: User): Promise<Array<UserAlarmInfo>> {\n\t\tconst { alarmInfoList } = user\n\n\t\tif (alarmInfoList == null) {\n\t\t\treturn []\n\t\t}\n\n\t\tconst ids = alarmInfos.filter((alarmInfoId) => isSameId(listIdPart(alarmInfoId), alarmInfoList.alarms))\n\n\t\tif (ids.length === 0) {\n\t\t\treturn []\n\t\t}\n\n\t\treturn this.entityClient.loadMultiple(UserAlarmInfoTypeRef, listIdPart(ids[0]), ids.map(elementIdPart))\n\t}\n\n\tasync deleteCalendar(calendar: CalendarInfo): Promise<void> {\n\t\tawait this.calendarFacade.deleteCalendar(calendar.groupRoot._id)\n\t\tthis.deviceConfig.removeLastSync(calendar.group._id)\n\t}\n\n\tasync getEventsByUid(uid: string): Promise<CalendarEventUidIndexEntry | null> {\n\t\treturn this.calendarFacade.getEventsByUid(uid)\n\t}\n\n\tprivate async entityEventsReceived(updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: Id): Promise<void> {\n\t\tconst calendarInfos = await this.calendarInfos.getAsync()\n\t\t// We iterate over the alarms twice: once to collect them and to set the counter correctly and the second time to actually process them.\n\t\tconst alarmEventsToProcess: UserAlarmInfo[] = []\n\t\tfor (const entityEventData of updates) {\n\t\t\t// apps handle alarms natively. this code is a candidate to move into\n\t\t\t// a generic web/native alarm handler\n\t\t\tif (isUpdateForTypeRef(UserAlarmInfoTypeRef, entityEventData) && !isApp()) {\n\t\t\t\tif (entityEventData.operation === OperationType.CREATE) {\n\t\t\t\t\t// Updates for UserAlarmInfo and CalendarEvent come in a\n\t\t\t\t\t// separate batches and there's a race between loading of the\n\t\t\t\t\t// UserAlarmInfo and creation of the event.\n\t\t\t\t\t// We try to load UserAlarmInfo. Then we wait until the\n\t\t\t\t\t// CalendarEvent is there (which might already be true)\n\t\t\t\t\t// and load it.\n\t\t\t\t\t// All alarms for the same event come in the same batch so\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst userAlarmInfo = await this.entityClient.load(UserAlarmInfoTypeRef, [entityEventData.instanceListId, entityEventData.instanceId])\n\t\t\t\t\t\talarmEventsToProcess.push(userAlarmInfo)\n\t\t\t\t\t\tconst deferredEvent = this.getPendingAlarmRequest(userAlarmInfo.alarmInfo.calendarRef.elementId)\n\t\t\t\t\t\tdeferredEvent.pendingAlarmCounter++\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\t\tconsole.log(TAG, e, \"Event or alarm were not found: \", entityEventData, e)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (entityEventData.operation === OperationType.DELETE && !isApp()) {\n\t\t\t\t\tawait this.cancelUserAlarmInfo(entityEventData.instanceId)\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(CalendarEventTypeRef, entityEventData)) {\n\t\t\t\tif (entityEventData.operation === OperationType.CREATE || entityEventData.operation === OperationType.UPDATE) {\n\t\t\t\t\tconst deferredEvent = this.getPendingAlarmRequest(entityEventData.instanceId)\n\t\t\t\t\tdeferredEvent.deferred.resolve(undefined)\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(CalendarEventUpdateTypeRef, entityEventData) && entityEventData.operation === OperationType.CREATE) {\n\t\t\t\ttry {\n\t\t\t\t\tconst invite = await this.entityClient.load(CalendarEventUpdateTypeRef, [entityEventData.instanceListId, entityEventData.instanceId])\n\t\t\t\t\tawait this.handleCalendarEventUpdate(invite)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\tconsole.log(TAG, \"invite not found\", [entityEventData.instanceListId, entityEventData.instanceId], e)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(FileTypeRef, entityEventData)) {\n\t\t\t\t// with a file update, the owner enc session key should be present now so we can try to process any skipped calendar event updates\n\t\t\t\t// (see NoOwnerEncSessionKeyForCalendarEventError's comment)\n\t\t\t\tconst skippedCalendarEventUpdate = this.fileIdToSkippedCalendarEventUpdates.get(entityEventData.instanceId)\n\t\t\t\tif (skippedCalendarEventUpdate) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.handleCalendarEventUpdate(skippedCalendarEventUpdate)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\t\tconsole.log(TAG, \"invite not found\", [entityEventData.instanceListId, entityEventData.instanceId], e)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.fileIdToSkippedCalendarEventUpdates.delete(entityEventData.instanceId)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.logins.getUserController().isUpdateForLoggedInUserInstance(entityEventData, eventOwnerGroupId)) {\n\t\t\t\tconst calendarMemberships = this.logins.getUserController().getCalendarMemberships()\n\t\t\t\tconst oldGroupIds = new Set(calendarInfos.keys())\n\t\t\t\tconst newGroupIds = new Set(calendarMemberships.map((m) => m.group))\n\t\t\t\tconst diff = symmetricDifference(oldGroupIds, newGroupIds)\n\n\t\t\t\tif (diff.size !== 0) {\n\t\t\t\t\tthis.calendarInfos.reload()\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(GroupInfoTypeRef, entityEventData)) {\n\t\t\t\t// the batch does not belong to that group so we need to find if we actually care about the related GroupInfo\n\t\t\t\tfor (const { groupInfo } of calendarInfos.values()) {\n\t\t\t\t\tif (isUpdateFor(groupInfo, entityEventData)) {\n\t\t\t\t\t\tthis.calendarInfos.reload()\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isApp()) {\n\t\t\tconst pushIdentifier = this.pushService?.getLoadedPushIdentifier()\n\t\t\tif (pushIdentifier && pushIdentifier.disabled) {\n\t\t\t\treturn console.log(\"Push identifier disabled. Skipping alarm schedule\")\n\t\t\t}\n\t\t}\n\n\t\t// in the apps, this array is guaranteed to be empty.\n\t\tfor (const userAlarmInfo of alarmEventsToProcess) {\n\t\t\tconst { listId, elementId } = userAlarmInfo.alarmInfo.calendarRef\n\t\t\tconst deferredEvent = this.getPendingAlarmRequest(elementId)\n\t\t\t// Don't wait for the deferred event promise because it can lead to a deadlock.\n\t\t\t// Since issue #2264 we process event batches sequentially and the\n\t\t\t// deferred event can never be resolved until the calendar event update is received.\n\t\t\tdeferredEvent.deferred.promise = deferredEvent.deferred.promise.then(async () => {\n\t\t\t\tdeferredEvent.pendingAlarmCounter--\n\t\t\t\tif (deferredEvent.pendingAlarmCounter === 0) {\n\t\t\t\t\tthis.pendingAlarmRequests.delete(elementId)\n\t\t\t\t}\n\t\t\t\tconst calendarEvent = await this.entityClient.load(CalendarEventTypeRef, [listId, elementId])\n\t\t\t\tconst scheduler = await this.alarmScheduler()\n\t\t\t\ttry {\n\t\t\t\t\tthis.scheduleUserAlarmInfo(calendarEvent, userAlarmInfo, scheduler)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\tconsole.log(TAG, \"event not found\", [listId, elementId])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate getPendingAlarmRequest(elementId: string) {\n\t\treturn getFromMap(this.pendingAlarmRequests, elementId, () => ({ pendingAlarmCounter: 0, deferred: defer() }))\n\t}\n\n\tprivate localAlarmsEnabled(): boolean {\n\t\treturn !isApp() && !isDesktop() && this.logins.isInternalUserLoggedIn() && !this.logins.isEnabled(FeatureType.DisableCalendar)\n\t}\n\n\tprivate scheduleUserAlarmInfo(event: CalendarEvent, userAlarmInfo: UserAlarmInfo, scheduler: AlarmScheduler): void {\n\t\tthis.userAlarmToAlarmInfo.set(getElementId(userAlarmInfo), userAlarmInfo.alarmInfo.alarmIdentifier)\n\n\t\tscheduler.scheduleAlarm(event, userAlarmInfo.alarmInfo, event.repeatRule, (eventTime, summary) => {\n\t\t\tconst { title, body } = formatNotificationForDisplay(eventTime, summary)\n\t\t\tthis.notifications.showNotification(\n\t\t\t\tNotificationType.Calendar,\n\t\t\t\ttitle,\n\t\t\t\t{\n\t\t\t\t\tbody,\n\t\t\t\t},\n\t\t\t\t() => m.route.set(\"/calendar\"),\n\t\t\t)\n\t\t})\n\t}\n\n\tprivate async cancelUserAlarmInfo(userAlarmInfoId: Id): Promise<any> {\n\t\tconst identifier = this.userAlarmToAlarmInfo.get(userAlarmInfoId)\n\n\t\tif (identifier) {\n\t\t\tconst alarmScheduler = await this.alarmScheduler()\n\t\t\talarmScheduler.cancelAlarm(identifier)\n\t\t}\n\t}\n\n\t// VisibleForTesting\n\tgetFileIdToSkippedCalendarEventUpdates(): Map<Id, CalendarEventUpdate> {\n\t\treturn this.fileIdToSkippedCalendarEventUpdates\n\t}\n\n\tgetBirthdayEventTitle(contactName: string) {\n\t\treturn lang.get(\"birthdayEvent_title\", {\n\t\t\t\"{name}\": contactName,\n\t\t})\n\t}\n\n\tgetAgeString(age: number) {\n\t\treturn lang.get(\"birthdayEventAge_title\", { \"{age}\": age })\n\t}\n}\n\n/** return false when the given events (representing the new and old version of the same event) are both long events\n * or both short events, true otherwise */\nasync function didLongStateChange(newEvent: CalendarEvent, existingEvent: CalendarEvent, zone: string): Promise<boolean> {\n\tconst { isLongEvent } = await import(\"../../../common/calendar/date/CalendarUtils.js\")\n\treturn isLongEvent(newEvent, zone) !== isLongEvent(existingEvent, zone)\n}\n\n/**\n * This is used due us receiving calendar events before updateOwnerEncSessionKey gets triggered, and thus we can't load calendar data attachments. This is\n * required due to our permission system and the fact that bucket keys are not immediately accessible from File, only Mail.\n *\n * This is a limitation that should be addressed in the future.\n */\nclass NoOwnerEncSessionKeyForCalendarEventError extends TutanotaError {\n\tconstructor(message: string) {\n\t\tsuper(\"NoOwnerEncSessionKeyForCalendarEventError\", message)\n\t}\n}\n\n/**\n * yield the given monitor one time and then switch to noOp monitors forever\n */\nfunction* oneShotProgressMonitorGenerator(progressTracker: ProgressTracker, userController: UserController): Generator<IProgressMonitor> {\n\t// load all calendars. if there is no calendar yet, create one\n\t// we load three instances per calendar / CalendarGroupRoot / GroupInfo / Group\n\tconst workPerCalendar = 3\n\tconst totalWork = userController.getCalendarMemberships().length * workPerCalendar\n\t// the first time we want a real progress monitor but any time we would reload we don't need it\n\tconst realMonitorId = progressTracker.registerMonitorSync(totalWork)\n\tconst realMonitor = assertNotNull(progressTracker.getMonitor(realMonitorId))\n\tyield realMonitor\n\twhile (true) {\n\t\tyield new NoopProgressMonitor()\n\t}\n}\n\nexport function formatNotificationForDisplay(eventTime: Date, summary: string): { title: string; body: string } {\n\tlet dateString: string\n\n\tif (isSameDay(eventTime, new Date())) {\n\t\tdateString = formatTime(eventTime)\n\t} else {\n\t\tdateString = formatDateWithWeekdayAndTime(eventTime)\n\t}\n\n\tconst body = `${dateString} ${summary}`\n\n\treturn { body, title: body }\n}\n\nasync function loadAllEvents(groupRoot: CalendarGroupRoot): Promise<Array<CalendarEvent>> {\n\treturn Promise.all([\n\t\tlocator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.longEvents),\n\t\tlocator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.shortEvents),\n\t]).then((results) => results.flat())\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAIa,uBAAN,MAA8B;CACpC,AAAQ;CACR,AAAS,SAAoB,4BAAQ;CAErC,YAAYA,cAA6CC,cAAiB;EAsC1E,KAtCyD;AACxD,OAAK,aAAa,IAAI,WAAc,YAAY;GAC/C,MAAM,QAAQ,MAAM,cAAc;AAClC,QAAK,OAAO,MAAM;AAClB,UAAO;EACP,GAAE;AAEH,OAAK,OAAO,aAAa;CACzB;CAED,WAAuB;AACtB,SAAO,KAAK,WAAW,UAAU;CACjC;CAED,WAAoB;AACnB,SAAO,KAAK,WAAW,UAAU;CACjC;CAED,YAAe;AACd,SAAO,KAAK,WAAW,WAAW;CAClC;;CAGD,MAAM,SAAqB;AAC1B,MAAI;AACH,UAAO,MAAM,KAAK,WAAW,QAAQ;EACrC,SAAQ,GAAG;AACX,QAAK,WAAW,OAAO;AACvB,QAAK,OAAO,KAAK,aAAa;AAC9B,UAAO,KAAK;EACZ;CACD;CAED,QAAQ;AACP,OAAK,WAAW,OAAO;AACvB,OAAK,OAAO,KAAK,aAAa;CAC9B;AACD;;;;AC6CD,MAAM,MAAM;AAUL,SAAS,oBAAoBC,OAAsB;AACzD,SAAQ,mBAAmB,MAAM,EAAjC;AACC,OAAK,sBAAsB,2BAC1B,OAAM,IAAI,UAAU;AACrB,OAAK,sBAAsB,sBAC1B,OAAM,IAAI,UAAU;AACrB,OAAK,sBAAsB,eAE1B,OAAM,IAAI,UAAU;AACrB,OAAK,sBAAsB;CAE3B;AACD;IAEY,gBAAN,MAAoB;;;;;;;;CAQ1B,AAAQ,uBAMJ,IAAI;CACR,AAAiB,uBAA4C,IAAI;CACjE,AAAiB,sCAAoE,IAAI;CAEzF,AAAQ;;;;CAKR,AAAiB,gBAAgB,IAAI,qBAAoD,MAAM;EAC9F,MAAMC,UAA4B,KAAK,oBAAoB,MAAM,CAAC;EAClE,MAAM,sBAAsB,KAAK,yBAAyB,QAAQ;AAClE,UAAQ,WAAW;AACnB,SAAO;CACP,GAAE,IAAI;CAEP,YACkBC,eACAC,gBACjBC,iBACiBC,iBACAC,QACAC,iBACAC,cACAC,cACAC,gBACAC,gBACAC,MACAC,wBACAC,cACAC,aAChB;EA89BF,KA5+BkB;EA4+BjB,KA3+BiB;EA2+BhB,KAz+BgB;EAy+Bf,KAx+Be;EAw+Bd,KAv+Bc;EAu+Bb,KAt+Ba;EAs+BZ,KAr+BY;EAq+BX,KAp+BW;EAo+BV,KAn+BU;EAm+BT,KAl+BS;EAk+BR,KAj+BQ;EAi+BP,KAh+BO;EAg+BN,KA/9BM;AAEjB,OAAK,sBAAsB,gCAAgC,iBAAiB,OAAO,mBAAmB,CAAC;AACvG,kBAAgB,kBAAkB,CAAC,SAAS,sBAAsB,KAAK,qBAAqB,SAAS,kBAAkB,CAAC;CACxH;CAED,mBAA2D;AAC1D,SAAO,KAAK,cAAc,UAAU;CACpC;CAED,yBAAgE;AAC/D,SAAO,KAAK,cAAc;CAC1B;CAED,MAAM,YAAYf,OAAsBgB,YAA8CJ,MAAcK,WAA6C;AAChJ,QAAM,KAAK,SAAS,OAAO,MAAM,WAAW,WAAW;CACvD;;CAGD,MAAM,YACLC,UACAC,WACAP,MACAK,WACAG,eACyB;AACzB,MAAI,cAAc,OAAO,KACxB,OAAM,IAAI,MAAM;AAGjB,MAAI,cAAc,OAAO,QAAQ,SAAS,QAAQ,cAAc,IAC/D,OAAM,IAAI,MAAM;AAKjB,MACC,cAAc,gBAAgB,UAAU,OACxC,SAAS,UAAU,SAAS,KAAK,cAAc,UAAU,SAAS,IACjE,MAAM,mBAAmB,UAAU,eAAe,KAAK,EACvD;AAED,SAAM,KAAK,SAAS,UAAU,MAAM,WAAW,WAAW,cAAc;AACxE,UAAO,MAAM,KAAK,aAAa,KAAoB,sBAAsB,SAAS,IAAI;EACtF,OAAM;AACN,YAAS,cAAc,UAAU;AAGjC,SAAM,KAAK,eAAe,oBAAoB,UAAU,WAAW,cAAc;AACjF,UAAO;EACP;CACD;;CAGD,MAAc,kBAAkBC,iBAA2E;EAC1G,MAAM,iBAAiB,KAAK,OAAO,mBAAmB;EAEtD,MAAMC,sBAAyC,CAAE;EACjD,MAAMC,iBAA+D,CAAE;AACvE,OAAK,MAAM,cAAc,eAAe,wBAAwB,EAAE;AACjE,OAAI;IACH,MAAM,SAAS,MAAM,QAAQ,IAAI;KAChC,KAAK,aAAa,KAAK,0BAA0B,WAAW,MAAM;KAClE,KAAK,aAAa,KAAK,kBAAkB,WAAW,UAAU;KAC9D,KAAK,aAAa,KAAK,cAAc,WAAW,MAAM;IACtD,EAAC;AACF,mBAAe,KAAK,OAAO;GAC3B,SAAQ,GAAG;AACX,QAAI,aAAa,cAChB,qBAAoB,KAAK,WAAW;IAEpC,OAAM;GAEP;AACD,mBAAgB,SAAS,EAAE;EAC3B;EAED,MAAMC,gBAAuC,IAAI;EACjD,MAAM,gBAAgB,eAAe,sBAAsB;AAC3D,OAAK,MAAM,CAAC,WAAW,WAAW,MAAM,IAAI,eAC3C,KAAI;GACH,MAAM,eAAe,MAAM,iBAAiB,OAAO,KAAK,aAAa;GACrE,MAAM,SAAS,aAAa,SAAS;GACrC,MAAM,eAAe,UAAU,mBAAmB,OAAO,eAAe,OAAO;GAC/E,MAAM,aAAa,aAAa,cAAc,KAAK,CAACC,oBAAkBA,gBAAc,UAAU,MAAM,IAAI,CAAC;AACzG,iBAAc,IAAI,UAAU,KAAK;IAChC;IACA;IACO;IACP;IACA;IACA;GACA,EAAC;EACF,SAAQ,GAAG;AACX,OAAI,aAAa,mBAChB,SAAQ,IAAI,4EAA4E;IAExF,OAAM;EAEP;AAIF,OAAK,MAAM,cAAc,oBAExB,MAAK,gBACH,OACA,mBACA,2BAA2B;GAC1B,MAAM,eAAe;GACrB,OAAO,WAAW;EAClB,EAAC,CACF,CACA,MAAM,CAAC,MAAM,QAAQ,IAAI,4CAA4C,WAAW,MAAM,CAAC;AAE1F,SAAO;CACP;CAED,MAAa,sBAAsBC,KAA8B;AAChE,OAAK,KAAK,uBAAwB,OAAM,IAAI,OAAO,mCAAmC,KAAK,uBAAuB;EAClH,MAAM,cAAc,MAAM,KAAK,wBAAwB,sBAAsB,IAAI;AACjF,SAAO,eAAe;CACtB;CAED,AAAO,+BAA+B;AACrC,cAAY,MAAM;AACjB,QAAK,uBAAuB,CAAC,MAAM,CAAC,MAAM,QAAQ,MAAM,EAAE,QAAQ,CAAC;EACnE,GAAE,gCAAgC;CACnC;CAED,MAAa,sBACZC,gBAAwC,MACxCC,eAAuB,iCACvBC,mBAA4B,OAC5BC,YAAqB,OACpB;AACD,OAAK,KAAK,2BAA2B,QAAQ,OAAO,iBAAiB,CACpE;EAGD,IAAI,wBAAwB;EAC5B,MAAM,iBAAiB,KAAK,OAAO,mBAAmB;EAEtD,MAAMC,qBAAmD,CAAE;EAC3D,IAAIC,yBAA8C,CAAE;AACpD,OAAK,MAAM,cAAc,eAAe,wBAAwB,CAC/D,oBAAmB,KAAK,KAAK,aAAa,KAAK,0BAA0B,WAAW,MAAM,CAAC;AAE5F,2BAAyB,MAAM,QAAQ,IAAI,mBAAmB;AAE9D,OAAK,uBAAuB;GAC3B,MAAM,EAAE,eAAe,WAAW,GAAG,MAAM,QAAQ,aAAa,KAAK,8BAA8B,eAAe,KAAK,UAAU,MAAM;AACvI,2BAAwB;EACxB;EAED,MAAMC,mBAAoE,IAAI;AAC9E,OAAK,MAAM,EAAE,WAAW,OAAO,MAAM,IAAI,uBAAuB;AAC/D,QAAK,UACJ;GAGD,MAAM,gBAAgB,KAAK,aAAa,6BAA6B,CAAC,IAAI,MAAM;GAChF,MAAM,SAAS;GACf,MAAM,kBACJ,aACD,eAAe,mBAAmB,WAAW,WAC7C,cAAc,sBACd,KAAK,KAAK,GAAG,SAAS,cAAc,qBAAqB;AAC1D,OAAI,eAAgB;GAEpB,MAAM,2BAA2B,uBAAuB,KAAK,CAAC,sBAAsB,SAAS,kBAAkB,KAAK,MAAM,CAAC,IAAI;AAC/H,QAAK,0BAA0B;AAC9B,YAAQ,OAAO,kEAAkE,MAAM,EAAE;AACzF;GACA;GAED,IAAIC,uBAAsC,CAAE;AAC5C,OAAI;IACH,MAAM,mBAAmB,MAAM,KAAK,sBAAsB,UAAU;AACpE,2BAAuB,wBAAwB,kBAAkB,aAAa,CAAC,CAAC;GAChF,SAAQ,OAAO;IACf,IAAI,eAAe;AACnB,SAAK,cAAc;KAClB,MAAM,YAAY,MAAM,KAAK,kBAAkB;AAC/C,oBAAe,UAAU,IAAI,MAAM,EAAE,UAAU;IAC/C;AACD,qBAAiB,IAAI,OAAO;KAAE;KAAc;IAAO,EAAC;AACpD;GACA;GAED,MAAM,oBAAoB,MAAM,cAAc,yBAAyB;GAEvE,MAAMC,gBAKF;IACH,SAAS,CAAE;IACX,SAAS,CAAE;IACX,SAAS,CAAE;IACX,SAAS,CAAE;GACX;;;;;;;GAOD,MAAM,EAAE,gBAAgB,mBAAmB,GAAG,oBAAoB,sBAAsB,mBAAmB,0BAA0B,aAAa,CAAC;GACnJ,MAAM,aAAa,eAAe,IAAI,2BAA2B,UAAU,IAAI,CAAE;AAGjF,QAAK,MAAM,mBAAmB,YAAY;IACzC,MAAM,gBAAgB,kBAAkB,KAAK,CAAC,UAAU,MAAM,QAAQ,gBAAgB,IAAI;AAC1F,SAAK,eAAe;AACnB,aAAQ,KAAK,+CAA+C;AAC5D;IACA;AACD,QAAI,KAAK,mBAAmB,iBAAiB,cAAc,EAAE;AAC5D,mBAAc,QAAQ,KAAK,gBAAgB;AAC3C;IACA;AACD,UAAM,KAAK,wBAAwB,eAAe,gBAAgB;AAClE,kBAAc,QAAQ,KAAK,gBAAgB;GAC3C;AACD,WAAQ,IAAI,MAAM,EAAE,cAAc,QAAQ,OAAO,+CAA+C;AAChG,WAAQ,IAAI,MAAM,EAAE,cAAc,QAAQ,OAAO,4CAA4C;AAG7F,QAAK,MAAM,EAAE,OAAO,IAAI,mBAAmB;AAC1C,kBAAc,OAAO,aAAa,EAAE,yBAAyB;AAE7D,UAAM,sBAAsB;AAE5B,QAAI,MAAM,cAAc,KACvB,OAAM,WAAW,gBAAgB,MAAM,WAAW,cAAc,IAAI,CAAC,EAAE,MAAM,KAAK,kBAAkB,EAAE,KAAM,EAAC,CAAC;AAG/G,aAAS,MAAM,CAAC,eAAe;AAC/B,UAAM,cAAc,yBAAyB;AAC7C,wBAAoB,MAAM;AAC1B,kBAAc,QAAQ,KAAK,MAAM;GACjC;AACD,SAAM,KAAK,eAAe,2BAA2B,mBAAmB,EAAE;AAC1E,WAAQ,IAAI,MAAM,EAAE,cAAc,QAAQ,OAAO,iBAAiB;GAGlE,MAAM,iBAAiB,kBAAkB,OACxC,CAAC,mBAAmB,qBAAqB,KAAK,CAAC,kBAAkB,cAAc,MAAM,QAAQ,cAAc,IAAI,CAC/G;AACD,QAAK,MAAM,SAAS,gBAAgB;AACnC,UAAM,KAAK,YAAY,MAAM,CAAC,MAAM,CAAC,QAAQ;AAC5C,SAAI,eAAe,cAClB,QAAO,QAAQ,KAAK,wBAAwB,MAAM;AAGnD,WAAM;IACN,EAAC;AACF,kBAAc,QAAQ,KAAK,MAAM;GACjC;AACD,WAAQ,IAAI,MAAM,EAAE,cAAc,QAAQ,OAAO,iBAAiB;AAElE,QAAK,aAAa,eAAe,MAAM;EACvC;AAED,MAAI,iBAAiB,MAAM;GAC1B,IAAI,eAAe,KAAK,IAAI,iBAAiB,IAAI,mBAAmB,SAAS;AAC7E,QAAK,MAAM,CAAC,OAAO,QAAQ,IAAI,iBAAiB,SAAS,EAAE;AAC1D,QAAI,iBAAkB,kBAAiB,EAAE,QAAQ,aAAa,KAAK,QAAQ,MAAM,QAAQ;AACzF,SAAK,aAAa,eAAe,OAAO,WAAW,OAAO;GAC1D;AACD,SAAM,IAAI,MAAM;EAChB;CACD;CAED,AAAQ,mBAAmBC,GAAkBC,GAAkB;AAC9D,SACC,EAAE,UAAU,SAAS,KAAK,EAAE,UAAU,SAAS,IAC/C,EAAE,QAAQ,SAAS,KAAK,EAAE,QAAQ,SAAS,IAC3C,UAAU,EAAE,GAAG,EAAE,UAAW,GAAE,EAAE,GAAG,EAAE,UAAW,EAAC,IACjD,EAAE,YAAY,EAAE,WAChB,EAAE,aAAa,EAAE,YACjB,EAAE,aAAa,EAAE,YACjB,EAAE,gBAAgB,EAAE,eACpB,UAAU,EAAE,WAAW,EAAE,UAAU,IACnC,UAAU,EAAE,YAAY,EAAE,WAAW,IACrC,EAAE,cAAc,SAAS,KAAK,EAAE,cAAc,SAAS;CAExD;CAED,MAAc,yBAAyBhB,iBAA2E;EACjH,MAAM,EAAE,0BAA0B,GAAG,MAAM,OAAO;EAClD,MAAM,gBAAgB,MAAM,KAAK,kBAAkB,gBAAgB;AAEnE,OAAK,KAAK,OAAO,wBAAwB,IAAI,yBAAyB,cAAc,CACnF,QAAO;KACD;AACN,SAAM,KAAK,eAAe,IAAI,MAAM,CAAE,GAAE,KAAK;AAC7C,UAAO,MAAM,KAAK,kBAAkB,gBAAgB;EACpD;CACD;CAED,MAAM,eAAeiB,MAAcC,OAAsBC,QAAyBC,WAA0C;EAI3H,MAAM,EAAE,MAAM,OAAO,GAAG,MAAM,KAAK,eAAe,YAAY,KAAK;AACnE,OAAK,OAAO,mBAAmB,CAAC,OAAO;EAEvC,MAAM,mBAAmB,OAAO,IAAI,CAAC,UAAU,uBAAuB,EAAE,SAAS,uBAAuB,MAAM,CAAE,EAAC,CAAC;AAClH,MAAI,SAAS,MAAM;GAClB,MAAM,EAAE,uBAAuB,GAAG,KAAK,OAAO,mBAAmB;GACjE,MAAM,mBAAmB,oBAAoB;IAC5C,OAAO,MAAM;IACN;IACP,MAAM;IACN,mBAAmB;IACnB;GACA,EAAC;AAEF,yBAAsB,cAAc,KAAK,iBAAiB;AAC1D,SAAM,KAAK,aAAa,OAAO,sBAAsB;EACrD;AAED,SAAO;CACP;CAED,MAAc,SACbzC,OACAY,MACAK,WACAD,YACA0B,eACgB;AAEhB,wBAAsB,MAAM;EAC5B,MAAM,EAAE,gCAAe,GAAG,MAAM,OAAO;AAGvC,kBAAc,OAAO,MAAM,UAAU;AAErC,QAAM,sBAAsB;AAC5B,MAAI,MAAM,cAAc,KACvB,OAAM,WAAW,gBAAgB,MAAM,WAAW,cAAc,IAAI,CAAC,EAAE,MAAM,KAAK,kBAAkB,EAAE,KAAM,EAAC,CAAC;AAG/G,WAAS,MAAM,CAAC,eAAe;AAC/B,QAAM,cAAc,UAAU;AAC9B,SAAO,MAAM,KAAK,eAAe,kBAAkB,OAAO,YAAY,iBAAiB,KAAK;CAC5F;CAED,MAAM,YAAY1C,OAAqC;AACtD,SAAO,MAAM,KAAK,aAAa,MAAM,MAAM;CAC3C;;;;;;CAOD,MAAM,+BAA+B,EAAE,KAAiC,EAAiC;AACxG,UAAQ,MAAM,KAAK,eAAe,cAAc,KAAK,uCAAuC,CAAC,GAAG,cAAc;CAC9G;CAED,MAAc,gCAA+C;EAC5D,MAAM,EAAE,kBAAkB,GAAG,MAAM,KAAK,aAAa,uBAAuB;EAC5E,MAAM,EAAE,sBAAsB,GAAG;AACjC,MAAI,wBAAwB,KAAM;EAElC,MAAM,UAAU,MAAM,KAAK,aAAa,QAAQ,4BAA4B,qBAAqB,KAAK;AACtG,OAAK,MAAM,UAAU,QACpB,OAAM,KAAK,0BAA0B,OAAO;CAE7C;;;;;;CAOD,iCAA6E;AAC5E,MAAI,KAAK,cAAc,UAAU,IAAI,KAAK,cAAc,WAAW,CAAC,OAAO,EAC1E,QAAO,KAAK,cAAc,WAAW;AAGtC,SAAO,QAAQ,SAAS,CAAC,KAAK,YAAY;GACzC,MAAM,YAAY,MAAM,KAAK,cAAc,UAAU;AAErD,OAAI,UAAU,OAAO,EACpB,QAAO;KACD;AACN,UAAM,KAAK,eAAe,IAAI,MAAM,CAAE,GAAE,KAAK;AAC7C,WAAO,KAAK,cAAc,QAAQ;GAClC;EACD,EAAC;CACF;CAED,MAAc,yBAAyB2C,QAAqD;AAC3F,MAAI;GAGH,MAAM,OAAO,MAAM,KAAK,aAAa,KAAK,aAAa,OAAO;GAC9D,MAAM,WAAW,MAAM,KAAK,eAAe,cAAc,KAAK;GAC9D,MAAM,EAAE,mBAAmB,GAAG,MAAM,OAAO;AAC3C,UAAO,MAAM,kBAAkB,SAAS;EACxC,SAAQ,GAAG;AACX,OAAI,aAAa,wBAEhB,OAAM,IAAI,0CAA0C;AAErD,OAAI,aAAa,eAAe,aAAa,eAAe;AAC3D,YAAQ,KAAK,KAAK,sCAAsC,EAAE;AAC1D,WAAO;GACP;AACD,SAAM;EACN;CACD;CAED,MAAc,0BAA0BC,QAA4C;AAEnF,MAAI;GACH,MAAM,qBAAqB,MAAM,KAAK,yBAAyB,OAAO,KAAK;AAC3E,OAAI,sBAAsB,KACzB,OAAM,KAAK,oBAAoB,OAAO,QAAQ,mBAAmB;EAElE,SAAQ,GAAG;AACX,OAAI,aAAa,oBAAoB;AAEpC,YAAQ,KAAK,KAAK,qDAAqD,EAAE;AACzE;GACA,WAAU,aAAa,yBAAyB;AAEhD,YAAQ,KAAK,KAAK,0DAA0D,EAAE;AAC9E;GACA,WAAU,aAAa,aAAa;AAEpC,YAAQ,KAAK,KAAK,6CAA6C,EAAE;AACjE;GACA,WAAU,aAAa,cAGvB,SAAQ,KAAK,KAAK,gDAAgD,EAAE;SAC1D,aAAa,2CAA2C;AAGlE,SAAK,oCAAoC,IAAI,cAAc,OAAO,KAAK,EAAE,OAAO;AAChF,YAAQ,KAAK,MAAM,qCAAqC,EAAE,QAAQ,GAAG,EAAE;AACvE;GACA,OAAM;AAIN,YAAQ,KAAK,KAAK,sCAAsC,EAAE;AAC1D,UAAM,KAAK,YAAY,OAAO;AAC9B,UAAM;GACN;EACD;AAED,QAAM,KAAK,YAAY,OAAO;CAC9B;;;;;;CAOD,MAAc,YAAYA,QAA4C;AACrE,MAAI;AACH,SAAM,KAAK,aAAa,MAAM,OAAO;EACrC,SAAQ,GAAG;AACX,WAAQ,IAAI,KAAK,4BAA4B,EAAE,KAAK;EACpD;CACD;;CAGD,MAAM,kBAAkBC,KAA4B;EACnD,MAAM,QAAQ,MAAM,KAAK,eAAe,eAAe,IAAI;AAC3D,MAAI,SAAS,MAAM;AAClB,WAAQ,IAAI,oDAAoD;AAChE;EACA;AAED,OAAK,MAAM,KAAK,MAAM,iBACrB,OAAM,KAAK,YAAY,EAAE;AAE1B,MAAI,MAAM,WACT,OAAM,KAAK,YAAY,MAAM,WAAW;CAEzC;;;;CAKD,MAAM,oBAAoBC,QAAgBC,cAAiD;AAC1F,MAAI,aAAa,SAAS,WAAW,GAAG;AACvC,WAAQ,IAAI,MAAM,0CAA0C;AAC5D;EACA;AAED,MAAI,aAAa,SAAS,GAAG,MAAM,OAAO,MAAM;AAC/C,WAAQ,IAAI,KAAK,8CAA8C;AAC/D;EACA;EASD,MAAM,WAAW,MAAM,KAAK,eAAe,eAAe,aAAa,SAAS,GAAG,MAAM,KAAK,YAAY,OAAO;AAEjH,MAAI,YAAY,MAAM;AAGrB,WAAQ,IAAI,KAAK,mFAAmF;AACpG;EACA;EACD,MAAM,SAAS,aAAa;AAC5B,OAAK,MAAM,WAAW,aAAa,UAAU;GAC5C,MAAM,eAAe,QAAQ;GAC7B,MAAM,cAAc,QAAQ;AAG5B,SAAM,KAAK,4BAA4B,QAAQ,QAAQ,aAAa,cAAc,SAAS;EAC3F;CACD;;;;;;;;;;;;;;;;CAiBD,MAAM,4BACLD,QACAE,QACAC,aACAC,cACAC,QACgB;EAChB,MAAM,kBAAkB,YAAY,cAAc,SAAS;EAC3D,MAAM,gBAAgB,mBAAmB,OAAO,OAAO,aAAa,OAAO,iBAAiB,KAAK,CAAC,MAAM,EAAE,aAAa,SAAS,KAAK,gBAAgB;AACrJ,MAAI,iBAAiB,KACpB,KAAI,WAAW,eAAe,QAM7B,QAAO,MAAM,KAAK,sBAAsB,QAAQ,aAAa,aAAa;SAChE,OAAO,YAAY,cAAc,QAAQ,YAAY,gBAAgB,QAAQ,WAAW,eAAe,QAAQ;AAKzH,UAAO,iBAAiB,KAAK,YAA4C;AAEzE,UAAO,MAAM,KAAK,sBAAsB,QAAQ,OAAO,YAAY,OAAO,WAAW;EACrF,OAAM;AACN,WAAQ,IAAI,MAAM,0EAA0E,OAAO;AACnG;EACA;EAGF,MAAMC,kBAA2B,cAAc,aAAa,QAAQ,cAAc,UAAU,YAAY;AACxG,MAAI,WAAW,eAAe,MAC7B,QAAO,KAAK,qBAAqB,QAAQ,eAAe,YAAY;SAC1D,mBAAmB,WAAW,eAAe,QACvD,QAAO,MAAM,KAAK,sBAAsB,QAAQ,eAAe,YAAY;SACjE,mBAAmB,WAAW,eAAe,OACvD,QAAO,MAAM,KAAK,4BAA4B,cAAc;IAE5D,SAAQ,IAAI,MAAM,EAAE,OAAO,0CAA0C;CAEtE;;;;;CAMD,MAAc,sBAAsBC,UAAsCC,SAAgCC,aAA2C;AACpJ,UAAQ,IAAI,KAAK,iDAAiD;EAClE,MAAM,EAAE,wCAAwC,GAAG,MAAM,OAAO;AAIhE,MAAI,UAAU,QAAQ,SAAS,GAAG,UAAU,YAAY,SAAS,EAAE;AAClE,WAAQ,IAAI,KAAK,mDAAmD;AACpE;EACA;AACD,MAAI,YAAY,gBAAgB,QAAQ,YAAY,cAAc,KAEjE,aAAY,aAAa,uCACxB,aACA,SAAS,iBAAiB,IAAI,CAAC,MAAM,EAAE,aAAa,EACpD,KAAK,KACL;AAMF,WAAS,aAAc,MAAM,KAAK,wBAAwB,SAAS,YAAY;CAC/E;;;;;;;CAQD,MAAc,sBACbF,UACAJ,aACAO,QACgB;AAChB,UAAQ,IAAI,KAAK,kCAAkC;EACnD,MAAM,EAAE,wCAAwC,GAAG,MAAM,OAAO;AAChE,MAAI,YAAY,gBAAgB,QAAQ,SAAS,cAAc,QAAQ,SAAS,WAAW,cAAc,MAAM;GAG9G,MAAM,oBAAoB,MAAM,SAAS,WAAW;AACpD,qBAAkB,aAAa,uCAAuC,mBAAmB,CAAC,YAAY,YAAa,GAAE,KAAK,KAAK;AAC/H,YAAS,aAAc,MAAM,KAAK,cAAc,SAAS,YAAY,kBAAkB;EACvF,WAAU,YAAY,gBAAgB,QAAQ,YAAY,cAAc,QAAQ,SAAS,iBAAiB,SAAS,EAEnH,aAAY,aAAa,uCACxB,aACA,SAAS,iBAAiB,IAAI,CAAC,MAAM,EAAE,aAAa,EACpD,KAAK,KACL;EAEF,IAAI;AACJ,MAAI;AACH,uBAAoB,MAAM,KAAK,aAAa,KAAK,0BAA0B,SAAS,WAAW;EAC/F,SAAQ,GAAG;AACX,SAAM,aAAa,oBAAoB,aAAa,oBAAqB,OAAM;AAC/E,WAAQ,IAAI,KAAK,2HAA2H;AAC5I;EACA;AACD,SAAO,MAAM,KAAK,SAAS,aAAa,IAAI,mBAAmB,OAAO;CACtE;;;CAID,MAAc,qBAAqBV,QAAgBW,SAAwBF,aAA2C;AACrH,UAAQ,IAAI,4BAA4B;EAExC,MAAM,gBAAgB,wBAAwB,YAAY,WAAW,CAAC,MAAO,EAAC;AAE9E,MAAI,iBAAiB,MAAM;AAC1B,WAAQ,IAAI,KAAK,2CAA2C,cAAc;AAC1E;EACA;EAED,MAAM,WAAW,MAAM,QAAQ;EAE/B,MAAM,aAAa,wBAAwB,SAAS,WAAW,CAAC,cAAc,QAAQ,OAAQ,EAAC;AAE/F,MAAI,cAAc,MAAM;AACvB,WAAQ,IAAI,KAAK,0BAA0B,QAAQ,KAAK,cAAc;AACtE;EACA;AAED,aAAW,SAAS,cAAc;AAClC,QAAM,KAAK,cAAc,SAAS,SAAS;CAC3C;;;CAID,MAAc,4BAA4BD,SAA+C;AACxF,UAAQ,IAAI,KAAK,0BAA0B;AAE3C,MAAI,QAAQ,gBAAgB,QAAQ,QAAQ,OAAO,KAClD,QAAO,MAAM,KAAK,kBAAkB,QAAQ,IAAI;IAIhD,QAAO,MAAM,KAAK,aAAa,MAAM,QAAQ;CAE9C;;;;CAKD,MAAM,wBAAwBG,SAAwBC,UAAiD;EACtG,MAAM,WAAW,MAAM,QAAQ;AAC/B,WAAS,YAAY,SAAS;AAC9B,WAAS,UAAU,SAAS;AAC5B,WAAS,YAAY,SAAS;AAC9B,WAAS,UAAU,SAAS;AAC5B,WAAS,WAAW,SAAS;AAC7B,WAAS,WAAW,SAAS;AAC7B,WAAS,cAAc,SAAS;AAChC,WAAS,YAAY,SAAS;AAC9B,WAAS,aAAa,SAAS;AAC/B,WAAS,eAAe,SAAS;AACjC,SAAO,MAAM,KAAK,cAAc,SAAS,SAAS;CAClD;CAED,MAAM,cAAcD,SAAwBvC,UAAiD;EAC5F,MAAM,CAAC,QAAQ,UAAU,GAAG,MAAM,QAAQ,IAAI,CAC7C,KAAK,WAAW,QAAQ,YAAY,KAAK,OAAO,mBAAmB,CAAC,KAAK,EACzE,KAAK,aAAa,KAAwB,0BAA0B,cAAc,QAAQ,YAAY,CAAC,AACvG,EAAC;EACF,MAAM,aAAa,OAAO,IAAI,CAAC,MAAM,EAAE,UAAU;AACjD,SAAO,MAAM,KAAK,YAAY,UAAU,YAAY,IAAI,WAAW,QAAQ;CAC3E;CAED,MAAM,OAAsB;AAC3B,QAAM,KAAK,uBAAuB;AAClC,QAAM,KAAK,+BAA+B;CAC1C;CAED,MAAM,wBAAuC;AAC5C,OAAK,KAAK,oBAAoB,CAAE;EAEhC,MAAM,iBAAiB,KAAK,aAAa,yBAAyB;AAClE,MAAI,kBAAkB,eAAe,SACpC,QAAO,QAAQ,IAAI,oDAAoD;EAGxE,MAAM,kBAAkB,MAAM,KAAK,eAAe,iBAAiB;EACnE,MAAMyC,YAA4B,MAAM,KAAK,gBAAgB;AAC7D,OAAK,IAAI,EAAE,OAAO,gBAAgB,IAAI,gBACrC,MAAK,IAAI,iBAAiB,eACzB,MAAK,sBAAsB,OAAO,eAAe,UAAU;CAG7D;CAED,MAAM,WAAWC,YAA4BC,MAA2C;EACvF,MAAM,EAAE,eAAe,GAAG;AAE1B,MAAI,iBAAiB,KACpB,QAAO,CAAE;EAGV,MAAM,MAAM,WAAW,OAAO,CAAC,gBAAgB,SAAS,WAAW,YAAY,EAAE,cAAc,OAAO,CAAC;AAEvG,MAAI,IAAI,WAAW,EAClB,QAAO,CAAE;AAGV,SAAO,KAAK,aAAa,aAAa,sBAAsB,WAAW,IAAI,GAAG,EAAE,IAAI,IAAI,cAAc,CAAC;CACvG;CAED,MAAM,eAAeC,UAAuC;AAC3D,QAAM,KAAK,eAAe,eAAe,SAAS,UAAU,IAAI;AAChE,OAAK,aAAa,eAAe,SAAS,MAAM,IAAI;CACpD;CAED,MAAM,eAAejB,KAAyD;AAC7E,SAAO,KAAK,eAAe,eAAe,IAAI;CAC9C;CAED,MAAc,qBAAqBkB,SAA0CC,mBAAsC;EAClH,MAAM,gBAAgB,MAAM,KAAK,cAAc,UAAU;EAEzD,MAAMC,uBAAwC,CAAE;AAChD,OAAK,MAAM,mBAAmB,QAG7B,KAAI,mBAAmB,sBAAsB,gBAAgB,KAAK,OAAO,EACxE;OAAI,gBAAgB,cAAc,cAAc,OAQ/C,KAAI;IACH,MAAM,gBAAgB,MAAM,KAAK,aAAa,KAAK,sBAAsB,CAAC,gBAAgB,gBAAgB,gBAAgB,UAAW,EAAC;AACtI,yBAAqB,KAAK,cAAc;IACxC,MAAM,gBAAgB,KAAK,uBAAuB,cAAc,UAAU,YAAY,UAAU;AAChG,kBAAc;GACd,SAAQ,GAAG;AACX,QAAI,aAAa,cAChB,SAAQ,IAAI,KAAK,GAAG,mCAAmC,iBAAiB,EAAE;IAE1E,OAAM;GAEP;SACS,gBAAgB,cAAc,cAAc,WAAW,OAAO,CACxE,OAAM,KAAK,oBAAoB,gBAAgB,WAAW;EAC1D,WACS,mBAAmB,sBAAsB,gBAAgB,EACnE;OAAI,gBAAgB,cAAc,cAAc,UAAU,gBAAgB,cAAc,cAAc,QAAQ;IAC7G,MAAM,gBAAgB,KAAK,uBAAuB,gBAAgB,WAAW;AAC7E,kBAAc,SAAS,QAAQ,UAAU;GACzC;aACS,mBAAmB,4BAA4B,gBAAgB,IAAI,gBAAgB,cAAc,cAAc,OACzH,KAAI;GACH,MAAM,SAAS,MAAM,KAAK,aAAa,KAAK,4BAA4B,CAAC,gBAAgB,gBAAgB,gBAAgB,UAAW,EAAC;AACrI,SAAM,KAAK,0BAA0B,OAAO;EAC5C,SAAQ,GAAG;AACX,OAAI,aAAa,cAChB,SAAQ,IAAI,KAAK,oBAAoB,CAAC,gBAAgB,gBAAgB,gBAAgB,UAAW,GAAE,EAAE;IAErG,OAAM;EAEP;SACS,mBAAmB,aAAa,gBAAgB,EAAE;GAG5D,MAAM,6BAA6B,KAAK,oCAAoC,IAAI,gBAAgB,WAAW;AAC3G,OAAI,2BACH,KAAI;AACH,UAAM,KAAK,0BAA0B,2BAA2B;GAChE,SAAQ,GAAG;AACX,QAAI,aAAa,cAChB,SAAQ,IAAI,KAAK,oBAAoB,CAAC,gBAAgB,gBAAgB,gBAAgB,UAAW,GAAE,EAAE;IAErG,OAAM;GAEP,UAAS;AACT,SAAK,oCAAoC,OAAO,gBAAgB,WAAW;GAC3E;EAEF,WAAU,KAAK,OAAO,mBAAmB,CAAC,gCAAgC,iBAAiB,kBAAkB,EAAE;GAC/G,MAAM,sBAAsB,KAAK,OAAO,mBAAmB,CAAC,wBAAwB;GACpF,MAAM,cAAc,IAAI,IAAI,cAAc,MAAM;GAChD,MAAM,cAAc,IAAI,IAAI,oBAAoB,IAAI,CAAC,MAAM,EAAE,MAAM;GACnE,MAAM,OAAO,oBAAoB,aAAa,YAAY;AAE1D,OAAI,KAAK,SAAS,EACjB,MAAK,cAAc,QAAQ;EAE5B,WAAU,mBAAmB,kBAAkB,gBAAgB,EAE/D;QAAK,MAAM,EAAE,WAAW,IAAI,cAAc,QAAQ,CACjD,KAAI,YAAY,WAAW,gBAAgB,EAAE;AAC5C,SAAK,cAAc,QAAQ;AAC3B;GACA;EACD;AAIH,OAAK,OAAO,EAAE;GACb,MAAM,iBAAiB,KAAK,aAAa,yBAAyB;AAClE,OAAI,kBAAkB,eAAe,SACpC,QAAO,QAAQ,IAAI,oDAAoD;EAExE;AAGD,OAAK,MAAM,iBAAiB,sBAAsB;GACjD,MAAM,EAAE,QAAQ,WAAW,GAAG,cAAc,UAAU;GACtD,MAAM,gBAAgB,KAAK,uBAAuB,UAAU;AAI5D,iBAAc,SAAS,UAAU,cAAc,SAAS,QAAQ,KAAK,YAAY;AAChF,kBAAc;AACd,QAAI,cAAc,wBAAwB,EACzC,MAAK,qBAAqB,OAAO,UAAU;IAE5C,MAAM,gBAAgB,MAAM,KAAK,aAAa,KAAK,sBAAsB,CAAC,QAAQ,SAAU,EAAC;IAC7F,MAAM,YAAY,MAAM,KAAK,gBAAgB;AAC7C,QAAI;AACH,UAAK,sBAAsB,eAAe,eAAe,UAAU;IACnE,SAAQ,GAAG;AACX,SAAI,aAAa,cAChB,SAAQ,IAAI,KAAK,mBAAmB,CAAC,QAAQ,SAAU,EAAC;IAExD,OAAM;IAEP;GACD,EAAC;EACF;CACD;CAED,AAAQ,uBAAuBC,WAAmB;AACjD,SAAO,WAAW,KAAK,sBAAsB,WAAW,OAAO;GAAE,qBAAqB;GAAG,UAAU,OAAO;EAAE,GAAE;CAC9G;CAED,AAAQ,qBAA8B;AACrC,UAAQ,OAAO,KAAK,WAAW,IAAI,KAAK,OAAO,wBAAwB,KAAK,KAAK,OAAO,UAAU,YAAY,gBAAgB;CAC9H;CAED,AAAQ,sBAAsBlE,OAAsBmE,eAA8BR,WAAiC;AAClH,OAAK,qBAAqB,IAAI,aAAa,cAAc,EAAE,cAAc,UAAU,gBAAgB;AAEnG,YAAU,cAAc,OAAO,cAAc,WAAW,MAAM,YAAY,CAAC,WAAW,YAAY;GACjG,MAAM,EAAE,OAAO,MAAM,GAAG,6BAA6B,WAAW,QAAQ;AACxE,QAAK,cAAc,iBAClB,iBAAiB,UACjB,OACA,EACC,KACA,GACD,MAAM,gBAAE,MAAM,IAAI,YAAY,CAC9B;EACD,EAAC;CACF;CAED,MAAc,oBAAoBS,iBAAmC;EACpE,MAAM,aAAa,KAAK,qBAAqB,IAAI,gBAAgB;AAEjE,MAAI,YAAY;GACf,MAAM,iBAAiB,MAAM,KAAK,gBAAgB;AAClD,kBAAe,YAAY,WAAW;EACtC;CACD;CAGD,yCAAuE;AACtE,SAAO,KAAK;CACZ;CAED,sBAAsBC,aAAqB;AAC1C,SAAO,KAAK,IAAI,uBAAuB,EACtC,UAAU,YACV,EAAC;CACF;CAED,aAAaC,KAAa;AACzB,SAAO,KAAK,IAAI,0BAA0B,EAAE,SAAS,IAAK,EAAC;CAC3D;AACD;;;AAID,eAAe,mBAAmBpD,UAAyBE,eAA8BR,MAAgC;CACxH,MAAM,EAAE,aAAa,GAAG,MAAM,OAAO;AACrC,QAAO,YAAY,UAAU,KAAK,KAAK,YAAY,eAAe,KAAK;AACvE;IAQK,4CAAN,cAAwD,cAAc;CACrE,YAAY2D,SAAiB;AAC5B,QAAM,6CAA6C,QAAQ;CAC3D;AACD;;;;AAKD,UAAU,gCAAgChE,iBAAkCiE,gBAA6D;CAGxI,MAAM,kBAAkB;CACxB,MAAM,YAAY,eAAe,wBAAwB,CAAC,SAAS;CAEnE,MAAM,gBAAgB,gBAAgB,oBAAoB,UAAU;CACpE,MAAM,cAAc,cAAc,gBAAgB,WAAW,cAAc,CAAC;AAC5E,OAAM;AACN,QAAO,KACN,OAAM,IAAI;AAEX;AAEM,SAAS,6BAA6BC,WAAiBC,SAAkD;CAC/G,IAAIC;AAEJ,KAAI,UAAU,WAAW,IAAI,OAAO,CACnC,cAAa,WAAW,UAAU;IAElC,cAAa,6BAA6B,UAAU;CAGrD,MAAM,QAAQ,EAAE,WAAW,GAAG,QAAQ;AAEtC,QAAO;EAAE;EAAM,OAAO;CAAM;AAC5B;AAED,eAAe,cAAc1D,WAA6D;AACzF,QAAO,QAAQ,IAAI,CAClB,QAAQ,aAAa,QAAQ,sBAAsB,UAAU,WAAW,EACxE,QAAQ,aAAa,QAAQ,sBAAsB,UAAU,YAAY,AACzE,EAAC,CAAC,KAAK,CAAC,YAAY,QAAQ,MAAM,CAAC;AACpC"}