
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { arrayEquals, assertNotNull, base64ToBase64Ext, base64ToBase64Url, base64ToUint8Array, base64UrlToBase64, defer, hexToUint8Array, neverNull, ofClass, uint8ArrayToBase64, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertWorkerOrNode, isAdminClient } from "./Env-D5xGlXfw.js";
import { AccountType, CloseEventBusOption, Const, DEFAULT_KDF_TYPE, KdfType, asKdfType } from "./TutanotaConstants-3bwAESYA.js";
import { AccessExpiredError, ConnectionError, LockedError, NotAuthenticatedError, NotFoundError, SessionExpiredError } from "./RestError-D17JEBMr.js";
import { LoginIncompleteError } from "./LoginIncompleteError-CpiW0a0l.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { GENERATED_ID_BYTES_LENGTH, isSameId } from "./EntityUtils-RQxXZlcV.js";
import { TutanotaPropertiesTypeRef } from "./TypeRefs-CR3TLWn0.js";
import { GroupInfoTypeRef, RecoverCodeTypeRef, SessionTypeRef, UserTypeRef, createChangeKdfPostIn, createChangePasswordPostIn, createCreateSessionData, createDeleteCustomerData, createResetFactorsDeleteData, createSaltData, createSecondFactorAuthDeleteData, createSecondFactorAuthGetData, createTakeOverDeletedAddressData, createVerifierTokenServiceIn } from "./TypeRefs-BP1jvX9p.js";
import { HttpMethod, MediaType, resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import { EntityClient } from "./EntityClient-B0RSdk2i.js";
import { KeyLength, TotpVerifier, aes256DecryptWithRecoveryKey, aes256RandomKey, aesDecrypt, base64ToKey, createAuthVerifier, createAuthVerifierAsBase64Url, encryptKey, generateKeyFromPassphrase$1 as generateKeyFromPassphrase, generateRandomSalt, keyToUint8Array, sha256Hash, uint8ArrayToBitArray } from "./dist-DcZ1Y4qd.js";
import { ChangeKdfService, ChangePasswordService, CustomerService, ResetFactorsService, SaltService, SecondFactorAuthService, SessionService, TakeOverDeletedAddressService, VerifierTokenService } from "./Services-CZFE0084.js";
import { SessionType } from "./SessionType-rxSDsswH.js";
import { ConnectMode, EntityRestClient, typeRefToPath } from "./EntityRestClient--6dT7ZRF.js";
import { encryptString } from "./CryptoWrapper-BTtEczdP.js";
import { CredentialType } from "./CredentialType-DXeA2MQH.js";
import { LoginFailReason } from "./PageContextLoginListener-dgY8O-YX.js";

//#region ../src/common/api/worker/facades/LoginFacade.ts
assertWorkerOrNode();
let ResumeSessionErrorReason = function(ResumeSessionErrorReason$1) {
	ResumeSessionErrorReason$1[ResumeSessionErrorReason$1["OfflineNotAvailableForFree"] = 0] = "OfflineNotAvailableForFree";
	return ResumeSessionErrorReason$1;
}({});
var LoginFacade = class {
	eventBusClient;
	/**
	* Used for cancelling second factor and to not mix different attempts
	*/
	loginRequestSessionId = null;
	/**
	* Used for cancelling second factor immediately
	*/
	loggingInPromiseWrapper = null;
	/** On platforms with offline cache we do the actual login asynchronously and we can retry it. This is the state of such async login. */
	asyncLoginState = { state: "idle" };
	constructor(restClient, entityClient, loginListener, instanceMapper, cryptoFacade, keyRotationFacade, cacheInitializer, serviceExecutor, userFacade, blobAccessTokenFacade, entropyFacade, databaseKeyFactory, argon2idFacade, noncachingEntityClient, sendError, cacheManagementFacade) {
		this.restClient = restClient;
		this.entityClient = entityClient;
		this.loginListener = loginListener;
		this.instanceMapper = instanceMapper;
		this.cryptoFacade = cryptoFacade;
		this.keyRotationFacade = keyRotationFacade;
		this.cacheInitializer = cacheInitializer;
		this.serviceExecutor = serviceExecutor;
		this.userFacade = userFacade;
		this.blobAccessTokenFacade = blobAccessTokenFacade;
		this.entropyFacade = entropyFacade;
		this.databaseKeyFactory = databaseKeyFactory;
		this.argon2idFacade = argon2idFacade;
		this.noncachingEntityClient = noncachingEntityClient;
		this.sendError = sendError;
		this.cacheManagementFacade = cacheManagementFacade;
	}
	init(eventBusClient) {
		this.eventBusClient = eventBusClient;
	}
	async resetSession() {
		this.eventBusClient.close(CloseEventBusOption.Terminate);
		await this.deInitCache();
		this.userFacade.reset();
	}
	/**
	* Create session and log in. Changes internal state to refer to the logged in user.
	*/
	async createSession(mailAddress, passphrase, clientIdentifier, sessionType, databaseKey) {
		if (this.userFacade.isPartiallyLoggedIn()) console.log("session already exists, reuse data");
		const { userPassphraseKey, kdfType } = await this.loadUserPassphraseKey(mailAddress, passphrase);
		const authVerifier = createAuthVerifierAsBase64Url(userPassphraseKey);
		const createSessionData = createCreateSessionData({
			accessKey: null,
			authToken: null,
			authVerifier,
			clientIdentifier,
			mailAddress: mailAddress.toLowerCase().trim(),
			recoverCodeVerifier: null,
			user: null
		});
		let accessKey = null;
		if (sessionType === SessionType.Persistent) {
			accessKey = aes256RandomKey();
			createSessionData.accessKey = keyToUint8Array(accessKey);
		}
		const createSessionReturn = await this.serviceExecutor.post(SessionService, createSessionData);
		const sessionData = await this.waitUntilSecondFactorApprovedOrCancelled(createSessionReturn, mailAddress);
		const forceNewDatabase = sessionType === SessionType.Persistent && databaseKey == null;
		if (forceNewDatabase) {
			console.log("generating new database key for persistent session");
			databaseKey = await this.databaseKeyFactory.generateKey();
		}
		const cacheInfo = await this.initCache({
			userId: sessionData.userId,
			databaseKey,
			timeRangeDays: null,
			forceNewDatabase
		});
		const { user, userGroupInfo, accessToken } = await this.initSession(sessionData.userId, sessionData.accessToken, userPassphraseKey);
		const modernKdfType = this.isModernKdfType(kdfType);
		if (!modernKdfType) await this.migrateKdfType(KdfType.Argon2id, passphrase, user);
		const credentials = {
			login: mailAddress,
			accessToken,
			encryptedPassword: sessionType === SessionType.Persistent ? uint8ArrayToBase64(encryptString(neverNull(accessKey), passphrase)) : null,
			encryptedPassphraseKey: sessionType === SessionType.Persistent ? encryptKey(neverNull(accessKey), userPassphraseKey) : null,
			userId: sessionData.userId,
			type: CredentialType.Internal
		};
		this.loginListener.onFullLoginSuccess(sessionType, cacheInfo, credentials);
		if (!isAdminClient()) await this.keyRotationFacade.initialize(userPassphraseKey, modernKdfType);
		return {
			user,
			userGroupInfo,
			sessionId: sessionData.sessionId,
			credentials,
			databaseKey: cacheInfo.isPersistent ? databaseKey : null
		};
	}
	/**
	* Ensure that the user is using a modern KDF type, migrating if not.
	* @param targetKdfType the current KDF type
	* @param passphrase either the plaintext passphrase or the encrypted passphrase with the access token necessary to decrypt it
	* @param user the user we are updating
	*/
	async migrateKdfType(targetKdfType, passphrase, user) {
		if (!Const.EXECUTE_KDF_MIGRATION) return;
		const currentPassphraseKeyData = {
			passphrase,
			kdfType: asKdfType(user.kdfVersion),
			salt: assertNotNull(user.salt, `current salt for user ${user._id} not found`)
		};
		const currentUserPassphraseKey = await this.deriveUserPassphraseKey(currentPassphraseKeyData);
		const currentAuthVerifier = createAuthVerifier(currentUserPassphraseKey);
		const newPassphraseKeyData = {
			passphrase,
			kdfType: targetKdfType,
			salt: generateRandomSalt()
		};
		const newUserPassphraseKey = await this.deriveUserPassphraseKey(newPassphraseKeyData);
		const currentUserGroupKey = this.userFacade.getCurrentUserGroupKey();
		const pwEncUserGroupKey = encryptKey(newUserPassphraseKey, currentUserGroupKey.object);
		const newAuthVerifier = createAuthVerifier(newUserPassphraseKey);
		const changeKdfPostIn = createChangeKdfPostIn({
			kdfVersion: newPassphraseKeyData.kdfType,
			salt: newPassphraseKeyData.salt,
			pwEncUserGroupKey,
			verifier: newAuthVerifier,
			oldVerifier: currentAuthVerifier,
			userGroupKeyVersion: String(currentUserGroupKey.version)
		});
		console.log("Migrate KDF from:", user.kdfVersion, "to", targetKdfType);
		await this.serviceExecutor.post(ChangeKdfService, changeKdfPostIn);
		await (await this.cacheManagementFacade()).reloadUser();
		this.userFacade.setUserGroupKeyDistributionKey(newUserPassphraseKey);
	}
	/**
	* Checks if the given KDF type is phased out.
	* @param kdfType
	* @private
	*/
	isModernKdfType(kdfType) {
		return kdfType !== KdfType.Bcrypt;
	}
	/**
	* If the second factor login has been cancelled a CancelledError is thrown.
	*/
	waitUntilSecondFactorApprovedOrCancelled(createSessionReturn, mailAddress) {
		let p = Promise.resolve();
		let sessionId = [this.getSessionListId(createSessionReturn.accessToken), this.getSessionElementId(createSessionReturn.accessToken)];
		this.loginRequestSessionId = sessionId;
		if (createSessionReturn.challenges.length > 0) {
			this.loginListener.onSecondFactorChallenge(sessionId, createSessionReturn.challenges, mailAddress);
			p = this.waitUntilSecondFactorApproved(createSessionReturn.accessToken, sessionId, 0);
		}
		this.loggingInPromiseWrapper = defer();
		return Promise.race([this.loggingInPromiseWrapper.promise, p]).then(() => ({
			sessionId,
			accessToken: createSessionReturn.accessToken,
			userId: createSessionReturn.user
		}));
	}
	async waitUntilSecondFactorApproved(accessToken, sessionId, retryOnNetworkError) {
		let secondFactorAuthGetData = createSecondFactorAuthGetData({ accessToken });
		try {
			const secondFactorAuthGetReturn = await this.serviceExecutor.get(SecondFactorAuthService, secondFactorAuthGetData);
			if (!this.loginRequestSessionId || !isSameId(this.loginRequestSessionId, sessionId)) throw new CancelledError("login cancelled");
			if (secondFactorAuthGetReturn.secondFactorPending) return this.waitUntilSecondFactorApproved(accessToken, sessionId, 0);
		} catch (e) {
			if (e instanceof ConnectionError && retryOnNetworkError < 10) return this.waitUntilSecondFactorApproved(accessToken, sessionId, retryOnNetworkError + 1);
			throw e;
		}
	}
	/**
	* Create external (temporary mailbox for passphrase-protected emails) session and log in.
	* Changes internal state to refer to the logged-in user.
	*/
	async createExternalSession(userId, passphrase, salt, kdfType, clientIdentifier, persistentSession) {
		if (this.userFacade.isPartiallyLoggedIn()) throw new Error("user already logged in");
		const userPassphraseKey = await this.deriveUserPassphraseKey({
			kdfType,
			passphrase,
			salt
		});
		const authVerifier = createAuthVerifierAsBase64Url(userPassphraseKey);
		const authToken = base64ToBase64Url(uint8ArrayToBase64(sha256Hash(salt)));
		const sessionData = createCreateSessionData({
			accessKey: null,
			authToken,
			authVerifier,
			clientIdentifier,
			mailAddress: null,
			recoverCodeVerifier: null,
			user: userId
		});
		let accessKey = null;
		if (persistentSession) {
			accessKey = aes256RandomKey();
			sessionData.accessKey = keyToUint8Array(accessKey);
		}
		const createSessionReturn = await this.serviceExecutor.post(SessionService, sessionData);
		let sessionId = [this.getSessionListId(createSessionReturn.accessToken), this.getSessionElementId(createSessionReturn.accessToken)];
		const cacheInfo = await this.initCache({
			userId,
			databaseKey: null,
			timeRangeDays: null,
			forceNewDatabase: true
		});
		const { user, userGroupInfo, accessToken } = await this.initSession(createSessionReturn.user, createSessionReturn.accessToken, userPassphraseKey);
		const credentials = {
			login: userId,
			accessToken,
			encryptedPassword: accessKey ? uint8ArrayToBase64(encryptString(accessKey, passphrase)) : null,
			encryptedPassphraseKey: accessKey ? encryptKey(accessKey, userPassphraseKey) : null,
			userId,
			type: CredentialType.External
		};
		this.loginListener.onFullLoginSuccess(SessionType.Login, cacheInfo, credentials);
		return {
			user,
			userGroupInfo,
			sessionId,
			credentials,
			databaseKey: null
		};
	}
	/**
	* Derive a key given a KDF type, passphrase, and salt
	*/
	async deriveUserPassphraseKey({ kdfType, passphrase, salt }) {
		switch (kdfType) {
			case KdfType.Bcrypt: return generateKeyFromPassphrase(passphrase, salt, KeyLength.b128);
			case KdfType.Argon2id: return this.argon2idFacade.generateKeyFromPassphrase(passphrase, salt);
		}
	}
	/** Cancels 2FA process. */
	async cancelCreateSession(sessionId) {
		if (!this.loginRequestSessionId || !isSameId(this.loginRequestSessionId, sessionId)) throw new Error("Trying to cancel session creation but the state is invalid");
		const secondFactorAuthDeleteData = createSecondFactorAuthDeleteData({ session: sessionId });
		await this.serviceExecutor.delete(SecondFactorAuthService, secondFactorAuthDeleteData).catch(ofClass(NotFoundError, (e) => {
			console.warn("Tried to cancel second factor but it was not there anymore", e);
		})).catch(ofClass(LockedError, (e) => {
			console.warn("Tried to cancel second factor but it is currently locked", e);
		}));
		this.loginRequestSessionId = null;
		this.loggingInPromiseWrapper?.reject(new CancelledError("login cancelled"));
	}
	/** Finishes 2FA process either using second factor or approving session on another client. */
	async authenticateWithSecondFactor(data, host) {
		await this.serviceExecutor.post(SecondFactorAuthService, data, { baseUrl: host });
	}
	/**
	* Resumes previously created session (using persisted credentials).
	* @param credentials the saved credentials to use
	* @param externalUserKeyDeriver information for deriving a key (if external user)
	* @param databaseKey key to unlock the local database (if enabled)
	* @param timeRangeDays the user configured time range for the offline database
	*/
	async resumeSession(credentials, externalUserKeyDeriver, databaseKey, timeRangeDays) {
		if (this.userFacade.getUser() != null) throw new ProgrammingError(`Trying to resume the session for user ${credentials.userId} while already logged in for ${this.userFacade.getUser()?._id}`);
		if (this.asyncLoginState.state !== "idle") throw new ProgrammingError(`Trying to resume the session for user ${credentials.userId} while the asyncLoginState is ${this.asyncLoginState.state}`);
		this.userFacade.setAccessToken(credentials.accessToken);
		const cacheInfo = await this.initCache({
			userId: credentials.userId,
			databaseKey,
			timeRangeDays,
			forceNewDatabase: false
		});
		const sessionId = this.getSessionId(credentials);
		try {
			if (cacheInfo?.isPersistent && !cacheInfo.isNewOfflineDb) {
				const user = await this.entityClient.load(UserTypeRef, credentials.userId);
				if (user.accountType !== AccountType.PAID) return await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo).catch(ofClass(ConnectionError, async () => {
					await this.resetSession();
					return {
						type: "error",
						reason: ResumeSessionErrorReason.OfflineNotAvailableForFree
					};
				}));
				this.userFacade.setUser(user);
				let userGroupInfo;
				try {
					userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo);
				} catch (e) {
					console.log("Could not do start login, groupInfo is not cached, falling back to sync login");
					if (e instanceof LoginIncompleteError) return await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo);
else throw e;
				}
				Promise.resolve().then(() => this.asyncResumeSession(credentials, cacheInfo));
				const data = {
					user,
					userGroupInfo,
					sessionId
				};
				return {
					type: "success",
					data
				};
			} else return await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo);
		} catch (e) {
			await this.resetSession();
			throw e;
		}
	}
	getSessionId(credentials) {
		return [this.getSessionListId(credentials.accessToken), this.getSessionElementId(credentials.accessToken)];
	}
	async asyncResumeSession(credentials, cacheInfo) {
		if (this.asyncLoginState.state === "running") throw new Error("finishLoginResume run in parallel");
		this.asyncLoginState = { state: "running" };
		try {
			await this.finishResumeSession(credentials, null, cacheInfo);
		} catch (e) {
			if (e instanceof NotAuthenticatedError || e instanceof SessionExpiredError) {
				this.asyncLoginState = { state: "idle" };
				await this.loginListener.onLoginFailure(LoginFailReason.SessionExpired);
			} else {
				this.asyncLoginState = {
					state: "failed",
					credentials,
					cacheInfo
				};
				if (!(e instanceof ConnectionError)) await this.sendError(e);
				await this.loginListener.onLoginFailure(LoginFailReason.Error);
			}
		}
	}
	async finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo) {
		const sessionId = this.getSessionId(credentials);
		const sessionData = await this.loadSessionData(credentials.accessToken);
		const accessKey = assertNotNull(sessionData.accessKey, "no access key on session data!");
		const isExternalUser = externalUserKeyDeriver != null;
		let userPassphraseKey;
		let credentialsWithPassphraseKey;
		if (credentials.encryptedPassword) {
			const passphrase = utf8Uint8ArrayToString(aesDecrypt(accessKey, base64ToUint8Array(credentials.encryptedPassword)));
			if (isExternalUser) {
				await this.checkOutdatedExternalSalt(credentials, sessionData, externalUserKeyDeriver.salt);
				userPassphraseKey = await this.deriveUserPassphraseKey({
					...externalUserKeyDeriver,
					passphrase
				});
			} else {
				const passphraseData = await this.loadUserPassphraseKey(credentials.login, passphrase);
				userPassphraseKey = passphraseData.userPassphraseKey;
			}
			const encryptedPassphraseKey = encryptKey(accessKey, userPassphraseKey);
			credentialsWithPassphraseKey = {
				...credentials,
				encryptedPassphraseKey
			};
		} else throw new ProgrammingError("no key or password stored in credentials!");
		const { user, userGroupInfo } = await this.initSession(sessionData.userId, credentials.accessToken, userPassphraseKey);
		this.loginListener.onFullLoginSuccess(SessionType.Persistent, cacheInfo, credentialsWithPassphraseKey);
		this.asyncLoginState = { state: "idle" };
		const data = {
			user,
			userGroupInfo,
			sessionId
		};
		const modernKdfType = this.isModernKdfType(asKdfType(user.kdfVersion));
		if (!isExternalUser && credentials.encryptedPassword != null && !modernKdfType) {
			const passphrase = utf8Uint8ArrayToString(aesDecrypt(accessKey, base64ToUint8Array(credentials.encryptedPassword)));
			await this.migrateKdfType(KdfType.Argon2id, passphrase, user);
		}
		if (!isExternalUser && !isAdminClient()) await this.keyRotationFacade.initialize(userPassphraseKey, modernKdfType);
		return {
			type: "success",
			data
		};
	}
	async initSession(userId, accessToken, userPassphraseKey) {
		const userIdFromFormerLogin = this.userFacade.getUser()?._id ?? null;
		if (userIdFromFormerLogin && userId !== userIdFromFormerLogin) throw new Error("different user is tried to login in existing other user's session");
		this.userFacade.setAccessToken(accessToken);
		try {
			const user = await this.noncachingEntityClient.load(UserTypeRef, userId);
			await this.checkOutdatedVerifier(user, accessToken, userPassphraseKey);
			this.userFacade.setUser(user);
			const wasFullyLoggedIn = this.userFacade.isFullyLoggedIn();
			this.userFacade.unlockUserGroupKey(userPassphraseKey);
			const userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo);
			await this.loadEntropy();
			if (wasFullyLoggedIn) this.eventBusClient.connect(ConnectMode.Reconnect);
else this.eventBusClient.connect(ConnectMode.Initial);
			await this.entropyFacade.storeEntropy();
			return {
				user,
				accessToken,
				userGroupInfo
			};
		} catch (e) {
			this.resetSession();
			throw e;
		}
	}
	/**
	* init an appropriate cache implementation. we will always try to create a persistent cache for persistent sessions and fall back to an ephemeral cache
	* in the browser.
	*
	* @param userId the user for which the cache is created
	* @param databaseKey the key to use
	* @param timeRangeDays how far into the past the cache keeps data around
	* @param forceNewDatabase true if the old database should be deleted if there is one
	* @private
	*/
	async initCache({ userId, databaseKey, timeRangeDays, forceNewDatabase }) {
		if (databaseKey != null) return {
			databaseKey,
			...await this.cacheInitializer.initialize({
				type: "offline",
				userId,
				databaseKey,
				timeRangeDays,
				forceNewDatabase
			})
		};
else return {
			databaseKey: null,
			...await this.cacheInitializer.initialize({
				type: "ephemeral",
				userId
			})
		};
	}
	async deInitCache() {
		return this.cacheInitializer.deInitialize();
	}
	/**
	* Check whether the passed salt for external user is up-to-date (whether an outdated link was used).
	*/
	async checkOutdatedExternalSalt(credentials, sessionData, externalUserSalt) {
		this.userFacade.setAccessToken(credentials.accessToken);
		const user = await this.entityClient.load(UserTypeRef, sessionData.userId);
		const latestSaltHash = assertNotNull(user.externalAuthInfo.latestSaltHash, "latestSaltHash is not set!");
		if (!arrayEquals(latestSaltHash, sha256Hash(externalUserSalt))) {
			this.resetSession();
			throw new AccessExpiredError("Salt changed, outdated link?");
		}
	}
	/**
	* Check that the auth verifier is not changed e.g. due to the password change.
	* Normally this won't happen for internal users as all sessions are closed on password change. This may happen for external users when the sender has
	* changed the password.
	* We do not delete all sessions on the server when changing the external password to avoid that an external user is immediately logged out.
	*
	* @param user Should be up-to-date, i.e., not loaded from cache, but fresh from the server, otherwise an outdated verifier will cause a logout.
	*/
	async checkOutdatedVerifier(user, accessToken, userPassphraseKey) {
		if (uint8ArrayToBase64(user.verifier) !== uint8ArrayToBase64(sha256Hash(createAuthVerifier(userPassphraseKey)))) {
			console.log("Auth verifier has changed");
			await this.deleteSession(accessToken).catch((e) => console.error("Could not delete session", e));
			await this.resetSession();
			throw new NotAuthenticatedError("Auth verifier has changed");
		}
	}
	async loadUserPassphraseKey(mailAddress, passphrase) {
		mailAddress = mailAddress.toLowerCase().trim();
		const saltRequest = createSaltData({ mailAddress });
		const saltReturn = await this.serviceExecutor.get(SaltService, saltRequest);
		const kdfType = asKdfType(saltReturn.kdfVersion);
		return {
			userPassphraseKey: await this.deriveUserPassphraseKey({
				kdfType,
				passphrase,
				salt: saltReturn.salt
			}),
			kdfType
		};
	}
	/**
	* We use the accessToken that should be deleted for authentication. Therefore it can be invoked while logged in or logged out.
	*
	* @param pushIdentifier identifier associated with this device, if any, to delete PushIdentifier on the server
	*/
	async deleteSession(accessToken, pushIdentifier = null) {
		let path = typeRefToPath(SessionTypeRef) + "/" + this.getSessionListId(accessToken) + "/" + this.getSessionElementId(accessToken);
		const sessionTypeModel = await resolveTypeReference(SessionTypeRef);
		const headers = {
			accessToken: neverNull(accessToken),
			v: sessionTypeModel.version
		};
		const queryParams = pushIdentifier == null ? {} : { pushIdentifier };
		return this.restClient.request(path, HttpMethod.DELETE, {
			headers,
			responseType: MediaType.Json,
			queryParams
		}).catch(ofClass(NotAuthenticatedError, () => {
			console.log("authentication failed => session is already closed");
		})).catch(ofClass(NotFoundError, () => {
			console.log("authentication failed => session instance is already deleted");
		}));
	}
	getSessionElementId(accessToken) {
		let byteAccessToken = base64ToUint8Array(base64UrlToBase64(neverNull(accessToken)));
		return base64ToBase64Url(uint8ArrayToBase64(sha256Hash(byteAccessToken.slice(GENERATED_ID_BYTES_LENGTH))));
	}
	getSessionListId(accessToken) {
		let byteAccessToken = base64ToUint8Array(base64UrlToBase64(neverNull(accessToken)));
		return base64ToBase64Ext(uint8ArrayToBase64(byteAccessToken.slice(0, GENERATED_ID_BYTES_LENGTH)));
	}
	async loadSessionData(accessToken) {
		const path = typeRefToPath(SessionTypeRef) + "/" + this.getSessionListId(accessToken) + "/" + this.getSessionElementId(accessToken);
		const SessionTypeModel = await resolveTypeReference(SessionTypeRef);
		let headers = {
			accessToken,
			v: SessionTypeModel.version
		};
		return this.restClient.request(path, HttpMethod.GET, {
			headers,
			responseType: MediaType.Json
		}).then((instance) => {
			let session = JSON.parse(instance);
			return {
				userId: session.user,
				accessKey: session.accessKey ? base64ToKey(session.accessKey) : null
			};
		});
	}
	/**
	* Loads entropy from the last logout.
	*/
	async loadEntropy() {
		const tutanotaProperties = await this.entityClient.loadRoot(TutanotaPropertiesTypeRef, this.userFacade.getUserGroupId());
		return this.entropyFacade.loadEntropy(tutanotaProperties);
	}
	/**
	* Change password and/or KDF type for the current user. This will cause all other sessions to be closed.
	* @return New password encrypted with accessKey if this is a persistent session or {@code null}  if it's an ephemeral one.
	*/
	async changePassword(currentPasswordKeyData, newPasswordKeyDataTemplate) {
		const currentUserPassphraseKey = await this.deriveUserPassphraseKey(currentPasswordKeyData);
		const currentAuthVerifier = createAuthVerifier(currentUserPassphraseKey);
		const newPasswordKeyData = {
			...newPasswordKeyDataTemplate,
			salt: generateRandomSalt()
		};
		const newUserPassphraseKey = await this.deriveUserPassphraseKey(newPasswordKeyData);
		const currentUserGroupKey = this.userFacade.getCurrentUserGroupKey();
		const pwEncUserGroupKey = encryptKey(newUserPassphraseKey, currentUserGroupKey.object);
		const authVerifier = createAuthVerifier(newUserPassphraseKey);
		const service = createChangePasswordPostIn({
			code: null,
			kdfVersion: newPasswordKeyDataTemplate.kdfType,
			oldVerifier: currentAuthVerifier,
			pwEncUserGroupKey,
			recoverCodeVerifier: null,
			salt: newPasswordKeyData.salt,
			verifier: authVerifier,
			userGroupKeyVersion: String(currentUserGroupKey.version)
		});
		await this.serviceExecutor.post(ChangePasswordService, service);
		this.userFacade.setUserGroupKeyDistributionKey(newUserPassphraseKey);
		const accessToken = assertNotNull(this.userFacade.getAccessToken());
		const sessionData = await this.loadSessionData(accessToken);
		if (sessionData.accessKey != null) {
			const newEncryptedPassphrase = uint8ArrayToBase64(encryptString(sessionData.accessKey, newPasswordKeyDataTemplate.passphrase));
			const newEncryptedPassphraseKey = encryptKey(sessionData.accessKey, newUserPassphraseKey);
			return {
				newEncryptedPassphrase,
				newEncryptedPassphraseKey
			};
		} else return null;
	}
	async deleteAccount(password, takeover, surveyData = null) {
		const userSalt = assertNotNull(this.userFacade.getLoggedInUser().salt);
		const passphraseKeyData = {
			kdfType: asKdfType(this.userFacade.getLoggedInUser().kdfVersion),
			passphrase: password,
			salt: userSalt
		};
		const passwordKey = await this.deriveUserPassphraseKey(passphraseKeyData);
		const deleteCustomerData = createDeleteCustomerData({
			authVerifier: createAuthVerifier(passwordKey),
			reason: null,
			takeoverMailAddress: null,
			undelete: false,
			customer: neverNull(neverNull(this.userFacade.getLoggedInUser()).customer),
			surveyData
		});
		if (takeover !== "") deleteCustomerData.takeoverMailAddress = takeover;
else deleteCustomerData.takeoverMailAddress = null;
		await this.serviceExecutor.delete(CustomerService, deleteCustomerData);
	}
	/** Changes user password to another one using recoverCode instead of the old password. */
	async recoverLogin(mailAddress, recoverCode, newPassword, clientIdentifier) {
		const recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode));
		const recoverCodeVerifier = createAuthVerifier(recoverCodeKey);
		const recoverCodeVerifierBase64 = base64ToBase64Url(uint8ArrayToBase64(recoverCodeVerifier));
		const sessionData = createCreateSessionData({
			accessKey: null,
			authToken: null,
			authVerifier: null,
			clientIdentifier,
			mailAddress: mailAddress.toLowerCase().trim(),
			recoverCodeVerifier: recoverCodeVerifierBase64,
			user: null
		});
		const tempAuthDataProvider = {
			createAuthHeaders() {
				return {};
			},
			isFullyLoggedIn() {
				return false;
			}
		};
		const eventRestClient = new EntityRestClient(tempAuthDataProvider, this.restClient, () => this.cryptoFacade, this.instanceMapper, this.blobAccessTokenFacade);
		const entityClient = new EntityClient(eventRestClient);
		const createSessionReturn = await this.serviceExecutor.post(SessionService, sessionData);
		const { userId, accessToken } = await this.waitUntilSecondFactorApprovedOrCancelled(createSessionReturn, null);
		const user = await entityClient.load(UserTypeRef, userId, { extraHeaders: { accessToken } });
		if (user.auth == null || user.auth.recoverCode == null) throw new Error("missing recover code");
		const recoverCodeExtraHeaders = {
			accessToken,
			recoverCodeVerifier: recoverCodeVerifierBase64
		};
		const recoverCodeData = await entityClient.load(RecoverCodeTypeRef, user.auth.recoverCode, { extraHeaders: recoverCodeExtraHeaders });
		try {
			const groupKey = aes256DecryptWithRecoveryKey(recoverCodeKey, recoverCodeData.recoverCodeEncUserGroupKey);
			const salt = generateRandomSalt();
			const newKdfType = DEFAULT_KDF_TYPE;
			const newPassphraseKeyData = {
				kdfType: newKdfType,
				passphrase: newPassword,
				salt
			};
			const userPassphraseKey = await this.deriveUserPassphraseKey(newPassphraseKeyData);
			const pwEncUserGroupKey = encryptKey(userPassphraseKey, groupKey);
			const newPasswordVerifier = createAuthVerifier(userPassphraseKey);
			const postData = createChangePasswordPostIn({
				code: null,
				kdfVersion: newKdfType,
				oldVerifier: null,
				salt,
				pwEncUserGroupKey,
				verifier: newPasswordVerifier,
				recoverCodeVerifier,
				userGroupKeyVersion: recoverCodeData.userKeyVersion
			});
			const extraHeaders = { accessToken };
			await this.serviceExecutor.post(ChangePasswordService, postData, { extraHeaders });
		} finally {
			this.deleteSession(accessToken);
		}
	}
	/** Deletes second factors using recoverCode as second factor. */
	resetSecondFactors(mailAddress, password, recoverCode) {
		return this.loadUserPassphraseKey(mailAddress, password).then((passphraseReturn) => {
			const authVerifier = createAuthVerifierAsBase64Url(passphraseReturn.userPassphraseKey);
			const recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode));
			const recoverCodeVerifier = createAuthVerifierAsBase64Url(recoverCodeKey);
			const deleteData = createResetFactorsDeleteData({
				mailAddress,
				authVerifier,
				recoverCodeVerifier
			});
			return this.serviceExecutor.delete(ResetFactorsService, deleteData);
		});
	}
	takeOverDeletedAddress(mailAddress, password, recoverCode, targetAccountMailAddress) {
		return this.loadUserPassphraseKey(mailAddress, password).then((passphraseReturn) => {
			const authVerifier = createAuthVerifierAsBase64Url(passphraseReturn.userPassphraseKey);
			let recoverCodeVerifier = null;
			if (recoverCode) {
				const recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode));
				recoverCodeVerifier = createAuthVerifierAsBase64Url(recoverCodeKey);
			}
			let data = createTakeOverDeletedAddressData({
				mailAddress,
				authVerifier,
				recoverCodeVerifier,
				targetAccountMailAddress
			});
			return this.serviceExecutor.post(TakeOverDeletedAddressService, data);
		});
	}
	generateTotpSecret() {
		return this.getTotpVerifier().then((totp) => totp.generateSecret());
	}
	generateTotpCode(time, key) {
		return this.getTotpVerifier().then((totp) => totp.generateTotp(time, key));
	}
	getTotpVerifier() {
		return Promise.resolve(new TotpVerifier());
	}
	async retryAsyncLogin() {
		if (this.asyncLoginState.state === "running") return;
else if (this.asyncLoginState.state === "failed") await this.asyncResumeSession(this.asyncLoginState.credentials, this.asyncLoginState.cacheInfo);
else throw new Error("credentials went missing");
	}
	/**
	* Returns a verifier token, which is proof of password authentication and is valid for a limited time.
	* This token will have to be passed back to the server with the appropriate call.
	*/
	async getVerifierToken(passphrase) {
		const user = this.userFacade.getLoggedInUser();
		const passphraseKey = await this.deriveUserPassphraseKey({
			kdfType: asKdfType(user.kdfVersion),
			passphrase,
			salt: assertNotNull(user.salt)
		});
		const authVerifier = createAuthVerifier(passphraseKey);
		const out = await this.serviceExecutor.post(VerifierTokenService, createVerifierTokenServiceIn({ authVerifier }));
		return out.token;
	}
};

//#endregion
export { LoginFacade, ResumeSessionErrorReason };
//# sourceMappingURL=LoginFacade-zvyZiAr1.js.map