
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { LazyLoaded, assertNotNull, concat, downcast, isSameTypeRefByAttr, stringToUtf8Uint8Array, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import { ExternalImageRule, OperationType } from "./TutanotaConstants-3bwAESYA.js";
import { DbError } from "./DbError-CcwZaPG2.js";
import { UserTypeRef } from "./TypeRefs-BP1jvX9p.js";
import { IV_BYTE_LENGTH, aes256RandomKey, aesEncrypt, decryptKey, random, unauthenticatedAesDecrypt } from "./dist-DcZ1Y4qd.js";
import { encryptKeyWithVersionedKey } from "./CryptoWrapper-BTtEczdP.js";
import { DbFacade, b64UserIdHash } from "./DbFacade-DYw6Nyfw.js";
import { Metadata } from "./IndexTables-C5S9WDY9.js";

//#region ../src/common/api/worker/facades/lazy/ConfigurationDatabase.ts
const VERSION = 2;
const DB_KEY_PREFIX = "ConfigStorage";
const ExternalImageListOS = "ExternalAllowListOS";
const ConfigurationMetaDataOS = "MetaDataOS";
async function encryptItem(item, key, iv) {
	return aesEncrypt(key, stringToUtf8Uint8Array(item), iv, true);
}
async function decryptLegacyItem(encryptedAddress, key, iv) {
	return utf8Uint8ArrayToString(unauthenticatedAesDecrypt(key, concat(iv, encryptedAddress)));
}
var ConfigurationDatabase = class {
	db;
	constructor(keyLoaderFacade, userFacade, dbLoadFn = (user, keyLoaderFacade$1) => this.loadConfigDb(user, keyLoaderFacade$1)) {
		this.keyLoaderFacade = keyLoaderFacade;
		this.db = new LazyLoaded(() => {
			const user = assertNotNull(userFacade.getLoggedInUser());
			return dbLoadFn(user, keyLoaderFacade);
		});
	}
	async addExternalImageRule(address, rule) {
		const { db, metaData } = await this.db.getAsync();
		if (!db.indexingSupported) return;
		const encryptedAddress = await encryptItem(address, metaData.key, metaData.iv);
		return addAddressToImageList(db, encryptedAddress, rule);
	}
	async getExternalImageRule(address) {
		const { db, metaData } = await this.db.getAsync();
		if (!db.indexingSupported) return ExternalImageRule.None;
		const encryptedAddress = await encryptItem(address, metaData.key, metaData.iv);
		const transaction = await db.createTransaction(true, [ExternalImageListOS]);
		const entry = await transaction.get(ExternalImageListOS, encryptedAddress);
		let rule = ExternalImageRule.None;
		if (entry != null) if (entry.rule != null) rule = entry.rule;
else {
			await addAddressToImageList(db, encryptedAddress, ExternalImageRule.Allow);
			rule = ExternalImageRule.Allow;
		}
		return rule;
	}
	async loadConfigDb(user, keyLoaderFacade) {
		const id = this.getDbId(user._id);
		const db = new DbFacade(VERSION, async (event, db$1, dbFacade) => {
			if (event.oldVersion === 0) {
				db$1.createObjectStore(ConfigurationMetaDataOS);
				db$1.createObjectStore(ExternalImageListOS, { keyPath: "address" });
			}
			const metaData$1 = await loadEncryptionMetadata(dbFacade, id, keyLoaderFacade, ConfigurationMetaDataOS) || await initializeDb(dbFacade, id, keyLoaderFacade, ConfigurationMetaDataOS);
			if (event.oldVersion === 1) {
				const transaction = await dbFacade.createTransaction(true, [ExternalImageListOS]);
				const entries = await transaction.getAll(ExternalImageListOS);
				const { key, iv } = metaData$1;
				for (const entry of entries) {
					const address = await decryptLegacyItem(new Uint8Array(downcast(entry.key)), key, iv);
					await this.addExternalImageRule(address, entry.value.rule);
					const deleteTransaction = await dbFacade.createTransaction(false, [ExternalImageListOS]);
					await deleteTransaction.delete(ExternalImageListOS, entry.key);
				}
			}
		});
		const metaData = await loadEncryptionMetadata(db, id, keyLoaderFacade, ConfigurationMetaDataOS) || await initializeDb(db, id, keyLoaderFacade, ConfigurationMetaDataOS);
		return {
			db,
			metaData
		};
	}
	async onEntityEventsReceived(batch) {
		const { events, groupId, batchId } = batch;
		for (const event of events) {
			if (!(event.operation === OperationType.UPDATE && isSameTypeRefByAttr(UserTypeRef, event.application, event.type))) continue;
			const configDb = await this.db.getAsync();
			if (configDb.db.isSameDbId(this.getDbId(event.instanceId))) return updateEncryptionMetadata(configDb.db, this.keyLoaderFacade, ConfigurationMetaDataOS);
		}
	}
	async delete(userId) {
		const dbId = this.getDbId(userId);
		if (this.db.isLoadedOrLoading()) {
			const { db } = await this.db.getAsync();
			await db.deleteDatabase(dbId);
		} else await DbFacade.deleteDb(dbId);
	}
	getDbId(userId) {
		return `${DB_KEY_PREFIX}_${b64UserIdHash(userId)}`;
	}
};
async function decryptMetaData(keyLoaderFacade, metaData) {
	const userGroupKey = await keyLoaderFacade.loadSymUserGroupKey(metaData.userGroupKeyVersion);
	const key = decryptKey(userGroupKey, metaData.userEncDbKey);
	const iv = unauthenticatedAesDecrypt(key, metaData.encDbIv);
	return {
		key,
		iv
	};
}
async function loadEncryptionMetadata(db, id, keyLoaderFacade, objectStoreName) {
	await db.open(id);
	const metaData = await getMetaData(db, objectStoreName);
	if (metaData != null) return await decryptMetaData(keyLoaderFacade, metaData);
else return null;
}
async function updateEncryptionMetadata(db, keyLoaderFacade, objectStoreName) {
	const metaData = await getMetaData(db, objectStoreName);
	const currentUserGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey();
	if (metaData == null || currentUserGroupKey.version === metaData.userGroupKeyVersion) return;
	const encryptionMetadata = await decryptMetaData(keyLoaderFacade, metaData);
	if (encryptionMetadata == null) return;
	const { key, iv } = encryptionMetadata;
	await encryptAndSaveDbKey(currentUserGroupKey, key, iv, db, objectStoreName);
}
async function getMetaData(db, objectStoreName) {
	const transaction = await db.createTransaction(true, [objectStoreName]);
	const userEncDbKey = await transaction.get(objectStoreName, Metadata.userEncDbKey);
	const encDbIv = await transaction.get(objectStoreName, Metadata.encDbIv);
	const userGroupKeyVersion = await transaction.get(objectStoreName, Metadata.userGroupKeyVersion) ?? 0;
	if (userEncDbKey == null || encDbIv == null) return null;
else return {
		userEncDbKey,
		encDbIv,
		userGroupKeyVersion
	};
}
async function getIndexerMetaData(db, objectStoreName) {
	const transaction = await db.createTransaction(true, [objectStoreName]);
	const userEncDbKey = await transaction.get(objectStoreName, Metadata.userEncDbKey);
	const encDbIv = await transaction.get(objectStoreName, Metadata.encDbIv);
	const userGroupKeyVersion = await transaction.get(objectStoreName, Metadata.userGroupKeyVersion) ?? 0;
	const mailIndexingEnabled = await transaction.get(objectStoreName, Metadata.mailIndexingEnabled);
	const excludedListIds = await transaction.get(objectStoreName, Metadata.excludedListIds);
	const lastEventIndexTimeMs = await transaction.get(objectStoreName, Metadata.lastEventIndexTimeMs);
	if (userEncDbKey == null || encDbIv == null) return null;
else return {
		userEncDbKey,
		encDbIv,
		userGroupKeyVersion,
		mailIndexingEnabled,
		excludedListIds,
		lastEventIndexTimeMs
	};
}
async function encryptAndSaveDbKey(userGroupKey, dbKey, dbIv, db, objectStoreName) {
	const transaction = await db.createTransaction(false, [objectStoreName]);
	const groupEncSessionKey = encryptKeyWithVersionedKey(userGroupKey, dbKey);
	await transaction.put(objectStoreName, Metadata.userEncDbKey, groupEncSessionKey.key);
	await transaction.put(objectStoreName, Metadata.userGroupKeyVersion, groupEncSessionKey.encryptingKeyVersion);
	await transaction.put(objectStoreName, Metadata.encDbIv, aesEncrypt(dbKey, dbIv));
}
async function initializeDb(db, id, keyLoaderFacade, objectStoreName) {
	await db.deleteDatabase(id).then(() => db.open(id));
	const key = aes256RandomKey();
	const iv = random.generateRandomData(IV_BYTE_LENGTH);
	const userGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey();
	await encryptAndSaveDbKey(userGroupKey, key, iv, db, objectStoreName);
	return {
		key,
		iv
	};
}
async function addAddressToImageList(db, encryptedAddress, rule) {
	try {
		const transaction = await db.createTransaction(false, [ExternalImageListOS]);
		await transaction.put(ExternalImageListOS, null, {
			address: encryptedAddress,
			rule
		});
	} catch (e) {
		if (e instanceof DbError) {
			console.error("failed to add address to image list:", e.message);
			return;
		}
		throw e;
	}
}

//#endregion
export { ConfigurationDatabase, ConfigurationMetaDataOS, decryptLegacyItem, encryptItem, getIndexerMetaData, getMetaData, initializeDb, loadEncryptionMetadata, updateEncryptionMetadata };
//# sourceMappingURL=ConfigurationDatabase-ClkJ3kmL.js.map