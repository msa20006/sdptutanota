{"version":3,"file":"Indexer-BJlfvpHM.js","names":["core: IndexerCore","db: Db","entity: EntityClient","suggestionFacade: SuggestionFacade<Contact>","contact: Contact","tutanotaModels","event: EntityUpdate","contactList: ContactList","groupData: GroupData | null","events: EntityUpdate[]","groupId: Id","batchId: Id","indexUpdate: IndexUpdate","type: TypeRef<T>","db: Db","words: string[]","word: string","message: string","db: IDBDatabase","DB_VERSION: number","entityRestClient: EntityRestClient","infoMessageHandler: InfoMessageHandler","browserData: BrowserData","defaultEntityRestCache: DefaultEntityRestCache","makeMailIndexer: (core: IndexerCore, db: Db) => MailIndexer","nextElement: QueuedBatch","user: User","cacheInfo: CacheInfo | undefined","contactList: ContactList","userId: string","newOldestTimestamp: number","batches: QueuedBatch[]","visible: boolean","userGroupKey: VersionedKey","userGroupKey: AesKey","metaData: EncryptedIndexerMetaData","t: DbTransaction","groupDataEntry: DatabaseEntry","currentGroups: Array<{\n\t\t\tid: Id\n\t\t\ttype: GroupType\n\t\t}>","loadedGroups: {\n\t\t\t\t\t\tkey: DbKey\n\t\t\t\t\t\tvalue: GroupData\n\t\t\t\t\t}[]","id: Id","groupDiff: {\n\t\t\tdeletedGroups: {\n\t\t\t\tid: Id\n\t\t\t\ttype: GroupType\n\t\t\t}[]\n\t\t\tnewGroups: {\n\t\t\t\tid: Id\n\t\t\t\ttype: GroupType\n\t\t\t}[]\n\t\t}","groupBatches: {\n\t\t\t\t\t\tgroupId: Id\n\t\t\t\t\t\tgroupData: GroupData\n\t\t\t\t\t}[]","restrictToTheseGroups?: Id[]","membership: GroupMembership","groupBatches: {\n\t\t\tgroupId: Id\n\t\t\tgroupData: GroupData\n\t\t}[]","t2: DbTransaction","groupIdToEventBatches: {\n\t\t\tgroupId: Id\n\t\t\teventBatchIds: Id[]\n\t\t}[]","batchesOfAllGroups: QueuedBatch[]","lastIndexTimeMs: number | null","eventBatchesOnServer: EntityEventBatch[]","batchesToQueue: QueuedBatch[]","lastEventBatchIds: Id[]","groupData: GroupData | null","batch: QueuedBatch","groupedEvents: Map<TypeRef<any>, EntityUpdate[]>","events: EntityUpdate[]"],"sources":["../../src/mail-app/workerUtils/index/ContactIndexer.ts","../../src/mail-app/workerUtils/index/SuggestionFacade.ts","../../src/common/api/common/error/MembershipRemovedError.ts","../../src/common/api/worker/utils/DbUtils.ts","../../src/mail-app/workerUtils/index/Indexer.ts"],"sourcesContent":["import { NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError.js\"\nimport type { Contact, ContactList } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { ContactTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { typeModels as tutanotaModels } from \"../../../common/api/entities/tutanota/TypeModels.js\"\nimport type { Db, GroupData, IndexUpdate, SearchIndexEntry } from \"../../../common/api/worker/search/SearchTypes.js\"\nimport { _createNewIndexUpdate, typeRefToTypeInfo } from \"../../../common/api/worker/search/IndexUtils.js\"\nimport { neverNull, noOp, ofClass, promiseMap } from \"@tutao/tutanota-utils\"\nimport { FULL_INDEXED_TIMESTAMP, OperationType } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { IndexerCore } from \"./IndexerCore.js\"\nimport { SuggestionFacade } from \"./SuggestionFacade.js\"\nimport { tokenize } from \"@tutao/tutanota-utils\"\nimport type { EntityUpdate } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport { GroupDataOS, MetaDataOS } from \"../../../common/api/worker/search/IndexTables.js\"\n\nexport class ContactIndexer {\n\t_core: IndexerCore\n\t_db: Db\n\t_entity: EntityClient\n\tsuggestionFacade: SuggestionFacade<Contact>\n\n\tconstructor(core: IndexerCore, db: Db, entity: EntityClient, suggestionFacade: SuggestionFacade<Contact>) {\n\t\tthis._core = core\n\t\tthis._db = db\n\t\tthis._entity = entity\n\t\tthis.suggestionFacade = suggestionFacade\n\t}\n\n\tcreateContactIndexEntries(contact: Contact): Map<string, SearchIndexEntry[]> {\n\t\tconst ContactModel = tutanotaModels.Contact\n\t\tlet keyToIndexEntries = this._core.createIndexEntriesForAttributes(contact, [\n\t\t\t{\n\t\t\t\tattribute: ContactModel.values[\"firstName\"],\n\t\t\t\tvalue: () => contact.firstName,\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.values[\"lastName\"],\n\t\t\t\tvalue: () => contact.lastName,\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.values[\"nickname\"],\n\t\t\t\tvalue: () => contact.nickname || \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.values[\"role\"],\n\t\t\t\tvalue: () => contact.role,\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.values[\"title\"],\n\t\t\t\tvalue: () => contact.title || \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.values[\"comment\"],\n\t\t\t\tvalue: () => contact.comment,\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.values[\"company\"],\n\t\t\t\tvalue: () => contact.company,\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.associations[\"addresses\"],\n\t\t\t\tvalue: () => contact.addresses.map((a) => a.address).join(\",\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.associations[\"mailAddresses\"],\n\t\t\t\tvalue: () => contact.mailAddresses.map((cma) => cma.address).join(\",\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.associations[\"phoneNumbers\"],\n\t\t\t\tvalue: () => contact.phoneNumbers.map((pn) => pn.number).join(\",\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\tattribute: ContactModel.associations[\"socialIds\"],\n\t\t\t\tvalue: () => contact.socialIds.map((s) => s.socialId).join(\",\"),\n\t\t\t},\n\t\t])\n\n\t\tthis.suggestionFacade.addSuggestions(this._getSuggestionWords(contact))\n\t\treturn keyToIndexEntries\n\t}\n\n\t_getSuggestionWords(contact: Contact): string[] {\n\t\treturn tokenize(contact.firstName + \" \" + contact.lastName + \" \" + contact.mailAddresses.map((ma) => ma.address).join(\" \"))\n\t}\n\n\tprocessNewContact(event: EntityUpdate): Promise<\n\t\t| {\n\t\t\t\tcontact: Contact\n\t\t\t\tkeyToIndexEntries: Map<string, SearchIndexEntry[]>\n\t\t  }\n\t\t| null\n\t\t| undefined\n\t> {\n\t\treturn this._entity\n\t\t\t.load(ContactTypeRef, [event.instanceListId, event.instanceId])\n\t\t\t.then((contact) => {\n\t\t\t\tlet keyToIndexEntries = this.createContactIndexEntries(contact)\n\t\t\t\treturn this.suggestionFacade.store().then(() => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcontact,\n\t\t\t\t\t\tkeyToIndexEntries,\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\tconsole.log(\"tried to index non existing contact\")\n\t\t\t\t\treturn null\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(NotAuthorizedError, () => {\n\t\t\t\t\tconsole.log(\"tried to index contact without permission\")\n\t\t\t\t\treturn null\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\tasync getIndexTimestamp(contactList: ContactList): Promise<number | null> {\n\t\tconst t = await this._db.dbFacade.createTransaction(true, [MetaDataOS, GroupDataOS])\n\t\tconst groupId = neverNull(contactList._ownerGroup)\n\t\treturn t.get(GroupDataOS, groupId).then((groupData: GroupData | null) => {\n\t\t\treturn groupData ? groupData.indexTimestamp : null\n\t\t})\n\t}\n\n\t/**\n\t * Indexes the contact list if it is not yet indexed.\n\t */\n\tasync indexFullContactList(contactList: ContactList): Promise<any> {\n\t\tconst groupId = neverNull(contactList._ownerGroup)\n\t\tlet indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(ContactTypeRef))\n\t\ttry {\n\t\t\tconst contacts = await this._entity.loadAll(ContactTypeRef, contactList.contacts)\n\t\t\tfor (const contact of contacts) {\n\t\t\t\tlet keyToIndexEntries = this.createContactIndexEntries(contact)\n\t\t\t\tthis._core.encryptSearchIndexEntries(contact._id, neverNull(contact._ownerGroup), keyToIndexEntries, indexUpdate)\n\t\t\t}\n\t\t\treturn Promise.all([\n\t\t\t\tthis._core.writeIndexUpdate(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgroupId,\n\t\t\t\t\t\t\tindexTimestamp: FULL_INDEXED_TIMESTAMP,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tindexUpdate,\n\t\t\t\t),\n\t\t\t\tthis.suggestionFacade.store(),\n\t\t\t])\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\treturn Promise.resolve()\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tprocessEntityEvents(events: EntityUpdate[], groupId: Id, batchId: Id, indexUpdate: IndexUpdate): Promise<void> {\n\t\treturn promiseMap(events, async (event) => {\n\t\t\tif (event.operation === OperationType.CREATE) {\n\t\t\t\tawait this.processNewContact(event).then((result) => {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tthis._core.encryptSearchIndexEntries(result.contact._id, neverNull(result.contact._ownerGroup), result.keyToIndexEntries, indexUpdate)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else if (event.operation === OperationType.UPDATE) {\n\t\t\t\tawait Promise.all([\n\t\t\t\t\tthis._core._processDeleted(event, indexUpdate),\n\t\t\t\t\tthis.processNewContact(event).then((result) => {\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tthis._core.encryptSearchIndexEntries(\n\t\t\t\t\t\t\t\tresult.contact._id,\n\t\t\t\t\t\t\t\tneverNull(result.contact._ownerGroup),\n\t\t\t\t\t\t\t\tresult.keyToIndexEntries,\n\t\t\t\t\t\t\t\tindexUpdate,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t])\n\t\t\t} else if (event.operation === OperationType.DELETE) {\n\t\t\t\tawait this._core._processDeleted(event, indexUpdate)\n\t\t\t}\n\t\t}).then(noOp)\n\t}\n}\n","import type { Db } from \"../../../common/api/worker/search/SearchTypes.js\"\nimport { stringToUtf8Uint8Array, TypeRef, utf8Uint8ArrayToString } from \"@tutao/tutanota-utils\"\nimport { aesDecrypt, aes256EncryptSearchIndexEntry, unauthenticatedAesDecrypt } from \"@tutao/tutanota-crypto\"\nimport { SearchTermSuggestionsOS } from \"../../../common/api/worker/search/IndexTables.js\"\n\nexport type SuggestionsType = Record<string, string[]>\n\nexport class SuggestionFacade<T> {\n\t_db: Db\n\ttype: TypeRef<T>\n\t_suggestions: SuggestionsType\n\n\tconstructor(type: TypeRef<T>, db: Db) {\n\t\tthis.type = type\n\t\tthis._db = db\n\t\tthis._suggestions = {}\n\t}\n\n\tload(): Promise<void> {\n\t\treturn this._db.initialized.then(() => {\n\t\t\treturn this._db.dbFacade.createTransaction(true, [SearchTermSuggestionsOS]).then((t) => {\n\t\t\t\treturn t.get(SearchTermSuggestionsOS, this.type.type.toLowerCase()).then((encSuggestions) => {\n\t\t\t\t\tif (encSuggestions) {\n\t\t\t\t\t\tthis._suggestions = JSON.parse(utf8Uint8ArrayToString(unauthenticatedAesDecrypt(this._db.key, encSuggestions, true)))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._suggestions = {}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\taddSuggestions(words: string[]): void {\n\t\tfor (const word of words) {\n\t\t\tif (word.length > 0) {\n\t\t\t\tlet key = word.charAt(0)\n\n\t\t\t\tif (this._suggestions[key]) {\n\t\t\t\t\tlet existingValues = this._suggestions[key]\n\n\t\t\t\t\tif (existingValues.indexOf(word) === -1) {\n\t\t\t\t\t\tlet insertIndex = existingValues.findIndex((v) => word < v)\n\n\t\t\t\t\t\tif (insertIndex === -1) {\n\t\t\t\t\t\t\texistingValues.push(word)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texistingValues.splice(insertIndex, 0, word)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._suggestions[key] = [word]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetSuggestions(word: string): string[] {\n\t\tif (word.length > 0) {\n\t\t\tlet key = word.charAt(0)\n\t\t\tlet result = this._suggestions[key]\n\t\t\treturn result ? result.filter((r) => r.startsWith(word)) : []\n\t\t} else {\n\t\t\treturn []\n\t\t}\n\t}\n\n\tstore(): Promise<void> {\n\t\treturn this._db.initialized.then(() => {\n\t\t\treturn this._db.dbFacade.createTransaction(false, [SearchTermSuggestionsOS]).then((t) => {\n\t\t\t\tlet encSuggestions = aes256EncryptSearchIndexEntry(this._db.key, stringToUtf8Uint8Array(JSON.stringify(this._suggestions)))\n\t\t\t\tt.put(SearchTermSuggestionsOS, this.type.type.toLowerCase(), encSuggestions)\n\t\t\t\treturn t.wait()\n\t\t\t})\n\t\t})\n\t}\n}\n","//@bundleInto:common-min\n\nimport { TutanotaError } from \"@tutao/tutanota-error\"\n\nexport class MembershipRemovedError extends TutanotaError {\n\tconstructor(message: string) {\n\t\tsuper(\"MembershipRemovedError\", message)\n\t}\n}\n","import { assertWorkerOrNode } from \"../../common/Env\"\n\nassertWorkerOrNode()\n\nexport function deleteObjectStores(db: IDBDatabase, ...oss: string[]) {\n\tfor (let os of oss) {\n\t\ttry {\n\t\t\tdb.deleteObjectStore(os)\n\t\t} catch (e) {\n\t\t\tconsole.warn(\"Error while deleting old os\", os, \"ignoring\", e)\n\t\t}\n\t}\n}\n","import {\n\tENTITY_EVENT_BATCH_TTL_DAYS,\n\tgetMembershipGroupType,\n\tGroupType,\n\tNOTHING_INDEXED_TIMESTAMP,\n\tOperationType,\n} from \"../../../common/api/common/TutanotaConstants.js\"\nimport { ConnectionError, NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError.js\"\nimport type { EntityUpdate, GroupMembership, User } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { EntityEventBatch, EntityEventBatchTypeRef, UserTypeRef } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport type { DatabaseEntry, DbKey, DbTransaction } from \"../../../common/api/worker/search/DbFacade.js\"\nimport { b64UserIdHash, DbFacade } from \"../../../common/api/worker/search/DbFacade.js\"\nimport {\n\tassertNotNull,\n\tcontains,\n\tdaysToMillis,\n\tdefer,\n\tDeferredObject,\n\tdowncast,\n\tgetFromMap,\n\tisNotNull,\n\tisSameTypeRef,\n\tisSameTypeRefByAttr,\n\tmillisToDays,\n\tneverNull,\n\tnoOp,\n\tofClass,\n\tpromiseMap,\n\tTypeRef,\n} from \"@tutao/tutanota-utils\"\nimport {\n\tfirstBiggerThanSecond,\n\tGENERATED_MAX_ID,\n\tgeneratedIdToTimestamp,\n\tgetElementId,\n\tisSameId,\n\ttimestampToGeneratedId,\n} from \"../../../common/api/common/utils/EntityUtils.js\"\nimport { _createNewIndexUpdate, filterIndexMemberships, markEnd, markStart, typeRefToTypeInfo } from \"../../../common/api/worker/search/IndexUtils.js\"\nimport type { Db, GroupData } from \"../../../common/api/worker/search/SearchTypes.js\"\nimport { IndexingErrorReason } from \"../../../common/api/worker/search/SearchTypes.js\"\nimport { ContactIndexer } from \"./ContactIndexer.js\"\nimport { ContactList, ContactListTypeRef, ContactTypeRef, ImportMailStateTypeRef, MailTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { MailIndexer } from \"./MailIndexer.js\"\nimport { IndexerCore } from \"./IndexerCore.js\"\nimport type { EntityRestClient } from \"../../../common/api/worker/rest/EntityRestClient.js\"\nimport { OutOfSyncError } from \"../../../common/api/common/error/OutOfSyncError.js\"\nimport { SuggestionFacade } from \"./SuggestionFacade.js\"\nimport { DbError } from \"../../../common/api/common/error/DbError.js\"\nimport type { QueuedBatch } from \"../../../common/api/worker/EventQueue.js\"\nimport { EventQueue } from \"../../../common/api/worker/EventQueue.js\"\nimport { CancelledError } from \"../../../common/api/common/error/CancelledError.js\"\nimport { MembershipRemovedError } from \"../../../common/api/common/error/MembershipRemovedError.js\"\nimport type { BrowserData } from \"../../../common/misc/ClientConstants.js\"\nimport { InvalidDatabaseStateError } from \"../../../common/api/common/error/InvalidDatabaseStateError.js\"\nimport { LocalTimeDateProvider } from \"../../../common/api/worker/DateProvider.js\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport { deleteObjectStores } from \"../../../common/api/worker/utils/DbUtils.js\"\nimport {\n\taes256EncryptSearchIndexEntry,\n\taes256RandomKey,\n\tAesKey,\n\tBitArray,\n\tdecryptKey,\n\tIV_BYTE_LENGTH,\n\trandom,\n\tunauthenticatedAesDecrypt,\n} from \"@tutao/tutanota-crypto\"\nimport { DefaultEntityRestCache } from \"../../../common/api/worker/rest/DefaultEntityRestCache.js\"\nimport { CacheInfo } from \"../../../common/api/worker/facades/LoginFacade.js\"\nimport { InfoMessageHandler } from \"../../../common/gui/InfoMessageHandler.js\"\nimport {\n\tElementDataOS,\n\tEncryptedIndexerMetaData,\n\tGroupDataOS,\n\tMetadata,\n\tMetaDataOS,\n\tSearchIndexMetaDataOS,\n\tSearchIndexOS,\n\tSearchIndexWordsIndex,\n\tSearchTermSuggestionsOS,\n} from \"../../../common/api/worker/search/IndexTables.js\"\nimport { MailFacade } from \"../../../common/api/worker/facades/lazy/MailFacade.js\"\nimport { KeyLoaderFacade } from \"../../../common/api/worker/facades/KeyLoaderFacade.js\"\nimport { getIndexerMetaData, updateEncryptionMetadata } from \"../../../common/api/worker/facades/lazy/ConfigurationDatabase.js\"\nimport { encryptKeyWithVersionedKey, VersionedKey } from \"../../../common/api/worker/crypto/CryptoWrapper.js\"\n\nexport type InitParams = {\n\tuser: User\n\tkeyLoaderFacade: KeyLoaderFacade\n}\n\nconst DB_VERSION: number = 3\n\ninterface IndexerInitParams {\n\tuser: User\n\tkeyLoaderFacade: KeyLoaderFacade\n\tretryOnError?: boolean\n\tcacheInfo?: CacheInfo\n}\n\nexport function newSearchIndexDB(): DbFacade {\n\treturn new DbFacade(DB_VERSION, (event, db) => {\n\t\tif (event.oldVersion !== DB_VERSION && event.oldVersion !== 0) {\n\t\t\tdeleteObjectStores(db, SearchIndexOS, ElementDataOS, MetaDataOS, GroupDataOS, SearchTermSuggestionsOS, SearchIndexMetaDataOS)\n\t\t}\n\n\t\tdb.createObjectStore(SearchIndexOS, {\n\t\t\tautoIncrement: true,\n\t\t})\n\t\tconst metaOS = db.createObjectStore(SearchIndexMetaDataOS, {\n\t\t\tautoIncrement: true,\n\t\t\tkeyPath: \"id\",\n\t\t})\n\t\tdb.createObjectStore(ElementDataOS)\n\t\tdb.createObjectStore(MetaDataOS)\n\t\tdb.createObjectStore(GroupDataOS)\n\t\tdb.createObjectStore(SearchTermSuggestionsOS)\n\t\tmetaOS.createIndex(SearchIndexWordsIndex, \"word\", {\n\t\t\tunique: true,\n\t\t})\n\t})\n}\n\nexport class Indexer {\n\treadonly db: Db\n\tprivate readonly _dbInitializedDeferredObject: DeferredObject<void>\n\tprivate _initParams!: InitParams\n\treadonly _contact: ContactIndexer\n\treadonly _mail: MailIndexer\n\n\t/**\n\t * Last batch id per group from initial loading.\n\t * In case we get duplicate events from loading and websocket we want to filter them out to avoid processing duplicates.\n\t * */\n\t_initiallyLoadedBatchIdsPerGroup: Map<Id, Id>\n\n\t/**\n\t * Queue which gets all the websocket events and dispatches them to the core. It is paused until we load initial events to avoid\n\t * putting events from websocket before initial events.\n\t */\n\t_realtimeEventQueue: EventQueue\n\t_core: IndexerCore\n\t_entity: EntityClient\n\t_entityRestClient: EntityRestClient\n\t_indexedGroupIds: Array<Id>\n\n\tconstructor(\n\t\tentityRestClient: EntityRestClient,\n\t\tprivate readonly infoMessageHandler: InfoMessageHandler,\n\t\tbrowserData: BrowserData,\n\t\tdefaultEntityRestCache: DefaultEntityRestCache,\n\t\tmakeMailIndexer: (core: IndexerCore, db: Db) => MailIndexer,\n\t) {\n\t\tlet deferred = defer<void>()\n\t\tthis._dbInitializedDeferredObject = deferred\n\t\tthis.db = {\n\t\t\tdbFacade: newSearchIndexDB(),\n\t\t\tkey: downcast<BitArray>(null),\n\t\t\tiv: downcast<Uint8Array>(null),\n\t\t\tinitialized: deferred.promise,\n\t\t}\n\t\t// correctly initialized during init()\n\t\tthis._core = new IndexerCore(this.db, new EventQueue(\"indexer_core\", true, (batch) => this._processEntityEvents(batch)), browserData)\n\t\tthis._entityRestClient = entityRestClient\n\t\tthis._entity = new EntityClient(defaultEntityRestCache)\n\t\tthis._contact = new ContactIndexer(this._core, this.db, this._entity, new SuggestionFacade(ContactTypeRef, this.db))\n\t\tthis._mail = makeMailIndexer(this._core, this.db)\n\t\tthis._indexedGroupIds = []\n\t\tthis._initiallyLoadedBatchIdsPerGroup = new Map()\n\t\tthis._realtimeEventQueue = new EventQueue(\"indexer_realtime\", false, (nextElement: QueuedBatch) => {\n\t\t\t// During initial loading we remember the last batch we loaded\n\t\t\t// so if we get updates from EventBusClient here for things that are already loaded we discard them\n\t\t\tconst loadedIdForGroup = this._initiallyLoadedBatchIdsPerGroup.get(nextElement.groupId)\n\n\t\t\tif (loadedIdForGroup == null || firstBiggerThanSecond(nextElement.batchId, loadedIdForGroup)) {\n\t\t\t\tthis._core.addBatchesToQueue([nextElement])\n\t\t\t}\n\n\t\t\treturn Promise.resolve()\n\t\t})\n\n\t\tthis._realtimeEventQueue.pause()\n\t}\n\n\t/**\n\t * Opens a new DbFacade and initializes the metadata if it is not there yet\n\t */\n\tasync init({ user, keyLoaderFacade, retryOnError, cacheInfo }: IndexerInitParams): Promise<void> {\n\t\tthis._initParams = {\n\t\t\tuser,\n\t\t\tkeyLoaderFacade,\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.db.dbFacade.open(this.getDbId(user))\n\t\t\tconst metaData = await getIndexerMetaData(this.db.dbFacade, MetaDataOS)\n\t\t\tif (metaData == null) {\n\t\t\t\tconst userGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey()\n\t\t\t\t// database was opened for the first time - create new tables\n\t\t\t\tawait this.createIndexTables(user, userGroupKey)\n\t\t\t} else {\n\t\t\t\tconst userGroupKey = await keyLoaderFacade.loadSymUserGroupKey(metaData.userGroupKeyVersion)\n\t\t\t\tawait this.loadIndexTables(user, userGroupKey, metaData)\n\t\t\t}\n\n\t\t\tawait this.infoMessageHandler.onSearchIndexStateUpdate({\n\t\t\t\tinitializing: false,\n\t\t\t\tmailIndexEnabled: this._mail.mailIndexingEnabled,\n\t\t\t\tprogress: 0,\n\t\t\t\tcurrentMailIndexTimestamp: this._mail.currentIndexTimestamp,\n\t\t\t\taimedMailIndexTimestamp: this._mail.currentIndexTimestamp,\n\t\t\t\tindexedMailCount: 0,\n\t\t\t\tfailedIndexingUpTo: null,\n\t\t\t})\n\n\t\t\tthis._core.startProcessing()\n\t\t\tawait this.indexOrLoadContactListIfNeeded(user, cacheInfo)\n\t\t\tawait this._mail.mailboxIndexingPromise\n\t\t\tawait this._mail.indexMailboxes(user, this._mail.currentIndexTimestamp)\n\t\t\tconst groupIdToEventBatches = await this._loadPersistentGroupData(user)\n\t\t\tawait this._loadNewEntities(groupIdToEventBatches).catch(ofClass(OutOfSyncError, (e) => this.disableMailIndexing()))\n\t\t} catch (e) {\n\t\t\tif (retryOnError !== false && (e instanceof MembershipRemovedError || e instanceof InvalidDatabaseStateError)) {\n\t\t\t\t// in case of MembershipRemovedError mail or contact group has been removed from user.\n\t\t\t\t// in case of InvalidDatabaseError no group id has been stored to the database.\n\t\t\t\t// disable mail indexing and init index again in both cases.\n\t\t\t\t// do not use this.disableMailIndexing() because db.initialized is not yet resolved.\n\t\t\t\t// initialized promise will be resolved in this.init later.\n\t\t\t\tconsole.log(\"disable mail indexing and init again\", e)\n\t\t\t\treturn this._reCreateIndex()\n\t\t\t} else {\n\t\t\t\tawait this.infoMessageHandler.onSearchIndexStateUpdate({\n\t\t\t\t\tinitializing: false,\n\t\t\t\t\tmailIndexEnabled: this._mail.mailIndexingEnabled,\n\t\t\t\t\tprogress: 0,\n\t\t\t\t\tcurrentMailIndexTimestamp: this._mail.currentIndexTimestamp,\n\t\t\t\t\taimedMailIndexTimestamp: this._mail.currentIndexTimestamp,\n\t\t\t\t\tindexedMailCount: 0,\n\t\t\t\t\tfailedIndexingUpTo: this._mail.currentIndexTimestamp,\n\t\t\t\t\terror: e instanceof ConnectionError ? IndexingErrorReason.ConnectionLost : IndexingErrorReason.Unknown,\n\t\t\t\t})\n\n\t\t\t\tthis._dbInitializedDeferredObject.reject(e)\n\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getDbId(user: User) {\n\t\treturn b64UserIdHash(user._id)\n\t}\n\n\tprivate async indexOrLoadContactListIfNeeded(user: User, cacheInfo: CacheInfo | undefined) {\n\t\ttry {\n\t\t\tconst contactList: ContactList = await this._entity.loadRoot(ContactListTypeRef, user.userGroup.group)\n\t\t\tconst indexTimestamp = await this._contact.getIndexTimestamp(contactList)\n\t\t\tif (indexTimestamp === NOTHING_INDEXED_TIMESTAMP) {\n\t\t\t\tawait this._contact.indexFullContactList(contactList)\n\t\t\t}\n\t\t\t//If we do not have to index the contact list we might still need to download it so we cache it in the offline storage\n\t\t\telse if (cacheInfo?.isNewOfflineDb) {\n\t\t\t\tawait this._entity.loadAll(ContactTypeRef, contactList.contacts)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// external users have no contact list.\n\t\t\tif (!(e instanceof NotFoundError)) {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tenableMailIndexing(): Promise<void> {\n\t\treturn this.db.initialized.then(() => {\n\t\t\treturn this._mail.enableMailIndexing(this._initParams.user).then(() => {\n\t\t\t\t// We don't have to disable mail indexing when it's stopped now\n\t\t\t\tthis._mail.mailboxIndexingPromise.catch(ofClass(CancelledError, noOp))\n\t\t\t})\n\t\t})\n\t}\n\n\tasync disableMailIndexing(): Promise<void> {\n\t\tawait this.db.initialized\n\n\t\tif (!this._core.isStoppedProcessing()) {\n\t\t\tawait this.deleteIndex(this._initParams.user._id)\n\t\t\tawait this.init({\n\t\t\t\tuser: this._initParams.user,\n\t\t\t\tkeyLoaderFacade: this._initParams.keyLoaderFacade,\n\t\t\t})\n\t\t}\n\t}\n\n\tasync deleteIndex(userId: string): Promise<void> {\n\t\tthis._core.stopProcessing()\n\t\tawait this._mail.disableMailIndexing(userId)\n\t}\n\n\textendMailIndex(newOldestTimestamp: number): Promise<void> {\n\t\treturn this._mail.extendIndexIfNeeded(this._initParams.user, newOldestTimestamp)\n\t}\n\n\tcancelMailIndexing(): Promise<void> {\n\t\treturn this._mail.cancelMailIndexing()\n\t}\n\n\taddBatchesToQueue(batches: QueuedBatch[]) {\n\t\tthis._realtimeEventQueue.addBatches(batches)\n\t}\n\n\tstartProcessing() {\n\t\tthis._core.queue.start()\n\t}\n\n\tasync onVisibilityChanged(visible: boolean): Promise<void> {\n\t\tthis._core.onVisibilityChanged(visible)\n\t}\n\n\t_reCreateIndex(): Promise<void> {\n\t\tconst mailIndexingWasEnabled = this._mail.mailIndexingEnabled\n\t\treturn this._mail.disableMailIndexing(assertNotNull(this._initParams.user._id)).then(() => {\n\t\t\t// do not try to init again on error\n\t\t\treturn this.init({\n\t\t\t\tuser: this._initParams.user,\n\t\t\t\tkeyLoaderFacade: this._initParams.keyLoaderFacade,\n\t\t\t\tretryOnError: false,\n\t\t\t}).then(() => {\n\t\t\t\tif (mailIndexingWasEnabled) {\n\t\t\t\t\treturn this.enableMailIndexing()\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\tprivate async createIndexTables(user: User, userGroupKey: VersionedKey): Promise<void> {\n\t\tthis.db.key = aes256RandomKey()\n\t\tthis.db.iv = random.generateRandomData(IV_BYTE_LENGTH)\n\t\tconst groupBatches = await this._loadGroupData(user)\n\t\tconst userEncDbKey = encryptKeyWithVersionedKey(userGroupKey, this.db.key)\n\t\tconst transaction = await this.db.dbFacade.createTransaction(false, [MetaDataOS, GroupDataOS])\n\t\tawait transaction.put(MetaDataOS, Metadata.userEncDbKey, userEncDbKey.key)\n\t\tawait transaction.put(MetaDataOS, Metadata.mailIndexingEnabled, this._mail.mailIndexingEnabled)\n\t\tawait transaction.put(MetaDataOS, Metadata.encDbIv, aes256EncryptSearchIndexEntry(this.db.key, this.db.iv))\n\t\tawait transaction.put(MetaDataOS, Metadata.userGroupKeyVersion, userEncDbKey.encryptingKeyVersion)\n\t\tawait transaction.put(MetaDataOS, Metadata.lastEventIndexTimeMs, this._entityRestClient.getRestClient().getServerTimestampMs())\n\t\tawait this._initGroupData(groupBatches, transaction)\n\t\tawait this._updateIndexedGroups()\n\t\tthis._dbInitializedDeferredObject.resolve()\n\t}\n\n\tprivate async loadIndexTables(user: User, userGroupKey: AesKey, metaData: EncryptedIndexerMetaData): Promise<void> {\n\t\tthis.db.key = decryptKey(userGroupKey, metaData.userEncDbKey)\n\t\tthis.db.iv = unauthenticatedAesDecrypt(this.db.key, neverNull(metaData.encDbIv), true)\n\t\tthis._mail.mailIndexingEnabled = metaData.mailIndexingEnabled\n\t\tconst groupDiff = await this._loadGroupDiff(user)\n\t\tawait this._updateGroups(user, groupDiff)\n\t\tawait this._mail.updateCurrentIndexTimestamp(user)\n\t\tawait this._updateIndexedGroups()\n\t\tthis._dbInitializedDeferredObject.resolve()\n\t\tawait this._contact.suggestionFacade.load()\n\t}\n\n\tasync _updateIndexedGroups(): Promise<void> {\n\t\tconst t: DbTransaction = await this.db.dbFacade.createTransaction(true, [GroupDataOS])\n\t\tconst indexedGroupIds = await promiseMap(await t.getAll(GroupDataOS), (groupDataEntry: DatabaseEntry) => downcast<Id>(groupDataEntry.key))\n\n\t\tif (indexedGroupIds.length === 0) {\n\t\t\t// tried to index twice, this is probably not our fault\n\t\t\tconsole.log(\"no group ids in database, disabling indexer\")\n\t\t\tthis.disableMailIndexing()\n\t\t}\n\n\t\tthis._indexedGroupIds = indexedGroupIds\n\t}\n\n\t_loadGroupDiff(user: User): Promise<{\n\t\tdeletedGroups: {\n\t\t\tid: Id\n\t\t\ttype: GroupType\n\t\t}[]\n\t\tnewGroups: {\n\t\t\tid: Id\n\t\t\ttype: GroupType\n\t\t}[]\n\t}> {\n\t\tlet currentGroups: Array<{\n\t\t\tid: Id\n\t\t\ttype: GroupType\n\t\t}> = filterIndexMemberships(user).map((m) => {\n\t\t\treturn {\n\t\t\t\tid: m.group,\n\t\t\t\ttype: getMembershipGroupType(m),\n\t\t\t}\n\t\t})\n\t\treturn this.db.dbFacade.createTransaction(true, [GroupDataOS]).then((t) => {\n\t\t\treturn t.getAll(GroupDataOS).then(\n\t\t\t\t(\n\t\t\t\t\tloadedGroups: {\n\t\t\t\t\t\tkey: DbKey\n\t\t\t\t\t\tvalue: GroupData\n\t\t\t\t\t}[],\n\t\t\t\t) => {\n\t\t\t\t\tif (!Array.isArray(loadedGroups)) {\n\t\t\t\t\t\tthrow new InvalidDatabaseStateError(\"loadedGroups is not an array\")\n\t\t\t\t\t}\n\t\t\t\t\tlet oldGroups = loadedGroups.map((group) => {\n\t\t\t\t\t\tif (typeof group?.key !== \"string\" || typeof group?.value?.groupType !== \"string\") {\n\t\t\t\t\t\t\tthrow new InvalidDatabaseStateError(`loaded group is malformed: ${group} ${JSON.stringify(group)}`)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst id: Id = group.key\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\ttype: group.value.groupType,\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tlet deletedGroups = oldGroups.filter((oldGroup) => !currentGroups.some((m) => m.id === oldGroup.id))\n\t\t\t\t\tlet newGroups = currentGroups.filter((m) => !oldGroups.some((oldGroup) => m.id === oldGroup.id))\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdeletedGroups,\n\t\t\t\t\t\tnewGroups,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t)\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * Initializes the index db for new groups of the user, but does not start the actual indexing for those groups.\n\t * If the user was removed from a contact or mail group the function throws a CancelledError to delete the complete mail index afterwards.\n\t */\n\t_updateGroups(\n\t\tuser: User,\n\t\tgroupDiff: {\n\t\t\tdeletedGroups: {\n\t\t\t\tid: Id\n\t\t\t\ttype: GroupType\n\t\t\t}[]\n\t\t\tnewGroups: {\n\t\t\t\tid: Id\n\t\t\t\ttype: GroupType\n\t\t\t}[]\n\t\t},\n\t): Promise<void> {\n\t\tif (groupDiff.deletedGroups.some((g) => g.type === GroupType.Mail || g.type === GroupType.Contact)) {\n\t\t\treturn Promise.reject(new MembershipRemovedError(\"user has been removed from contact or mail group\")) // user has been removed from a shared group\n\t\t} else if (groupDiff.newGroups.length > 0) {\n\t\t\treturn this._loadGroupData(\n\t\t\t\tuser,\n\t\t\t\tgroupDiff.newGroups.map((g) => g.id),\n\t\t\t).then(\n\t\t\t\t(\n\t\t\t\t\tgroupBatches: {\n\t\t\t\t\t\tgroupId: Id\n\t\t\t\t\t\tgroupData: GroupData\n\t\t\t\t\t}[],\n\t\t\t\t) => {\n\t\t\t\t\treturn this.db.dbFacade.createTransaction(false, [GroupDataOS]).then((t) => {\n\t\t\t\t\t\treturn this._initGroupData(groupBatches, t)\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\n\t\treturn Promise.resolve()\n\t}\n\n\t/**\n\t * Provides a GroupData object including the last 100 event batch ids for all indexed membership groups of the given user.\n\t */\n\t_loadGroupData(\n\t\tuser: User,\n\t\trestrictToTheseGroups?: Id[],\n\t): Promise<\n\t\t{\n\t\t\tgroupId: Id\n\t\t\tgroupData: GroupData\n\t\t}[]\n\t> {\n\t\tlet memberships = filterIndexMemberships(user)\n\t\tconst restrictTo = restrictToTheseGroups // type check\n\n\t\tif (restrictTo) {\n\t\t\tmemberships = memberships.filter((membership) => contains(restrictTo, membership.group))\n\t\t}\n\n\t\treturn promiseMap(memberships, (membership: GroupMembership) => {\n\t\t\t// we only need the latest EntityEventBatch to synchronize the index state after reconnect. The lastBatchIds are filled up to 100 with each event we receive.\n\t\t\treturn this._entity\n\t\t\t\t.loadRange(EntityEventBatchTypeRef, membership.group, GENERATED_MAX_ID, 1, true)\n\t\t\t\t.then((eventBatches) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tgroupId: membership.group,\n\t\t\t\t\t\tgroupData: {\n\t\t\t\t\t\t\tlastBatchIds: eventBatches.map((eventBatch) => eventBatch._id[1]),\n\t\t\t\t\t\t\tindexTimestamp: NOTHING_INDEXED_TIMESTAMP,\n\t\t\t\t\t\t\tgroupType: getMembershipGroupType(membership),\n\t\t\t\t\t\t} as GroupData,\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(\n\t\t\t\t\tofClass(NotAuthorizedError, () => {\n\t\t\t\t\t\tconsole.log(\"could not download entity updates => lost permission on list\")\n\t\t\t\t\t\treturn null\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t}) // sequentially to avoid rate limiting\n\t\t\t.then((data) => data.filter(isNotNull))\n\t}\n\n\t/**\n\t * creates the initial group data for all provided group ids\n\t */\n\t_initGroupData(\n\t\tgroupBatches: {\n\t\t\tgroupId: Id\n\t\t\tgroupData: GroupData\n\t\t}[],\n\t\tt2: DbTransaction,\n\t): Promise<void> {\n\t\tfor (const groupIdToLastBatchId of groupBatches) {\n\t\t\tt2.put(GroupDataOS, groupIdToLastBatchId.groupId, groupIdToLastBatchId.groupData)\n\t\t}\n\t\treturn t2.wait()\n\t}\n\n\tasync _loadNewEntities(\n\t\tgroupIdToEventBatches: {\n\t\t\tgroupId: Id\n\t\t\teventBatchIds: Id[]\n\t\t}[],\n\t): Promise<void> {\n\t\tconst batchesOfAllGroups: QueuedBatch[] = []\n\t\tconst lastLoadedBatchIdInGroup = new Map<Id, Id>()\n\t\tconst transaction = await this.db.dbFacade.createTransaction(true, [MetaDataOS])\n\t\tconst lastIndexTimeMs: number | null = await transaction.get(MetaDataOS, Metadata.lastEventIndexTimeMs)\n\t\tawait this._throwIfOutOfDate()\n\n\t\ttry {\n\t\t\tfor (let groupIdToEventBatch of groupIdToEventBatches) {\n\t\t\t\tif (groupIdToEventBatch.eventBatchIds.length > 0) {\n\t\t\t\t\tlet startId = this._getStartIdForLoadingMissedEventBatches(groupIdToEventBatch.eventBatchIds)\n\n\t\t\t\t\tlet eventBatchesOnServer: EntityEventBatch[] = []\n\t\t\t\t\teventBatchesOnServer = await this._entity.loadAll(EntityEventBatchTypeRef, groupIdToEventBatch.groupId, startId)\n\t\t\t\t\tconst batchesToQueue: QueuedBatch[] = []\n\n\t\t\t\t\tfor (let batch of eventBatchesOnServer) {\n\t\t\t\t\t\tconst batchId = getElementId(batch)\n\n\t\t\t\t\t\tif (groupIdToEventBatch.eventBatchIds.indexOf(batchId) === -1 && firstBiggerThanSecond(batchId, startId)) {\n\t\t\t\t\t\t\tbatchesToQueue.push({\n\t\t\t\t\t\t\t\tgroupId: groupIdToEventBatch.groupId,\n\t\t\t\t\t\t\t\tbatchId,\n\t\t\t\t\t\t\t\tevents: batch.events,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tconst lastBatch = lastLoadedBatchIdInGroup.get(groupIdToEventBatch.groupId)\n\n\t\t\t\t\t\t\tif (lastBatch == null || firstBiggerThanSecond(batchId, lastBatch)) {\n\t\t\t\t\t\t\t\tlastLoadedBatchIdInGroup.set(groupIdToEventBatch.groupId, batchId)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Good scenario: we know when we stopped, we can process events we did not process yet and catch up the server\n\t\t\t\t\t//\n\t\t\t\t\t//\n\t\t\t\t\t// [4, 3, 2, 1]                          - processed events, lastBatchId =1\n\t\t\t\t\t// load from lowest id 1 -1\n\t\t\t\t\t// [0.9, 1, 2, 3, 4, 5, 6, 7, 8]         - last X events from server\n\t\t\t\t\t// => [5, 6, 7, 8]                       - batches to queue\n\t\t\t\t\t//\n\t\t\t\t\t// Bad scenario: we don' know where we stopped, server doesn't have events to fill the gap anymore, we cannot fix the index.\n\t\t\t\t\t// [4, 3, 2, 1] - processed events, lastBatchId = 1\n\t\t\t\t\t// [7, 5, 9, 10] - last events from server\n\t\t\t\t\t// => [7, 5, 9, 10] - batches to queue - nothing has been processed before so we are out of sync\n\t\t\t\t\t// We only want to do this check for clients that haven't yet saved the index time\n\t\t\t\t\t// This can be removed in the future\n\t\t\t\t\tif (lastIndexTimeMs == null && eventBatchesOnServer.length === batchesToQueue.length) {\n\t\t\t\t\t\t// Bad scenario happened.\n\t\t\t\t\t\t// None of the events we want to process were processed before, we're too far away, stop the process and delete\n\t\t\t\t\t\t// the index.\n\t\t\t\t\t\tthrow new OutOfSyncError(`We lost entity events for group ${groupIdToEventBatch.groupId}. start id was ${startId}`)\n\t\t\t\t\t}\n\n\t\t\t\t\tbatchesOfAllGroups.push(...batchesToQueue)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\tconsole.log(\"could not download entity updates => lost permission on list\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthrow e\n\t\t}\n\n\t\t// add all batches of all groups in one step to avoid that just some groups are added when a ServiceUnavailableError occurs\n\t\t// Add them directly to the core so that they are added before the realtime batches\n\t\tthis._core.addBatchesToQueue(batchesOfAllGroups)\n\n\t\t// Add latest batches per group so that we can filter out overlapping realtime updates later\n\t\tthis._initiallyLoadedBatchIdsPerGroup = lastLoadedBatchIdInGroup\n\n\t\tthis._realtimeEventQueue.resume()\n\n\t\tthis.startProcessing()\n\t\tawait this._writeServerTimestamp()\n\t}\n\n\t_getStartIdForLoadingMissedEventBatches(lastEventBatchIds: Id[]): Id {\n\t\tlet newestBatchId = lastEventBatchIds[0]\n\t\tlet oldestBatchId = lastEventBatchIds[lastEventBatchIds.length - 1]\n\t\t// load all EntityEventBatches which are not older than 1 minute before the newest batch\n\t\t// to be able to get batches that were overtaken by the newest batch and therefore missed before\n\t\tlet startId = timestampToGeneratedId(generatedIdToTimestamp(newestBatchId) - 1000 * 60)\n\n\t\t// do not load events that are older than the stored events\n\t\tif (!firstBiggerThanSecond(startId, oldestBatchId)) {\n\t\t\t// reduce the generated id by a millisecond in order to fetch the instance with lastBatchId, too (would throw OutOfSync, otherwise if the instance with lasBatchId is the only one in the list)\n\t\t\tstartId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1)\n\t\t}\n\n\t\treturn startId\n\t}\n\n\t/**\n\t * @private a map from group id to event batches\n\t */\n\t_loadPersistentGroupData(user: User): Promise<\n\t\t{\n\t\t\tgroupId: Id\n\t\t\teventBatchIds: Id[]\n\t\t}[]\n\t> {\n\t\treturn this.db.dbFacade.createTransaction(true, [GroupDataOS]).then((t) => {\n\t\t\treturn Promise.all(\n\t\t\t\tfilterIndexMemberships(user).map((membership) => {\n\t\t\t\t\treturn t.get(GroupDataOS, membership.group).then((groupData: GroupData | null) => {\n\t\t\t\t\t\tif (groupData) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tgroupId: membership.group,\n\t\t\t\t\t\t\t\teventBatchIds: groupData.lastBatchIds,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new InvalidDatabaseStateError(\n\t\t\t\t\t\t\t\t\"no group data for group \" + membership.group + \" indexedGroupIds: \" + this._indexedGroupIds.join(\",\"),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t)\n\t\t})\n\t}\n\n\t_processEntityEvents(batch: QueuedBatch): Promise<any> {\n\t\tconst { events, groupId, batchId } = batch\n\t\treturn this.db.initialized\n\t\t\t.then(async () => {\n\t\t\t\tif (!this.db.dbFacade.indexingSupported) {\n\t\t\t\t\treturn Promise.resolve()\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfilterIndexMemberships(this._initParams.user)\n\t\t\t\t\t\t.map((m) => m.group)\n\t\t\t\t\t\t.indexOf(groupId) === -1\n\t\t\t\t) {\n\t\t\t\t\treturn Promise.resolve()\n\t\t\t\t}\n\n\t\t\t\tif (this._indexedGroupIds.indexOf(groupId) === -1) {\n\t\t\t\t\treturn Promise.resolve()\n\t\t\t\t}\n\n\t\t\t\tmarkStart(\"processEntityEvents\")\n\t\t\t\tconst groupedEvents: Map<TypeRef<any>, EntityUpdate[]> = new Map() // define map first because Webstorm has problems with type annotations\n\n\t\t\t\tevents.reduce((all, update) => {\n\t\t\t\t\tif (isSameTypeRefByAttr(MailTypeRef, update.application, update.type)) {\n\t\t\t\t\t\tgetFromMap(all, MailTypeRef, () => []).push(update)\n\t\t\t\t\t} else if (isSameTypeRefByAttr(ContactTypeRef, update.application, update.type)) {\n\t\t\t\t\t\tgetFromMap(all, ContactTypeRef, () => []).push(update)\n\t\t\t\t\t} else if (isSameTypeRefByAttr(UserTypeRef, update.application, update.type)) {\n\t\t\t\t\t\tgetFromMap(all, UserTypeRef, () => []).push(update)\n\t\t\t\t\t} else if (isSameTypeRefByAttr(ImportMailStateTypeRef, update.application, update.type)) {\n\t\t\t\t\t\tgetFromMap(all, ImportMailStateTypeRef, () => []).push(update)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn all\n\t\t\t\t}, groupedEvents)\n\t\t\t\tmarkStart(\"processEvent\")\n\t\t\t\treturn promiseMap(groupedEvents.entries(), ([key, value]) => {\n\t\t\t\t\tlet promise = Promise.resolve()\n\n\t\t\t\t\tif (isSameTypeRef(UserTypeRef, key)) {\n\t\t\t\t\t\treturn this._processUserEntityEvents(value)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst typeInfoToIndex =\n\t\t\t\t\t\tisSameTypeRef(ImportMailStateTypeRef, key) || isSameTypeRef(MailTypeRef, key) ? typeRefToTypeInfo(MailTypeRef) : typeRefToTypeInfo(key)\n\t\t\t\t\tconst indexUpdate = _createNewIndexUpdate(typeInfoToIndex)\n\n\t\t\t\t\tif (isSameTypeRef(MailTypeRef, key)) {\n\t\t\t\t\t\tpromise = this._mail.processEntityEvents(value, groupId, batchId, indexUpdate)\n\t\t\t\t\t} else if (isSameTypeRef(ContactTypeRef, key)) {\n\t\t\t\t\t\tpromise = this._contact.processEntityEvents(value, groupId, batchId, indexUpdate)\n\t\t\t\t\t} else if (isSameTypeRef(ImportMailStateTypeRef, key)) {\n\t\t\t\t\t\tpromise = this._mail.processImportStateEntityEvents(value, groupId, batchId, indexUpdate)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn promise\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tmarkEnd(\"processEvent\")\n\t\t\t\t\t\t\tmarkStart(\"writeIndexUpdate\")\n\t\t\t\t\t\t\treturn this._core.writeIndexUpdateWithBatchId(groupId, batchId, indexUpdate)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tmarkEnd(\"writeIndexUpdate\")\n\t\t\t\t\t\t\tmarkEnd(\"processEntityEvents\") // if (!env.dist && env.mode !== \"Test\") {\n\t\t\t\t\t\t\t// \tprintMeasure(\"Update of \" + key.type + \" \" + batch.events.map(e => operationTypeKeys[e.operation]).join(\",\"), [\n\t\t\t\t\t\t\t// \t\t\"processEntityEvents\", \"processEvent\", \"writeIndexUpdate\"\n\t\t\t\t\t\t\t// \t])\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t\t.catch(ofClass(CancelledError, noOp))\n\t\t\t.catch(\n\t\t\t\tofClass(DbError, (e) => {\n\t\t\t\t\tif (this._core.isStoppedProcessing()) {\n\t\t\t\t\t\tconsole.log(\"Ignoring DBerror when indexing is disabled\", e)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(InvalidDatabaseStateError, (e) => {\n\t\t\t\t\tconsole.log(\"InvalidDatabaseStateError during _processEntityEvents\")\n\n\t\t\t\t\tthis._core.stopProcessing()\n\n\t\t\t\t\treturn this._reCreateIndex()\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\t/**\n\t * @VisibleForTesting\n\t * @param events\n\t */\n\tasync _processUserEntityEvents(events: EntityUpdate[]): Promise<void> {\n\t\tfor (const event of events) {\n\t\t\tif (!(event.operation === OperationType.UPDATE && isSameId(this._initParams.user._id, event.instanceId))) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis._initParams.user = await this._entity.load(UserTypeRef, event.instanceId)\n\t\t\tawait updateEncryptionMetadata(this.db.dbFacade, this._initParams.keyLoaderFacade, MetaDataOS)\n\t\t}\n\t}\n\n\tasync _throwIfOutOfDate(): Promise<void> {\n\t\tconst transaction = await this.db.dbFacade.createTransaction(true, [MetaDataOS])\n\t\tconst lastIndexTimeMs = await transaction.get(MetaDataOS, Metadata.lastEventIndexTimeMs)\n\n\t\tif (lastIndexTimeMs != null) {\n\t\t\tconst now = this._entityRestClient.getRestClient().getServerTimestampMs()\n\n\t\t\tconst timeSinceLastIndex = now - lastIndexTimeMs\n\n\t\t\tif (timeSinceLastIndex >= daysToMillis(ENTITY_EVENT_BATCH_TTL_DAYS)) {\n\t\t\t\tthrow new OutOfSyncError(\n\t\t\t\t\t`we haven't updated the index in ${millisToDays(timeSinceLastIndex)} days. last update was ${new Date(\n\t\t\t\t\t\tneverNull(lastIndexTimeMs),\n\t\t\t\t\t).toString()}`,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _writeServerTimestamp() {\n\t\tconst transaction = await this.db.dbFacade.createTransaction(false, [MetaDataOS])\n\n\t\tconst now = this._entityRestClient.getRestClient().getServerTimestampMs()\n\n\t\tawait transaction.put(MetaDataOS, Metadata.lastEventIndexTimeMs, now)\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAea,iBAAN,MAAqB;CAC3B;CACA;CACA;CACA;CAEA,YAAYA,MAAmBC,IAAQC,QAAsBC,kBAA6C;AACzG,OAAK,QAAQ;AACb,OAAK,MAAM;AACX,OAAK,UAAU;AACf,OAAK,mBAAmB;CACxB;CAED,0BAA0BC,SAAmD;EAC5E,MAAM,eAAeC,WAAe;EACpC,IAAI,oBAAoB,KAAK,MAAM,gCAAgC,SAAS;GAC3E;IACC,WAAW,aAAa,OAAO;IAC/B,OAAO,MAAM,QAAQ;GACrB;GACD;IACC,WAAW,aAAa,OAAO;IAC/B,OAAO,MAAM,QAAQ;GACrB;GACD;IACC,WAAW,aAAa,OAAO;IAC/B,OAAO,MAAM,QAAQ,YAAY;GACjC;GACD;IACC,WAAW,aAAa,OAAO;IAC/B,OAAO,MAAM,QAAQ;GACrB;GACD;IACC,WAAW,aAAa,OAAO;IAC/B,OAAO,MAAM,QAAQ,SAAS;GAC9B;GACD;IACC,WAAW,aAAa,OAAO;IAC/B,OAAO,MAAM,QAAQ;GACrB;GACD;IACC,WAAW,aAAa,OAAO;IAC/B,OAAO,MAAM,QAAQ;GACrB;GACD;IACC,WAAW,aAAa,aAAa;IACrC,OAAO,MAAM,QAAQ,UAAU,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,KAAK,IAAI;GAC9D;GACD;IACC,WAAW,aAAa,aAAa;IACrC,OAAO,MAAM,QAAQ,cAAc,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,IAAI;GACtE;GACD;IACC,WAAW,aAAa,aAAa;IACrC,OAAO,MAAM,QAAQ,aAAa,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,KAAK,IAAI;GAClE;GACD;IACC,WAAW,aAAa,aAAa;IACrC,OAAO,MAAM,QAAQ,UAAU,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,IAAI;GAC/D;EACD,EAAC;AAEF,OAAK,iBAAiB,eAAe,KAAK,oBAAoB,QAAQ,CAAC;AACvE,SAAO;CACP;CAED,oBAAoBD,SAA4B;AAC/C,SAAO,SAAS,QAAQ,YAAY,MAAM,QAAQ,WAAW,MAAM,QAAQ,cAAc,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,KAAK,IAAI,CAAC;CAC3H;CAED,kBAAkBE,OAOhB;AACD,SAAO,KAAK,QACV,KAAK,gBAAgB,CAAC,MAAM,gBAAgB,MAAM,UAAW,EAAC,CAC9D,KAAK,CAAC,YAAY;GAClB,IAAI,oBAAoB,KAAK,0BAA0B,QAAQ;AAC/D,UAAO,KAAK,iBAAiB,OAAO,CAAC,KAAK,MAAM;AAC/C,WAAO;KACN;KACA;IACA;GACD,EAAC;EACF,EAAC,CACD,MACA,QAAQ,eAAe,MAAM;AAC5B,WAAQ,IAAI,sCAAsC;AAClD,UAAO;EACP,EAAC,CACF,CACA,MACA,QAAQ,oBAAoB,MAAM;AACjC,WAAQ,IAAI,4CAA4C;AACxD,UAAO;EACP,EAAC,CACF;CACF;CAED,MAAM,kBAAkBC,aAAkD;EACzE,MAAM,IAAI,MAAM,KAAK,IAAI,SAAS,kBAAkB,MAAM,CAAC,YAAY,WAAY,EAAC;EACpF,MAAM,UAAU,UAAU,YAAY,YAAY;AAClD,SAAO,EAAE,IAAI,aAAa,QAAQ,CAAC,KAAK,CAACC,cAAgC;AACxE,UAAO,YAAY,UAAU,iBAAiB;EAC9C,EAAC;CACF;;;;CAKD,MAAM,qBAAqBD,aAAwC;EAClE,MAAM,UAAU,UAAU,YAAY,YAAY;EAClD,IAAI,cAAc,sBAAsB,kBAAkB,eAAe,CAAC;AAC1E,MAAI;GACH,MAAM,WAAW,MAAM,KAAK,QAAQ,QAAQ,gBAAgB,YAAY,SAAS;AACjF,QAAK,MAAM,WAAW,UAAU;IAC/B,IAAI,oBAAoB,KAAK,0BAA0B,QAAQ;AAC/D,SAAK,MAAM,0BAA0B,QAAQ,KAAK,UAAU,QAAQ,YAAY,EAAE,mBAAmB,YAAY;GACjH;AACD,UAAO,QAAQ,IAAI,CAClB,KAAK,MAAM,iBACV,CACC;IACC;IACA,gBAAgB;GAChB,CACD,GACD,YACA,EACD,KAAK,iBAAiB,OAAO,AAC7B,EAAC;EACF,SAAQ,GAAG;AACX,OAAI,aAAa,cAChB,QAAO,QAAQ,SAAS;AAEzB,SAAM;EACN;CACD;CAED,oBAAoBE,QAAwBC,SAAaC,SAAaC,aAAyC;AAC9G,SAAO,KAAW,QAAQ,OAAO,UAAU;AAC1C,OAAI,MAAM,cAAc,cAAc,OACrC,OAAM,KAAK,kBAAkB,MAAM,CAAC,KAAK,CAAC,WAAW;AACpD,QAAI,OACH,MAAK,MAAM,0BAA0B,OAAO,QAAQ,KAAK,UAAU,OAAO,QAAQ,YAAY,EAAE,OAAO,mBAAmB,YAAY;GAEvI,EAAC;SACQ,MAAM,cAAc,cAAc,OAC5C,OAAM,QAAQ,IAAI,CACjB,KAAK,MAAM,gBAAgB,OAAO,YAAY,EAC9C,KAAK,kBAAkB,MAAM,CAAC,KAAK,CAAC,WAAW;AAC9C,QAAI,OACH,MAAK,MAAM,0BACV,OAAO,QAAQ,KACf,UAAU,OAAO,QAAQ,YAAY,EACrC,OAAO,mBACP,YACA;GAEF,EAAC,AACF,EAAC;SACQ,MAAM,cAAc,cAAc,OAC5C,OAAM,KAAK,MAAM,gBAAgB,OAAO,YAAY;EAErD,EAAC,CAAC,KAAK,KAAK;CACb;AACD;;;;IClLY,mBAAN,MAA0B;CAChC;CACA;CACA;CAEA,YAAYC,MAAkBC,IAAQ;AACrC,OAAK,OAAO;AACZ,OAAK,MAAM;AACX,OAAK,eAAe,CAAE;CACtB;CAED,OAAsB;AACrB,SAAO,KAAK,IAAI,YAAY,KAAK,MAAM;AACtC,UAAO,KAAK,IAAI,SAAS,kBAAkB,MAAM,CAAC,uBAAwB,EAAC,CAAC,KAAK,CAAC,MAAM;AACvF,WAAO,EAAE,IAAI,yBAAyB,KAAK,KAAK,KAAK,aAAa,CAAC,CAAC,KAAK,CAAC,mBAAmB;AAC5F,SAAI,eACH,MAAK,eAAe,KAAK,MAAM,uBAAuB,0BAA0B,KAAK,IAAI,KAAK,gBAAgB,KAAK,CAAC,CAAC;IAErH,MAAK,eAAe,CAAE;IAEvB,EAAC;GACF,EAAC;EACF,EAAC;CACF;CAED,eAAeC,OAAuB;AACrC,OAAK,MAAM,QAAQ,MAClB,KAAI,KAAK,SAAS,GAAG;GACpB,IAAI,MAAM,KAAK,OAAO,EAAE;AAExB,OAAI,KAAK,aAAa,MAAM;IAC3B,IAAI,iBAAiB,KAAK,aAAa;AAEvC,QAAI,eAAe,QAAQ,KAAK,KAAK,IAAI;KACxC,IAAI,cAAc,eAAe,UAAU,CAAC,MAAM,OAAO,EAAE;AAE3D,SAAI,gBAAgB,GACnB,gBAAe,KAAK,KAAK;IAEzB,gBAAe,OAAO,aAAa,GAAG,KAAK;IAE5C;GACD,MACA,MAAK,aAAa,OAAO,CAAC,IAAK;EAEhC;CAEF;CAED,eAAeC,MAAwB;AACtC,MAAI,KAAK,SAAS,GAAG;GACpB,IAAI,MAAM,KAAK,OAAO,EAAE;GACxB,IAAI,SAAS,KAAK,aAAa;AAC/B,UAAO,SAAS,OAAO,OAAO,CAAC,MAAM,EAAE,WAAW,KAAK,CAAC,GAAG,CAAE;EAC7D,MACA,QAAO,CAAE;CAEV;CAED,QAAuB;AACtB,SAAO,KAAK,IAAI,YAAY,KAAK,MAAM;AACtC,UAAO,KAAK,IAAI,SAAS,kBAAkB,OAAO,CAAC,uBAAwB,EAAC,CAAC,KAAK,CAAC,MAAM;IACxF,IAAI,iBAAiB,8BAA8B,KAAK,IAAI,KAAK,uBAAuB,KAAK,UAAU,KAAK,aAAa,CAAC,CAAC;AAC3H,MAAE,IAAI,yBAAyB,KAAK,KAAK,KAAK,aAAa,EAAE,eAAe;AAC5E,WAAO,EAAE,MAAM;GACf,EAAC;EACF,EAAC;CACF;AACD;;;;ICvEY,yBAAN,cAAqC,cAAc;CACzD,YAAYC,SAAiB;AAC5B,QAAM,0BAA0B,QAAQ;CACxC;AACD;;;;ACND,oBAAoB;AAEb,SAAS,mBAAmBC,IAAiB,GAAG,KAAe;AACrE,MAAK,IAAI,MAAM,IACd,KAAI;AACH,KAAG,kBAAkB,GAAG;CACxB,SAAQ,GAAG;AACX,UAAQ,KAAK,+BAA+B,IAAI,YAAY,EAAE;CAC9D;AAEF;;;;ACgFD,MAAMC,aAAqB;AASpB,SAAS,mBAA6B;AAC5C,QAAO,IAAI,SAAS,YAAY,CAAC,OAAO,OAAO;AAC9C,MAAI,MAAM,eAAe,cAAc,MAAM,eAAe,EAC3D,oBAAmB,IAAI,eAAe,eAAe,YAAY,aAAa,yBAAyB,sBAAsB;AAG9H,KAAG,kBAAkB,eAAe,EACnC,eAAe,KACf,EAAC;EACF,MAAM,SAAS,GAAG,kBAAkB,uBAAuB;GAC1D,eAAe;GACf,SAAS;EACT,EAAC;AACF,KAAG,kBAAkB,cAAc;AACnC,KAAG,kBAAkB,WAAW;AAChC,KAAG,kBAAkB,YAAY;AACjC,KAAG,kBAAkB,wBAAwB;AAC7C,SAAO,YAAY,uBAAuB,QAAQ,EACjD,QAAQ,KACR,EAAC;CACF;AACD;IAEY,UAAN,MAAc;CACpB,AAAS;CACT,AAAiB;CACjB,AAAQ;CACR,AAAS;CACT,AAAS;;;;;CAMT;;;;;CAMA;CACA;CACA;CACA;CACA;CAEA,YACCC,kBACiBC,oBACjBC,aACAC,wBACAC,iBACC;EA6nBF,KAjoBkB;EAKjB,IAAI,WAAW,OAAa;AAC5B,OAAK,+BAA+B;AACpC,OAAK,KAAK;GACT,UAAU,kBAAkB;GAC5B,KAAK,SAAmB,KAAK;GAC7B,IAAI,SAAqB,KAAK;GAC9B,aAAa,SAAS;EACtB;AAED,OAAK,QAAQ,IAAI,YAAY,KAAK,IAAI,IAAI,WAAW,gBAAgB,MAAM,CAAC,UAAU,KAAK,qBAAqB,MAAM,GAAG;AACzH,OAAK,oBAAoB;AACzB,OAAK,UAAU,IAAI,aAAa;AAChC,OAAK,WAAW,IAAI,eAAe,KAAK,OAAO,KAAK,IAAI,KAAK,SAAS,IAAI,iBAAiB,gBAAgB,KAAK;AAChH,OAAK,QAAQ,gBAAgB,KAAK,OAAO,KAAK,GAAG;AACjD,OAAK,mBAAmB,CAAE;AAC1B,OAAK,mCAAmC,IAAI;AAC5C,OAAK,sBAAsB,IAAI,WAAW,oBAAoB,OAAO,CAACC,gBAA6B;GAGlG,MAAM,mBAAmB,KAAK,iCAAiC,IAAI,YAAY,QAAQ;AAEvF,OAAI,oBAAoB,QAAQ,sBAAsB,YAAY,SAAS,iBAAiB,CAC3F,MAAK,MAAM,kBAAkB,CAAC,WAAY,EAAC;AAG5C,UAAO,QAAQ,SAAS;EACxB;AAED,OAAK,oBAAoB,OAAO;CAChC;;;;CAKD,MAAM,KAAK,EAAE,MAAM,iBAAiB,cAAc,WAA8B,EAAiB;AAChG,OAAK,cAAc;GAClB;GACA;EACA;AAED,MAAI;AACH,SAAM,KAAK,GAAG,SAAS,KAAK,KAAK,QAAQ,KAAK,CAAC;GAC/C,MAAM,WAAW,MAAM,mBAAmB,KAAK,GAAG,UAAU,WAAW;AACvE,OAAI,YAAY,MAAM;IACrB,MAAM,eAAe,gBAAgB,2BAA2B;AAEhE,UAAM,KAAK,kBAAkB,MAAM,aAAa;GAChD,OAAM;IACN,MAAM,eAAe,MAAM,gBAAgB,oBAAoB,SAAS,oBAAoB;AAC5F,UAAM,KAAK,gBAAgB,MAAM,cAAc,SAAS;GACxD;AAED,SAAM,KAAK,mBAAmB,yBAAyB;IACtD,cAAc;IACd,kBAAkB,KAAK,MAAM;IAC7B,UAAU;IACV,2BAA2B,KAAK,MAAM;IACtC,yBAAyB,KAAK,MAAM;IACpC,kBAAkB;IAClB,oBAAoB;GACpB,EAAC;AAEF,QAAK,MAAM,iBAAiB;AAC5B,SAAM,KAAK,+BAA+B,MAAM,UAAU;AAC1D,SAAM,KAAK,MAAM;AACjB,SAAM,KAAK,MAAM,eAAe,MAAM,KAAK,MAAM,sBAAsB;GACvE,MAAM,wBAAwB,MAAM,KAAK,yBAAyB,KAAK;AACvE,SAAM,KAAK,iBAAiB,sBAAsB,CAAC,MAAM,QAAQ,gBAAgB,CAAC,MAAM,KAAK,qBAAqB,CAAC,CAAC;EACpH,SAAQ,GAAG;AACX,OAAI,iBAAiB,UAAU,aAAa,0BAA0B,aAAa,4BAA4B;AAM9G,YAAQ,IAAI,wCAAwC,EAAE;AACtD,WAAO,KAAK,gBAAgB;GAC5B,OAAM;AACN,UAAM,KAAK,mBAAmB,yBAAyB;KACtD,cAAc;KACd,kBAAkB,KAAK,MAAM;KAC7B,UAAU;KACV,2BAA2B,KAAK,MAAM;KACtC,yBAAyB,KAAK,MAAM;KACpC,kBAAkB;KAClB,oBAAoB,KAAK,MAAM;KAC/B,OAAO,aAAa,kBAAkB,oBAAoB,iBAAiB,oBAAoB;IAC/F,EAAC;AAEF,SAAK,6BAA6B,OAAO,EAAE;AAE3C,UAAM;GACN;EACD;CACD;CAED,AAAQ,QAAQC,MAAY;AAC3B,SAAO,cAAc,KAAK,IAAI;CAC9B;CAED,MAAc,+BAA+BA,MAAYC,WAAkC;AAC1F,MAAI;GACH,MAAMC,cAA2B,MAAM,KAAK,QAAQ,SAAS,oBAAoB,KAAK,UAAU,MAAM;GACtG,MAAM,iBAAiB,MAAM,KAAK,SAAS,kBAAkB,YAAY;AACzE,OAAI,mBAAmB,0BACtB,OAAM,KAAK,SAAS,qBAAqB,YAAY;SAG7C,WAAW,eACnB,OAAM,KAAK,QAAQ,QAAQ,gBAAgB,YAAY,SAAS;EAEjE,SAAQ,GAAG;AAEX,SAAM,aAAa,eAClB,OAAM;EAEP;CACD;CAED,qBAAoC;AACnC,SAAO,KAAK,GAAG,YAAY,KAAK,MAAM;AACrC,UAAO,KAAK,MAAM,mBAAmB,KAAK,YAAY,KAAK,CAAC,KAAK,MAAM;AAEtE,SAAK,MAAM,uBAAuB,MAAM,QAAQ,gBAAgB,KAAK,CAAC;GACtE,EAAC;EACF,EAAC;CACF;CAED,MAAM,sBAAqC;AAC1C,QAAM,KAAK,GAAG;AAEd,OAAK,KAAK,MAAM,qBAAqB,EAAE;AACtC,SAAM,KAAK,YAAY,KAAK,YAAY,KAAK,IAAI;AACjD,SAAM,KAAK,KAAK;IACf,MAAM,KAAK,YAAY;IACvB,iBAAiB,KAAK,YAAY;GAClC,EAAC;EACF;CACD;CAED,MAAM,YAAYC,QAA+B;AAChD,OAAK,MAAM,gBAAgB;AAC3B,QAAM,KAAK,MAAM,oBAAoB,OAAO;CAC5C;CAED,gBAAgBC,oBAA2C;AAC1D,SAAO,KAAK,MAAM,oBAAoB,KAAK,YAAY,MAAM,mBAAmB;CAChF;CAED,qBAAoC;AACnC,SAAO,KAAK,MAAM,oBAAoB;CACtC;CAED,kBAAkBC,SAAwB;AACzC,OAAK,oBAAoB,WAAW,QAAQ;CAC5C;CAED,kBAAkB;AACjB,OAAK,MAAM,MAAM,OAAO;CACxB;CAED,MAAM,oBAAoBC,SAAiC;AAC1D,OAAK,MAAM,oBAAoB,QAAQ;CACvC;CAED,iBAAgC;EAC/B,MAAM,yBAAyB,KAAK,MAAM;AAC1C,SAAO,KAAK,MAAM,oBAAoB,cAAc,KAAK,YAAY,KAAK,IAAI,CAAC,CAAC,KAAK,MAAM;AAE1F,UAAO,KAAK,KAAK;IAChB,MAAM,KAAK,YAAY;IACvB,iBAAiB,KAAK,YAAY;IAClC,cAAc;GACd,EAAC,CAAC,KAAK,MAAM;AACb,QAAI,uBACH,QAAO,KAAK,oBAAoB;GAEjC,EAAC;EACF,EAAC;CACF;CAED,MAAc,kBAAkBN,MAAYO,cAA2C;AACtF,OAAK,GAAG,MAAM,iBAAiB;AAC/B,OAAK,GAAG,KAAK,OAAO,mBAAmB,eAAe;EACtD,MAAM,eAAe,MAAM,KAAK,eAAe,KAAK;EACpD,MAAM,eAAe,2BAA2B,cAAc,KAAK,GAAG,IAAI;EAC1E,MAAM,cAAc,MAAM,KAAK,GAAG,SAAS,kBAAkB,OAAO,CAAC,YAAY,WAAY,EAAC;AAC9F,QAAM,YAAY,IAAI,YAAY,SAAS,cAAc,aAAa,IAAI;AAC1E,QAAM,YAAY,IAAI,YAAY,SAAS,qBAAqB,KAAK,MAAM,oBAAoB;AAC/F,QAAM,YAAY,IAAI,YAAY,SAAS,SAAS,8BAA8B,KAAK,GAAG,KAAK,KAAK,GAAG,GAAG,CAAC;AAC3G,QAAM,YAAY,IAAI,YAAY,SAAS,qBAAqB,aAAa,qBAAqB;AAClG,QAAM,YAAY,IAAI,YAAY,SAAS,sBAAsB,KAAK,kBAAkB,eAAe,CAAC,sBAAsB,CAAC;AAC/H,QAAM,KAAK,eAAe,cAAc,YAAY;AACpD,QAAM,KAAK,sBAAsB;AACjC,OAAK,6BAA6B,SAAS;CAC3C;CAED,MAAc,gBAAgBP,MAAYQ,cAAsBC,UAAmD;AAClH,OAAK,GAAG,MAAM,WAAW,cAAc,SAAS,aAAa;AAC7D,OAAK,GAAG,KAAK,0BAA0B,KAAK,GAAG,KAAK,UAAU,SAAS,QAAQ,EAAE,KAAK;AACtF,OAAK,MAAM,sBAAsB,SAAS;EAC1C,MAAM,YAAY,MAAM,KAAK,eAAe,KAAK;AACjD,QAAM,KAAK,cAAc,MAAM,UAAU;AACzC,QAAM,KAAK,MAAM,4BAA4B,KAAK;AAClD,QAAM,KAAK,sBAAsB;AACjC,OAAK,6BAA6B,SAAS;AAC3C,QAAM,KAAK,SAAS,iBAAiB,MAAM;CAC3C;CAED,MAAM,uBAAsC;EAC3C,MAAMC,IAAmB,MAAM,KAAK,GAAG,SAAS,kBAAkB,MAAM,CAAC,WAAY,EAAC;EACtF,MAAM,kBAAkB,MAAM,KAAW,MAAM,EAAE,OAAO,YAAY,EAAE,CAACC,mBAAkC,SAAa,eAAe,IAAI,CAAC;AAE1I,MAAI,gBAAgB,WAAW,GAAG;AAEjC,WAAQ,IAAI,8CAA8C;AAC1D,QAAK,qBAAqB;EAC1B;AAED,OAAK,mBAAmB;CACxB;CAED,eAAeX,MASZ;EACF,IAAIY,gBAGC,uBAAuB,KAAK,CAAC,IAAI,CAAC,MAAM;AAC5C,UAAO;IACN,IAAI,EAAE;IACN,MAAM,uBAAuB,EAAE;GAC/B;EACD,EAAC;AACF,SAAO,KAAK,GAAG,SAAS,kBAAkB,MAAM,CAAC,WAAY,EAAC,CAAC,KAAK,CAAC,MAAM;AAC1E,UAAO,EAAE,OAAO,YAAY,CAAC,KAC5B,CACCC,iBAII;AACJ,SAAK,MAAM,QAAQ,aAAa,CAC/B,OAAM,IAAI,0BAA0B;IAErC,IAAI,YAAY,aAAa,IAAI,CAAC,UAAU;AAC3C,gBAAW,OAAO,QAAQ,mBAAmB,OAAO,OAAO,cAAc,SACxE,OAAM,IAAI,2BAA2B,6BAA6B,MAAM,GAAG,KAAK,UAAU,MAAM,CAAC;KAElG,MAAMC,KAAS,MAAM;AACrB,YAAO;MACN;MACA,MAAM,MAAM,MAAM;KAClB;IACD,EAAC;IACF,IAAI,gBAAgB,UAAU,OAAO,CAAC,cAAc,cAAc,KAAK,CAAC,MAAM,EAAE,OAAO,SAAS,GAAG,CAAC;IACpG,IAAI,YAAY,cAAc,OAAO,CAAC,OAAO,UAAU,KAAK,CAAC,aAAa,EAAE,OAAO,SAAS,GAAG,CAAC;AAChG,WAAO;KACN;KACA;IACA;GACD,EACD;EACD,EAAC;CACF;;;;;;CAOD,cACCd,MACAe,WAUgB;AAChB,MAAI,UAAU,cAAc,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU,QAAQ,EAAE,SAAS,UAAU,QAAQ,CACjG,QAAO,QAAQ,OAAO,IAAI,uBAAuB,oDAAoD;SAC3F,UAAU,UAAU,SAAS,EACvC,QAAO,KAAK,eACX,MACA,UAAU,UAAU,IAAI,CAAC,MAAM,EAAE,GAAG,CACpC,CAAC,KACD,CACCC,iBAII;AACJ,UAAO,KAAK,GAAG,SAAS,kBAAkB,OAAO,CAAC,WAAY,EAAC,CAAC,KAAK,CAAC,MAAM;AAC3E,WAAO,KAAK,eAAe,cAAc,EAAE;GAC3C,EAAC;EACF,EACD;AAGF,SAAO,QAAQ,SAAS;CACxB;;;;CAKD,eACChB,MACAiB,uBAMC;EACD,IAAI,cAAc,uBAAuB,KAAK;EAC9C,MAAM,aAAa;AAEnB,MAAI,WACH,eAAc,YAAY,OAAO,CAAC,eAAe,SAAS,YAAY,WAAW,MAAM,CAAC;AAGzF,SAAO,KAAW,aAAa,CAACC,eAAgC;AAE/D,UAAO,KAAK,QACV,UAAU,yBAAyB,WAAW,OAAO,kBAAkB,GAAG,KAAK,CAC/E,KAAK,CAAC,iBAAiB;AACvB,WAAO;KACN,SAAS,WAAW;KACpB,WAAW;MACV,cAAc,aAAa,IAAI,CAAC,eAAe,WAAW,IAAI,GAAG;MACjE,gBAAgB;MAChB,WAAW,uBAAuB,WAAW;KAC7C;IACD;GACD,EAAC,CACD,MACA,QAAQ,oBAAoB,MAAM;AACjC,YAAQ,IAAI,+DAA+D;AAC3E,WAAO;GACP,EAAC,CACF;EACF,EAAC,CACA,KAAK,CAAC,SAAS,KAAK,OAAO,UAAU,CAAC;CACxC;;;;CAKD,eACCC,cAIAC,IACgB;AAChB,OAAK,MAAM,wBAAwB,aAClC,IAAG,IAAI,aAAa,qBAAqB,SAAS,qBAAqB,UAAU;AAElF,SAAO,GAAG,MAAM;CAChB;CAED,MAAM,iBACLC,uBAIgB;EAChB,MAAMC,qBAAoC,CAAE;EAC5C,MAAM,2BAA2B,IAAI;EACrC,MAAM,cAAc,MAAM,KAAK,GAAG,SAAS,kBAAkB,MAAM,CAAC,UAAW,EAAC;EAChF,MAAMC,kBAAiC,MAAM,YAAY,IAAI,YAAY,SAAS,qBAAqB;AACvG,QAAM,KAAK,mBAAmB;AAE9B,MAAI;AACH,QAAK,IAAI,uBAAuB,sBAC/B,KAAI,oBAAoB,cAAc,SAAS,GAAG;IACjD,IAAI,UAAU,KAAK,wCAAwC,oBAAoB,cAAc;IAE7F,IAAIC,uBAA2C,CAAE;AACjD,2BAAuB,MAAM,KAAK,QAAQ,QAAQ,yBAAyB,oBAAoB,SAAS,QAAQ;IAChH,MAAMC,iBAAgC,CAAE;AAExC,SAAK,IAAI,SAAS,sBAAsB;KACvC,MAAM,UAAU,aAAa,MAAM;AAEnC,SAAI,oBAAoB,cAAc,QAAQ,QAAQ,KAAK,MAAM,sBAAsB,SAAS,QAAQ,EAAE;AACzG,qBAAe,KAAK;OACnB,SAAS,oBAAoB;OAC7B;OACA,QAAQ,MAAM;MACd,EAAC;MACF,MAAM,YAAY,yBAAyB,IAAI,oBAAoB,QAAQ;AAE3E,UAAI,aAAa,QAAQ,sBAAsB,SAAS,UAAU,CACjE,0BAAyB,IAAI,oBAAoB,SAAS,QAAQ;KAEnE;IACD;AAgBD,QAAI,mBAAmB,QAAQ,qBAAqB,WAAW,eAAe,OAI7E,OAAM,IAAI,gBAAgB,kCAAkC,oBAAoB,QAAQ,iBAAiB,QAAQ;AAGlH,uBAAmB,KAAK,GAAG,eAAe;GAC1C;EAEF,SAAQ,GAAG;AACX,OAAI,aAAa,oBAAoB;AACpC,YAAQ,IAAI,+DAA+D;AAC3E;GACA;AAED,SAAM;EACN;AAID,OAAK,MAAM,kBAAkB,mBAAmB;AAGhD,OAAK,mCAAmC;AAExC,OAAK,oBAAoB,QAAQ;AAEjC,OAAK,iBAAiB;AACtB,QAAM,KAAK,uBAAuB;CAClC;CAED,wCAAwCC,mBAA6B;EACpE,IAAI,gBAAgB,kBAAkB;EACtC,IAAI,gBAAgB,kBAAkB,kBAAkB,SAAS;EAGjE,IAAI,UAAU,uBAAuB,uBAAuB,cAAc,GAAG,IAAU;AAGvF,OAAK,sBAAsB,SAAS,cAAc,CAEjD,WAAU,uBAAuB,uBAAuB,cAAc,GAAG,EAAE;AAG5E,SAAO;CACP;;;;CAKD,yBAAyB1B,MAKvB;AACD,SAAO,KAAK,GAAG,SAAS,kBAAkB,MAAM,CAAC,WAAY,EAAC,CAAC,KAAK,CAAC,MAAM;AAC1E,UAAO,QAAQ,IACd,uBAAuB,KAAK,CAAC,IAAI,CAAC,eAAe;AAChD,WAAO,EAAE,IAAI,aAAa,WAAW,MAAM,CAAC,KAAK,CAAC2B,cAAgC;AACjF,SAAI,UACH,QAAO;MACN,SAAS,WAAW;MACpB,eAAe,UAAU;KACzB;IAED,OAAM,IAAI,0BACT,6BAA6B,WAAW,QAAQ,uBAAuB,KAAK,iBAAiB,KAAK,IAAI;IAGxG,EAAC;GACF,EAAC,CACF;EACD,EAAC;CACF;CAED,qBAAqBC,OAAkC;EACtD,MAAM,EAAE,QAAQ,SAAS,SAAS,GAAG;AACrC,SAAO,KAAK,GAAG,YACb,KAAK,YAAY;AACjB,QAAK,KAAK,GAAG,SAAS,kBACrB,QAAO,QAAQ,SAAS;AAGzB,OACC,uBAAuB,KAAK,YAAY,KAAK,CAC3C,IAAI,CAAC,MAAM,EAAE,MAAM,CACnB,QAAQ,QAAQ,KAAK,GAEvB,QAAO,QAAQ,SAAS;AAGzB,OAAI,KAAK,iBAAiB,QAAQ,QAAQ,KAAK,GAC9C,QAAO,QAAQ,SAAS;AAGzB,aAAU,sBAAsB;GAChC,MAAMC,gBAAmD,IAAI;AAE7D,UAAO,OAAO,CAAC,KAAK,WAAW;AAC9B,QAAI,oBAAoB,aAAa,OAAO,aAAa,OAAO,KAAK,CACpE,YAAW,KAAK,aAAa,MAAM,CAAE,EAAC,CAAC,KAAK,OAAO;SACzC,oBAAoB,gBAAgB,OAAO,aAAa,OAAO,KAAK,CAC9E,YAAW,KAAK,gBAAgB,MAAM,CAAE,EAAC,CAAC,KAAK,OAAO;SAC5C,oBAAoB,aAAa,OAAO,aAAa,OAAO,KAAK,CAC3E,YAAW,KAAK,aAAa,MAAM,CAAE,EAAC,CAAC,KAAK,OAAO;SACzC,oBAAoB,wBAAwB,OAAO,aAAa,OAAO,KAAK,CACtF,YAAW,KAAK,wBAAwB,MAAM,CAAE,EAAC,CAAC,KAAK,OAAO;AAG/D,WAAO;GACP,GAAE,cAAc;AACjB,aAAU,eAAe;AACzB,UAAO,KAAW,cAAc,SAAS,EAAE,CAAC,CAAC,KAAK,MAAM,KAAK;IAC5D,IAAI,UAAU,QAAQ,SAAS;AAE/B,QAAI,cAAc,aAAa,IAAI,CAClC,QAAO,KAAK,yBAAyB,MAAM;IAG5C,MAAM,kBACL,cAAc,wBAAwB,IAAI,IAAI,cAAc,aAAa,IAAI,GAAG,kBAAkB,YAAY,GAAG,kBAAkB,IAAI;IACxI,MAAM,cAAc,sBAAsB,gBAAgB;AAE1D,QAAI,cAAc,aAAa,IAAI,CAClC,WAAU,KAAK,MAAM,oBAAoB,OAAO,SAAS,SAAS,YAAY;SACpE,cAAc,gBAAgB,IAAI,CAC5C,WAAU,KAAK,SAAS,oBAAoB,OAAO,SAAS,SAAS,YAAY;SACvE,cAAc,wBAAwB,IAAI,CACpD,WAAU,KAAK,MAAM,+BAA+B,OAAO,SAAS,SAAS,YAAY;AAG1F,WAAO,QACL,KAAK,MAAM;AACX,aAAQ,eAAe;AACvB,eAAU,mBAAmB;AAC7B,YAAO,KAAK,MAAM,4BAA4B,SAAS,SAAS,YAAY;IAC5E,EAAC,CACD,KAAK,MAAM;AACX,aAAQ,mBAAmB;AAC3B,aAAQ,sBAAsB;IAK9B,EAAC;GACH,EAAC;EACF,EAAC,CACD,MAAM,QAAQ,gBAAgB,KAAK,CAAC,CACpC,MACA,QAAQ,SAAS,CAAC,MAAM;AACvB,OAAI,KAAK,MAAM,qBAAqB,CACnC,SAAQ,IAAI,8CAA8C,EAAE;IAE5D,OAAM;EAEP,EAAC,CACF,CACA,MACA,QAAQ,2BAA2B,CAAC,MAAM;AACzC,WAAQ,IAAI,wDAAwD;AAEpE,QAAK,MAAM,gBAAgB;AAE3B,UAAO,KAAK,gBAAgB;EAC5B,EAAC,CACF;CACF;;;;;CAMD,MAAM,yBAAyBC,QAAuC;AACrE,OAAK,MAAM,SAAS,QAAQ;AAC3B,SAAM,MAAM,cAAc,cAAc,UAAU,SAAS,KAAK,YAAY,KAAK,KAAK,MAAM,WAAW,EACtG;AAED,QAAK,YAAY,OAAO,MAAM,KAAK,QAAQ,KAAK,aAAa,MAAM,WAAW;AAC9E,SAAM,yBAAyB,KAAK,GAAG,UAAU,KAAK,YAAY,iBAAiB,WAAW;EAC9F;CACD;CAED,MAAM,oBAAmC;EACxC,MAAM,cAAc,MAAM,KAAK,GAAG,SAAS,kBAAkB,MAAM,CAAC,UAAW,EAAC;EAChF,MAAM,kBAAkB,MAAM,YAAY,IAAI,YAAY,SAAS,qBAAqB;AAExF,MAAI,mBAAmB,MAAM;GAC5B,MAAM,MAAM,KAAK,kBAAkB,eAAe,CAAC,sBAAsB;GAEzE,MAAM,qBAAqB,MAAM;AAEjC,OAAI,sBAAsB,aAAa,4BAA4B,CAClE,OAAM,IAAI,gBACR,kCAAkC,aAAa,mBAAmB,CAAC,yBAAyB,IAAI,KAChG,UAAU,gBAAgB,EACzB,UAAU,CAAC;EAGf;CACD;CAED,MAAM,wBAAwB;EAC7B,MAAM,cAAc,MAAM,KAAK,GAAG,SAAS,kBAAkB,OAAO,CAAC,UAAW,EAAC;EAEjF,MAAM,MAAM,KAAK,kBAAkB,eAAe,CAAC,sBAAsB;AAEzE,QAAM,YAAY,IAAI,YAAY,SAAS,sBAAsB,IAAI;CACrE;AACD"}