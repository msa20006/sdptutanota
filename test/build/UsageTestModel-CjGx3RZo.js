
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { TypeRef, assertNotNull, filterInt, neverNull } from "./dist-CJHwsXKY.js";
import { BadRequestError, NotFoundError, PreconditionFailedError } from "./RestError-D17JEBMr.js";
import { SuspensionError } from "./SuspensionError-okvIjE4H.js";
import { isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { create } from "./EntityUtils-RQxXZlcV.js";
import { UserSettingsGroupRootTypeRef, createUserSettingsGroupRoot } from "./TypeRefs-CR3TLWn0.js";
import { CustomerPropertiesTypeRef, CustomerTypeRef } from "./TypeRefs-BP1jvX9p.js";
import { resolveTypeReference, typeModels$1 as typeModels } from "./EntityFunctions-l6CncM5C.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { SuspensionBehavior } from "./RestClient-CmoHrId4.js";

//#region ../src/common/api/entities/usage/TypeRefs.ts
const UsageTestAssignmentTypeRef = new TypeRef("usage", "UsageTestAssignment");
const UsageTestAssignmentInTypeRef = new TypeRef("usage", "UsageTestAssignmentIn");
function createUsageTestAssignmentIn(values) {
	return Object.assign(create(typeModels.UsageTestAssignmentIn, UsageTestAssignmentInTypeRef), values);
}
const UsageTestAssignmentOutTypeRef = new TypeRef("usage", "UsageTestAssignmentOut");
const UsageTestMetricConfigTypeRef = new TypeRef("usage", "UsageTestMetricConfig");
const UsageTestMetricConfigValueTypeRef = new TypeRef("usage", "UsageTestMetricConfigValue");
const UsageTestMetricDataTypeRef = new TypeRef("usage", "UsageTestMetricData");
function createUsageTestMetricData(values) {
	return Object.assign(create(typeModels.UsageTestMetricData, UsageTestMetricDataTypeRef), values);
}
const UsageTestParticipationInTypeRef = new TypeRef("usage", "UsageTestParticipationIn");
function createUsageTestParticipationIn(values) {
	return Object.assign(create(typeModels.UsageTestParticipationIn, UsageTestParticipationInTypeRef), values);
}
const UsageTestStageTypeRef = new TypeRef("usage", "UsageTestStage");

//#endregion
//#region ../packages/tutanota-usagetests/dist/model/Stage.js
var Stage = class {
	number;
	test;
	minPings;
	maxPings;
	collectedMetrics = new Map();
	metricConfigs = new Map();
	constructor(number, test, minPings, maxPings) {
		this.number = number;
		this.test = test;
		this.minPings = minPings;
		this.maxPings = maxPings;
	}
	/**
	* Attempts to complete the stage and returns true if a ping has been sent successfully.
	*/
	async complete() {
		return await this.test.completeStage(this);
	}
	setMetric(metric) {
		this.collectedMetrics.set(metric.name, metric);
	}
	setMetricConfig(metricConfig) {
		this.metricConfigs.set(metricConfig.name, metricConfig);
	}
};
var ObsoleteStage = class extends Stage {
	async complete() {
		return true;
	}
	setMetric(metric) {}
};

//#endregion
//#region ../packages/tutanota-usagetests/dist/model/UsageTest.js
const NO_PARTICIPATION_VARIANT = 0;
var UsageTest = class {
	testId;
	testName;
	variant;
	active;
	stages = new Map();
	pingAdapter;
	lastCompletedStage = 0;
	meta = {};
	/**
	* Enabling this makes it possible to restart a test even if the last stage has not been sent.
	*/
	allowEarlyRestarts = false;
	sentPings = 0;
	started = false;
	recordTime = false;
	lastPingDate;
	constructor(testId, testName, variant, active) {
		this.testId = testId;
		this.testName = testName;
		this.variant = variant;
		this.active = active;
	}
	/**
	Tries to restart the test (by sending stage 0) regardless of the allowEarlyRestarts setting
	*/
	forceRestart() {
		return this.completeStage(this.getStage(0), true);
	}
	isStarted() {
		return this.started;
	}
	getStage(stageNum) {
		const stage = this.stages.get(stageNum);
		if (!stage) {
			console.log(`Stage ${stageNum} is not registered, meaning that test '${this.testName}' is likely misconfigured`);
			return new ObsoleteStage(0, this, 0, 0);
		}
		return stage;
	}
	addStage(stage) {
		if (this.stages.get(stage.number)) throw new Error(`Stage ${stage.number} is already registered`);
		this.stages.set(stage.number, stage);
		return stage;
	}
	getVariant(variants) {
		return variants[this.variant]();
	}
	/**
	* Completes a range of stages in the case that we want to make sure that previous stages are/have been sent.
	*
	* Useful when reaching a stage necessitates (and implies) that all previous stages have been sent successfully.
	*/
	async completeRange(start, end) {
		for (let i = start; i <= end; i++) await this.getStage(i).complete();
	}
	/**
	* Should not be used directly. Use stage.complete() instead.
	*/
	async completeStage(stage, forceRestart = false) {
		if (!this.pingAdapter) throw new Error("no ping adapter has been registered");
else if (this.variant === NO_PARTICIPATION_VARIANT || !this.active) return false;
else if (this.sentPings >= stage.maxPings && this.lastCompletedStage === stage.number && (stage.number !== 0 || !this.allowEarlyRestarts)) {
			console.log(`Not sending ping for stage (${stage.number}) of test '${this.testId}' because maxPings=${stage.maxPings} has been reached`);
			return false;
		} else if (!forceRestart && !this.allowEarlyRestarts && this.isStarted() && stage.number === 0 && this.lastCompletedStage !== this.stages.size - 1) {
			console.log(`Cannot restart test '${this.testName}' because allowEarlyRestarts=false and the final stage has not been reached`);
			return false;
		} else if (stage.number < this.lastCompletedStage && stage.number !== 0) {
			console.log(`Cannot send ping for stage (${stage.number}) of test '${this.testId}' because stage ${this.lastCompletedStage} has already been sent`);
			return false;
		}
		for (let i = this.lastCompletedStage + 1; i < stage.number; i++) {
			let currentStage = this.stages.get(i);
			if (!!currentStage && currentStage.minPings != 0) {
				console.log(`Not sending ping for stage (${stage.number}) in wrong order of test '${this.testId}' because stage ${currentStage.number} is not finished`);
				return false;
			}
		}
		console.log(`Test '${this.testName}': Completing stage ${stage.number}, variant ${this.variant}`);
		this.sentPings = stage.number === this.lastCompletedStage ? this.sentPings + 1 : 1;
		this.lastCompletedStage = stage.number;
		if (this.recordTime) {
			const currentDate = new Date();
			if (stage.number > 0) {
				const secondsPassed = this.lastPingDate ? (currentDate.getTime() - this.lastPingDate.getTime()) / 1e3 : 0;
				stage.setMetric({
					name: "secondsPassed",
					value: secondsPassed.toString()
				});
			}
			this.lastPingDate = currentDate;
		}
		await this.pingAdapter.sendPing(this, stage);
		this.started = true;
		return true;
	}
};
var ObsoleteUsageTest = class extends UsageTest {
	obsoleteStage;
	constructor(testId, testName, variant) {
		super(testId, testName, variant, false);
		this.obsoleteStage = new ObsoleteStage(0, this, 1, 1);
	}
	getStage(stageNum) {
		return this.obsoleteStage;
	}
	addStage(stage) {
		return this.obsoleteStage;
	}
	getVariant(variants) {
		return variants[0]();
	}
	async completeStage(stage) {
		return true;
	}
};

//#endregion
//#region ../packages/tutanota-usagetests/dist/model/UsageTestController.js
var UsageTestController = class {
	pingAdapter;
	tests = new Map();
	obsoleteUsageTest = new ObsoleteUsageTest("obsolete", "obsolete", 0);
	constructor(pingAdapter) {
		this.pingAdapter = pingAdapter;
	}
	addTest(test) {
		test.pingAdapter = this.pingAdapter;
		this.tests.set(test.testId, test);
	}
	addTests(tests) {
		for (let test of tests) this.addTest(test);
	}
	setTests(tests) {
		this.tests.clear();
		this.addTests(tests);
	}
	/**
	* Searches a test first by its ID and then, if no match is found, by its name.
	* If no test matches by name either, then we assume that the test is finished and the server no longer sends assignments for it.
	* In that case, we want to render the no-participation variant, so a sham test instance needs to be returned.
	*
	* @param testIdOrName The test's ID or its name
	*/
	getTest(testIdOrName) {
		let result = this.tests.get(testIdOrName);
		if (result) return result;
		for (let test of this.tests.values()) if (test.testName === testIdOrName) return test;
		console.log(`Test '${testIdOrName}' not found, using obsolete...`);
		return this.obsoleteUsageTest;
	}
	/**
	* some components are used in multiple places, but only want to do a test in one of them.
	* use this to get a test that always renders variant 0 and doesn't send pings.
	*/
	getObsoleteTest() {
		return this.obsoleteUsageTest;
	}
};

//#endregion
//#region ../src/common/api/entities/usage/Services.ts
const UsageTestAssignmentService = Object.freeze({
	app: "usage",
	name: "UsageTestAssignmentService",
	get: null,
	post: {
		data: UsageTestAssignmentInTypeRef,
		return: UsageTestAssignmentOutTypeRef
	},
	put: {
		data: UsageTestAssignmentInTypeRef,
		return: UsageTestAssignmentOutTypeRef
	},
	delete: null
});
const UsageTestParticipationService = Object.freeze({
	app: "usage",
	name: "UsageTestParticipationService",
	get: null,
	post: {
		data: UsageTestParticipationInTypeRef,
		return: null
	},
	put: null,
	delete: null
});

//#endregion
//#region ../src/common/misc/UsageTestModel.ts
var import_stream = __toESM(require_stream(), 1);
var EphemeralUsageTestStorage = class {
	assignments = null;
	testDeviceId = null;
	getAssignments() {
		return Promise.resolve(this.assignments);
	}
	getTestDeviceId() {
		return Promise.resolve(this.testDeviceId);
	}
	storeAssignments(persistedAssignmentData) {
		this.assignments = persistedAssignmentData;
		return Promise.resolve();
	}
	storeTestDeviceId(testDeviceId) {
		this.testDeviceId = testDeviceId;
		return Promise.resolve();
	}
};
const ASSIGNMENT_UPDATE_INTERVAL_MS = 36e5;
let StorageBehavior = function(StorageBehavior$1) {
	StorageBehavior$1[StorageBehavior$1["Persist"] = 0] = "Persist";
	StorageBehavior$1[StorageBehavior$1["Ephemeral"] = 1] = "Ephemeral";
	return StorageBehavior$1;
}({});
var UsageTestModel = class {
	storageBehavior = StorageBehavior.Ephemeral;
	customerProperties;
	lastOptInDecision = null;
	lastPing = Promise.resolve();
	constructor(storages, dateProvider, serviceExecutor, entityClient, loginController, eventController, usageTestController) {
		this.storages = storages;
		this.dateProvider = dateProvider;
		this.serviceExecutor = serviceExecutor;
		this.entityClient = entityClient;
		this.loginController = loginController;
		this.eventController = eventController;
		this.usageTestController = usageTestController;
		eventController.addEntityListener((updates) => {
			return this.entityEventsReceived(updates);
		});
	}
	async entityEventsReceived(updates) {
		for (const update of updates) if (isUpdateForTypeRef(CustomerPropertiesTypeRef, update)) {
			await this.loginController.waitForFullLogin();
			await this.updateCustomerProperties();
		} else if (isUpdateForTypeRef(UserSettingsGroupRootTypeRef, update)) {
			await this.loginController.waitForFullLogin();
			const updatedOptInDecision = this.loginController.getUserController().userSettingsGroupRoot.usageDataOptedIn;
			if (this.lastOptInDecision === updatedOptInDecision) return;
			const tests = await this.loadActiveUsageTests();
			this.usageTestController().setTests(tests);
			this.lastOptInDecision = updatedOptInDecision;
		}
	}
	/**
	* only for usage from the console. may have unintended consequences when used too early or too late.
	* @param test the name of the test to change the variant on
	* @param variant the number of the variant to use from here on
	*/
	setVariant(test, variant) {
		this.usageTestController().getTest(test).variant = variant;
	}
	async updateCustomerProperties() {
		const customer = await this.entityClient.load(CustomerTypeRef, neverNull(this.loginController.getUserController().user.customer));
		this.customerProperties = await this.entityClient.load(CustomerPropertiesTypeRef, neverNull(customer.properties));
	}
	/**
	* Needs to be called after construction, ideally after login, so that the logged-in user's CustomerProperties are loaded.
	*/
	async init() {
		await this.updateCustomerProperties();
	}
	setStorageBehavior(storageBehavior) {
		this.storageBehavior = storageBehavior;
	}
	storage() {
		return this.storages[this.storageBehavior];
	}
	/**
	* Returns true if the customer has opted out.
	* Defaults to true if init() has not been called.
	*/
	isCustomerOptedOut() {
		return this.customerProperties?.usageDataOptedOut ?? true;
	}
	/**
	* Returns true if the opt-in dialog indicator should be shown, depending on the user's and the customer's decisions.
	* Defaults to false if init() has not been called.
	*/
	showOptInIndicator() {
		if (!this.loginController.isUserLoggedIn() || this.isCustomerOptedOut()) return false;
		return this.loginController.getUserController().userSettingsGroupRoot.usageDataOptedIn === null;
	}
	/**
	* Sets the user's usage data opt-in decision. True means they opt in.
	*
	* Immediately refetches the user's active usage tests if they opted in.
	*/
	async setOptInDecision(decision) {
		const userSettingsGroupRoot = createUserSettingsGroupRoot(this.loginController.getUserController().userSettingsGroupRoot);
		userSettingsGroupRoot.usageDataOptedIn = decision;
		await this.entityClient.update(userSettingsGroupRoot);
		this.lastOptInDecision = decision;
		const tests = decision ? await this.doLoadActiveUsageTests() : [];
		this.usageTestController().setTests(tests);
	}
	getOptInDecision() {
		if (!this.loginController.isUserLoggedIn()) return false;
		const userOptIn = this.loginController.getUserController().userSettingsGroupRoot.usageDataOptedIn;
		if (!userOptIn) return false;
		return !assertNotNull(this.customerProperties).usageDataOptedOut;
	}
	/**
	* If the storageBehavior is set to StorageBehavior.Persist, then init() must have been called before calling this method.
	*/
	async loadActiveUsageTests() {
		if (this.storageBehavior === StorageBehavior.Persist && !this.getOptInDecision()) return [];
		return await this.doLoadActiveUsageTests();
	}
	async doLoadActiveUsageTests() {
		const persistedData = await this.storage().getAssignments();
		const modelVersion = await this.modelVersion();
		if (persistedData == null || persistedData.usageModelVersion !== modelVersion || Date.now() - persistedData.updatedAt > ASSIGNMENT_UPDATE_INTERVAL_MS) return this.assignmentsToTests(await this.loadAssignments());
else return this.assignmentsToTests(persistedData.assignments);
	}
	async modelVersion() {
		const model = await resolveTypeReference(UsageTestAssignmentTypeRef);
		return filterInt(model.version);
	}
	async loadAssignments() {
		const testDeviceId = await this.storage().getTestDeviceId();
		const data = createUsageTestAssignmentIn({ testDeviceId });
		try {
			const response = testDeviceId ? await this.serviceExecutor.put(UsageTestAssignmentService, data, { suspensionBehavior: SuspensionBehavior.Throw }) : await this.serviceExecutor.post(UsageTestAssignmentService, data, { suspensionBehavior: SuspensionBehavior.Throw });
			await this.storage().storeTestDeviceId(response.testDeviceId);
			await this.storage().storeAssignments({
				assignments: response.assignments,
				updatedAt: this.dateProvider.now(),
				usageModelVersion: await this.modelVersion()
			});
			return response.assignments;
		} catch (e) {
			if (e instanceof SuspensionError) {
				console.log("rate-limit for new assignments reached, disabling tests");
				return [];
			} else if (isOfflineError(e)) {
				console.log("offline, disabling tests");
				return [];
			}
			throw e;
		}
	}
	assignmentsToTests(assignments) {
		return assignments.map((usageTestAssignment) => {
			const test = new UsageTest(usageTestAssignment.testId, usageTestAssignment.name, Number(usageTestAssignment.variant), usageTestAssignment.sendPings);
			for (const [index, stageConfig] of usageTestAssignment.stages.entries()) {
				const stage = new Stage(index, test, Number(stageConfig.minPings), Number(stageConfig.maxPings));
				for (const metricConfig of stageConfig.metrics) {
					const configValues = new Map();
					for (const metricConfigValue of metricConfig.configValues) configValues.set(metricConfigValue.key, metricConfigValue.value);
					stage.setMetricConfig({
						name: metricConfig.name,
						type: metricConfig.type,
						configValues
					});
				}
				test.addStage(stage);
			}
			return test;
		});
	}
	async sendPing(test, stage) {
		this.lastPing = this.lastPing.then(() => this.doSendPing(stage, test), () => this.doSendPing(stage, test));
		return this.lastPing;
	}
	async doSendPing(stage, test) {
		if (this.storageBehavior === StorageBehavior.Persist && !this.getOptInDecision()) return;
		const testDeviceId = await this.storage().getTestDeviceId();
		if (testDeviceId == null) {
			console.warn("No device id set before sending pings");
			return;
		}
		const metrics = Array.from(stage.collectedMetrics).map(([key, { name, value }]) => createUsageTestMetricData({
			name,
			value
		}));
		const data = createUsageTestParticipationIn({
			testId: test.testId,
			metrics,
			stage: stage.number.toString(),
			testDeviceId
		});
		try {
			await this.serviceExecutor.post(UsageTestParticipationService, data, { suspensionBehavior: SuspensionBehavior.Throw });
		} catch (e) {
			if (e instanceof SuspensionError) {
				test.active = false;
				console.log("rate-limit for pings reached");
			} else if (e instanceof PreconditionFailedError) if (e.data === "invalid_state") {
				test.active = false;
				console.log(`Tried to send ping for paused test ${test.testName}`, e);
			} else if (e.data === "invalid_restart") {
				test.active = false;
				console.log(`Tried to restart test '${test.testName}' in ParticipationMode.Once that device has already participated in`, e);
			} else if (e.data === "invalid_stage") console.log(`Tried to send ping for wrong stage ${stage.number} of test '${test.testName}'`, e);
else if (e.data === "invalid_stage_skip") console.log(`Tried to skip a required stage before stage ${stage.number} of test '${test.testName}'`, e);
else if (e.data === "invalid_stage_repetition") console.log(`Tried to repeat stage ${stage.number} of test '${test.testName}' too many times`, e);
else throw e;
else if (e instanceof NotFoundError) {
				test.active = false;
				console.log(`Tried to send ping. Removing test '${test.testName}' from storage`, e);
				const storedAssignments = await this.storage().getAssignments();
				if (storedAssignments) await this.storage().storeAssignments({
					updatedAt: storedAssignments.updatedAt,
					usageModelVersion: storedAssignments.usageModelVersion,
					assignments: storedAssignments.assignments.filter((assignment) => assignment.testId !== test.testId)
				});
			} else if (e instanceof BadRequestError) {
				test.active = false;
				console.log(`Tried to send ping. Setting test '${test.testName}' inactive because it is misconfigured`, e);
			} else if (isOfflineError(e)) console.log("Tried to send ping, but we are offline", e);
else throw e;
		}
	}
};

//#endregion
export { ASSIGNMENT_UPDATE_INTERVAL_MS, EphemeralUsageTestStorage, Stage, StorageBehavior, UsageTest, UsageTestAssignmentInTypeRef, UsageTestAssignmentOutTypeRef, UsageTestAssignmentService, UsageTestAssignmentTypeRef, UsageTestController, UsageTestModel, UsageTestParticipationInTypeRef, UsageTestParticipationService, createUsageTestMetricData };
//# sourceMappingURL=UsageTestModel-CjGx3RZo.js.map