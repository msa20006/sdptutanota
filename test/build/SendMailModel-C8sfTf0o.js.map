{"version":3,"file":"SendMailModel-C8sfTf0o.js","names":["mailboxProperties: MailboxProperties","senderAddress: string","mailFacade: MailFacade","entity: EntityClient","logins: LoginController","mailboxModel: MailboxModel","contactModel: ContactModel","eventController: EventController","mailboxDetails: MailboxDetail","recipientsModel: RecipientsModel","dateProvider: DateProvider","mailboxProperties: MailboxProperties","needNewDraft: (mail: Mail) => Promise<boolean>","updates: ReadonlyArray<EntityUpdateData>","l: Language","mailAddress: string","password: string","subject: string","body: string","senderAddress: string","recipient: PartialRecipient","hasChanged: boolean","recipients: Recipients","bodyText: string","attachments?: ReadonlyArray<Attachment>","confidential?: boolean","senderMailAddress?: string","initialChangedState?: boolean","args: InitAsResponseArgs","inlineImages: InlineImages","previousMessageId: string | null","draft: Mail","draftDetails: MailDetails","attachments: TutanotaFile[]","previousMail: Mail | null","to: RecipientList","cc: RecipientList","bcc: RecipientList","type: RecipientField","fieldType: RecipientField","resolveMode: ResolveMode","address","contact","partialRecipient: PartialRecipient","address: string","notify: boolean","recipient: Recipient","files: ReadonlyArray<Attachment>","file: Attachment","attachments: ReadonlyArray<Attachment> | null","mailMethod: MailMethod","confidential: boolean","getConfirmation: (arg0: MaybeTranslation) => Promise<boolean>","waitHandler: (arg0: MaybeTranslation, arg1: Promise<any>) => Promise<any>","tooManyRequestsError: TranslationKey","saveAttachments: boolean","code: string","resolvedRecipients: Recipient[]","update: EntityUpdateData","contactId: IdTuple","fun: () => unknown","recipientList: ReadonlyArray<PartialRecipient>"],"sources":["../../src/common/misc/MailboxPropertiesUtils.ts","../../src/common/mailFunctionality/SendMailModel.ts"],"sourcesContent":["import type { MailboxProperties } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { ReportMovedMailsType } from \"../api/common/TutanotaConstants\"\nimport { downcast } from \"@tutao/tutanota-utils\"\n\n/**\n * @returns ALWAYS_ASK if not set yet.\n */\nexport function getReportMovedMailsType(props: MailboxProperties | null): ReportMovedMailsType {\n\tif (!props) {\n\t\treturn ReportMovedMailsType.ALWAYS_ASK\n\t}\n\n\treturn downcast(props.reportMovedMails)\n}\n\nexport function getSenderName(mailboxProperties: MailboxProperties, senderAddress: string): string | null {\n\treturn mailboxProperties.mailAddressProperties.find((a) => a.mailAddress === senderAddress)?.senderName ?? null\n}\n","import { assertMainOrNode } from \"../api/common/Env.js\"\nimport { DataFile } from \"../api/common/DataFile.js\"\nimport { FileReference } from \"../api/common/utils/FileUtils.js\"\nimport {\n\tContactTypeRef,\n\tConversationEntryTypeRef,\n\tFileTypeRef,\n\tMail,\n\tMailboxProperties,\n\tMailboxPropertiesTypeRef,\n\tMailDetails,\n\tMailTypeRef,\n} from \"../api/entities/tutanota/TypeRefs.js\"\nimport { ApprovalStatus, ConversationType, MailSetKind, MailMethod, MAX_ATTACHMENT_SIZE, OperationType, ReplyType } from \"../api/common/TutanotaConstants.js\"\nimport { PartialRecipient, Recipient, RecipientList, Recipients, RecipientType } from \"../api/common/recipients/Recipient.js\"\nimport {\n\tassertNotNull,\n\tcleanMatch,\n\tdeduplicate,\n\tdefer,\n\tDeferredObject,\n\tdowncast,\n\tfindAndRemove,\n\tgetFromMap,\n\tLazyLoaded,\n\tneverNull,\n\tnoOp,\n\tofClass,\n\tpromiseMap,\n\tremove,\n\ttypedValues,\n} from \"@tutao/tutanota-utils\"\nimport Stream from \"mithril/stream\"\nimport stream from \"mithril/stream\"\nimport type { File as TutanotaFile } from \"../../common/api/entities/tutanota/TypeRefs.js\"\nimport { checkAttachmentSize, getDefaultSender, getTemplateLanguages, isUserEmail, RecipientField } from \"./SharedMailUtils.js\"\nimport { cloneInlineImages, InlineImages, revokeInlineImages } from \"./inlineImagesUtils.js\"\nimport { RecipientsModel, ResolvableRecipient, ResolveMode } from \"../api/main/RecipientsModel.js\"\nimport { getAvailableLanguageCode, getSubstitutedLanguageCode, lang, Language, languages, TranslationKey, MaybeTranslation } from \"../misc/LanguageViewModel.js\"\nimport { MailFacade } from \"../api/worker/facades/lazy/MailFacade.js\"\nimport { EntityClient } from \"../api/common/EntityClient.js\"\nimport { LoginController } from \"../api/main/LoginController.js\"\nimport { EventController } from \"../api/main/EventController.js\"\nimport { DateProvider } from \"../api/common/DateProvider.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../api/common/utils/EntityUpdateUtils.js\"\nimport { UserController } from \"../api/main/UserController.js\"\nimport { cleanMailAddress, findRecipientWithAddress } from \"../api/common/utils/CommonCalendarUtils.js\"\nimport { getPasswordStrengthForUser, isSecurePassword, PASSWORD_MIN_SECURE_VALUE } from \"../misc/passwords/PasswordUtils.js\"\nimport {\n\tAccessBlockedError,\n\tLockedError,\n\tNotAuthorizedError,\n\tNotFoundError,\n\tPayloadTooLargeError,\n\tPreconditionFailedError,\n\tTooManyRequestsError,\n} from \"../api/common/error/RestError.js\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\nimport { UserError } from \"../api/main/UserError.js\"\nimport { getSenderName } from \"../misc/MailboxPropertiesUtils.js\"\nimport { RecipientNotResolvedError } from \"../api/common/error/RecipientNotResolvedError.js\"\nimport { RecipientsNotFoundError } from \"../api/common/error/RecipientsNotFoundError.js\"\nimport { checkApprovalStatus } from \"../misc/LoginUtils.js\"\nimport { FileNotFoundError } from \"../api/common/error/FileNotFoundError.js\"\nimport { getListId, isSameId, stringToCustomId } from \"../api/common/utils/EntityUtils.js\"\nimport { MailBodyTooLargeError } from \"../api/common/error/MailBodyTooLargeError.js\"\nimport { createApprovalMail } from \"../api/entities/monitor/TypeRefs.js\"\nimport { CustomerPropertiesTypeRef } from \"../api/entities/sys/TypeRefs.js\"\nimport { isMailAddress } from \"../misc/FormatValidator.js\"\nimport { MailboxDetail, MailboxModel } from \"./MailboxModel.js\"\nimport { ContactModel } from \"../contactsFunctionality/ContactModel.js\"\nimport { getContactDisplayName } from \"../contactsFunctionality/ContactUtils.js\"\nimport { getMailBodyText } from \"../api/common/CommonMailUtils.js\"\n\nassertMainOrNode()\n\nexport const TOO_MANY_VISIBLE_RECIPIENTS = 10\n\nexport type Attachment = TutanotaFile | DataFile | FileReference\n\nexport type InitAsResponseArgs = {\n\tpreviousMail: Mail\n\tconversationType: ConversationType\n\tsenderMailAddress: string\n\trecipients: Recipients\n\tattachments: TutanotaFile[]\n\tsubject: string\n\tbodyText: string\n\treplyTos: RecipientList\n}\n\ntype InitArgs = {\n\tconversationType: ConversationType\n\tsubject: string\n\tbodyText: string\n\trecipients: Recipients\n\tconfidential: boolean | null\n\tdraft?: Mail | null\n\tsenderMailAddress?: string\n\tattachments?: ReadonlyArray<Attachment>\n\treplyTos?: RecipientList\n\tpreviousMail?: Mail | null\n\tpreviousMessageId?: string | null\n\tinitialChangedState: boolean | null\n}\n\n/**\n * Model which allows sending mails interactively - including resolving of recipients and handling of drafts.\n */\nexport class SendMailModel {\n\tprivate initialized: DeferredObject<void> | null = null\n\tonMailChanged: Stream<null> = stream(null)\n\tonRecipientDeleted: Stream<{ field: RecipientField; recipient: Recipient } | null> = stream(null)\n\tonBeforeSend: () => void = noOp\n\tloadedInlineImages: InlineImages = new Map()\n\n\t// Isn't private because used by MinimizedEditorOverlay, refactor?\n\tdraft: Mail | null = null\n\tprivate conversationType: ConversationType = ConversationType.NEW\n\tprivate subject: string = \"\"\n\tprivate body: string = \"\"\n\tprivate recipients: Map<RecipientField, Array<ResolvableRecipient>> = new Map()\n\tprivate senderAddress: string\n\tprivate confidential: boolean\n\n\t// contains either Files from Tutanota or DataFiles of locally loaded files. these map 1:1 to the _attachmentButtons\n\tprivate attachments: Array<Attachment> = []\n\n\tprivate replyTos: Array<ResolvableRecipient> = []\n\n\t// only needs to be the correct value if this is a new email. if we are editing a draft, conversationType is not used\n\tprivate previousMessageId: Id | null = null\n\n\tprivate previousMail: Mail | null = null\n\tprivate selectedNotificationLanguage: string\n\tprivate availableNotificationTemplateLanguages: Array<Language> = []\n\tprivate mailChangedAt: number = 0\n\tprivate mailSavedAt: number = 1\n\tprivate passwords: Map<string, string> = new Map()\n\n\t// The promise for the draft currently being saved\n\tprivate currentSavePromise: Promise<void> | null = null\n\n\t// If saveDraft is called while the previous call is still running, then flag to call again afterwards\n\tprivate doSaveAgain: boolean = false\n\tprivate recipientsResolved = new LazyLoaded<void>(async () => {})\n\n\t/**\n\t * creates a new empty draft message. calling an init method will fill in all the blank data\n\t */\n\tconstructor(\n\t\tpublic readonly mailFacade: MailFacade,\n\t\tpublic readonly entity: EntityClient,\n\t\tpublic readonly logins: LoginController,\n\t\tpublic readonly mailboxModel: MailboxModel,\n\t\tpublic readonly contactModel: ContactModel,\n\t\tprivate readonly eventController: EventController,\n\t\tpublic readonly mailboxDetails: MailboxDetail,\n\t\tprivate readonly recipientsModel: RecipientsModel,\n\t\tprivate readonly dateProvider: DateProvider,\n\t\tprivate mailboxProperties: MailboxProperties,\n\t\tprivate readonly needNewDraft: (mail: Mail) => Promise<boolean>,\n\t) {\n\t\tconst userProps = logins.getUserController().props\n\t\tthis.senderAddress = this.getDefaultSender()\n\t\tthis.confidential = !userProps.defaultUnconfidential\n\n\t\tthis.selectedNotificationLanguage = getAvailableLanguageCode(userProps.notificationMailLanguage || lang.code)\n\t\tthis.updateAvailableNotificationTemplateLanguages()\n\n\t\tthis.eventController.addEntityListener(this.entityEventReceived)\n\t}\n\n\tprivate readonly entityEventReceived = async (updates: ReadonlyArray<EntityUpdateData>) => {\n\t\tfor (const update of updates) {\n\t\t\tawait this.handleEntityEvent(update)\n\t\t}\n\t}\n\n\t/**\n\t * Sort list of all languages alphabetically\n\t * then we see if the user has custom notification templates\n\t * in which case we replace the list with just the templates that the user has specified\n\t */\n\tprivate async updateAvailableNotificationTemplateLanguages(): Promise<void> {\n\t\tthis.availableNotificationTemplateLanguages = languages.slice().sort((a, b) => lang.get(a.textId).localeCompare(lang.get(b.textId)))\n\t\tconst filteredLanguages = await getTemplateLanguages(this.availableNotificationTemplateLanguages, this.entity, this.logins)\n\t\tif (filteredLanguages.length > 0) {\n\t\t\tconst languageCodes = filteredLanguages.map((l: Language) => l.code)\n\t\t\tthis.selectedNotificationLanguage =\n\t\t\t\tgetSubstitutedLanguageCode(this.logins.getUserController().props.notificationMailLanguage || lang.code, languageCodes) || languageCodes[0]\n\t\t\tthis.availableNotificationTemplateLanguages = filteredLanguages\n\t\t}\n\t}\n\n\tuser(): UserController {\n\t\treturn this.logins.getUserController()\n\t}\n\n\tisSharedMailbox(): boolean {\n\t\treturn !this.mailboxDetails.mailGroup.user\n\t}\n\n\tgetPreviousMail(): Mail | null {\n\t\treturn this.previousMail\n\t}\n\n\tgetConversationType(): ConversationType {\n\t\treturn this.conversationType\n\t}\n\n\tsetPassword(mailAddress: string, password: string) {\n\t\tthis.onMailChanged(null)\n\t\tthis.passwords.set(mailAddress, password)\n\t}\n\n\tgetPassword(mailAddress: string): string {\n\t\treturn this.passwords.get(mailAddress) || \"\"\n\t}\n\n\tgetSubject(): string {\n\t\treturn this.subject\n\t}\n\n\tsetSubject(subject: string) {\n\t\tthis.markAsChangedIfNecessary(subject !== this.subject)\n\t\tthis.subject = subject\n\t}\n\n\tgetBody(): string {\n\t\treturn this.body\n\t}\n\n\tsetBody(body: string) {\n\t\tthis.markAsChangedIfNecessary(this.body !== body)\n\t\tthis.body = body\n\t}\n\n\t/**\n\t * set the mail address used to send the mail.\n\t * @param senderAddress the mail address that will show up lowercased in the sender field of the sent mail.\n\t */\n\tsetSender(senderAddress: string) {\n\t\t// we can (and should) do this because we lowercase all addresses on signup and when creating aliases.\n\t\tsenderAddress = cleanMailAddress(senderAddress)\n\t\tthis.markAsChangedIfNecessary(this.senderAddress !== senderAddress)\n\t\tthis.senderAddress = senderAddress\n\t}\n\n\tgetSender(): string {\n\t\treturn this.senderAddress\n\t}\n\n\t/**\n\t * Returns the strength indicator for the recipients password\n\t * @returns value between 0 and 100\n\t */\n\tgetPasswordStrength(recipient: PartialRecipient): number {\n\t\treturn getPasswordStrengthForUser(this.getPassword(recipient.address), recipient, this.mailboxDetails, this.logins)\n\t}\n\n\thasMailChanged(): boolean {\n\t\treturn this.mailChangedAt > this.mailSavedAt\n\t}\n\n\t/**\n\t * update the changed state of the mail.\n\t * will only be reset when saving.\n\t */\n\tmarkAsChangedIfNecessary(hasChanged: boolean) {\n\t\tif (!hasChanged) return\n\t\tthis.mailChangedAt = this.dateProvider.now()\n\t\t// if this method is called wherever state gets changed, onMailChanged should function properly\n\t\tthis.onMailChanged(null)\n\t}\n\n\t/**\n\t *\n\t * @param recipients\n\t * @param subject\n\t * @param bodyText\n\t * @param attachments\n\t * @param confidential\n\t * @param senderMailAddress\n\t * @param initialChangedState\n\t * @returns {Promise<SendMailModel>}\n\t */\n\tinitWithTemplate(\n\t\trecipients: Recipients,\n\t\tsubject: string,\n\t\tbodyText: string,\n\t\tattachments?: ReadonlyArray<Attachment>,\n\t\tconfidential?: boolean,\n\t\tsenderMailAddress?: string,\n\t\tinitialChangedState?: boolean,\n\t): Promise<SendMailModel> {\n\t\tthis.startInit()\n\t\treturn this.init({\n\t\t\tconversationType: ConversationType.NEW,\n\t\t\tsubject,\n\t\t\tbodyText,\n\t\t\trecipients,\n\t\t\tattachments,\n\t\t\tconfidential: confidential ?? null,\n\t\t\tsenderMailAddress,\n\t\t\tinitialChangedState: initialChangedState ?? null,\n\t\t})\n\t}\n\n\tasync initAsResponse(args: InitAsResponseArgs, inlineImages: InlineImages): Promise<SendMailModel> {\n\t\tthis.startInit()\n\n\t\tconst { previousMail, conversationType, senderMailAddress, recipients, attachments, subject, bodyText, replyTos } = args\n\t\tlet previousMessageId: string | null = null\n\t\tawait this.entity\n\t\t\t.load(ConversationEntryTypeRef, previousMail.conversationEntry)\n\t\t\t.then((ce) => {\n\t\t\t\tpreviousMessageId = ce.messageId\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, (e) => {\n\t\t\t\t\tconsole.log(\"could not load conversation entry\", e)\n\t\t\t\t}),\n\t\t\t)\n\t\t// if we reuse the same image references, changing the displayed mail in mail view will cause the minimized draft to lose\n\t\t// that reference, because it will be revoked\n\t\tthis.loadedInlineImages = cloneInlineImages(inlineImages)\n\n\t\treturn this.init({\n\t\t\tconversationType,\n\t\t\tsubject,\n\t\t\tbodyText,\n\t\t\trecipients,\n\t\t\tsenderMailAddress,\n\t\t\tconfidential: previousMail.confidential,\n\t\t\tattachments,\n\t\t\treplyTos,\n\t\t\tpreviousMail,\n\t\t\tpreviousMessageId,\n\t\t\tinitialChangedState: false,\n\t\t})\n\t}\n\n\tasync initWithDraft(draft: Mail, draftDetails: MailDetails, attachments: TutanotaFile[], inlineImages: InlineImages): Promise<SendMailModel> {\n\t\tthis.startInit()\n\n\t\tlet previousMessageId: string | null = null\n\t\tlet previousMail: Mail | null = null\n\n\t\tconst conversationEntry = await this.entity.load(ConversationEntryTypeRef, draft.conversationEntry)\n\t\tconst conversationType = downcast<ConversationType>(conversationEntry.conversationType)\n\n\t\tif (conversationEntry.previous) {\n\t\t\ttry {\n\t\t\t\tconst previousEntry = await this.entity.load(ConversationEntryTypeRef, conversationEntry.previous)\n\t\t\t\tpreviousMessageId = previousEntry.messageId\n\t\t\t\tif (previousEntry.mail) {\n\t\t\t\t\tpreviousMail = await this.entity.load(MailTypeRef, previousEntry.mail)\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t// ignore\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we reuse the same image references, changing the displayed mail in mail view will cause the minimized draft to lose\n\t\t// that reference, because it will be revoked\n\t\tthis.loadedInlineImages = cloneInlineImages(inlineImages)\n\t\tconst { confidential, sender, subject } = draft\n\t\tconst { toRecipients, ccRecipients, bccRecipients } = draftDetails.recipients\n\t\tconst recipients: Recipients = {\n\t\t\tto: toRecipients,\n\t\t\tcc: ccRecipients,\n\t\t\tbcc: bccRecipients,\n\t\t}\n\n\t\tconst bodyText = getMailBodyText(draftDetails.body)\n\t\treturn this.init({\n\t\t\tconversationType: conversationType,\n\t\t\tsubject,\n\t\t\tbodyText,\n\t\t\trecipients,\n\t\t\tdraft,\n\t\t\tsenderMailAddress: sender.address,\n\t\t\tconfidential,\n\t\t\tattachments,\n\t\t\treplyTos: draftDetails.replyTos,\n\t\t\tpreviousMail,\n\t\t\tpreviousMessageId,\n\t\t\tinitialChangedState: false,\n\t\t})\n\t}\n\n\tprivate startInit() {\n\t\tif (this.initialized) {\n\t\t\tthrow new ProgrammingError(\"trying to initialize SendMailModel twice\")\n\t\t}\n\t\tthis.initialized = defer()\n\t}\n\n\tprivate async init({\n\t\tconversationType,\n\t\tsubject,\n\t\tbodyText,\n\t\tdraft,\n\t\trecipients,\n\t\tsenderMailAddress,\n\t\tconfidential,\n\t\tattachments,\n\t\treplyTos,\n\t\tpreviousMail,\n\t\tpreviousMessageId,\n\t\tinitialChangedState,\n\t}: InitArgs): Promise<SendMailModel> {\n\t\tthis.conversationType = conversationType\n\t\tthis.subject = subject\n\t\tthis.body = bodyText\n\t\tthis.draft = draft || null\n\n\t\tlet to: RecipientList\n\t\tlet cc: RecipientList\n\t\tlet bcc: RecipientList\n\n\t\tif (recipients instanceof Array) {\n\t\t\tto = recipients\n\t\t\tcc = []\n\t\t\tbcc = []\n\t\t} else {\n\t\t\tto = recipients.to ?? []\n\t\t\tcc = recipients.cc ?? []\n\t\t\tbcc = recipients.bcc ?? []\n\t\t}\n\n\t\t// We deliberately use .map() and not promiseMap() here because we want to insert all\n\t\t// the recipients right away, we count on it in some checks in send() and we also want all of them\n\t\t// to show up immediately.\n\t\t// If we want to limit recipient resolution at some point we need to build a queue in some other place.\n\t\t// Making it LazyLoaded() will allow us to retry it in case it fails.\n\t\t// It is very important that we insert the recipients here synchronously. Even though it is inside the async function it will call insertRecipient()\n\t\t// right away when we call getAsync() below\n\t\tthis.recipientsResolved = new LazyLoaded(async () => {\n\t\t\tawait Promise.all([\n\t\t\t\trecipientsFilter(to).map((r) => this.insertRecipient(RecipientField.TO, r)),\n\t\t\t\trecipientsFilter(cc).map((r) => this.insertRecipient(RecipientField.CC, r)),\n\t\t\t\trecipientsFilter(bcc).map((r) => this.insertRecipient(RecipientField.BCC, r)),\n\t\t\t])\n\t\t})\n\t\t// noinspection ES6MissingAwait\n\t\tthis.recipientsResolved.getAsync()\n\n\t\t// .toLowerCase because all our aliases and accounts are lowercased on creation\n\t\tthis.senderAddress = senderMailAddress?.toLowerCase() || this.getDefaultSender()\n\t\tthis.confidential = confidential ?? !this.user().props.defaultUnconfidential\n\t\tthis.attachments = []\n\n\t\tif (attachments) {\n\t\t\tthis.attachFiles(attachments)\n\t\t}\n\n\t\tthis.replyTos = recipientsFilter(replyTos ?? []).map((recipient) => this.recipientsModel.resolve(recipient, ResolveMode.Eager))\n\t\tthis.previousMail = previousMail || null\n\t\tthis.previousMessageId = previousMessageId || null\n\t\tthis.mailChangedAt = this.dateProvider.now()\n\n\t\t// Determine if we should have this mail already be detected as modified so it saves.\n\t\tif (initialChangedState) {\n\t\t\tthis.onMailChanged(null)\n\t\t\tthis.mailSavedAt = this.mailChangedAt - 1\n\t\t} else {\n\t\t\tthis.mailSavedAt = this.mailChangedAt + 1\n\t\t}\n\n\t\tassertNotNull(this.initialized, \"somehow got to the end of init without startInit called\").resolve()\n\n\t\treturn this\n\t}\n\n\tprivate getDefaultSender(): string {\n\t\treturn getDefaultSender(this.logins, this.mailboxDetails)\n\t}\n\n\tgetRecipientList(type: RecipientField): Array<ResolvableRecipient> {\n\t\treturn getFromMap(this.recipients, type, () => [])\n\t}\n\n\ttoRecipients(): Array<ResolvableRecipient> {\n\t\treturn this.getRecipientList(RecipientField.TO)\n\t}\n\n\ttoRecipientsResolved(): Promise<Array<Recipient>> {\n\t\treturn Promise.all(this.toRecipients().map((recipient) => recipient.resolved()))\n\t}\n\n\tccRecipients(): Array<ResolvableRecipient> {\n\t\treturn this.getRecipientList(RecipientField.CC)\n\t}\n\n\tccRecipientsResolved(): Promise<Array<Recipient>> {\n\t\treturn Promise.all(this.ccRecipients().map((recipient) => recipient.resolved()))\n\t}\n\n\tbccRecipients(): Array<ResolvableRecipient> {\n\t\treturn this.getRecipientList(RecipientField.BCC)\n\t}\n\n\tbccRecipientsResolved(): Promise<Array<Recipient>> {\n\t\treturn Promise.all(this.bccRecipients().map((recipient) => recipient.resolved()))\n\t}\n\n\treplyTosResolved(): Promise<Array<Recipient>> {\n\t\treturn Promise.all(this.replyTos.map((r) => r.resolved()))\n\t}\n\n\t/**\n\t * add a recipient to the recipient list without updating the saved state of the draft.\n\t * if the recipient is already inserted, it will wait for it to resolve before returning.\n\t *\n\t * @returns whether the list was actually changed.\n\t */\n\tprivate async insertRecipient(\n\t\tfieldType: RecipientField,\n\t\t{ address, name, type, contact }: PartialRecipient,\n\t\tresolveMode: ResolveMode = ResolveMode.Eager,\n\t): Promise<boolean> {\n\t\tlet recipient = findRecipientWithAddress(this.getRecipientList(fieldType), address)\n\t\t// Only add a recipient if it doesn't exist\n\t\tif (!recipient) {\n\t\t\trecipient = this.recipientsModel.resolve(\n\t\t\t\t{\n\t\t\t\t\taddress,\n\t\t\t\t\tname,\n\t\t\t\t\ttype,\n\t\t\t\t\tcontact,\n\t\t\t\t},\n\t\t\t\tresolveMode,\n\t\t\t)\n\n\t\t\tthis.getRecipientList(fieldType).push(recipient)\n\n\t\t\trecipient.resolved().then(({ address, contact }) => {\n\t\t\t\tif (!this.passwords.has(address) && contact != null) {\n\t\t\t\t\tthis.setPassword(address, contact.presharedPassword ?? \"\")\n\t\t\t\t} else {\n\t\t\t\t\t// always notify listeners after we finished resolving the recipient, even if email itself didn't change\n\t\t\t\t\tthis.onMailChanged(null)\n\t\t\t\t}\n\t\t\t})\n\t\t\tawait recipient.resolved()\n\t\t\treturn true\n\t\t}\n\t\tawait recipient.resolved()\n\t\treturn false\n\t}\n\n\t/**\n\t * Add a new recipient, this method resolves when the recipient resolves.\n\t * will notify of a changed draft state after the recipient was inserted\n\t */\n\tasync addRecipient(fieldType: RecipientField, partialRecipient: PartialRecipient, resolveMode: ResolveMode = ResolveMode.Eager): Promise<void> {\n\t\tconst wasAdded = await this.insertRecipient(fieldType, partialRecipient, resolveMode)\n\t\tthis.markAsChangedIfNecessary(wasAdded)\n\t}\n\n\tgetRecipient(type: RecipientField, address: string): ResolvableRecipient | null {\n\t\treturn findRecipientWithAddress(this.getRecipientList(type), address)\n\t}\n\n\tremoveRecipientByAddress(address: string, type: RecipientField, notify: boolean = true) {\n\t\tconst recipient = findRecipientWithAddress(this.getRecipientList(type), address)\n\t\tif (recipient) {\n\t\t\tthis.removeRecipient(recipient, type, notify)\n\t\t}\n\t}\n\n\t/**\n\t * remove recipient from the recipient list\n\t * @return true if the recipient was removed\n\t */\n\tremoveRecipient(recipient: Recipient, type: RecipientField, notify: boolean = true): boolean {\n\t\tconst recipients = this.recipients.get(type) ?? []\n\t\tconst cleanRecipientAddress = cleanMailAddress(recipient.address)\n\t\tconst didRemove = findAndRemove(recipients, (r) => cleanMailAddress(r.address) === cleanRecipientAddress)\n\t\tthis.markAsChangedIfNecessary(didRemove)\n\n\t\tif (didRemove && notify) {\n\t\t\tthis.onRecipientDeleted({\n\t\t\t\tfield: type,\n\t\t\t\trecipient,\n\t\t\t})\n\t\t}\n\n\t\treturn didRemove\n\t}\n\n\tdispose() {\n\t\tthis.eventController.removeEntityListener(this.entityEventReceived)\n\n\t\trevokeInlineImages(this.loadedInlineImages)\n\t}\n\n\t/**\n\t * @throws UserError in the case that any files were too big to attach. Small enough files will still have been attached\n\t */\n\tgetAttachments(): Array<Attachment> {\n\t\treturn this.attachments\n\t}\n\n\t/** @throws UserError in case files are too big to add */\n\tattachFiles(files: ReadonlyArray<Attachment>): void {\n\t\tlet sizeLeft = MAX_ATTACHMENT_SIZE - this.attachments.reduce((total, file) => total + Number(file.size), 0)\n\n\t\tconst sizeCheckResult = checkAttachmentSize(files, sizeLeft)\n\n\t\tthis.attachments.push(...sizeCheckResult.attachableFiles)\n\t\tthis.markAsChangedIfNecessary(sizeCheckResult.attachableFiles.length > 0)\n\n\t\tif (sizeCheckResult.tooBigFiles.length > 0) {\n\t\t\tthrow new UserError(lang.makeTranslation(\"tooBigAttachment_msg\", lang.get(\"tooBigAttachment_msg\") + \"\\n\" + sizeCheckResult.tooBigFiles.join(\"\\n\")))\n\t\t}\n\t}\n\n\tremoveAttachment(file: Attachment): void {\n\t\tthis.markAsChangedIfNecessary(remove(this.attachments, file))\n\t}\n\n\tgetSenderName(): string {\n\t\treturn getSenderName(this.mailboxProperties, this.senderAddress) ?? \"\"\n\t}\n\n\tgetDraft(): Readonly<Mail> | null {\n\t\treturn this.draft\n\t}\n\n\tprivate async updateDraft(body: string, attachments: ReadonlyArray<Attachment> | null, draft: Mail): Promise<Mail> {\n\t\treturn this.mailFacade\n\t\t\t.updateDraft({\n\t\t\t\tsubject: this.getSubject(),\n\t\t\t\tbody: body,\n\t\t\t\tsenderMailAddress: this.senderAddress,\n\t\t\t\tsenderName: this.getSenderName(),\n\t\t\t\ttoRecipients: await this.toRecipientsResolved(),\n\t\t\t\tccRecipients: await this.ccRecipientsResolved(),\n\t\t\t\tbccRecipients: await this.bccRecipientsResolved(),\n\t\t\t\tattachments: attachments,\n\t\t\t\tconfidential: this.isConfidential(),\n\t\t\t\tdraft: draft,\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(LockedError, (e) => {\n\t\t\t\t\tconsole.log(\"updateDraft: operation is still active\", e)\n\t\t\t\t\tthrow new UserError(\"operationStillActive_msg\")\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, (e) => {\n\t\t\t\t\tconsole.log(\"draft has been deleted, creating new one\")\n\t\t\t\t\treturn this.createDraft(body, attachments, downcast(draft.method))\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\tprivate async createDraft(body: string, attachments: ReadonlyArray<Attachment> | null, mailMethod: MailMethod): Promise<Mail> {\n\t\treturn this.mailFacade.createDraft({\n\t\t\tsubject: this.getSubject(),\n\t\t\tbodyText: body,\n\t\t\tsenderMailAddress: this.senderAddress,\n\t\t\tsenderName: this.getSenderName(),\n\t\t\ttoRecipients: await this.toRecipientsResolved(),\n\t\t\tccRecipients: await this.ccRecipientsResolved(),\n\t\t\tbccRecipients: await this.bccRecipientsResolved(),\n\t\t\tconversationType: this.conversationType,\n\t\t\tpreviousMessageId: this.previousMessageId,\n\t\t\tattachments: attachments,\n\t\t\tconfidential: this.isConfidential(),\n\t\t\treplyTos: await this.replyTosResolved(),\n\t\t\tmethod: mailMethod,\n\t\t})\n\t}\n\n\tisConfidential(): boolean {\n\t\treturn this.confidential || !this.containsExternalRecipients()\n\t}\n\n\tisConfidentialExternal(): boolean {\n\t\treturn this.confidential && this.containsExternalRecipients()\n\t}\n\n\tsetConfidential(confidential: boolean): void {\n\t\tthis.markAsChangedIfNecessary(this.confidential !== confidential)\n\t\tthis.confidential = confidential\n\t}\n\n\tcontainsExternalRecipients(): boolean {\n\t\treturn this.allRecipients().some((r) => r.type === RecipientType.EXTERNAL)\n\t}\n\n\tgetExternalRecipients(): Array<Recipient> {\n\t\treturn this.allRecipients().filter((r) => r.type === RecipientType.EXTERNAL)\n\t}\n\n\t/**\n\t * @reject {RecipientsNotFoundError}\n\t * @reject {TooManyRequestsError}\n\t * @reject {AccessBlockedError}\n\t * @reject {FileNotFoundError}\n\t * @reject {PreconditionFailedError}\n\t * @reject {LockedError}\n\t * @reject {UserError}\n\t * @param mailMethod\n\t * @param getConfirmation: A callback to get user confirmation\n\t * @param waitHandler: A callback to allow UI blocking while the mail is being sent. it seems like wrapping the send call in showProgressDialog causes the confirmation dialogs not to be shown. We should fix this, but this works for now\n\t * @param tooManyRequestsError\n\t * @return true if the send was completed, false if it was aborted (by getConfirmation returning false\n\t */\n\tasync send(\n\t\tmailMethod: MailMethod,\n\t\tgetConfirmation: (arg0: MaybeTranslation) => Promise<boolean> = (_) => Promise.resolve(true),\n\t\twaitHandler: (arg0: MaybeTranslation, arg1: Promise<any>) => Promise<any> = (_, p) => p,\n\t\ttooManyRequestsError: TranslationKey = \"tooManyMails_msg\",\n\t): Promise<boolean> {\n\t\t// To avoid parallel invocations do not do anything async here that would later execute the sending.\n\t\t// It is fine to wait for getConfirmation() because it is modal and will prevent the user from triggering multiple sends.\n\t\t// If you need to do something async here put it into `asyncSend`\n\t\t//\n\t\t// You can't rely on resolved recipients here, only after waitForResolvedRecipients() inside asyncSend()!\n\t\tthis.onBeforeSend()\n\n\t\tif (this.allRecipients().length === 1 && this.allRecipients()[0].address.toLowerCase().trim() === \"approval@tutao.de\") {\n\t\t\tawait this.sendApprovalMail(this.getBody())\n\t\t\treturn true\n\t\t}\n\n\t\tif (this.toRecipients().length === 0 && this.ccRecipients().length === 0 && this.bccRecipients().length === 0) {\n\t\t\tthrow new UserError(\"noRecipients_msg\")\n\t\t}\n\n\t\tconst numVisibleRecipients = this.toRecipients().length + this.ccRecipients().length\n\n\t\t// Many recipients is a warning\n\t\tif (numVisibleRecipients >= TOO_MANY_VISIBLE_RECIPIENTS && !(await getConfirmation(\"manyRecipients_msg\"))) {\n\t\t\treturn false\n\t\t}\n\n\t\t// Empty subject is a warning\n\t\tif (this.getSubject().length === 0 && !(await getConfirmation(\"noSubject_msg\"))) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst asyncSend = async () => {\n\t\t\t// The next check depends on contacts being available\n\t\t\t// So we need to wait for our recipients here\n\t\t\tconst recipients = await this.waitForResolvedRecipients()\n\n\t\t\t// No password in external confidential mail is an error\n\t\t\tif (this.isConfidentialExternal() && this.getExternalRecipients().some((r) => !this.getPassword(r.address))) {\n\t\t\t\tthrow new UserError(\"noPreSharedPassword_msg\")\n\t\t\t}\n\n\t\t\t// Weak password is a warning\n\t\t\tif (this.isConfidentialExternal() && this.hasInsecurePasswords() && !(await getConfirmation(\"presharedPasswordNotStrongEnough_msg\"))) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tawait this.saveDraft(true, mailMethod)\n\t\t\tawait this.updateContacts(recipients)\n\t\t\tawait this.mailFacade.sendDraft(assertNotNull(this.draft, \"draft was null?\"), recipients, this.selectedNotificationLanguage)\n\t\t\tawait this.updatePreviousMail()\n\t\t\tawait this.updateExternalLanguage()\n\t\t\treturn true\n\t\t}\n\n\t\treturn waitHandler(this.isConfidential() ? \"sending_msg\" : \"sendingUnencrypted_msg\", asyncSend())\n\t\t\t.catch(\n\t\t\t\tofClass(LockedError, () => {\n\t\t\t\t\tthrow new UserError(\"operationStillActive_msg\")\n\t\t\t\t}),\n\t\t\t) // catch all of the badness\n\t\t\t.catch(\n\t\t\t\tofClass(RecipientNotResolvedError, () => {\n\t\t\t\t\tthrow new UserError(\"tooManyAttempts_msg\")\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(RecipientsNotFoundError, (e) => {\n\t\t\t\t\tif (mailMethod === MailMethod.ICAL_CANCEL) {\n\t\t\t\t\t\t// in case of calendar event termination we will remove invalid recipients and then delete the event without sending updates\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet invalidRecipients = e.message\n\t\t\t\t\t\tthrow new UserError(\n\t\t\t\t\t\t\tlang.makeTranslation(\n\t\t\t\t\t\t\t\t\"error_msg\",\n\t\t\t\t\t\t\t\tlang.get(\"tutanotaAddressDoesNotExist_msg\") + \" \" + lang.get(\"invalidRecipients_msg\") + \"\\n\" + invalidRecipients,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(TooManyRequestsError, () => {\n\t\t\t\t\tthrow new UserError(tooManyRequestsError)\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(AccessBlockedError, (e) => {\n\t\t\t\t\t// special case: the approval status is set to SpamSender, but the update has not been received yet, so use SpamSender as default\n\t\t\t\t\treturn checkApprovalStatus(this.logins, true, ApprovalStatus.SPAM_SENDER).then(() => {\n\t\t\t\t\t\tconsole.log(\"could not send mail (blocked access)\", e)\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(FileNotFoundError, () => {\n\t\t\t\t\tthrow new UserError(\"couldNotAttachFile_msg\")\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(PreconditionFailedError, () => {\n\t\t\t\t\tthrow new UserError(\"operationStillActive_msg\")\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\t/**\n\t * Whether any of the external recipients have an insecure password.\n\t * We don't consider empty passwords, because an empty password will disallow and encrypted email from sending, whereas an insecure password\n\t * can still be used\n\t * @returns {boolean}\n\t */\n\thasInsecurePasswords(): boolean {\n\t\tconst minimalPasswordStrength = this.allRecipients()\n\t\t\t.filter((r) => this.getPassword(r.address) !== \"\")\n\t\t\t.reduce((min, recipient) => Math.min(min, this.getPasswordStrength(recipient)), PASSWORD_MIN_SECURE_VALUE)\n\t\treturn !isSecurePassword(minimalPasswordStrength)\n\t}\n\n\tsaveDraft(saveAttachments: boolean, mailMethod: MailMethod): Promise<void> {\n\t\tif (this.currentSavePromise == null) {\n\t\t\tthis.currentSavePromise = Promise.resolve().then(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.doSaveDraft(saveAttachments, mailMethod)\n\t\t\t\t} finally {\n\t\t\t\t\t// If there is an error, we still need to reset currentSavePromise\n\t\t\t\t\tthis.currentSavePromise = null\n\t\t\t\t}\n\t\t\t\tif (this.hasMailChanged() && this.doSaveAgain) {\n\t\t\t\t\tthis.doSaveAgain = false\n\t\t\t\t\tawait this.saveDraft(saveAttachments, mailMethod)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tthis.doSaveAgain = true\n\t\t}\n\n\t\treturn this.currentSavePromise\n\t}\n\n\t/**\n\t * Saves the draft.\n\t * @param saveAttachments True if also the attachments shall be saved, false otherwise.\n\t * @param mailMethod\n\t * @returns {Promise} When finished.\n\t * @throws FileNotFoundError when one of the attachments could not be opened\n\t * @throws PreconditionFailedError when the draft is locked\n\t */\n\tprivate async doSaveDraft(saveAttachments: boolean, mailMethod: MailMethod): Promise<void> {\n\t\tif (this.initialized == null) {\n\t\t\tthrow new ProgrammingError(\"init for SendMailModel was not called\")\n\t\t}\n\t\tawait this.initialized\n\t\ttry {\n\t\t\tconst attachments = saveAttachments ? this.attachments : null\n\n\t\t\t// We also want to create new drafts for drafts edited from trash or spam folder\n\t\t\tconst { htmlSanitizer } = await import(\"../misc/HtmlSanitizer.js\")\n\t\t\tconst unsanitized_body = this.getBody()\n\t\t\tconst body = htmlSanitizer.sanitizeHTML(unsanitized_body, {\n\t\t\t\t// store the draft always with external links preserved. this reverts\n\t\t\t\t// the draft-src and draft-srcset attribute stow.\n\t\t\t\tblockExternalContent: false,\n\t\t\t\t// since we're not displaying this, this is fine.\n\t\t\t\tallowRelativeLinks: true,\n\t\t\t\t// do not touch inline images, we just want to store this.\n\t\t\t\tusePlaceholderForInlineImages: false,\n\t\t\t}).html\n\n\t\t\tthis.draft =\n\t\t\t\tthis.draft == null || (await this.needNewDraft(this.draft))\n\t\t\t\t\t? await this.createDraft(body, attachments, mailMethod)\n\t\t\t\t\t: await this.updateDraft(body, attachments, this.draft)\n\n\t\t\tconst attachmentIds = await this.mailFacade.getAttachmentIds(this.draft)\n\t\t\tconst newAttachments = await promiseMap(attachmentIds, (fileId) => this.entity.load<TutanotaFile>(FileTypeRef, fileId), {\n\t\t\t\tconcurrency: 5,\n\t\t\t})\n\n\t\t\tthis.attachments = [] // attachFiles will push to existing files but we want to overwrite them\n\t\t\tthis.attachFiles(newAttachments)\n\n\t\t\t// Allow any changes that might occur while the mail is being saved to be accounted for\n\t\t\t// if saved is called before this has completed\n\t\t\tthis.mailSavedAt = this.dateProvider.now()\n\t\t} catch (e) {\n\t\t\tif (e instanceof PayloadTooLargeError) {\n\t\t\t\tthrow new UserError(\"requestTooLarge_msg\")\n\t\t\t} else if (e instanceof MailBodyTooLargeError) {\n\t\t\t\tthrow new UserError(\"mailBodyTooLarge_msg\")\n\t\t\t} else if (e instanceof FileNotFoundError) {\n\t\t\t\tthrow new UserError(\"couldNotAttachFile_msg\")\n\t\t\t} else if (e instanceof PreconditionFailedError) {\n\t\t\t\tthrow new UserError(\"operationStillActive_msg\")\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate sendApprovalMail(body: string): Promise<unknown> {\n\t\tconst listId = \"---------c--\"\n\t\tconst m = createApprovalMail({\n\t\t\t_id: [listId, stringToCustomId(this.senderAddress)],\n\t\t\t_ownerGroup: this.user().user.userGroup.group,\n\t\t\ttext: `Subject: ${this.getSubject()}<br>${body}`,\n\t\t\tdate: null,\n\t\t\trange: null,\n\t\t\tcustomer: null,\n\t\t})\n\t\treturn this.entity.setup(listId, m).catch(ofClass(NotAuthorizedError, (e) => console.log(\"not authorized for approval message\")))\n\t}\n\n\tgetAvailableNotificationTemplateLanguages(): Array<Language> {\n\t\treturn this.availableNotificationTemplateLanguages\n\t}\n\n\tgetSelectedNotificationLanguageCode(): string {\n\t\treturn this.selectedNotificationLanguage\n\t}\n\n\tsetSelectedNotificationLanguageCode(code: string) {\n\t\tthis.markAsChangedIfNecessary(this.selectedNotificationLanguage !== code)\n\t\tthis.selectedNotificationLanguage = code\n\t\tthis.markAsChangedIfNecessary(true)\n\t}\n\n\tprivate updateExternalLanguage() {\n\t\tlet props = this.user().props\n\n\t\tif (props.notificationMailLanguage !== this.selectedNotificationLanguage) {\n\t\t\tprops.notificationMailLanguage = this.selectedNotificationLanguage\n\n\t\t\tthis.entity.update(props)\n\t\t}\n\t}\n\n\tprivate updatePreviousMail(): Promise<void> {\n\t\tif (this.previousMail) {\n\t\t\tif (this.previousMail.replyType === ReplyType.NONE && this.conversationType === ConversationType.REPLY) {\n\t\t\t\tthis.previousMail.replyType = ReplyType.REPLY\n\t\t\t} else if (this.previousMail.replyType === ReplyType.NONE && this.conversationType === ConversationType.FORWARD) {\n\t\t\t\tthis.previousMail.replyType = ReplyType.FORWARD\n\t\t\t} else if (this.previousMail.replyType === ReplyType.FORWARD && this.conversationType === ConversationType.REPLY) {\n\t\t\t\tthis.previousMail.replyType = ReplyType.REPLY_FORWARD\n\t\t\t} else if (this.previousMail.replyType === ReplyType.REPLY && this.conversationType === ConversationType.FORWARD) {\n\t\t\t\tthis.previousMail.replyType = ReplyType.REPLY_FORWARD\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve()\n\t\t\t}\n\n\t\t\treturn this.entity.update(this.previousMail).catch(ofClass(NotFoundError, noOp))\n\t\t} else {\n\t\t\treturn Promise.resolve()\n\t\t}\n\t}\n\n\t/**\n\t * If contacts have had their passwords changed, we update them before sending\n\t */\n\tprivate async updateContacts(resolvedRecipients: Recipient[]): Promise<any> {\n\t\tfor (const { address, contact, type } of resolvedRecipients) {\n\t\t\tif (contact == null) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst isExternalAndConfidential = type === RecipientType.EXTERNAL && this.isConfidential()\n\n\t\t\tif (!contact._id && (!this.user().props.noAutomaticContacts || isExternalAndConfidential)) {\n\t\t\t\tif (isExternalAndConfidential) {\n\t\t\t\t\tcontact.presharedPassword = this.getPassword(address).trim()\n\t\t\t\t}\n\n\t\t\t\tconst listId = await this.contactModel.getContactListId()\n\t\t\t\tawait this.entity.setup(listId, contact)\n\t\t\t} else if (contact._id && isExternalAndConfidential && contact.presharedPassword !== this.getPassword(address).trim()) {\n\t\t\t\tcontact.presharedPassword = this.getPassword(address).trim()\n\t\t\t\tawait this.entity.update(contact)\n\t\t\t}\n\t\t}\n\t}\n\n\tallRecipients(): ReadonlyArray<ResolvableRecipient> {\n\t\treturn this.toRecipients().concat(this.ccRecipients()).concat(this.bccRecipients())\n\t}\n\n\t/**\n\t * Makes sure the recipient type and contact are resolved.\n\t */\n\tasync waitForResolvedRecipients(): Promise<Recipient[]> {\n\t\tawait this.recipientsResolved.getAsync()\n\t\treturn Promise.all(this.allRecipients().map((recipient) => recipient.resolved())).catch(\n\t\t\tofClass(TooManyRequestsError, () => {\n\t\t\t\tthrow new RecipientNotResolvedError(\"\")\n\t\t\t}),\n\t\t)\n\t}\n\n\tasync handleEntityEvent(update: EntityUpdateData): Promise<void> {\n\t\tconst { operation, instanceId, instanceListId } = update\n\t\tlet contactId: IdTuple = [neverNull(instanceListId), instanceId]\n\t\tlet changed = false\n\n\t\tif (isUpdateForTypeRef(ContactTypeRef, update)) {\n\t\t\tawait this.recipientsResolved.getAsync()\n\n\t\t\tif (operation === OperationType.UPDATE) {\n\t\t\t\tthis.entity.load(ContactTypeRef, contactId).then((contact) => {\n\t\t\t\t\tfor (const fieldType of typedValues(RecipientField)) {\n\t\t\t\t\t\tconst matching = this.getRecipientList(fieldType).filter(\n\t\t\t\t\t\t\t(recipient) => recipient.contact && isSameId(recipient.contact._id, contact._id),\n\t\t\t\t\t\t)\n\t\t\t\t\t\tfor (const recipient of matching) {\n\t\t\t\t\t\t\t// if the mail address no longer exists on the contact then delete the recipient\n\t\t\t\t\t\t\tif (!contact.mailAddresses.some((ma) => cleanMatch(ma.address, recipient.address))) {\n\t\t\t\t\t\t\t\tchanged = changed || this.removeRecipient(recipient, fieldType, true)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// else just modify the recipient\n\t\t\t\t\t\t\t\trecipient.setName(getContactDisplayName(contact))\n\t\t\t\t\t\t\t\trecipient.setContact(contact)\n\t\t\t\t\t\t\t\tchanged = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else if (operation === OperationType.DELETE) {\n\t\t\t\tfor (const fieldType of typedValues(RecipientField)) {\n\t\t\t\t\tconst recipients = this.getRecipientList(fieldType)\n\n\t\t\t\t\tconst toDelete = recipients.filter((recipient) => (recipient.contact && isSameId(recipient.contact._id, contactId)) || false)\n\n\t\t\t\t\tfor (const r of toDelete) {\n\t\t\t\t\t\tchanged = changed || this.removeRecipient(r, fieldType, true)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.markAsChangedIfNecessary(true)\n\t\t} else if (isUpdateForTypeRef(CustomerPropertiesTypeRef, update)) {\n\t\t\tthis.updateAvailableNotificationTemplateLanguages()\n\t\t} else if (isUpdateForTypeRef(MailboxPropertiesTypeRef, update) && operation === OperationType.UPDATE) {\n\t\t\tthis.mailboxProperties = await this.entity.load(MailboxPropertiesTypeRef, update.instanceId)\n\t\t}\n\t\tthis.markAsChangedIfNecessary(changed)\n\t\treturn Promise.resolve()\n\t}\n\n\tsetOnBeforeSendFunction(fun: () => unknown) {\n\t\tthis.onBeforeSend = fun\n\t}\n\n\tisUserPreviousSender(): boolean {\n\t\tif (!this.previousMail) return false\n\n\t\treturn isUserEmail(this.logins, this.mailboxDetails, this.previousMail.sender.address)\n\t}\n}\n\n/**\n * deduplicate a list of recipients for insertion in any of the recipient fields\n * recipients are considered equal when their cleanMailAddress() is the same\n * returns the recipients with their original mail address\n *\n * unhandled edge case: it's possible to lose recipients that should be kept when\n * * the mail contains several recipients that have the same clean address (Bob@e.de and bob@e.de)\n * * the e.de mail server considers these distinct\n * * we hit \"reply all\"\n *\n */\nfunction recipientsFilter(recipientList: ReadonlyArray<PartialRecipient>): Array<PartialRecipient> {\n\t// we pack each recipient along with its cleaned address, deduplicate the array by comparing cleaned and then unpack the original recipient\n\t// this prevents us from changing the values contained in the array and still keeps the cleanAddress calls out of the n^2 loop\n\tconst cleanedList = recipientList.filter((r) => isMailAddress(r.address, false)).map((a) => ({ recipient: a, cleaned: cleanMailAddress(a.address) }))\n\treturn deduplicate(cleanedList, (a, b) => a.cleaned === b.cleaned).map((a) => a.recipient)\n}\n"],"mappings":"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"}