{"version":3,"file":"SubscriptionUtils-D0qLWHbE.js","names":["featureType: BookingItemFeatureType","booking: Booking | null","lastBooking: Booking | null","planConfig: PlanConfiguration","data: string | null","serviceExecutor: IServiceExecutor","predicate: (configuration: PlanConfiguration) => boolean","errorMessage: string","planType: PlanType","accountingInfo: AccountingInfo","userIdBytes: Uint8Array | null"],"sources":["../../src/common/subscription/SubscriptionUtils.ts"],"sourcesContent":["import type { TranslationKey } from \"../misc/LanguageViewModel\"\nimport {\n\tAccountType,\n\tAvailablePlanType,\n\tBookingItemFeatureType,\n\tgetClientType,\n\tgetPaymentMethodType,\n\tNewPaidPlans,\n\tPaymentMethodType,\n\tPlanType,\n\tPlanTypeToName,\n} from \"../api/common/TutanotaConstants\"\nimport type { AccountingInfo, Customer, CustomerInfo, PlanConfiguration } from \"../api/entities/sys/TypeRefs.js\"\nimport { Booking, createPaymentDataServiceGetData } from \"../api/entities/sys/TypeRefs.js\"\nimport { isEmpty, LazyLoaded } from \"@tutao/tutanota-utils\"\nimport { locator } from \"../api/main/CommonLocator\"\nimport { PaymentDataService } from \"../api/entities/sys/Services\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\nimport { IServiceExecutor } from \"../api/common/ServiceRequest.js\"\nimport { MobilePaymentSubscriptionOwnership } from \"../native/common/generatedipc/MobilePaymentSubscriptionOwnership.js\"\n\nexport const enum UpgradeType {\n\tSignup = \"Signup\",\n\t// during signup\n\tInitial = \"Initial\",\n\t// when logged into Free account\n\tSwitch = \"Switch\", // switching in paid account\n}\n\nexport function getCurrentCount(featureType: BookingItemFeatureType, booking: Booking | null): number {\n\tif (booking) {\n\t\tlet bookingItem = booking.items.find((item) => item.featureType === featureType)\n\t\treturn bookingItem ? Number(bookingItem.currentCount) : 0\n\t} else {\n\t\treturn 0\n\t}\n}\n\n/**\n * Returns the available storage capacity for the customer in GB\n */\nexport function getTotalStorageCapacityPerCustomer(customer: Customer, customerInfo: CustomerInfo, lastBooking: Booking | null): number {\n\tlet freeStorageCapacity = getIncludedStorageCapacityPerCustomer(customerInfo)\n\n\tif (customer.type === AccountType.PAID) {\n\t\treturn Math.max(freeStorageCapacity, getCurrentCount(BookingItemFeatureType.Storage, lastBooking))\n\t} else {\n\t\treturn freeStorageCapacity\n\t}\n}\n\nfunction getIncludedStorageCapacityPerCustomer(customerInfo: CustomerInfo): number {\n\treturn Math.max(Number(customerInfo.includedStorageCapacity), Number(customerInfo.promotionStorageCapacity))\n}\n\nexport function isWhitelabelActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn getCurrentCount(BookingItemFeatureType.Whitelabel, lastBooking) !== 0 || planConfig.whitelabel\n}\n\nexport function isSharingActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn getCurrentCount(BookingItemFeatureType.Sharing, lastBooking) !== 0 || planConfig.sharing\n}\n\nfunction isBusinessFeatureActive(lastBooking: Booking | null): boolean {\n\treturn getCurrentCount(BookingItemFeatureType.Business, lastBooking) !== 0\n}\n\nexport function isEventInvitesActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn isBusinessFeatureActive(lastBooking) || planConfig.eventInvites\n}\n\nexport function isAutoResponderActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn isBusinessFeatureActive(lastBooking) || planConfig.autoResponder\n}\n\nexport type PaymentErrorCode =\n\t| \"paypal.change\"\n\t| \"paypal.confirm_again\"\n\t| \"paypal.other_source\"\n\t| \"card.contact_bank\"\n\t| \"card.insufficient_funds\"\n\t| \"card.expired_card\"\n\t| \"card.change\"\n\t| \"card.3ds2_needed\"\n\t| \"card.3ds2_pending\"\n\t| \"card.3ds2_failed\"\n\t| \"card.cvv_invalid\"\n\t| \"card.number_invalid\"\n\t| \"card.date_invalid\"\n\nexport function getPreconditionFailedPaymentMsg(data: string | null): TranslationKey {\n\t// the type is mostly there to keep multiple locations that switch over these in sync\n\tswitch (data as PaymentErrorCode) {\n\t\tcase \"paypal.change\":\n\t\t\treturn \"payChangeError_msg\"\n\n\t\tcase \"paypal.confirm_again\":\n\t\t\treturn \"payPaypalConfirmAgainError_msg\"\n\n\t\tcase \"paypal.other_source\":\n\t\t\treturn \"payPaypalChangeSourceError_msg\"\n\n\t\tcase \"card.contact_bank\":\n\t\t\treturn \"payCardContactBankError_msg\"\n\n\t\tcase \"card.insufficient_funds\":\n\t\t\treturn \"payCardInsufficientFundsError_msg\"\n\n\t\tcase \"card.expired_card\":\n\t\t\treturn \"payCardExpiredError_msg\"\n\n\t\tcase \"card.change\":\n\t\t\treturn \"payChangeError_msg\"\n\n\t\tcase \"card.3ds2_needed\":\n\t\t\treturn \"creditCardPaymentErrorVerificationNeeded_msg\"\n\n\t\tcase \"card.3ds2_pending\":\n\t\t\treturn \"creditCardPendingVerification_msg\"\n\n\t\tcase \"card.3ds2_failed\":\n\t\t\treturn \"creditCardVerificationFailed_msg\"\n\n\t\tcase \"card.cvv_invalid\":\n\t\t\treturn \"creditCardCVVInvalid_msg\"\n\n\t\tcase \"card.number_invalid\":\n\t\t\treturn \"creditCardNumberInvalid_msg\"\n\n\t\tcase \"card.date_invalid\":\n\t\t\treturn \"creditCardExprationDateInvalid_msg\"\n\n\t\tdefault:\n\t\t\treturn \"payContactUsError_msg\"\n\t}\n}\n\nexport function getLazyLoadedPayPalUrl(): LazyLoaded<string> {\n\treturn new LazyLoaded(async () => {\n\t\tconst clientType = getClientType()\n\t\tconst result = await locator.serviceExecutor.get(\n\t\t\tPaymentDataService,\n\t\t\tcreatePaymentDataServiceGetData({\n\t\t\t\tclientType,\n\t\t\t}),\n\t\t)\n\t\treturn result.loginUrl\n\t})\n}\n\n/**\n * only to be invoked for PlanTypes where isNewPlan returns true\n */\nexport function toFeatureType(type: PlanType): BookingItemFeatureType {\n\tswitch (type) {\n\t\tcase PlanType.Revolutionary:\n\t\t\treturn BookingItemFeatureType.Revolutionary\n\t\tcase PlanType.Legend:\n\t\t\treturn BookingItemFeatureType.Legend\n\t\tcase PlanType.Essential:\n\t\t\treturn BookingItemFeatureType.Essential\n\t\tcase PlanType.Advanced:\n\t\t\treturn BookingItemFeatureType.Advanced\n\t\tcase PlanType.Unlimited:\n\t\t\treturn BookingItemFeatureType.Unlimited\n\t\tcase PlanType.Premium:\n\t\t\treturn BookingItemFeatureType.LegacyUsers\n\t\tdefault:\n\t\t\tthrow new Error(`can't convert ${type} to BookingItemFeatureType`)\n\t}\n}\n\n/**\n * Get plans that are available for purchase and that comply with the given criteria.\n * @param serviceExecutor\n * @param predicate\n */\nexport async function getAvailableMatchingPlans(\n\tserviceExecutor: IServiceExecutor,\n\tpredicate: (configuration: PlanConfiguration) => boolean,\n): Promise<Array<AvailablePlanType>> {\n\tconst { PriceAndConfigProvider } = await import(\"../subscription/PriceUtils.js\")\n\tconst priceAndConfigProvider = await PriceAndConfigProvider.getInitializedInstance(null, serviceExecutor, null)\n\treturn NewPaidPlans.filter((p) => {\n\t\tconst config = priceAndConfigProvider.getPlanPricesForPlan(p).planConfiguration\n\t\treturn predicate(config)\n\t})\n}\n\n/**\n * Filter for plans a customer can upgrade to that include a feature, assuming that the feature must be available on at least one plan.\n * @param predicate the criterion to select plans by\n * @param errorMessage the error message to throw in case no plan satisfies the criterion\n */\nasync function getAtLeastOneAvailableMatchingPlan(\n\tpredicate: (configuration: PlanConfiguration) => boolean,\n\terrorMessage: string,\n): Promise<Array<AvailablePlanType>> {\n\tconst plans = await getAvailableMatchingPlans(locator.serviceExecutor, predicate)\n\tif (isEmpty(plans)) {\n\t\tthrow new ProgrammingError(errorMessage)\n\t}\n\treturn plans\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Whitelabel feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithWhitelabel(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.whitelabel, \"no available plan with the Whitelabel feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Whitelabel feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithTemplates(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.templates, \"no available plan with the Templates feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Sharing feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithSharing(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.sharing, \"no available plan with the Sharing feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Event Invites feature.\n */\nexport async function getAvailablePlansWithEventInvites(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.eventInvites, \"no available plan with the Event Invites feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Auto-Responder feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithAutoResponder(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.autoResponder, \"no available plan with the Auto-Responder feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Contact List feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithContactList(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.contactList, \"no available plan with the Contact List feature\")\n}\n\nexport async function getAvailablePlansWithCalendarInvites(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.eventInvites, \"no available plan with the Calendar Invite feature\")\n}\n\n/** name of the plan/product how it is expected by iOS AppStore */\nexport function appStorePlanName(planType: PlanType): string {\n\treturn PlanTypeToName[planType].toLowerCase()\n}\n\n/** does current user has an active (non-expired) AppStore subscription? */\nexport function hasRunningAppStoreSubscription(accountingInfo: AccountingInfo): boolean {\n\treturn getPaymentMethodType(accountingInfo) === PaymentMethodType.AppStore && accountingInfo.appStoreSubscription != null\n}\n\n/** Check if the latest transaction using the current Store Account belongs to the user */\nexport async function queryAppStoreSubscriptionOwnership(userIdBytes: Uint8Array | null): Promise<MobilePaymentSubscriptionOwnership> {\n\treturn await locator.mobilePaymentsFacade.queryAppStoreSubscriptionOwnership(userIdBytes)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqBkB,sCAAX;AACN;AAEA;AAEA;;AACA;AAEM,SAAS,gBAAgBA,aAAqCC,SAAiC;AACrG,KAAI,SAAS;EACZ,IAAI,cAAc,QAAQ,MAAM,KAAK,CAAC,SAAS,KAAK,gBAAgB,YAAY;AAChF,SAAO,cAAc,OAAO,YAAY,aAAa,GAAG;CACxD,MACA,QAAO;AAER;AAmBM,SAAS,mBAAmBC,aAA6BC,YAAwC;AACvG,QAAO,gBAAgB,uBAAuB,YAAY,YAAY,KAAK,KAAK,WAAW;AAC3F;AAiCM,SAAS,gCAAgCC,MAAqC;AAEpF,SAAQ,MAAR;AACC,OAAK,gBACJ,QAAO;AAER,OAAK,uBACJ,QAAO;AAER,OAAK,sBACJ,QAAO;AAER,OAAK,oBACJ,QAAO;AAER,OAAK,0BACJ,QAAO;AAER,OAAK,oBACJ,QAAO;AAER,OAAK,cACJ,QAAO;AAER,OAAK,mBACJ,QAAO;AAER,OAAK,oBACJ,QAAO;AAER,OAAK,mBACJ,QAAO;AAER,OAAK,mBACJ,QAAO;AAER,OAAK,sBACJ,QAAO;AAER,OAAK,oBACJ,QAAO;AAER,UACC,QAAO;CACR;AACD;AAEM,SAAS,yBAA6C;AAC5D,QAAO,IAAI,WAAW,YAAY;EACjC,MAAM,aAAa,eAAe;EAClC,MAAM,SAAS,MAAM,QAAQ,gBAAgB,IAC5C,oBACA,gCAAgC,EAC/B,WACA,EAAC,CACF;AACD,SAAO,OAAO;CACd;AACD;AA6BM,eAAe,0BACrBC,iBACAC,WACoC;CACpC,MAAM,EAAE,wBAAwB,GAAG,MAAM,OAAO;CAChD,MAAM,yBAAyB,MAAM,uBAAuB,uBAAuB,MAAM,iBAAiB,KAAK;AAC/G,QAAO,aAAa,OAAO,CAAC,MAAM;EACjC,MAAM,SAAS,uBAAuB,qBAAqB,EAAE,CAAC;AAC9D,SAAO,UAAU,OAAO;CACxB,EAAC;AACF;;;;;;AAOD,eAAe,mCACdA,WACAC,cACoC;CACpC,MAAM,QAAQ,MAAM,0BAA0B,QAAQ,iBAAiB,UAAU;AACjF,KAAI,QAAQ,MAAM,CACjB,OAAM,IAAI,iBAAiB;AAE5B,QAAO;AACP;AAMM,eAAe,kCAAqE;AAC1F,QAAO,mCAAmC,CAAC,WAAW,OAAO,YAAY,gDAAgD;AACzH;AAMM,eAAe,iCAAoE;AACzF,QAAO,mCAAmC,CAAC,WAAW,OAAO,WAAW,+CAA+C;AACvH;AAMM,eAAe,+BAAkE;AACvF,QAAO,mCAAmC,CAAC,WAAW,OAAO,SAAS,6CAA6C;AACnH;AAKM,eAAe,oCAAuE;AAC5F,QAAO,mCAAmC,CAAC,WAAW,OAAO,cAAc,mDAAmD;AAC9H;AAcM,eAAe,mCAAsE;AAC3F,QAAO,mCAAmC,CAAC,WAAW,OAAO,aAAa,kDAAkD;AAC5H;AAEM,eAAe,uCAA0E;AAC/F,QAAO,mCAAmC,CAAC,WAAW,OAAO,cAAc,qDAAqD;AAChI;AAGM,SAAS,iBAAiBC,UAA4B;AAC5D,QAAO,eAAe,UAAU,aAAa;AAC7C;AAGM,SAAS,+BAA+BC,gBAAyC;AACvF,QAAO,qBAAqB,eAAe,KAAK,kBAAkB,YAAY,eAAe,wBAAwB;AACrH;AAGM,eAAe,mCAAmCC,aAA6E;AACrI,QAAO,MAAM,QAAQ,qBAAqB,mCAAmC,YAAY;AACzF"}