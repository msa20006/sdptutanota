{"version":3,"file":"SearchTypes-BQT7nl8f.js","names":[],"sources":["../../src/common/api/worker/search/SearchTypes.ts"],"sourcesContent":["import type { DbFacade } from \"./DbFacade\"\nimport type { GroupType } from \"../../common/TutanotaConstants\"\nimport type { TypeInfo } from \"./IndexUtils\"\nimport type { Base64, lazy } from \"@tutao/tutanota-utils\"\nimport { TypeRef } from \"@tutao/tutanota-utils\"\nimport type { ModelAssociation, ModelValue } from \"../../common/EntityTypes\"\nimport { Aes256Key } from \"@tutao/tutanota-crypto\"\n// db types\n\n/**\n * First part encrypted element id (16 bytes), second part encoded and encrypted attribute and positions\n */\nexport type EncryptedSearchIndexEntry = Uint8Array\n\n/**\n * Binary encoded EncryptedSearchIndexEntries SearchIndexEncoding).\n */\nexport type SearchIndexDbRow = Uint8Array\nexport type SearchIndexMetaDataDbRow = {\n\tid: number\n\tword: string\n\trows: Uint8Array // sequences of numbers like: [app, type, indexRowId, size, app, type, ...] encoded and encrypted SearchIndexMetadataEntry\n}\nexport type ElementDataDbRow = [\n\tId, // first list id\n\tUint8Array, // second is enc meta row keys encoded in binary format\n\tId, // third is owner group id\n]\nexport type EncryptedSearchIndexEntryWithHash = {\n\tencEntry: EncryptedSearchIndexEntry\n\tidHash: number\n}\nexport type GroupData = {\n\tlastBatchIds: Id[]\n\tindexTimestamp: number\n\tgroupType: GroupType\n}\n// runtime types\nexport type B64EncIndexKey = Base64\ntype EncIndexKey = Uint8Array\ntype EncInstanceId = Uint8Array\nexport type B64EncInstanceId = Base64\nexport type AttributeHandler = {\n\tattribute: ModelValue | ModelAssociation\n\tvalue: lazy<string>\n}\nexport type ElementDataSurrogate = {\n\tlistId: Id\n\t// we store it here instead of SearchIndexEntry to allow moving mails without changing the SearchIndexEntries for the mail\n\tencWordsB64: Array<B64EncIndexKey>\n\townerGroup: Id\n}\nexport type KeyToIndexEntries = {\n\tindexKey: Base64\n\tindexEntries: DecryptedSearchIndexEntry[]\n}\nexport type KeyToEncryptedIndexEntries = {\n\tindexKey: Base64\n\tindexEntries: EncryptedSearchIndexEntryWithHash[]\n}\nexport type SearchIndexEntry = {\n\tid: Id\n\tattribute: number\n\tpositions: number[]\n}\nexport type DecryptedSearchIndexEntry = SearchIndexEntry & {\n\tencId: Uint8Array\n}\n// We calculate timestamp upfront because we need it for sorting when inserting\nexport type EncSearchIndexEntryWithTimestamp = {\n\tentry: EncryptedSearchIndexEntry\n\ttimestamp: number\n}\nexport type EncWordToMetaRow = Record<Base64, number>\nexport type EncInstanceIdWithTimestamp = {\n\tencInstanceId: Uint8Array\n\ttimestamp: number\n\tappId: number\n\ttypeId: number\n}\nexport type IndexUpdate = {\n\ttypeInfo: TypeInfo\n\t// index update must be unique for type\n\tcreate: {\n\t\tencInstanceIdToElementData: Map<B64EncInstanceId, ElementDataSurrogate>\n\t\t// For each word there's a list of entries we want to insert\n\t\tindexMap: Map<B64EncIndexKey, Array<EncSearchIndexEntryWithTimestamp>>\n\t}\n\tmove: Array<{\n\t\tencInstanceId: B64EncInstanceId\n\t\tnewListId: Id\n\t}>\n\tdelete: {\n\t\t// For each metadata row there's a list of entries we want to delete\n\t\tsearchMetaRowToEncInstanceIds: Map<number, Array<EncInstanceIdWithTimestamp>>\n\t\tencInstanceIds: B64EncInstanceId[]\n\t}\n}\nexport type Db = {\n\tkey: Aes256Key\n\t// @pre: must not be accessed before initialized promise is resolved.\n\tiv: Uint8Array\n\t// fixed iv for all search index entries\n\tdbFacade: DbFacade\n\tinitialized: Promise<void>\n}\nexport type SearchIndexMetaDataRow = {\n\tid: number\n\tword: B64EncIndexKey\n\trows: Array<SearchIndexMetadataEntry>\n}\nexport type SearchIndexMetadataEntry = {\n\tkey: number\n\tsize: number\n\tapp: number\n\ttype: number\n\t// we have app and type in search index meta to filter for type (mail, contact, users) before loading and decrypting index rows.\n\toldestElementTimestamp: number\n}\nexport type MoreResultsIndexEntry = {\n\tid: Id\n\tencId: Uint8Array\n}\nexport type SearchRestriction = {\n\ttype: TypeRef<any>\n\tstart: number | null\n\t// timestamp\n\tend: number | null\n\t// must be kept in sync with field\n\tfield: string | null\n\t// must be kept in sync with attributeIds\n\tattributeIds: number[] | null\n\t// list of locations (calendars, folders, labels to search). if empty, match anything. otherwise it's an OR-match.\n\tfolderIds: Array<Id>\n\t// if true, include repeating events in the search\n\teventSeries: boolean | null\n}\nexport type SearchResult = {\n\tquery: string\n\trestriction: SearchRestriction\n\tresults: IdTuple[]\n\tcurrentIndexTimestamp: number\n\tmaxResults?: number\n\tmoreResults: Array<MoreResultsIndexEntry>\n\tmoreResultsEntries: []\n\tlastReadSearchIndexRow: Array<[string, number | null]>\n\t// array of pairs (token, lastReadSearchIndexRowOldestElementTimestamp) lastRowReadSearchIndexRow: null = no result read, 0 = no more search results????\n\tmatchWordOrder: boolean\n}\n\nexport const enum IndexingErrorReason {\n\tUnknown,\n\tConnectionLost,\n}\n\n/**\n * Current state of the Mailindexer\n * aimedMailIndexTimestamp is the timestamp we are currently indexing for (or same as currentMailIndexTimestamp if we are not indexing)\n */\nexport type SearchIndexStateInfo = {\n\tinitializing: boolean\n\tmailIndexEnabled: boolean\n\tprogress: number\n\tcurrentMailIndexTimestamp: number\n\taimedMailIndexTimestamp: number\n\tindexedMailCount: number\n\tfailedIndexingUpTo: number | null\n\terror?: IndexingErrorReason | null\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAsJkB,sDAAX;AACN;AACA;;AACA"}