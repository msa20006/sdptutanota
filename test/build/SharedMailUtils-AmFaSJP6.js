
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { assertNotNull, contains, neverNull, pMap, uint8ArrayToBase64 } from "./dist-CJHwsXKY.js";
import { assertMainOrNode, isApp } from "./Env-D5xGlXfw.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { BrowserType, client } from "./ClientDetector-D0v6Vqu6.js";
import { ALLOWED_IMAGE_FORMATS, ArchiveDataType, ContactAddressType, ConversationType, EncryptionAuthStatus, GroupType, MAX_ATTACHMENT_SIZE, MAX_BASE64_IMAGE_SIZE, TUTA_MAIL_ADDRESS_DOMAINS } from "./TutanotaConstants-3bwAESYA.js";
import { Dialog } from "./Dialog-B6-HFvZd.js";
import { ConnectionError } from "./RestError-D17JEBMr.js";
import { CryptoError } from "./CryptoError-PqdvQky4.js";
import { FileNotFoundError, isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { PermissionError } from "./PermissionError-BGDsHuAh.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { createContact, createContactMailAddress } from "./TypeRefs-CR3TLWn0.js";
import { CustomerPropertiesTypeRef } from "./TypeRefs-BP1jvX9p.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { fullNameToFirstAndLastName, mailAddressToFirstAndLastName } from "./MailAddressParser-BgYy6oyp.js";
import { getEnabledMailAddressesForGroupInfo, getGroupInfoDisplayName } from "./GroupUtils-0ZkLIAeC.js";
import { convertToDataFile, createDataFile } from "./DataFile-CY7uuk9j.js";
import { deduplicateFilenames, sanitizeFilename } from "./FileUtils-W-u2-gZz.js";
import { showProgressDialog } from "./ProgressDialog-CJfJjh62.js";
import { createReferencingInstance } from "./BlobUtils-D5ADcckZ.js";

//#region ../src/common/file/FileController.ts
var import_stream = __toESM(require_stream(), 1);
assertMainOrNode();
const CALENDAR_MIME_TYPE = "text/calendar";
let VCARD_MIME_TYPES = function(VCARD_MIME_TYPES$1) {
	VCARD_MIME_TYPES$1["X_VCARD"] = "text/x-vcard";
	VCARD_MIME_TYPES$1["VCARD"] = "text/vcard";
	return VCARD_MIME_TYPES$1;
}({});
let MAIL_MIME_TYPES = function(MAIL_MIME_TYPES$1) {
	MAIL_MIME_TYPES$1["EML"] = "message/rfc822";
	MAIL_MIME_TYPES$1["MBOX"] = "application/mbox";
	return MAIL_MIME_TYPES$1;
}({});
var DownloadPostProcessing = function(DownloadPostProcessing$1) {
	DownloadPostProcessing$1[DownloadPostProcessing$1["Open"] = 0] = "Open";
	DownloadPostProcessing$1[DownloadPostProcessing$1["Write"] = 1] = "Write";
	return DownloadPostProcessing$1;
}(DownloadPostProcessing || {});
var FileController = class {
	constructor(blobFacade, observeProgress) {
		this.blobFacade = blobFacade;
		this.observeProgress = observeProgress;
	}
	async doDownload(tutanotaFiles, action, progress) {
		const downloadedFiles = [];
		try {
			let isOffline = false;
			for (const file of tutanotaFiles) try {
				const downloadedFile = await this.downloadAndDecrypt(file);
				downloadedFiles.push(downloadedFile);
				if (progress != null) progress((tutanotaFiles.indexOf(file) + 1) / tutanotaFiles.length * 100);
			} catch (e) {
				await handleDownloadErrors(e, (msg) => {
					if (msg === "couldNotAttachFile_msg") isOffline = true;
else Dialog.message(lang.makeTranslation("error_msg", lang.get(msg) + " " + file.name));
				});
				if (isOffline) break;
			}
			if (downloadedFiles.length > 0) if (action === DownloadPostProcessing.Open) this.openDownloadedFiles(downloadedFiles);
else await this.writeDownloadedFiles(downloadedFiles);
			if (isOffline) throw new ConnectionError("currently offline");
		} finally {
			if (action !== DownloadPostProcessing.Open) await this.cleanUp(downloadedFiles);
		}
	}
	/**
	* get the referenced TutanotaFile as a DataFile without writing anything to disk
	*/
	async getAsDataFile(file) {
		return downloadAndDecryptDataFile(file, this.blobFacade);
	}
	/**
	* Download a file from the server to the filesystem
	*/
	async download(file) {
		await this.observeProgress(this.doDownload([file], DownloadPostProcessing.Write));
	}
	/**
	* Download all provided files
	*
	* Temporary files are deleted afterwards in apps.
	*/
	async downloadAll(files) {
		const progress = (0, import_stream.default)(0);
		await this.observeProgress(this.doDownload(files, DownloadPostProcessing.Write, progress), progress);
	}
	/**
	* Open a file in the host system
	* Temporary files are deleted afterwards in apps.
	*/
	async open(file) {
		await this.observeProgress(this.doDownload([file], DownloadPostProcessing.Open));
	}
};
function handleDownloadErrors(e, errorAction) {
	if (isOfflineError(e)) return errorAction("couldNotAttachFile_msg");
else if (e instanceof CryptoError) return errorAction("corrupted_msg");
else throw e;
}
function readLocalFiles(nativeFiles) {
	return pMap(nativeFiles, (nativeFile) => {
		return new Promise((resolve, reject) => {
			let reader = new FileReader();
			reader.onloadend = function(evt) {
				const target = evt.target;
				if (target.readyState === reader.DONE && target.result) resolve(convertToDataFile(nativeFile, new Uint8Array(target.result)));
else reject(new Error("could not load file"));
			};
			reader.readAsArrayBuffer(nativeFile);
		});
	}, { concurrency: 5 });
}
function showFileChooser(allowMultiple, allowedExtensions) {
	const fileInput = document.getElementById("hiddenFileChooser");
	const body = neverNull(document.body);
	if (fileInput) body.removeChild(fileInput);
	const newFileInput = document.createElement("input");
	newFileInput.setAttribute("type", "file");
	if (allowMultiple) newFileInput.setAttribute("multiple", "multiple");
	newFileInput.setAttribute("id", "hiddenFileChooser");
	if (allowedExtensions) newFileInput.setAttribute("accept", allowedExtensions.map((e) => "." + e).join(","));
	newFileInput.style.display = "none";
	const promise = new Promise((resolve) => {
		newFileInput.addEventListener("change", (e) => {
			readLocalFiles(e.target.files).then(resolve).catch(async (e$1) => {
				console.log(e$1);
				await Dialog.message("couldNotAttachFile_msg");
				resolve([]);
			});
		});
		newFileInput.addEventListener("cancel", () => resolve([]));
	});
	body.appendChild(newFileInput);
	newFileInput.click();
	return promise;
}
async function zipDataFiles(dataFiles, name) {
	const jsZip = await import("./jszip-EJRBpxUR.js");
	const zip = jsZip.default();
	const deduplicatedMap = deduplicateFilenames(dataFiles.map((df) => sanitizeFilename(df.name)));
	for (let file of dataFiles) {
		const filename = assertNotNull(deduplicatedMap[file.name].shift());
		zip.file(sanitizeFilename(filename), file.data, { binary: true });
	}
	const zipData = await zip.generateAsync({ type: "uint8array" });
	return createDataFile(name, "application/zip", zipData);
}
async function openDataFileInBrowser(dataFile) {
	try {
		const URL = window.URL ?? window.webkitURL;
		const needsPdfWorkaround = dataFile.mimeType === "application/pdf" && client.browser === BrowserType.FIREFOX && client.browserVersion >= 98;
		const mimeType = needsPdfWorkaround ? "application/octet-stream" : dataFile.mimeType;
		const blob = new Blob([dataFile.data], { type: mimeType });
		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		if (typeof a.download !== "undefined") {
			a.href = url;
			a.download = dataFile.name;
			a.style.display = "none";
			a.target = "_blank";
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			setTimeout(() => {
				window.URL.revokeObjectURL(url);
			}, 2e3);
		} else if (client.isIos() && client.browser === BrowserType.CHROME && typeof FileReader === "function") {
			const reader = new FileReader();
			const downloadPromise = new Promise((resolve) => {
				reader.onloadend = async function() {
					const url$1 = reader.result;
					resolve(await Dialog.legacyDownload(dataFile.name, url$1));
				};
			});
			reader.readAsDataURL(blob);
			await downloadPromise;
		} else await Dialog.legacyDownload(dataFile.name, url);
	} catch (e) {
		console.log(e);
		return Dialog.message("canNotOpenFileOnDevice_msg");
	}
}
async function downloadAndDecryptDataFile(file, blobFacade) {
	const bytes = await blobFacade.downloadAndDecrypt(ArchiveDataType.Attachments, createReferencingInstance(file));
	return convertToDataFile(file, bytes);
}
async function guiDownload(downloadPromise, progress) {
	try {
		await showProgressDialog("pleaseWait_msg", downloadPromise, progress);
	} catch (e) {
		if (e instanceof CancelledError) return;
		console.log("downloadAndOpen error", e.message);
		await handleDownloadErrors(e, Dialog.message);
	}
}
async function showNativeFilePicker(fileTypes, isFileOnly = false) {
	if (isApp()) {
		const rect = {
			width: 0,
			height: 0,
			left: 0,
			top: 0
		};
		try {
			const fileApp = locator.fileApp;
			const fileList = await fileApp.openFileChooser(rect, fileTypes, isFileOnly);
			const readFiles = [];
			for (const file of fileList) {
				const data = await fileApp.readDataFile(file.location);
				if (!data) continue;
				readFiles.push(data);
			}
			return Promise.resolve(readFiles);
		} catch (err) {
			if (err instanceof PermissionError) Dialog.message("fileAccessDeniedMobile_msg");
else if (err instanceof FileNotFoundError) Dialog.message("couldNotAttachFile_msg");
			console.log("Failed read files", err);
		}
	}
	return Promise.resolve([]);
}

//#endregion
//#region ../src/common/mailFunctionality/SharedMailUtils.ts
assertMainOrNode();
const LINE_BREAK = "<br>";
function createNewContact(user, mailAddress, name) {
	let firstAndLastName = name.trim() !== "" ? fullNameToFirstAndLastName(name) : mailAddressToFirstAndLastName(mailAddress);
	let contact = createContact({
		_ownerGroup: assertNotNull(user.memberships.find((m) => m.groupType === GroupType.Contact), "called createNewContact as user without contact group mship").group,
		firstName: firstAndLastName.firstName,
		lastName: firstAndLastName.lastName,
		mailAddresses: [createContactMailAddress({
			address: mailAddress,
			type: ContactAddressType.OTHER,
			customTypeName: ""
		})],
		birthdayIso: null,
		comment: "",
		company: "",
		nickname: null,
		oldBirthdayDate: null,
		presharedPassword: null,
		role: "",
		title: null,
		addresses: [],
		oldBirthdayAggregate: null,
		phoneNumbers: [],
		photo: null,
		socialIds: [],
		department: null,
		middleName: null,
		nameSuffix: null,
		phoneticFirst: null,
		phoneticLast: null,
		phoneticMiddle: null,
		customDate: [],
		messengerHandles: [],
		pronouns: [],
		relationships: [],
		websites: []
	});
	return contact;
}
function getMailAddressDisplayText(name, mailAddress, preferNameOnly) {
	if (!name) return mailAddress;
else if (preferNameOnly) return name;
else return name + " <" + mailAddress + ">";
}
function getEnabledMailAddressesWithUser(mailboxDetail, userGroupInfo) {
	if (isUserMailbox(mailboxDetail)) return getEnabledMailAddressesForGroupInfo(userGroupInfo);
else return getEnabledMailAddressesForGroupInfo(mailboxDetail.mailGroupInfo);
}
function isUserMailbox(mailboxDetails) {
	return mailboxDetails.mailGroup != null && mailboxDetails.mailGroup.user != null;
}
function getDefaultSender(logins, mailboxDetails) {
	if (isUserMailbox(mailboxDetails)) {
		let props = logins.getUserController().props;
		return props.defaultSender && contains(getEnabledMailAddressesWithUser(mailboxDetails, logins.getUserController().userGroupInfo), props.defaultSender) ? props.defaultSender : assertNotNull(logins.getUserController().userGroupInfo.mailAddress);
	} else return assertNotNull(mailboxDetails.mailGroupInfo.mailAddress);
}
function isUserEmail(logins, mailboxDetails, address) {
	if (isUserMailbox(mailboxDetails)) return contains(getEnabledMailAddressesWithUser(mailboxDetails, logins.getUserController().userGroupInfo), address) || logins.getUserController().userGroupInfo.mailAddress === address;
else return mailboxDetails.mailGroupInfo.mailAddress === address;
}
function getSenderNameForUser(mailboxDetails, userController) {
	if (isUserMailbox(mailboxDetails)) return userController.userGroupInfo.name;
else return mailboxDetails.mailGroupInfo ? mailboxDetails.mailGroupInfo.name : "";
}
function getMailboxName(logins, mailboxDetails) {
	if (!logins.isInternalUserLoggedIn()) return lang.get("mailbox_label");
else if (isUserMailbox(mailboxDetails)) return getDefaultSender(logins, mailboxDetails);
else return getGroupInfoDisplayName(assertNotNull(mailboxDetails.mailGroupInfo, "mailboxDetails without mailGroupInfo?"));
}
function getTemplateLanguages(sortedLanguages, entityClient, loginController) {
	return loginController.getUserController().loadCustomer().then((customer) => entityClient.load(CustomerPropertiesTypeRef, neverNull(customer.properties))).then((customerProperties) => {
		return sortedLanguages.filter((sL) => customerProperties.notificationMailTemplates.find((nmt) => nmt.language === sL.code));
	}).catch(() => []);
}
function dialogTitleTranslationKey(conversationType) {
	let key;
	switch (conversationType) {
		case ConversationType.NEW:
			key = "newMail_action";
			break;
		case ConversationType.REPLY:
			key = "reply_action";
			break;
		case ConversationType.FORWARD:
			key = "forward_action";
			break;
		default: key = "emptyString_msg";
	}
	return key;
}
function checkAttachmentSize(files, maxAttachmentSize = MAX_ATTACHMENT_SIZE) {
	let totalSize = 0;
	const attachableFiles = [];
	const tooBigFiles = [];
	for (const file of files) if (totalSize + Number(file.size) > maxAttachmentSize) tooBigFiles.push(file.name);
else {
		totalSize += Number(file.size);
		attachableFiles.push(file);
	}
	return {
		attachableFiles,
		tooBigFiles
	};
}
let RecipientField = function(RecipientField$1) {
	RecipientField$1["TO"] = "to";
	RecipientField$1["CC"] = "cc";
	RecipientField$1["BCC"] = "bcc";
	return RecipientField$1;
}({});
function isTutaMailAddress(mailAddress) {
	return TUTA_MAIL_ADDRESS_DOMAINS.some((tutaDomain) => mailAddress.endsWith("@" + tutaDomain));
}
function hasValidEncryptionAuthForTeamOrSystemMail({ encryptionAuthStatus }) {
	switch (encryptionAuthStatus) {
		case null:
		case undefined:
		case EncryptionAuthStatus.RSA_NO_AUTHENTICATION:
		case EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED:
		case EncryptionAuthStatus.TUTACRYPT_SENDER: return true;
		case EncryptionAuthStatus.AES_NO_AUTHENTICATION:
		case EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED:
		default: return false;
	}
}
function insertInlineImageB64ClickHandler(ev, handler) {
	showFileChooser(true, ALLOWED_IMAGE_FORMATS).then((files) => {
		const tooBig = [];
		for (let file of files) if (file.size > MAX_BASE64_IMAGE_SIZE) tooBig.push(file);
else {
			const b64 = uint8ArrayToBase64(file.data);
			const dataUrlString = `data:${file.mimeType};base64,${b64}`;
			handler.insertImage(dataUrlString, { style: "max-width: 100%" });
		}
		if (tooBig.length > 0) Dialog.message(lang.getTranslation("tooBigInlineImages_msg", { "{size}": MAX_BASE64_IMAGE_SIZE / 1024 }));
	});
}

//#endregion
export { CALENDAR_MIME_TYPE, FileController, LINE_BREAK, MAIL_MIME_TYPES, RecipientField, VCARD_MIME_TYPES, checkAttachmentSize, createNewContact, dialogTitleTranslationKey, getDefaultSender, getEnabledMailAddressesWithUser, getMailAddressDisplayText, getMailboxName, getSenderNameForUser, getTemplateLanguages, guiDownload, hasValidEncryptionAuthForTeamOrSystemMail, insertInlineImageB64ClickHandler, isTutaMailAddress, isUserEmail, openDataFileInBrowser, readLocalFiles, showFileChooser, showNativeFilePicker, zipDataFiles };
//# sourceMappingURL=SharedMailUtils-AmFaSJP6.js.map