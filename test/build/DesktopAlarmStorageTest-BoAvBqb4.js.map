{"version":3,"file":"DesktopAlarmStorageTest-BoAvBqb4.js","names":["conf: DesktopConfig","cryptoFacade: DesktopNativeCryptoFacade","keyStoreFacade: DesktopKeyStoreFacade","pushIdentifierId: string","pushIdentifierSessionKey: Uint8Array","keys: Record<string, Base64>","piId: string","notificationSessionKey: NotificationSessionKey","alarm: EncryptedAlarmNotification","identifier: string","userId: Id | null","alarms: Array<EncryptedAlarmNotification & { repeatRule?: Record<string, unknown> }>","alarms: ReadonlyArray<EncryptedAlarmNotification>","cryptoMock: DesktopNativeCryptoFacade","confMock: DesktopConfig","keyStoreFacade: DesktopKeyStoreFacade","key1"],"sources":["../../src/common/desktop/sse/DesktopAlarmStorage.ts","../tests/desktop/sse/DesktopAlarmStorageTest.ts"],"sourcesContent":["import type { DesktopConfig } from \"../config/DesktopConfig\"\nimport { DesktopNativeCryptoFacade } from \"../DesktopNativeCryptoFacade\"\nimport { elementIdPart } from \"../../api/common/utils/EntityUtils\"\nimport { DesktopConfigKey } from \"../config/ConfigKeys\"\nimport type { DesktopKeyStoreFacade } from \"../DesktopKeyStoreFacade.js\"\nimport type { Base64 } from \"@tutao/tutanota-utils\"\nimport { base64ToUint8Array, findAllAndRemove, uint8ArrayToBase64 } from \"@tutao/tutanota-utils\"\nimport { log } from \"../DesktopLog\"\nimport { EncryptedAlarmNotification, NotificationSessionKey } from \"../../native/common/EncryptedAlarmNotification.js\"\n\n/**\n * manages session keys used for decrypting alarm notifications, encrypting & persisting them to disk\n */\nexport class DesktopAlarmStorage {\n\t/** push identifier id to key */\n\tprivate sessionKeys: Record<string, string>\n\n\tconstructor(\n\t\tprivate readonly conf: DesktopConfig,\n\t\tprivate readonly cryptoFacade: DesktopNativeCryptoFacade,\n\t\tprivate readonly keyStoreFacade: DesktopKeyStoreFacade,\n\t) {\n\t\tthis.sessionKeys = {}\n\t}\n\n\t/**\n\t * encrypt & store a session key to disk\n\t * @param pushIdentifierId pushIdentifier the key belongs to\n\t * @param pushIdentifierSessionKey unencrypted B64 encoded key to store\n\t * @returns {*}\n\t */\n\tasync storePushIdentifierSessionKey(pushIdentifierId: string, pushIdentifierSessionKey: Uint8Array): Promise<void> {\n\t\tconst keys: Record<string, Base64> = (await this.conf.getVar(DesktopConfigKey.pushEncSessionKeys)) || {}\n\n\t\tif (!keys[pushIdentifierId]) {\n\t\t\tthis.sessionKeys[pushIdentifierId] = uint8ArrayToBase64(pushIdentifierSessionKey)\n\t\t\treturn this.keyStoreFacade.getDeviceKey().then((pw) => {\n\t\t\t\tkeys[pushIdentifierId] = uint8ArrayToBase64(this.cryptoFacade.aes256EncryptKey(pw, pushIdentifierSessionKey))\n\t\t\t\treturn this.conf.setVar(DesktopConfigKey.pushEncSessionKeys, keys)\n\t\t\t})\n\t\t}\n\n\t\treturn Promise.resolve()\n\t}\n\n\tremovePushIdentifierKeys(): Promise<void> {\n\t\tthis.sessionKeys = {}\n\t\treturn this.conf.setVar(DesktopConfigKey.pushEncSessionKeys, null)\n\t}\n\n\tremovePushIdentifierKey(piId: string): Promise<void> {\n\t\tlog.debug(\"Remove push identifier key. elementId=\" + piId)\n\t\tdelete this.sessionKeys[piId]\n\t\treturn this.conf.setVar(DesktopConfigKey.pushEncSessionKeys, this.sessionKeys)\n\t}\n\n\t/**\n\t * try to get a B64 encoded PushIdentifierSessionKey that can decrypt a notificationSessionKey from memory or decrypt it from disk storage\n\t * @param notificationSessionKey one notificationSessionKey from an alarmNotification.\n\t * @return {Promise<?Base64>} a stored pushIdentifierSessionKey that should be able to decrypt the given notificationSessionKey\n\t */\n\tasync getPushIdentifierSessionKey(notificationSessionKey: NotificationSessionKey): Promise<Uint8Array | null> {\n\t\tconst pw = await this.keyStoreFacade.getDeviceKey()\n\t\tconst pushIdentifierId = elementIdPart(notificationSessionKey.pushIdentifier)\n\n\t\tif (this.sessionKeys[pushIdentifierId]) {\n\t\t\treturn base64ToUint8Array(this.sessionKeys[pushIdentifierId])\n\t\t} else {\n\t\t\tconst keys: Record<string, Base64> = (await this.conf.getVar(DesktopConfigKey.pushEncSessionKeys)) || {}\n\t\t\tconst sessionKeyFromConf = keys[pushIdentifierId]\n\n\t\t\tif (sessionKeyFromConf == null) {\n\t\t\t\t// key with this id is not saved in local conf, so we can't resolve it\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst decryptedKey = this.cryptoFacade.unauthenticatedAes256DecryptKey(pw, base64ToUint8Array(sessionKeyFromConf))\n\t\t\t\tthis.sessionKeys[pushIdentifierId] = uint8ArrayToBase64(decryptedKey)\n\t\t\t\treturn decryptedKey\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\"could not decrypt pushIdentifierSessionKey\")\n\t\t\t\treturn null\n\t\t\t}\n\t\t}\n\t}\n\n\tasync storeAlarm(alarm: EncryptedAlarmNotification): Promise<void> {\n\t\tconst allAlarms = await this.getScheduledAlarms()\n\t\tfindAllAndRemove(allAlarms, (an) => an.alarmInfo.alarmIdentifier === alarm.alarmInfo.alarmIdentifier)\n\t\tallAlarms.push(alarm)\n\t\tawait this._saveAlarms(allAlarms)\n\t}\n\n\tasync deleteAlarm(identifier: string): Promise<void> {\n\t\tconst allAlarms = await this.getScheduledAlarms()\n\t\tfindAllAndRemove(allAlarms, (an) => an.alarmInfo.alarmIdentifier === identifier)\n\t\tawait this._saveAlarms(allAlarms)\n\t}\n\n\t/**\n\t * If userId is null then we delete alarms for all users\n\t */\n\tasync deleteAllAlarms(userId: Id | null): Promise<void> {\n\t\tif (userId == null) {\n\t\t\treturn this._saveAlarms([])\n\t\t} else {\n\t\t\tconst allScheduledAlarms = await this.getScheduledAlarms()\n\t\t\tfindAllAndRemove(allScheduledAlarms, (alarm) => alarm.user === userId)\n\t\t\treturn this._saveAlarms(allScheduledAlarms)\n\t\t}\n\t}\n\n\tasync getScheduledAlarms(): Promise<Array<EncryptedAlarmNotification>> {\n\t\t// the model for alarm notifications changed and we may have stored some that are missing the\n\t\t// excludedDates field.\n\t\t// to be able to decrypt & map these we need to at least add a plausible value there\n\t\t// we'll unschedule, redownload and reschedule the fixed instances after login.\n\t\tconst alarms: Array<EncryptedAlarmNotification & { repeatRule?: Record<string, unknown> }> = await this.conf.getVar(DesktopConfigKey.scheduledAlarms)\n\t\treturn (\n\t\t\talarms?.map((a) => {\n\t\t\t\tif (!a.repeatRule) return a\n\t\t\t\ta.repeatRule = { excludedDates: [], ...a.repeatRule }\n\t\t\t\treturn a\n\t\t\t}) || []\n\t\t)\n\t}\n\n\t_saveAlarms(alarms: ReadonlyArray<EncryptedAlarmNotification>): Promise<void> {\n\t\treturn this.conf.setVar(DesktopConfigKey.scheduledAlarms, alarms)\n\t}\n}\n","import o from \"@tutao/otest\"\nimport { instance, matchers, object, verify, when } from \"testdouble\"\nimport { DesktopAlarmStorage } from \"../../../../src/common/desktop/sse/DesktopAlarmStorage.js\"\nimport { DesktopConfig } from \"../../../../src/common/desktop/config/DesktopConfig.js\"\nimport { DesktopNativeCryptoFacade } from \"../../../../src/common/desktop/DesktopNativeCryptoFacade.js\"\nimport type { DesktopKeyStoreFacade } from \"../../../../src/common/desktop/DesktopKeyStoreFacade.js\"\nimport { makeKeyStoreFacade } from \"../../TestUtils.js\"\nimport { DesktopConfigKey } from \"../../../../src/common/desktop/config/ConfigKeys.js\"\nimport { assertNotNull, uint8ArrayToBase64 } from \"@tutao/tutanota-utils\"\n\no.spec(\"DesktopAlarmStorageTest\", function () {\n\tlet cryptoMock: DesktopNativeCryptoFacade\n\tlet confMock: DesktopConfig\n\n\tconst key1 = new Uint8Array([1])\n\tconst key2 = new Uint8Array([2])\n\tconst key3 = new Uint8Array([3])\n\tconst key4 = new Uint8Array([4])\n\tconst decryptedKey = new Uint8Array([0, 1])\n\tconst encryptedKey = new Uint8Array([1, 0])\n\n\to.beforeEach(function () {\n\t\tcryptoMock = instance(DesktopNativeCryptoFacade)\n\t\twhen(cryptoMock.unauthenticatedAes256DecryptKey(matchers.anything(), key3)).thenReturn(decryptedKey)\n\t\twhen(cryptoMock.aes256EncryptKey(matchers.anything(), matchers.anything())).thenReturn(encryptedKey)\n\n\t\tconfMock = object()\n\t\twhen(confMock.getVar(DesktopConfigKey.pushEncSessionKeys)).thenResolve({\n\t\t\tuser1: uint8ArrayToBase64(key1),\n\t\t\tuser2: uint8ArrayToBase64(key2),\n\t\t\ttwoId: uint8ArrayToBase64(key3),\n\t\t\tfourId: uint8ArrayToBase64(key4),\n\t\t})\n\t})\n\n\to(\"getPushIdentifierSessionKey with uncached sessionKey\", async function () {\n\t\tconst keyStoreFacade: DesktopKeyStoreFacade = makeKeyStoreFacade(new Uint8Array([1, 2, 3]))\n\t\tconst desktopStorage = new DesktopAlarmStorage(confMock, cryptoMock, keyStoreFacade)\n\t\tconst key = await desktopStorage.getPushIdentifierSessionKey({\n\t\t\tpushIdentifierSessionEncSessionKey: \"abc\",\n\t\t\tpushIdentifier: [\"oneId\", \"twoId\"],\n\t\t})\n\n\t\tverify(confMock.getVar(DesktopConfigKey.pushEncSessionKeys), { times: 1 })\n\t\to(Array.from(assertNotNull(key))).deepEquals(Array.from(decryptedKey))\n\t})\n\n\to(\"getPushIdentifierSessionKey with cached sessionKey\", async function () {\n\t\tconst keyStoreFacade: DesktopKeyStoreFacade = makeKeyStoreFacade(new Uint8Array([1, 2, 3]))\n\t\twhen(confMock.getVar(matchers.anything())).thenResolve(null)\n\t\tconst desktopStorage = new DesktopAlarmStorage(confMock, cryptoMock, keyStoreFacade)\n\t\tawait desktopStorage.storePushIdentifierSessionKey(\"fourId\", key4)\n\n\t\tverify(confMock.setVar(DesktopConfigKey.pushEncSessionKeys, { fourId: uint8ArrayToBase64(encryptedKey) }), { times: 1 })\n\n\t\tconst key = await desktopStorage.getPushIdentifierSessionKey({\n\t\t\tpushIdentifierSessionEncSessionKey: \"def\",\n\t\t\tpushIdentifier: [\"threeId\", \"fourId\"],\n\t\t})\n\t\to(Array.from(assertNotNull(key))).deepEquals(Array.from(key4))\n\t})\n\n\to(\"getPushIdentifierSessionKey when sessionKey is unavailable\", async function () {\n\t\tconst keyStoreFacade: DesktopKeyStoreFacade = makeKeyStoreFacade(new Uint8Array([1, 2, 3]))\n\t\tconst desktopStorage = new DesktopAlarmStorage(confMock, cryptoMock, keyStoreFacade)\n\t\tconst key1 = await desktopStorage.getPushIdentifierSessionKey({\n\t\t\tpushIdentifierSessionEncSessionKey: \"def\",\n\t\t\tpushIdentifier: [\"fiveId\", \"sixId\"],\n\t\t})\n\t\to(key1).equals(null)\n\t})\n})\n"],"mappings":"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"}