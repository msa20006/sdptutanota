
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { stringToUtf8Uint8Array } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import "./LanguageViewModel-BNC5ekpO.js";
import { NotFoundError, PreconditionFailedError, TooManyRequestsError } from "./RestError-D17JEBMr.js";
import "./CryptoError-PqdvQky4.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import { HttpMethod } from "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./dist-DcZ1Y4qd.js";
import { createDataFile } from "./DataFile-CY7uuk9j.js";
import "./FileUtils-W-u2-gZz.js";
import { BuildConfigKey, DesktopConfigKey } from "./ConfigKeys-B1UD5FwS.js";
import "./DesktopLog-yAgEoQsh.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { assertThrows } from "./dist-BY49f75m.js";
import { nodemocker_default } from "./nodemocker-Bh_RUICG.js";
import "./PathUtils-DFfSo_TG.js";
import { DesktopFileFacade } from "./DesktopFileFacade-o-Coc2Lq.js";

//#region tests/desktop/files/DesktopFileFacadeTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
const DEFAULT_DOWNLOAD_PATH = "/a/download/path/";
dist_default.spec("DesktopFileFacade", function() {
	let win;
	let conf;
	let du;
	let dp;
	let fetch;
	let electron;
	let fs;
	let tfs;
	let ff;
	dist_default.beforeEach(function() {
		win = (0, import_testdouble.object)();
		fetch = (0, import_testdouble.func)();
		fs = (0, import_testdouble.object)();
		tfs = (0, import_testdouble.object)();
		fs.promises = (0, import_testdouble.object)();
		(0, import_testdouble.when)(fs.promises.stat(import_testdouble.matchers.anything())).thenResolve({ size: 42 });
		electron = (0, import_testdouble.object)();
		electron["shell"] = (0, import_testdouble.object)();
		electron["dialog"] = (0, import_testdouble.object)();
		conf = (0, import_testdouble.object)();
		du = (0, import_testdouble.object)();
		dp = (0, import_testdouble.object)();
		ff = new DesktopFileFacade(win, conf, dp, fetch, electron, tfs, fs);
	});
	dist_default.spec("saveDataFile", function() {
		dist_default("when there's no existing file it will be simply written", async function() {
			const dataFile = createDataFile("blob", "application/octet-stream", new Uint8Array([1]));
			(0, import_testdouble.when)(fs.promises.readdir(import_testdouble.matchers.anything())).thenResolve(["somethingelse"]);
			(0, import_testdouble.when)(fs.promises.mkdir("/tutanota/tmp/path/download", { recursive: true })).thenResolve(undefined);
			(0, import_testdouble.when)(fs.promises.writeFile("/tutanota/tmp/path/download/blob", dataFile.data)).thenResolve();
			await ff.writeDataFile(dataFile);
		});
		dist_default("with default download path but file exists -> nonclobbering name is chosen", async function() {
			const e = new Error();
			e.code = "EEXISTS";
			const dataFile = createDataFile("blob", "application/octet-stream", new Uint8Array([1]));
			(0, import_testdouble.when)(fs.promises.writeFile("/tutanota/tmp/path/download/blob", import_testdouble.matchers.anything())).thenReject(e);
			(0, import_testdouble.when)(fs.promises.readdir(import_testdouble.matchers.anything())).thenResolve(["blob"]);
			(0, import_testdouble.when)(fs.promises.mkdir("/tutanota/tmp/path/download", { recursive: true })).thenResolve(undefined);
			(0, import_testdouble.when)(fs.promises.writeFile("/tutanota/tmp/path/download/blob-1", dataFile.data)).thenResolve();
			await ff.writeDataFile(dataFile);
		});
	});
	dist_default.spec("download", function() {
		dist_default("no error", async function() {
			const headers = {
				v: "foo",
				accessToken: "bar"
			};
			const expectedFilePath = "/tutanota/tmp/path/encrypted/nativelyDownloadedFile";
			const response = mockResponse(200, { responseBody: new Uint8Array() });
			const ws = mockWriteStream(response);
			(0, import_testdouble.when)(fs.createWriteStream(expectedFilePath, { emitClose: true })).thenReturn(ws);
			(0, import_testdouble.when)(fetch(urlMatches(new URL("some://url/file")), {
				method: "GET",
				headers
			})).thenResolve(response);
			(0, import_testdouble.when)(ws.on("finish")).thenCallback(undefined, undefined);
			(0, import_testdouble.when)(tfs.ensureEncryptedDir()).thenResolve("/tutanota/tmp/path/encrypted");
			const downloadResult = await ff.download("some://url/file", "nativelyDownloadedFile", headers);
			dist_default(downloadResult.statusCode).equals(200);
			dist_default(downloadResult.encryptedFileUri).equals(expectedFilePath);
		});
		dist_default("404 error gets returned", async function() {
			const headers = {
				v: "foo",
				accessToken: "bar"
			};
			const errorId = "123";
			const response = mockResponse(NotFoundError.CODE, { responseHeaders: { "error-id": errorId } });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const result = await ff.download("some://url/file", "nativelyDownloadedFile", headers);
			dist_default(result).deepEquals({
				statusCode: 404,
				errorId,
				precondition: null,
				suspensionTime: null,
				encryptedFileUri: null
			});
			(0, import_testdouble.verify)(fs.createWriteStream(import_testdouble.matchers.anything(), import_testdouble.matchers.anything()), { times: 0 });
		});
		dist_default("retry-after", async function() {
			const retryAfter = "20";
			const errorId = "123";
			const response = mockResponse(TooManyRequestsError.CODE, { responseHeaders: {
				"error-id": errorId,
				"retry-after": retryAfter
			} });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const headers = {
				v: "foo",
				accessToken: "bar"
			};
			const result = await ff.download("some://url/file", "nativelyDownloadedFile", headers);
			dist_default(result).deepEquals({
				statusCode: TooManyRequestsError.CODE,
				errorId,
				precondition: null,
				suspensionTime: retryAfter,
				encryptedFileUri: null
			});
			(0, import_testdouble.verify)(fs.createWriteStream(import_testdouble.matchers.anything(), import_testdouble.matchers.anything()), { times: 0 });
		});
		dist_default("suspension", async function() {
			const headers = {
				v: "foo",
				accessToken: "bar"
			};
			const errorId = "123";
			const retryAfter = "20";
			const response = mockResponse(TooManyRequestsError.CODE, { responseHeaders: {
				"error-id": errorId,
				"suspension-time": retryAfter
			} });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const result = await ff.download("some://url/file", "nativelyDownloadedFile", headers);
			dist_default(result).deepEquals({
				statusCode: TooManyRequestsError.CODE,
				errorId,
				precondition: null,
				suspensionTime: retryAfter,
				encryptedFileUri: null
			});
			(0, import_testdouble.verify)(fs.createWriteStream(import_testdouble.matchers.anything(), import_testdouble.matchers.anything()), { times: 0 });
		});
		dist_default("precondition", async function() {
			const headers = {
				v: "foo",
				accessToken: "bar"
			};
			const errorId = "123";
			const precondition = "a.2";
			const response = mockResponse(PreconditionFailedError.CODE, { responseHeaders: {
				"error-id": errorId,
				precondition
			} });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const result = await ff.download("some://url/file", "nativelyDownloadedFile", headers);
			dist_default(result).deepEquals({
				statusCode: PreconditionFailedError.CODE,
				errorId,
				precondition,
				suspensionTime: null,
				encryptedFileUri: null
			});
			(0, import_testdouble.verify)(fs.createWriteStream(import_testdouble.matchers.anything(), import_testdouble.matchers.anything()), { times: 0 });
		});
		dist_default("IO error during download leads to cleanup and error is thrown", async function() {
			const headers = {
				v: "foo",
				accessToken: "bar"
			};
			const response = mockResponse(200, { responseBody: new Uint8Array() });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const error = new Error("Test! I/O error");
			const ws = mockWriteStream();
			(0, import_testdouble.when)(ws.on("finish", import_testdouble.matchers.anything())).thenThrow(error);
			(0, import_testdouble.when)(fs.createWriteStream(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenReturn(ws);
			(0, import_testdouble.when)(tfs.ensureEncryptedDir()).thenResolve("/tutanota/tmp/path/encrypted");
			const e = await assertThrows(Error, () => ff.download("some://url/file", "nativelyDownloadedFile", headers));
			dist_default(e).equals(error);
			(0, import_testdouble.verify)(fs.promises.unlink("/tutanota/tmp/path/encrypted/nativelyDownloadedFile"), { times: 1 });
		});
	});
	dist_default.spec("upload", function() {
		const fileToUploadPath = "/tutnaota/tmp/path/encrypted/toUpload.txt";
		const targetUrl = "https://test.tutanota.com/rest/for/a/bit";
		dist_default("when there's no error it uploads correct data and returns the right result", async function() {
			const body = stringToUtf8Uint8Array("BODY");
			const response = mockResponse(200, { responseBody: body });
			const headers = { blobAccessToken: "1236" };
			const fileStreamMock = mockReadStream();
			(0, import_testdouble.when)(fs.createReadStream(fileToUploadPath)).thenReturn(fileStreamMock);
			(0, import_testdouble.when)(fetch(urlMatches(new URL(targetUrl)), {
				method: HttpMethod.POST,
				headers,
				body: fileStreamMock
			})).thenResolve(response);
			const uploadResult = await ff.upload(fileToUploadPath, targetUrl, HttpMethod.POST, headers);
			dist_default(uploadResult.statusCode).equals(200);
			dist_default(uploadResult.errorId).equals(null);
			dist_default(uploadResult.precondition).equals(null);
			dist_default(uploadResult.suspensionTime).equals(null);
			dist_default(Array.from(uploadResult.responseBody)).deepEquals(Array.from(body));
		});
		dist_default("when 404 is returned it returns correct result", async function() {
			const errorId = "123";
			const response = mockResponse(404, { responseHeaders: { "error-id": errorId } });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const uploadResult = await ff.upload(fileToUploadPath, targetUrl, HttpMethod.POST, {});
			dist_default(uploadResult.statusCode).equals(404);
			dist_default(uploadResult.errorId).equals(errorId);
			dist_default(uploadResult.precondition).equals(null);
			dist_default(uploadResult.suspensionTime).equals(null);
			dist_default(Array.from(uploadResult.responseBody)).deepEquals([]);
		});
		dist_default("when retry-after is returned, it is propagated", async function() {
			const retryAFter = "20";
			const errorId = "123";
			const response = mockResponse(TooManyRequestsError.CODE, { responseHeaders: {
				"error-id": errorId,
				"retry-after": retryAFter
			} });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const uploadResult = await ff.upload(fileToUploadPath, targetUrl, HttpMethod.POST, {});
			dist_default(uploadResult.statusCode).equals(TooManyRequestsError.CODE);
			dist_default(uploadResult.errorId).equals(errorId);
			dist_default(uploadResult.precondition).equals(null);
			dist_default(uploadResult.suspensionTime).equals(retryAFter);
			dist_default(Array.from(uploadResult.responseBody)).deepEquals([]);
		});
		dist_default("when suspension-time is returned, it is propagated", async function() {
			const retryAFter = "20";
			const errorId = "123";
			const response = mockResponse(TooManyRequestsError.CODE, { responseHeaders: {
				"error-id": errorId,
				"suspension-time": retryAFter
			} });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const uploadResult = await ff.upload(fileToUploadPath, targetUrl, HttpMethod.POST, {});
			dist_default(uploadResult.statusCode).equals(TooManyRequestsError.CODE);
			dist_default(uploadResult.errorId).equals(errorId);
			dist_default(uploadResult.precondition).equals(null);
			dist_default(uploadResult.suspensionTime).equals(retryAFter);
			dist_default(Array.from(uploadResult.responseBody)).deepEquals([]);
		});
		dist_default("when precondition-time is returned, it is propagated", async function() {
			const precondition = "a.2";
			const errorId = "123";
			const response = mockResponse(PreconditionFailedError.CODE, { responseHeaders: {
				"error-id": errorId,
				precondition
			} });
			(0, import_testdouble.when)(fetch(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenResolve(response);
			const uploadResult = await ff.upload(fileToUploadPath, targetUrl, HttpMethod.POST, {});
			dist_default(uploadResult.statusCode).equals(PreconditionFailedError.CODE);
			dist_default(uploadResult.errorId).equals(errorId);
			dist_default(uploadResult.precondition).equals(precondition);
			dist_default(uploadResult.suspensionTime).equals(null);
			dist_default(Array.from(uploadResult.responseBody)).deepEquals([]);
		});
	});
	dist_default.spec("open", function() {
		dist_default("open valid", async function() {
			(0, import_testdouble.when)(electron.shell.openPath("/some/folder/file")).thenResolve("");
			await ff.open("/some/folder/file");
		});
		dist_default("open invalid", async () => {
			await assertThrows(Error, () => ff.open("invalid"));
			(0, import_testdouble.verify)(electron.shell.openPath("invalid"), { times: 1 });
		});
		dist_default("open on windows", async function() {
			nodemocker_default.setPlatform("win32");
			(0, import_testdouble.when)(electron.dialog.showMessageBox(import_testdouble.matchers.anything())).thenReturn(Promise.resolve({
				response: 1,
				checkboxChecked: false
			}));
			await ff.open("exec.exe");
			(0, import_testdouble.verify)(electron.shell.openPath(import_testdouble.matchers.anything()), { times: 0 });
		});
	});
	dist_default.spec("join", function() {
		dist_default("join a single file", async function() {
			const ws = mockWriteStream();
			const rs = mockReadStream(ws);
			(0, import_testdouble.when)(fs.createWriteStream(import_testdouble.matchers.anything(), import_testdouble.matchers.anything())).thenReturn(ws);
			(0, import_testdouble.when)(fs.createReadStream(import_testdouble.matchers.anything())).thenReturn(rs);
			(0, import_testdouble.when)(rs.on("end")).thenCallback(undefined, undefined);
			(0, import_testdouble.when)(fs.promises.readdir("/tutanota/tmp/path/unencrypted")).thenResolve(["folderContents"]);
			(0, import_testdouble.when)(tfs.ensureUnencrytpedDir()).thenResolve("/tutanota/tmp/path/unencrypted");
			const joinedFilePath = await ff.joinFiles("fileName.pdf", ["/file1"]);
			dist_default(joinedFilePath).equals("/tutanota/tmp/path/unencrypted/fileName.pdf");
		});
	});
	dist_default.spec("splitFile", function() {
		dist_default("returns one slice for a small file", async function() {
			const filename = "/tutanota/tmp/path/download/small.txt";
			const fileContent = stringToUtf8Uint8Array(filename);
			const filenameHash = "9ca089f82e397e9e860daa312ac25def39f2da0e066f0de94ffc02aa7b3a6250";
			const expectedChunkPath = `/tutanota/tmp/path/unencrypted/${filenameHash}.0.blob`;
			(0, import_testdouble.when)(tfs.ensureUnencrytpedDir()).thenResolve("/tutanota/tmp/path/unencrypted");
			(0, import_testdouble.when)(fs.promises.writeFile(expectedChunkPath, fileContent)).thenResolve();
			(0, import_testdouble.when)(fs.promises.readFile(filename)).thenResolve(Buffer.from(fileContent));
			const chunks = await ff.splitFile(filename, 1024);
			dist_default(chunks).deepEquals([expectedChunkPath])("only one chunk");
		});
		dist_default("returns multiple slices for a bigger file", async function() {
			const filename = "/tutanota/tmp/path/download/big.txt";
			const fileContent = stringToUtf8Uint8Array(filename);
			const filenameHash = "c24646a4738a92d624cd03134f26c371d8a2950d2b3bbce7921c288de9a56fd3";
			const expectedChunkPath0 = `/tutanota/tmp/path/unencrypted/${filenameHash}.0.blob`;
			const expectedChunkPath1 = `/tutanota/tmp/path/unencrypted/${filenameHash}.1.blob`;
			(0, import_testdouble.when)(tfs.ensureUnencrytpedDir()).thenResolve("/tutanota/tmp/path/unencrypted");
			(0, import_testdouble.when)(fs.promises.writeFile(expectedChunkPath0, fileContent.slice(0, 30))).thenResolve();
			(0, import_testdouble.when)(fs.promises.writeFile(expectedChunkPath1, fileContent.slice(30))).thenResolve();
			(0, import_testdouble.when)(fs.promises.readFile(filename)).thenResolve(Buffer.from(fileContent));
			const chunks = await ff.splitFile(filename, 30);
			dist_default(chunks).deepEquals([expectedChunkPath0, expectedChunkPath1])("both written files are in the returned array");
		});
	});
	dist_default.spec("showInFileExplorer", function() {
		dist_default("two downloads, open two filemanagers", async function() {
			const dir = "/path/to";
			const p = dir + "/file.txt";
			await ff.showInFileExplorer(p);
			(0, import_testdouble.verify)(electron.shell.openPath(dir), { times: 1 });
		});
		dist_default("two downloads, open two filemanagers after a pause", async function() {
			const time = 1629115820468;
			const dir = "/path/to";
			const p = dir + "/file.txt";
			await ff.showInFileExplorer(p);
			(0, import_testdouble.when)(dp.now()).thenReturn(time);
			(0, import_testdouble.when)(conf.getConst(BuildConfigKey.fileManagerTimeout)).thenResolve(2);
			(0, import_testdouble.verify)(electron.shell.openPath(dir), { times: 1 });
			(0, import_testdouble.when)(dp.now()).thenReturn(time + 10);
			await ff.showInFileExplorer(p);
			(0, import_testdouble.verify)(electron.shell.openPath(dir), { times: 2 });
		});
	});
	dist_default.spec("putFileIntoDownloadsFolder", function() {
		dist_default("putFileIntoDownloadsFolder", async function() {
			const src = "/path/random.pdf";
			const filename = "fileName.pdf";
			(0, import_testdouble.when)(conf.getVar(DesktopConfigKey.defaultDownloadPath)).thenResolve(DEFAULT_DOWNLOAD_PATH);
			(0, import_testdouble.when)(fs.promises.readdir(import_testdouble.matchers.anything())).thenResolve([]);
			const copiedFileUri = await ff.putFileIntoDownloadsFolder(src, filename);
			(0, import_testdouble.verify)(fs.promises.copyFile(src, DEFAULT_DOWNLOAD_PATH + "fileName.pdf"));
			dist_default(copiedFileUri).equals(DEFAULT_DOWNLOAD_PATH + "fileName.pdf");
		});
	});
	dist_default.spec("size", function() {
		dist_default("size", async function() {
			(0, import_testdouble.when)(fs.promises.stat(import_testdouble.matchers.anything())).thenResolve({ size: 33 });
			dist_default(await ff.getSize("/file1")).equals(33);
		});
	});
	dist_default.spec("hash", function() {
		dist_default("hash", async function() {
			(0, import_testdouble.when)(fs.promises.readFile("/file1")).thenResolve(new Uint8Array([
				0,
				1,
				2,
				3
			]));
			dist_default(await ff.hashFile("/file1")).equals("BU7ewdAh");
		});
	});
});
function mockReadStream(ws) {
	const rs = (0, import_testdouble.object)();
	if (ws != null) (0, import_testdouble.when)(rs.pipe(ws, { end: false })).thenReturn(ws);
	return rs;
}
const urlMatches = import_testdouble.matchers.create({
	name: "urlMatches",
	matches(matcherArgs, actual) {
		return actual.toString() === matcherArgs[0].toString();
	}
});
function mockWriteStream(response) {
	const ws = (0, import_testdouble.object)();
	if (response != null) {}
	const closeCapturer = import_testdouble.matchers.captor();
	(0, import_testdouble.when)(ws.on("close", closeCapturer.capture())).thenReturn(ws);
	(0, import_testdouble.when)(ws.close()).thenDo(() => closeCapturer.value());
	return ws;
}
function mockResponse(statusCode, resOpts) {
	const { responseBody, responseHeaders } = resOpts;
	return new global.Response(responseBody, {
		status: statusCode,
		headers: new Headers(responseHeaders)
	});
}

//#endregion
//# sourceMappingURL=DesktopFileFacadeTest-C-8eR8kB.js.map