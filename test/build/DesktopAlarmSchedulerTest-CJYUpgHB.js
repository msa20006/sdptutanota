
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import "./mithril-Csg4iNnm.js";
import { base64ToUint8Array, downcast, isSameDay, lastThrow } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import "./LanguageViewModel-BNC5ekpO.js";
import { EndType, OperationType, RepeatPeriod } from "./TutanotaConstants-3bwAESYA.js";
import "./Icons-Dl3nFav5.js";
import "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import { CryptoError } from "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import { hasError } from "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import "./stream-u2PttBAC.js";
import "./luxon-D6cgmg6Q.js";
import { elementIdPart } from "./EntityUtils-RQxXZlcV.js";
import "./CommonCalendarUtils-DKaO7v1K.js";
import { formatDateWithWeekdayAndTime, formatTime } from "./Formatter-zB15D6XI.js";
import "./TypeModels-XIXYys8J.js";
import "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import { AlarmInfoTypeRef, AlarmNotificationTypeRef, CalendarEventRefTypeRef, RepeatRuleTypeRef } from "./TypeRefs-BP1jvX9p.js";
import "./CalendarUtils-C6jeYrj9.js";
import "./ProgressMonitor-HBfOF56H.js";
import "./Notifications-DLibQbV7.js";
import { resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./EntityClient-B0RSdk2i.js";
import "./SetupMultipleError-B6uY8P-x.js";
import "./dist-DcZ1Y4qd.js";
import "./Services-CZFE0084.js";
import "./Services-DCx-CeM7.js";
import "./CalendarFacade-CaovxyFN.js";
import { formatNotificationForDisplay } from "./CalendarModel-DK762b35.js";
import "./EntityUpdateUtils-B5iTKMk4.js";
import "./GroupUtils-CpT2lvVS.js";
import "./CommonLocator-Csg4iNnm.js";
import "./ImportExportUtils-B1MoOmZ0.js";
import "./FormatValidator-2BBermUe.js";
import "./UserError-DfXlMLTl.js";
import "./Recipient-BFxhfecW.js";
import "./IndexTables-C5S9WDY9.js";
import "./IndexUtils-K27esrGs.js";
import { log } from "./DesktopLog-yAgEoQsh.js";
import "./IndexerCore-CrLYpsA5.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { assertThrows, spy } from "./dist-BY49f75m.js";
import "./TestUtils-f_4UhLVE.js";
import { makeAlarmScheduler } from "./CalendarTestUtils-I5CFxRuP.js";
import { nodemocker_default } from "./nodemocker-Bh_RUICG.js";
import { NotificationResult } from "./DesktopNotifier-BR7GuUWK.js";

//#region ../src/common/desktop/sse/DesktopAlarmScheduler.ts
var DesktopAlarmScheduler = class {
	constructor(wm, notifier, alarmStorage, desktopCrypto, alarmScheduler) {
		this.wm = wm;
		this.notifier = notifier;
		this.alarmStorage = alarmStorage;
		this.desktopCrypto = desktopCrypto;
		this.alarmScheduler = alarmScheduler;
	}
	/**
	* stores, deletes and schedules alarm notifications
	* @param an the AlarmNotification to handle
	*/
	async handleAlarmNotification(an) {
		if (an.operation === OperationType.CREATE) await this.handleCreateAlarm(an);
else if (an.operation === OperationType.DELETE) {
			log.debug(`deleting alarm notifications for ${an.alarmInfo.alarmIdentifier}!`);
			this.handleDeleteAlarm(an);
		} else console.warn(`received AlarmNotification (alarmInfo identifier ${an.alarmInfo.alarmIdentifier}) with unsupported operation ${an.operation}, ignoring`);
	}
	async unscheduleAllAlarms(userId = null) {
		const alarms = await this.alarmStorage.getScheduledAlarms();
		for (const alarm of alarms) if (userId == null || alarm.user === userId) this.cancelAlarms(alarm);
		return this.alarmStorage.deleteAllAlarms(userId);
	}
	/**
	* read all stored alarms and reschedule the notifications
	*/
	async rescheduleAll() {
		const alarms = await this.alarmStorage.getScheduledAlarms();
		for (const alarm of alarms) await this.decryptAndSchedule(alarm);
	}
	async decryptAndSchedule(an) {
		for (const currentKey of an.notificationSessionKeys) {
			const pushIdentifierSessionKey = await this.alarmStorage.getPushIdentifierSessionKey(currentKey);
			if (!pushIdentifierSessionKey) continue;
			const decAn = await this.desktopCrypto.decryptAndMapToInstance(await resolveTypeReference(AlarmNotificationTypeRef), an, pushIdentifierSessionKey, base64ToUint8Array(currentKey.pushIdentifierSessionEncSessionKey));
			if (hasError(decAn)) {
				await this.alarmStorage.removePushIdentifierKey(elementIdPart(currentKey.pushIdentifier));
				continue;
			}
			an.notificationSessionKeys = [currentKey];
			return this.scheduleAlarms(decAn);
		}
		throw new CryptoError("could not decrypt alarmNotification");
	}
	handleDeleteAlarm(an) {
		this.cancelAlarms(an);
		this.alarmStorage.deleteAlarm(an.alarmInfo.alarmIdentifier);
	}
	async handleCreateAlarm(an) {
		log.debug("creating alarm notification!");
		await this.decryptAndSchedule(an);
		await this.alarmStorage.storeAlarm(an);
	}
	cancelAlarms(an) {
		this.alarmScheduler.cancelAlarm(an.alarmInfo.alarmIdentifier);
	}
	scheduleAlarms(decAn) {
		const eventInfo = {
			startTime: decAn.eventStart,
			endTime: decAn.eventEnd,
			summary: decAn.summary
		};
		this.alarmScheduler.scheduleAlarm(eventInfo, decAn.alarmInfo, decAn.repeatRule, (eventTime, summary) => {
			const { title, body } = formatNotificationForDisplay$1(eventTime, summary);
			this.notifier.submitGroupedNotification(title, body, decAn.alarmInfo.alarmIdentifier, (res) => {
				if (res === NotificationResult.Click) this.wm.openCalendar({ userId: decAn.user });
			});
		});
	}
};
function formatNotificationForDisplay$1(eventTime, summary) {
	let dateString;
	if (isSameDay(eventTime, new Date())) dateString = formatTime(eventTime);
else dateString = formatDateWithWeekdayAndTime(eventTime);
	const body = `${dateString} ${summary}`;
	return {
		body,
		title: body
	};
}

//#endregion
//#region tests/desktop/sse/DesktopAlarmSchedulerTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
const oldTimezone = process.env.TZ;
dist_default.spec("DesktopAlarmSchedulerTest", function() {
	dist_default.before(function() {
		process.env.TZ = "Europe/Berlin";
	});
	dist_default.after(function() {
		process.env.TZ = oldTimezone;
	});
	const lang = { lang: { get: (key) => key } };
	const crypto = { decryptAndMapToInstance: (tm, an) => Promise.resolve(Object.assign({}, an)) };
	const alarmNotification = {};
	const wm = { openCalendar() {} };
	const notifier = { submitGroupedNotification: () => {
		console.log("show notification!");
	} };
	const standardMocks = () => {
		const langMock = nodemocker_default.mock("__lang", lang).set();
		const alarmNotificationMock = nodemocker_default.mock("__alarmNotification", alarmNotification).set();
		const cryptoMock = nodemocker_default.mock("__crypto", crypto).set();
		const wmMock = nodemocker_default.mock("__wm", wm).set();
		const notifierMock = nodemocker_default.mock("__notifier", notifier).set();
		const alarmStorage = {
			storeAlarm: spy(() => Promise.resolve()),
			deleteAlarm: spy(() => Promise.resolve()),
			getPushIdentifierSessionKey: () => Promise.resolve("piSk"),
			getScheduledAlarms: () => [],
			removePushIdentifierKey: () => {}
		};
		const alarmStorageMock = nodemocker_default.mock("__alarmStorage", alarmStorage).set();
		return {
			langMock,
			alarmNotificationMock,
			wmMock,
			notifierMock,
			alarmStorageMock,
			cryptoMock
		};
	};
	dist_default.spec("rescheduleAll", function() {
		dist_default("no alarms", async function() {
			const { wmMock, notifierMock, cryptoMock, alarmStorageMock } = standardMocks();
			const alarmScheduler = makeAlarmScheduler();
			const scheduler = new DesktopAlarmScheduler(wmMock, notifierMock, alarmStorageMock, cryptoMock, alarmScheduler);
			await scheduler.rescheduleAll();
			dist_default(alarmStorageMock.storeAlarm.callCount).equals(0);
			dist_default(notifierMock.submitGroupedNotification.callCount).equals(0);
			(0, import_testdouble.verify)(alarmScheduler.scheduleAlarm(import_testdouble.matchers.anything(), import_testdouble.matchers.anything(), import_testdouble.matchers.anything(), import_testdouble.matchers.anything()), { times: 0 });
		});
		dist_default("some alarms", async function() {
			const { wmMock, notifierMock, cryptoMock, alarmStorageMock } = standardMocks();
			const alarmScheduler = makeAlarmScheduler();
			const scheduler = new DesktopAlarmScheduler(wmMock, notifierMock, alarmStorageMock, cryptoMock, alarmScheduler);
			const an = createAlarmNotification({
				startTime: new Date(2019, 9, 20, 10),
				endTime: new Date(2019, 9, 20, 12),
				trigger: "5M",
				endType: EndType.Never,
				endValue: null,
				frequency: RepeatPeriod.ANNUALLY,
				interval: "1"
			});
			alarmStorageMock.getScheduledAlarms = () => Promise.resolve([downcast(an)]);
			await scheduler.rescheduleAll();
			dist_default(alarmStorageMock.storeAlarm.callCount).equals(0);
			(0, import_testdouble.verify)(alarmScheduler.scheduleAlarm({
				startTime: an.eventStart,
				endTime: an.eventEnd,
				summary: an.summary
			}, an.alarmInfo, an.repeatRule, import_testdouble.matchers.anything()), { times: 1 });
		});
	});
	dist_default.spec("handleAlarmNotification", function() {
		dist_default("handle multiple events", async function() {
			const { wmMock, notifierMock, alarmStorageMock, cryptoMock } = standardMocks();
			const alarmScheduler = makeAlarmScheduler();
			const scheduler = new DesktopAlarmScheduler(wmMock, notifierMock, alarmStorageMock, cryptoMock, alarmScheduler);
			const an1 = createAlarmNotification({
				startTime: new Date(2019, 9, 20, 10),
				endTime: new Date(2019, 9, 20, 12),
				trigger: "5M",
				endType: EndType.Never,
				endValue: null,
				frequency: RepeatPeriod.ANNUALLY,
				interval: "1"
			});
			const an2 = createAlarmNotification({
				startTime: new Date(2019, 9, 20, 10),
				endTime: new Date(2019, 9, 20, 12),
				trigger: "5M",
				endType: EndType.Never,
				endValue: null,
				frequency: RepeatPeriod.ANNUALLY,
				interval: "1"
			});
			const an3 = createDeleteAlarmNotification(an1.alarmInfo.alarmIdentifier);
			await scheduler.handleAlarmNotification(an1);
			await scheduler.handleAlarmNotification(an2);
			(0, import_testdouble.verify)(alarmScheduler.scheduleAlarm({
				startTime: an1.eventStart,
				endTime: an1.eventEnd,
				summary: an1.summary
			}, an1.alarmInfo, an1.repeatRule, import_testdouble.matchers.anything()), { times: 1 });
			(0, import_testdouble.verify)(alarmScheduler.scheduleAlarm({
				startTime: an2.eventStart,
				endTime: an2.eventEnd,
				summary: an2.summary
			}, an2.alarmInfo, an2.repeatRule, import_testdouble.matchers.anything()), { times: 1 });
			await scheduler.handleAlarmNotification(an3);
			(0, import_testdouble.verify)(alarmScheduler.cancelAlarm(an3.alarmInfo.alarmIdentifier), { times: 1 });
		});
		dist_default("notification is shown and calendar is opened when it's clicked", async function() {
			const { wmMock, notifierMock, alarmStorageMock, cryptoMock } = standardMocks();
			const alarmScheduler = (0, import_testdouble.object)();
			const scheduler = new DesktopAlarmScheduler(wmMock, notifierMock, alarmStorageMock, cryptoMock, alarmScheduler);
			const an1 = createAlarmNotification({
				startTime: new Date(2019, 9, 20, 10),
				endTime: new Date(2019, 9, 20, 12),
				trigger: "5M",
				endType: EndType.Never,
				endValue: null,
				frequency: RepeatPeriod.ANNUALLY,
				interval: "1"
			});
			const cbCaptor = import_testdouble.matchers.captor();
			(0, import_testdouble.when)(alarmScheduler.scheduleAlarm(import_testdouble.matchers.anything(), import_testdouble.matchers.anything(), import_testdouble.matchers.anything(), cbCaptor.capture())).thenResolve(undefined);
			await scheduler.handleAlarmNotification(an1);
			dist_default(notifierMock.submitGroupedNotification.callCount).equals(0);
			const cb = cbCaptor.value;
			cb(an1.eventStart, "title");
			const { title, body } = formatNotificationForDisplay(an1.eventStart, "title");
			dist_default(notifierMock.submitGroupedNotification.calls.map((c) => c.slice(0, -1))).deepEquals([[
				title,
				title,
				an1.alarmInfo.alarmIdentifier
			]]);
			dist_default(wmMock.openCalendar.callCount).equals(0);
			const onClick = lastThrow(notifierMock.submitGroupedNotification.calls[0]);
			onClick(NotificationResult.Click);
			dist_default(wmMock.openCalendar.callCount).equals(1);
		});
		dist_default("alarmnotification with unavailable pushIdentifierSessionKey", async function() {
			const { wmMock, notifierMock, cryptoMock } = standardMocks();
			const alarmStorageMock = nodemocker_default.mock("__alarmStorage", {
				storeAlarm: spy(() => Promise.resolve()),
				deleteAlarm: spy(() => Promise.resolve()),
				getPushIdentifierSessionKey: () => null,
				getScheduledAlarms: () => []
			}).set();
			const alarmScheduler = makeAlarmScheduler();
			const scheduler = new DesktopAlarmScheduler(wmMock, notifierMock, alarmStorageMock, cryptoMock, alarmScheduler);
			const an1 = createAlarmNotification({
				startTime: new Date(2019, 9, 20, 10),
				endTime: new Date(2019, 9, 20, 12),
				trigger: "5M",
				endType: EndType.Never,
				endValue: null,
				frequency: RepeatPeriod.ANNUALLY,
				interval: "1"
			});
			an1.notificationSessionKeys.push({
				_id: `notificationSessionKeysIdFoo`,
				pushIdentifierSessionEncSessionKey: `pushIdentifierSessionEncSessionKeyFoo`,
				pushIdentifier: [`pushIdentifierFooPart1`, `pushIdentifierFooPart2`]
			});
			await assertThrows(CryptoError, () => scheduler.handleAlarmNotification(an1));
			dist_default(alarmStorageMock.getPushIdentifierSessionKey.callCount).equals(2);
		});
		dist_default("alarmnotification with corrupt fields", async function() {
			const { wmMock, notifierMock, alarmStorageMock } = standardMocks();
			const cryptoMock = nodemocker_default.mock("__crypto", crypto).with({ decryptAndMapToInstance: (tm, an) => Promise.resolve(Object.assign({ _errors: {} }, an)) }).set();
			const alarmScheduler = makeAlarmScheduler();
			const scheduler = new DesktopAlarmScheduler(wmMock, notifierMock, alarmStorageMock, cryptoMock, alarmScheduler);
			const an1 = createAlarmNotification({
				startTime: new Date(2019, 9, 20, 10),
				endTime: new Date(2019, 9, 20, 12),
				trigger: "5M",
				endType: EndType.Never,
				endValue: null,
				frequency: RepeatPeriod.ANNUALLY,
				interval: "1"
			});
			await assertThrows(CryptoError, () => scheduler.handleAlarmNotification(an1));
			dist_default(alarmStorageMock.removePushIdentifierKey.callCount).equals(1);
		});
	});
});
let alarmIdCounter = 0;
function createAlarmNotification({ startTime, endTime, trigger, endType, endValue, frequency, interval }) {
	alarmIdCounter++;
	return {
		_id: `scheduledAlarmId${alarmIdCounter}`,
		_type: AlarmNotificationTypeRef,
		eventStart: startTime,
		eventEnd: endTime,
		operation: "0",
		summary: `summary${alarmIdCounter}`,
		alarmInfo: {
			_type: AlarmInfoTypeRef,
			_id: `alarmInfoId1${alarmIdCounter}`,
			alarmIdentifier: `alarmIdentifier${alarmIdCounter}`,
			trigger,
			calendarRef: {
				_type: CalendarEventRefTypeRef,
				_id: `calendarRefId${alarmIdCounter}`,
				elementId: `calendarRefElementId${alarmIdCounter}`,
				listId: `calendarRefListId${alarmIdCounter}`
			}
		},
		notificationSessionKeys: [{
			_id: `notificationSessionKeysId${alarmIdCounter}`,
			pushIdentifierSessionEncSessionKey: `pushIdentifierSessionEncSessionKey${alarmIdCounter}=`,
			pushIdentifier: [`pushIdentifier${alarmIdCounter}Part1`, `pushIdentifier${alarmIdCounter}Part2`]
		}],
		repeatRule: endType ? {
			_id: `repeatRuleId${alarmIdCounter}`,
			_type: RepeatRuleTypeRef,
			timeZone: "Europe/Berlin",
			excludedDates: [],
			endType,
			endValue,
			frequency,
			interval,
			advancedRules: []
		} : null,
		user: "userId1"
	};
}
function createDeleteAlarmNotification(alarmIdentifier) {
	return {
		_id: "irrelevantAlarmNotificationId",
		eventEnd: "",
		eventStart: "",
		operation: "2",
		summary: "",
		alarmInfo: {
			_id: "irrelevantAlarmInfoId",
			alarmIdentifier,
			trigger: "",
			calendarRef: {
				_id: "yZRX5A",
				elementId: "irrelevantElementId",
				listId: "irrelevantListId"
			}
		},
		notificationSessionKeys: [],
		repeatRule: null,
		user: "someIrrelevantUserId"
	};
}

//#endregion
//# sourceMappingURL=DesktopAlarmSchedulerTest-CJYUpgHB.js.map