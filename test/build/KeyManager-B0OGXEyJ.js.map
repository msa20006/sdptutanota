{"version":3,"file":"KeyManager-B0OGXEyJ.js","names":["event: KeyboardEvent","e: KeyboardEvent","onKey: keyHandler | undefined","e: HTMLElement","dom: HTMLElement","key: string","modifiers?: { ctrlOrCmd?: boolean; ctrl?: boolean; alt?: boolean; shift?: boolean; meta?: boolean }","helpShortcut: Shortcut","forceBaseShortcuts: boolean","shortcuts: ReadonlyArray<Shortcut>","shortcuts: Array<Shortcut>","operation: (id: string, s: Shortcut) => unknown","key: string | undefined","keyManager: KeyManager"],"sources":["../../src/common/misc/KeyManager.ts"],"sourcesContent":["import type { TranslationKey } from \"./LanguageViewModel\"\nimport { Keys } from \"../api/common/TutanotaConstants\"\nimport { lazy, mod } from \"@tutao/tutanota-utils\"\nimport { assertMainOrNodeBoot, isAppleDevice } from \"../api/common/Env\"\nimport m from \"mithril\"\n\nassertMainOrNodeBoot()\nexport const TABBABLE = \"button, input, textarea, div[contenteditable='true'], [tabindex='0'], a, [role=button], [role=input]\"\nexport type KeyPress = {\n\tkey: string\n\n\t/** On Apple devices, this is command; on all other platforms, this is control */\n\tctrlOrCmd: boolean\n\n\t/** Control on all platforms; should not be combined with ctrlOrCmd */\n\tctrl: boolean\n\n\t/** Shift on all platforms */\n\tshift: boolean\n\n\t/** Alt on all platforms */\n\talt: boolean\n\n\t/** Meta is the Windows, Command, or a dedicated meta key depending on platform; should not be combined with ctrlOrCmd */\n\tmeta: boolean\n}\nexport type Key = {\n\tcode: string\n\tname: string\n}\n\n/**\n * Convert the keyboard event into a key press\n * @param event event to convert\n */\nexport function keyboardEventToKeyPress(event: KeyboardEvent): KeyPress {\n\tconst ctrlOrCmd = isAppleDevice() ? event.metaKey : event.ctrlKey\n\n\treturn {\n\t\tkey: event.key,\n\t\tctrlOrCmd,\n\t\tshift: event.shiftKey,\n\t\talt: event.altKey,\n\n\t\t// Ignore these modifiers if ctrlOrCmd is set, as it will otherwise cause either both ctrl/ctrlOrCmd to be set or meta/ctrlOrCmd to be set, which will\n\t\t// make the shortcut not fire\n\t\tctrl: !ctrlOrCmd && event.ctrlKey,\n\t\tmeta: !ctrlOrCmd && event.metaKey,\n\t}\n}\n\n/**\n * @return false, if the default action should be aborted\n */\nexport type keyHandler = (key: KeyPress) => boolean\n\nexport function useKeyHandler(e: KeyboardEvent, onKey: keyHandler | undefined): boolean {\n\t// keydown is used to cancel certain keypresses of the user (mainly needed for the BubbleTextField)\n\tconst key = keyboardEventToKeyPress(e)\n\treturn onKey != null ? onKey(key) : true\n}\n\nexport interface Shortcut {\n\t// key to use (the code/name is important here)\n\tkey: Key\n\n\t// set to true to include a modifier, false or undefined to not\n\tctrlOrCmd?: boolean\n\tctrl?: boolean\n\talt?: boolean\n\tshift?: boolean\n\tmeta?: boolean\n\tenabled?: lazy<boolean>\n\n\t// must return true, if preventDefault should not be invoked\n\texec(key: KeyPress, e?: Event): boolean | void\n\n\t// displayed to the user in the help screen\n\thelp: TranslationKey\n}\n\nfunction isFocusable(e: HTMLElement) {\n\tif (\"disabled\" in e && !!e.disabled) {\n\t\treturn false\n\t}\n\tif (e.tabIndex === -1) {\n\t\t// also filter for tabIndex here to restrict tabbing to invisible inputs\n\t\treturn false\n\t}\n\treturn (\n\t\te.style.display !== \"none\" &&\n\t\t// check that none of the parents have hidden=true or aria-hidden=true\n\t\te.closest(\"[hidden]:not([hidden=false]), [aria-hidden]:not([aria-hidden=false]), [inert]:not([inert=false])\") == null\n\t)\n}\n\nexport function focusPrevious(dom: HTMLElement): boolean {\n\tconst tabbable = Array.from(dom.querySelectorAll(TABBABLE)).filter(isFocusable) as HTMLElement[]\n\n\tconst selected = tabbable.find((e) => document.activeElement === e)\n\n\tif (selected) {\n\t\t//work around for squire so tabulator actions are executed properly\n\t\t//squire makes a list which can be indented and manages this with tab and shift tab\n\t\tconst selection = window.getSelection()\n\n\t\tif (\n\t\t\tselection &&\n\t\t\tselection.focusNode &&\n\t\t\t(selection.focusNode.nodeName === \"LI\" || (selection.focusNode.parentNode && selection.focusNode.parentNode.nodeName === \"LI\"))\n\t\t) {\n\t\t\treturn true //dont change selection if selection is in list\n\t\t} else {\n\t\t\ttabbable[mod(tabbable.indexOf(selected) - 1, tabbable.length)].focus()\n\t\t\treturn false\n\t\t}\n\t} else if (tabbable.length > 0) {\n\t\ttabbable[tabbable.length - 1].focus()\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nexport function focusNext(dom: HTMLElement): boolean {\n\tconst tabbable = Array.from(dom.querySelectorAll(TABBABLE)).filter(isFocusable) as HTMLElement[]\n\n\tconst selected = tabbable.find((e) => document.activeElement === e)\n\n\tif (selected) {\n\t\t//work around for squire so tabulator actions are executed properly\n\t\t//squire makes a list which can be indented and manages this with tab and shift tab\n\t\tconst selection = window.getSelection()\n\n\t\tif (\n\t\t\tselection &&\n\t\t\tselection.focusNode &&\n\t\t\t(selection.focusNode.nodeName === \"LI\" || (selection.focusNode.parentNode && selection.focusNode.parentNode.nodeName === \"LI\"))\n\t\t) {\n\t\t\treturn true //dont change selection\n\t\t} else {\n\t\t\ttabbable[mod(tabbable.indexOf(selected) + 1, tabbable.length)].focus()\n\t\t\treturn false\n\t\t}\n\t} else if (tabbable.length > 0) {\n\t\ttabbable[0].focus()\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunction createKeyIdentifier(key: string, modifiers?: { ctrlOrCmd?: boolean; ctrl?: boolean; alt?: boolean; shift?: boolean; meta?: boolean }): string {\n\treturn (\n\t\tkey +\n\t\t(modifiers?.ctrlOrCmd ? \"X\" : \"\") +\n\t\t(modifiers?.ctrl ? \"C\" : \"\") +\n\t\t(modifiers?.alt ? \"A\" : \"\") +\n\t\t(modifiers?.shift ? \"S\" : \"\") +\n\t\t(modifiers?.meta ? \"M\" : \"\")\n\t)\n}\n\n/**\n * KeyManager offers the API for (un)registration of all keyboard shortcuts and routes\n * key presses to the correct handler.\n *\n * Shortcuts that are registered by a modal always take precedence.\n */\n\nclass KeyManager {\n\tprivate keyToShortcut: Map<string, Shortcut>\n\t// override for shortcuts: If a modal is visible, only modal-shortcuts should be active\n\tprivate keyToModalShortcut: Map<string, Shortcut>\n\tprivate desktopShortcuts: Shortcut[]\n\tprivate isHelpOpen: boolean = false\n\n\tconstructor() {\n\t\tconst helpShortcut: Shortcut = {\n\t\t\tkey: Keys.F1,\n\t\t\texec: () => this.openF1Help(),\n\t\t\thelp: \"showHelp_action\",\n\t\t}\n\t\tconst helpId = createKeyIdentifier(helpShortcut.key.code)\n\t\tthis.keyToShortcut = new Map([[helpId, helpShortcut]])\n\t\t// override for _shortcuts: If a modal is visible, only modal-shortcuts should be active\n\t\tthis.keyToModalShortcut = new Map([[helpId, helpShortcut]])\n\t\tthis.desktopShortcuts = []\n\t\tif (!window.document.addEventListener) return\n\t\twindow.document.addEventListener(\"keydown\", (e) => this.handleKeydown(e), false)\n\t}\n\n\tprivate handleKeydown(e: KeyboardEvent): void {\n\t\t// If we get a keyboard event while in a composition system (such as an input method editor),\n\t\t// it should be ignored (since the system should be handling key commands for that).\n\t\tif (!e.isComposing) {\n\t\t\tconst keysToShortcuts = this.keyToModalShortcut.size > 1 ? this.keyToModalShortcut : this.keyToShortcut\n\t\t\tconst keyPress = keyboardEventToKeyPress(e)\n\t\t\tconst shortcut = keyPress.key ? keysToShortcuts.get(createKeyIdentifier(e.key.toLowerCase(), keyPress)) : null\n\n\t\t\tif (shortcut != null && (shortcut.enabled == null || shortcut.enabled())) {\n\t\t\t\tif (shortcut.exec(keyPress) !== true) {\n\t\t\t\t\te.preventDefault()\n\t\t\t\t}\n\t\t\t}\n\t\t\tm.redraw()\n\t\t}\n\t}\n\n\t/**\n\t * open a dialog listing all currently active shortcuts\n\t * @param forceBaseShortcuts set to true for the special case where the dialog is opened\n\t * from the support dropdown (which registers its own shortcuts as modal shortcuts)\n\t */\n\topenF1Help(forceBaseShortcuts: boolean = false): void {\n\t\tif (this.isHelpOpen) return\n\t\tthis.isHelpOpen = true\n\t\t// we decide which shortcuts to show right now.\n\t\t//\n\t\t// the help dialog will register its own shortcuts which would override the\n\t\t// standard shortcuts if we did this later\n\t\t//\n\t\t// we can't do this in the register/unregister method because the modal\n\t\t// unregisters the old dialog shortcuts and then registers the new ones\n\t\t// when the top dialog changes, leading to a situation where\n\t\t// modalshortcuts is empty.\n\t\tconst shortcutsToShow =\n\t\t\tthis.keyToModalShortcut.size > 1 && !forceBaseShortcuts\n\t\t\t\t? Array.from(this.keyToModalShortcut.values()) // copy values, they will change\n\t\t\t\t: [...this.keyToShortcut.values(), ...this.desktopShortcuts]\n\t\timport(\"../gui/dialogs/ShortcutDialog.js\").then(({ showShortcutDialog }) => showShortcutDialog(shortcutsToShow)).then(() => (this.isHelpOpen = false))\n\t}\n\n\tregisterShortcuts(shortcuts: ReadonlyArray<Shortcut>) {\n\t\tthis.applyOperation(shortcuts, (id, s) => this.keyToShortcut.set(id, s))\n\t}\n\n\tunregisterShortcuts(shortcuts: ReadonlyArray<Shortcut>) {\n\t\tthis.applyOperation(shortcuts, (id, _) => this.keyToShortcut.delete(id))\n\t}\n\n\tregisterDesktopShortcuts(shortcuts: ReadonlyArray<Shortcut>) {\n\t\tthis.applyOperation(shortcuts, (_, s) => this.desktopShortcuts.push(s))\n\t}\n\n\tregisterModalShortcuts(shortcuts: Array<Shortcut>) {\n\t\tthis.applyOperation(shortcuts, (id, s) => this.keyToModalShortcut.set(id, s))\n\t}\n\n\tunregisterModalShortcuts(shortcuts: Array<Shortcut>) {\n\t\tthis.applyOperation(shortcuts, (id, _) => this.keyToModalShortcut.delete(id))\n\t}\n\n\t/**\n\t *\n\t * @param shortcuts list of shortcuts to operate on\n\t * @param operation operation to execute for every shortcut and its ID\n\t * @private\n\t */\n\tprivate applyOperation(shortcuts: ReadonlyArray<Shortcut>, operation: (id: string, s: Shortcut) => unknown) {\n\t\tfor (const s of shortcuts) {\n\t\t\toperation(createKeyIdentifier(s.key.code, s), s)\n\t\t}\n\t}\n}\n\n/**\n *\n * @param key The key to be checked, should correspond to KeyEvent.key\n * @param keys Keys to be checked against, type of Keys\n */\nexport function isKeyPressed(key: string | undefined, ...keys: Array<Key>): boolean {\n\tif (key != null) {\n\t\treturn keys.some((k) => k.code === key.toLowerCase())\n\t}\n\treturn false\n}\n\nexport const keyManager: KeyManager = new KeyManager()\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,sBAAsB;MACT,WAAW;AA4BjB,SAAS,wBAAwBA,OAAgC;CACvE,MAAM,YAAY,eAAe,GAAG,MAAM,UAAU,MAAM;AAE1D,QAAO;EACN,KAAK,MAAM;EACX;EACA,OAAO,MAAM;EACb,KAAK,MAAM;EAIX,OAAO,aAAa,MAAM;EAC1B,OAAO,aAAa,MAAM;CAC1B;AACD;AAOM,SAAS,cAAcC,GAAkBC,OAAwC;CAEvF,MAAM,MAAM,wBAAwB,EAAE;AACtC,QAAO,SAAS,OAAO,MAAM,IAAI,GAAG;AACpC;AAqBD,SAAS,YAAYC,GAAgB;AACpC,KAAI,cAAc,OAAO,EAAE,SAC1B,QAAO;AAER,KAAI,EAAE,aAAa,GAElB,QAAO;AAER,QACC,EAAE,MAAM,YAAY,UAEpB,EAAE,QAAQ,mGAAmG,IAAI;AAElH;AAEM,SAAS,cAAcC,KAA2B;CACxD,MAAM,WAAW,MAAM,KAAK,IAAI,iBAAiB,SAAS,CAAC,CAAC,OAAO,YAAY;CAE/E,MAAM,WAAW,SAAS,KAAK,CAAC,MAAM,SAAS,kBAAkB,EAAE;AAEnE,KAAI,UAAU;EAGb,MAAM,YAAY,OAAO,cAAc;AAEvC,MACC,aACA,UAAU,cACT,UAAU,UAAU,aAAa,QAAS,UAAU,UAAU,cAAc,UAAU,UAAU,WAAW,aAAa,MAEzH,QAAO;KACD;AACN,YAAS,IAAI,SAAS,QAAQ,SAAS,GAAG,GAAG,SAAS,OAAO,EAAE,OAAO;AACtE,UAAO;EACP;CACD,WAAU,SAAS,SAAS,GAAG;AAC/B,WAAS,SAAS,SAAS,GAAG,OAAO;AACrC,SAAO;CACP;AAED,QAAO;AACP;AAEM,SAAS,UAAUA,KAA2B;CACpD,MAAM,WAAW,MAAM,KAAK,IAAI,iBAAiB,SAAS,CAAC,CAAC,OAAO,YAAY;CAE/E,MAAM,WAAW,SAAS,KAAK,CAAC,MAAM,SAAS,kBAAkB,EAAE;AAEnE,KAAI,UAAU;EAGb,MAAM,YAAY,OAAO,cAAc;AAEvC,MACC,aACA,UAAU,cACT,UAAU,UAAU,aAAa,QAAS,UAAU,UAAU,cAAc,UAAU,UAAU,WAAW,aAAa,MAEzH,QAAO;KACD;AACN,YAAS,IAAI,SAAS,QAAQ,SAAS,GAAG,GAAG,SAAS,OAAO,EAAE,OAAO;AACtE,UAAO;EACP;CACD,WAAU,SAAS,SAAS,GAAG;AAC/B,WAAS,GAAG,OAAO;AACnB,SAAO;CACP;AAED,QAAO;AACP;AAED,SAAS,oBAAoBC,KAAaC,WAA6G;AACtJ,QACC,OACC,WAAW,YAAY,MAAM,OAC7B,WAAW,OAAO,MAAM,OACxB,WAAW,MAAM,MAAM,OACvB,WAAW,QAAQ,MAAM,OACzB,WAAW,OAAO,MAAM;AAE1B;IASK,aAAN,MAAiB;CAChB,AAAQ;CAER,AAAQ;CACR,AAAQ;CACR,AAAQ,aAAsB;CAE9B,cAAc;EACb,MAAMC,eAAyB;GAC9B,KAAK,KAAK;GACV,MAAM,MAAM,KAAK,YAAY;GAC7B,MAAM;EACN;EACD,MAAM,SAAS,oBAAoB,aAAa,IAAI,KAAK;AACzD,OAAK,gBAAgB,IAAI,IAAI,CAAC,CAAC,QAAQ,YAAa,CAAC;AAErD,OAAK,qBAAqB,IAAI,IAAI,CAAC,CAAC,QAAQ,YAAa,CAAC;AAC1D,OAAK,mBAAmB,CAAE;AAC1B,OAAK,OAAO,SAAS,iBAAkB;AACvC,SAAO,SAAS,iBAAiB,WAAW,CAAC,MAAM,KAAK,cAAc,EAAE,EAAE,MAAM;CAChF;CAED,AAAQ,cAAcN,GAAwB;AAG7C,OAAK,EAAE,aAAa;GACnB,MAAM,kBAAkB,KAAK,mBAAmB,OAAO,IAAI,KAAK,qBAAqB,KAAK;GAC1F,MAAM,WAAW,wBAAwB,EAAE;GAC3C,MAAM,WAAW,SAAS,MAAM,gBAAgB,IAAI,oBAAoB,EAAE,IAAI,aAAa,EAAE,SAAS,CAAC,GAAG;AAE1G,OAAI,YAAY,SAAS,SAAS,WAAW,QAAQ,SAAS,SAAS,GACtE;QAAI,SAAS,KAAK,SAAS,KAAK,KAC/B,GAAE,gBAAgB;GAClB;AAEF,mBAAE,QAAQ;EACV;CACD;;;;;;CAOD,WAAWO,qBAA8B,OAAa;AACrD,MAAI,KAAK,WAAY;AACrB,OAAK,aAAa;EAUlB,MAAM,kBACL,KAAK,mBAAmB,OAAO,MAAM,qBAClC,MAAM,KAAK,KAAK,mBAAmB,QAAQ,CAAC,GAC5C,CAAC,GAAG,KAAK,cAAc,QAAQ,EAAE,GAAG,KAAK,gBAAiB;AAC9D,SAAO,gCAAoC,KAAK,CAAC,EAAE,oBAAoB,KAAK,mBAAmB,gBAAgB,CAAC,CAAC,KAAK,MAAO,KAAK,aAAa,MAAO;CACtJ;CAED,kBAAkBC,WAAoC;AACrD,OAAK,eAAe,WAAW,CAAC,IAAI,MAAM,KAAK,cAAc,IAAI,IAAI,EAAE,CAAC;CACxE;CAED,oBAAoBA,WAAoC;AACvD,OAAK,eAAe,WAAW,CAAC,IAAI,MAAM,KAAK,cAAc,OAAO,GAAG,CAAC;CACxE;CAED,yBAAyBA,WAAoC;AAC5D,OAAK,eAAe,WAAW,CAAC,GAAG,MAAM,KAAK,iBAAiB,KAAK,EAAE,CAAC;CACvE;CAED,uBAAuBC,WAA4B;AAClD,OAAK,eAAe,WAAW,CAAC,IAAI,MAAM,KAAK,mBAAmB,IAAI,IAAI,EAAE,CAAC;CAC7E;CAED,yBAAyBA,WAA4B;AACpD,OAAK,eAAe,WAAW,CAAC,IAAI,MAAM,KAAK,mBAAmB,OAAO,GAAG,CAAC;CAC7E;;;;;;;CAQD,AAAQ,eAAeD,WAAoCE,WAAiD;AAC3G,OAAK,MAAM,KAAK,UACf,WAAU,oBAAoB,EAAE,IAAI,MAAM,EAAE,EAAE,EAAE;CAEjD;AACD;AAOM,SAAS,aAAaC,KAAyB,GAAG,MAA2B;AACnF,KAAI,OAAO,KACV,QAAO,KAAK,KAAK,CAAC,MAAM,EAAE,SAAS,IAAI,aAAa,CAAC;AAEtD,QAAO;AACP;MAEYC,aAAyB,IAAI"}