
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { LazyLoaded, assertNotNull, clone, deepEqual, defer, downcast, filterInt, getFromMap, isSameDay, symmetricDifference } from "./dist-CJHwsXKY.js";
import { TutanotaError } from "./dist-Rk9U8Iqn.js";
import { isApp, isDesktop } from "./Env-D5xGlXfw.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { CalendarMethod, EXTERNAL_CALENDAR_SYNC_INTERVAL, FeatureType, OperationType } from "./TutanotaConstants-3bwAESYA.js";
import { LockedError, NotAuthorizedError, NotFoundError, PreconditionFailedError } from "./RestError-D17JEBMr.js";
import { SessionKeyNotFoundError } from "./ErrorUtils-o1-v67Dd.js";
import { ParserError } from "./ParserCombinator-D38ofgFx.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { elementIdPart, getElementId, isSameId, listIdPart, removeTechnicalFields } from "./EntityUtils-RQxXZlcV.js";
import { findAttendeeInAddresses, serializeAlarmInterval } from "./CommonCalendarUtils-DKaO7v1K.js";
import { formatDateWithWeekdayAndTime, formatTime } from "./Formatter-zB15D6XI.js";
import { CalendarEventTypeRef, CalendarEventUpdateTypeRef, CalendarGroupRootTypeRef, FileTypeRef, UserSettingsGroupRootTypeRef, createDefaultAlarmInfo, createGroupSettings } from "./TypeRefs-CR3TLWn0.js";
import { GroupInfoTypeRef, GroupTypeRef, UserAlarmInfoTypeRef, createDateWrapper, createMembershipRemoveData } from "./TypeRefs-BP1jvX9p.js";
import { CalendarEventValidity, assignEventId, checkEventValidity, getTimeZone, hasSourceUrl } from "./CalendarUtils-C6jeYrj9.js";
import { NoopProgressMonitor } from "./ProgressMonitor-HBfOF56H.js";
import { NotificationType } from "./Notifications-DLibQbV7.js";
import { MembershipService } from "./Services-CZFE0084.js";
import { CachingMode } from "./CalendarFacade-CaovxyFN.js";
import { isUpdateFor, isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import { isSharedGroupOwner, loadGroupMembers } from "./GroupUtils-CpT2lvVS.js";
import { locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { EventImportRejectionReason, SyncStatus, parseCalendarStringData, sortOutParsedEvents } from "./ImportExportUtils-B1MoOmZ0.js";
import { UserError } from "./UserError-DfXlMLTl.js";

//#region ../src/common/api/common/utils/ObservableLazyLoaded.ts
var import_stream = __toESM(require_stream(), 1);
var ObservableLazyLoaded = class {
	lazyLoaded;
	stream = (0, import_stream.default)();
	constructor(loadFunction, defaultValue) {
		this.defaultValue = defaultValue;
		this.lazyLoaded = new LazyLoaded(async () => {
			const value = await loadFunction();
			this.stream(value);
			return value;
		}, defaultValue);
		this.stream(defaultValue);
	}
	getAsync() {
		return this.lazyLoaded.getAsync();
	}
	isLoaded() {
		return this.lazyLoaded.isLoaded();
	}
	getLoaded() {
		return this.lazyLoaded.getLoaded();
	}
	/** reset & reload the inner lazyLoaded without an observable default state unless loading fails */
	async reload() {
		try {
			return await this.lazyLoaded.reload();
		} catch (e) {
			this.lazyLoaded.reset();
			this.stream(this.defaultValue);
			return this.defaultValue;
		}
	}
	reset() {
		this.lazyLoaded.reset();
		this.stream(this.defaultValue);
	}
};

//#endregion
//#region ../src/calendar-app/calendar/model/CalendarModel.ts
const TAG = "[CalendarModel]";
function assertEventValidity(event) {
	switch (checkEventValidity(event)) {
		case CalendarEventValidity.InvalidContainsInvalidDate: throw new UserError("invalidDate_msg");
		case CalendarEventValidity.InvalidEndBeforeStart: throw new UserError("startAfterEnd_label");
		case CalendarEventValidity.InvalidPre1970: throw new UserError("pre1970Start_msg");
		case CalendarEventValidity.Valid:
	}
}
var CalendarModel = class {
	/**
	* Map from calendar event element id to the deferred object with a promise of getting CREATE event for this calendar event. We need to do that because
	* entity updates for CalendarEvent and UserAlarmInfo come in different batches and we need to wait for the event when we want to process new alarm.
	*
	* We use the counter to remove the pending request from map when all alarms are processed. We want to do that in case the event gets updated and we need
	* to wait for the new version of the event.
	*/
	pendingAlarmRequests = new Map();
	userAlarmToAlarmInfo = new Map();
	fileIdToSkippedCalendarEventUpdates = new Map();
	readProgressMonitor;
	/**
	* Map from group id to CalendarInfo
	*/
	calendarInfos = new ObservableLazyLoaded(() => {
		const monitor = this.readProgressMonitor.next().value;
		const calendarInfoPromise = this.loadOrCreateCalendarInfo(monitor);
		monitor.completed();
		return calendarInfoPromise;
	}, new Map());
	constructor(notifications, alarmScheduler, eventController, serviceExecutor, logins, progressTracker, entityClient, mailboxModel, calendarFacade, fileController, zone, externalCalendarFacade, deviceConfig, pushService) {
		this.notifications = notifications;
		this.alarmScheduler = alarmScheduler;
		this.serviceExecutor = serviceExecutor;
		this.logins = logins;
		this.progressTracker = progressTracker;
		this.entityClient = entityClient;
		this.mailboxModel = mailboxModel;
		this.calendarFacade = calendarFacade;
		this.fileController = fileController;
		this.zone = zone;
		this.externalCalendarFacade = externalCalendarFacade;
		this.deviceConfig = deviceConfig;
		this.pushService = pushService;
		this.readProgressMonitor = oneShotProgressMonitorGenerator(progressTracker, logins.getUserController());
		eventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId));
	}
	getCalendarInfos() {
		return this.calendarInfos.getAsync();
	}
	getCalendarInfosStream() {
		return this.calendarInfos.stream;
	}
	async createEvent(event, alarmInfos, zone, groupRoot) {
		await this.doCreate(event, zone, groupRoot, alarmInfos);
	}
	/** Update existing event when time did not change */
	async updateEvent(newEvent, newAlarms, zone, groupRoot, existingEvent) {
		if (existingEvent._id == null) throw new Error("Invalid existing event for update: no id");
		if (existingEvent.uid != null && newEvent.uid !== existingEvent.uid) throw new Error("Invalid existing event for update: mismatched uids.");
		if (existingEvent._ownerGroup !== groupRoot._id || newEvent.startTime.getTime() !== existingEvent.startTime.getTime() || await didLongStateChange(newEvent, existingEvent, zone)) {
			await this.doCreate(newEvent, zone, groupRoot, newAlarms, existingEvent);
			return await this.entityClient.load(CalendarEventTypeRef, newEvent._id);
		} else {
			newEvent._ownerGroup = groupRoot._id;
			await this.calendarFacade.updateCalendarEvent(newEvent, newAlarms, existingEvent);
			return newEvent;
		}
	}
	/** Load map from group/groupRoot ID to the calendar info */
	async loadCalendarInfos(progressMonitor) {
		const userController = this.logins.getUserController();
		const notFoundMemberships = [];
		const groupInstances = [];
		for (const membership of userController.getCalendarMemberships()) {
			try {
				const result = await Promise.all([
					this.entityClient.load(CalendarGroupRootTypeRef, membership.group),
					this.entityClient.load(GroupInfoTypeRef, membership.groupInfo),
					this.entityClient.load(GroupTypeRef, membership.group)
				]);
				groupInstances.push(result);
			} catch (e) {
				if (e instanceof NotFoundError) notFoundMemberships.push(membership);
else throw e;
			}
			progressMonitor.workDone(3);
		}
		const calendarInfos = new Map();
		const groupSettings = userController.userSettingsGroupRoot.groupSettings;
		for (const [groupRoot, groupInfo, group] of groupInstances) try {
			const groupMembers = await loadGroupMembers(group, this.entityClient);
			const shared = groupMembers.length > 1;
			const userIsOwner = !shared || isSharedGroupOwner(group, userController.userId);
			const isExternal = hasSourceUrl(groupSettings.find((groupSettings$1) => groupSettings$1.group === group._id));
			calendarInfos.set(groupRoot._id, {
				groupRoot,
				groupInfo,
				group,
				shared,
				userIsOwner,
				isExternal
			});
		} catch (e) {
			if (e instanceof NotAuthorizedError) console.log("NotAuthorizedError when initializing calendar. Calendar has been removed ");
else throw e;
		}
		for (const membership of notFoundMemberships) this.serviceExecutor.delete(MembershipService, createMembershipRemoveData({
			user: userController.userId,
			group: membership.group
		})).catch((e) => console.log("error cleaning up membership for group: ", membership.group));
		return calendarInfos;
	}
	async fetchExternalCalendar(url) {
		if (!this.externalCalendarFacade) throw new Error(`externalCalendarFacade is ${typeof this.externalCalendarFacade} at CalendarModel`);
		const calendarStr = await this.externalCalendarFacade?.fetchExternalCalendar(url);
		return calendarStr ?? "";
	}
	scheduleExternalCalendarSync() {
		setInterval(() => {
			this.syncExternalCalendars().catch((e) => console.error(e.message));
		}, EXTERNAL_CALENDAR_SYNC_INTERVAL);
	}
	async syncExternalCalendars(groupSettings = null, syncInterval = EXTERNAL_CALENDAR_SYNC_INTERVAL, longErrorMessage = false, forceSync = false) {
		if (!this.externalCalendarFacade || !locator.logins.isFullyLoggedIn()) return;
		let existingGroupSettings = groupSettings;
		const userController = this.logins.getUserController();
		const groupRootsPromises = [];
		let calendarGroupRootsList = [];
		for (const membership of userController.getCalendarMemberships()) groupRootsPromises.push(this.entityClient.load(CalendarGroupRootTypeRef, membership.group));
		calendarGroupRootsList = await Promise.all(groupRootsPromises);
		if (!existingGroupSettings) {
			const { groupSettings: gSettings } = await locator.entityClient.load(UserSettingsGroupRootTypeRef, userController.user.userGroup.group);
			existingGroupSettings = gSettings;
		}
		const skippedCalendars = new Map();
		for (const { sourceUrl, group, name } of existingGroupSettings) {
			if (!sourceUrl) continue;
			const lastSyncEntry = this.deviceConfig.getLastExternalCalendarSync().get(group);
			const offset = 1e3;
			const shouldSkipSync = !forceSync && lastSyncEntry?.lastSyncStatus === SyncStatus.Success && lastSyncEntry.lastSuccessfulSync && Date.now() + offset - lastSyncEntry.lastSuccessfulSync < syncInterval;
			if (shouldSkipSync) continue;
			const currentCalendarGroupRoot = calendarGroupRootsList.find((calendarGroupRoot) => isSameId(calendarGroupRoot._id, group)) ?? null;
			if (!currentCalendarGroupRoot) {
				console.error(`Trying to sync a calendar the user isn't subscribed to anymore: ${group}`);
				continue;
			}
			let parsedExternalEvents = [];
			try {
				const externalCalendar = await this.fetchExternalCalendar(sourceUrl);
				parsedExternalEvents = parseCalendarStringData(externalCalendar, getTimeZone()).contents;
			} catch (error) {
				let calendarName = name;
				if (!calendarName) {
					const calendars = await this.getCalendarInfos();
					calendarName = calendars.get(group)?.groupInfo.name;
				}
				skippedCalendars.set(group, {
					calendarName,
					error
				});
				continue;
			}
			const existingEventList = await loadAllEvents(currentCalendarGroupRoot);
			const operationsLog = {
				skipped: [],
				updated: [],
				created: [],
				deleted: []
			};
			/**
			* Sync strategy
			* - Replace duplicates
			* - Add new
			* - Remove rest
			*/
			const { rejectedEvents, eventsForCreation } = sortOutParsedEvents(parsedExternalEvents, existingEventList, currentCalendarGroupRoot, getTimeZone());
			const duplicates = rejectedEvents.get(EventImportRejectionReason.Duplicate) ?? [];
			for (const duplicatedEvent of duplicates) {
				const existingEvent = existingEventList.find((event) => event.uid === duplicatedEvent.uid);
				if (!existingEvent) {
					console.warn("Found a duplicate without an existing event!");
					continue;
				}
				if (this.eventHasSameFields(duplicatedEvent, existingEvent)) {
					operationsLog.skipped.push(duplicatedEvent);
					continue;
				}
				await this.updateEventWithExternal(existingEvent, duplicatedEvent);
				operationsLog.updated.push(duplicatedEvent);
			}
			console.log(TAG, `${operationsLog.skipped.length} events skipped (duplication without changes)`);
			console.log(TAG, `${operationsLog.updated.length} events updated (duplication with changes)`);
			for (const { event } of eventsForCreation) {
				assignEventId(event, getTimeZone(), currentCalendarGroupRoot);
				event._ownerEncSessionKey = null;
				if (event.repeatRule != null) event.repeatRule.excludedDates = event.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date }));
				downcast(event)._permissions = null;
				event._ownerGroup = currentCalendarGroupRoot._id;
				assertEventValidity(event);
				operationsLog.created.push(event);
			}
			await this.calendarFacade.saveImportedCalendarEvents(eventsForCreation, 0);
			console.log(TAG, `${operationsLog.created.length} events created`);
			const eventsToRemove = existingEventList.filter((existingEvent) => !parsedExternalEvents.some((externalEvent) => externalEvent.event.uid === existingEvent.uid));
			for (const event of eventsToRemove) {
				await this.deleteEvent(event).catch((err) => {
					if (err instanceof NotFoundError) return console.log(`Already deleted event`, event);
					throw err;
				});
				operationsLog.deleted.push(event);
			}
			console.log(TAG, `${operationsLog.deleted.length} events removed`);
			this.deviceConfig.updateLastSync(group);
		}
		if (skippedCalendars.size) {
			let errorMessage = lang.get("iCalSync_error") + (longErrorMessage ? "\n\n" : "");
			for (const [group, details] of skippedCalendars.entries()) {
				if (longErrorMessage) errorMessage += `${details.calendarName} - ${details.error.message}\n`;
				this.deviceConfig.updateLastSync(group, SyncStatus.Failed);
			}
			throw new Error(errorMessage);
		}
	}
	eventHasSameFields(a, b) {
		return a.startTime.valueOf() === b.startTime.valueOf() && a.endTime.valueOf() === b.endTime.valueOf() && deepEqual({ ...a.attendees }, { ...b.attendees }) && a.summary === b.summary && a.sequence === b.sequence && a.location === b.location && a.description === b.description && deepEqual(a.organizer, b.organizer) && deepEqual(a.repeatRule, b.repeatRule) && a.recurrenceId?.valueOf() === b.recurrenceId?.valueOf();
	}
	async loadOrCreateCalendarInfo(progressMonitor) {
		const { findFirstPrivateCalendar } = await import("./CalendarUtils-DwR144gS.js");
		const calendarInfos = await this.loadCalendarInfos(progressMonitor);
		if (!this.logins.isInternalUserLoggedIn() || findFirstPrivateCalendar(calendarInfos)) return calendarInfos;
else {
			await this.createCalendar("", null, [], null);
			return await this.loadCalendarInfos(progressMonitor);
		}
	}
	async createCalendar(name, color, alarms, sourceUrl) {
		const { user, group } = await this.calendarFacade.addCalendar(name);
		this.logins.getUserController().user = user;
		const serializedAlarms = alarms.map((alarm) => createDefaultAlarmInfo({ trigger: serializeAlarmInterval(alarm) }));
		if (color != null) {
			const { userSettingsGroupRoot } = this.logins.getUserController();
			const newGroupSettings = createGroupSettings({
				group: group._id,
				color,
				name: null,
				defaultAlarmsList: serializedAlarms,
				sourceUrl
			});
			userSettingsGroupRoot.groupSettings.push(newGroupSettings);
			await this.entityClient.update(userSettingsGroupRoot);
		}
		return group;
	}
	async doCreate(event, zone, groupRoot, alarmInfos, existingEvent) {
		removeTechnicalFields(event);
		const { assignEventId: assignEventId$1 } = await import("./CalendarUtils-DwR144gS.js");
		assignEventId$1(event, zone, groupRoot);
		event._ownerEncSessionKey = null;
		if (event.repeatRule != null) event.repeatRule.excludedDates = event.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date }));
		downcast(event)._permissions = null;
		event._ownerGroup = groupRoot._id;
		return await this.calendarFacade.saveCalendarEvent(event, alarmInfos, existingEvent ?? null);
	}
	async deleteEvent(event) {
		return await this.entityClient.erase(event);
	}
	/**
	* get the "primary" event of a series - the one that contains the repeat rule and is not a repeated or a rescheduled instance.
	*
	* note about recurrenceId in event series https://stackoverflow.com/questions/11456406/recurrence-id-in-icalendar-rfc-5545
	*/
	async resolveCalendarEventProgenitor({ uid }) {
		return (await this.getEventsByUid(assertNotNull(uid, "could not resolve progenitor: no uid")))?.progenitor ?? null;
	}
	async loadAndProcessCalendarUpdates() {
		const { mailboxGroupRoot } = await this.mailboxModel.getUserMailboxDetails();
		const { calendarEventUpdates } = mailboxGroupRoot;
		if (calendarEventUpdates == null) return;
		const invites = await this.entityClient.loadAll(CalendarEventUpdateTypeRef, calendarEventUpdates.list);
		for (const invite of invites) await this.handleCalendarEventUpdate(invite);
	}
	/**
	* Get calendar infos, creating a new calendar info if none exist
	* Not async because we want to return the result directly if it is available when called
	* otherwise we return a promise
	*/
	getCalendarInfosCreateIfNeeded() {
		if (this.calendarInfos.isLoaded() && this.calendarInfos.getLoaded().size > 0) return this.calendarInfos.getLoaded();
		return Promise.resolve().then(async () => {
			const calendars = await this.calendarInfos.getAsync();
			if (calendars.size > 0) return calendars;
else {
				await this.createCalendar("", null, [], null);
				return this.calendarInfos.reload();
			}
		});
	}
	async getCalendarDataForUpdate(fileId) {
		try {
			const file = await this.entityClient.load(FileTypeRef, fileId);
			const dataFile = await this.fileController.getAsDataFile(file);
			const { parseCalendarFile } = await import("./CalendarImporter-zjX-8iQD.js");
			return await parseCalendarFile(dataFile);
		} catch (e) {
			if (e instanceof SessionKeyNotFoundError) throw new NoOwnerEncSessionKeyForCalendarEventError("no owner enc session key found on the calendar data's file");
			if (e instanceof ParserError || e instanceof NotFoundError) {
				console.warn(TAG, "could not get calendar update data", e);
				return null;
			}
			throw e;
		}
	}
	async handleCalendarEventUpdate(update) {
		try {
			const parsedCalendarData = await this.getCalendarDataForUpdate(update.file);
			if (parsedCalendarData != null) await this.processCalendarData(update.sender, parsedCalendarData);
		} catch (e) {
			if (e instanceof NotAuthorizedError) {
				console.warn(TAG, "could not process calendar update: not authorized", e);
				return;
			} else if (e instanceof PreconditionFailedError) {
				console.warn(TAG, "could not process calendar update: precondition failed", e);
				return;
			} else if (e instanceof LockedError) {
				console.warn(TAG, "could not process calendar update: locked", e);
				return;
			} else if (e instanceof NotFoundError) console.warn(TAG, "could not process calendar update: not found", e);
else if (e instanceof NoOwnerEncSessionKeyForCalendarEventError) {
				this.fileIdToSkippedCalendarEventUpdates.set(elementIdPart(update.file), update);
				console.warn(TAG, `could not process calendar update: ${e.message}`, e);
				return;
			} else {
				console.warn(TAG, "could not process calendar update:", e);
				await this.eraseUpdate(update);
				throw e;
			}
		}
		await this.eraseUpdate(update);
	}
	/**
	* try to delete a calendar update from the server, ignoring errors
	* @param update the update to erase
	* @private
	*/
	async eraseUpdate(update) {
		try {
			await this.entityClient.erase(update);
		} catch (e) {
			console.log(TAG, "failed to delete update:", e.name);
		}
	}
	/** whether the operation could be performed or not */
	async deleteEventsByUid(uid) {
		const entry = await this.calendarFacade.getEventsByUid(uid);
		if (entry == null) {
			console.log("could not find an uid index entry to delete event");
			return;
		}
		for (const e of entry.alteredInstances) await this.deleteEvent(e);
		if (entry.progenitor) await this.deleteEvent(entry.progenitor);
	}
	/** process a calendar update retrieved from the server automatically. will not apply updates to event series that do not
	*  exist on the server yet (that's being done by calling processCalendarEventMessage manually)
	* public for testing */
	async processCalendarData(sender, calendarData) {
		if (calendarData.contents.length === 0) {
			console.log(TAG, `Calendar update with no events, ignoring`);
			return;
		}
		if (calendarData.contents[0].event.uid == null) {
			console.log(TAG, "invalid event update without UID, ignoring.");
			return;
		}
		const dbEvents = await this.calendarFacade.getEventsByUid(calendarData.contents[0].event.uid, CachingMode.Bypass);
		if (dbEvents == null) {
			console.log(TAG, "received event update for event that has not been saved to the server, ignoring.");
			return;
		}
		const method = calendarData.method;
		for (const content of calendarData.contents) {
			const updateAlarms = content.alarms;
			const updateEvent = content.event;
			await this.processCalendarEventMessage(sender, method, updateEvent, updateAlarms, dbEvents);
		}
	}
	/**
	* Processing calendar update - bring events in calendar up-to-date with ical data sent via email.
	* calendar data are currently processed for
	* - REQUEST: here we have two cases:
	*     - there is an existing event: we apply the update to that event and do the necessary changes to the other parts of the series that may already exist
	*     - there is no existing event: create the event as received, and do the necessary changes to the other parts of the series that may already exist
	* - REPLY: update attendee status,
	* - CANCEL: we delete existing event instance
	*
	* @param sender
	* @param method
	* @param updateEvent the actual instance that needs to be updated
	* @param updateAlarms
	* @param target either the existing event to update or the calendar group Id to create the event in in case of a new event.
	*/
	async processCalendarEventMessage(sender, method, updateEvent, updateAlarms, target) {
		const updateEventTime = updateEvent.recurrenceId?.getTime();
		const targetDbEvent = updateEventTime == null ? target.progenitor : target.alteredInstances.find((e) => e.recurrenceId.getTime() === updateEventTime);
		if (targetDbEvent == null) if (method === CalendarMethod.REQUEST) return await this.processCalendarAccept(target, updateEvent, updateAlarms);
else if (target.progenitor?.repeatRule != null && updateEvent.recurrenceId != null && method === CalendarMethod.CANCEL) {
			target.alteredInstances.push(updateEvent);
			return await this.processCalendarUpdate(target, target.progenitor, target.progenitor);
		} else {
			console.log(TAG, `got something that's not a REQUEST for nonexistent server event on uid:`, method);
			return;
		}
		const sentByOrganizer = targetDbEvent.organizer != null && targetDbEvent.organizer.address === sender;
		if (method === CalendarMethod.REPLY) return this.processCalendarReply(sender, targetDbEvent, updateEvent);
else if (sentByOrganizer && method === CalendarMethod.REQUEST) return await this.processCalendarUpdate(target, targetDbEvent, updateEvent);
else if (sentByOrganizer && method === CalendarMethod.CANCEL) return await this.processCalendarCancellation(targetDbEvent);
else console.log(TAG, `${method} update sent not by organizer, ignoring.`);
	}
	/** process either a request for an existing progenitor or an existing altered instance.
	* @param dbTarget the uid entry containing the other events that are known to us that belong to this event series.
	* @param dbEvent the version of updateEvent stored on the server. must be identical to dbTarget.progenitor or one of dbTarget.alteredInstances
	* @param updateEvent the event that contains the new version of dbEvent. */
	async processCalendarUpdate(dbTarget, dbEvent, updateEvent) {
		console.log(TAG, "processing request for existing event instance");
		const { repeatRuleWithExcludedAlteredInstances } = await import("./CalendarEventWhenModel-snhU8z-C.js");
		if (filterInt(dbEvent.sequence) > filterInt(updateEvent.sequence)) {
			console.log(TAG, "got update for outdated event version, ignoring.");
			return;
		}
		if (updateEvent.recurrenceId == null && updateEvent.repeatRule != null) updateEvent.repeatRule = repeatRuleWithExcludedAlteredInstances(updateEvent, dbTarget.alteredInstances.map((r) => r.recurrenceId), this.zone);
		dbTarget.progenitor = await this.updateEventWithExternal(dbEvent, updateEvent);
	}
	/**
	* do not call this for anything but a REQUEST
	* @param dbTarget the progenitor that must have a repeat rule and an exclusion for this event to be accepted, the known altered instances and the ownergroup.
	* @param updateEvent the event to create
	* @param alarms alarms to set up for this user/event
	*/
	async processCalendarAccept(dbTarget, updateEvent, alarms) {
		console.log(TAG, "processing new instance request");
		const { repeatRuleWithExcludedAlteredInstances } = await import("./CalendarEventWhenModel-snhU8z-C.js");
		if (updateEvent.recurrenceId != null && dbTarget.progenitor != null && dbTarget.progenitor.repeatRule != null) {
			const updatedProgenitor = clone(dbTarget.progenitor);
			updatedProgenitor.repeatRule = repeatRuleWithExcludedAlteredInstances(updatedProgenitor, [updateEvent.recurrenceId], this.zone);
			dbTarget.progenitor = await this.doUpdateEvent(dbTarget.progenitor, updatedProgenitor);
		} else if (updateEvent.recurrenceId == null && updateEvent.repeatRule != null && dbTarget.alteredInstances.length > 0) updateEvent.repeatRule = repeatRuleWithExcludedAlteredInstances(updateEvent, dbTarget.alteredInstances.map((r) => r.recurrenceId), this.zone);
		let calendarGroupRoot;
		try {
			calendarGroupRoot = await this.entityClient.load(CalendarGroupRootTypeRef, dbTarget.ownerGroup);
		} catch (e) {
			if (!(e instanceof NotFoundError) && !(e instanceof NotAuthorizedError)) throw e;
			console.log(TAG, "tried to create new progenitor or got new altered instance for progenitor in nonexistent/inaccessible calendar, ignoring");
			return;
		}
		return await this.doCreate(updateEvent, "", calendarGroupRoot, alarms);
	}
	/** Someone replied whether they attend an event or not. this MUST be applied to all instances in our
	* model since we keep attendee lists in sync for now. */
	async processCalendarReply(sender, dbEvent, updateEvent) {
		console.log("processing calendar reply");
		const replyAttendee = findAttendeeInAddresses(updateEvent.attendees, [sender]);
		if (replyAttendee == null) {
			console.log(TAG, "Sender is not among attendees, ignoring", replyAttendee);
			return;
		}
		const newEvent = clone(dbEvent);
		const dbAttendee = findAttendeeInAddresses(newEvent.attendees, [replyAttendee.address.address]);
		if (dbAttendee == null) {
			console.log(TAG, "attendee was not found", dbEvent._id, replyAttendee);
			return;
		}
		dbAttendee.status = replyAttendee.status;
		await this.doUpdateEvent(dbEvent, newEvent);
	}
	/** handle an event cancellation - either the whole series (progenitor got cancelled)
	* or the altered occurrence. */
	async processCalendarCancellation(dbEvent) {
		console.log(TAG, "processing cancellation");
		if (dbEvent.recurrenceId == null && dbEvent.uid != null) return await this.deleteEventsByUid(dbEvent.uid);
else return await this.entityClient.erase(dbEvent);
	}
	/**
	* Update {@param dbEvent} stored on the server with {@param icsEvent} from the ics file.
	*/
	async updateEventWithExternal(dbEvent, icsEvent) {
		const newEvent = clone(dbEvent);
		newEvent.startTime = icsEvent.startTime;
		newEvent.endTime = icsEvent.endTime;
		newEvent.attendees = icsEvent.attendees;
		newEvent.summary = icsEvent.summary;
		newEvent.sequence = icsEvent.sequence;
		newEvent.location = icsEvent.location;
		newEvent.description = icsEvent.description;
		newEvent.organizer = icsEvent.organizer;
		newEvent.repeatRule = icsEvent.repeatRule;
		newEvent.recurrenceId = icsEvent.recurrenceId;
		return await this.doUpdateEvent(dbEvent, newEvent);
	}
	async doUpdateEvent(dbEvent, newEvent) {
		const [alarms, groupRoot] = await Promise.all([this.loadAlarms(dbEvent.alarmInfos, this.logins.getUserController().user), this.entityClient.load(CalendarGroupRootTypeRef, assertNotNull(dbEvent._ownerGroup))]);
		const alarmInfos = alarms.map((a) => a.alarmInfo);
		return await this.updateEvent(newEvent, alarmInfos, "", groupRoot, dbEvent);
	}
	async init() {
		await this.scheduleAlarmsLocally();
		await this.loadAndProcessCalendarUpdates();
	}
	async scheduleAlarmsLocally() {
		if (!this.localAlarmsEnabled()) return;
		const pushIdentifier = this.pushService?.getLoadedPushIdentifier();
		if (pushIdentifier && pushIdentifier.disabled) return console.log("Push identifier disabled. Skipping alarm schedule");
		const eventsWithInfos = await this.calendarFacade.loadAlarmEvents();
		const scheduler = await this.alarmScheduler();
		for (let { event, userAlarmInfos } of eventsWithInfos) for (let userAlarmInfo of userAlarmInfos) this.scheduleUserAlarmInfo(event, userAlarmInfo, scheduler);
	}
	async loadAlarms(alarmInfos, user) {
		const { alarmInfoList } = user;
		if (alarmInfoList == null) return [];
		const ids = alarmInfos.filter((alarmInfoId) => isSameId(listIdPart(alarmInfoId), alarmInfoList.alarms));
		if (ids.length === 0) return [];
		return this.entityClient.loadMultiple(UserAlarmInfoTypeRef, listIdPart(ids[0]), ids.map(elementIdPart));
	}
	async deleteCalendar(calendar) {
		await this.calendarFacade.deleteCalendar(calendar.groupRoot._id);
		this.deviceConfig.removeLastSync(calendar.group._id);
	}
	async getEventsByUid(uid) {
		return this.calendarFacade.getEventsByUid(uid);
	}
	async entityEventsReceived(updates, eventOwnerGroupId) {
		const calendarInfos = await this.calendarInfos.getAsync();
		const alarmEventsToProcess = [];
		for (const entityEventData of updates) if (isUpdateForTypeRef(UserAlarmInfoTypeRef, entityEventData) && !isApp()) {
			if (entityEventData.operation === OperationType.CREATE) try {
				const userAlarmInfo = await this.entityClient.load(UserAlarmInfoTypeRef, [entityEventData.instanceListId, entityEventData.instanceId]);
				alarmEventsToProcess.push(userAlarmInfo);
				const deferredEvent = this.getPendingAlarmRequest(userAlarmInfo.alarmInfo.calendarRef.elementId);
				deferredEvent.pendingAlarmCounter++;
			} catch (e) {
				if (e instanceof NotFoundError) console.log(TAG, e, "Event or alarm were not found: ", entityEventData, e);
else throw e;
			}
else if (entityEventData.operation === OperationType.DELETE && !isApp()) await this.cancelUserAlarmInfo(entityEventData.instanceId);
		} else if (isUpdateForTypeRef(CalendarEventTypeRef, entityEventData)) {
			if (entityEventData.operation === OperationType.CREATE || entityEventData.operation === OperationType.UPDATE) {
				const deferredEvent = this.getPendingAlarmRequest(entityEventData.instanceId);
				deferredEvent.deferred.resolve(undefined);
			}
		} else if (isUpdateForTypeRef(CalendarEventUpdateTypeRef, entityEventData) && entityEventData.operation === OperationType.CREATE) try {
			const invite = await this.entityClient.load(CalendarEventUpdateTypeRef, [entityEventData.instanceListId, entityEventData.instanceId]);
			await this.handleCalendarEventUpdate(invite);
		} catch (e) {
			if (e instanceof NotFoundError) console.log(TAG, "invite not found", [entityEventData.instanceListId, entityEventData.instanceId], e);
else throw e;
		}
else if (isUpdateForTypeRef(FileTypeRef, entityEventData)) {
			const skippedCalendarEventUpdate = this.fileIdToSkippedCalendarEventUpdates.get(entityEventData.instanceId);
			if (skippedCalendarEventUpdate) try {
				await this.handleCalendarEventUpdate(skippedCalendarEventUpdate);
			} catch (e) {
				if (e instanceof NotFoundError) console.log(TAG, "invite not found", [entityEventData.instanceListId, entityEventData.instanceId], e);
else throw e;
			} finally {
				this.fileIdToSkippedCalendarEventUpdates.delete(entityEventData.instanceId);
			}
		} else if (this.logins.getUserController().isUpdateForLoggedInUserInstance(entityEventData, eventOwnerGroupId)) {
			const calendarMemberships = this.logins.getUserController().getCalendarMemberships();
			const oldGroupIds = new Set(calendarInfos.keys());
			const newGroupIds = new Set(calendarMemberships.map((m) => m.group));
			const diff = symmetricDifference(oldGroupIds, newGroupIds);
			if (diff.size !== 0) this.calendarInfos.reload();
		} else if (isUpdateForTypeRef(GroupInfoTypeRef, entityEventData)) {
			for (const { groupInfo } of calendarInfos.values()) if (isUpdateFor(groupInfo, entityEventData)) {
				this.calendarInfos.reload();
				break;
			}
		}
		if (!isApp()) {
			const pushIdentifier = this.pushService?.getLoadedPushIdentifier();
			if (pushIdentifier && pushIdentifier.disabled) return console.log("Push identifier disabled. Skipping alarm schedule");
		}
		for (const userAlarmInfo of alarmEventsToProcess) {
			const { listId, elementId } = userAlarmInfo.alarmInfo.calendarRef;
			const deferredEvent = this.getPendingAlarmRequest(elementId);
			deferredEvent.deferred.promise = deferredEvent.deferred.promise.then(async () => {
				deferredEvent.pendingAlarmCounter--;
				if (deferredEvent.pendingAlarmCounter === 0) this.pendingAlarmRequests.delete(elementId);
				const calendarEvent = await this.entityClient.load(CalendarEventTypeRef, [listId, elementId]);
				const scheduler = await this.alarmScheduler();
				try {
					this.scheduleUserAlarmInfo(calendarEvent, userAlarmInfo, scheduler);
				} catch (e) {
					if (e instanceof NotFoundError) console.log(TAG, "event not found", [listId, elementId]);
else throw e;
				}
			});
		}
	}
	getPendingAlarmRequest(elementId) {
		return getFromMap(this.pendingAlarmRequests, elementId, () => ({
			pendingAlarmCounter: 0,
			deferred: defer()
		}));
	}
	localAlarmsEnabled() {
		return !isApp() && !isDesktop() && this.logins.isInternalUserLoggedIn() && !this.logins.isEnabled(FeatureType.DisableCalendar);
	}
	scheduleUserAlarmInfo(event, userAlarmInfo, scheduler) {
		this.userAlarmToAlarmInfo.set(getElementId(userAlarmInfo), userAlarmInfo.alarmInfo.alarmIdentifier);
		scheduler.scheduleAlarm(event, userAlarmInfo.alarmInfo, event.repeatRule, (eventTime, summary) => {
			const { title, body } = formatNotificationForDisplay(eventTime, summary);
			this.notifications.showNotification(NotificationType.Calendar, title, { body }, () => mithril_default.route.set("/calendar"));
		});
	}
	async cancelUserAlarmInfo(userAlarmInfoId) {
		const identifier = this.userAlarmToAlarmInfo.get(userAlarmInfoId);
		if (identifier) {
			const alarmScheduler = await this.alarmScheduler();
			alarmScheduler.cancelAlarm(identifier);
		}
	}
	getFileIdToSkippedCalendarEventUpdates() {
		return this.fileIdToSkippedCalendarEventUpdates;
	}
	getBirthdayEventTitle(contactName) {
		return lang.get("birthdayEvent_title", { "{name}": contactName });
	}
	getAgeString(age) {
		return lang.get("birthdayEventAge_title", { "{age}": age });
	}
};
/** return false when the given events (representing the new and old version of the same event) are both long events
* or both short events, true otherwise */
async function didLongStateChange(newEvent, existingEvent, zone) {
	const { isLongEvent } = await import("./CalendarUtils-DwR144gS.js");
	return isLongEvent(newEvent, zone) !== isLongEvent(existingEvent, zone);
}
var NoOwnerEncSessionKeyForCalendarEventError = class extends TutanotaError {
	constructor(message) {
		super("NoOwnerEncSessionKeyForCalendarEventError", message);
	}
};
/**
* yield the given monitor one time and then switch to noOp monitors forever
*/
function* oneShotProgressMonitorGenerator(progressTracker, userController) {
	const workPerCalendar = 3;
	const totalWork = userController.getCalendarMemberships().length * workPerCalendar;
	const realMonitorId = progressTracker.registerMonitorSync(totalWork);
	const realMonitor = assertNotNull(progressTracker.getMonitor(realMonitorId));
	yield realMonitor;
	while (true) yield new NoopProgressMonitor();
}
function formatNotificationForDisplay(eventTime, summary) {
	let dateString;
	if (isSameDay(eventTime, new Date())) dateString = formatTime(eventTime);
else dateString = formatDateWithWeekdayAndTime(eventTime);
	const body = `${dateString} ${summary}`;
	return {
		body,
		title: body
	};
}
async function loadAllEvents(groupRoot) {
	return Promise.all([locator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.longEvents), locator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.shortEvents)]).then((results) => results.flat());
}

//#endregion
export { CalendarModel, assertEventValidity, formatNotificationForDisplay };
//# sourceMappingURL=CalendarModel-DK762b35.js.map