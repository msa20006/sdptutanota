
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, freshVersioned, getFirstOrThrow, isNotEmpty, neverNull } from "./dist-CJHwsXKY.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { assertWorkerOrNode } from "./Env-D5xGlXfw.js";
import { CounterType, GroupType, PublicKeyIdentifierType } from "./TutanotaConstants-3bwAESYA.js";
import { createCreateMailGroupData, createDeleteGroupData, createInternalGroupData, createUserAreaGroupData, createUserAreaGroupDeleteData, createUserAreaGroupPostData } from "./TypeRefs-CR3TLWn0.js";
import { AdministratedGroupTypeRef, CustomerTypeRef, GroupInfoTypeRef, GroupTypeRef, UserTypeRef, createLocalAdminGroupReplacementData, createLocalAdminRemovalPostIn, createMembershipAddData, createMembershipRemoveData } from "./TypeRefs-BP1jvX9p.js";
import { LocalAdminRemovalService, MembershipService } from "./Services-CZFE0084.js";
import { CalendarService, ContactListGroupService, MailGroupService, TemplateGroupService } from "./Services-DCx-CeM7.js";
import { isGlobalAdmin } from "./UserUtils-C4O25CeW.js";
import { encryptKeyWithVersionedKey, encryptString } from "./CryptoWrapper-BTtEczdP.js";

//#region ../src/common/api/worker/facades/lazy/GroupManagementFacade.ts
assertWorkerOrNode();
var GroupManagementFacade = class {
	constructor(userFacade, counters, entityClient, serviceExecutor, pqFacade, keyLoaderFacade, cacheManagementFacade, asymmetricCryptoFacade, cryptoWrapper) {
		this.userFacade = userFacade;
		this.counters = counters;
		this.entityClient = entityClient;
		this.serviceExecutor = serviceExecutor;
		this.pqFacade = pqFacade;
		this.keyLoaderFacade = keyLoaderFacade;
		this.cacheManagementFacade = cacheManagementFacade;
		this.asymmetricCryptoFacade = asymmetricCryptoFacade;
		this.cryptoWrapper = cryptoWrapper;
	}
	async readUsedSharedMailGroupStorage(group) {
		return this.counters.readCounterValue(CounterType.UserStorageLegacy, neverNull(group.customer), group._id);
	}
	async createMailGroup(name, mailAddress) {
		const adminGroupIds = this.userFacade.getGroupIds(GroupType.Admin);
		const adminGroupId = getFirstOrThrow(adminGroupIds);
		let adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		let customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(this.userFacade.getGroupId(GroupType.Customer));
		let mailGroupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey());
		let mailGroupInfoSessionKey = this.cryptoWrapper.aes256RandomKey();
		let mailboxSessionKey = this.cryptoWrapper.aes256RandomKey();
		const keyPair = await this.pqFacade.generateKeyPairs();
		const mailGroupData = this.generateInternalGroupData(keyPair, mailGroupKey.object, mailGroupInfoSessionKey, adminGroupId, adminGroupKey, customerGroupKey);
		const mailEncMailboxSessionKey = encryptKeyWithVersionedKey(mailGroupKey, mailboxSessionKey);
		const data = createCreateMailGroupData({
			mailAddress,
			encryptedName: encryptString(mailGroupInfoSessionKey, name),
			mailEncMailboxSessionKey: mailEncMailboxSessionKey.key,
			groupData: mailGroupData
		});
		await this.serviceExecutor.post(MailGroupService, data);
	}
	/**
	* Generates keys for the new group and prepares the group data object to create the group.
	*
	* @param name Name of the group
	*/
	async generateUserAreaGroupData(name) {
		const userGroup = await this.entityClient.load(GroupTypeRef, this.userFacade.getUserGroupId());
		const adminGroupId = neverNull(userGroup.admin);
		let adminGroupKey = null;
		if (this.userFacade.getAllGroupIds().indexOf(adminGroupId) !== -1) adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		const customerGroupId = this.userFacade.getGroupId(GroupType.Customer);
		const customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(customerGroupId);
		const userGroupKey = this.userFacade.getCurrentUserGroupKey();
		const groupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey());
		const groupRootSessionKey = this.cryptoWrapper.aes256RandomKey();
		const groupInfoSessionKey = this.cryptoWrapper.aes256RandomKey();
		const userEncGroupKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object);
		const adminEncGroupKey = adminGroupKey ? encryptKeyWithVersionedKey(adminGroupKey, groupKey.object) : null;
		const customerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(customerGroupKey, groupInfoSessionKey);
		const groupEncGroupRootSessionKey = encryptKeyWithVersionedKey(groupKey, groupRootSessionKey);
		return createUserAreaGroupData({
			groupEncGroupRootSessionKey: groupEncGroupRootSessionKey.key,
			customerEncGroupInfoSessionKey: customerEncGroupInfoSessionKey.key,
			userEncGroupKey: userEncGroupKey.key,
			groupInfoEncName: encryptString(groupInfoSessionKey, name),
			adminEncGroupKey: adminEncGroupKey?.key ?? null,
			adminGroup: adminGroupId,
			customerKeyVersion: customerEncGroupInfoSessionKey.encryptingKeyVersion.toString(),
			userKeyVersion: userGroupKey.version.toString(),
			adminKeyVersion: adminEncGroupKey?.encryptingKeyVersion.toString() ?? null
		});
	}
	async createCalendar(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const postData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(CalendarService, postData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		const group = await this.entityClient.load(GroupTypeRef, postGroupData.group);
		const user = await this.cacheManagementFacade.reloadUser();
		return {
			user,
			group
		};
	}
	async createTemplateGroup(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const serviceData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(TemplateGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		await this.cacheManagementFacade.reloadUser();
		return postGroupData.group;
	}
	async createContactListGroup(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const serviceData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(ContactListGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		const group = await this.entityClient.load(GroupTypeRef, postGroupData.group);
		await this.cacheManagementFacade.reloadUser();
		return group;
	}
	async deleteContactListGroup(groupRoot) {
		const serviceData = createUserAreaGroupDeleteData({ group: groupRoot._id });
		await this.serviceExecutor.delete(ContactListGroupService, serviceData);
	}
	/**
	* Assemble the data transfer type to create a new internal group on the server.
	* The group key version is not needed because it is always zero.
	*/
	generateInternalGroupData(keyPair, groupKey, groupInfoSessionKey, adminGroupId, adminGroupKey, ownerGroupKey) {
		const adminEncGroupKey = encryptKeyWithVersionedKey(adminGroupKey, groupKey);
		const ownerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(ownerGroupKey, groupInfoSessionKey);
		return createInternalGroupData({
			pubRsaKey: null,
			groupEncPrivRsaKey: null,
			pubEccKey: keyPair.eccKeyPair.publicKey,
			groupEncPrivEccKey: this.cryptoWrapper.encryptEccKey(groupKey, keyPair.eccKeyPair.privateKey),
			pubKyberKey: this.cryptoWrapper.kyberPublicKeyToBytes(keyPair.kyberKeyPair.publicKey),
			groupEncPrivKyberKey: this.cryptoWrapper.encryptKyberKey(groupKey, keyPair.kyberKeyPair.privateKey),
			adminGroup: adminGroupId,
			adminEncGroupKey: adminEncGroupKey.key,
			ownerEncGroupInfoSessionKey: ownerEncGroupInfoSessionKey.key,
			adminKeyVersion: adminEncGroupKey.encryptingKeyVersion.toString(),
			ownerKeyVersion: ownerEncGroupInfoSessionKey.encryptingKeyVersion.toString()
		});
	}
	async addUserToGroup(user, groupId) {
		const userGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(user.userGroup.group);
		const groupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId);
		const symEncGKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object);
		const data = createMembershipAddData({
			user: user._id,
			group: groupId,
			symEncGKey: symEncGKey.key,
			groupKeyVersion: String(groupKey.version),
			symKeyVersion: symEncGKey.encryptingKeyVersion.toString()
		});
		await this.serviceExecutor.post(MembershipService, data);
	}
	async removeUserFromGroup(userId, groupId) {
		const data = createMembershipRemoveData({
			user: userId,
			group: groupId
		});
		await this.serviceExecutor.delete(MembershipService, data);
	}
	async deactivateGroup(group, restore) {
		const data = createDeleteGroupData({
			group: group._id,
			restore
		});
		if (group.type === GroupType.Mail) await this.serviceExecutor.delete(MailGroupService, data);
else throw new Error("invalid group type for deactivation");
	}
	async getGroupKeyViaUser(groupId, version, viaUser) {
		const currentGroupKey = await this.getCurrentGroupKeyViaUser(groupId, viaUser);
		return this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey);
	}
	/**
	* Get a group key for any group we are admin and know some member of.
	*
	* Unlike {@link getCurrentGroupKeyViaAdminEncGKey} this should work for any group because we will actually go a "long" route of decrypting userGroupKey of the
	* member and decrypting group key with that.
	*/
	async getCurrentGroupKeyViaUser(groupId, viaUser) {
		const user = await this.entityClient.load(UserTypeRef, viaUser);
		const membership = user.memberships.find((m) => m.group === groupId);
		if (membership == null) throw new Error(`User doesn't have this group membership! User: ${viaUser} groupId: ${groupId}`);
		const requiredUserGroupKeyVersion = membership.symKeyVersion;
		const requiredUserGroupKey = await this.getGroupKeyViaAdminEncGKey(user.userGroup.group, Number(requiredUserGroupKeyVersion));
		const key = this.cryptoWrapper.decryptKey(requiredUserGroupKey, membership.symEncGKey);
		const version = Number(membership.groupKeyVersion);
		return {
			object: key,
			version
		};
	}
	async getGroupKeyViaAdminEncGKey(groupId, version) {
		if (this.userFacade.hasGroup(groupId)) return this.keyLoaderFacade.loadSymGroupKey(groupId, version);
else {
			const currentGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId);
			return this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey);
		}
	}
	/**
	* @returns true if the group currently has an adminEncGKey. This may be an asymmetrically encrypted one.
	*/
	hasAdminEncGKey(group) {
		return group.adminGroupEncGKey != null && group.adminGroupEncGKey.length !== 0 || group.pubAdminGroupEncGKey != null;
	}
	/**
	* Get a group key for certain group types.
	*
	* Some groups (e.g. user groups or shared mailboxes) have adminGroupEncGKey set on creation. For those groups we can fairly easily get a group key without
	* decrypting userGroupKey of some member of that group.
	*/
	async getCurrentGroupKeyViaAdminEncGKey(groupId) {
		if (this.userFacade.hasGroup(groupId)) return this.keyLoaderFacade.getCurrentSymGroupKey(groupId);
else {
			const group = await this.cacheManagementFacade.reloadGroup(groupId);
			if (!this.hasAdminEncGKey(group)) throw new ProgrammingError("Group doesn't have adminGroupEncGKey, you can't get group key this way");
			if (!(group.admin && this.userFacade.hasGroup(group.admin))) throw new Error(`The user is not a member of the admin group ${group.admin} when trying to get the group key for group ${groupId}`);
			const requiredAdminKeyVersion = Number(group.adminGroupKeyVersion ?? 0);
			if (group.adminGroupEncGKey != null) return await this.decryptViaSymmetricAdminGKey(group, requiredAdminKeyVersion);
else return await this.decryptViaAsymmetricAdminGKey(group, requiredAdminKeyVersion);
		}
	}
	async decryptViaSymmetricAdminGKey(group, requiredAdminKeyVersion) {
		const requiredAdminGroupKey = await this.keyLoaderFacade.loadSymGroupKey(assertNotNull(group.admin), requiredAdminKeyVersion);
		const decryptedKey = this.cryptoWrapper.decryptKey(requiredAdminGroupKey, assertNotNull(group.adminGroupEncGKey));
		return {
			object: decryptedKey,
			version: Number(group.groupKeyVersion)
		};
	}
	async decryptViaAsymmetricAdminGKey(group, requiredAdminKeyVersion) {
		const requiredAdminGroupKeyPair = await this.keyLoaderFacade.loadKeypair(assertNotNull(group.admin), requiredAdminKeyVersion);
		const pubEncKeyData = assertNotNull(group.pubAdminGroupEncGKey);
		const decryptedKey = await this.asymmetricCryptoFacade.decryptSymKeyWithKeyPairAndAuthenticate(requiredAdminGroupKeyPair, pubEncKeyData, {
			identifier: group._id,
			identifierType: PublicKeyIdentifierType.GROUP_ID
		});
		return {
			object: decryptedKey.decryptedAesKey,
			version: Number(group.groupKeyVersion)
		};
	}
	/**
	* Context: removal of local admins
	* Problem: local admins encrypted the user group key of their users with their admin group key but global admin can't
	* decrypt these with their admin group key.
	* We want the global admin to still be able to decrypt user data.
	*
	* This function will decrypt the user group key with the local admin group key and then encrypt it with the global admin group key
	* Please note that this function is free of side effects, it only returns a new reference of the newly modified group.
	*
	* @param globalAdminGroupKey the key of the global admin that will encrypt the user group key
	* @param localAdminGroupKey the key of the local admin that was used to encrypt the user group key and will be used to decrypt the user group key
	* @param userGroup the user group that needs its adminEncGroupKey to be replaced
	*/
	async replaceLocalAdminEncGroupKeyWithGlobalAdminEncGroupKey(globalAdminGroupKey, localAdminGroupKey, userGroup) {
		const localAdminEncUserGroupKey = assertNotNull(userGroup.adminGroupEncGKey);
		const decryptedUserGroupKey = this.cryptoWrapper.decryptKey(localAdminGroupKey, localAdminEncUserGroupKey);
		const globalAdminEncUserGroupKey = this.cryptoWrapper.encryptKey(globalAdminGroupKey.object, decryptedUserGroupKey);
		const groupUpdate = createLocalAdminGroupReplacementData({
			adminGroupKeyVersion: String(globalAdminGroupKey.version),
			adminGroupEncGKey: globalAdminEncUserGroupKey,
			groupId: userGroup._id,
			groupKeyVersion: userGroup.groupKeyVersion
		});
		return groupUpdate;
	}
	/**
	* Since local admins won't be supported anymore and will be removed we need to let the
	* global admin access the locally administrated group data.
	* As its name suggest this function migrate the users administrated by the local admins
	* to the global admin of the customer so that the global admin can have direct
	* encryption and decryption of its users group keys.
	*/
	async migrateLocalAdminsToGlobalAdmins() {
		const user = this.userFacade.getLoggedInUser();
		if (!isGlobalAdmin(user)) return;
		const customer = await this.entityClient.load(CustomerTypeRef, assertNotNull(user.customer));
		const teamGroupInfos = await this.entityClient.loadAll(GroupInfoTypeRef, customer.teamGroups);
		const localAdminGroupInfos = teamGroupInfos.filter((group) => group.groupType === GroupType.LocalAdmin);
		const adminGroupId = customer.adminGroup;
		const adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		const postIn = createLocalAdminRemovalPostIn({ groupUpdates: [] });
		for (let localAdminGroupInfo of localAdminGroupInfos) {
			const localAdminGroup = await this.entityClient.load(GroupTypeRef, localAdminGroupInfo.group);
			const administratedGroupsListId = localAdminGroup.administratedGroups?.items;
			if (administratedGroupsListId == null) return null;
			const administratedGroups = await this.entityClient.loadAll(AdministratedGroupTypeRef, administratedGroupsListId);
			const thisLocalAdminGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(localAdminGroup._id);
			for (let ag of administratedGroups) {
				const thisRelatedGroupInfo = await this.entityClient.load(GroupInfoTypeRef, ag.groupInfo);
				const thisRelatedGroup = await this.entityClient.load(GroupTypeRef, thisRelatedGroupInfo.group);
				const groupUpdate = await this.replaceLocalAdminEncGroupKeyWithGlobalAdminEncGroupKey(adminGroupKey, thisLocalAdminGroupKey.object, thisRelatedGroup);
				postIn.groupUpdates.push(groupUpdate);
			}
		}
		if (isNotEmpty(postIn.groupUpdates)) await this.serviceExecutor.post(LocalAdminRemovalService, postIn);
	}
};

//#endregion
export { GroupManagementFacade };
//# sourceMappingURL=GroupManagementFacade-Dn8D-o9X.js.map