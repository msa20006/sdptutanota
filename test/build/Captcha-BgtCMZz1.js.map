{"version":3,"file":"Captcha-BgtCMZz1.js","names":["cc: string","CardPrefixRanges: Record<CardType, NumberString[][]>","s: string","fn: StringInputCorrecter","v: string","ov: string","rest: string","ret: string","length: number","value: string","oldDate: string","groups: number[]","expirationDate: string","lang: LanguageViewModel","number: string","cvv: string","data: CreditCard | null","captchaInput: string","mailAddress: string","isBusinessUse: boolean","isPaidSubscription: boolean","campaignToken: string | null","challenge: Uint8Array","token: string","dialog: Dialog","actionBarAttrs: DialogHeaderBarAttrs"],"sources":["../../src/common/subscription/SimplifiedCreditCardInputModel.ts","../../src/common/subscription/Captcha.ts"],"sourcesContent":["import { createCreditCard, CreditCard } from \"../api/entities/sys/TypeRefs.js\"\nimport { LanguageViewModel, TranslationKey } from \"../misc/LanguageViewModel.js\"\nimport { CCViewModel } from \"./SimplifiedCreditCardInput.js\"\nimport { isValidCreditCardNumber } from \"../misc/FormatValidator.js\"\nimport { typedValues } from \"@tutao/tutanota-utils\"\n\n// we're using string values to make it easy to iterate all card types\nexport enum CardType {\n\tAmex = \"Amex\",\n\tVisa = \"Visa\",\n\tMastercard = \"Mastercard\",\n\tMaestro = \"Maestro\",\n\tDiscover = \"Discover\",\n\tOther = \"Other\",\n}\n\n/**\n * Tries to find the credit card issuer by credit card number.\n * Therefore, it is checked whether the typed in number is in a known range.\n * Input MUST be sanitized to only contain numerical digits\n * @param cc the credit card number typed in by the user\n */\nexport function getCardTypeRange(cc: string): CardType {\n\tfor (let cardType of typedValues(CardType)) {\n\t\tif (cardType === CardType.Other) continue\n\t\tfor (let range of CardPrefixRanges[cardType]) {\n\t\t\tconst lowestRange = range[0].padEnd(8, \"0\")\n\t\t\tconst highestRange = range[1].padEnd(8, \"9\")\n\t\t\tconst lowestCC = cc.slice(0, 8).padEnd(8, \"0\")\n\t\t\tconst highestCC = cc.slice(0, 8).padEnd(8, \"9\")\n\t\t\tif (lowestRange <= lowestCC && highestCC <= highestRange) {\n\t\t\t\treturn cardType\n\t\t\t}\n\t\t}\n\t}\n\treturn CardType.Other\n}\n\ntype CardSpec = { cvvLength: number | null; cvvName: string; name: string | null }\n\n// we can't have enums with\nconst CardSpecs = Object.freeze({\n\t[CardType.Visa]: { cvvLength: 3, cvvName: \"CVV\", name: \"Visa\" },\n\t[CardType.Mastercard]: { cvvLength: 3, cvvName: \"CVC\", name: \"Mastercard\" },\n\t[CardType.Maestro]: { cvvLength: 3, cvvName: \"CVV\", name: \"Maestro\" },\n\t[CardType.Amex]: { cvvLength: 4, cvvName: \"CSC\", name: \"American Express\" },\n\t[CardType.Discover]: { cvvLength: 3, cvvName: \"CVD\", name: \"Discover\" },\n\t[CardType.Other]: { cvvLength: null, cvvName: \"CVV\", name: null },\n})\n\n// https://en.wikipedia.org/wiki/Payment_card_number\nconst CardPrefixRanges: Record<CardType, NumberString[][]> = Object.freeze({\n\t[CardType.Visa]: [[\"4\", \"4\"]],\n\t[CardType.Mastercard]: [\n\t\t[\"51\", \"55\"],\n\t\t[\"2221\", \"2720\"],\n\t],\n\t[CardType.Maestro]: [\n\t\t[\"6759\", \"6759\"],\n\t\t[\"676770\", \"676770\"],\n\t\t[\"676774\", \"676774\"],\n\t\t[\"5018\", \"5018\"],\n\t\t[\"5020\", \"5020\"],\n\t\t[\"5038\", \"5038\"],\n\t\t[\"5893\", \"5893\"],\n\t\t[\"6304\", \"6304\"],\n\t\t[\"6759\", \"6759\"],\n\t\t[\"6761\", \"6763\"],\n\t],\n\t[CardType.Amex]: [\n\t\t[\"34\", \"34\"],\n\t\t[\"37\", \"37\"],\n\t],\n\t[CardType.Discover]: [\n\t\t[\"6011\", \"6011\"],\n\t\t[\"644\", \"649\"],\n\t\t[\"65\", \"65\"],\n\t\t[\"622126\", \"622925\"],\n\t],\n\t[CardType.Other]: [[]],\n})\ntype StringInputCorrecter = (value: string, oldValue?: string) => string\n\nconst allDigits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nconst definiteMonthDigits = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nconst secondMonthDigits = [\"0\", \"1\", \"2\"]\nconst separator = \"/\"\nconst niceSeparator = ` ${separator} `\n\n/**\n * completely strip all whitespace from a string\n * @param s the string to clean up\n */\nfunction stripWhitespace(s: string): string {\n\treturn s.replace(/\\s/g, \"\")\n}\n\nfunction stripNonDigits(s: string): string {\n\treturn s.replace(/\\D/g, \"\")\n}\n\n/**\n * true if s contains characters and all of them are digits.\n */\nexport function isDigitString(s: string) {\n\tif (s.length === 0) return false\n\tconst matches = s.match(/\\d/g)\n\treturn matches != null && matches.length === s.length\n}\n\n/**\n * take a function that corrects whitespace on input that does not contain whitespace\n * and return one that does the same on input that contains arbitrary whitespace.\n * @param fn a function that does not deal with whitespace-containing or empty input\n */\nfunction normalizeInput(fn: StringInputCorrecter): StringInputCorrecter {\n\treturn (v: string, ov: string = \"\") => {\n\t\tv = stripWhitespace(v)\n\t\tif (v === \"\") return v\n\t\tov = stripWhitespace(ov)\n\t\treturn fn(v, ov)\n\t}\n}\n\n/*\n * take digits from the start of rest and add them to the end of ret until a non-digit is encountered.\n * discards rest from first non-digit.\n *\n * returns modified rest and ret\n */\nfunction nomDigitsUntilLength(rest: string, ret: string, length: number): { rest: string; ret: string } {\n\twhile (rest.length > 0 && ret.length < length) {\n\t\tconst next = rest[0]\n\t\trest = rest.slice(1)\n\t\tif (allDigits.includes(next)) {\n\t\t\tret += next\n\t\t} else {\n\t\t\trest = \"\"\n\t\t\tbreak\n\t\t}\n\t}\n\treturn { rest, ret }\n}\n\n/**\n * take a date input string and a previous value to render a version that's non-ambiguous\n * and conforms to a valid prefix of the \"MM / YY\" or \"MM / YYYY\" format in the 2000-2099 date range.\n * - should work with pre-emptively adding/removing the backslash\n * - should reformat pasted input\n * - ignores invalid input characters and any leftover input.\n *\n * EXAMPLES: new, old -> output (for more, look at the CreditCardViewModelTest.ts):\n * \"1\" -> \"1\" \t\t\t\tambiguous, we can't complete this\n * \"00\", \"0\" -> \"0\"     \tinvalid input character\n * \"3\", \"\" -> \"03 / \"       this must be march, there are no months starting with 3\n * \"13\", \"1\" -> \"01 / 3\"    13 as a month is invalid, the 1 must have been january and 3 part of the year\n * \"01 /\", \"01 / 2\" -> \"01\" pre-emptively remove backslash if the user backspaces across it\n * \"0126\", \"\" -> \"01 / 26\"  if the input is valid, we still add the separator even when pasting.\n *\n * @param value the new value of the (potentially partial) expiration date\n * @param oldDate the previous value, needed for some special backspace handling.\n */\nexport const inferExpirationDate = normalizeInput(inferNormalizedExpirationDate)\n\n/**\n *\n * @param value non-empty string without whitespace specifying a (potentially partial) date as a sequence of 0 to 6 digits.\n * @param oldDate previous value\n */\nfunction inferNormalizedExpirationDate(value: string, oldDate: string): string {\n\tif (oldDate.startsWith(value) && value.endsWith(separator)) {\n\t\t// probably used backspace. in this case, we need to remove the separator\n\t\t// in a special way to be consistent.\n\t\treturn value.slice(0, -1)\n\t}\n\tif (!allDigits.includes(value[0])) return \"\"\n\tlet rest = value\n\tlet ret = \"\"\n\tif (definiteMonthDigits.includes(rest[0])) {\n\t\t// we already know what month this must be (typed without leading zero)\n\t\tret = \"0\" + rest[0]\n\t\trest = rest.slice(1)\n\t} else {\n\t\t// we don't know yet if we have 01, 02, ..., 09 or 10, 11, 12\n\t\tif (rest[0] === \"0\") {\n\t\t\tret = \"0\"\n\t\t\trest = rest.slice(1)\n\t\t\tif (rest[0] === \"0\") {\n\t\t\t\t// started with \"00\"\n\t\t\t\treturn \"0\"\n\t\t\t} else if (allDigits.includes(rest[0])) {\n\t\t\t\t// started with \"0x\" x being a digit\n\t\t\t\tret = \"0\" + rest[0]\n\t\t\t\trest = rest.slice(1)\n\t\t\t} else {\n\t\t\t\t// started with 0x x not being a non-zero digit.\n\t\t\t\treturn \"0\"\n\t\t\t}\n\t\t} else if (value.length > 1) {\n\t\t\t/* input started with 1 */\n\t\t\trest = rest.slice(1)\n\t\t\tif (secondMonthDigits.includes(rest[0])) {\n\t\t\t\tret = \"1\" + rest[0]\n\t\t\t\trest = rest.slice(1)\n\t\t\t} else if (allDigits.includes(rest[0])) {\n\t\t\t\t// any digit other than 0,1,2 after \"1\" must mean january\n\t\t\t\tret = \"01\"\n\t\t\t\t// not removing a slash or input that's part of the year here.\n\t\t\t} else if (rest[0] === separator) {\n\t\t\t\tret = \"01\"\n\t\t\t\t// not stripping separator here, we do that later anyway\n\t\t\t} else {\n\t\t\t\t// 1x... -> x is invalid in this position\n\t\t\t\treturn \"1\"\n\t\t\t}\n\t\t} else {\n\t\t\t/* input was exactly \"1\" */\n\t\t\treturn \"1\"\n\t\t}\n\t}\n\n\tlet hadSlash = false\n\twhile (rest.startsWith(separator)) {\n\t\thadSlash = true\n\t\trest = rest.slice(1)\n\t}\n\n\tif ((ret.length === 2 && rest.length > 0) || hadSlash || value.length > oldDate.length) {\n\t\t// if there is more input or the user added a slash at the end of the month or the month just got finished,\n\t\t// we need a slash\n\t\tret += separator\n\t}\n\n\t// we have a month + slash + potentially first year digit\n\t// rest contains only the part of the input that is relevant to the year\n\t;({ rest, ret } = nomDigitsUntilLength(rest, ret, \"xx/xx\".length))\n\n\tif (!ret.endsWith(\"/20\")) {\n\t\t// we only consider years in the 2000-2099 range valid, which\n\t\t// means we can assume two-digit year and return.\n\t\treturn ret.replace(separator, niceSeparator)\n\t}\n\n\t;({ ret } = nomDigitsUntilLength(rest, ret, \"xx/xxxx\".length))\n\n\treturn ret.replace(separator, niceSeparator)\n}\n\n/**\n * take a sequence of digits and other characters, strip non-digits and group the rest into space-separated groups.\n * @param value non-empty string without whitespace specifying a (potentially partial) credit card number\n * @param groups most credit card number digits are grouped in groups of 4, but there are exceptions\n */\nfunction groupCreditCardNumber(value: string, groups: number[] = [4, 4, 4, 4, 4]): string {\n\tvalue = stripNonDigits(value)\n\tvalue = value.slice(0, 20)\n\tlet ret = value.slice(0, groups[0])\n\tvalue = value.slice(groups[0])\n\tfor (let i = 1; i < groups.length && value.length > 0; i++) {\n\t\tret += \" \"\n\t\tret += value.slice(0, groups[i])\n\t\tvalue = value.slice(groups[i])\n\t}\n\treturn ret\n}\n\n/*\n * extract a numeric month and year from an expiration date in the form \"M... / Y...\"\n * if the format is invalid (wrong separator, month not 1 - 12, invalid numbers, year not in 2000 - 2099 range) return null.\n * otherwise, return object containing the year and month properties.\n */\nexport function getExpirationMonthAndYear(expirationDate: string): { year: number; month: number } | null {\n\tif (expirationDate.length < \"xx / xx\".length || !expirationDate.includes(\" / \")) {\n\t\treturn null\n\t}\n\tconst [monthString, yearString] = expirationDate.split(\" / \").map((p) => p.trim())\n\tif (!isDigitString(monthString) || !isDigitString(yearString)) {\n\t\treturn null\n\t}\n\tconst monthNumber = Number(monthString)\n\tif (monthNumber < 1 || monthNumber > 12) {\n\t\treturn null\n\t}\n\tconst yearNumber = Number(yearString)\n\tif (yearString.length === 4 && yearString.startsWith(\"20\")) {\n\t\treturn {\n\t\t\tyear: Math.floor(yearNumber) - 2000,\n\t\t\tmonth: Math.floor(monthNumber),\n\t\t}\n\t} else if (yearString.length === 2) {\n\t\treturn {\n\t\t\tyear: Math.floor(yearNumber),\n\t\t\tmonth: Math.floor(monthNumber),\n\t\t}\n\t} else {\n\t\treturn null\n\t}\n}\n\nexport class SimplifiedCreditCardViewModel implements CCViewModel {\n\tprivate _cardHolderName: string = \"\"\n\tprivate _creditCardNumber: string = \"\"\n\tprivate _cvv: string = \"\"\n\tprivate _expirationDate: string = \"\"\n\n\tprivate creditCardType: CardType = CardType.Other\n\n\tconstructor(private readonly lang: LanguageViewModel) {}\n\n\tget expirationDate(): string {\n\t\treturn this._expirationDate\n\t}\n\n\tset expirationDate(value: string) {\n\t\tthis._expirationDate = inferExpirationDate(value, this._expirationDate)\n\t}\n\n\tget cvv(): string {\n\t\treturn this._cvv\n\t}\n\n\tset cvv(value: string) {\n\t\tconst correctedCvv = stripWhitespace(stripNonDigits(value))\n\t\tthis._cvv = correctedCvv.slice(0, 4)\n\t}\n\n\tget creditCardNumber(): string {\n\t\treturn this._creditCardNumber\n\t}\n\n\tset creditCardNumber(value: string) {\n\t\tlet cleanedNumber = stripNonDigits(stripWhitespace(value))\n\t\tthis.creditCardType = getCardTypeRange(cleanedNumber)\n\t\tthis._creditCardNumber =\n\t\t\tthis.creditCardType === CardType.Amex ? groupCreditCardNumber(cleanedNumber, [4, 6, 5, 5]) : groupCreditCardNumber(cleanedNumber)\n\t}\n\n\tget cardHolderName(): string {\n\t\treturn this._cardHolderName\n\t}\n\n\tset cardHolderName(value: string) {\n\t\t// no-op for now.\n\t}\n\n\tvalidateCreditCardPaymentData(): TranslationKey | null {\n\t\tconst cc = this.getCreditCardData()\n\t\tconst invalidNumber = this.validateCreditCardNumber(cc.number)\n\t\tif (invalidNumber) {\n\t\t\treturn invalidNumber\n\t\t}\n\t\tconst invalidCVV = this.validateCVV(cc.cvv)\n\t\tif (invalidCVV) {\n\t\t\treturn invalidCVV\n\t\t}\n\t\tconst invalidExpirationDate = this.getExpirationDateErrorHint()\n\t\tif (invalidExpirationDate) {\n\t\t\treturn invalidExpirationDate\n\t\t}\n\t\treturn null\n\t}\n\n\tvalidateCreditCardNumber(number: string): TranslationKey | null {\n\t\tif (number === \"\") {\n\t\t\treturn \"creditCardNumberFormat_msg\"\n\t\t} else if (!isValidCreditCardNumber(number)) {\n\t\t\treturn \"creditCardNumberInvalid_msg\"\n\t\t}\n\t\treturn null\n\t}\n\n\tvalidateCVV(cvv: string): TranslationKey | null {\n\t\tif (cvv.length < 3 || cvv.length > 4) {\n\t\t\treturn \"creditCardCVVFormat_label\"\n\t\t}\n\t\treturn null\n\t}\n\n\tgetCreditCardNumberHint(): string | null {\n\t\tconst spec = CardSpecs[this.creditCardType]\n\t\tif (this.creditCardType === CardType.Other) {\n\t\t\treturn null\n\t\t}\n\t\treturn spec.name\n\t}\n\n\tgetCreditCardNumberErrorHint(): string | null {\n\t\treturn this.validateCreditCardNumber(this._creditCardNumber) ? this.lang.get(\"creditCardNumberInvalid_msg\") : null\n\t}\n\n\t/**\n\t * return a translation string detailing what's wrong with the\n\t * contents of the expiration date field, if any.\n\t */\n\tgetExpirationDateErrorHint(): TranslationKey | null {\n\t\tconst expiration = getExpirationMonthAndYear(this._expirationDate)\n\t\tif (expiration == null) {\n\t\t\treturn \"creditCardExprationDateInvalid_msg\"\n\t\t}\n\t\tconst today = new Date()\n\t\tconst currentYear = today.getFullYear() - 2000\n\t\tconst currentMonth = today.getMonth() + 1\n\t\tconst { year, month } = expiration\n\t\tif (year > currentYear || (year === currentYear && month >= currentMonth)) {\n\t\t\treturn null\n\t\t}\n\t\treturn \"creditCardExpired_msg\"\n\t}\n\n\tgetCvvHint(): string | null {\n\t\tif (this.creditCardType === CardType.Other) {\n\t\t\treturn null\n\t\t} else {\n\t\t\tconst spec = CardSpecs[this.creditCardType]\n\t\t\treturn this.lang.get(\"creditCardCvvHint_msg\", { \"{currentDigits}\": this.cvv.length, \"{totalDigits}\": spec.cvvLength })\n\t\t}\n\t}\n\n\tgetCvvErrorHint(): string | null {\n\t\tconst spec = CardSpecs[this.creditCardType]\n\t\treturn this.validateCVV(this.cvv) ? this.lang.get(\"creditCardSpecificCVVInvalid_msg\", { \"{securityCode}\": spec.cvvName }) : null\n\t}\n\n\tgetCvvLabel(): string {\n\t\tif (this.creditCardType === CardType.Other) {\n\t\t\treturn this.lang.get(\"creditCardCvvLabelLong_label\", { \"{cvvName}\": CardSpecs[CardType.Other].cvvName })\n\t\t} else {\n\t\t\tconst spec = CardSpecs[this.creditCardType]\n\t\t\treturn this.lang.get(\"creditCardCvvLabelLong_label\", { \"{cvvName}\": spec.cvvName })\n\t\t}\n\t}\n\n\tgetCreditCardData(): CreditCard {\n\t\tconst expiration = getExpirationMonthAndYear(this._expirationDate)\n\t\tlet cc = createCreditCard({\n\t\t\tnumber: stripWhitespace(this._creditCardNumber),\n\t\t\tcardHolderName: this._cardHolderName,\n\t\t\tcvv: this._cvv,\n\t\t\texpirationMonth: expiration ? String(expiration.month) : \"\",\n\t\t\texpirationYear: expiration ? String(expiration.year) : \"\",\n\t\t})\n\t\treturn cc\n\t}\n\n\tsetCreditCardData(data: CreditCard | null): void {\n\t\tif (data) {\n\t\t\tthis.creditCardNumber = data.number\n\t\t\tthis.cvv = data.cvv\n\n\t\t\tif (data.expirationMonth && data.expirationYear) {\n\t\t\t\tthis.expirationDate = data.expirationMonth + \" / \" + data.expirationYear\n\t\t\t}\n\t\t} else {\n\t\t\tthis._creditCardNumber = \"\"\n\t\t\tthis._cvv = \"\"\n\t\t\tthis._expirationDate = \"\"\n\t\t}\n\t}\n}\n","import { locator } from \"../api/main/CommonLocator.js\"\nimport { RegistrationCaptchaService } from \"../api/entities/sys/Services.js\"\nimport { createRegistrationCaptchaServiceData, createRegistrationCaptchaServiceGetData } from \"../api/entities/sys/TypeRefs.js\"\nimport { deviceConfig } from \"../misc/DeviceConfig.js\"\nimport { AccessDeactivatedError, AccessExpiredError, InvalidDataError } from \"../api/common/error/RestError.js\"\nimport { Dialog, DialogType } from \"../gui/base/Dialog.js\"\nimport { DialogHeaderBar, DialogHeaderBarAttrs } from \"../gui/base/DialogHeaderBar.js\"\nimport { ButtonType } from \"../gui/base/Button.js\"\nimport { lang } from \"../misc/LanguageViewModel.js\"\nimport m, { Children } from \"mithril\"\nimport { TextField } from \"../gui/base/TextField.js\"\nimport { uint8ArrayToBase64 } from \"@tutao/tutanota-utils\"\nimport { theme } from \"../gui/theme\"\nimport { getColorLuminance, isMonochrome } from \"../gui/base/Color\"\n\n/**\n * Accepts multiple formats for a time of day and always returns 12h-format with leading zeros.\n * @param captchaInput\n * @returns {string} HH:MM if parsed, null otherwise\n */\nexport function parseCaptchaInput(captchaInput: string): string | null {\n\tif (captchaInput.match(/^[0-2]?[0-9]:[0-5]?[0-9]$/)) {\n\t\tlet [h, m] = captchaInput\n\t\t\t.trim()\n\t\t\t.split(\":\")\n\t\t\t.map((t) => Number(t))\n\n\t\t// regex correctly matches 0-59 minutes, but matches hours 0-29, so we need to make sure hours is 0-24\n\t\tif (h > 24) {\n\t\t\treturn null\n\t\t}\n\n\t\treturn [h % 12, m].map((a) => String(a).padStart(2, \"0\")).join(\":\")\n\t} else {\n\t\treturn null\n\t}\n}\n\n/**\n * @returns the auth token for the signup if the captcha was solved or no captcha was necessary, null otherwise\n *\n * TODO:\n *  * Refactor token usage\n */\nexport async function runCaptchaFlow(\n\tmailAddress: string,\n\tisBusinessUse: boolean,\n\tisPaidSubscription: boolean,\n\tcampaignToken: string | null,\n): Promise<string | null> {\n\ttry {\n\t\tconst captchaReturn = await locator.serviceExecutor.get(\n\t\t\tRegistrationCaptchaService,\n\t\t\tcreateRegistrationCaptchaServiceGetData({\n\t\t\t\ttoken: campaignToken,\n\t\t\t\tmailAddress,\n\t\t\t\tsignupToken: deviceConfig.getSignupToken(),\n\t\t\t\tbusinessUseSelected: isBusinessUse,\n\t\t\t\tpaidSubscriptionSelected: isPaidSubscription,\n\t\t\t}),\n\t\t)\n\t\tif (captchaReturn.challenge) {\n\t\t\ttry {\n\t\t\t\treturn await showCaptchaDialog(captchaReturn.challenge, captchaReturn.token)\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof InvalidDataError) {\n\t\t\t\t\tawait Dialog.message(\"createAccountInvalidCaptcha_msg\")\n\t\t\t\t\treturn runCaptchaFlow(mailAddress, isBusinessUse, isPaidSubscription, campaignToken)\n\t\t\t\t} else if (e instanceof AccessExpiredError) {\n\t\t\t\t\tawait Dialog.message(\"createAccountAccessDeactivated_msg\")\n\t\t\t\t\treturn null\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn captchaReturn.token\n\t\t}\n\t} catch (e) {\n\t\tif (e instanceof AccessDeactivatedError) {\n\t\t\tawait Dialog.message(\"createAccountAccessDeactivated_msg\")\n\t\t\treturn null\n\t\t} else {\n\t\t\tthrow e\n\t\t}\n\t}\n}\n\nfunction showCaptchaDialog(challenge: Uint8Array, token: string): Promise<string | null> {\n\treturn new Promise<string | null>((resolve, reject) => {\n\t\tlet dialog: Dialog\n\t\tlet captchaInput = \"\"\n\n\t\tconst cancelAction = () => {\n\t\t\tdialog.close()\n\t\t\tresolve(null)\n\t\t}\n\n\t\tconst okAction = () => {\n\t\t\tlet parsedInput = parseCaptchaInput(captchaInput)\n\n\t\t\t// User entered an incorrectly formatted time\n\t\t\tif (parsedInput == null) {\n\t\t\t\tDialog.message(\"captchaEnter_msg\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// The user entered a correctly formatted time, but not one that our captcha will ever give out (i.e. not *0 or *5)\n\t\t\tconst minuteOnesPlace = parsedInput[parsedInput.length - 1]\n\t\t\tif (minuteOnesPlace !== \"0\" && minuteOnesPlace !== \"5\") {\n\t\t\t\tDialog.message(\"createAccountInvalidCaptcha_msg\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdialog.close()\n\t\t\tlocator.serviceExecutor\n\t\t\t\t.post(RegistrationCaptchaService, createRegistrationCaptchaServiceData({ token, response: parsedInput }))\n\t\t\t\t.then(() => {\n\t\t\t\t\tresolve(token)\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\treject(e)\n\t\t\t\t})\n\t\t}\n\n\t\tlet actionBarAttrs: DialogHeaderBarAttrs = {\n\t\t\tleft: [\n\t\t\t\t{\n\t\t\t\t\tlabel: \"cancel_action\",\n\t\t\t\t\tclick: cancelAction,\n\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t},\n\t\t\t],\n\t\t\tright: [\n\t\t\t\t{\n\t\t\t\t\tlabel: \"ok_action\",\n\t\t\t\t\tclick: okAction,\n\t\t\t\t\ttype: ButtonType.Primary,\n\t\t\t\t},\n\t\t\t],\n\t\t\tmiddle: \"captchaDisplay_label\",\n\t\t}\n\t\tconst imageData = `data:image/png;base64,${uint8ArrayToBase64(challenge)}`\n\n\t\tdialog = new Dialog(DialogType.EditSmall, {\n\t\t\tview: (): Children => {\n\t\t\t\t// The captcha is black-on-white, which will not look correct on anything where the background is not\n\t\t\t\t// white. We can use CSS filters to fix this.\n\t\t\t\tlet captchaFilter = {}\n\t\t\t\tif (theme.elevated_bg != null && isMonochrome(theme.elevated_bg)) {\n\t\t\t\t\tcaptchaFilter = {\n\t\t\t\t\t\tfilter: `invert(${1.0 - getColorLuminance(theme.elevated_bg)}`,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [\n\t\t\t\t\tm(DialogHeaderBar, actionBarAttrs),\n\t\t\t\t\tm(\".plr-l.pb\", [\n\t\t\t\t\t\tm(\"img.pt-ml.center-h.block\", {\n\t\t\t\t\t\t\tsrc: imageData,\n\t\t\t\t\t\t\talt: lang.get(\"captchaDisplay_label\"),\n\t\t\t\t\t\t\tstyle: captchaFilter,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tm(TextField, {\n\t\t\t\t\t\t\tlabel: lang.makeTranslation(\"captcha_input\", lang.get(\"captchaInput_label\") + \" (hh:mm)\"),\n\t\t\t\t\t\t\thelpLabel: () => lang.get(\"captchaInfo_msg\"),\n\t\t\t\t\t\t\tvalue: captchaInput,\n\t\t\t\t\t\t\toninput: (value) => (captchaInput = value),\n\t\t\t\t\t\t}),\n\t\t\t\t\t]),\n\t\t\t\t]\n\t\t\t},\n\t\t})\n\t\t\t.setCloseHandler(cancelAction)\n\t\t\t.show()\n\t})\n}\n"],"mappings":"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"}