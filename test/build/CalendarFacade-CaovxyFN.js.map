{"version":3,"file":"CalendarFacade-CaovxyFN.js","names":["userFacade: UserFacade","groupManagementFacade: GroupManagementFacade","entityRestCache: DefaultEntityRestCache","noncachingEntityClient: EntityClient","nativePushFacade: NativePushFacade","operationProgressTracker: ExposedOperationProgressTracker","instanceMapper: InstanceMapper","serviceExecutor: IServiceExecutor","cryptoFacade: CryptoFacade","infoMessageHandler: InfoMessageHandler","eventWrappers: Array<EventWrapper>","operationId: OperationId","month: CalendarTimeRange","calendarInfos: ReadonlyMap<Id, CalendarInfo>","daysToEvents: DaysToEvents","zone: string","calendars: Array<{ long: CalendarEvent[]; short: CalendarEvent[] }>","eventMap: Map<number, CalendarEvent[]>","events: CalendarEvent[]","range: CalendarTimeRange","overwriteRange: boolean","eventsWrapper: Array<EventWrapper>","onProgress: (percent: number) => Promise<void>","eventsWithAlarms: Array<AlarmNotificationsPerEvent>","collectedAlarmNotifications: AlarmNotification[]","event: CalendarEvent","alarmInfos: ReadonlyArray<AlarmInfoTemplate>","oldEvent: CalendarEvent | null","newAlarms: ReadonlyArray<AlarmInfoTemplate>","existingEvent: CalendarEvent","start: number","end: number","results: Array<IdTuple>","name: string","groupRootId: Id","pushIdentifier: PushIdentifier","encryptedAlarms: EncryptedAlarmNotification[]","uid: string","cacheMode: CachingMode","indexEntry: CalendarEventUidIndex","progenitor: CalendarEventProgenitor | null","alteredInstances: Array<CalendarEventAlteredInstance>","alarmNotifications: Array<AlarmNotification>","pushIdentifierList: Array<PushIdentifier>","notificationSessionKey: AesKey","user: User","eventsWrapper: Array<{\n\t\t\tevent: CalendarEvent\n\t\t\talarms: ReadonlyArray<AlarmInfoTemplate>\n\t\t}>","userAlarmInfosAndNotificationsPerEvent: Array<{\n\t\t\tevent: CalendarEvent\n\t\t\tuserAlarmInfoAndNotification: Array<{\n\t\t\t\talarm: UserAlarmInfo\n\t\t\t\talarmNotification: AlarmNotification\n\t\t\t}>\n\t\t}>","userAlarmInfoAndNotification: Array<{\n\t\t\t\talarm: UserAlarmInfo\n\t\t\t\talarmNotification: AlarmNotification\n\t\t\t}>","alarmIds: Array<Id>","alarmInfo: AlarmInfo","userId: Id","calendarRepeatRule: CalendarRepeatRule","userAlarmInfo: UserAlarmInfo","arr: Array<CalendarEventAlteredInstance>","entityClient: EntityClient","indexedEventIds: Map<Id, Array<Id>>","e: IdTuple","e: CalendarEventAlteredInstance"],"sources":["../../src/common/api/worker/facades/lazy/CalendarFacade.ts"],"sourcesContent":["import { assertWorkerOrNode } from \"../../../common/Env.js\"\nimport type { AlarmInfo, AlarmNotification, Group, PushIdentifier, RepeatRule, User, UserAlarmInfo } from \"../../../entities/sys/TypeRefs.js\"\nimport {\n\tAlarmServicePostTypeRef,\n\tcreateAlarmInfo,\n\tcreateAlarmNotification,\n\tcreateAlarmServicePost,\n\tcreateCalendarEventRef,\n\tcreateDateWrapper,\n\tcreateNotificationSessionKey,\n\tcreateRepeatRule,\n\tcreateUserAlarmInfo,\n\tPushIdentifierTypeRef,\n\tUserAlarmInfoTypeRef,\n} from \"../../../entities/sys/TypeRefs.js\"\nimport {\n\tassertNotNull,\n\tDAY_IN_MILLIS,\n\tdowncast,\n\tflatMap,\n\tgetFromMap,\n\tgroupBy,\n\tgroupByAndMap,\n\tgroupByAndMapUniquely,\n\tisNotNull,\n\tneverNull,\n\tofClass,\n\tpromiseMap,\n\tRequire,\n\tstringToUtf8Uint8Array,\n} from \"@tutao/tutanota-utils\"\nimport { CryptoFacade } from \"../../crypto/CryptoFacade.js\"\nimport { GroupType, OperationType } from \"../../../common/TutanotaConstants.js\"\nimport type { CalendarEvent, CalendarEventUidIndex, CalendarRepeatRule } from \"../../../entities/tutanota/TypeRefs.js\"\nimport { CalendarEventTypeRef, CalendarEventUidIndexTypeRef, CalendarGroupRootTypeRef, createCalendarDeleteData } from \"../../../entities/tutanota/TypeRefs.js\"\nimport { DefaultEntityRestCache } from \"../../rest/DefaultEntityRestCache.js\"\nimport { ConnectionError, NotAuthorizedError, NotFoundError, PayloadTooLargeError } from \"../../../common/error/RestError.js\"\nimport { EntityClient, loadMultipleFromLists } from \"../../../common/EntityClient.js\"\nimport { elementIdPart, getLetId, getListId, isSameId, listIdPart, uint8arrayToCustomId } from \"../../../common/utils/EntityUtils.js\"\nimport { GroupManagementFacade } from \"./GroupManagementFacade.js\"\nimport { SetupMultipleError } from \"../../../common/error/SetupMultipleError.js\"\nimport { ImportError } from \"../../../common/error/ImportError.js\"\nimport { aes256RandomKey, AesKey, encryptKey, sha256Hash } from \"@tutao/tutanota-crypto\"\nimport { InstanceMapper } from \"../../crypto/InstanceMapper.js\"\nimport { TutanotaError } from \"@tutao/tutanota-error\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { AlarmService } from \"../../../entities/sys/Services.js\"\nimport { CalendarService } from \"../../../entities/tutanota/Services.js\"\nimport { resolveTypeReference } from \"../../../common/EntityFunctions.js\"\nimport { UserFacade } from \"../UserFacade.js\"\nimport { EncryptedAlarmNotification } from \"../../../../native/common/EncryptedAlarmNotification.js\"\nimport { NativePushFacade } from \"../../../../native/common/generatedipc/NativePushFacade.js\"\nimport { ExposedOperationProgressTracker, OperationId } from \"../../../main/OperationProgressTracker.js\"\nimport { InfoMessageHandler } from \"../../../../gui/InfoMessageHandler.js\"\nimport { ProgrammingError } from \"../../../common/error/ProgrammingError.js\"\nimport {\n\taddDaysForEventInstance,\n\taddDaysForRecurringEvent,\n\tCalendarTimeRange,\n\tgenerateCalendarInstancesInRange,\n\tisClientOnlyCalendar,\n} from \"../../../../calendar/date/CalendarUtils.js\"\nimport { CalendarInfo } from \"../../../../../calendar-app/calendar/model/CalendarModel.js\"\nimport { geEventElementMaxId, getEventElementMinId } from \"../../../common/utils/CommonCalendarUtils.js\"\nimport { DaysToEvents } from \"../../../../calendar/date/CalendarEventsRepository.js\"\nimport { isOfflineError } from \"../../../common/utils/ErrorUtils.js\"\nimport type { EventWrapper } from \"../../../../calendar/import/ImportExportUtils.js\"\n\nassertWorkerOrNode()\n\ntype AlarmNotificationsPerEvent = {\n\tevent: CalendarEvent\n\talarmInfoIds: IdTuple[]\n\talarmNotifications: AlarmNotification[]\n}\n\n/** event that is a part of an event series and references another event via its recurrenceId and uid */\nexport type CalendarEventAlteredInstance = Require<\"recurrenceId\" | \"uid\", CalendarEvent> & { repeatRule: null }\n/** events that has a uid, but no recurrenceId exist on their own and may define a series. events that do not repeat are also progenitors. */\nexport type CalendarEventProgenitor = Require<\"uid\", CalendarEvent> & { recurrenceId: null }\nexport type CalendarEventInstance = CalendarEventAlteredInstance | CalendarEventProgenitor\n/** index entry that bundles all the events with the same uid in the ownerGroup. */\nexport type CalendarEventUidIndexEntry = {\n\townerGroup: NonNullable<CalendarEvent[\"_ownerGroup\"]>\n\tprogenitor: CalendarEventProgenitor | null\n\talteredInstances: Array<CalendarEventAlteredInstance>\n}\n\nexport class CalendarFacade {\n\t// visible for testing\n\treadonly cachingEntityClient: EntityClient\n\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly groupManagementFacade: GroupManagementFacade,\n\t\t// We inject cache directly because we need to delete user from it for a hack\n\t\tprivate readonly entityRestCache: DefaultEntityRestCache,\n\t\tprivate readonly noncachingEntityClient: EntityClient,\n\t\tprivate readonly nativePushFacade: NativePushFacade,\n\t\tprivate readonly operationProgressTracker: ExposedOperationProgressTracker,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly infoMessageHandler: InfoMessageHandler,\n\t) {\n\t\tthis.cachingEntityClient = new EntityClient(this.entityRestCache)\n\t}\n\n\tasync saveImportedCalendarEvents(eventWrappers: Array<EventWrapper>, operationId: OperationId): Promise<void> {\n\t\t// it is safe to assume that all event uids are set at this time\n\t\treturn this.saveCalendarEvents(eventWrappers, (percent) => this.operationProgressTracker.onProgress(operationId, percent))\n\t}\n\n\t/**\n\t * extend or one month of the given daysToEvents map\n\t *\n\t * @param month only update events that intersect days in this month\n\t * @param calendarInfos update events contained in these calendars\n\t * @param daysToEvents the old version of the map\n\t * @param zone the time zone to consider the event times under\n\t * @returns a new daysToEventsMap where the given month is updated.\n\t */\n\tasync updateEventMap(\n\t\tmonth: CalendarTimeRange,\n\t\tcalendarInfos: ReadonlyMap<Id, CalendarInfo>,\n\t\tdaysToEvents: DaysToEvents,\n\t\tzone: string,\n\t): Promise<DaysToEvents> {\n\t\t// Because of the timezones and all day events, we might not load an event which we need to display.\n\t\t// So we add a margin on 24 hours to be sure we load everything we need. We will filter matching\n\t\t// events anyway.\n\t\tconst startId = getEventElementMinId(month.start - DAY_IN_MILLIS)\n\t\tconst endId = geEventElementMaxId(month.end + DAY_IN_MILLIS)\n\n\t\t// We collect events from all calendars together and then replace map synchronously.\n\t\t// This is important to replace the map synchronously to not get race conditions because we load different months in parallel.\n\t\t// We could replace map more often instead of aggregating events but this would mean creating even more (cals * months) maps.\n\t\t//\n\t\t// Note: there may be issues if we get entity update before other calendars finish loading but the chance is low and we do not\n\t\t// take care of this now.\n\n\t\tconst calendars: Array<{ long: CalendarEvent[]; short: CalendarEvent[] }> = []\n\n\t\tfor (const { groupRoot } of calendarInfos.values()) {\n\t\t\tconst [shortEventsResult, longEventsResult] = await Promise.all([\n\t\t\t\tthis.cachingEntityClient.loadReverseRangeBetween(CalendarEventTypeRef, groupRoot.shortEvents, endId, startId, 200),\n\t\t\t\tthis.cachingEntityClient.loadAll(CalendarEventTypeRef, groupRoot.longEvents),\n\t\t\t])\n\n\t\t\tcalendars.push({\n\t\t\t\tshort: shortEventsResult.elements,\n\t\t\t\tlong: longEventsResult,\n\t\t\t})\n\t\t}\n\t\tconst newEvents = new Map<number, Array<CalendarEvent>>(Array.from(daysToEvents.entries()).map(([day, events]) => [day, events.slice()]))\n\n\t\t// Generate events occurrences per calendar to avoid calendars flashing in the screen\n\t\tfor (const calendar of calendars) {\n\t\t\tthis.generateEventOccurences(newEvents, calendar.short, month, zone, true)\n\t\t\tthis.generateEventOccurences(newEvents, calendar.long, month, zone, false)\n\t\t}\n\n\t\treturn newEvents\n\t}\n\n\tprivate generateEventOccurences(\n\t\teventMap: Map<number, CalendarEvent[]>,\n\t\tevents: CalendarEvent[],\n\t\trange: CalendarTimeRange,\n\t\tzone: string,\n\t\toverwriteRange: boolean,\n\t) {\n\t\tfor (const e of events) {\n\t\t\t// Overrides end of range to prevent events from being truncated. Generating them until the end of the event\n\t\t\t// instead of the original end guarantees that the event will be fully displayed. This WILL NOT end in an\n\t\t\t// endless loop, because short events last a maximum of two weeks.\n\t\t\tconst generationRange = overwriteRange ? { ...range, end: e.endTime.getTime() } : range\n\n\t\t\tif (e.repeatRule) {\n\t\t\t\taddDaysForRecurringEvent(eventMap, e, generationRange, zone)\n\t\t\t} else {\n\t\t\t\taddDaysForEventInstance(eventMap, e, generationRange, zone)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * We try to create as many events as possible and only throw the error at the end.\n\t * If alarmNotifications are created for an event that will later fail to be created we ignore them.\n\t * This function does not perform any checks on the event so it should only be called internally when\n\t * we can be sure that those checks have already been performed.\n\t * @param eventsWrapper the events and alarmNotifications to be created.\n\t * @param onProgress\n\t */\n\tprivate async saveCalendarEvents(eventsWrapper: Array<EventWrapper>, onProgress: (percent: number) => Promise<void>): Promise<void> {\n\t\tlet currentProgress = 10\n\t\tawait onProgress(currentProgress)\n\n\t\tfor (const { event } of eventsWrapper) {\n\t\t\tevent.hashedUid = hashUid(assertNotNull(event.uid, \"tried to save calendar event without uid.\"))\n\t\t}\n\n\t\tconst user = this.userFacade.getLoggedInUser()\n\n\t\tconst numEvents = eventsWrapper.length\n\t\tlet eventsWithAlarms: Array<AlarmNotificationsPerEvent>\n\t\ttry {\n\t\t\teventsWithAlarms = await this.saveMultipleAlarms(user, eventsWrapper)\n\t\t} catch (e) {\n\t\t\tif (e instanceof SetupMultipleError) {\n\t\t\t\tconsole.log(\"Saving alarms failed.\", e)\n\t\t\t\tthrow new ImportError(e.errors[0], \"Could not save alarms.\", numEvents)\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t\tfor (const { event, alarmInfoIds } of eventsWithAlarms) {\n\t\t\tevent.alarmInfos = alarmInfoIds\n\t\t}\n\t\tcurrentProgress = 33\n\t\tawait onProgress(currentProgress)\n\t\tconst eventsWithAlarmsByEventListId = groupBy(eventsWithAlarms, (eventWrapper) => getListId(eventWrapper.event))\n\t\tlet collectedAlarmNotifications: AlarmNotification[] = []\n\t\t//we have different lists for short and long events so this is 1 or 2\n\t\tconst size = eventsWithAlarmsByEventListId.size\n\t\tlet failed = 0\n\t\tlet errors = [] as Array<TutanotaError>\n\n\t\tfor (const [listId, eventsWithAlarmsOfOneList] of eventsWithAlarmsByEventListId) {\n\t\t\tlet successfulEvents = eventsWithAlarmsOfOneList\n\t\t\tawait this.cachingEntityClient\n\t\t\t\t.setupMultipleEntities(\n\t\t\t\t\tlistId,\n\t\t\t\t\teventsWithAlarmsOfOneList.map((e) => e.event),\n\t\t\t\t)\n\t\t\t\t.catch(\n\t\t\t\t\tofClass(SetupMultipleError, (e) => {\n\t\t\t\t\t\tfailed += e.failedInstances.length\n\t\t\t\t\t\terrors = errors.concat(e.errors)\n\t\t\t\t\t\tconsole.log(e.errors)\n\t\t\t\t\t\tsuccessfulEvents = eventsWithAlarmsOfOneList.filter(({ event }) => !e.failedInstances.includes(event))\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\tconst allAlarmNotificationsOfListId = successfulEvents.map((event) => event.alarmNotifications).flat()\n\t\t\tcollectedAlarmNotifications = collectedAlarmNotifications.concat(allAlarmNotificationsOfListId)\n\t\t\tcurrentProgress += Math.floor(56 / size)\n\t\t\tawait onProgress(currentProgress)\n\t\t}\n\n\t\tconst pushIdentifierList = await this.cachingEntityClient.loadAll(\n\t\t\tPushIdentifierTypeRef,\n\t\t\tneverNull(this.userFacade.getLoggedInUser().pushIdentifierList).list,\n\t\t)\n\n\t\tif (collectedAlarmNotifications.length > 0 && pushIdentifierList.length > 0) {\n\t\t\tawait this.sendAlarmNotifications(collectedAlarmNotifications, pushIdentifierList)\n\t\t}\n\n\t\tawait onProgress(100)\n\n\t\tif (failed !== 0) {\n\t\t\tif (errors.some(isOfflineError)) {\n\t\t\t\t//In this case the user will not be informed about the number of failed events. We considered this is okay because it is not actionable anyways.\n\t\t\t\tthrow new ConnectionError(\"Connection lost while saving events\")\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Could not save events. Number of failed imports: \", failed)\n\t\t\t\tthrow new ImportError(errors[0], \"Could not save events.\", failed)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync saveCalendarEvent(event: CalendarEvent, alarmInfos: ReadonlyArray<AlarmInfoTemplate>, oldEvent: CalendarEvent | null): Promise<void> {\n\t\tif (event._id == null) throw new Error(\"No id set on the event\")\n\t\tif (event._ownerGroup == null) throw new Error(\"No _ownerGroup is set on the event\")\n\t\tif (event.uid == null) throw new Error(\"no uid set on the event\")\n\t\tevent.hashedUid = hashUid(event.uid)\n\n\t\tif (oldEvent) {\n\t\t\tawait this.cachingEntityClient.erase(oldEvent).catch(ofClass(NotFoundError, () => console.log(\"could not delete old event when saving new one\")))\n\t\t}\n\n\t\treturn await this.saveCalendarEvents(\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tevent,\n\t\t\t\t\talarms: alarmInfos,\n\t\t\t\t},\n\t\t\t],\n\t\t\t() => Promise.resolve(),\n\t\t)\n\t}\n\n\tasync updateCalendarEvent(event: CalendarEvent, newAlarms: ReadonlyArray<AlarmInfoTemplate>, existingEvent: CalendarEvent): Promise<void> {\n\t\tevent._id = existingEvent._id\n\t\tevent._ownerEncSessionKey = existingEvent._ownerEncSessionKey\n\t\tevent._ownerKeyVersion = existingEvent._ownerKeyVersion\n\t\tevent._permissions = existingEvent._permissions\n\t\tif (existingEvent.uid == null) throw new Error(\"no uid set on the existing event\")\n\t\tevent.uid = existingEvent.uid\n\t\tevent.hashedUid = hashUid(existingEvent.uid)\n\n\t\tconst user = this.userFacade.getLoggedInUser()\n\n\t\tconst userAlarmIdsWithAlarmNotificationsPerEvent = await this.saveMultipleAlarms(user, [\n\t\t\t{\n\t\t\t\tevent,\n\t\t\t\talarms: newAlarms,\n\t\t\t},\n\t\t])\n\t\tconst { alarmInfoIds, alarmNotifications } = userAlarmIdsWithAlarmNotificationsPerEvent[0]\n\t\tconst userAlarmInfoListId = neverNull(user.alarmInfoList).alarms\n\t\t// Remove all alarms which belongs to the current user. We need to be careful about other users' alarms.\n\t\t// Server takes care of the removed alarms,\n\t\tevent.alarmInfos = existingEvent.alarmInfos.filter((a) => !isSameId(listIdPart(a), userAlarmInfoListId)).concat(alarmInfoIds)\n\t\tawait this.cachingEntityClient.update(event)\n\n\t\tif (alarmNotifications.length > 0) {\n\t\t\tconst pushIdentifierList = await this.cachingEntityClient.loadAll(\n\t\t\t\tPushIdentifierTypeRef,\n\t\t\t\tneverNull(this.userFacade.getLoggedInUser().pushIdentifierList).list,\n\t\t\t)\n\t\t\tawait this.sendAlarmNotifications(alarmNotifications, pushIdentifierList)\n\t\t}\n\t}\n\n\t/**\n\t * get all the calendar event instances in the given time range that are generated by the given progenitor Ids\n\t */\n\tasync reifyCalendarSearchResult(start: number, end: number, results: Array<IdTuple>): Promise<Array<CalendarEvent>> {\n\t\tconst filteredEvents = results.filter(([calendarId, eventId]) => !isClientOnlyCalendar(calendarId))\n\t\tconst progenitors = await loadMultipleFromLists(CalendarEventTypeRef, this.cachingEntityClient, filteredEvents)\n\t\tconst range: CalendarTimeRange = { start, end }\n\t\treturn generateCalendarInstancesInRange(progenitors, range)\n\t}\n\n\tasync addCalendar(name: string): Promise<{ user: User; group: Group }> {\n\t\treturn await this.groupManagementFacade.createCalendar(name)\n\t}\n\n\tasync deleteCalendar(groupRootId: Id): Promise<void> {\n\t\tawait this.serviceExecutor.delete(CalendarService, createCalendarDeleteData({ groupRootId }))\n\t}\n\n\tasync scheduleAlarmsForNewDevice(pushIdentifier: PushIdentifier): Promise<void> {\n\t\tconst user = this.userFacade.getLoggedInUser()\n\n\t\tconst eventsWithAlarmInfos = await this.loadAlarmEvents()\n\t\tconst alarmNotifications = flatMap(eventsWithAlarmInfos, ({ event, userAlarmInfos }) =>\n\t\t\tuserAlarmInfos.map((userAlarmInfo) => createAlarmNotificationForEvent(event, userAlarmInfo.alarmInfo, user._id)),\n\t\t)\n\t\t// Theoretically we don't need to encrypt anything if we are sending things locally but we use already encrypted data on the client\n\t\t// to store alarms securely.\n\t\tconst notificationKey = aes256RandomKey()\n\t\tawait this.encryptNotificationKeyForDevices(notificationKey, alarmNotifications, [pushIdentifier])\n\t\tconst requestEntity = createAlarmServicePost({\n\t\t\talarmNotifications,\n\t\t})\n\t\tconst AlarmServicePostTypeModel = await resolveTypeReference(AlarmServicePostTypeRef)\n\t\tconst encEntity = await this.instanceMapper.encryptAndMapToLiteral(AlarmServicePostTypeModel, requestEntity, notificationKey)\n\t\tconst encryptedAlarms: EncryptedAlarmNotification[] = downcast(encEntity).alarmNotifications\n\t\tawait this.nativePushFacade.scheduleAlarms(encryptedAlarms)\n\t}\n\n\t/**\n\t * Load all events that have an alarm assigned.\n\t * @return: Map from concatenated ListId of an event to list of UserAlarmInfos for that event\n\t */\n\tasync loadAlarmEvents(): Promise<Array<EventWithUserAlarmInfos>> {\n\t\tconst alarmInfoList = this.userFacade.getLoggedInUser().alarmInfoList\n\n\t\tif (!alarmInfoList) {\n\t\t\tconsole.warn(\"No alarmInfo list on user\")\n\t\t\treturn []\n\t\t}\n\n\t\tconst userAlarmInfos = await this.cachingEntityClient.loadAll(UserAlarmInfoTypeRef, alarmInfoList.alarms)\n\t\t// Group referenced event ids by list id so we can load events of one list in one request.\n\t\tconst listIdToElementIds = groupByAndMapUniquely(\n\t\t\tuserAlarmInfos,\n\t\t\t(userAlarmInfo) => userAlarmInfo.alarmInfo.calendarRef.listId,\n\t\t\t(userAlarmInfo) => userAlarmInfo.alarmInfo.calendarRef.elementId,\n\t\t)\n\t\t// we group by the full concatenated list id\n\t\t// because there might be collisions between event element ids due to being custom ids\n\t\tconst eventIdToAlarmInfos = groupBy(userAlarmInfos, (userAlarmInfo) => getEventIdFromUserAlarmInfo(userAlarmInfo).join(\"\"))\n\t\tconst calendarEvents = await promiseMap(listIdToElementIds.entries(), ([listId, elementIds]) => {\n\t\t\treturn this.cachingEntityClient.loadMultiple(CalendarEventTypeRef, listId, Array.from(elementIds)).catch((error) => {\n\t\t\t\t// handle NotAuthorized here because user could have been removed from group.\n\t\t\t\tif (error instanceof NotAuthorizedError) {\n\t\t\t\t\tconsole.warn(\"NotAuthorized when downloading alarm events\", error)\n\t\t\t\t\treturn []\n\t\t\t\t}\n\n\t\t\t\tthrow error\n\t\t\t})\n\t\t})\n\t\treturn calendarEvents.flat().map((event) => {\n\t\t\treturn {\n\t\t\t\tevent,\n\t\t\t\tuserAlarmInfos: getFromMap(eventIdToAlarmInfos, getLetId(event).join(\"\"), () => []),\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Queries the events using the uid index. The index is stored per calendar, so we have to go through all calendars\n\t * to find the matching events. We currently only need this for calendar event updates and for that we don't want to\n\t * look into shared calendars.\n\t *\n\t * @returns {CalendarEventUidIndexEntry}\n\t */\n\tasync getEventsByUid(uid: string, cacheMode: CachingMode = CachingMode.Cached): Promise<CalendarEventUidIndexEntry | null> {\n\t\tconst { memberships } = this.userFacade.getLoggedInUser()\n\t\tconst entityClient = this.getEntityClient(cacheMode)\n\t\tfor (const membership of memberships) {\n\t\t\tif (membership.groupType !== GroupType.Calendar) continue\n\t\t\ttry {\n\t\t\t\tconst groupRoot = await this.cachingEntityClient.load(CalendarGroupRootTypeRef, membership.group)\n\t\t\t\tif (groupRoot.index == null) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst indexEntry: CalendarEventUidIndex = await entityClient.load<CalendarEventUidIndex>(CalendarEventUidIndexTypeRef, [\n\t\t\t\t\tgroupRoot.index.list,\n\t\t\t\t\tuint8arrayToCustomId(hashUid(uid)),\n\t\t\t\t])\n\n\t\t\t\tconst progenitor: CalendarEventProgenitor | null = await loadProgenitorFromIndexEntry(entityClient, indexEntry)\n\t\t\t\tconst alteredInstances: Array<CalendarEventAlteredInstance> = await loadAlteredInstancesFromIndexEntry(entityClient, indexEntry)\n\t\t\t\treturn { progenitor, alteredInstances, ownerGroup: assertNotNull(indexEntry._ownerGroup, \"ownergroup on index entry was null!\") }\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\tprivate async sendAlarmNotifications(alarmNotifications: Array<AlarmNotification>, pushIdentifierList: Array<PushIdentifier>): Promise<void> {\n\t\tconst notificationSessionKey = aes256RandomKey()\n\t\treturn this.encryptNotificationKeyForDevices(notificationSessionKey, alarmNotifications, pushIdentifierList).then(async () => {\n\t\t\tconst requestEntity = createAlarmServicePost({\n\t\t\t\talarmNotifications,\n\t\t\t})\n\t\t\ttry {\n\t\t\t\tawait this.serviceExecutor.post(AlarmService, requestEntity, { sessionKey: notificationSessionKey })\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof PayloadTooLargeError) {\n\t\t\t\t\treturn this.infoMessageHandler.onInfoMessage({\n\t\t\t\t\t\ttranslationKey: \"calendarAlarmsTooBigError_msg\",\n\t\t\t\t\t\targs: {},\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate async encryptNotificationKeyForDevices(\n\t\tnotificationSessionKey: AesKey,\n\t\talarmNotifications: Array<AlarmNotification>,\n\t\tpushIdentifierList: Array<PushIdentifier>,\n\t): Promise<void> {\n\t\t// PushID SK ->* Notification SK -> alarm fields\n\t\tconst maybeEncSessionKeys = await promiseMap(pushIdentifierList, async (identifier) => {\n\t\t\tconst pushIdentifierSk = await this.cryptoFacade.resolveSessionKeyForInstance(identifier)\n\t\t\tif (pushIdentifierSk) {\n\t\t\t\tconst pushIdentifierSessionEncSessionKey = encryptKey(pushIdentifierSk, notificationSessionKey)\n\t\t\t\treturn {\n\t\t\t\t\tidentifierId: identifier._id,\n\t\t\t\t\tpushIdentifierSessionEncSessionKey,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null\n\t\t\t}\n\t\t}) // rate limiting against blocking while resolving session keys (neccessary)\n\t\tconst encSessionKeys = maybeEncSessionKeys.filter(isNotNull)\n\n\t\tfor (let notification of alarmNotifications) {\n\t\t\tnotification.notificationSessionKeys = encSessionKeys.map((esk) => {\n\t\t\t\treturn createNotificationSessionKey({\n\t\t\t\t\tpushIdentifier: esk.identifierId,\n\t\t\t\t\tpushIdentifierSessionEncSessionKey: esk.pushIdentifierSessionEncSessionKey,\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate async saveMultipleAlarms(\n\t\tuser: User,\n\t\teventsWrapper: Array<{\n\t\t\tevent: CalendarEvent\n\t\t\talarms: ReadonlyArray<AlarmInfoTemplate>\n\t\t}>,\n\t): Promise<Array<AlarmNotificationsPerEvent>> {\n\t\tconst userAlarmInfosAndNotificationsPerEvent: Array<{\n\t\t\tevent: CalendarEvent\n\t\t\tuserAlarmInfoAndNotification: Array<{\n\t\t\t\talarm: UserAlarmInfo\n\t\t\t\talarmNotification: AlarmNotification\n\t\t\t}>\n\t\t}> = []\n\t\tconst userAlarmInfoListId = neverNull(user.alarmInfoList).alarms\n\t\tconst ownerGroup = user.userGroup.group\n\n\t\tfor (const { event, alarms } of eventsWrapper) {\n\t\t\tconst userAlarmInfoAndNotification: Array<{\n\t\t\t\talarm: UserAlarmInfo\n\t\t\t\talarmNotification: AlarmNotification\n\t\t\t}> = []\n\t\t\tconst calendarRef = createCalendarEventRef({\n\t\t\t\tlistId: listIdPart(event._id),\n\t\t\t\telementId: elementIdPart(event._id),\n\t\t\t})\n\n\t\t\tfor (const alarmInfo of alarms) {\n\t\t\t\tconst userAlarmInfo = createUserAlarmInfo({\n\t\t\t\t\t_ownerGroup: ownerGroup,\n\t\t\t\t\talarmInfo: createAlarmInfo({\n\t\t\t\t\t\talarmIdentifier: alarmInfo.alarmIdentifier,\n\t\t\t\t\t\ttrigger: alarmInfo.trigger,\n\t\t\t\t\t\tcalendarRef: calendarRef,\n\t\t\t\t\t}),\n\t\t\t\t})\n\n\t\t\t\tconst alarmNotification = createAlarmNotificationForEvent(event, userAlarmInfo.alarmInfo, user._id)\n\t\t\t\tuserAlarmInfoAndNotification.push({\n\t\t\t\t\talarm: userAlarmInfo,\n\t\t\t\t\talarmNotification,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tuserAlarmInfosAndNotificationsPerEvent.push({\n\t\t\t\tevent,\n\t\t\t\tuserAlarmInfoAndNotification,\n\t\t\t})\n\t\t}\n\n\t\tconst allAlarms = userAlarmInfosAndNotificationsPerEvent.flatMap(({ userAlarmInfoAndNotification }) =>\n\t\t\tuserAlarmInfoAndNotification.map(({ alarm }) => alarm),\n\t\t)\n\n\t\tconst alarmIds: Array<Id> = await this.cachingEntityClient.setupMultipleEntities(userAlarmInfoListId, allAlarms)\n\t\tlet currentIndex = 0\n\t\treturn userAlarmInfosAndNotificationsPerEvent.map(({ event, userAlarmInfoAndNotification }) => {\n\t\t\treturn {\n\t\t\t\tevent,\n\t\t\t\talarmInfoIds: userAlarmInfoAndNotification.map(() => [userAlarmInfoListId, alarmIds[currentIndex++]]),\n\t\t\t\talarmNotifications: userAlarmInfoAndNotification.map(({ alarmNotification }) => alarmNotification),\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate getEntityClient(cacheMode: CachingMode): EntityClient {\n\t\tif (cacheMode === CachingMode.Cached) {\n\t\t\treturn this.cachingEntityClient\n\t\t} else {\n\t\t\treturn this.noncachingEntityClient\n\t\t}\n\t}\n}\n\nexport type EventWithUserAlarmInfos = {\n\tevent: CalendarEvent\n\tuserAlarmInfos: Array<UserAlarmInfo>\n}\n\nfunction createAlarmNotificationForEvent(event: CalendarEvent, alarmInfo: AlarmInfo, userId: Id): AlarmNotification {\n\treturn createAlarmNotification({\n\t\talarmInfo: createAlarmInfoForAlarmInfo(alarmInfo),\n\t\trepeatRule: event.repeatRule && createRepeatRuleForCalendarRepeatRule(event.repeatRule),\n\t\tnotificationSessionKeys: [],\n\t\toperation: OperationType.CREATE,\n\t\tsummary: event.summary,\n\t\teventStart: event.startTime,\n\t\teventEnd: event.endTime,\n\t\tuser: userId,\n\t})\n}\n\nfunction createAlarmInfoForAlarmInfo(alarmInfo: AlarmInfo): AlarmInfo {\n\tconst calendarRef = createCalendarEventRef({\n\t\telementId: alarmInfo.calendarRef.elementId,\n\t\tlistId: alarmInfo.calendarRef.listId,\n\t})\n\treturn createAlarmInfo({\n\t\talarmIdentifier: alarmInfo.alarmIdentifier,\n\t\ttrigger: alarmInfo.trigger,\n\t\tcalendarRef,\n\t})\n}\n\nfunction createRepeatRuleForCalendarRepeatRule(calendarRepeatRule: CalendarRepeatRule): RepeatRule {\n\treturn createRepeatRule({\n\t\tendType: calendarRepeatRule.endType,\n\t\tendValue: calendarRepeatRule.endValue,\n\t\tfrequency: calendarRepeatRule.frequency,\n\t\tinterval: calendarRepeatRule.interval,\n\t\ttimeZone: calendarRepeatRule.timeZone,\n\t\texcludedDates: calendarRepeatRule.excludedDates.map(({ date }) => createDateWrapper({ date })),\n\t\tadvancedRules: calendarRepeatRule.advancedRules,\n\t})\n}\n\nfunction getEventIdFromUserAlarmInfo(userAlarmInfo: UserAlarmInfo): IdTuple {\n\treturn [userAlarmInfo.alarmInfo.calendarRef.listId, userAlarmInfo.alarmInfo.calendarRef.elementId]\n}\n\n/** to make lookup on the encrypted event uid possible, we hash it and use that value as a key. */\nfunction hashUid(uid: string): Uint8Array {\n\treturn sha256Hash(stringToUtf8Uint8Array(uid))\n}\n\n/**\n * sort a list of events by recurrence id, sorting events without a recurrence id to the front.\n * @param arr the array of events to sort\n * exported for testing.\n */\nexport function sortByRecurrenceId(arr: Array<CalendarEventAlteredInstance>): void {\n\tarr.sort((a, b) => (a.recurrenceId.getTime() < b.recurrenceId.getTime() ? -1 : 1))\n}\n\nasync function loadAlteredInstancesFromIndexEntry(entityClient: EntityClient, indexEntry: CalendarEventUidIndex): Promise<Array<CalendarEventAlteredInstance>> {\n\tif (indexEntry.alteredInstances.length === 0) return []\n\tconst indexedEventIds: Map<Id, Array<Id>> = groupByAndMap<IdTuple, Id, Id>(\n\t\tindexEntry.alteredInstances,\n\t\t(e: IdTuple) => listIdPart(e),\n\t\t(e: IdTuple) => elementIdPart(e),\n\t)\n\n\tconst isAlteredInstance = (e: CalendarEventAlteredInstance): e is CalendarEventAlteredInstance => e.recurrenceId != null && e.uid != null\n\tconst indexedEvents = await loadMultipleFromLists(CalendarEventTypeRef, entityClient, indexEntry.alteredInstances)\n\tconst alteredInstances: Array<CalendarEventAlteredInstance> = indexedEvents.filter(isAlteredInstance)\n\tif (indexedEvents.length > alteredInstances.length) {\n\t\tconsole.warn(\"there were altered instances indexed that do not have a recurrence Id or uid!\")\n\t}\n\tsortByRecurrenceId(alteredInstances)\n\treturn alteredInstances\n}\n\nasync function loadProgenitorFromIndexEntry(entityClient: EntityClient, indexEntry: CalendarEventUidIndex): Promise<CalendarEventProgenitor | null> {\n\tif (indexEntry.progenitor == null) return null\n\tconst loadedProgenitor = await entityClient.load<CalendarEvent>(CalendarEventTypeRef, indexEntry.progenitor)\n\tif (loadedProgenitor.recurrenceId != null) {\n\t\tthrow new ProgrammingError(`loaded progenitor has a recurrence Id! ${loadedProgenitor.recurrenceId.toISOString()}`)\n\t}\n\tassertNotNull(loadedProgenitor.uid, \"loaded progenitor has no UID\")\n\treturn loadedProgenitor as CalendarEventProgenitor\n}\n\nexport const enum CachingMode {\n\tCached,\n\tBypass,\n}\n\nexport type AlarmInfoTemplate = Pick<AlarmInfo, \"alarmIdentifier\" | \"trigger\">\n"],"mappings":"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"}