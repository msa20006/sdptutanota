{"version":3,"file":"MailViewModel-BI0SdEEY.js","names":["mailboxModel: MailboxModel","mailModel: MailModel","entityClient: EntityClient","eventController: EventController","connectivityModel: WebsocketConnectivityModel","cacheStorage: ExposedCacheStorage","conversationViewModelFactory: ConversationViewModelFactory","mailOpenedListener: MailOpenedListener","conversationPrefProvider: ConversationPrefProvider","inboxRuleHandler: InboxRuleHandler","router: Router","updateUi: () => unknown","filter: MailFilterType | null","mailsetId?: Id","mailId?: Id","fullMailId: IdTuple","onMissingExplicitMailTarget: () => unknown","stickyMailId: IdTuple","folder?: MailFolder | null","folderArgument: MailFolder | null","listId: Id","mailId: Id","onMissingTargetEmail: () => unknown","expectedStickyMailId: IdTuple","mail: Mail | null","mail: Mail","expectedId: IdTuple","message: string","folder: MailFolder","_folderId: Id","itemsWhenCalled: ReadonlyArray<Mail>","newState: ListState<Mail>","params: Record<string, unknown>","viewModelParams: CreateMailViewerOptions","updates: ReadonlyArray<EntityUpdateData>","importMailStateUpdates: Array<EntityUpdateData>","update","update: EntityUpdateData","importedMailSetEntries: MailSetEntry[]","mailIds","folderType: Omit<MailSetKind, MailSetKind.CUSTOM>","clearSelectionOnMultiSelectStart?: boolean","multiselect: boolean","mailbox: MailBox","labelData: { name: string; color: string }","label: MailFolder","newData: { name: string; color: string }"],"sources":["../../src/mail-app/mail/view/MailViewModel.ts"],"sourcesContent":["import { MailboxDetail, MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport {\n\tImportedMailTypeRef,\n\tImportMailStateTypeRef,\n\tMail,\n\tMailBox,\n\tMailFolder,\n\tMailSetEntry,\n\tMailSetEntryTypeRef,\n\tMailTypeRef,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport {\n\tdeconstructMailSetEntryId,\n\telementIdPart,\n\tfirstBiggerThanSecond,\n\tgetElementId,\n\tisSameId,\n\tlistIdPart,\n} from \"../../../common/api/common/utils/EntityUtils.js\"\nimport {\n\tassertNotNull,\n\tcount,\n\tdebounce,\n\tfirst,\n\tgroupBy,\n\tisNotEmpty,\n\tlastThrow,\n\tlazyMemoized,\n\tmapWith,\n\tmapWithout,\n\tmemoized,\n\tofClass,\n\tpromiseMap,\n} from \"@tutao/tutanota-utils\"\nimport { ListState } from \"../../../common/gui/base/List.js\"\nimport { ConversationPrefProvider, ConversationViewModel, ConversationViewModelFactory } from \"./ConversationViewModel.js\"\nimport { CreateMailViewerOptions } from \"./MailViewer.js\"\nimport { isOfflineError } from \"../../../common/api/common/utils/ErrorUtils.js\"\nimport { getMailSetKind, ImportStatus, MailSetKind, OperationType } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { WsConnectionState } from \"../../../common/api/main/WorkerClient.js\"\nimport { WebsocketConnectivityModel } from \"../../../common/misc/WebsocketConnectivityModel.js\"\nimport { ExposedCacheStorage } from \"../../../common/api/worker/rest/DefaultEntityRestCache.js\"\nimport { NotAuthorizedError, NotFoundError, PreconditionFailedError } from \"../../../common/api/common/error/RestError.js\"\nimport { UserError } from \"../../../common/api/main/UserError.js\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError.js\"\nimport Stream from \"mithril/stream\"\nimport { InboxRuleHandler } from \"../model/InboxRuleHandler.js\"\nimport { Router } from \"../../../common/gui/ScopedRouter.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport { EventController } from \"../../../common/api/main/EventController.js\"\nimport { MailModel } from \"../model/MailModel.js\"\nimport { assertSystemFolderOfType } from \"../model/MailUtils.js\"\nimport { getMailFilterForType, MailFilterType } from \"./MailViewerUtils.js\"\nimport { CacheMode } from \"../../../common/api/worker/rest/EntityRestClient.js\"\nimport { isOfTypeOrSubfolderOf, isSpamOrTrashFolder, isSubfolderOfType } from \"../model/MailChecks.js\"\nimport { MailListModel } from \"../model/MailListModel\"\n\nexport interface MailOpenedListener {\n\tonEmailOpened(mail: Mail): unknown\n}\n\nconst TAG = \"MailVM\"\n\n/** ViewModel for the overall mail view. */\nexport class MailViewModel {\n\tprivate _folder: MailFolder | null = null\n\t/** id of the mail that was requested to be displayed, independent of the list state. */\n\tprivate stickyMailId: IdTuple | null = null\n\t/**\n\t * When the URL contains both folder id and mail id we will try to select that mail but we might need to load the list until we find it.\n\t * This is that mail id that we are loading.\n\t */\n\tprivate loadingTargetId: Id | null = null\n\tprivate conversationViewModel: ConversationViewModel | null = null\n\tprivate _filterType: MailFilterType | null = null\n\n\t/**\n\t * We remember the last URL used for each folder so if we switch between folders we can keep the selected mail.\n\t * There's a similar (but different) hacky mechanism where we store last URL but per each top-level view: navButtonRoutes. This one is per folder.\n\t */\n\tprivate mailFolderElementIdToSelectedMailId: ReadonlyMap<Id, Id> = new Map()\n\tprivate listStreamSubscription: Stream<unknown> | null = null\n\tprivate conversationPref: boolean = false\n\t/** A slightly hacky marker to avoid concurrent URL updates. */\n\tprivate currentShowTargetMarker: object = {}\n\n\tconstructor(\n\t\tprivate readonly mailboxModel: MailboxModel,\n\t\tprivate readonly mailModel: MailModel,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly connectivityModel: WebsocketConnectivityModel,\n\t\tprivate readonly cacheStorage: ExposedCacheStorage,\n\t\tprivate readonly conversationViewModelFactory: ConversationViewModelFactory,\n\t\tprivate readonly mailOpenedListener: MailOpenedListener,\n\t\tprivate readonly conversationPrefProvider: ConversationPrefProvider,\n\t\tprivate readonly inboxRuleHandler: InboxRuleHandler,\n\t\tprivate readonly router: Router,\n\t\tprivate readonly updateUi: () => unknown,\n\t) {}\n\n\tgetSelectedMailSetKind(): MailSetKind | null {\n\t\treturn this._folder ? getMailSetKind(this._folder) : null\n\t}\n\n\tget filterType(): MailFilterType | null {\n\t\treturn this._filterType\n\t}\n\n\tsetFilter(filter: MailFilterType | null) {\n\t\tthis._filterType = filter\n\t\tthis.listModel?.setFilter(getMailFilterForType(filter))\n\t}\n\n\tasync showMailWithMailSetId(mailsetId?: Id, mailId?: Id): Promise<void> {\n\t\tconst showMailMarker = {}\n\t\tthis.currentShowTargetMarker = showMailMarker\n\t\tif (mailsetId) {\n\t\t\tconst mailset = await this.mailModel.getMailSetById(mailsetId)\n\t\t\tif (showMailMarker !== this.currentShowTargetMarker) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (mailset) {\n\t\t\t\treturn this.showMail(mailset, mailId)\n\t\t\t}\n\t\t}\n\t\treturn this.showMail(null, mailId)\n\t}\n\n\tasync showStickyMail(fullMailId: IdTuple, onMissingExplicitMailTarget: () => unknown): Promise<void> {\n\t\tconst [listId, elementId] = fullMailId\n\t\t// If we are already displaying the requested email, do nothing\n\t\tif (this.conversationViewModel && isSameId(this.conversationViewModel.primaryMail._id, elementId)) {\n\t\t\treturn\n\t\t}\n\t\tif (isSameId(this.stickyMailId, fullMailId)) {\n\t\t\treturn\n\t\t}\n\n\t\tconsole.log(TAG, \"Loading sticky mail\", listId, elementId)\n\t\tthis.stickyMailId = fullMailId\n\n\t\t// This should be very quick as we only wait for the cache,\n\t\tawait this.loadExplicitMailTarget(listId, elementId, onMissingExplicitMailTarget)\n\t}\n\n\tprivate async resetOrInitializeList(stickyMailId: IdTuple) {\n\t\tif (this._folder != null) {\n\t\t\t// If we already have a folder, deselect.\n\t\t\tthis.listModel?.selectNone()\n\t\t} else {\n\t\t\t// Otherwise, load the inbox so that it won't be empty on mobile when you try to go back.\n\t\t\tconst userInbox = await this.getFolderForUserInbox()\n\n\t\t\tif (this.didStickyMailChange(stickyMailId, \"after loading user inbox ID\")) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.setListId(userInbox)\n\t\t}\n\t}\n\n\tprivate async showMail(folder?: MailFolder | null, mailId?: Id) {\n\t\t// an optimization to not open an email that we already display\n\t\tif (folder != null && mailId != null && this.conversationViewModel && isSameId(elementIdPart(this.conversationViewModel.primaryMail._id), mailId)) {\n\t\t\treturn\n\t\t}\n\t\t// If we are already loading towards the email that is passed to us in the URL then we don't need to do anything. We already updated URL on the\n\t\t// previous call.\n\t\tif (\n\t\t\tfolder != null &&\n\t\t\tmailId != null &&\n\t\t\tthis._folder &&\n\t\t\tthis.loadingTargetId &&\n\t\t\tisSameId(folder._id, this._folder._id) &&\n\t\t\tisSameId(this.loadingTargetId, mailId)\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tconsole.log(TAG, \"showMail\", folder?._id, mailId)\n\n\t\t// important: to set it early enough because setting listId will trigger URL update.\n\t\t// if we don't set this one before setListId, url update will cause this function to be called again but without target mail, and we will lose the\n\t\t// target id\n\t\tconst loadingTargetId = mailId ?? null\n\t\tthis.loadingTargetId = loadingTargetId\n\n\t\t// if the URL has changed then we probably want to reset the explicitly shown email\n\t\tthis.stickyMailId = null\n\n\t\tconst folderToUse = await this.selectFolderToUse(folder ?? null)\n\t\t// Selecting folder is async, check that the target hasn't changed inbetween\n\t\tif (this.loadingTargetId !== loadingTargetId) return\n\n\t\t// This will cause a URL update indirectly\n\t\tthis.setListId(folderToUse)\n\n\t\t// If we have a mail that should be selected start loading towards it.\n\t\t// We already checked in the beginning that we are not loading to the same target. We set the loadingTarget early so there should be no races.\n\t\tif (loadingTargetId) {\n\t\t\t// Record the selected mail for the folder\n\t\t\tthis.mailFolderElementIdToSelectedMailId = mapWith(this.mailFolderElementIdToSelectedMailId, getElementId(folderToUse), loadingTargetId)\n\t\t\ttry {\n\t\t\t\tawait this.loadAndSelectMail(folderToUse, loadingTargetId)\n\t\t\t} finally {\n\t\t\t\t// We either selected the mail and we don't need the target anymore or we didn't find it and we should remove the target\n\t\t\t\tthis.loadingTargetId = null\n\t\t\t}\n\t\t} else {\n\t\t\t// update URL if the view was just opened without any url params\n\t\t\t// setListId might not have done it if the list didn't change for us internally but is changed for the view\n\t\t\tif (folder == null) this.updateUrl()\n\t\t}\n\t}\n\n\tprivate async selectFolderToUse(folderArgument: MailFolder | null): Promise<MailFolder> {\n\t\tif (folderArgument) {\n\t\t\tconst mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(folderArgument)\n\t\t\tif (mailboxDetail) {\n\t\t\t\treturn folderArgument\n\t\t\t} else {\n\t\t\t\treturn await this.getFolderForUserInbox()\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._folder ?? (await this.getFolderForUserInbox())\n\t\t}\n\t}\n\n\tprivate async loadExplicitMailTarget(listId: Id, mailId: Id, onMissingTargetEmail: () => unknown) {\n\t\tconst expectedStickyMailId: IdTuple = [listId, mailId]\n\n\t\t// First try getting the mail from the list. We don't need to do anything more if we can simply select it, as\n\t\t// getting the mail is completely synchronous.\n\t\tconst mailInList = this.listModel?.getMail(mailId)\n\t\tif (mailInList) {\n\t\t\tconsole.log(TAG, \"opening mail from list\", mailId)\n\t\t\tthis.listModel?.onSingleSelection(mailInList)\n\t\t\treturn\n\t\t}\n\n\t\t// Load the cached mail to display it sooner.\n\t\t// We still want to load the mail remotely, though, to make sure that it won't disappear due to being moved.\n\t\tconst cached = await this.cacheStorage.get(MailTypeRef, listId, mailId)\n\t\tif (this.didStickyMailChange(expectedStickyMailId, \"after loading cached\")) {\n\t\t\treturn\n\t\t}\n\t\tif (cached) {\n\t\t\tconsole.log(TAG, \"displaying cached mail\", mailId)\n\t\t\tawait this.displayExplicitMailTarget(cached)\n\t\t}\n\n\t\tlet mail: Mail | null\n\t\ttry {\n\t\t\tmail = await this.entityClient.load(MailTypeRef, [listId, mailId], { cacheMode: CacheMode.WriteOnly })\n\t\t} catch (e) {\n\t\t\tif (isOfflineError(e)) {\n\t\t\t\treturn\n\t\t\t} else if (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\tmail = null\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t\tif (this.didStickyMailChange(expectedStickyMailId, \"after loading from entity client\")) {\n\t\t\treturn\n\t\t}\n\n\t\t// If the user has migrated to mailsets, simply checking if Mail exists won't be enough.\n\t\t// Instead, we check against the sets in the Mail and see if it's moved folders since the last sync.\n\t\t// We have to do this because if the mail did move since the last sync, it will still disappear from view.\n\t\tlet movedSetsSinceLastSync = false\n\t\tif (mail != null && cached != null && cached.sets.length > 0) {\n\t\t\t// This will most likely be the inbox\n\t\t\tconst currentFolderId = elementIdPart(assertNotNull(this._folder, \"cached was displayed earlier, thus folder would have been set\")._id)\n\t\t\t// This can be false if the mail was moved while the user is logged in, which is fine, and we don't need to check the loaded mail\n\t\t\tconst cachedMailInFolder = cached.sets.some((id) => elementIdPart(id) === currentFolderId)\n\t\t\tmovedSetsSinceLastSync = cachedMailInFolder && !mail.sets.some((id) => elementIdPart(id) === currentFolderId)\n\t\t}\n\n\t\tif (!movedSetsSinceLastSync && mail != null) {\n\t\t\tconsole.log(TAG, \"opening mail from entity client\", mailId)\n\t\t\tawait this.displayExplicitMailTarget(mail)\n\t\t} else {\n\t\t\tif (mail != null) {\n\t\t\t\tconsole.log(TAG, \"Explicit mail target moved sets\", listId, mailId)\n\t\t\t} else {\n\t\t\t\tconsole.log(TAG, \"Explicit mail target not found\", listId, mailId)\n\t\t\t}\n\t\t\tonMissingTargetEmail()\n\t\t\t// We already know that email is not there, we can reset the target here and avoid list loading\n\t\t\tthis.stickyMailId = null\n\t\t\tthis.updateUrl()\n\t\t}\n\t}\n\n\tprivate async displayExplicitMailTarget(mail: Mail) {\n\t\tawait this.resetOrInitializeList(mail._id)\n\t\tthis.createConversationViewModel({ mail, showFolder: false })\n\t\tthis.updateUi()\n\t}\n\n\tprivate didStickyMailChange(expectedId: IdTuple, message: string): boolean {\n\t\tconst changed = !isSameId(this.stickyMailId, expectedId)\n\t\tif (changed) {\n\t\t\tconsole.log(TAG, \"target mail id changed\", message, expectedId, this.stickyMailId)\n\t\t}\n\t\treturn changed\n\t}\n\n\tprivate async loadAndSelectMail(folder: MailFolder, mailId: Id) {\n\t\tconst foundMail = await this.listModel?.loadAndSelect(\n\t\t\tmailId,\n\t\t\t() =>\n\t\t\t\t// if we changed the list, stop\n\t\t\t\tthis.getFolder() !== folder ||\n\t\t\t\t// if listModel is gone for some reason, stop\n\t\t\t\t!this.listModel ||\n\t\t\t\t// if the target mail has changed, stop\n\t\t\t\tthis.loadingTargetId !== mailId ||\n\t\t\t\t// if we loaded past the target item we won't find it, stop\n\t\t\t\t(this.listModel.items.length > 0 && firstBiggerThanSecond(mailId, getElementId(lastThrow(this.listModel.items)))),\n\t\t)\n\t\tif (foundMail == null) {\n\t\t\tconsole.log(\"did not find mail\", folder, mailId)\n\t\t}\n\t}\n\n\tprivate async getFolderForUserInbox(): Promise<MailFolder> {\n\t\tconst mailboxDetail = await this.mailboxModel.getUserMailboxDetails()\n\t\tconst folders = await this.mailModel.getMailboxFoldersForId(assertNotNull(mailboxDetail.mailbox.folders)._id)\n\t\treturn assertSystemFolderOfType(folders, MailSetKind.INBOX)\n\t}\n\n\tinit() {\n\t\tthis.singInit()\n\t\tconst conversationEnabled = this.conversationPrefProvider.getConversationViewShowOnlySelectedMail()\n\t\tif (this.conversationViewModel && this.conversationPref !== conversationEnabled) {\n\t\t\tconst mail = this.conversationViewModel.primaryMail\n\t\t\tthis.createConversationViewModel({\n\t\t\t\tmail,\n\t\t\t\tshowFolder: false,\n\t\t\t\tdelayBodyRenderingUntil: Promise.resolve(),\n\t\t\t})\n\t\t\tthis.mailOpenedListener.onEmailOpened(mail)\n\t\t}\n\t\tthis.conversationPref = conversationEnabled\n\t}\n\n\tprivate readonly singInit = lazyMemoized(() => {\n\t\tthis.eventController.addEntityListener((updates) => this.entityEventsReceived(updates))\n\t})\n\n\tget listModel(): MailListModel | null {\n\t\treturn this._folder ? this.listModelForFolder(getElementId(this._folder)) : null\n\t}\n\n\tgetMailFolderToSelectedMail(): ReadonlyMap<Id, Id> {\n\t\treturn this.mailFolderElementIdToSelectedMailId\n\t}\n\n\tgetFolder(): MailFolder | null {\n\t\treturn this._folder\n\t}\n\n\tgetLabelsForMail(mail: Mail): ReadonlyArray<MailFolder> {\n\t\treturn this.listModel?.getLabelsForMail(mail) ?? []\n\t}\n\n\tprivate setListId(folder: MailFolder) {\n\t\tif (folder === this._folder) {\n\t\t\treturn\n\t\t}\n\t\t// Cancel old load all\n\t\tthis.listModel?.cancelLoadAll()\n\t\tthis._filterType = null\n\n\t\tthis._folder = folder\n\t\tthis.listStreamSubscription?.end(true)\n\t\tthis.listStreamSubscription = this.listModel!.stateStream.map((state) => this.onListStateChange(state))\n\t\tthis.listModel!.loadInitial().then(() => {\n\t\t\tif (this.listModel != null && this._folder === folder) {\n\t\t\t\tthis.fixCounterIfNeeded(folder, this.listModel.items)\n\t\t\t}\n\t\t})\n\t}\n\n\tgetConversationViewModel(): ConversationViewModel | null {\n\t\treturn this.conversationViewModel\n\t}\n\n\tprivate listModelForFolder = memoized((_folderId: Id) => {\n\t\t// Capture state to avoid race conditions.\n\t\t// We need to populate mail set entries cache when loading mails so that we can react to updates later.\n\t\tconst folder = assertNotNull(this._folder)\n\t\treturn new MailListModel(folder, this.conversationPrefProvider, this.entityClient, this.mailModel, this.inboxRuleHandler, this.cacheStorage)\n\t})\n\n\tprivate fixCounterIfNeeded: (folder: MailFolder, itemsWhenCalled: ReadonlyArray<Mail>) => void = debounce(\n\t\t2000,\n\t\tasync (folder: MailFolder, itemsWhenCalled: ReadonlyArray<Mail>) => {\n\t\t\tconst ourFolder = this.getFolder()\n\t\t\tif (ourFolder == null || (this._filterType != null && this.filterType !== MailFilterType.Unread)) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If folders are changed, list won't have the data we need.\n\t\t\t// Do not rely on counters if we are not connected\n\t\t\tif (!isSameId(getElementId(ourFolder), getElementId(folder)) || this.connectivityModel.wsConnection()() !== WsConnectionState.connected) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If list was modified in the meantime, we cannot be sure that we will fix counters correctly (e.g. because of the inbox rules)\n\t\t\tif (this.listModel?.items !== itemsWhenCalled) {\n\t\t\t\tconsole.log(`list changed, trying again later`)\n\t\t\t\treturn this.fixCounterIfNeeded(folder, this.listModel?.items ?? [])\n\t\t\t}\n\n\t\t\tconst unreadMailsCount = count(this.listModel.items, (e) => e.unread)\n\n\t\t\tconst counterValue = await this.mailModel.getCounterValue(folder)\n\t\t\tif (counterValue != null && counterValue !== unreadMailsCount) {\n\t\t\t\tconsole.log(`fixing up counter for folder ${folder._id}`)\n\t\t\t\tawait this.mailModel.fixupCounterForFolder(folder, unreadMailsCount)\n\t\t\t} else {\n\t\t\t\tconsole.log(`same counter, no fixup on folder ${folder._id}`)\n\t\t\t}\n\t\t},\n\t)\n\n\tprivate onListStateChange(newState: ListState<Mail>) {\n\t\t// If we are already displaying sticky mail just leave it alone, no matter what's happening to the list.\n\t\t// User actions and URL updated do reset sticky mail id.\n\t\tconst displayedMailId = this.conversationViewModel?.primaryViewModel()?.mail._id\n\t\tif (!(displayedMailId && isSameId(displayedMailId, this.stickyMailId))) {\n\t\t\tconst targetItem = this.stickyMailId\n\t\t\t\t? newState.items.find((item) => isSameId(this.stickyMailId, item._id))\n\t\t\t\t: !newState.inMultiselect && newState.selectedItems.size === 1\n\t\t\t\t? first(this.listModel!.getSelectedAsArray())\n\t\t\t\t: null\n\t\t\tif (targetItem != null) {\n\t\t\t\t// Always write the targetItem in case it was not written before but already being displayed (sticky mail)\n\t\t\t\tthis.mailFolderElementIdToSelectedMailId = mapWith(\n\t\t\t\t\tthis.mailFolderElementIdToSelectedMailId,\n\t\t\t\t\tgetElementId(assertNotNull(this.getFolder())),\n\t\t\t\t\tgetElementId(targetItem),\n\t\t\t\t)\n\t\t\t\tif (!this.conversationViewModel || !isSameId(this.conversationViewModel?.primaryMail._id, targetItem._id)) {\n\t\t\t\t\tthis.createConversationViewModel({\n\t\t\t\t\t\tmail: targetItem,\n\t\t\t\t\t\tshowFolder: false,\n\t\t\t\t\t})\n\t\t\t\t\tthis.mailOpenedListener.onEmailOpened(targetItem)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.conversationViewModel?.dispose()\n\t\t\t\tthis.conversationViewModel = null\n\t\t\t\tthis.mailFolderElementIdToSelectedMailId = mapWithout(this.mailFolderElementIdToSelectedMailId, getElementId(assertNotNull(this.getFolder())))\n\t\t\t}\n\t\t}\n\t\tthis.updateUrl()\n\t\tthis.updateUi()\n\t}\n\n\tprivate updateUrl() {\n\t\tconst folder = this._folder\n\t\tconst folderId = folder ? getElementId(folder) : null\n\t\t// If we are loading towards an email we want to keep it in the URL, otherwise we will reset it.\n\t\t// Otherwise, if we have a single selected email then that should be in the URL.\n\t\tconst mailId = this.loadingTargetId ?? (folderId ? this.getMailFolderToSelectedMail().get(folderId) : null)\n\t\tconst stickyMail = this.stickyMailId\n\n\t\tif (mailId != null) {\n\t\t\tthis.router.routeTo(\n\t\t\t\t\"/mail/:folderId/:mailId\",\n\t\t\t\tthis.addStickyMailParam({\n\t\t\t\t\tfolderId,\n\t\t\t\t\tmailId,\n\t\t\t\t\tmail: stickyMail,\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\tthis.router.routeTo(\"/mail/:folderId\", this.addStickyMailParam({ folderId: folderId ?? \"\" }))\n\t\t}\n\t}\n\n\tprivate addStickyMailParam(params: Record<string, unknown>): typeof params {\n\t\tif (this.stickyMailId) {\n\t\t\tparams.mail = this.stickyMailId.join(\",\")\n\t\t}\n\t\treturn params\n\t}\n\n\tprivate createConversationViewModel(viewModelParams: CreateMailViewerOptions) {\n\t\tthis.conversationViewModel?.dispose()\n\t\tthis.conversationViewModel = this.conversationViewModelFactory(viewModelParams)\n\t}\n\n\tprivate async entityEventsReceived(updates: ReadonlyArray<EntityUpdateData>) {\n\t\t// capturing the state so that if we switch folders we won't run into race conditions\n\t\tconst folder = this._folder\n\t\tconst listModel = this.listModel\n\n\t\tif (!folder || !listModel) {\n\t\t\treturn\n\t\t}\n\n\t\tlet importMailStateUpdates: Array<EntityUpdateData> = []\n\t\tfor (const update of updates) {\n\t\t\tif (isUpdateForTypeRef(MailSetEntryTypeRef, update) && isSameId(folder.entries, update.instanceListId)) {\n\t\t\t\tif (update.operation === OperationType.DELETE && this.stickyMailId != null) {\n\t\t\t\t\tconst { mailId } = deconstructMailSetEntryId(update.instanceId)\n\t\t\t\t\tif (isSameId(mailId, elementIdPart(this.stickyMailId))) {\n\t\t\t\t\t\t// Reset target before we dispatch event to the list so that our handler in onListStateChange() has up-to-date state.\n\t\t\t\t\t\tthis.stickyMailId = null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tisUpdateForTypeRef(ImportMailStateTypeRef, update) &&\n\t\t\t\t(update.operation == OperationType.CREATE || update.operation == OperationType.UPDATE)\n\t\t\t) {\n\t\t\t\timportMailStateUpdates.push(update)\n\t\t\t}\n\n\t\t\tawait listModel.handleEntityUpdate(update)\n\t\t\tawait promiseMap(importMailStateUpdates, (update) => this.processImportedMails(update))\n\t\t}\n\t}\n\n\tprivate async processImportedMails(update: EntityUpdateData) {\n\t\tconst importMailState = await this.entityClient.load(ImportMailStateTypeRef, [update.instanceListId, update.instanceId])\n\t\tconst listModelOfImport = this.listModelForFolder(elementIdPart(importMailState.targetFolder))\n\n\t\tlet status = parseInt(importMailState.status) as ImportStatus\n\t\tif (status === ImportStatus.Finished || status === ImportStatus.Canceled) {\n\t\t\tlet importedMailEntries = await this.entityClient.loadAll(ImportedMailTypeRef, importMailState.importedMails)\n\t\t\tif (importedMailEntries.length === 0) return Promise.resolve()\n\n\t\t\tlet mailSetEntryIds = importedMailEntries.map((importedMail) => elementIdPart(importedMail.mailSetEntry))\n\t\t\tconst mailSetEntryListId = listIdPart(importedMailEntries[0].mailSetEntry)\n\t\t\tconst importedMailSetEntries = await this.entityClient.loadMultiple(MailSetEntryTypeRef, mailSetEntryListId, mailSetEntryIds)\n\t\t\tif (isNotEmpty(importedMailSetEntries)) {\n\t\t\t\t// put mails into cache before list model will download them one by one\n\t\t\t\tawait this.preloadMails(importedMailSetEntries)\n\n\t\t\t\tawait promiseMap(importedMailSetEntries, (importedMailSetEntry) => {\n\t\t\t\t\treturn listModelOfImport.handleEntityUpdate({\n\t\t\t\t\t\tinstanceListId: listIdPart(importedMailSetEntry._id),\n\t\t\t\t\t\tinstanceId: elementIdPart(importedMailSetEntry._id),\n\t\t\t\t\t\toperation: OperationType.CREATE,\n\t\t\t\t\t\ttype: MailSetEntryTypeRef.type,\n\t\t\t\t\t\tapplication: MailSetEntryTypeRef.app,\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async preloadMails(importedMailSetEntries: MailSetEntry[]) {\n\t\tconst mailIds = importedMailSetEntries.map((mse) => mse.mail)\n\t\tconst mailsByList = groupBy(mailIds, (m) => listIdPart(m))\n\t\tfor (const [listId, mailIds] of mailsByList.entries()) {\n\t\t\tconst mailElementIds = mailIds.map((m) => elementIdPart(m))\n\t\t\tawait this.entityClient.loadMultiple(MailTypeRef, listId, mailElementIds)\n\t\t}\n\t}\n\n\tasync switchToFolder(folderType: Omit<MailSetKind, MailSetKind.CUSTOM>): Promise<void> {\n\t\tconst state = {}\n\t\tthis.currentShowTargetMarker = state\n\t\tconst mailboxDetail = assertNotNull(await this.getMailboxDetails())\n\t\tif (this.currentShowTargetMarker !== state) {\n\t\t\treturn\n\t\t}\n\t\tif (mailboxDetail == null || mailboxDetail.mailbox.folders == null) {\n\t\t\treturn\n\t\t}\n\t\tconst folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id)\n\t\tif (this.currentShowTargetMarker !== state) {\n\t\t\treturn\n\t\t}\n\t\tconst folder = assertSystemFolderOfType(folders, folderType)\n\t\tawait this.showMail(folder, this.mailFolderElementIdToSelectedMailId.get(getElementId(folder)))\n\t}\n\n\tasync getMailboxDetails(): Promise<MailboxDetail> {\n\t\tconst folder = this.getFolder()\n\t\treturn await this.mailboxDetailForListWithFallback(folder)\n\t}\n\n\tasync showingDraftsFolder(): Promise<boolean> {\n\t\tif (!this._folder) return false\n\t\tconst mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(this._folder)\n\t\tconst selectedFolder = this.getFolder()\n\t\tif (selectedFolder && mailboxDetail && mailboxDetail.mailbox.folders) {\n\t\t\tconst folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id)\n\t\t\treturn isOfTypeOrSubfolderOf(folders, selectedFolder, MailSetKind.DRAFT)\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tasync showingTrashOrSpamFolder(): Promise<boolean> {\n\t\tconst folder = this.getFolder()\n\t\tif (folder) {\n\t\t\tconst mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(folder)\n\t\t\tif (folder && mailboxDetail && mailboxDetail.mailbox.folders) {\n\t\t\t\tconst folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id)\n\t\t\t\treturn isSpamOrTrashFolder(folders, folder)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tprivate async mailboxDetailForListWithFallback(folder?: MailFolder | null) {\n\t\tconst mailboxDetailForListId = folder ? await this.mailModel.getMailboxDetailsForMailFolder(folder) : null\n\t\treturn mailboxDetailForListId ?? (await this.mailboxModel.getUserMailboxDetails())\n\t}\n\n\tasync finallyDeleteAllMailsInSelectedFolder(folder: MailFolder): Promise<void> {\n\t\t// remove any selection to avoid that the next mail is loaded and selected for each deleted mail event\n\t\tthis.listModel?.selectNone()\n\n\t\tconst mailboxDetail = await this.getMailboxDetails()\n\n\t\t// the request is handled a little differently if it is the system folder vs a subfolder\n\t\tif (folder.folderType === MailSetKind.TRASH || folder.folderType === MailSetKind.SPAM) {\n\t\t\treturn this.mailModel.clearFolder(folder).catch(\n\t\t\t\tofClass(PreconditionFailedError, () => {\n\t\t\t\t\tthrow new UserError(\"operationStillActive_msg\")\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\tconst folders = await this.mailModel.getMailboxFoldersForId(assertNotNull(mailboxDetail.mailbox.folders)._id)\n\t\t\tif (isSubfolderOfType(folders, folder, MailSetKind.TRASH) || isSubfolderOfType(folders, folder, MailSetKind.SPAM)) {\n\t\t\t\treturn this.mailModel.finallyDeleteCustomMailFolder(folder).catch(\n\t\t\t\t\tofClass(PreconditionFailedError, () => {\n\t\t\t\t\t\tthrow new UserError(\"operationStillActive_msg\")\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthrow new ProgrammingError(`Cannot delete mails in folder ${String(folder._id)} with type ${folder.folderType}`)\n\t\t\t}\n\t\t}\n\t}\n\n\tonSingleSelection(mail: Mail) {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.onSingleSelection(mail)\n\t}\n\n\tareAllSelected(): boolean {\n\t\treturn this.listModel?.areAllSelected() ?? false\n\t}\n\n\tselectNone(): void {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.selectNone()\n\t}\n\n\tselectAll(): void {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.selectAll()\n\t}\n\n\tonSingleInclusiveSelection(mail: Mail, clearSelectionOnMultiSelectStart?: boolean) {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.onSingleInclusiveSelection(mail, clearSelectionOnMultiSelectStart)\n\t}\n\n\tonRangeSelectionTowards(mail: Mail) {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.selectRangeTowards(mail)\n\t}\n\n\tselectPrevious(multiselect: boolean) {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.selectPrevious(multiselect)\n\t}\n\n\tselectNext(multiselect: boolean) {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.selectNext(multiselect)\n\t}\n\n\tonSingleExclusiveSelection(mail: Mail) {\n\t\tthis.stickyMailId = null\n\t\tthis.loadingTargetId = null\n\t\tthis.listModel?.onSingleExclusiveSelection(mail)\n\t}\n\n\tasync createLabel(mailbox: MailBox, labelData: { name: string; color: string }) {\n\t\tawait this.mailModel.createLabel(assertNotNull(mailbox._ownerGroup), labelData)\n\t}\n\n\tasync editLabel(label: MailFolder, newData: { name: string; color: string }) {\n\t\tawait this.mailModel.updateLabel(label, newData)\n\t}\n\n\tasync deleteLabel(label: MailFolder) {\n\t\tawait this.mailModel.deleteLabel(label)\n\t}\n}\n"],"mappings":"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"}