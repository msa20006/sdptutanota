
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { assertNotNull, delay, downcast, filterNull, getAsLazy, identity, lazyMemoized, makeSingleUse, mapLazily, neverNull, noOp, resolveMaybeLazy } from "./dist-CJHwsXKY.js";
import { assertMainOrNode, assertMainOrNodeBoot } from "./Env-D5xGlXfw.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { AlphaEnum, DefaultAnimationTime, TransformEnum, alpha, animations, ease, getElevatedBackground, getSafeAreaInsetBottom, getSafeAreaInsetTop, isColorLight, opacity, px, size, styles, theme, transform } from "./HtmlUtils-C-ecR7U7.js";
import { client } from "./ClientDetector-D0v6Vqu6.js";
import { DEFAULT_ERROR, Keys, TabIndex } from "./TutanotaConstants-3bwAESYA.js";
import { BaseButton, BootIcons, Button, ButtonType, Icon, IconSize } from "./Icon-BuqNK7vz.js";
import { HabReminderImage } from "./Icons-Dl3nFav5.js";
import { focusNext, focusPrevious, isKeyPressed, keyManager, useKeyHandler } from "./KeyManager-B0OGXEyJ.js";
import { windowFacade } from "./WindowFacade-B9kSBKw7.js";
import { modal } from "./Modal-g4c-b9IU.js";
import { Countries } from "./CountryList-DkVQtcTj.js";
import { ButtonSize, IconButton } from "./IconButton-DsU60HJ_.js";
import { isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import { require_stream } from "./stream-u2PttBAC.js";

//#region ../src/common/gui/base/DialogHeaderBar.ts
var DialogHeaderBar = class {
	view(vnode) {
		const a = Object.assign({}, {
			left: [],
			right: []
		}, vnode.attrs);
		let columnClass = a.middle ? ".flex-third.overflow-hidden" : ".flex-half.overflow-hidden";
		return mithril_default(".dialog-header.plr-l.flex-space-between.dialog-header-line-height", {
			oncreate: ({ dom }) => {
				if (a.create) a.create(dom);
			},
			onremove: () => {
				if (a.remove) a.remove();
			},
			class: vnode.attrs.class
		}, [
			mithril_default(columnClass + ".ml-negative-s", resolveMaybeLazy(a.left).map((a$1) => mithril_default(Button, a$1))),
			a.middle ? mithril_default("#dialog-title.flex-third-middle.overflow-hidden.flex.justify-center.items-center.b", { "data-testid": `dialog:${lang.getTestId(a.middle)}` }, [mithril_default(".text-ellipsis", lang.getTranslationText(a.middle))]) : null,
			mithril_default(columnClass + ".mr-negative-s.flex.justify-end", resolveMaybeLazy(a.right).map((a$1) => mithril_default(Button, a$1)))
		]);
	}
};

//#endregion
//#region ../src/common/gui/base/PureComponent.ts
function pureComponent(factory) {
	return { view(vnode) {
		return factory(vnode.attrs, vnode.children);
	} };
}

//#endregion
//#region ../src/common/gui/base/buttons/RowButton.ts
var RowButton = class {
	view(vnode) {
		const attrs = vnode.attrs;
		const label = lang.getTranslationText(attrs.label);
		const text = lang.getTranslationText(attrs.text ?? attrs.label);
		const color = attrs.selected ? theme.content_button_selected : theme.content_button;
		return mithril_default(BaseButton, {
			label: attrs.label,
			text: mithril_default(".plr-button.text-ellipsis", {
				style: { color },
				ariaHidden: label !== text
			}, text),
			role: attrs.role,
			selected: attrs.selected,
			icon: attrs.icon && attrs.icon !== "none" ? mithril_default(Icon, {
				icon: attrs.icon,
				container: "div",
				class: "mr-button",
				style: { fill: color },
				size: IconSize.Medium
			}) : attrs.icon === "none" ? mithril_default(".icon-large.mr-button") : null,
			class: "flex items-center state-bg button-content plr-button " + attrs.class,
			style: {
				...attrs.style,
				color
			},
			onclick: attrs.onclick
		});
	}
};

//#endregion
//#region ../src/common/gui/AriaUtils.ts
assertMainOrNodeBoot();
let AriaLandmarks = function(AriaLandmarks$1) {
	AriaLandmarks$1["Banner"] = "banner";
	AriaLandmarks$1["Search"] = "search";
	AriaLandmarks$1["Navigation"] = "navigation";
	AriaLandmarks$1["Main"] = "main";
	AriaLandmarks$1["Complementary"] = "complementary";
	AriaLandmarks$1["Contentinfo"] = "contentinfo";
	AriaLandmarks$1["Region"] = "region";
	return AriaLandmarks$1;
}({});
let AriaLiveRegions = function(AriaLiveRegions$1) {
	AriaLiveRegions$1["Alert"] = "alert";
	AriaLiveRegions$1["Log"] = "log";
	AriaLiveRegions$1["Marquee"] = "Marquee";
	AriaLiveRegions$1["Status"] = "status";
	AriaLiveRegions$1["Timer"] = "timer";
	return AriaLiveRegions$1;
}({});
let AriaWindow = function(AriaWindow$1) {
	AriaWindow$1["AlertDialog"] = "alertdialog";
	AriaWindow$1["Dialog"] = "dialog";
	return AriaWindow$1;
}({});
var AriaLiveData = function(AriaLiveData$1) {
	AriaLiveData$1["Off"] = "off";
	AriaLiveData$1["Polite"] = "polite";
	AriaLiveData$1["Assertive"] = "assertive";
	return AriaLiveData$1;
}(AriaLiveData || {});
function liveDataAttrs() {
	return {
		"aria-live": AriaLiveData.Polite,
		"aria-atomic": "true"
	};
}
let AriaPopupType = function(AriaPopupType$1) {
	AriaPopupType$1["None"] = "false";
	AriaPopupType$1["Menu"] = "menu";
	AriaPopupType$1["ListBox"] = "listbox";
	AriaPopupType$1["Tree"] = "tree";
	AriaPopupType$1["Grid"] = "grid";
	AriaPopupType$1["Dialog"] = "dialog";
	return AriaPopupType$1;
}({});
let AriaRole = function(AriaRole$1) {
	AriaRole$1["Menu"] = "Menu";
	AriaRole$1["MenuItem"] = "menuitem";
	AriaRole$1["Combobox"] = "combobox";
	AriaRole$1["Listbox"] = "listbox";
	AriaRole$1["Option"] = "option";
	AriaRole$1["Switch"] = "switch";
	AriaRole$1["MenuItemCheckbox"] = "menuitemcheckbox";
	AriaRole$1["RadioGroup"] = "radiogroup";
	return AriaRole$1;
}({});
function landmarkAttrs(role, label) {
	return {
		class: "hide-outline",
		role,
		tabindex: TabIndex.Programmatic,
		"aria-label": label
	};
}

//#endregion
//#region ../src/common/gui/base/Dropdown.ts
assertMainOrNode();
/**
* Renders small info message inside the dropdown.
*/
const DropdownInfo = pureComponent(({ center, bold, info }) => {
	return mithril_default(".dropdown-info.text-break.selectable" + (center ? ".center" : "") + (bold ? ".b" : ""), info);
});
function isDropDownInfo(dropdownChild) {
	return Object.hasOwn(dropdownChild, "info") && Object.hasOwn(dropdownChild, "center") && Object.hasOwn(dropdownChild, "bold");
}
var DomRectReadOnlyPolyfilled = class {
	x;
	y;
	width;
	height;
	constructor(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}
	get top() {
		return this.height > 0 ? this.y : this.y + this.height;
	}
	get bottom() {
		return this.height > 0 ? this.y + this.height : this.y;
	}
	get left() {
		return this.width > 0 ? this.x : this.x + this.width;
	}
	get right() {
		return this.width > 0 ? this.x + this.width : this.x;
	}
};
var Dropdown = class Dropdown {
	children;
	domDropdown = null;
	origin = null;
	oninit;
	view;
	width;
	shortcuts;
	filterString;
	domInput = null;
	domContents = null;
	isFilterable = false;
	maxHeight = null;
	closeHandler = null;
	focusedBeforeShown = document.activeElement;
	constructor(lazyChildren, width) {
		this.children = [];
		this.width = width;
		this.filterString = "";
		this.oninit = () => {
			this.children = filterNull(lazyChildren());
			this.isFilterable = this.children.length > 10;
			this.children.map((child) => {
				if (isDropDownInfo(child)) return child;
				const buttonChild = child;
				buttonChild.click = this.wrapClick(child.click ? child.click : () => null);
				return child;
			});
		};
		let _shortcuts = this._createShortcuts();
		this.shortcuts = () => {
			return _shortcuts;
		};
		const inputField = () => {
			return this.isFilterable ? mithril_default("input.input.dropdown-bar.elevated-bg.doNotClose.button-height.button-min-height.pr-s", {
				placeholder: lang.get("typeToFilter_label"),
				oncreate: (vnode) => {
					this.domInput = downcast(vnode.dom);
					this.domInput.value = this.filterString;
				},
				oninput: () => {
					this.filterString = neverNull(this.domInput).value;
				},
				style: { paddingLeft: px(size.hpad_large * 2) }
			}, this.filterString) : null;
		};
		const contents = () => {
			const showingIcons = this.children.some((c) => "icon" in c && typeof c.icon !== "undefined");
			return mithril_default(".dropdown-content.scroll", {
				role: AriaRole.Menu,
				tabindex: TabIndex.Programmatic,
				oncreate: (vnode) => {
					this.domContents = vnode.dom;
				},
				onupdate: (vnode) => {
					if (this.maxHeight == null) {
						const children = Array.from(vnode.dom.children);
						this.maxHeight = children.reduce((accumulator, children$1) => accumulator + children$1.offsetHeight, 0) + size.vpad;
						if (this.origin) showDropdown(this.origin, assertNotNull(this.domDropdown), this.maxHeight, this.width).then(() => {
							const firstButton = vnode.dom.getElementsByTagName("button").item(0);
							if (this.domInput && !client.isMobileDevice()) this.domInput.focus();
else if (firstButton !== null) firstButton.focus();
else this.domContents?.focus();
						});
					}
				},
				onscroll: (ev) => {
					const target = ev.target;
					ev.redraw = this.domContents != null && target.scrollTop < 0 && target.scrollTop + this.domContents.offsetHeight > target.scrollHeight;
				},
				style: {
					top: px(this.getFilterHeight()),
					bottom: 0
				}
			}, this.visibleChildren().map((child) => {
				if (isDropDownInfo(child)) return mithril_default(DropdownInfo, child);
else return Dropdown.renderDropDownButton(child, showingIcons);
			}));
		};
		const closeBtn = () => {
			return mithril_default(BaseButton, {
				label: "close_alt",
				text: lang.get("close_alt"),
				class: "hidden-until-focus content-accent-fg button-content",
				onclick: () => {
					this.onClose();
				}
			});
		};
		this.view = () => {
			return mithril_default(".dropdown-panel.elevated-bg.border-radius.dropdown-shadow.fit-content.flex-column.flex-start", {
				oncreate: (vnode) => {
					this.domDropdown = vnode.dom;
					this.domDropdown.style.opacity = "0";
				},
				onkeypress: () => {
					if (this.domInput) this.domInput.focus();
				}
			}, [
				inputField(),
				contents(),
				closeBtn()
			]);
		};
	}
	static renderDropDownButton(child, showingIcons) {
		return mithril_default(RowButton, {
			role: AriaRole.Option,
			selected: child.selected,
			label: child.label,
			text: child.text,
			icon: child.icon && showingIcons ? child.icon : showingIcons ? "none" : undefined,
			class: "dropdown-button",
			onclick: child.click ? child.click : noOp
		});
	}
	wrapClick(fn) {
		return (e, dom) => {
			const r = fn(e, dom);
			this.close();
			return r;
		};
	}
	backgroundClick(e) {
		if (this.domDropdown && !e.target.classList.contains("doNotClose") && (this.domDropdown.contains(e.target) || this.domDropdown.parentNode === e.target)) this.onClose();
	}
	_createShortcuts() {
		return [
			{
				key: Keys.ESC,
				exec: () => this.onClose(),
				help: "close_alt"
			},
			{
				key: Keys.TAB,
				shift: true,
				exec: () => this.domDropdown ? focusPrevious(this.domDropdown) : false,
				help: "selectPrevious_action"
			},
			{
				key: Keys.TAB,
				shift: false,
				exec: () => this.domDropdown ? focusNext(this.domDropdown) : false,
				help: "selectNext_action"
			},
			{
				key: Keys.UP,
				exec: () => this.domDropdown ? focusPrevious(this.domDropdown) : false,
				help: "selectPrevious_action"
			},
			{
				key: Keys.DOWN,
				exec: () => this.domDropdown ? focusNext(this.domDropdown) : false,
				help: "selectNext_action"
			},
			{
				key: Keys.RETURN,
				exec: () => this.chooseMatch(),
				help: "ok_action"
			}
		];
	}
	setOrigin(origin) {
		this.origin = origin;
		return this;
	}
	close() {
		modal.remove(this);
	}
	onClose() {
		if (this.closeHandler) this.closeHandler();
else this.close();
	}
	popState(e) {
		this.onClose();
		return false;
	}
	callingElement() {
		return this.focusedBeforeShown;
	}
	chooseMatch = () => {
		const filterString = this.filterString.toLowerCase();
		let visibleElements = downcast(this.visibleChildren().filter((b) => !isDropDownInfo(b)));
		let matchingButton = visibleElements.length === 1 ? visibleElements[0] : visibleElements.find((b) => lang.getTranslationText(b.label).toLowerCase() === filterString);
		if (this.domInput && document.activeElement === this.domInput && matchingButton && matchingButton.click) {
			matchingButton.click(new MouseEvent("click"), this.domInput);
			return false;
		}
		return true;
	};
	/**
	* Is invoked from modal as the two animations (background layer opacity and dropdown) should run in parallel
	*/
	hideAnimation() {
		return Promise.resolve();
	}
	setCloseHandler(handler) {
		this.closeHandler = handler;
		return this;
	}
	visibleChildren() {
		return this.children.filter((b) => {
			if (isDropDownInfo(b)) return b.info.includes(this.filterString.toLowerCase());
else if (this.isFilterable) {
				const filterable = lang.getTranslationText(b.text ?? b.label);
				return filterable.toLowerCase().includes(this.filterString.toLowerCase());
			} else return true;
		});
	}
	getFilterHeight() {
		return this.isFilterable ? size.button_height + size.vpad_xs : 0;
	}
};
function createDropdown({ lazyButtons, overrideOrigin, width, withBackground }) {
	return createAsyncDropdown({
		lazyButtons: async () => lazyButtons(),
		overrideOrigin,
		width,
		withBackground
	});
}
function createAsyncDropdown({ lazyButtons, overrideOrigin, width = 200, withBackground = false, onClose = undefined }) {
	return (_, dom) => {
		const originalButtons = lazyButtons();
		let buttonsResolved = false;
		originalButtons.then(() => {
			buttonsResolved = true;
		});
		let buttons = originalButtons;
		buttons = Promise.race([originalButtons, Promise.all([delay(100), import("./ProgressDialog-B_Oyx_zv.js")]).then(([_$1, module]) => {
			if (!buttonsResolved) return module.showProgressDialog("loading_msg", originalButtons);
else return originalButtons;
		})]);
		buttons.then((buttons$1) => {
			let dropdown = new Dropdown(() => buttons$1, width);
			if (onClose) dropdown.setCloseHandler(() => {
				onClose();
				dropdown.close();
			});
			let buttonRect;
			if (overrideOrigin) buttonRect = overrideOrigin(dom.getBoundingClientRect());
else buttonRect = dom.getBoundingClientRect();
			dropdown.setOrigin(buttonRect);
			modal.displayUnique(dropdown, withBackground);
		});
	};
}
function showDropdownAtPosition(buttons, xPos, yPos, closeHandler = noOp, width = 200) {
	const dropdown = new Dropdown(() => buttons, width);
	const close = makeSingleUse(() => {
		closeHandler();
		dropdown.close();
	});
	dropdown.setOrigin(new DomRectReadOnlyPolyfilled(xPos, yPos, 0, 0));
	dropdown.setCloseHandler(close);
	modal.displayUnique(dropdown, false);
}
function attachDropdown({ mainButtonAttrs, childAttrs, showDropdown: showDropdown$1 = () => true, width, overrideOrigin, onClose }) {
	return Object.assign({}, mainButtonAttrs, { click: (e, dom) => {
		if (showDropdown$1()) {
			const dropDownFn = createAsyncDropdown({
				lazyButtons: () => Promise.resolve(childAttrs()),
				overrideOrigin,
				width,
				onClose
			});
			dropDownFn(e, dom);
			e.stopPropagation();
		}
	} });
}
const DROPDOWN_MARGIN = 4;
function showDropdown(origin, domDropdown, contentHeight, contentWidth, position) {
	const leftEdgeOfElement = origin.left;
	const rightEdgeOfElement = origin.right;
	const bottomEdgeOfElement = origin.bottom;
	const topEdgeOfElement = origin.top;
	const upperSpace = origin.top - getSafeAreaInsetTop();
	const lowerSpace = window.innerHeight - origin.bottom - getSafeAreaInsetBottom();
	const leftSpace = origin.left;
	const rightSpace = window.innerWidth - origin.right;
	let transformOrigin = "";
	let maxHeight;
	const showBelow = !position && lowerSpace > upperSpace || position === "bottom";
	if (showBelow) {
		transformOrigin += "top";
		domDropdown.style.top = bottomEdgeOfElement + "px";
		domDropdown.style.bottom = "";
		maxHeight = Math.min(contentHeight, lowerSpace);
	} else {
		transformOrigin += "bottom";
		domDropdown.style.top = "";
		domDropdown.style.bottom = px(window.innerHeight - topEdgeOfElement);
		maxHeight = Math.min(contentHeight, upperSpace);
	}
	transformOrigin += leftSpace < rightSpace ? " left" : " right";
	const dropdownMaxWidth = window.innerWidth - DROPDOWN_MARGIN * 2;
	const dropdownWidth = Math.max(contentWidth, domDropdown.getBoundingClientRect().width);
	let width = dropdownWidth;
	let leftStyle = null;
	let rightStyle = null;
	if (width >= dropdownMaxWidth) {
		domDropdown.classList.remove("fit-content");
		leftStyle = DROPDOWN_MARGIN;
		width = dropdownMaxWidth;
	} else if (leftSpace < rightSpace) {
		const availableSpaceForDropdown = window.innerWidth - leftEdgeOfElement;
		let leftEdgeOfDropdown = leftEdgeOfElement;
		if (availableSpaceForDropdown < dropdownWidth) {
			const shiftForDropdown = leftEdgeOfDropdown + dropdownWidth - window.innerWidth + DROPDOWN_MARGIN;
			leftEdgeOfDropdown = leftEdgeOfElement - shiftForDropdown;
		}
		leftStyle = Math.max(DROPDOWN_MARGIN, leftEdgeOfDropdown);
	} else {
		const availableSpaceForDropdown = origin.right;
		let rightEdgeOfDropdown = rightEdgeOfElement;
		if (availableSpaceForDropdown < dropdownWidth) {
			const shiftForDropdown = dropdownWidth - rightEdgeOfDropdown + DROPDOWN_MARGIN;
			rightEdgeOfDropdown = rightEdgeOfElement + shiftForDropdown;
		}
		rightStyle = Math.max(DROPDOWN_MARGIN, window.innerWidth - rightEdgeOfDropdown);
	}
	domDropdown.style.left = leftStyle != null ? px(leftStyle) : "";
	domDropdown.style.right = rightStyle != null ? px(rightStyle) : "";
	domDropdown.style.width = px(width);
	domDropdown.style.height = px(maxHeight);
	domDropdown.style.transformOrigin = transformOrigin;
	return animations.add(domDropdown, [opacity(0, 1, true), transform(TransformEnum.Scale, .5, 1)], { easing: ease.out });
}

//#endregion
//#region ../src/common/gui/base/DropDownSelector.ts
assertMainOrNode();
var DropDownSelector = class {
	view(vnode) {
		const a = vnode.attrs;
		return mithril_default(TextField, {
			label: a.label,
			value: this.valueToText(a, a.selectedValue) || "",
			helpLabel: a.helpLabel,
			isReadOnly: true,
			onclick: a.disabled ? noOp : this.createDropdown(a),
			class: "click " + (a.class == null ? "mt" : a.class) + " " + getOperatingClasses(a.disabled),
			style: a.style,
			injectionsRight: () => a.disabled ? null : mithril_default(".flex.items-center.justify-center", { style: {
				width: "30px",
				height: "30px"
			} }, mithril_default(IconButton, {
				icon: a.icon ? a.icon : BootIcons.Expand,
				title: "show_action",
				click: a.disabled ? noOp : this.createDropdown(a),
				size: ButtonSize.Compact
			})),
			doShowBorder: a.doShowBorder
		});
	}
	createDropdown(a) {
		return createDropdown({
			lazyButtons: () => {
				return a.items.filter((item) => item.selectable !== false).map((item) => {
					return {
						label: lang.makeTranslation(item.name, item.name),
						click: () => {
							a.selectionChangedHandler?.(item.value);
							mithril_default.redraw();
						},
						selected: a.selectedValue === item.value
					};
				});
			},
			width: a.dropdownWidth
		});
	}
	valueToText(a, value) {
		if (a.selectedValueDisplay) return a.selectedValueDisplay;
		const selectedItem = a.items.find((item) => item.value === a.selectedValue);
		if (selectedItem) return selectedItem.name;
else {
			console.log(`Dropdown ${lang.getTranslationText(a.label)} couldn't find element for value: ${String(JSON.stringify(value))}`);
			return null;
		}
	}
};

//#endregion
//#region ../src/common/gui/base/GuiUtils.ts
let DropType = function(DropType$1) {
	DropType$1["ExternalFile"] = "ExternalFile";
	DropType$1["Mail"] = "Mail";
	return DropType$1;
}({});
const dropdownCountries = lazyMemoized(() => Countries.map((c) => ({
	value: c,
	name: c.n
})));
function renderCountryDropdown(params) {
	return mithril_default(DropDownSelector, {
		label: params.label ?? "invoiceCountry_label",
		helpLabel: params.helpLabel,
		items: [...dropdownCountries(), {
			value: null,
			name: lang.get("choose_label")
		}],
		selectedValue: params.selectedCountry,
		selectionChangedHandler: params.onSelectionChanged
	});
}
function getConfirmation(message, confirmMessage = "ok_action") {
	const confirmationPromise = Dialog.confirm(message, confirmMessage);
	const confirmation = {
		confirmed(action) {
			confirmationPromise.then((ok) => {
				if (ok) action();
			});
			return confirmation;
		},
		cancelled(action) {
			confirmationPromise.then((ok) => {
				if (!ok) action();
			});
			return confirmation;
		},
		result: confirmationPromise
	};
	return confirmation;
}
function makeListSelectionChangedScrollHandler(scrollDom, entryHeight, getSelectedEntryIndex) {
	return function() {
		scrollListDom(scrollDom, entryHeight, getSelectedEntryIndex());
	};
}
function scrollListDom(scrollDom, entryHeight, selectedIndex) {
	const scrollWindowHeight = scrollDom.getBoundingClientRect().height;
	const scrollOffset = scrollDom.scrollTop;
	const selectedTop = entryHeight * selectedIndex;
	const selectedBottom = selectedTop + entryHeight;
	const selectedRelativeTop = selectedTop - scrollOffset;
	const selectedRelativeBottom = selectedBottom - scrollOffset;
	if (selectedRelativeTop < 0) scrollDom.scrollTop = selectedTop;
else if (selectedRelativeBottom > scrollWindowHeight) scrollDom.scrollTop = selectedBottom - scrollWindowHeight;
}
function ifAllowedTutaLinks(logins, linkId, render) {
	if (canSeeTutaLinks(logins)) return render(linkId);
	return null;
}
function canSeeTutaLinks(logins) {
	return !logins.isWhitelabel() || logins.getUserController().isGlobalAdmin();
}
function encodeSVG(svg) {
	return "data:image/svg+xml;utf8," + svg.replace(/"/g, "'").replace(/#/g, "%23").replace(/\s+/g, " ");
}
function getOperatingClasses(isDisabled, cursorClass) {
	const cursorClassOrDefault = cursorClass ? cursorClass : "";
	return isDisabled ? "disabled click-disabled" : cursorClassOrDefault;
}
function getContactTitle(contact) {
	const title = contact.title ? `${contact.title} ` : "";
	const middleName = contact.middleName != null ? ` ${contact.middleName} ` : " ";
	const fullName = `${contact.firstName}${middleName}${contact.lastName} `;
	const suffix = contact.nameSuffix ?? "";
	return (title + fullName + suffix).trim();
}
function colorForBg(color) {
	return isColorLight(color) ? "black" : "white";
}

//#endregion
//#region ../src/common/gui/base/TextField.ts
let TextFieldType = function(TextFieldType$1) {
	TextFieldType$1["Text"] = "text";
	TextFieldType$1["Email"] = "email";
	/** @deprecated Prefer the `PasswordField` component over using this type with `TextField` */
	TextFieldType$1["Password"] = "password";
	TextFieldType$1["Area"] = "area";
	TextFieldType$1["Number"] = "number";
	TextFieldType$1["Url"] = "url";
	TextFieldType$1["Date"] = "date";
	TextFieldType$1["Time"] = "time";
	return TextFieldType$1;
}({});
let Autocomplete = function(Autocomplete$1) {
	Autocomplete$1["off"] = "off";
	Autocomplete$1["email"] = "email";
	Autocomplete$1["username"] = "username";
	Autocomplete$1["newPassword"] = "new-password";
	Autocomplete$1["currentPassword"] = "current-password";
	Autocomplete$1["oneTimeCode"] = "one-time-code";
	Autocomplete$1["ccNumber"] = "cc-number";
	Autocomplete$1["ccCsc"] = "cc-csc";
	Autocomplete$1["ccExp"] = "cc-exp";
	return Autocomplete$1;
}({});
let Autocapitalize = function(Autocapitalize$1) {
	Autocapitalize$1["none"] = "none";
	return Autocapitalize$1;
}({});
const inputLineHeight = size.font_size_base + 8;
const inputMarginTop = size.font_size_small + size.hpad_small + 3;
const baseLabelPosition = 21;
const minInputHeight = 46;
var TextField = class {
	active;
	onblur = null;
	domInput;
	_domWrapper;
	_domLabel;
	_domInputWrapper;
	_didAutofill;
	constructor() {
		this.active = false;
	}
	view(vnode) {
		const a = vnode.attrs;
		const maxWidth = a.maxWidth;
		const labelBase = !this.active && a.value === "" && !a.isReadOnly && !this._didAutofill && !a.injectionsLeft;
		const labelTransitionSpeed = DefaultAnimationTime / 2;
		const doShowBorder = a.doShowBorder !== false;
		const borderWidth = this.active ? "2px" : "1px";
		const borderColor = this.active ? theme.content_accent : theme.content_border;
		return mithril_default(".text-field.rel.overflow-hidden", {
			id: vnode.attrs.id,
			oncreate: (vnode$1) => this._domWrapper = vnode$1.dom,
			onclick: (e) => a.onclick ? a.onclick(e, this._domInputWrapper) : this.focus(e, a),
			"aria-haspopup": a.hasPopup,
			class: a.class != null ? a.class : "pt " + getOperatingClasses(a.disabled),
			style: maxWidth ? {
				maxWidth: px(maxWidth),
				...a.style
			} : { ...a.style }
		}, [
			mithril_default("label.abs.text-ellipsis.noselect.z1.i.pr-s", {
				"aria-hidden": "true",
				class: this.active ? "content-accent-fg" : " " + getOperatingClasses(a.disabled),
				oncreate: (vnode$1) => {
					this._domLabel = vnode$1.dom;
				},
				style: {
					fontSize: `${labelBase ? size.font_size_base : size.font_size_small}px`,
					transform: `translateY(${labelBase ? baseLabelPosition : 0}px)`,
					transition: `transform ${labelTransitionSpeed}ms ease-out, font-size ${labelTransitionSpeed}ms  ease-out`
				}
			}, lang.getTranslationText(a.label)),
			mithril_default(".flex.flex-column", [mithril_default(".flex.items-end.flex-wrap", { style: {
				"min-height": px(minInputHeight),
				"padding-bottom": this.active ? px(0) : px(1),
				"border-bottom": doShowBorder ? `${borderWidth} solid ${borderColor}` : ""
			} }, [a.injectionsLeft ? a.injectionsLeft() : null, mithril_default(".inputWrapper.flex-space-between.items-end", {
				style: { minHeight: px(minInputHeight - 2) },
				oncreate: (vnode$1) => this._domInputWrapper = vnode$1.dom
			}, [a.type !== TextFieldType.Area ? this._getInputField(a) : this._getTextArea(a), a.injectionsRight ? mithril_default(".flex-end.items-center", { style: { minHeight: px(minInputHeight - 2) } }, a.injectionsRight()) : null])])]),
			a.helpLabel ? mithril_default("small.noselect", { onclick: (e) => {
				e.stopPropagation();
			} }, a.helpLabel()) : []
		]);
	}
	_getInputField(a) {
		if (a.isReadOnly) return mithril_default(".text-break.selectable", {
			style: {
				marginTop: px(inputMarginTop),
				lineHeight: px(inputLineHeight)
			},
			"data-testid": `tf:${lang.getTestId(a.label)}`
		}, a.value);
else {
			const autofillGuard = a.autocompleteAs === Autocomplete.off ? [
				mithril_default("input.abs", {
					style: {
						opacity: "0",
						height: "0"
					},
					tabIndex: TabIndex.Programmatic,
					type: TextFieldType.Text
				}),
				mithril_default("input.abs", {
					style: {
						opacity: "0",
						height: "0"
					},
					tabIndex: TabIndex.Programmatic,
					type: TextFieldType.Password
				}),
				mithril_default("input.abs", {
					style: {
						opacity: "0",
						height: "0"
					},
					tabIndex: TabIndex.Programmatic,
					type: TextFieldType.Text
				})
			] : [];
			return mithril_default(".flex-grow.rel", autofillGuard.concat([mithril_default("input.input" + (a.alignRight ? ".right" : ""), {
				autocomplete: a.autocompleteAs ?? "",
				autocapitalize: a.autocapitalize,
				type: a.type,
				min: a.min,
				max: a.max,
				"aria-label": lang.getTranslationText(a.label),
				disabled: a.disabled,
				class: getOperatingClasses(a.disabled) + " text",
				oncreate: (vnode) => {
					this.domInput = vnode.dom;
					a.onDomInputCreated?.(this.domInput);
					this.domInput.value = a.value;
					if (a.type !== TextFieldType.Area) vnode.dom.addEventListener("animationstart", (e) => {
						if (e.animationName === "onAutoFillStart") {
							this._didAutofill = true;
							mithril_default.redraw();
						} else if (e.animationName === "onAutoFillCancel") {
							this._didAutofill = false;
							mithril_default.redraw();
						}
					});
				},
				onfocus: (e) => {
					this.focus(e, a);
					a.onfocus?.(this._domWrapper, this.domInput);
				},
				onblur: (e) => this.blur(e, a),
				onkeydown: (e) => {
					const handled = useKeyHandler(e, a.keyHandler);
					if (!isKeyPressed(e.key, Keys.F1, Keys.TAB, Keys.ESC)) e.stopPropagation();
					return handled;
				},
				onupdate: () => {
					if (this.domInput.value !== a.value) this.domInput.value = a.value;
				},
				oninput: () => {
					a.oninput?.(this.domInput.value, this.domInput);
				},
				onremove: () => {
					if (this.domInput) this.domInput.value = "";
				},
				style: {
					maxWidth: a.maxWidth,
					minWidth: px(20),
					lineHeight: px(inputLineHeight),
					fontSize: a.fontSize
				},
				"data-testid": `tf:${lang.getTestId(a.label)}`
			})]));
		}
	}
	_getTextArea(a) {
		if (a.isReadOnly) return mithril_default(".text-prewrap.text-break.selectable", { style: {
			marginTop: px(inputMarginTop),
			lineHeight: px(inputLineHeight)
		} }, a.value);
else return mithril_default("textarea.input-area.text-pre", {
			"aria-label": lang.getTranslationText(a.label),
			disabled: a.disabled,
			autocapitalize: a.autocapitalize,
			class: getOperatingClasses(a.disabled) + " text",
			oncreate: (vnode) => {
				this.domInput = vnode.dom;
				this.domInput.value = a.value;
				this.domInput.style.height = px(Math.max(a.value.split("\n").length, 1) * inputLineHeight);
			},
			onfocus: (e) => this.focus(e, a),
			onblur: (e) => this.blur(e, a),
			onkeydown: (e) => useKeyHandler(e, a.keyHandler),
			oninput: () => {
				this.domInput.style.height = "0px";
				this.domInput.style.height = px(this.domInput.scrollHeight);
				a.oninput?.(this.domInput.value, this.domInput);
			},
			onupdate: () => {
				if (this.domInput.value !== a.value) this.domInput.value = a.value;
			},
			style: {
				marginTop: px(inputMarginTop),
				lineHeight: px(inputLineHeight),
				minWidth: px(20),
				fontSize: a.fontSize
			}
		});
	}
	focus(e, a) {
		if (!this.active && !a.disabled && !a.isReadOnly) {
			this.active = true;
			this.domInput.focus();
			this._domWrapper.classList.add("active");
		}
	}
	blur(e, a) {
		this._domWrapper.classList.remove("active");
		this.active = false;
		if (a.onblur instanceof Function) a.onblur(e);
	}
	isEmpty(value) {
		return value === "";
	}
};

//#endregion
//#region ../src/common/gui/base/DialogInjectionRight.ts
var DialogInjectionRight = class {
	view({ attrs }) {
		const { component, componentAttrs } = attrs;
		if (attrs.visible()) return mithril_default(".flex-grow-shrink-auto.flex-transition.ml-s.rel.dialog.dialog-width-m.elevated-bg.dropdown-shadow.border-radius", [mithril_default(DialogHeaderBar, resolveMaybeLazy(attrs.headerAttrs)), mithril_default(".dialog-container.scroll.plr-l", mithril_default(component, componentAttrs))]);
else return mithril_default(".flex-hide.flex-transition.rel", { style: { maxWidth: px(0) } });
	}
};

//#endregion
//#region ../src/common/gui/base/Dialog.ts
var import_stream = __toESM(require_stream(), 1);
assertMainOrNode();
const INPUT = "input, textarea, div[contenteditable='true']";
let DialogType = function(DialogType$1) {
	DialogType$1["Progress"] = "Progress";
	DialogType$1["Alert"] = "Alert";
	DialogType$1["Reminder"] = "Reminder";
	DialogType$1["EditSmall"] = "EditSmall";
	DialogType$1["EditMedium"] = "EditMedium";
	DialogType$1["EditLarger"] = "EditLarger";
	DialogType$1["EditLarge"] = "EditLarge";
	return DialogType$1;
}({});
var Dialog = class Dialog {
	static keyboardHeight = 0;
	domDialog = null;
	_shortcuts;
	view;
	visible;
	focusOnLoadFunction;
	wasFocusOnLoadCalled;
	closeHandler = null;
	focusedBeforeShown = null;
	injectionRightAttrs = null;
	constructor(dialogType, childComponent) {
		this.visible = false;
		this.focusOnLoadFunction = () => this.defaultFocusOnLoad(assertNotNull(this.domDialog));
		this.wasFocusOnLoadCalled = false;
		this._shortcuts = [{
			key: Keys.TAB,
			shift: true,
			exec: () => this.domDialog ? focusPrevious(this.domDialog) : false,
			help: "selectPrevious_action"
		}, {
			key: Keys.TAB,
			shift: false,
			exec: () => this.domDialog ? focusNext(this.domDialog) : false,
			help: "selectNext_action"
		}];
		this.view = () => {
			const marginPx = px(size.hpad);
			const isEditLarge = dialogType === DialogType.EditLarge;
			const sidesMargin = styles.isSingleColumnLayout() && isEditLarge ? "4px" : marginPx;
			return mithril_default(
				this.getDialogWrapperClasses(dialogType),
				{ style: {
					paddingTop: "env(safe-area-inset-top)",
					paddingLeft: "env(safe-area-inset-left)",
					paddingRight: "env(safe-area-inset-right)"
				} },
				/** controls vertical alignment
				* we need overflow-hidden (actually resulting in min-height: 0 instead of auto)
				* here because otherwise the content of the dialog may make this wrapper grow bigger outside
				* the window on some browsers, e.g. upgrade reminder on Firefox mobile */
				mithril_default(".flex.justify-center.align-self-stretch.rel.overflow-hidden" + (isEditLarge ? ".flex-grow" : ".transition-margin"), { style: {
					marginTop: marginPx,
					marginLeft: sidesMargin,
					marginRight: sidesMargin,
					"margin-bottom": Dialog.keyboardHeight > 0 ? px(Dialog.keyboardHeight) : isEditLarge ? 0 : marginPx
				} }, [mithril_default(this.getDialogStyle(dialogType), {
					role: AriaWindow.Dialog,
					"aria-modal": "true",
					"aria-labelledby": "dialog-title",
					"aria-describedby": "dialog-message",
					onclick: (e) => e.stopPropagation(),
					oncreate: (vnode) => {
						this.domDialog = vnode.dom;
						let animation = null;
						if (isEditLarge) {
							this.domDialog.style.transform = `translateY(${window.innerHeight}px)`;
							animation = animations.add(this.domDialog, transform(TransformEnum.TranslateY, window.innerHeight, 0));
						} else {
							const bgcolor = getElevatedBackground();
							const children = Array.from(this.domDialog.children);
							for (let child of children) child.style.opacity = "0";
							this.domDialog.style.backgroundColor = `rgba(0, 0, 0, 0)`;
							animation = Promise.all([animations.add(this.domDialog, alpha(AlphaEnum.BackgroundColor, bgcolor, 0, 1)), animations.add(children, opacity(0, 1, true), { delay: DefaultAnimationTime / 2 })]);
						}
						window.requestAnimationFrame(() => {
							const activeElement = document.activeElement;
							if (activeElement && typeof activeElement.blur === "function") activeElement.blur();
						});
						animation.then(() => {
							this.focusOnLoadFunction(assertNotNull(this.domDialog));
							this.wasFocusOnLoadCalled = true;
							if (this.domDialog != null && !isEditLarge) this.domDialog.style.removeProperty("background-color");
						});
					}
				}, mithril_default(childComponent)), this.injectionRightAttrs ? mithril_default(DialogInjectionRight, this.injectionRightAttrs) : null])
);
		};
	}
	setInjectionRight(injectionRightAttrs) {
		this.injectionRightAttrs = injectionRightAttrs;
	}
	defaultFocusOnLoad(dom) {
		const inputs = Array.from(dom.querySelectorAll(INPUT));
		const scrollableWrapper = dom.querySelector(".dialog-container.scroll");
		if (inputs.length > 0) inputs[0].focus();
else if (!scrollableWrapper) {
			let button = dom.querySelector("button");
			if (button) button.focus();
		} else {
			scrollableWrapper.tabIndex = Number(TabIndex.Default);
			scrollableWrapper.focus();
		}
	}
	/**
	* By default the focus is set on the first text field after this dialog is fully visible. This behavior can be overwritten by calling this function.
	* If it has already been called, then calls it instantly
	*/
	setFocusOnLoadFunction(callback) {
		this.focusOnLoadFunction = callback;
		if (this.wasFocusOnLoadCalled) this.focusOnLoadFunction(assertNotNull(this.domDialog));
	}
	getDialogWrapperClasses(dialogType) {
		let dialogWrapperStyle = ".fill-absolute.flex.items-stretch.flex-column";
		if (dialogType === DialogType.EditLarge) dialogWrapperStyle += ".flex-start";
else dialogWrapperStyle += ".flex-center";
		return dialogWrapperStyle;
	}
	getDialogStyle(dialogType) {
		let dialogStyle = ".dialog.elevated-bg.flex-grow.border-radius-top";
		if (dialogType === DialogType.Progress) dialogStyle += ".dialog-width-s.dialog-progress.border-radius-bottom";
else if (dialogType === DialogType.Alert) dialogStyle += ".dialog-width-alert.pt.border-radius-bottom";
else if (dialogType === DialogType.Reminder) dialogStyle += ".dialog-width-m.pt.flex.flex-column.border-radius-bottom";
else if (dialogType === DialogType.EditSmall) dialogStyle += ".dialog-width-s.flex.flex-column.border-radius-bottom";
else if (dialogType === DialogType.EditMedium) dialogStyle += ".dialog-width-m.border-radius-bottom";
else if (dialogType === DialogType.EditLarge || dialogType === DialogType.EditLarger) dialogStyle += ".dialog-width-l";
		return dialogStyle;
	}
	addShortcut(shortcut) {
		this._shortcuts.push(shortcut);
		if (this.visible) keyManager.registerModalShortcuts([shortcut]);
		return this;
	}
	/**
	* Sets a close handler to the dialog. If set the handler will be notified when onClose is called on the dialog.
	* The handler must is then responsible for closing the dialog.
	*/
	setCloseHandler(closeHandler) {
		this.closeHandler = closeHandler;
		return this;
	}
	shortcuts() {
		return this._shortcuts;
	}
	show() {
		this.focusedBeforeShown = document.activeElement;
		modal.display(this);
		this.visible = true;
		return this;
	}
	/**
	* Removes the dialog from the current view.
	*/
	close() {
		this.visible = false;
		modal.remove(this);
	}
	/**
	* Should be called to close a dialog. Notifies the closeHandler about the close attempt.
	*/
	onClose() {
		if (this.closeHandler) this.closeHandler();
else this.close();
	}
	popState(e) {
		this.onClose();
		return false;
	}
	callingElement() {
		return this.focusedBeforeShown;
	}
	/**
	* Is invoked from modal as the two animations (background layer opacity and dropdown) should run in parallel
	* @returns {Promise.<void>}
	*/
	hideAnimation() {
		let bgcolor = getElevatedBackground();
		if (this.domDialog) return Promise.all([animations.add(this.domDialog.children, opacity(1, 0, true)), animations.add(this.domDialog, alpha(AlphaEnum.BackgroundColor, bgcolor, 1, 0), {
			delay: DefaultAnimationTime / 2,
			easing: ease.linear
		})]).then(noOp);
else return Promise.resolve();
	}
	backgroundClick(e) {}
	/**
	* show a dialog with only a "ok" button
	*
	* @param messageIdOrMessageFunction the text to display
	* @param infoToAppend {?string | lazy<Children>} some text or UI elements to show below the message
	* @returns {Promise<void>} a promise that resolves after the dialog is fully closed
	*/
	static message(messageIdOrMessageFunction, infoToAppend) {
		return new Promise((resolve) => {
			let dialog;
			const closeAction = () => {
				dialog.close();
				setTimeout(() => resolve(), DefaultAnimationTime);
			};
			let lines = lang.getTranslationText(messageIdOrMessageFunction).split("\n");
			let testId = `dialog:${lang.getTestId(messageIdOrMessageFunction)}`;
			if (typeof infoToAppend === "string") lines.push(infoToAppend);
			const buttonAttrs = {
				label: "ok_action",
				click: closeAction,
				type: ButtonType.Primary
			};
			dialog = new Dialog(DialogType.Alert, { view: () => [mithril_default(".dialog-max-height.dialog-contentButtonsBottom.text-break.text-prewrap.selectable.scroll", { "data-testid": testId }, [lines.map((line) => mithril_default(".text-break.selectable", line)), typeof infoToAppend == "function" ? infoToAppend() : null]), mithril_default(".flex-center.dialog-buttons", mithril_default(Button, buttonAttrs))] }).setCloseHandler(closeAction).addShortcut({
				key: Keys.RETURN,
				shift: false,
				exec: closeAction,
				help: "close_alt"
			}).addShortcut({
				key: Keys.ESC,
				shift: false,
				exec: closeAction,
				help: "close_alt"
			}).show();
		});
	}
	/**
	* fallback for cases where we can't directly download and open a file
	*/
	static legacyDownload(filename, url) {
		return new Promise((resolve) => {
			let dialog;
			const closeAction = () => {
				dialog.close();
				setTimeout(() => resolve(), DefaultAnimationTime);
			};
			const closeButtonAttrs = {
				label: "close_alt",
				click: closeAction,
				type: ButtonType.Primary
			};
			const downloadButtonAttrs = {
				label: "download_action",
				click: () => {
					const popup = open("", "_blank");
					if (popup) popup.location = url;
					dialog.close();
					resolve();
				},
				type: ButtonType.Primary
			};
			dialog = new Dialog(DialogType.Alert, { view: () => mithril_default("", [mithril_default(".dialog-contentButtonsBottom.text-break", [mithril_default(Button, downloadButtonAttrs), mithril_default(".pt", lang.get("saveDownloadNotPossibleIos_msg"))]), mithril_default(".flex-center.dialog-buttons", mithril_default(Button, closeButtonAttrs))]) }).setCloseHandler(closeAction).show();
		});
	}
	/**
	* Simpler version of {@link Dialog#confirmMultiple} with just two options: no and yes (or another confirmation).
	* @return Promise, which is resolved with user selection - true for confirm, false for cancel.
	*/
	static confirm(messageIdOrMessageFunction, confirmId = "ok_action", infoToAppend) {
		return new Promise((resolve) => {
			const closeAction = (conf) => {
				dialog.close();
				setTimeout(() => resolve(conf), DefaultAnimationTime);
			};
			const buttonAttrs = [{
				label: "cancel_action",
				click: () => closeAction(false),
				type: ButtonType.Secondary
			}, {
				label: confirmId,
				click: () => closeAction(true),
				type: ButtonType.Primary
			}];
			const dialog = Dialog.confirmMultiple(messageIdOrMessageFunction, buttonAttrs, resolve, infoToAppend);
		});
	}
	/**
	* Show a dialog with multiple selection options below the message.
	* @param messageIdOrMessageFunction which displayed in the body
	* @param buttons which are displayed below
	* @param onclose which is called on shortcut or when dialog is closed any other way (e.g. back navigation). Not called when pressing
	* one of the buttons.
	* @param infoToAppend additional UI elements to show below the message
	*/
	static confirmMultiple(messageIdOrMessageFunction, buttons, onclose, infoToAppend) {
		let dialog;
		const closeAction = (positive) => {
			dialog.close();
			setTimeout(() => onclose && onclose(positive), DefaultAnimationTime);
		};
		function getContent() {
			const additionalChild = typeof infoToAppend === "string" ? mithril_default(".dialog-contentButtonsBottom.text-break.selectable", infoToAppend) : typeof infoToAppend === "function" ? infoToAppend() : null;
			return [lang.getTranslationText(messageIdOrMessageFunction), additionalChild];
		}
		dialog = new Dialog(DialogType.Alert, { view: () => [mithril_default("#dialog-message.dialog-max-height.dialog-contentButtonsBottom.text-break.text-prewrap.selectable.scroll", getContent()), buttons.length === 0 ? null : mithril_default(".flex-center.dialog-buttons", buttons.map((a) => mithril_default(Button, a)))] }).setCloseHandler(() => closeAction(false)).addShortcut({
			key: Keys.ESC,
			shift: false,
			exec: () => closeAction(false),
			help: "cancel_action"
		});
		dialog.show();
		return dialog;
	}
	/** show a dialog with several buttons on the bottom and return the option that was selected.
	*
	* never resolves if the user escapes out of the dialog without selecting an option.
	* */
	static choice(message, choices) {
		return new Promise((resolve) => {
			const choose = (choice) => {
				dialog.close();
				setTimeout(() => resolve(choice), DefaultAnimationTime);
			};
			const buttonAttrs = choices.map((choice) => {
				return {
					label: choice.text,
					click: () => choose(choice.value),
					type: ButtonType.Secondary
				};
			});
			const dialog = Dialog.confirmMultiple(message, buttonAttrs);
		});
	}
	/**
	* Shows a (not-cancellable) multiple-choice dialog.
	* @returns the selected option.
	*/
	static choiceVertical(message, choices) {
		return new Promise((resolve) => {
			const choose = (choice) => {
				dialog.close();
				setTimeout(() => resolve(choice), DefaultAnimationTime);
			};
			const buttonAttrs = choices.map((choice) => {
				return {
					label: choice.text,
					click: () => choose(choice.value),
					type: choice.type === "primary" ? ButtonType.Primary : ButtonType.Secondary
				};
			});
			function getContent() {
				return lang.getTranslationText(message);
			}
			const dialog = new Dialog(DialogType.Alert, { view: () => mithril_default(".flex.flex-column.pl-l.pr-l.pb-s", [mithril_default("#dialog-message.dialog-max-height.text-break.text-prewrap.selectable.scroll", getContent()), buttonAttrs.length === 0 ? null : mithril_default(".flex.flex-column", buttonAttrs.map((a) => mithril_default(Button, a)))]) });
			dialog.show();
		});
	}
	/**
	* show a dialog (resp. monologue) with no buttons that can not be closed, not even with ESC.
	*/
	static deadEnd(message) {
		const dialog = Dialog.confirmMultiple(message, []);
		dialog.addShortcut({
			key: Keys.ESC,
			shift: false,
			exec: noOp,
			help: "emptyString_msg"
		});
		dialog.addShortcut({
			key: Keys.F1,
			shift: false,
			exec: noOp,
			help: "emptyString_msg"
		});
	}
	static save(title, saveAction, child) {
		return new Promise((resolve) => {
			let saveDialog;
			const closeAction = () => {
				saveDialog.close();
				setTimeout(() => resolve(), DefaultAnimationTime);
			};
			const onOk = () => {
				saveAction().then(() => {
					saveDialog.close();
					setTimeout(() => resolve(), DefaultAnimationTime);
				});
			};
			const actionBarAttrs = {
				left: [{
					label: "close_alt",
					click: closeAction,
					type: ButtonType.Secondary
				}],
				right: [{
					label: "save_action",
					click: onOk,
					type: ButtonType.Primary
				}],
				middle: lang.makeTranslation("title", title())
			};
			saveDialog = new Dialog(DialogType.EditMedium, { view: () => mithril_default("", [mithril_default(DialogHeaderBar, actionBarAttrs), mithril_default(".plr-l.pb.text-break", mithril_default(child))]) }).setCloseHandler(closeAction).show();
		});
	}
	static reminder(title, message) {
		return new Promise((resolve) => {
			let dialog;
			const closeAction = (res) => {
				dialog.close();
				setTimeout(() => resolve(res), DefaultAnimationTime);
			};
			const buttonAttrs = [{
				label: "upgradeReminderCancel_action",
				click: () => closeAction(false),
				type: ButtonType.Secondary
			}, {
				label: "showMoreUpgrade_action",
				click: () => closeAction(true),
				type: ButtonType.Primary
			}];
			dialog = new Dialog(DialogType.Reminder, { view: () => [mithril_default(".dialog-contentButtonsBottom.text-break.scroll", [mithril_default(".h2.pb", title), mithril_default(".flex-direction-change.items-center", [mithril_default("#dialog-message.pb", message), mithril_default("img[src=" + HabReminderImage + "].dialog-img.mb.bg-white.border-radius", { style: { "min-width": "150px" } })])]), mithril_default(".flex-center.dialog-buttons.flex-no-grow-no-shrink-auto", buttonAttrs.map((a) => mithril_default(Button, a)))] }).setCloseHandler(() => closeAction(false)).addShortcut({
				key: Keys.ESC,
				shift: false,
				exec: () => closeAction(false),
				help: "cancel_action"
			}).show();
		});
	}
	/**
	* Shows a dialog with a text field input and ok/cancel buttons.
	* @param   props.child either a component (object with view function that returns a Children) or a naked view Function
	* @param   props.validator Called when "Ok" is clicked. Must return null if the input is valid or an error messageID if it is invalid, so an error message is shown.
	* @param   props.okAction called after successful validation.
	* @param   props.cancelAction called when allowCancel is true and the cancel button/shortcut was pressed.
	* @returns the Dialog
	*/
	static showActionDialog(props) {
		let dialog = this.createActionDialog(props);
		return dialog.show();
	}
	static createActionDialog(props) {
		let dialog;
		const { title, child, okAction, validator, allowCancel, allowOkWithReturn, okActionTextId, cancelActionTextId, cancelAction, type } = Object.assign({}, {
			allowCancel: true,
			allowOkWithReturn: false,
			okActionTextId: "ok_action",
			cancelActionTextId: "cancel_action",
			type: DialogType.EditSmall,
			errorMessageStream: (0, import_stream.default)(DEFAULT_ERROR)
		}, props);
		const doCancel = () => {
			if (cancelAction) cancelAction(dialog);
			dialog.close();
		};
		const doAction = () => {
			if (!okAction) return;
			let validationResult = null;
			if (validator) validationResult = validator();
			let finalizer = Promise.resolve(validationResult).then((error_id) => {
				if (error_id) Dialog.message(error_id);
else okAction(dialog);
			});
			if (validationResult instanceof Promise) import("./ProgressDialog-B_Oyx_zv.js").then((module) => module.showProgressDialog("pleaseWait_msg", finalizer));
		};
		const actionBarAttrs = {
			left: mapLazily(allowCancel, (allow) => allow ? [{
				label: cancelActionTextId,
				click: doCancel,
				type: ButtonType.Secondary
			}] : []),
			right: okAction ? [{
				label: okActionTextId,
				click: doAction,
				type: ButtonType.Primary
			}] : [],
			middle: title
		};
		dialog = new Dialog(type, { view: () => [mithril_default(DialogHeaderBar, actionBarAttrs), mithril_default(".dialog-max-height.plr-l.pb.text-break.scroll", ["function" === typeof child ? child() : mithril_default(child)])] }).setCloseHandler(doCancel);
		dialog.addShortcut({
			key: Keys.ESC,
			shift: false,
			exec: mapLazily(allowCancel, (allow) => allow && doCancel()),
			help: "cancel_action",
			enabled: getAsLazy(allowCancel)
		});
		if (allowOkWithReturn) dialog.addShortcut({
			key: Keys.RETURN,
			shift: false,
			exec: doAction,
			help: "ok_action"
		});
		return dialog;
	}
	/**
	* Shows a dialog with a text field input and ok/cancel buttons.
	* @returns A promise resolving to the entered text. The returned promise is only resolved if "ok" is clicked.
	*/
	static showTextInputDialog(props) {
		return new Promise((resolve) => {
			Dialog.showProcessTextInputDialog(props, async (value) => resolve(value));
		});
	}
	/**
	* Shows a dialog with a text field input and ok/cancel buttons. In contrast to {@link showTextInputDialog} the entered text is not returned but processed in the okAction.
	*/
	static showProcessTextInputDialog(props, okAction) {
		let textFieldType = props.textFieldType ?? TextFieldType.Text;
		let result = props.defaultValue ?? "";
		Dialog.showActionDialog({
			title: props.title,
			child: () => mithril_default(TextField, {
				label: props.label,
				value: result,
				type: textFieldType,
				oninput: (newValue) => result = newValue,
				helpLabel: () => props.infoMsgId ? lang.getTranslationText(props.infoMsgId) : ""
			}),
			validator: () => props.inputValidator ? props.inputValidator(result) : null,
			allowOkWithReturn: true,
			okAction: async (dialog) => {
				try {
					await okAction(result);
					dialog.close();
				} catch (error) {
					if (!isOfflineError(error)) dialog.close();
					throw error;
				}
			}
		});
	}
	/**
	* Shows a dialog with a text area input and ok/cancel buttons.
	* @param titleId title of the dialog
	* @param labelIdOrLabelFunction label of the text area
	* @param infoMsgId help label of the text area
	* @param value initial value
	* @returns A promise resolving to the entered text. The returned promise is only resolved if "ok" is clicked.
	*/
	static showTextAreaInputDialog(titleId, labelIdOrLabelFunction, infoMsgId, value) {
		return new Promise((resolve) => {
			let result = value;
			Dialog.showActionDialog({
				title: titleId,
				child: { view: () => mithril_default(TextField, {
					label: labelIdOrLabelFunction,
					helpLabel: () => infoMsgId ? lang.get(infoMsgId) : "",
					value: result,
					oninput: (newValue) => result = newValue,
					type: TextFieldType.Area
				}) },
				okAction: (dialog) => {
					resolve(result);
					dialog.close();
				}
			});
		});
	}
	/**
	* Show a dialog with a dropdown selector
	* @param titleId title of the dialog
	* @param label label of the dropdown selector
	* @param infoMsgId help label of the dropdown selector
	* @param items selection set
	* @param initialValue initial value
	* @param dropdownWidth width of the dropdown
	* @returns A promise resolving to the selected item. The returned promise is only resolved if "ok" is clicked.
	*/
	static showDropDownSelectionDialog(titleId, label, infoMsgId, items, initialValue, dropdownWidth) {
		let selectedValue = initialValue;
		return new Promise((resolve) => {
			Dialog.showActionDialog({
				title: titleId,
				child: { view: () => mithril_default(DropDownSelector, identity({
					label,
					items,
					selectedValue,
					selectionChangedHandler: (newValue) => selectedValue = newValue
				})) },
				okAction: (dialog) => {
					resolve(selectedValue);
					dialog.close();
				}
			});
		});
	}
	/** @deprecated use editDialog*/
	static largeDialog(headerBarAttrs, child) {
		return new Dialog(DialogType.EditLarge, { view: () => {
			return mithril_default("", [mithril_default(DialogHeaderBar, headerBarAttrs), mithril_default(".dialog-container.scroll", mithril_default(".fill-absolute.plr-l", mithril_default(child)))]);
		} });
	}
	static editDialog(headerBarAttrs, child, childAttrs) {
		return new Dialog(DialogType.EditLarge, { view: () => mithril_default("", [headerBarAttrs.noHeader ? null : mithril_default(DialogHeaderBar, headerBarAttrs), mithril_default(".dialog-container.scroll.hide-outline", mithril_default(".fill-absolute.plr-l", mithril_default(child, childAttrs)))]) });
	}
	static editMediumDialog(headerBarAttrs, child, childAttrs, dialogStyle) {
		return new Dialog(DialogType.EditMedium, { view: () => mithril_default(".flex.col.border-radius", { style: dialogStyle }, [headerBarAttrs.noHeader ? null : mithril_default(DialogHeaderBar, headerBarAttrs), mithril_default(".scroll.hide-outline.plr-l.flex-grow", { style: { "overflow-x": "hidden" } }, mithril_default(child, childAttrs))]) });
	}
	static editSmallDialog(headerBarAttrs, child) {
		return new Dialog(DialogType.EditSmall, { view: () => [headerBarAttrs.noHeader ? null : mithril_default(DialogHeaderBar, headerBarAttrs), mithril_default(".scroll.hide-outline.plr-l", child())] });
	}
	static async viewerDialog(title, child, childAttrs) {
		return new Promise((resolve) => {
			let dialog;
			const close = () => {
				dialog.close();
				resolve();
			};
			const headerAttrs = {
				left: [{
					label: "close_alt",
					click: close,
					type: ButtonType.Secondary
				}],
				middle: title
			};
			dialog = Dialog.editDialog(headerAttrs, child, childAttrs).setCloseHandler(close).addShortcut({
				key: Keys.ESC,
				exec: close,
				help: "close_alt"
			}).show();
		});
	}
	static onKeyboardSizeChanged(newSize) {
		Dialog.keyboardHeight = newSize;
		mithril_default.redraw();
	}
};
windowFacade.addKeyboardSizeListener(Dialog.onKeyboardSizeChanged);

//#endregion
export { AriaLandmarks, AriaPopupType, AriaRole, Autocapitalize, Autocomplete, DROPDOWN_MARGIN, Dialog, DialogHeaderBar, DialogType, DomRectReadOnlyPolyfilled, DropDownSelector, DropType, Dropdown, INPUT, TextField, TextFieldType, attachDropdown, canSeeTutaLinks, colorForBg, createAsyncDropdown, createDropdown, encodeSVG, getConfirmation, getContactTitle, getOperatingClasses, ifAllowedTutaLinks, inputLineHeight as inputLineHeight$1, landmarkAttrs, liveDataAttrs, makeListSelectionChangedScrollHandler, pureComponent, renderCountryDropdown, scrollListDom, showDropdown, showDropdownAtPosition };
//# sourceMappingURL=Dialog-B6-HFvZd.js.map