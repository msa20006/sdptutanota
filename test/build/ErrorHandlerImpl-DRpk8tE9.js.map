{"version":3,"file":"ErrorHandlerImpl-DRpk8tE9.js","names":["e: Error","credentials: Credentials","databaseKey: Uint8Array | null","error: UserError"],"sources":["../../src/common/misc/ErrorHandlerImpl.ts"],"sourcesContent":["import {\n\tAccessBlockedError,\n\tAccessDeactivatedError,\n\tAccessExpiredError,\n\tConnectionError,\n\tInsufficientStorageError,\n\tInvalidSoftwareVersionError,\n\tNotAuthenticatedError,\n\tRequestTimeoutError,\n\tServiceUnavailableError,\n\tSessionExpiredError,\n} from \"../api/common/error/RestError\"\nimport { Dialog } from \"../gui/base/Dialog\"\nimport { lang } from \"./LanguageViewModel\"\nimport { assertMainOrNode, isDesktop, isOfflineStorageAvailable } from \"../api/common/Env\"\nimport { assertNotNull, noOp } from \"@tutao/tutanota-utils\"\nimport { OutOfSyncError } from \"../api/common/error/OutOfSyncError\"\nimport { showProgressDialog } from \"../gui/dialogs/ProgressDialog\"\nimport { IndexingNotSupportedError } from \"../api/common/error/IndexingNotSupportedError\"\nimport { windowFacade } from \"./WindowFacade\"\nimport { locator } from \"../api/main/CommonLocator\"\nimport { QuotaExceededError } from \"../api/common/error/QuotaExceededError\"\nimport { UserError } from \"../api/main/UserError\"\nimport { showMoreStorageNeededOrderDialog } from \"./SubscriptionDialogs\"\nimport { showSnackBar } from \"../gui/base/SnackBar\"\nimport { Credentials, credentialsToUnencrypted } from \"./credentials/Credentials\"\nimport { showErrorDialogNotLoggedIn, showErrorNotification } from \"./ErrorReporter\"\nimport { CancelledError } from \"../api/common/error/CancelledError\"\n\nimport { SessionType } from \"../api/common/SessionType.js\"\nimport { OfflineDbClosedError } from \"../api/common/error/OfflineDbClosedError.js\"\nimport { UserTypeRef } from \"../api/entities/sys/TypeRefs.js\"\nimport { isOfflineError } from \"../api/common/utils/ErrorUtils.js\"\nimport { showRequestPasswordDialog } from \"./passwords/PasswordRequestDialog.js\"\n\nassertMainOrNode()\n\nlet unknownErrorDialogActive = false\nlet notConnectedDialogActive = false\nlet invalidSoftwareVersionActive = false\nlet loginDialogActive = false\nlet isLoggingOut = false\nlet serviceUnavailableDialogActive = false\nlet requestTimeoutDialogActive = false\nlet shownQuotaError = false\nlet showingImportError = false\nconst ignoredMessages = [\"webkitExitFullScreen\", \"googletag\", \"avast_submit\"]\n\nexport async function handleUncaughtErrorImpl(e: Error) {\n\tconst { logins, interWindowEventSender, worker, search } = locator\n\n\tif (isLoggingOut) {\n\t\t// ignore all errors while logging out\n\t\treturn\n\t}\n\n\tif (e instanceof UserError) {\n\t\treturn showUserError(e)\n\t}\n\n\tif (isOfflineError(e)) {\n\t\tshowOfflineMessage()\n\t} else if (e instanceof InvalidSoftwareVersionError) {\n\t\tif (!invalidSoftwareVersionActive) {\n\t\t\tinvalidSoftwareVersionActive = true\n\t\t\tDialog.message(\"outdatedClient_msg\").then(() => (invalidSoftwareVersionActive = false))\n\t\t}\n\t} else if (\n\t\te instanceof NotAuthenticatedError ||\n\t\te instanceof AccessBlockedError ||\n\t\te instanceof AccessDeactivatedError ||\n\t\te instanceof AccessExpiredError\n\t) {\n\t\t// If the session is closed (e.g. password is changed) we log user out forcefully so we reload the page\n\t\tif (logins.isUserLoggedIn()) {\n\t\t\tlogoutIfNoPasswordPrompt()\n\t\t}\n\t} else if (e instanceof SessionExpiredError) {\n\t\treloginForExpiredSession()\n\t} else if (e instanceof OutOfSyncError) {\n\t\tconst isOffline = isOfflineStorageAvailable() && logins.isUserLoggedIn() && logins.getUserController().sessionType === SessionType.Persistent\n\n\t\tawait Dialog.message(\"outOfSync_label\", lang.get(isOffline ? \"dataExpiredOfflineDb_msg\" : \"dataExpired_msg\"))\n\n\t\tconst { userId } = logins.getUserController()\n\t\tif (isDesktop()) {\n\t\t\tawait interWindowEventSender?.localUserDataInvalidated(userId)\n\t\t\tawait worker.getWorkerInterface().sqlCipherFacade.deleteDb(userId)\n\t\t}\n\t\tawait logins.logout(false)\n\t\tawait windowFacade.reload({ noAutoLogin: true })\n\t} else if (e instanceof InsufficientStorageError) {\n\t\tif (logins.getUserController().isGlobalAdmin()) {\n\t\t\tshowMoreStorageNeededOrderDialog(\"insufficientStorageAdmin_msg\")\n\t\t} else {\n\t\t\tconst errorMessage = lang.makeTranslation(\n\t\t\t\t\"insufficientStorageUser_msg\",\n\t\t\t\tlang.get(\"insufficientStorageUser_msg\") + \" \" + lang.get(\"contactAdmin_msg\"),\n\t\t\t)\n\t\t\tDialog.message(errorMessage)\n\t\t}\n\t} else if (e instanceof ServiceUnavailableError) {\n\t\tif (!serviceUnavailableDialogActive) {\n\t\t\tserviceUnavailableDialogActive = true\n\t\t\tDialog.message(\"serviceUnavailable_msg\").then(() => {\n\t\t\t\tserviceUnavailableDialogActive = false\n\t\t\t})\n\t\t}\n\t} else if (e instanceof RequestTimeoutError) {\n\t\tif (!requestTimeoutDialogActive) {\n\t\t\trequestTimeoutDialogActive = true\n\t\t\tDialog.message(\"requestTimeout_msg\").then(() => {\n\t\t\t\trequestTimeoutDialogActive = false\n\t\t\t})\n\t\t}\n\t} else if (e instanceof IndexingNotSupportedError) {\n\t\tconsole.log(\"Indexing not supported\", e)\n\t\tif (\"indexingSupported\" in search) {\n\t\t\t// search can be in two flavours: \"SearchModel\" and \"CalendarSearchModel. Only \"SearchModel\" has indexing\n\t\t\tsearch.indexingSupported = false\n\t\t}\n\t} else if (e instanceof QuotaExceededError) {\n\t\tif (!shownQuotaError) {\n\t\t\tshownQuotaError = true\n\t\t\tDialog.message(\"storageQuotaExceeded_msg\")\n\t\t}\n\t} else if (e instanceof OfflineDbClosedError) {\n\t\tif (!loginDialogActive) {\n\t\t\tthrow e\n\t\t}\n\t} else if (ignoredError(e)) {\n\t\t// ignore, this is not our code\n\t} else {\n\t\tif (!unknownErrorDialogActive) {\n\t\t\tunknownErrorDialogActive = true\n\n\t\t\t// only logged in users can report errors because we send mail for that.\n\t\t\tif (logins.isUserLoggedIn()) {\n\t\t\t\tconst { ignored } = await showErrorNotification(e)\n\t\t\t\tunknownErrorDialogActive = false\n\t\t\t\tif (ignored) {\n\t\t\t\t\tignoredMessages.push(e.message)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Unknown error\", e)\n\t\t\t\tshowErrorDialogNotLoggedIn(e).then(() => (unknownErrorDialogActive = false))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction showOfflineMessage() {\n\tif (!notConnectedDialogActive) {\n\t\tnotConnectedDialogActive = true\n\t\tshowSnackBar({\n\t\t\tmessage: \"serverNotReachable_msg\",\n\t\t\tbutton: {\n\t\t\t\tlabel: \"ok_action\",\n\t\t\t\tclick: () => {},\n\t\t\t},\n\t\t\tonClose: () => {\n\t\t\t\tnotConnectedDialogActive = false\n\t\t\t},\n\t\t})\n\t}\n}\n\nfunction logoutIfNoPasswordPrompt() {\n\tif (!loginDialogActive) {\n\t\twindowFacade.reload({})\n\t}\n}\n\nexport async function reloginForExpiredSession() {\n\tif (loginDialogActive) {\n\t\treturn\n\t}\n\tconst { logins, loginFacade, secondFactorHandler, credentialsProvider, cacheStorage } = locator\n\t// Make sure that partial login part is complete before we will try to make a new session.\n\t// Otherwise we run into a race condition where login failure arrives before we initialize userController.\n\tawait logins.waitForPartialLogin()\n\tconsole.log(\"RELOGIN\", logins.isUserLoggedIn())\n\tconst oldSessionType = logins.getUserController().sessionType\n\tconst userId = logins.getUserController().user._id\n\tconst mailAddress = assertNotNull(logins.getUserController().userGroupInfo.mailAddress, \"could not get mailAddress from userGroupInfo\")\n\t// Fetch old credentials to preserve database key if it's there\n\tconst oldCredentials = await credentialsProvider.getDecryptedCredentialsByUserId(userId)\n\t// we're deleting the outdated user here because before resetSession() the cache is still open and can be modified.\n\tawait cacheStorage?.deleteIfExists(UserTypeRef, null, userId)\n\tconst sessionReset = loginFacade.resetSession()\n\tloginDialogActive = true\n\n\tconst dialog = showRequestPasswordDialog({\n\t\taction: async (pw) => {\n\t\t\tawait sessionReset\n\t\t\tlet credentials: Credentials\n\t\t\tlet databaseKey: Uint8Array | null\n\t\t\ttry {\n\t\t\t\tconst newSessionData = await logins.createSession(mailAddress, pw, oldSessionType, oldCredentials?.databaseKey)\n\t\t\t\tcredentials = newSessionData.credentials\n\t\t\t\tdatabaseKey = newSessionData.databaseKey\n\t\t\t} catch (e) {\n\t\t\t\tif (\n\t\t\t\t\te instanceof CancelledError ||\n\t\t\t\t\te instanceof AccessBlockedError ||\n\t\t\t\t\te instanceof NotAuthenticatedError ||\n\t\t\t\t\te instanceof AccessDeactivatedError ||\n\t\t\t\t\te instanceof ConnectionError\n\t\t\t\t) {\n\t\t\t\t\tconst { getLoginErrorMessage } = await import(\"../misc/LoginUtils.js\")\n\t\t\t\t\treturn lang.getTranslationText(getLoginErrorMessage(e, false))\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\t// Once login succeeds we need to manually close the dialog\n\t\t\t\tsecondFactorHandler.closeWaitingForSecondFactorDialog()\n\t\t\t}\n\t\t\tawait credentialsProvider.deleteByUserId(userId, { deleteOfflineDb: false })\n\t\t\tif (oldSessionType === SessionType.Persistent) {\n\t\t\t\tawait credentialsProvider.store(credentialsToUnencrypted(credentials, databaseKey))\n\t\t\t}\n\t\t\tloginDialogActive = false\n\t\t\tdialog.close()\n\t\t\treturn \"\"\n\t\t},\n\t\tcancel: {\n\t\t\ttextId: \"logout_label\",\n\t\t\taction() {\n\t\t\t\twindowFacade.reload({})\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunction ignoredError(e: Error): boolean {\n\treturn e.message != null && ignoredMessages.some((s) => e.message.includes(s))\n}\n\n/**\n * Trying to handle errors during logout can cause unhandled error loops, so we just want to ignore them\n */\nexport function disableErrorHandlingDuringLogout() {\n\tisLoggingOut = true\n\tshowProgressDialog(\"loggingOut_msg\", new Promise(noOp))\n}\n\nfunction handleImportError() {\n\tif (showingImportError) {\n\t\treturn\n\t}\n\n\tshowingImportError = true\n\tconst message =\n\t\t\"There was an error while loading part of the app. It might be that you are offline, running an outdated version, or your browser is blocking the request.\"\n\tDialog.choice(lang.makeTranslation(\"error_msg\", message), [\n\t\t{\n\t\t\ttext: \"close_alt\",\n\t\t\tvalue: false,\n\t\t},\n\t\t{\n\t\t\ttext: \"reloadPage_action\",\n\t\t\tvalue: true,\n\t\t},\n\t]).then((reload) => {\n\t\tshowingImportError = false\n\n\t\tif (reload) {\n\t\t\twindowFacade.reload({})\n\t\t}\n\t})\n}\n\nif (typeof window !== \"undefined\") {\n\t// @ts-ignore\n\twindow.tutao.testError = () => handleUncaughtErrorImpl(new Error(\"test error!\"))\n}\n\nexport function showUserError(error: UserError): Promise<void> {\n\treturn Dialog.message(lang.makeTranslation(\"error_msg\", error.message))\n}\n"],"mappings":"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"}