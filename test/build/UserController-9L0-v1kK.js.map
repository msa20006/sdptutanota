{"version":3,"file":"UserController-9L0-v1kK.js","names":["user: User","_userGroupInfo: GroupInfo","sessionId: IdTuple","_props: TutanotaProperties","accessToken: Base64Url","_userSettingsGroupRoot: UserSettingsGroupRoot","sessionType: SessionType","loginUsername: string","entityClient: EntityClient","serviceExecutor: IServiceExecutor","cacheMode: CacheMode","type: PlanType","update: EntityUpdateData","eventOwnerGroupId: Id","updates: ReadonlyArray<EntityUpdateData>","sync: boolean","sysTypeModels"],"sources":["../../src/common/api/main/UserController.ts"],"sourcesContent":["import { AccountType, FeatureType, GroupType, LegacyPlans, OperationType, PlanType } from \"../common/TutanotaConstants\"\nimport type { Base64Url } from \"@tutao/tutanota-utils\"\nimport { assertNotNull, downcast, first, mapAndFilterNull, neverNull, ofClass } from \"@tutao/tutanota-utils\"\nimport { MediaType } from \"../common/EntityFunctions\"\nimport { assertMainOrNode, getApiBaseUrl, isDesktop } from \"../common/Env\"\n\nimport { NotFoundError } from \"../common/error/RestError\"\nimport { locator } from \"./CommonLocator\"\nimport { elementIdPart, isSameId, listIdPart } from \"../common/utils/EntityUtils\"\nimport { getWhitelabelCustomizations } from \"../../misc/WhitelabelCustomizations\"\nimport { EntityClient } from \"../common/EntityClient\"\nimport { CloseSessionService, PlanService } from \"../entities/sys/Services\"\nimport {\n\tAccountingInfo,\n\tAccountingInfoTypeRef,\n\tcreateCloseSessionServicePost,\n\tCustomer,\n\tCustomerInfo,\n\tCustomerInfoTypeRef,\n\tCustomerProperties,\n\tCustomerPropertiesTypeRef,\n\tCustomerTypeRef,\n\tDomainInfo,\n\tGroupInfo,\n\tGroupInfoTypeRef,\n\tGroupMembership,\n\tPlanConfiguration,\n\tUser,\n\tUserTypeRef,\n\tWhitelabelConfig,\n\tWhitelabelConfigTypeRef,\n} from \"../entities/sys/TypeRefs\"\nimport {\n\tcreateUserSettingsGroupRoot,\n\tTutanotaProperties,\n\tTutanotaPropertiesTypeRef,\n\tUserSettingsGroupRoot,\n\tUserSettingsGroupRootTypeRef,\n} from \"../entities/tutanota/TypeRefs\"\nimport { typeModels as sysTypeModels } from \"../entities/sys/TypeModels\"\nimport { SessionType } from \"../common/SessionType\"\nimport { IServiceExecutor } from \"../common/ServiceRequest.js\"\nimport { isCustomizationEnabledForCustomer } from \"../common/utils/CustomerUtils.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../common/utils/EntityUpdateUtils.js\"\nimport { isGlobalAdmin, isInternalUser } from \"../common/utils/UserUtils.js\"\nimport { CacheMode } from \"../worker/rest/EntityRestClient.js\"\n\nassertMainOrNode()\n\nexport class UserController {\n\tprivate planConfig: PlanConfiguration | null\n\n\tconstructor(\n\t\t// should be readonly but is needed for a workaround in CalendarModel\n\t\tpublic user: User,\n\t\tprivate _userGroupInfo: GroupInfo,\n\t\tpublic readonly sessionId: IdTuple,\n\t\tprivate _props: TutanotaProperties,\n\t\tpublic readonly accessToken: Base64Url,\n\t\tprivate _userSettingsGroupRoot: UserSettingsGroupRoot,\n\t\tpublic readonly sessionType: SessionType,\n\t\t/** Which identifier (e.g. email address) was used to create the session. */\n\t\tpublic readonly loginUsername: string,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t) {\n\t\tthis.planConfig = null\n\t}\n\n\tget userId(): Id {\n\t\treturn this.user._id\n\t}\n\n\tget props(): TutanotaProperties {\n\t\treturn this._props\n\t}\n\n\tget userGroupInfo(): GroupInfo {\n\t\treturn this._userGroupInfo\n\t}\n\n\tget userSettingsGroupRoot(): UserSettingsGroupRoot {\n\t\treturn this._userSettingsGroupRoot\n\t}\n\n\t/**\n\t * Checks if the current user is an admin of the customer.\n\t * @return True if the user is an admin\n\t */\n\tisGlobalAdmin(): boolean {\n\t\treturn isGlobalAdmin(this.user)\n\t}\n\n\t/**\n\t * Checks if the account type of the logged-in user is FREE.\n\t * @returns True if the account type is FREE otherwise false\n\t */\n\tisFreeAccount(): boolean {\n\t\treturn this.user.accountType === AccountType.FREE\n\t}\n\n\tisPremiumAccount(): boolean {\n\t\treturn this.user.accountType === AccountType.PAID\n\t}\n\n\t/**\n\t * Provides the information if an internal user is logged in.\n\t * @return True if an internal user is logged in, false if no user or an external user is logged in.\n\t */\n\tisInternalUser(): boolean {\n\t\treturn isInternalUser(this.user)\n\t}\n\n\tloadCustomer(cacheMode: CacheMode = CacheMode.ReadAndWrite): Promise<Customer> {\n\t\treturn this.entityClient.load(CustomerTypeRef, assertNotNull(this.user.customer), { cacheMode })\n\t}\n\n\tasync loadCustomerInfo(): Promise<CustomerInfo> {\n\t\tconst customer = await this.loadCustomer()\n\t\treturn await this.entityClient.load(CustomerInfoTypeRef, customer.customerInfo)\n\t}\n\n\tasync loadCustomerProperties(): Promise<CustomerProperties> {\n\t\tconst customer = await this.loadCustomer()\n\t\treturn await this.entityClient.load(CustomerPropertiesTypeRef, assertNotNull(customer.properties))\n\t}\n\n\tasync getPlanType(): Promise<PlanType> {\n\t\tconst customerInfo = await this.loadCustomerInfo()\n\t\treturn downcast(customerInfo.plan)\n\t}\n\n\tasync getPlanConfig(): Promise<PlanConfiguration> {\n\t\tif (this.planConfig === null) {\n\t\t\tconst planServiceGetOut = await this.serviceExecutor.get(PlanService, null)\n\t\t\tthis.planConfig = planServiceGetOut.config\n\t\t}\n\t\treturn downcast(this.planConfig)\n\t}\n\n\tisLegacyPlan(type: PlanType): boolean {\n\t\treturn LegacyPlans.includes(type)\n\t}\n\n\tasync isNewPaidPlan(): Promise<boolean> {\n\t\tconst type = await this.getPlanType()\n\t\treturn !this.isLegacyPlan(type) && type !== PlanType.Free\n\t}\n\n\tasync useLegacyBookingItem(): Promise<boolean> {\n\t\tconst customerInfo = await this.loadCustomerInfo()\n\t\tconst type: PlanType = downcast(customerInfo.plan)\n\t\treturn !(this.isLegacyPlan(type) && customerInfo.customPlan == null) && type !== PlanType.Free\n\t}\n\n\t/**\n\t * Checks if the current plan allows adding users and groups.\n\t */\n\tasync canHaveUsers(): Promise<boolean> {\n\t\tconst customer = await this.loadCustomer()\n\t\tconst planType = await this.getPlanType()\n\t\tconst planConfig = await this.getPlanConfig()\n\n\t\treturn this.isLegacyPlan(planType) || planConfig.multiUser || isCustomizationEnabledForCustomer(customer, FeatureType.MultipleUsers)\n\t}\n\n\tasync loadAccountingInfo(): Promise<AccountingInfo> {\n\t\tconst customerInfo = await this.loadCustomerInfo()\n\t\treturn await this.entityClient.load(AccountingInfoTypeRef, customerInfo.accountingInfo)\n\t}\n\n\tgetMailGroupMemberships(): GroupMembership[] {\n\t\treturn this.user.memberships.filter((membership) => membership.groupType === GroupType.Mail)\n\t}\n\n\tgetContactGroupMemberships(): GroupMembership[] {\n\t\treturn this.user.memberships.filter((membership) => membership.groupType === GroupType.Contact)\n\t}\n\n\tgetCalendarMemberships(): GroupMembership[] {\n\t\treturn this.user.memberships.filter((membership) => membership.groupType === GroupType.Calendar)\n\t}\n\n\tgetUserMailGroupMembership(): GroupMembership {\n\t\treturn this.getMailGroupMemberships()[0]\n\t}\n\n\tgetTemplateMemberships(): GroupMembership[] {\n\t\treturn this.user.memberships.filter((membership) => membership.groupType === GroupType.Template)\n\t}\n\n\tgetContactListMemberships(): GroupMembership[] {\n\t\treturn this.user.memberships.filter((membership) => membership.groupType === GroupType.ContactList)\n\t}\n\n\t/**\n\t * Returns true if the given update is an update on the user instance of the logged in user and the update event is sent for the user group.\n\t * There are two updates for the user instance sent if the logged in user is an admin:, one for the user group and one for the admin group.\n\t * We only want to process it once, so we skip the admin group update\n\t *\n\t * Attention: Modules that act on user updates, e.g. for changed group memberships, need to use this function in their entityEventsReceived listener.\n\t * Only then it is guaranteed that the user in the user controller has been updated. The update event for the admin group might come first, so if a module\n\t * reacts on that one the user controller is not updated yet.\n\t */\n\tisUpdateForLoggedInUserInstance(update: EntityUpdateData, eventOwnerGroupId: Id): boolean {\n\t\treturn (\n\t\t\tupdate.operation === OperationType.UPDATE &&\n\t\t\tisUpdateForTypeRef(UserTypeRef, update) &&\n\t\t\tisSameId(this.user._id, update.instanceId) &&\n\t\t\tisSameId(this.user.userGroup.group, eventOwnerGroupId)\n\t\t) // only include updates for the user group here\n\t}\n\n\tasync entityEventsReceived(updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: Id): Promise<void> {\n\t\tfor (const update of updates) {\n\t\t\tconst { instanceListId, instanceId, operation } = update\n\t\t\tif (this.isUpdateForLoggedInUserInstance(update, eventOwnerGroupId)) {\n\t\t\t\tthis.user = await this.entityClient.load(UserTypeRef, this.user._id)\n\t\t\t} else if (\n\t\t\t\toperation === OperationType.UPDATE &&\n\t\t\t\tisUpdateForTypeRef(GroupInfoTypeRef, update) &&\n\t\t\t\tisSameId(this.userGroupInfo._id, [neverNull(instanceListId), instanceId])\n\t\t\t) {\n\t\t\t\tthis._userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, this._userGroupInfo._id)\n\t\t\t} else if (isUpdateForTypeRef(TutanotaPropertiesTypeRef, update) && operation === OperationType.UPDATE) {\n\t\t\t\tthis._props = await this.entityClient.loadRoot(TutanotaPropertiesTypeRef, this.user.userGroup.group)\n\t\t\t} else if (isUpdateForTypeRef(UserSettingsGroupRootTypeRef, update)) {\n\t\t\t\tthis._userSettingsGroupRoot = await this.entityClient.load(UserSettingsGroupRootTypeRef, this.user.userGroup.group)\n\t\t\t} else if (isUpdateForTypeRef(CustomerInfoTypeRef, update)) {\n\t\t\t\tif (operation === OperationType.CREATE) {\n\t\t\t\t\t// After premium upgrade customer info is deleted and created with new id. We want to make sure that it's cached for offline login.\n\t\t\t\t\tawait this.entityClient.load(CustomerInfoTypeRef, [update.instanceListId, update.instanceId])\n\t\t\t\t}\n\t\t\t\t// cached plan config might be outdated now\n\t\t\t\tthis.planConfig = null\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Delete the session (only if it's a non-persistent session\n\t * @param sync whether or not to delete in the main thread. For example, will be true when logging out due to closing the tab\n\t */\n\tasync deleteSession(sync: boolean): Promise<void> {\n\t\t// in case the tab is closed we need to delete the session in the main thread (synchronous rest request)\n\t\tif (sync) {\n\t\t\tif (this.sessionType !== SessionType.Persistent) {\n\t\t\t\tawait this.deleteSessionSync()\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.sessionType !== SessionType.Persistent) {\n\t\t\t\tawait locator.loginFacade.deleteSession(this.accessToken).catch((e) => console.log(\"Error ignored on Logout:\", e))\n\t\t\t}\n\t\t}\n\t}\n\n\tdeleteSessionSync(): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst sendBeacon = navigator.sendBeacon // Save sendBeacon to variable to satisfy type checker\n\n\t\t\tif (sendBeacon) {\n\t\t\t\ttry {\n\t\t\t\t\tconst apiUrl = new URL(getApiBaseUrl(locator.domainConfigProvider().getCurrentDomainConfig()))\n\t\t\t\t\tapiUrl.pathname += `/rest/sys/${CloseSessionService.name.toLowerCase()}`\n\t\t\t\t\tconst requestObject = createCloseSessionServicePost({\n\t\t\t\t\t\taccessToken: this.accessToken,\n\t\t\t\t\t\tsessionId: this.sessionId,\n\t\t\t\t\t})\n\t\t\t\t\tdelete downcast(requestObject)[\"_type\"] // Remove extra field which is not part of the data model\n\n\t\t\t\t\t// Send as Blob to be able to set content type otherwise sends 'text/plain'\n\t\t\t\t\tconst queued = sendBeacon.call(\n\t\t\t\t\t\tnavigator,\n\t\t\t\t\t\tapiUrl,\n\t\t\t\t\t\tnew Blob([JSON.stringify(requestObject)], {\n\t\t\t\t\t\t\ttype: MediaType.Json,\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t\tconsole.log(\"queued closing session: \", queued)\n\t\t\t\t\tresolve()\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(\"Failed to send beacon\", e)\n\t\t\t\t\treject(e)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Fall back to sync XHR if Beacon API is not available (which it should be everywhere by now but maybe it is suppressed somehow)\n\t\t\t\tconst apiUrl = new URL(getApiBaseUrl(locator.domainConfigProvider().getCurrentDomainConfig()))\n\t\t\t\tapiUrl.pathname += `/rest/sys/session/${listIdPart(this.sessionId)}/${elementIdPart(this.sessionId)}`\n\t\t\t\tconst xhr = new XMLHttpRequest()\n\t\t\t\txhr.open(\"DELETE\", apiUrl, false) // sync requests increase reliability when invoked in onunload\n\n\t\t\t\txhr.setRequestHeader(\"accessToken\", this.accessToken)\n\t\t\t\txhr.setRequestHeader(\"v\", sysTypeModels.Session.version)\n\n\t\t\t\txhr.onload = function () {\n\t\t\t\t\t// XMLHttpRequestProgressEvent, but not needed\n\t\t\t\t\tif (xhr.status === 200) {\n\t\t\t\t\t\tconsole.log(\"deleted session\")\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t} else if (xhr.status === 401) {\n\t\t\t\t\t\tconsole.log(\"authentication failed => session is already deleted\")\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"could not delete session \" + xhr.status)\n\t\t\t\t\t\treject(new Error(\"could not delete session \" + xhr.status))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\txhr.onerror = function () {\n\t\t\t\t\tconsole.error(\"failed to request delete session\")\n\t\t\t\t\treject(new Error(\"failed to request delete session\"))\n\t\t\t\t}\n\n\t\t\t\txhr.send()\n\t\t\t}\n\t\t})\n\t}\n\n\tasync isWhitelabelAccount(): Promise<boolean> {\n\t\t// isTutanotaDomain always returns true on desktop\n\t\tif (!isDesktop()) {\n\t\t\treturn !!getWhitelabelCustomizations(window)\n\t\t}\n\n\t\tconst customerInfo = await this.loadCustomerInfo()\n\t\treturn customerInfo.domainInfos.some((domainInfo) => domainInfo.whitelabelConfig)\n\t}\n\n\tasync loadWhitelabelConfig(): Promise<\n\t\t| {\n\t\t\t\twhitelabelConfig: WhitelabelConfig\n\t\t\t\tdomainInfo: DomainInfo\n\t\t  }\n\t\t| null\n\t\t| undefined\n\t> {\n\t\t// The model allows for multiple domainInfos to have whitelabel configs\n\t\t// but in reality on the server only a single custom configuration is allowed\n\t\t// therefore the result of the filtering all domainInfos with no whitelabelConfig\n\t\t// can only be an array of length 0 or 1\n\t\tconst customerInfo = await this.loadCustomerInfo()\n\t\tconst domainInfoAndConfig = first(\n\t\t\tmapAndFilterNull(\n\t\t\t\tcustomerInfo.domainInfos,\n\t\t\t\t(domainInfo) =>\n\t\t\t\t\tdomainInfo.whitelabelConfig && {\n\t\t\t\t\t\tdomainInfo,\n\t\t\t\t\t\twhitelabelConfig: domainInfo.whitelabelConfig,\n\t\t\t\t\t},\n\t\t\t),\n\t\t)\n\n\t\tif (domainInfoAndConfig) {\n\t\t\tconst whitelabelConfig = await locator.entityClient.load(WhitelabelConfigTypeRef, domainInfoAndConfig.whitelabelConfig)\n\t\t\treturn {\n\t\t\t\tdomainInfo: domainInfoAndConfig.domainInfo,\n\t\t\t\twhitelabelConfig,\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport type UserControllerInitData = {\n\tuser: User\n\tuserGroupInfo: GroupInfo\n\tsessionId: IdTuple\n\taccessToken: Base64Url\n\tsessionType: SessionType\n\tloginUsername: string\n}\n// noinspection JSUnusedGlobalSymbols\n// dynamically imported\nexport async function initUserController({\n\tuser,\n\tuserGroupInfo,\n\tsessionId,\n\taccessToken,\n\tsessionType,\n\tloginUsername,\n}: UserControllerInitData): Promise<UserController> {\n\tconst entityClient = locator.entityClient\n\tconst [props, userSettingsGroupRoot] = await Promise.all([\n\t\tentityClient.loadRoot(TutanotaPropertiesTypeRef, user.userGroup.group),\n\t\tentityClient.load(UserSettingsGroupRootTypeRef, user.userGroup.group).catch(\n\t\t\tofClass(NotFoundError, () =>\n\t\t\t\tentityClient\n\t\t\t\t\t.setup(\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tcreateUserSettingsGroupRoot({\n\t\t\t\t\t\t\t_ownerGroup: user.userGroup.group,\n\t\t\t\t\t\t\tstartOfTheWeek: \"0\",\n\t\t\t\t\t\t\ttimeFormat: \"0\",\n\t\t\t\t\t\t\tgroupSettings: [],\n\t\t\t\t\t\t\tusageDataOptedIn: null,\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t\t.then(() => entityClient.load(UserSettingsGroupRootTypeRef, user.userGroup.group)),\n\t\t\t),\n\t\t),\n\t])\n\treturn new UserController(\n\t\tuser,\n\t\tuserGroupInfo,\n\t\tsessionId,\n\t\tprops,\n\t\taccessToken,\n\t\tuserSettingsGroupRoot,\n\t\tsessionType,\n\t\tloginUsername,\n\t\tentityClient,\n\t\tlocator.serviceExecutor,\n\t)\n}\n"],"mappings":"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"}