
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { assertNotNull, base64ToBase64Url, deepEqual, filterInt, neverNull, stringToUtf8Uint8Array, uint8ArrayToBase64 } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import "./TutanotaConstants-3bwAESYA.js";
import { handleRestError } from "./RestError-D17JEBMr.js";
import "./CryptoError-PqdvQky4.js";
import "./CancelledError-FjP5S_cR.js";
import "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import { typeModels$4 as typeModels } from "./TypeModels-BktRFNDN.js";
import { createIdTupleWrapper, createMissedNotification, createNotificationInfo } from "./TypeRefs-BP1jvX9p.js";
import "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./dist-DcZ1Y4qd.js";
import "./IndexTables-C5S9WDY9.js";
import "./IndexUtils-K27esrGs.js";
import { makeTaggedLogger } from "./DesktopLog-yAgEoQsh.js";
import "./IndexerCore-CrLYpsA5.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import "./dist-BY49f75m.js";
import { mockFetchRequest } from "./TestUtils-f_4UhLVE.js";

//#region ../src/common/desktop/sse/TutaSseFacade.ts
const log = makeTaggedLogger("[SSEFacade]");
const MISSED_NOTIFICATION_TTL = 2592e6;
var TutaSseFacade = class {
	currentSseInfo = null;
	constructor(sseStorage, notificationHandler, sseClient, crypto, appVersion, fetch, date) {
		this.sseStorage = sseStorage;
		this.notificationHandler = notificationHandler;
		this.sseClient = sseClient;
		this.crypto = crypto;
		this.appVersion = appVersion;
		this.fetch = fetch;
		this.date = date;
		sseClient.setEventListener(this);
	}
	async connect() {
		if (await this.hasNotificationTTLExpired()) {
			await this.notificationHandler.onLocalDataInvalidated();
			await this.sseStorage.clear();
			return;
		}
		if (this.currentSseInfo != null) await this.disconnect();
		const sseInfo = await this.sseStorage.getSseInfo();
		if (sseInfo == null) {
			log.debug("No SSE info");
			return;
		}
		const url = this.getSseUrl(sseInfo, sseInfo.userIds[0]);
		const headers = {
			v: typeModels.MissedNotification.version,
			cv: this.appVersion
		};
		const timeout = await this.sseStorage.getHeartbeatTimeoutSec();
		if (timeout != null) this.sseClient.setReadTimeout(timeout);
		await this.sseClient.connect({
			url,
			headers
		});
		this.currentSseInfo = sseInfo;
	}
	/**
	* We remember the last time we connected or fetched missed notification and if since the last time we did the the TTL time has
	* expired, we certainly missed some updates.
	* We need to unschedule all alarms and to tell web part that we would like alarms to be scheduled all over.
	*/
	async hasNotificationTTLExpired() {
		const lastMissedNotificationCheckTime = await this.sseStorage.getMissedNotificationCheckTime();
		log.debug("last missed notification check:", { lastMissedNotificationCheckTime });
		return lastMissedNotificationCheckTime != null && this.date.now() - lastMissedNotificationCheckTime > MISSED_NOTIFICATION_TTL;
	}
	getSseUrl(sseInfo, userId) {
		const url = new URL(sseInfo.sseOrigin);
		url.pathname = "sse";
		url.searchParams.append("_body", this.requestJson(sseInfo.identifier, userId));
		return url;
	}
	requestJson(identifier, userId) {
		return JSON.stringify({
			_format: "0",
			identifier,
			userIds: [{
				_id: this.crypto.generateId(4),
				value: userId
			}]
		});
	}
	async onNotification() {
		if (await this.sseStorage.getMissedNotificationCheckTime() == null) await this.sseStorage.recordMissedNotificationCheckTime();
		if (await this.hasNotificationTTLExpired()) {
			await this.notificationHandler.onLocalDataInvalidated();
			return;
		}
		let missedNotification;
		try {
			missedNotification = await this.downloadMissedNotification();
		} catch (e) {
			log.warn("Failed to download missed notification", e);
			return;
		}
		await this.sseStorage.setLastProcessedNotificationId(assertNotNull(missedNotification.lastProcessedNotificationId));
		await this.sseStorage.recordMissedNotificationCheckTime();
		const sseInfo = this.currentSseInfo;
		if (sseInfo == null) return;
		for (const notificationInfo of missedNotification.notificationInfos) await this.notificationHandler.onMailNotification(sseInfo, notificationInfo);
		for (const alarmNotification of missedNotification.alarmNotifications) await this.notificationHandler.onAlarmNotification(alarmNotification);
	}
	async downloadMissedNotification() {
		const sseInfo = assertNotNull(this.currentSseInfo);
		const url = this.makeMissedNotificationUrl(sseInfo);
		log.debug("downloading missed notification");
		const headers = {
			userIds: sseInfo.userIds[0],
			v: typeModels.MissedNotification.version,
			cv: this.appVersion
		};
		const lastProcessedId = await this.sseStorage.getLastProcessedNotificationId();
		if (lastProcessedId) headers["lastProcessedNotificationId"] = lastProcessedId;
		const res = await this.fetch(url, { headers });
		if (!res.ok) throw handleRestError(neverNull(res.status), url, res.headers.get("error-id"), null);
else {
			const json = await res.json();
			log.debug("downloaded missed notification");
			return json;
		}
	}
	makeMissedNotificationUrl(sseInfo) {
		const { identifier, sseOrigin } = sseInfo;
		const customId = uint8ArrayToBase64(stringToUtf8Uint8Array(identifier));
		const url = new URL(sseOrigin);
		url.pathname = "rest/sys/missednotification/" + base64ToBase64Url(customId);
		return url.toString();
	}
	async onNewMessage(message) {
		if (message === "data: notification") {
			log.debug("notification");
			await this.onNotification();
		} else if (message.startsWith("data: heartbeatTimeout:")) {
			const timeoutString = message.split(":").at(2);
			log.debug("heartbeatTimeout", timeoutString);
			const timeout = timeoutString == null ? null : filterInt(timeoutString);
			if (timeout != null && !isNaN(timeout)) {
				await this.sseStorage.setHeartbeatTimeoutSec(timeout);
				this.sseClient.setReadTimeout(timeout);
			}
		}
	}
	async onNotAuthenticated() {
		log.debug("got NotAuthenticated, deleting userId");
		let lastSseInfo = this.currentSseInfo;
		this.currentSseInfo = null;
		if (lastSseInfo == null) {
			log.warn("NotAuthorized while not connected?");
			return;
		}
		const firstUser = lastSseInfo.userIds.at(0);
		await this.removeUserIdInternal(firstUser);
	}
	async removeUser(userId) {
		await this.removeUserIdInternal(userId);
		await this.connect();
	}
	async removeUserIdInternal(userId) {
		let sseInfo;
		if (userId != null) {
			sseInfo = await this.sseStorage.removeUser(userId);
			await this.notificationHandler.onUserRemoved(userId);
		} else sseInfo = await this.sseStorage.getSseInfo();
		if (sseInfo?.userIds.length === 0) {
			log.debug("No user ids, skipping reconnect");
			await this.notificationHandler.onLocalDataInvalidated();
			await this.sseStorage.clear();
		}
	}
	async reconnect() {
		await this.disconnect();
		await this.connect();
	}
	async disconnect() {
		this.currentSseInfo = null;
		await this.sseClient.disconnect();
	}
};

//#endregion
//#region tests/desktop/sse/TutaSseFacadeTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
const APP_V = "3";
dist_default.spec("TutaSseFacade", () => {
	let sseFacade;
	let sseStorage;
	let notificationHandler;
	let sseClient;
	let crypto;
	let fetch;
	let date;
	dist_default.beforeEach(() => {
		sseStorage = (0, import_testdouble.object)();
		notificationHandler = (0, import_testdouble.object)();
		sseClient = (0, import_testdouble.object)();
		crypto = (0, import_testdouble.object)();
		fetch = (0, import_testdouble.func)();
		date = (0, import_testdouble.object)();
		sseFacade = new TutaSseFacade(sseStorage, notificationHandler, sseClient, crypto, APP_V, fetch, date);
	});
	function setupSseInfo(template = {}) {
		const sseInfo = {
			identifier: "id",
			sseOrigin: "http://something.com",
			userIds: ["userId"],
			...template
		};
		(0, import_testdouble.when)(sseStorage.getSseInfo()).thenResolve(sseInfo);
		return sseInfo;
	}
	dist_default.spec("connect", () => {
		dist_default.test("connect", async () => {
			setupSseInfo();
			await sseFacade.connect();
			const url = new URL("http://something.com/sse?_body=%7B%22_format%22%3A%220%22%2C%22identifier%22%3A%22id%22%2C%22userIds%22%3A%5B%7B%22value%22%3A%22userId%22%7D%5D%7D");
			(0, import_testdouble.verify)(sseClient.connect(import_testdouble.matchers.argThat((opts) => {
				return opts.url.toString() === url.toString() && deepEqual(opts.headers, {
					v: typeModels.MissedNotification.version,
					cv: APP_V
				});
			})));
		});
		dist_default.test("connect when notification TTL expired", async () => {
			(0, import_testdouble.when)(date.now()).thenReturn(MISSED_NOTIFICATION_TTL + 100);
			(0, import_testdouble.when)(sseStorage.getMissedNotificationCheckTime()).thenResolve(1);
			await sseFacade.connect();
			(0, import_testdouble.verify)(notificationHandler.onLocalDataInvalidated());
			(0, import_testdouble.verify)(sseStorage.clear());
			(0, import_testdouble.verify)(sseClient.connect(import_testdouble.matchers.anything()), { times: 0 });
		});
		dist_default.test("disconnect and reconnect when already connected", async () => {
			setupSseInfo();
			await sseFacade.connect();
			await sseFacade.connect();
			(0, import_testdouble.verify)(sseClient.disconnect());
			(0, import_testdouble.verify)(sseClient.connect(import_testdouble.matchers.anything()), { times: 2 });
		});
		dist_default.test("set heartbeat timeout when connecting", async () => {
			(0, import_testdouble.when)(sseStorage.getHeartbeatTimeoutSec()).thenResolve(1);
			setupSseInfo();
			await sseFacade.connect();
			(0, import_testdouble.verify)(sseClient.setReadTimeout(1));
		});
	});
	dist_default.spec("onNotification", () => {
		dist_default.test("downloads and handles notification", async () => {
			const headers = {
				userIds: "userId",
				v: typeModels.MissedNotification.version,
				cv: APP_V
			};
			const sseInfo = setupSseInfo();
			await sseFacade.connect();
			const alarmNotification = { _marker: "encryptedAlarmNotification" };
			const notificationInfo = createNotificationInfo({
				_id: "notificationInfoId",
				_ownerGroup: "ownerGroupId",
				userId: "userId",
				mailId: createIdTupleWrapper({
					listId: "mailListId",
					listElementId: "mailElementId"
				}),
				mailAddress: "test@mail.address"
			});
			const missedNotification = createMissedNotification({
				_ownerEncSessionKey: null,
				_ownerGroup: "ownerGroupId",
				_permissions: "permissionsId",
				changeTime: new Date("2024-04-22"),
				confirmationId: "confirmationId",
				lastProcessedNotificationId: "lastProcessedNotificationId",
				alarmNotifications: [],
				notificationInfos: [notificationInfo]
			});
			const encryptedMissedNotification = Object.assign({}, missedNotification, { alarmNotifications: [alarmNotification] });
			const jsonDefer = mockFetchRequest(fetch, "http://something.com/rest/sys/missednotification/aWQ", headers, 200, encryptedMissedNotification);
			await sseFacade.onNewMessage("data: notification");
			await jsonDefer;
			(0, import_testdouble.verify)(sseStorage.setLastProcessedNotificationId("lastProcessedNotificationId"));
			(0, import_testdouble.verify)(sseStorage.recordMissedNotificationCheckTime());
			(0, import_testdouble.verify)(notificationHandler.onMailNotification(sseInfo, notificationInfo));
			(0, import_testdouble.verify)(notificationHandler.onAlarmNotification(alarmNotification));
		});
		dist_default.test("passes lastProcessedNotificationId if present", async () => {
			const previousLastProcessedNotificationId = "previousLastProcessedNotificationId";
			const newLastProcessedNotificationId = "newLastProcessedNotificationId";
			const headers = {
				userIds: "userId",
				v: typeModels.MissedNotification.version,
				cv: APP_V,
				lastProcessedNotificationId: previousLastProcessedNotificationId
			};
			setupSseInfo();
			(0, import_testdouble.when)(sseStorage.getLastProcessedNotificationId()).thenResolve(previousLastProcessedNotificationId);
			const missedNotification = createMissedNotification({
				_ownerEncSessionKey: null,
				_ownerGroup: "ownerGroupId",
				_permissions: "permissionsId",
				changeTime: new Date("2024-04-22"),
				confirmationId: "confirmationId",
				lastProcessedNotificationId: newLastProcessedNotificationId,
				alarmNotifications: [],
				notificationInfos: []
			});
			const encryptedMissedNotification = Object.assign({}, missedNotification, { alarmNotifications: [] });
			await sseFacade.connect();
			const jsonDefer = mockFetchRequest(fetch, "http://something.com/rest/sys/missednotification/aWQ", headers, 200, encryptedMissedNotification);
			await sseFacade.onNewMessage("data: notification");
			await jsonDefer;
			(0, import_testdouble.verify)(sseStorage.setLastProcessedNotificationId(newLastProcessedNotificationId));
		});
	});
	dist_default.spec("heartbeat", () => {
		dist_default.test("saves valid heartbeat and passes it to sse client", async () => {
			setupSseInfo();
			await sseFacade.connect();
			await sseFacade.onNewMessage("data: heartbeatTimeout:240");
			(0, import_testdouble.verify)(sseStorage.setHeartbeatTimeoutSec(240));
			(0, import_testdouble.verify)(sseClient.setReadTimeout(240));
		});
	});
	dist_default.spec("onNotAuthenticated", () => {
		dist_default.test("when it has more than one user it removes the first one", async () => {
			setupSseInfo({ userIds: ["user1", "user2"] });
			await sseFacade.connect();
			await sseFacade.onNotAuthenticated();
			(0, import_testdouble.verify)(sseStorage.removeUser("user1"));
			(0, import_testdouble.verify)(notificationHandler.onUserRemoved("user1"));
		});
		dist_default.test("when it has only one user it invalidates the storage", async () => {
			const sseInfo = setupSseInfo({ userIds: ["user1"] });
			(0, import_testdouble.when)(sseStorage.removeUser("user1")).thenResolve({
				...sseInfo,
				userIds: []
			});
			await sseFacade.connect();
			await sseFacade.onNotAuthenticated();
			(0, import_testdouble.verify)(notificationHandler.onUserRemoved("user1"));
			(0, import_testdouble.verify)(sseStorage.clear());
			(0, import_testdouble.verify)(notificationHandler.onLocalDataInvalidated());
		});
	});
	dist_default.spec("removeUser", () => {
		dist_default.test("reconnects with new SSE info", async () => {
			(0, import_testdouble.when)(sseStorage.getSseInfo()).thenResolve({
				identifier: "id",
				sseOrigin: "http://something.com",
				userIds: ["user1", "user2"]
			}, {
				identifier: "id",
				sseOrigin: "http://something.com",
				userIds: ["user1"]
			});
			await sseFacade.connect();
			await sseFacade.removeUser("user2");
			(0, import_testdouble.verify)(sseStorage.removeUser("user2"));
			(0, import_testdouble.verify)(notificationHandler.onUserRemoved("user2"));
			const captor = import_testdouble.matchers.captor();
			(0, import_testdouble.verify)(sseClient.connect(captor.capture()));
			const url = captor.values[1].url;
			const body = url.searchParams.get("_body");
			dist_default(JSON.parse(body).userIds).deepEquals([{ value: "user1" }]);
		});
		dist_default.test("does not reconnect if there are no more users", async () => {
			(0, import_testdouble.when)(sseStorage.getSseInfo()).thenResolve({
				identifier: "id",
				sseOrigin: "http://something.com",
				userIds: ["user1"]
			}, null);
			(0, import_testdouble.when)(sseStorage.removeUser("user1")).thenResolve({
				identifier: "id",
				sseOrigin: "http://something.com",
				userIds: []
			});
			await sseFacade.connect();
			await sseFacade.removeUser("user1");
			(0, import_testdouble.verify)(sseStorage.removeUser("user1"));
			(0, import_testdouble.verify)(notificationHandler.onUserRemoved("user1"));
			(0, import_testdouble.verify)(sseStorage.clear());
			(0, import_testdouble.verify)(notificationHandler.onLocalDataInvalidated());
			(0, import_testdouble.verify)(sseClient.connect(import_testdouble.matchers.anything()), { times: 1 });
		});
	});
});

//#endregion
//# sourceMappingURL=TutaSseFacadeTest-DdOMHyC8.js.map