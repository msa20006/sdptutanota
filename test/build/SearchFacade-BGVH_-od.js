
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { TypeRef, arrayHash, asyncFind, contains, downcast, getDayShifted, getStartOfDay, isEmpty, isNotEmpty, isNotNull, isSameTypeRef, neverNull, ofClass, pMap, promiseMapCompat, tokenize, uint8ArrayToBase64 } from "./dist-CJHwsXKY.js";
import { FULL_INDEXED_TIMESTAMP, NOTHING_INDEXED_TIMESTAMP } from "./TutanotaConstants-3bwAESYA.js";
import { NotAuthorizedError, NotFoundError } from "./RestError-D17JEBMr.js";
import { AssociationType, Cardinality, ValueType, compareNewestFirst, elementIdPart, firstBiggerThanSecond, getListId, timestampToGeneratedId } from "./EntityUtils-RQxXZlcV.js";
import { MailTypeRef } from "./TypeRefs-CR3TLWn0.js";
import { resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import { ElementDataOS, SearchIndexMetaDataOS, SearchIndexOS, SearchIndexWordsIndex } from "./IndexTables-C5S9WDY9.js";
import { decryptMetaData, decryptSearchIndexEntry, encryptIndexKeyBase64, getIdFromEncSearchIndexEntry, getPerformanceTimestamp, iterateBinaryBlocks, markEnd, markStart, printMeasure, typeRefToTypeInfo } from "./IndexUtils-K27esrGs.js";
import { INITIAL_MAIL_INDEX_INTERVAL_DAYS } from "./MailIndexer-DcPkSBCs.js";

//#region ../src/mail-app/workerUtils/index/SearchFacade.ts
var SearchFacade = class {
	_db;
	_mailIndexer;
	_suggestionFacades;
	_promiseMapCompat;
	_entityClient;
	constructor(userFacade, db, mailIndexer, suggestionFacades, browserData, entityClient) {
		this.userFacade = userFacade;
		this._db = db;
		this._mailIndexer = mailIndexer;
		this._suggestionFacades = suggestionFacades;
		this._promiseMapCompat = promiseMapCompat(browserData.needsMicrotaskHack);
		this._entityClient = entityClient;
	}
	/****************************** SEARCH ******************************/
	/**
	* Invoke an AND-query.
	* @param query is tokenized. All tokens must be matched by the result (AND-query)
	* @param minSuggestionCount If minSuggestionCount > 0 regards the last query token as suggestion token and includes suggestion results for that token, but not less than minSuggestionCount
	* @returns The result ids are sorted by id from newest to oldest
	*/
	search(query, restriction, minSuggestionCount, maxResults) {
		return this._db.initialized.then(() => {
			let searchTokens = tokenize(query);
			let result = {
				query,
				restriction,
				results: [],
				currentIndexTimestamp: this._getSearchEndTimestamp(restriction),
				lastReadSearchIndexRow: searchTokens.map((token) => [token, null]),
				matchWordOrder: searchTokens.length > 1 && query.startsWith("\"") && query.endsWith("\""),
				moreResults: [],
				moreResultsEntries: []
			};
			if (searchTokens.length > 0) {
				let isFirstWordSearch = searchTokens.length === 1;
				let before = getPerformanceTimestamp();
				let suggestionFacade = this._suggestionFacades.find((f) => isSameTypeRef(f.type, restriction.type));
				let searchPromise;
				if (minSuggestionCount > 0 && isFirstWordSearch && suggestionFacade) {
					let addSuggestionBefore = getPerformanceTimestamp();
					searchPromise = this._addSuggestions(searchTokens[0], suggestionFacade, minSuggestionCount, result).then(() => {
						if (result.results.length < minSuggestionCount) {
							let searchForTokensAfterSuggestionsBefore = getPerformanceTimestamp();
							return this._startOrContinueSearch(result).then((result$1) => {
								return result$1;
							});
						}
					});
				} else if (minSuggestionCount > 0 && !isFirstWordSearch && suggestionFacade) {
					let suggestionToken = neverNull(result.lastReadSearchIndexRow.pop())[0];
					searchPromise = this._startOrContinueSearch(result).then(() => {
						result.results.sort(compareNewestFirst);
						return this._loadAndReduce(restriction, result, suggestionToken, minSuggestionCount);
					});
				} else searchPromise = this._startOrContinueSearch(result, maxResults);
				return searchPromise.then(() => {
					result.results.sort(compareNewestFirst);
					return result;
				});
			} else return Promise.resolve(result);
		});
	}
	async _loadAndReduce(restriction, result, suggestionToken, minSuggestionCount) {
		if (result.results.length > 0) {
			const model = await resolveTypeReference(restriction.type);
			const suggestionQuery = result.matchWordOrder ? normalizeQuery(result.query) : suggestionToken;
			const finalResults = [];
			for (const id of result.results) if (finalResults.length >= minSuggestionCount) break;
else {
				let entity;
				try {
					entity = await this._entityClient.load(restriction.type, id);
				} catch (e) {
					if (e instanceof NotFoundError || e instanceof NotAuthorizedError) continue;
else throw e;
				}
				const found = await this._containsSuggestionToken(entity, model, restriction.attributeIds, suggestionQuery, result.matchWordOrder);
				if (found) finalResults.push(id);
			}
			result.results = finalResults;
		} else return Promise.resolve();
	}
	/**
	* Looks for a word in any of the entities string values or aggregations string values that starts with suggestionToken.
	* @param attributeIds Only looks in these attribute ids (or all its string values if it is an aggregation attribute id. If null, looks in all string values and aggregations.
	*/
	_containsSuggestionToken(entity, model, attributeIds, suggestionToken, matchWordOrder) {
		let attributeNames;
		if (!attributeIds) attributeNames = Object.keys(model.values).concat(Object.keys(model.associations));
else attributeNames = attributeIds.map((id) => neverNull(Object.keys(model.values).find((valueName) => model.values[valueName].id === id) || Object.keys(model.associations).find((associationName) => model.associations[associationName].id === id)));
		return asyncFind(attributeNames, async (attributeName) => {
			if (model.values[attributeName] && model.values[attributeName].type === ValueType.String && entity[attributeName]) if (matchWordOrder) return Promise.resolve(normalizeQuery(entity[attributeName]).indexOf(suggestionToken) !== -1);
else {
				let words = tokenize(entity[attributeName]);
				return Promise.resolve(words.some((w) => w.startsWith(suggestionToken)));
			}
else if (model.associations[attributeName] && model.associations[attributeName].type === AssociationType.Aggregation && entity[attributeName]) {
				let aggregates = model.associations[attributeName].cardinality === Cardinality.Any ? entity[attributeName] : [entity[attributeName]];
				const refModel = await resolveTypeReference(new TypeRef(model.app, model.associations[attributeName].refType));
				return asyncFind(aggregates, (aggregate) => {
					return this._containsSuggestionToken(downcast(aggregate), refModel, null, suggestionToken, matchWordOrder);
				}).then((found) => found != null);
			} else return Promise.resolve(false);
		}).then((found) => found != null);
	}
	_startOrContinueSearch(searchResult, maxResults) {
		markStart("findIndexEntries");
		const nextScheduledIndexingRun = getStartOfDay(getDayShifted(new Date(this._mailIndexer.currentIndexTimestamp), INITIAL_MAIL_INDEX_INTERVAL_DAYS));
		const theDayAfterTomorrow = getStartOfDay(getDayShifted(new Date(), 1));
		if (searchResult.moreResults.length === 0 && nextScheduledIndexingRun.getTime() > theDayAfterTomorrow.getTime() && !this._mailIndexer.isIndexing) this._mailIndexer.extendIndexIfNeeded(this.userFacade.getLoggedInUser(), getStartOfDay(getDayShifted(new Date(), -INITIAL_MAIL_INDEX_INTERVAL_DAYS)).getTime());
		let moreResultsEntries;
		if (maxResults && searchResult.moreResults.length >= maxResults) moreResultsEntries = Promise.resolve(searchResult.moreResults);
else moreResultsEntries = this._findIndexEntries(searchResult, maxResults).then((keyToEncryptedIndexEntries) => {
			markEnd("findIndexEntries");
			markStart("_filterByEncryptedId");
			return this._filterByEncryptedId(keyToEncryptedIndexEntries);
		}).then((keyToEncryptedIndexEntries) => {
			markEnd("_filterByEncryptedId");
			markStart("_decryptSearchResult");
			return this._decryptSearchResult(keyToEncryptedIndexEntries);
		}).then((keyToIndexEntries) => {
			markEnd("_decryptSearchResult");
			markStart("_filterByTypeAndAttributeAndTime");
			return this._filterByTypeAndAttributeAndTime(keyToIndexEntries, searchResult.restriction);
		}).then((keyToIndexEntries) => {
			markEnd("_filterByTypeAndAttributeAndTime");
			markStart("_reduceWords");
			return this._reduceWords(keyToIndexEntries, searchResult.matchWordOrder);
		}).then((searchIndexEntries) => {
			markEnd("_reduceWords");
			markStart("_reduceToUniqueElementIds");
			return this._reduceToUniqueElementIds(searchIndexEntries, searchResult);
		}).then((additionalEntries) => {
			markEnd("_reduceToUniqueElementIds");
			return additionalEntries.concat(searchResult.moreResults);
		});
		return moreResultsEntries.then((searchIndexEntries) => {
			markStart("_filterByListIdAndGroupSearchResults");
			return this._filterByListIdAndGroupSearchResults(searchIndexEntries, searchResult, maxResults);
		}).then((result) => {
			markEnd("_filterByListIdAndGroupSearchResults");
			if (typeof self !== "undefined") printMeasure("query: " + searchResult.query + ", maxResults: " + String(maxResults), [
				"findIndexEntries",
				"_filterByEncryptedId",
				"_decryptSearchResult",
				"_filterByTypeAndAttributeAndTime",
				"_reduceWords",
				"_reduceToUniqueElementIds",
				"_filterByListIdAndGroupSearchResults"
			]);
			return result;
		});
	}
	/**
	* Adds suggestions for the given searchToken to the searchResult until at least minSuggestionCount results are existing
	*/
	_addSuggestions(searchToken, suggestionFacade, minSuggestionCount, searchResult) {
		let suggestions = suggestionFacade.getSuggestions(searchToken);
		return pMap(suggestions, (suggestion) => {
			if (searchResult.results.length < minSuggestionCount) {
				const suggestionResult = {
					query: suggestion,
					restriction: searchResult.restriction,
					results: searchResult.results,
					currentIndexTimestamp: searchResult.currentIndexTimestamp,
					lastReadSearchIndexRow: [[suggestion, null]],
					matchWordOrder: false,
					moreResults: [],
					moreResultsEntries: []
				};
				return this._startOrContinueSearch(suggestionResult);
			}
		});
	}
	_findIndexEntries(searchResult, maxResults) {
		const typeInfo = typeRefToTypeInfo(searchResult.restriction.type);
		const firstSearchTokenInfo = searchResult.lastReadSearchIndexRow[0];
		return this._db.dbFacade.createTransaction(true, [SearchIndexOS, SearchIndexMetaDataOS]).then((transaction) => {
			return this._promiseMapCompat(searchResult.lastReadSearchIndexRow, (tokenInfo, index) => {
				const [searchToken] = tokenInfo;
				let indexKey = encryptIndexKeyBase64(this._db.key, searchToken, this._db.iv);
				return transaction.get(SearchIndexMetaDataOS, indexKey, SearchIndexWordsIndex).then((metaData) => {
					if (!metaData) {
						tokenInfo[1] = 0;
						return {
							id: -index,
							word: indexKey,
							rows: []
						};
					}
					return decryptMetaData(this._db.key, metaData);
				});
			}).thenOrApply((metaRows) => {
				const rowsToReadForIndexKeys = this._findRowsToReadFromMetaData(firstSearchTokenInfo, metaRows, typeInfo, maxResults);
				return this._promiseMapCompat(rowsToReadForIndexKeys, (rowsToRead) => {
					return this._promiseMapCompat(rowsToRead.rows, (entry) => this._findEntriesForMetadata(transaction, entry)).thenOrApply((a) => a.flat()).thenOrApply((indexEntries) => {
						return indexEntries.map((entry) => ({
							encEntry: entry,
							idHash: arrayHash(getIdFromEncSearchIndexEntry(entry))
						}));
					}).thenOrApply((indexEntries) => {
						return {
							indexKey: rowsToRead.indexKey,
							indexEntries
						};
					}).value;
				}).value;
			}).toPromise();
		});
	}
	_findRowsToReadFromMetaData(firstTokenInfo, safeMetaDataRows, typeInfo, maxResults) {
		const leadingRow = safeMetaDataRows[0];
		const otherRows = safeMetaDataRows.slice(1);
		const rangeForLeadingRow = this._findRowsToRead(leadingRow, typeInfo, firstTokenInfo[1] || Number.MAX_SAFE_INTEGER, maxResults);
		const rowsForLeadingRow = [{
			indexKey: leadingRow.word,
			rows: rangeForLeadingRow.metaEntries
		}];
		firstTokenInfo[1] = rangeForLeadingRow.oldestTimestamp;
		const rowsForOtherRows = otherRows.map((r) => {
			return {
				indexKey: r.word,
				rows: this._findRowsToReadByTimeRange(r, typeInfo, rangeForLeadingRow.newestRowTimestamp, rangeForLeadingRow.oldestTimestamp)
			};
		});
		return rowsForLeadingRow.concat(rowsForOtherRows);
	}
	_findEntriesForMetadata(transaction, entry) {
		return transaction.get(SearchIndexOS, entry.key).then((indexEntriesRow) => {
			if (!indexEntriesRow) return [];
			const result = new Array(entry.size);
			iterateBinaryBlocks(indexEntriesRow, (block, s, e, iteration) => {
				result[iteration] = block;
			});
			return result;
		});
	}
	_findRowsToReadByTimeRange(metaData, typeInfo, fromNewestTimestamp, toOldestTimestamp) {
		const filteredRows = metaData.rows.filter((r) => r.app === typeInfo.appId && r.type === typeInfo.typeId);
		filteredRows.reverse();
		const passedRows = [];
		for (let row of filteredRows) if (row.oldestElementTimestamp < fromNewestTimestamp) {
			passedRows.push(row);
			if (row.oldestElementTimestamp <= toOldestTimestamp) break;
		}
		return passedRows;
	}
	_findRowsToRead(metaData, typeInfo, mustBeOlderThan, maxResults) {
		const filteredRows = metaData.rows.filter((r) => r.app === typeInfo.appId && r.type === typeInfo.typeId);
		filteredRows.reverse();
		let entitiesToRead = 0;
		let lastReadRowTimestamp = 0;
		let newestRowTimestamp = Number.MAX_SAFE_INTEGER;
		let rowsToRead;
		if (maxResults) {
			rowsToRead = [];
			for (let r of filteredRows) if (r.oldestElementTimestamp < mustBeOlderThan) if (entitiesToRead < 1e3) {
				entitiesToRead += r.size;
				lastReadRowTimestamp = r.oldestElementTimestamp;
				rowsToRead.push(r);
			} else break;
else newestRowTimestamp = r.oldestElementTimestamp;
		} else rowsToRead = filteredRows;
		return {
			metaEntries: rowsToRead,
			oldestTimestamp: lastReadRowTimestamp,
			newestRowTimestamp
		};
	}
	/**
	* Reduces the search result by filtering out all mailIds that don't match all search tokens
	*/
	_filterByEncryptedId(results) {
		let matchingEncIds = null;
		for (const keyToEncryptedIndexEntry of results) if (matchingEncIds == null) matchingEncIds = new Set(keyToEncryptedIndexEntry.indexEntries.map((entry) => entry.idHash));
else {
			const filtered = new Set();
			for (const indexEntry of keyToEncryptedIndexEntry.indexEntries) if (matchingEncIds.has(indexEntry.idHash)) filtered.add(indexEntry.idHash);
			matchingEncIds = filtered;
		}
		return results.map((r) => {
			return {
				indexKey: r.indexKey,
				indexEntries: r.indexEntries.filter((entry) => matchingEncIds?.has(entry.idHash))
			};
		});
	}
	_decryptSearchResult(results) {
		return results.map((searchResult) => {
			return {
				indexKey: searchResult.indexKey,
				indexEntries: searchResult.indexEntries.map((entry) => decryptSearchIndexEntry(this._db.key, entry.encEntry, this._db.iv))
			};
		});
	}
	_filterByTypeAndAttributeAndTime(results, restriction) {
		let endTimestamp = this._getSearchEndTimestamp(restriction);
		const minIncludedId = timestampToGeneratedId(endTimestamp);
		const maxExcludedId = restriction.start ? timestampToGeneratedId(restriction.start + 1) : null;
		for (const result of results) result.indexEntries = result.indexEntries.filter((entry) => {
			return this._isValidAttributeAndTime(restriction, entry, minIncludedId, maxExcludedId);
		});
		let matchingIds = null;
		for (const keyToIndexEntry of results) if (!matchingIds) matchingIds = new Set(keyToIndexEntry.indexEntries.map((entry) => entry.id));
else {
			let filtered = new Set();
			for (const entry of keyToIndexEntry.indexEntries) if (matchingIds.has(entry.id)) filtered.add(entry.id);
			matchingIds = filtered;
		}
		return results.map((r) => {
			return {
				indexKey: r.indexKey,
				indexEntries: r.indexEntries.filter((entry) => matchingIds?.has(entry.id))
			};
		});
	}
	_isValidAttributeAndTime(restriction, entry, minIncludedId, maxExcludedId) {
		if (restriction.attributeIds) {
			if (!contains(restriction.attributeIds, entry.attribute)) return false;
		}
		if (maxExcludedId) {
			if (!firstBiggerThanSecond(maxExcludedId, entry.id)) return false;
		}
		return !firstBiggerThanSecond(minIncludedId, entry.id);
	}
	_reduceWords(results, matchWordOrder) {
		if (matchWordOrder) return results[0].indexEntries.filter((firstWordEntry) => {
			let filteredPositions = firstWordEntry.positions.slice();
			for (let i = 1; i < results.length; i++) {
				let entry = results[i].indexEntries.find((e) => e.id === firstWordEntry.id && e.attribute === firstWordEntry.attribute);
				if (entry) filteredPositions = filteredPositions.filter((firstWordPosition) => neverNull(entry).positions.find((position) => position === firstWordPosition + i));
else filteredPositions = [];
			}
			return filteredPositions.length > 0;
		});
else return results[0].indexEntries;
	}
	_reduceToUniqueElementIds(results, previousResult) {
		const uniqueIds = new Set();
		return results.filter((entry) => {
			if (!uniqueIds.has(entry.id) && !previousResult.results.some((r) => r[1] === entry.id)) {
				uniqueIds.add(entry.id);
				return true;
			} else return false;
		});
	}
	_filterByListIdAndGroupSearchResults(indexEntries, searchResult, maxResults) {
		indexEntries.sort((l, r) => compareNewestFirst(l.id, r.id));
		const entriesCopy = downcast(indexEntries.slice());
		return this._db.dbFacade.createTransaction(true, [ElementDataOS]).then((transaction) => pMap(indexEntries.slice(0, maxResults || indexEntries.length + 1), async (entry, index) => {
			return transaction.get(ElementDataOS, uint8ArrayToBase64(entry.encId)).then((elementData) => {
				entriesCopy[index] = null;
				if (elementData) return [elementData[0], entry.id];
else return null;
			});
		}, { concurrency: 5 })).then((intermediateResults) => intermediateResults.filter(isNotNull)).then(async (intermediateResults) => {
			if (isEmpty(searchResult.restriction.folderIds)) return intermediateResults;
else {
				const mails = await Promise.all(intermediateResults.map((intermediateResultId) => this._entityClient.load(MailTypeRef, intermediateResultId).catch(ofClass(NotFoundError, () => {
					console.log(`Could not find updated mail ${JSON.stringify(intermediateResultId)}`);
					return null;
				}))));
				return mails.filter(isNotNull).filter((mail) => {
					let folderIds;
					if (isNotEmpty(mail.sets)) folderIds = mail.sets.map((setId) => elementIdPart(setId));
else folderIds = [getListId(mail)];
					return folderIds.some((folderId) => searchResult.restriction.folderIds.includes(folderId));
				}).map((mail) => mail._id);
			}
		}).then((newResults) => {
			searchResult.results.push(...newResults);
			searchResult.moreResults = entriesCopy.filter(isNotNull);
		});
	}
	async getMoreSearchResults(searchResult, moreResultCount) {
		await this._startOrContinueSearch(searchResult, moreResultCount);
		return searchResult;
	}
	_getSearchEndTimestamp(restriction) {
		if (restriction.end) return restriction.end;
else if (isSameTypeRef(MailTypeRef, restriction.type)) return this._mailIndexer.currentIndexTimestamp === NOTHING_INDEXED_TIMESTAMP ? Date.now() : this._mailIndexer.currentIndexTimestamp;
else return FULL_INDEXED_TIMESTAMP;
	}
};
function normalizeQuery(query) {
	return tokenize(query).join(" ");
}

//#endregion
export { SearchFacade };
//# sourceMappingURL=SearchFacade-BGVH_-od.js.map