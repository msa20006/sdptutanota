
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, first, groupBy, isEmpty, isNotNull, neverNull, noOp, ofClass, pMap } from "./dist-CJHwsXKY.js";
import { FULL_INDEXED_TIMESTAMP, ImportStatus, MailSetKind, MailState, NOTHING_INDEXED_TIMESTAMP, OperationType } from "./TutanotaConstants-3bwAESYA.js";
import { ConnectionError, NotAuthorizedError, NotFoundError } from "./RestError-D17JEBMr.js";
import { hasError } from "./ErrorUtils-o1-v67Dd.js";
import { DbError } from "./DbError-CcwZaPG2.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { LEGACY_BCC_RECIPIENTS_ID, LEGACY_BODY_ID, LEGACY_CC_RECIPIENTS_ID, LEGACY_TO_RECIPIENTS_ID, deconstructMailSetEntryId, elementIdPart, isSameId, listIdPart } from "./EntityUtils-RQxXZlcV.js";
import { typeModels$3 as typeModels } from "./TypeModels-XIXYys8J.js";
import { ImportMailStateTypeRef, ImportedMailTypeRef, MailBoxTypeRef, MailDetailsBlobTypeRef, MailDetailsDraftTypeRef, MailFolderTypeRef, MailSetEntryTypeRef, MailTypeRef, MailboxGroupRootTypeRef } from "./TypeRefs-CR3TLWn0.js";
import { ProgressMonitor } from "./ProgressMonitor-HBfOF56H.js";
import { containsEventOfType } from "./EntityUpdateUtils-B5iTKMk4.js";
import { b64UserIdHash } from "./DbFacade-DYw6Nyfw.js";
import { ElementDataOS, GroupDataOS, MetaDataOS, Metadata } from "./IndexTables-C5S9WDY9.js";
import { _createNewIndexUpdate, encryptIndexKeyBase64, filterMailMemberships, getPerformanceTimestamp, htmlToText, typeRefToTypeInfo } from "./IndexUtils-K27esrGs.js";
import { getDisplayedSender, getMailBodyText } from "./CommonMailUtils-DNufl6ib.js";
import { isDraft } from "./MailChecks-PhVUoR7f.js";
import { IndexingErrorReason } from "./SearchTypes-BQT7nl8f.js";

//#region ../src/mail-app/workerUtils/index/MailIndexer.ts
const INITIAL_MAIL_INDEX_INTERVAL_DAYS = 28;
const MAIL_INDEX_BATCH_INTERVAL = 864e5;
var MailIndexer = class {
	currentIndexTimestamp;
	mailIndexingEnabled;
	mailboxIndexingPromise;
	isIndexing = false;
	_indexingCancelled;
	_core;
	_db;
	_dateProvider;
	constructor(core, db, infoMessageHandler, bulkLoaderFactory, entityClient, dateProvider, mailFacade) {
		this.infoMessageHandler = infoMessageHandler;
		this.bulkLoaderFactory = bulkLoaderFactory;
		this.entityClient = entityClient;
		this.mailFacade = mailFacade;
		this._core = core;
		this._db = db;
		this.currentIndexTimestamp = NOTHING_INDEXED_TIMESTAMP;
		this.mailIndexingEnabled = false;
		this.mailboxIndexingPromise = Promise.resolve();
		this._indexingCancelled = false;
		this._dateProvider = dateProvider;
	}
	createMailIndexEntries(mail, mailDetails, files) {
		let startTimeIndex = getPerformanceTimestamp();
		let senderToIndex;
		const hasSender = mail.sender != null;
		if (hasSender) senderToIndex = getDisplayedSender(mail);
		const MailModel = typeModels.Mail;
		const MailDetailsModel = typeModels.MailDetails;
		const RecipientModel = typeModels.Recipients;
		let keyToIndexEntries = this._core.createIndexEntriesForAttributes(mail, [
			{
				attribute: MailModel.values["subject"],
				value: () => mail.subject
			},
			{
				attribute: Object.assign({}, RecipientModel.associations["toRecipients"], { id: LEGACY_TO_RECIPIENTS_ID }),
				value: () => mailDetails.recipients.toRecipients.map((r) => r.name + " <" + r.address + ">").join(",")
			},
			{
				attribute: Object.assign({}, RecipientModel.associations["ccRecipients"], { id: LEGACY_CC_RECIPIENTS_ID }),
				value: () => mailDetails.recipients.ccRecipients.map((r) => r.name + " <" + r.address + ">").join(",")
			},
			{
				attribute: Object.assign({}, RecipientModel.associations["bccRecipients"], { id: LEGACY_BCC_RECIPIENTS_ID }),
				value: () => mailDetails.recipients.bccRecipients.map((r) => r.name + " <" + r.address + ">").join(",")
			},
			{
				attribute: MailModel.associations["sender"],
				value: () => hasSender ? senderToIndex.name + " <" + senderToIndex.address + ">" : ""
			},
			{
				attribute: Object.assign({}, MailDetailsModel.associations["body"], { id: LEGACY_BODY_ID }),
				value: () => htmlToText(getMailBodyText(mailDetails.body))
			},
			{
				attribute: MailModel.associations["attachments"],
				value: () => files.map((file) => file.name).join(" ")
			}
		]);
		this._core._stats.indexingTime += getPerformanceTimestamp() - startTimeIndex;
		return keyToIndexEntries;
	}
	processNewMail(mailId) {
		return this.entityClient.load(MailTypeRef, mailId).then(async (mail) => {
			let mailDetails;
			if (isDraft(mail)) {
				const mailOwnerEncSessionKey = assertNotNull(mail._ownerEncSessionKey);
				const mailDetailsDraftId = assertNotNull(mail.mailDetailsDraft);
				mailDetails = await this.entityClient.loadMultiple(MailDetailsDraftTypeRef, listIdPart(mailDetailsDraftId), [elementIdPart(mailDetailsDraftId)], async () => ({
					key: mailOwnerEncSessionKey,
					encryptingKeyVersion: Number(mail._ownerKeyVersion ?? 0)
				})).then((d) => {
					const draft = first(d);
					if (draft == null) throw new NotFoundError(`MailDetailsDraft ${mailDetailsDraftId}`);
					return draft.details;
				});
			} else {
				const mailOwnerEncSessionKey = assertNotNull(mail._ownerEncSessionKey);
				const mailDetailsBlobId = neverNull(mail.mailDetails);
				mailDetails = await this.entityClient.loadMultiple(MailDetailsBlobTypeRef, listIdPart(mailDetailsBlobId), [elementIdPart(mailDetailsBlobId)], async () => ({
					key: mailOwnerEncSessionKey,
					encryptingKeyVersion: Number(mail._ownerKeyVersion ?? 0)
				})).then((d) => {
					const blob = first(d);
					if (blob == null) throw new NotFoundError(`MailDetailsBlob ${mailDetailsBlobId}`);
					return blob.details;
				});
			}
			const files = await this.mailFacade.loadAttachments(mail);
			let keyToIndexEntries = this.createMailIndexEntries(mail, mailDetails, files);
			return {
				mail,
				keyToIndexEntries
			};
		}).catch(ofClass(NotFoundError, () => {
			console.log("tried to index non existing mail");
			return null;
		})).catch(ofClass(NotAuthorizedError, () => {
			console.log("tried to index contact without permission");
			return null;
		}));
	}
	processMovedMail(event, indexUpdate) {
		let encInstanceId = encryptIndexKeyBase64(this._db.key, event.instanceId, this._db.iv);
		return this._db.dbFacade.createTransaction(true, [ElementDataOS]).then((transaction) => {
			return transaction.get(ElementDataOS, encInstanceId).then((elementData) => {
				if (elementData) indexUpdate.move.push({
					encInstanceId,
					newListId: event.instanceListId
				});
else return this.processNewMail([event.instanceListId, event.instanceId]).then((result) => {
					if (result) this._core.encryptSearchIndexEntries(result.mail._id, neverNull(result.mail._ownerGroup), result.keyToIndexEntries, indexUpdate);
				});
			});
		});
	}
	async enableMailIndexing(user) {
		const t = await this._db.dbFacade.createTransaction(true, [MetaDataOS]);
		const enabled = await t.get(MetaDataOS, Metadata.mailIndexingEnabled);
		if (!enabled) {
			this.mailIndexingEnabled = true;
			const t2 = await this._db.dbFacade.createTransaction(false, [MetaDataOS]);
			t2.put(MetaDataOS, Metadata.mailIndexingEnabled, true);
			t2.put(MetaDataOS, Metadata.excludedListIds, []);
			const oldestTimestamp = this._dateProvider.getStartOfDayShiftedBy(-INITIAL_MAIL_INDEX_INTERVAL_DAYS).getTime();
			this.indexMailboxes(user, oldestTimestamp).catch(ofClass(CancelledError, (e) => {
				console.log("cancelled initial indexing", e);
			}));
			return t2.wait();
		} else return t.get(MetaDataOS, Metadata.excludedListIds).then((excludedListIds) => {
			this.mailIndexingEnabled = true;
		});
	}
	disableMailIndexing(userId) {
		this.mailIndexingEnabled = false;
		this._indexingCancelled = true;
		return this._db.dbFacade.deleteDatabase(b64UserIdHash(userId));
	}
	cancelMailIndexing() {
		this._indexingCancelled = true;
		return Promise.resolve();
	}
	/**
	* Extend mail index if not indexed this range yet.
	* newOldestTimestamp should be aligned to the start of the day up until which you want to index, we don't do rounding inside here.
	*/
	async extendIndexIfNeeded(user, newOldestTimestamp) {
		if (this.currentIndexTimestamp > FULL_INDEXED_TIMESTAMP && this.currentIndexTimestamp > newOldestTimestamp) {
			this.mailboxIndexingPromise = this.mailboxIndexingPromise.then(() => this.indexMailboxes(user, newOldestTimestamp)).catch(ofClass(CancelledError, (e) => {
				console.log("extend mail index has been cancelled", e);
			}));
			return this.mailboxIndexingPromise;
		}
	}
	/**
	* Indexes all mailboxes of the given user up to the endIndexTimestamp if mail indexing is enabled.
	* If the mailboxes are already fully indexed, they are not indexed again.
	*/
	async indexMailboxes(user, oldestTimestamp) {
		if (!this.mailIndexingEnabled) return Promise.resolve();
		this.isIndexing = true;
		this._indexingCancelled = false;
		this._core.resetStats();
		await this.infoMessageHandler.onSearchIndexStateUpdate({
			initializing: false,
			mailIndexEnabled: this.mailIndexingEnabled,
			progress: 1,
			currentMailIndexTimestamp: this.currentIndexTimestamp,
			aimedMailIndexTimestamp: oldestTimestamp,
			indexedMailCount: 0,
			failedIndexingUpTo: null
		});
		let memberships = filterMailMemberships(user);
		this._core.queue.pause();
		try {
			const mailBoxes = [];
			for (let mailGroupMembership of memberships) {
				let mailGroupId = mailGroupMembership.group;
				const mailboxGroupRoot = await this.entityClient.load(MailboxGroupRootTypeRef, mailGroupId);
				const mailbox = await this.entityClient.load(MailBoxTypeRef, mailboxGroupRoot.mailbox);
				const transaction = await this._db.dbFacade.createTransaction(true, [GroupDataOS]);
				const groupData = await transaction.get(GroupDataOS, mailGroupId);
				if (groupData) {
					const newestTimestamp = groupData.indexTimestamp === NOTHING_INDEXED_TIMESTAMP ? this._dateProvider.getStartOfDayShiftedBy(1).getTime() : groupData.indexTimestamp;
					if (newestTimestamp > oldestTimestamp) mailBoxes.push({
						mbox: mailbox,
						newestTimestamp
					});
				}
			}
			if (mailBoxes.length > 0) await this._indexMailLists(mailBoxes, oldestTimestamp);
			this._core.printStatus();
			await this.updateCurrentIndexTimestamp(user);
			await this.infoMessageHandler.onSearchIndexStateUpdate({
				initializing: false,
				mailIndexEnabled: this.mailIndexingEnabled,
				progress: 0,
				currentMailIndexTimestamp: this.currentIndexTimestamp,
				aimedMailIndexTimestamp: oldestTimestamp,
				indexedMailCount: this._core._stats.mailcount,
				failedIndexingUpTo: null
			});
		} catch (e) {
			console.warn("Mail indexing failed: ", e);
			this.mailboxIndexingPromise = Promise.resolve();
			await this.updateCurrentIndexTimestamp(user);
			const success = this._core.isStoppedProcessing() || e instanceof CancelledError;
			const failedIndexingUpTo = success ? null : oldestTimestamp;
			const error = success ? null : e instanceof ConnectionError ? IndexingErrorReason.ConnectionLost : IndexingErrorReason.Unknown;
			await this.infoMessageHandler.onSearchIndexStateUpdate({
				initializing: false,
				mailIndexEnabled: this.mailIndexingEnabled,
				progress: 0,
				currentMailIndexTimestamp: this.currentIndexTimestamp,
				aimedMailIndexTimestamp: oldestTimestamp,
				indexedMailCount: this._core._stats.mailcount,
				failedIndexingUpTo,
				error
			});
		} finally {
			this._core.queue.resume();
			this.isIndexing = false;
		}
	}
	_indexMailLists(mailBoxes, oldestTimestamp) {
		const newestTimestamp = mailBoxes.reduce((acc, data) => Math.max(acc, data.newestTimestamp), 0);
		const progress = new ProgressMonitor(newestTimestamp - oldestTimestamp, (progress$1) => {
			this.infoMessageHandler.onSearchIndexStateUpdate({
				initializing: false,
				mailIndexEnabled: this.mailIndexingEnabled,
				progress: progress$1,
				currentMailIndexTimestamp: this.currentIndexTimestamp,
				aimedMailIndexTimestamp: oldestTimestamp,
				indexedMailCount: this._core._stats.mailcount,
				failedIndexingUpTo: null
			});
		});
		const indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(MailTypeRef));
		const indexLoader = this.bulkLoaderFactory();
		return pMap(mailBoxes, (mBoxData) => {
			return this._loadMailListIds(mBoxData.mbox).then((mailListIds) => {
				return {
					mailListIds,
					newestTimestamp: mBoxData.newestTimestamp,
					ownerGroup: neverNull(mBoxData.mbox._ownerGroup)
				};
			});
		}).then((mailboxData) => this._indexMailListsInTimeBatches(mailboxData, [newestTimestamp, oldestTimestamp], indexUpdate, progress, indexLoader));
	}
	_processedEnough(indexUpdate) {
		return indexUpdate.create.encInstanceIdToElementData.size > 500;
	}
	_indexMailListsInTimeBatches(dataPerMailbox, timeRange, indexUpdate, progress, indexLoader) {
		const [rangeStart, rangeEnd] = timeRange;
		let batchEnd = rangeStart - MAIL_INDEX_BATCH_INTERVAL;
		if (batchEnd < rangeEnd) batchEnd = rangeEnd;
		const mailboxesToWrite = dataPerMailbox.filter((mboxData) => batchEnd < mboxData.newestTimestamp);
		const batchRange = [rangeStart, batchEnd];
		if (rangeStart <= rangeEnd) {
			const indexTimestampPerGroup = mailboxesToWrite.map((data) => ({
				groupId: data.ownerGroup,
				indexTimestamp: data.mailListIds.length === 0 ? FULL_INDEXED_TIMESTAMP : rangeStart
			}));
			return this._writeIndexUpdate(indexTimestampPerGroup, indexUpdate).then(() => {
				progress.workDone(rangeStart - batchEnd);
			});
		}
		return this._prepareMailDataForTimeBatch(mailboxesToWrite, batchRange, indexUpdate, indexLoader).then(() => {
			const nextRange = [batchEnd, rangeEnd];
			if (this._processedEnough(indexUpdate)) {
				const indexTimestampPerGroup = mailboxesToWrite.map((data) => ({
					groupId: data.ownerGroup,
					indexTimestamp: data.mailListIds.length === 0 ? FULL_INDEXED_TIMESTAMP : batchEnd
				}));
				return this._writeIndexUpdate(indexTimestampPerGroup, indexUpdate).then(() => {
					progress.workDone(rangeStart - batchEnd);
					const newIndexUpdate = _createNewIndexUpdate(indexUpdate.typeInfo);
					return this._indexMailListsInTimeBatches(dataPerMailbox, nextRange, newIndexUpdate, progress, indexLoader);
				});
			} else {
				progress.workDone(rangeStart - batchEnd);
				return this._indexMailListsInTimeBatches(dataPerMailbox, nextRange, indexUpdate, progress, indexLoader);
			}
		});
	}
	/**
	* @return Number of processed emails?
	* @private
	*/
	async _prepareMailDataForTimeBatch(mboxDataList, timeRange, indexUpdate, indexLoader) {
		const startTimeLoad = getPerformanceTimestamp();
		return pMap(mboxDataList, (mboxData) => {
			return pMap(mboxData.mailListIds.slice(), async (listId) => {
				const { elements: mails, loadedCompletely } = await indexLoader.loadMailsInRangeWithCache(listId, timeRange);
				if (loadedCompletely) mboxData.mailListIds.splice(mboxData.mailListIds.indexOf(listId), 1);
				this._core._stats.mailcount += mails.length;
				await Promise.all(mails.map((m) => indexLoader.removeFromCache(m._id)));
				return this._processIndexMails(mails, indexUpdate, indexLoader);
			}, { concurrency: 2 });
		}, { concurrency: 5 }).then(() => {
			this._core._stats.preparingTime += getPerformanceTimestamp() - startTimeLoad;
		});
	}
	async _processIndexMails(mails, indexUpdate, indexLoader) {
		if (this._indexingCancelled) throw new CancelledError("cancelled indexing in processing index mails");
		let mailsWithoutErros = mails.filter((m) => !hasError(m));
		const mailsWithMailDetails = await indexLoader.loadMailDetails(mailsWithoutErros);
		const files = await indexLoader.loadAttachments(mailsWithoutErros);
		const mailsWithMailDetailsAndFiles = mailsWithMailDetails.map((mailTuples) => {
			return {
				mail: mailTuples.mail,
				mailDetails: mailTuples.mailDetails,
				files: files.filter((file) => mailTuples.mail.attachments.find((a) => isSameId(a, file._id)))
			};
		}).filter(isNotNull);
		for (const element of mailsWithMailDetailsAndFiles) {
			let keyToIndexEntries = this.createMailIndexEntries(element.mail, element.mailDetails, element.files);
			this._core.encryptSearchIndexEntries(element.mail._id, neverNull(element.mail._ownerGroup), keyToIndexEntries, indexUpdate);
		}
		return mailsWithMailDetailsAndFiles.length;
	}
	_writeIndexUpdate(dataPerGroup, indexUpdate) {
		return this._core.writeIndexUpdate(dataPerGroup, indexUpdate);
	}
	updateCurrentIndexTimestamp(user) {
		return this._db.dbFacade.createTransaction(true, [GroupDataOS]).then((t) => {
			return Promise.all(filterMailMemberships(user).map((mailGroupMembership) => {
				return t.get(GroupDataOS, mailGroupMembership.group).then((groupData) => {
					if (!groupData) return NOTHING_INDEXED_TIMESTAMP;
else return groupData.indexTimestamp;
				});
			})).then((groupIndexTimestamps) => {
				this.currentIndexTimestamp = _getCurrentIndexTimestamp(groupIndexTimestamps);
			});
		}).catch((err) => {
			if (err instanceof DbError && this._core.isStoppedProcessing()) console.log("The database was closed, do not write currentIndexTimestamp");
		});
	}
	/**
	* Provides all mail list ids of the given mailbox
	*/
	async _loadMailListIds(mailbox) {
		const isMailsetMigrated = mailbox.currentMailBag != null;
		if (isMailsetMigrated) return [mailbox.currentMailBag, ...mailbox.archivedMailBags].map((mailbag) => mailbag.mails);
else {
			const folders = await this.entityClient.loadAll(MailFolderTypeRef, neverNull(mailbox.folders).folders);
			return folders.map((f) => f.mails);
		}
	}
	_getSpamFolder(mailGroup) {
		return this.entityClient.load(MailboxGroupRootTypeRef, mailGroup.group).then((mailGroupRoot) => this.entityClient.load(MailBoxTypeRef, mailGroupRoot.mailbox)).then((mbox) => {
			return this.entityClient.loadAll(MailFolderTypeRef, neverNull(mbox.folders).folders).then((folders) => neverNull(folders.find((folder) => folder.folderType === MailSetKind.SPAM)));
		});
	}
	async processImportStateEntityEvents(events, groupId, batchId, indexUpdate) {
		if (!this.mailIndexingEnabled) return Promise.resolve();
		await pMap(events, async (event) => {
			if (event.operation === OperationType.CREATE || event.operation === OperationType.UPDATE) {
				let mailIds = await this.loadImportedMailIdsInIndexDateRange([event.instanceListId, event.instanceId]);
				await this.preloadMails(mailIds);
				return await pMap(mailIds, (mailId) => this.processNewMail(mailId).then((result) => {
					if (result) this._core.encryptSearchIndexEntries(result.mail._id, neverNull(result.mail._ownerGroup), result.keyToIndexEntries, indexUpdate);
				}));
			}
		});
	}
	/**
	* We preload all mails and mail details into the cache in order to prevent loading mails one by one
	* after importing lots of mails...
	*/
	async preloadMails(mailIds) {
		const mailsByList = groupBy(mailIds, (m) => listIdPart(m));
		let mails = [];
		for (const [listId, mailIds$1] of mailsByList.entries()) {
			const mailElementIds = mailIds$1.map((m) => elementIdPart(m));
			mails = mails.concat(await this.entityClient.loadMultiple(MailTypeRef, listId, mailElementIds));
		}
		const indexLoader = this.bulkLoaderFactory();
		await indexLoader.loadMailDetails(mails);
		await indexLoader.loadAttachments(mails);
	}
	async loadImportedMailIdsInIndexDateRange(importStateId) {
		const importMailState = await this.entityClient.load(ImportMailStateTypeRef, importStateId);
		let status = parseInt(importMailState.status);
		if (status !== ImportStatus.Finished && status !== ImportStatus.Canceled) return Promise.resolve([]);
		let importedMailEntries = await this.entityClient.loadAll(ImportedMailTypeRef, importMailState.importedMails);
		if (isEmpty(importedMailEntries)) return Promise.resolve([]);
		let importedMailSetEntryListId = listIdPart(importedMailEntries[0].mailSetEntry);
		let dateRangeFilteredMailSetEntryIds = importedMailEntries.map((importedMail) => elementIdPart(importedMail.mailSetEntry)).filter((importedEntry) => deconstructMailSetEntryId(importedEntry).receiveDate.getTime() >= this.currentIndexTimestamp);
		return this.entityClient.loadMultiple(MailSetEntryTypeRef, importedMailSetEntryListId, dateRangeFilteredMailSetEntryIds).then((entries) => entries.map((entry) => entry.mail));
	}
	/**
	* Prepare IndexUpdate in response to the new entity events.
	* {@see MailIndexerTest.js}
	* @param events Events from one batch
	* @param groupId
	* @param batchId
	* @param indexUpdate which will be populated with operations
	* @returns {Promise<*>} Indication that we're done.
	*/
	processEntityEvents(events, groupId, batchId, indexUpdate) {
		if (!this.mailIndexingEnabled) return Promise.resolve();
		return pMap(events, (event) => {
			const mailId = [event.instanceListId, event.instanceId];
			if (event.operation === OperationType.CREATE) if (containsEventOfType(events, OperationType.DELETE, event.instanceId)) return this.processMovedMail(event, indexUpdate);
else return this.processNewMail(mailId).then((result) => {
				if (result) this._core.encryptSearchIndexEntries(result.mail._id, neverNull(result.mail._ownerGroup), result.keyToIndexEntries, indexUpdate);
			});
else if (event.operation === OperationType.UPDATE) return this.entityClient.load(MailTypeRef, [event.instanceListId, event.instanceId]).then((mail) => {
				if (mail.state === MailState.DRAFT) return Promise.all([this._core._processDeleted(event, indexUpdate), this.processNewMail(mailId).then((result) => {
					if (result) this._core.encryptSearchIndexEntries(result.mail._id, neverNull(result.mail._ownerGroup), result.keyToIndexEntries, indexUpdate);
				})]);
			}).catch(ofClass(NotFoundError, () => console.log("tried to index update event for non existing mail")));
else if (event.operation === OperationType.DELETE) {
				if (!containsEventOfType(events, OperationType.CREATE, event.instanceId)) return this._core._processDeleted(event, indexUpdate);
			}
		}).then(noOp);
	}
};
function _getCurrentIndexTimestamp(groupIndexTimestamps) {
	let currentIndexTimestamp = NOTHING_INDEXED_TIMESTAMP;
	for (const [index, t] of groupIndexTimestamps.entries()) if (index === 0) currentIndexTimestamp = t;
else if (t === NOTHING_INDEXED_TIMESTAMP) {} else if (t === FULL_INDEXED_TIMESTAMP && currentIndexTimestamp !== FULL_INDEXED_TIMESTAMP && currentIndexTimestamp !== NOTHING_INDEXED_TIMESTAMP) {} else if (currentIndexTimestamp === FULL_INDEXED_TIMESTAMP && t !== currentIndexTimestamp) currentIndexTimestamp = t;
else if (t < currentIndexTimestamp) currentIndexTimestamp = t;
	return currentIndexTimestamp;
}

//#endregion
export { INITIAL_MAIL_INDEX_INTERVAL_DAYS, MailIndexer, _getCurrentIndexTimestamp };
//# sourceMappingURL=MailIndexer-DcPkSBCs.js.map