
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { capitalizeFirstLetter, defer, delay, downcast, noOp, typedEntries, typedKeys } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { Keys } from "./TutanotaConstants-3bwAESYA.js";
import "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import "./EntityUtils-RQxXZlcV.js";
import "./TypeModels-XIXYys8J.js";
import "./TypeRefs-CR3TLWn0.js";
import "./dist-DcZ1Y4qd.js";
import "./FileUtils-W-u2-gZz.js";
import "./MessageDispatcher-wJwFhXWv.js";
import "./ConfigKeys-B1UD5FwS.js";
import { log } from "./DesktopLog-yAgEoQsh.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { spy, verify } from "./dist-BY49f75m.js";
import { nodemocker_default } from "./nodemocker-Bh_RUICG.js";
import { parseUrlOrNull } from "./PathUtils-DFfSo_TG.js";
import "./DesktopFileFacade-o-Coc2Lq.js";
import { handleProtocols } from "./ProtocolProxy-D3mwaAa4.js";
import path from "node:path";
import url from "node:url";

//#region ../src/common/desktop/ApplicationWindow.ts
const MINIMUM_WINDOW_SIZE = 350;
const TAG = "[ApplicationWindow]";
const VIRTUAL_APP_URL_BASE = "asset://app";
const VIRTUAL_APP_URL = VIRTUAL_APP_URL_BASE + "/index-desktop.html";
var ApplicationWindow = class {
	_desktopFacade;
	_commonNativeFacade;
	_interWindowEventSender;
	_desktopMailImportFacade;
	windowCleanup;
	_browserWindow;
	/** User logged in in this window. Reset from WindowManager. */
	userId = null;
	setBoundsTimeout = null;
	findingInPage = false;
	skipNextSearchBarBlur = false;
	lastSearchRequest = null;
	lastSearchPromiseReject;
	shortcuts;
	id;
	constructor(wm, absoluteAssetsPath, icon, electron, localShortcut, themeFacade, remoteBridge, noAutoLogin, preloadOverridePath) {
		this.absoluteAssetsPath = absoluteAssetsPath;
		this.electron = electron;
		this.localShortcut = localShortcut;
		this.themeFacade = themeFacade;
		this.remoteBridge = remoteBridge;
		this.lastSearchPromiseReject = noOp;
		const isMac = process.platform === "darwin";
		this.shortcuts = [
			{
				key: Keys.F,
				meta: isMac,
				ctrl: !isMac,
				exec: () => this.openFindInPage(),
				help: "searchPage_label"
			},
			{
				key: Keys.P,
				meta: isMac,
				ctrl: !isMac,
				exec: () => this.printMail(),
				help: "print_action"
			},
			{
				key: Keys.F12,
				exec: () => this.toggleDevTools(),
				help: "toggleDevTools_action"
			},
			{
				key: Keys["0"],
				meta: isMac,
				ctrl: !isMac,
				exec: () => {
					wm.changeZoom(1);
				},
				help: "resetZoomFactor_action"
			},
			{
				key: Keys.Q,
				ctrl: !isMac,
				meta: isMac,
				shift: !isMac,
				exec: () => this.electron.app.quit(),
				help: "quit_action"
			}
		].concat(isMac ? [{
			key: Keys.F,
			meta: true,
			ctrl: true,
			exec: () => this.toggleFullScreen(),
			help: "toggleFullScreen_action"
		}] : [
			{
				key: Keys.F11,
				exec: () => this.toggleFullScreen(),
				help: "toggleFullScreen_action"
			},
			{
				key: Keys.RIGHT,
				alt: true,
				exec: () => this._browserWindow.webContents.goForward(),
				help: "pageForward_label"
			},
			{
				key: Keys.LEFT,
				alt: true,
				exec: () => this.tryGoBack(),
				help: "pageBackward_label"
			},
			{
				key: Keys.H,
				ctrl: true,
				exec: () => wm.minimize(),
				help: "hideWindows_action"
			},
			{
				key: Keys.N,
				ctrl: true,
				exec: () => {
					wm.newWindow(true);
				},
				help: "openNewWindow_action"
			}
		]);
		log.debug(TAG, "webAssetsPath: ", this.absoluteAssetsPath);
		const preloadPath = preloadOverridePath ?? path.join(this.electron.app.getAppPath(), "./desktop/preload.js");
		this.createBrowserWindow(wm, {
			preloadPath,
			icon
		});
		this.initFacades();
		this.loadInitialUrl(noAutoLogin ?? false);
		this.electron.Menu.setApplicationMenu(null);
	}
	get desktopMailImportFacade() {
		return this._desktopMailImportFacade;
	}
	get desktopFacade() {
		return this._desktopFacade;
	}
	get commonNativeFacade() {
		return this._commonNativeFacade;
	}
	get interWindowEventSender() {
		return this._interWindowEventSender;
	}
	initFacades() {
		const sendingFacades = this.remoteBridge.createBridge(this);
		this._desktopFacade = sendingFacades.desktopFacade;
		this._commonNativeFacade = sendingFacades.commonNativeFacade;
		this._interWindowEventSender = sendingFacades.interWindowEventSender;
		this.windowCleanup = sendingFacades.windowCleanup;
	}
	async loadInitialUrl(noAutoLogin) {
		const initialUrl = await this.getInitialUrl({ noAutoLogin });
		await this.updateBackgroundColor();
		this._browserWindow.loadURL(initialUrl);
	}
	async updateBackgroundColor() {
		const theme = await this.themeFacade.getCurrentThemeWithFallback();
		if (theme) this._browserWindow.setBackgroundColor(theme.navigation_bg);
	}
	on = (...args) => this._browserWindow.on(...args);
	once = (...args) => this._browserWindow.once(...args);
	getTitle = () => this._browserWindow.webContents.getTitle();
	setZoomFactor = (f) => this._browserWindow.webContents.setZoomFactor(f);
	isFullScreen = () => this._browserWindow.isFullScreen();
	isMinimized = () => this._browserWindow.isMinimized();
	minimize = () => this._browserWindow.minimize();
	hide = () => this._browserWindow.hide();
	center = () => this._browserWindow.center();
	showInactive = () => this._browserWindow.showInactive();
	focus = () => this._browserWindow.focus();
	isFocused = () => this._browserWindow.isFocused();
	show() {
		if (!this._browserWindow) return;
		const contents = this._browserWindow.webContents;
		const devToolsState = contents.isDevToolsOpened();
		this._browserWindow.show();
		if (this._browserWindow.isMinimized()) {
			this._browserWindow.restore();
			contents.toggleDevTools();
			if (devToolsState) contents.openDevTools();
else contents.closeDevTools();
		} else if (!this._browserWindow.isFocused()) this._browserWindow.focus();
	}
	createBrowserWindow(wm, opts) {
		const { preloadPath, icon } = opts;
		this._browserWindow = new this.electron.BrowserWindow({
			icon,
			show: false,
			autoHideMenuBar: true,
			webPreferences: {
				nodeIntegration: false,
				nodeIntegrationInWorker: false,
				nodeIntegrationInSubFrames: false,
				sandbox: true,
				contextIsolation: true,
				webSecurity: true,
				enableRemoteModule: false,
				allowRunningInsecureContent: false,
				preload: preloadPath,
				webgl: false,
				plugins: false,
				experimentalFeatures: false,
				webviewTag: false,
				disableDialogs: true,
				navigateOnDragDrop: false,
				autoplayPolicy: "user-gesture-required",
				enableWebSQL: false,
				spellcheck: true
			}
		});
		const session = this._browserWindow.webContents.session;
		session.setPermissionRequestHandler((webContents, permission, callback) => callback(false));
		handleProtocols(session, this.absoluteAssetsPath);
		this._browserWindow.setMenuBarVisibility(false);
		this._browserWindow.removeMenu();
		this._browserWindow.setMinimumSize(MINIMUM_WINDOW_SIZE, MINIMUM_WINDOW_SIZE);
		this.id = this._browserWindow.id;
		this._browserWindow.on("closed", async () => {
			await this.cleanup();
		}).on("focus", () => this.localShortcut.enableAll(this._browserWindow)).on("blur", (_) => this.localShortcut.disableAll(this._browserWindow));
		this._browserWindow.webContents.on("will-attach-webview", (e) => e.preventDefault()).on("will-navigate", (e, url$1) => {
			log.debug(TAG, "will-navigate", url$1);
			e.preventDefault();
		}).on("before-input-event", (ev, input) => {
			if (this.lastSearchRequest && this.findingInPage && input.type === "keyDown" && input.key === "Enter") {
				this.skipNextSearchBarBlur = true;
				const [searchTerm, options] = this.lastSearchRequest;
				options.forward = true;
				this._browserWindow.webContents.once("found-in-page", (ev$1, res) => {
					this._desktopFacade.applySearchResultToOverlay(res);
				}).findInPage(searchTerm, options);
			}
		}).on("did-finish-load", () => {
			this.sendShortcutstoRender();
		}).on("did-fail-load", (evt, errorCode, errorDesc, validatedURL) => {
			log.debug(TAG, "failed to load resource: ", validatedURL, errorDesc);
			if (errorDesc === "ERR_FILE_NOT_FOUND") this.getInitialUrl({ noAutoLogin: true }).then((initialUrl) => {
				log.debug(TAG, "redirecting to start page...", initialUrl);
				return this._browserWindow.loadURL(initialUrl);
			}).then(() => log.debug(TAG, "...redirected"));
		}).on("remote-require", (e) => e.preventDefault()).on("remote-get-global", (e) => e.preventDefault()).on("remote-get-builtin", (e) => e.preventDefault()).on("remote-get-current-web-contents", (e) => e.preventDefault()).on("remote-get-current-window", (e) => e.preventDefault()).on("did-navigate", () => this._browserWindow.emit("did-navigate")).on("did-navigate-in-page", () => this._browserWindow.emit("did-navigate")).on("zoom-changed", (ev, direction) => this._browserWindow.emit("zoom-changed", ev, direction)).on("update-target-url", (ev, url$1) => {
			this._desktopFacade.updateTargetUrl(url$1, VIRTUAL_APP_URL_BASE);
		});
		this._browserWindow.webContents.setWindowOpenHandler((details) => this.onNewWindow(details));
		this.reRegisterShortcuts();
	}
	async reload(queryParams) {
		await this.cleanup();
		this.remoteBridge.unsubscribe(this._browserWindow.webContents.ipc);
		this.userId = null;
		this.initFacades();
		const url$1 = await this.getInitialUrl(queryParams);
		await this._browserWindow.loadURL(url$1);
	}
	async cleanup() {
		if (this.userId) await this.windowCleanup.onCleanup(this.userId);
	}
	onNewWindow(details) {
		const parsedUrl = parseUrlOrNull(details.url);
		if (parsedUrl == null) log.warn(TAG, "Could not parse url for new-window, will not open");
else if (parsedUrl.protocol === "file:") log.warn(TAG, "prevented file url from being opened by shell");
else if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") this.electron.dialog.showMessageBox({
			type: "warning",
			buttons: [lang.get("yes_label"), lang.get("no_label")],
			title: lang.get("suspiciousLink_title"),
			message: lang.get("suspiciousLink_msg", { "{url}": parsedUrl.toString() }),
			defaultId: 1
		}).then(({ response }) => {
			if (response === 0) this.doOpenLink(parsedUrl, details);
		});
else this.doOpenLink(parsedUrl, details);
		return { action: "deny" };
	}
	doOpenLink(parsedUrl, details) {
		this.electron.shell.openExternal(parsedUrl.toString()).catch((e) => {
			log.warn("failed to open external url", details.url, e);
			this.electron.dialog.showMessageBox({
				title: lang.get("showURL_alt"),
				buttons: [lang.get("ok_action")],
				defaultId: 0,
				message: lang.get("couldNotOpenLink_msg", { "{link}": details.url }),
				type: "error"
			});
		});
	}
	reRegisterShortcuts() {
		this.localShortcut.unregisterAll(this._browserWindow);
		for (const s of this.shortcuts) {
			let shortcutString = "";
			shortcutString += s.meta ? "Command+" : "";
			shortcutString += s.ctrl ? "Control+" : "";
			shortcutString += s.alt ? "Alt+" : "";
			shortcutString += s.shift ? "Shift+" : "";
			shortcutString += capitalizeFirstLetter(typedKeys(Keys).filter((k) => s.key === Keys[k])[0]);
			this.localShortcut.register(this._browserWindow, shortcutString, s.exec);
		}
	}
	sendShortcutstoRender() {
		const webShortcuts = this.shortcuts.map((s) => Object.assign({}, s, { exec: null }));
		this._desktopFacade.addShortcuts(webShortcuts);
	}
	tryGoBack() {
		const parsedUrl = url.parse(this._browserWindow.webContents.getURL());
		if (parsedUrl.pathname && !parsedUrl.pathname.endsWith("login")) this._browserWindow.webContents.goBack();
else log.debug(TAG, "Ignore back events on login page");
	}
	async openMailBox(info, path$1) {
		await this._commonNativeFacade.openMailBox(info.userId, info.mailAddress, path$1 ?? null);
		this.show();
	}
	async openCalendar(info) {
		await this._commonNativeFacade.openCalendar(info.userId);
		this.show();
	}
	setContextMenuHandler(handler) {
		const wc = this._browserWindow.webContents;
		wc.on("context-menu", (e, params) => handler(params));
	}
	getUserId() {
		return this.userId;
	}
	setUserId(id) {
		this.userId = id;
	}
	findInPage(searchTerm, forward, matchCase, findNext) {
		const options = {
			forward,
			matchCase,
			findNext
		};
		this.findingInPage = true;
		if (searchTerm !== "") {
			this.lastSearchRequest = [searchTerm, options];
			this._browserWindow.webContents.findInPage(searchTerm, options);
			return new Promise((resolve, reject) => {
				this.lastSearchPromiseReject(new CancelledError("search request was superseded"));
				this.lastSearchPromiseReject = reject;
				this._browserWindow.webContents.removeAllListeners("found-in-page").once("found-in-page", (ev, res) => {
					this.lastSearchPromiseReject = noOp;
					resolve(res);
				});
			}).catch((e) => {
				if (!(e instanceof CancelledError)) log.debug("findInPage reject: ", e);
				return null;
			});
		} else {
			this.stopFindInPage();
			return Promise.resolve(null);
		}
	}
	stopFindInPage() {
		this.findingInPage = false;
		this.lastSearchRequest = null;
		this._browserWindow.webContents.stopFindInPage("keepSelection");
	}
	/**
	* make it known to the window if the search overlay is focused.
	* used to check if enter events need to be caught to search the next result
	* @param state whether the search bar is focused right now
	* @param force ignores skipnextblur
	*/
	setSearchOverlayState(state, force) {
		if (!force && !state && this.skipNextSearchBarBlur) {
			this.skipNextSearchBarBlur = false;
			return;
		}
		this.findingInPage = state;
	}
	toggleDevTools() {
		const wc = this._browserWindow.webContents;
		if (wc.isDevToolsOpened()) wc.closeDevTools();
else wc.openDevTools({ mode: "undocked" });
	}
	toggleFullScreen() {
		this._browserWindow.setFullScreen(!this._browserWindow.isFullScreen());
	}
	printMail() {
		this._desktopFacade.print();
	}
	openFindInPage() {
		this._desktopFacade.openFindInPage();
	}
	setBounds(bounds) {
		this._browserWindow.setFullScreen(bounds.fullscreen);
		this.setZoomFactor(bounds.scale);
		if (bounds.fullscreen) return;
		this._browserWindow.setBounds(bounds.rect);
		if (process.platform !== "linux") return;
		if (this.setBoundsTimeout) clearTimeout(this.setBoundsTimeout);
		this.setBoundsTimeout = setTimeout(() => {
			if (this._browserWindow.isDestroyed()) return;
			const newRect = this._browserWindow.getBounds();
			if (bounds.rect.y !== newRect.y) this._browserWindow.setPosition(newRect.x, newRect.y + 2 * (bounds.rect.y - newRect.y));
		}, 200);
	}
	getBounds() {
		return {
			fullscreen: this._browserWindow.isFullScreen(),
			rect: this._browserWindow.getBounds(),
			scale: 1
		};
	}
	async getInitialUrl(additionalQueryParams) {
		const url$1 = new URL(VIRTUAL_APP_URL);
		for (const [key, value] of typedEntries(additionalQueryParams)) url$1.searchParams.append(key, String(value));
		url$1.searchParams.append("platformId", process.platform);
		const theme = await this.themeFacade.getCurrentThemeWithFallback();
		url$1.searchParams.append("theme", JSON.stringify(theme));
		return url$1.toString();
	}
};

//#endregion
//#region tests/desktop/ApplicationWindowTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
const { anything } = import_testdouble.matchers;
dist_default.spec("ApplicationWindow Test", function() {
	const electronLocalshortcut = {
		callbacks: Object.create(null),
		register: function(bw, key, cb) {
			this.callbacks[key] = cb;
		},
		unregisterAll: function(key) {}
	};
	const lang$1 = { lang: { initialized: { promise: { then: (cb) => {
		setImmediate(() => cb());
	} } } } };
	const wm = {
		ipc: {
			addWindow: () => {},
			removeWindow: () => {},
			sendRequest: () => Promise.resolve(),
			initialized: () => Promise.resolve()
		},
		dl: { manageDownloadsForSession: () => {} },
		newWindow: () => {},
		hide: () => {},
		minimize: () => {},
		getIcon: () => icon
	};
	const themeFacadeInstance = new class {
		async getThemePreference() {
			return "light";
		}
		async setThemePreference(themeId) {}
		async getThemes() {
			return [];
		}
		async setThemes(themes) {}
		async getCurrentTheme() {
			return null;
		}
		async prefersDark() {
			return false;
		}
		async getCurrentThemeWithFallback() {
			let theme = await (this.getCurrentTheme());
			if (theme == null) theme = {
				themeId: "light-fallback",
				content_bg: "#ffffff",
				header_bg: "#ffffff"
			};
			return theme;
		}
	}();
	const desktopHtml = "desktophtml";
	const icon = downcast(Symbol("icon"));
	const standardMocks = () => {
		const electron = {
			BrowserWindow: nodemocker_default.classify({
				prototype: {
					callbacks: {},
					devToolsOpened: false,
					destroyed: false,
					focused: true,
					minimized: false,
					bounds: {
						height: 0,
						width: 0,
						x: 0,
						y: 0
					},
					fullscreen: false,
					isDestroyed: function() {
						return this.destroyed;
					},
					on: function(ev, cb) {
						this.callbacks[ev] = cb;
						return this;
					},
					once: function(ev, cb) {
						this.callbacks[ev] = cb;
						return this;
					},
					emit: function(ev) {
						this.callbacks[ev]();
					},
					constructor: function(opts) {
						this.opts = opts;
						this.id = electron.BrowserWindow.lastId;
						electron.BrowserWindow.lastId = electron.BrowserWindow.lastId + 1;
						this.__loadedUrl = defer();
						this.webContents = nodemocker_default.spyify({
							callbacks: Object.create(null),
							destroyed: false,
							zoomFactor: 1,
							isDestroyed: () => {
								return this.webContents.destroyed;
							},
							send: (msg, val) => {},
							on: (ev, cb) => {
								this.webContents.callbacks[ev] = cb;
								return this.webContents;
							},
							once: (ev, cb) => {
								this.webContents.callbacks[ev] = cb;
								return this.webContents;
							},
							isDevToolsOpened: function() {
								return this.devToolsOpened;
							},
							openDevTools: function() {
								this.devToolsOpened = true;
							},
							closeDevTools: function() {
								this.devToolsOpened = false;
							},
							goBack: function() {},
							goForward: function() {},
							setZoomFactor: function(n) {
								this.zoomFactor = n;
							},
							getZoomFactor: function() {
								return 1;
							},
							toggleDevTools: function() {
								this.devToolsOpened = !this.devToolsOpened;
							},
							getTitle: () => "webContents Title",
							session: {
								setPermissionRequestHandler: () => {},
								setSpellCheckerDictionaryDownloadURL: () => {},
								protocol: {
									handled: true,
									isProtocolHandled: function() {
										this.handled = !this.handled;
										return this.handled;
									},
									handle() {
										return true;
									}
								},
								on() {
									return this;
								},
								removeAllListeners() {
									return this;
								}
							},
							findInPage: () => {},
							stopFindInPage: () => {},
							getURL: () => "file:///path/to/app/desktophtml/meh/more",
							removeAllListeners: (k) => {
								this.webContents.callbacks[k] = [];
								return this;
							},
							setWindowOpenHandler(handler) {
								this.windowOpenHandler = handler;
							}
						});
					},
					removeMenu: function() {},
					setMenuBarVisibility: function() {},
					setMinimumSize: function(x, y) {},
					loadURL: function(...args) {
						this.__loadedUrl.resolve(args);
						return Promise.resolve();
					},
					close: function() {},
					show: function() {},
					hide: function() {},
					center: function() {},
					showInactive: function() {},
					isFocused: function() {
						return this.focused;
					},
					setFullScreen: function(fullscreen) {
						this.fullscreen = fullscreen;
					},
					isFullScreen: function() {
						return this.fullscreen;
					},
					isMinimized: function() {
						return this.minimized;
					},
					minimize: function() {},
					focus: function() {},
					restore: function() {},
					getBounds: function() {
						return this.bounds;
					},
					setBounds: function(bounds) {
						this.bounds = bounds;
					},
					setPosition: function(x, y) {
						this.bounds.x = x;
						this.bounds.y = y;
					},
					setBackgroundColor: function() {}
				},
				statics: { lastId: 0 }
			}),
			shell: { openExternal: () => Promise.resolve() },
			Menu: { setApplicationMenu: () => {} },
			app: {
				getAppPath: () => "/path/to/app",
				getVersion: () => "app version"
			}
		};
		const electronMock = nodemocker_default.mock("electron", electron).set();
		const electronLocalshortcutMock = nodemocker_default.mock("electron-localshortcut", electronLocalshortcut).set();
		const desktopTrayMock = nodemocker_default.mock("./DesktopTray.js", { DesktopTray: { getIcon: () => "this is an icon" } }).set();
		const langMock = nodemocker_default.mock("../misc/LanguageViewModel", lang$1).set();
		const wmMock = nodemocker_default.mock("__wm", wm).set();
		const themeFacade = nodemocker_default.mock("__themeFacade", themeFacadeInstance).set();
		const remoteBridge = (0, import_testdouble.object)();
		const sendingFacades = {
			interWindowEventSender: (0, import_testdouble.object)(),
			desktopFacade: (0, import_testdouble.object)(),
			commonNativeFacade: (0, import_testdouble.object)(),
			windowCleanup: (0, import_testdouble.object)()
		};
		(0, import_testdouble.when)(remoteBridge.createBridge(anything())).thenReturn(sendingFacades);
		return {
			electronMock,
			electronLocalshortcutMock,
			desktopTrayMock,
			langMock,
			wmMock,
			themeFacade,
			remoteBridge,
			desktopFacade: sendingFacades.desktopFacade,
			interWindowEventSender: sendingFacades.interWindowEventSender,
			commonNativeFacade: sendingFacades.commonNativeFacade,
			windowCleanup: sendingFacades.windowCleanup
		};
	};
	dist_default.test("construction", async function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		dist_default(electronMock.BrowserWindow.mockedInstances.length).equals(1);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		await bwInstance.__loadedUrl.promise;
		dist_default(bwInstance.loadURL.callCount).equals(1);
		const theme = await themeFacade.getCurrentThemeWithFallback();
		const themeJson = JSON.stringify(theme);
		const query = new URLSearchParams({
			noAutoLogin: "false",
			platformId: process.platform,
			theme: themeJson
		});
		dist_default(bwInstance.loadURL.args[0]).equals(`asset://app/index-desktop.html?${query.toString()}`);
		dist_default(bwInstance.opts).deepEquals({
			icon,
			show: false,
			autoHideMenuBar: true,
			webPreferences: {
				nodeIntegration: false,
				nodeIntegrationInWorker: false,
				nodeIntegrationInSubFrames: false,
				sandbox: true,
				contextIsolation: true,
				webSecurity: true,
				enableRemoteModule: false,
				allowRunningInsecureContent: false,
				preload: "/path/to/app/desktop/preload.js",
				spellcheck: true,
				webgl: false,
				plugins: false,
				experimentalFeatures: false,
				webviewTag: false,
				disableDialogs: true,
				navigateOnDragDrop: false,
				autoplayPolicy: "user-gesture-required",
				enableWebSQL: false
			}
		});
		dist_default(bwInstance.setMenuBarVisibility.callCount).equals(1);
		dist_default(bwInstance.setMenuBarVisibility.args[0]).equals(false);
		dist_default(bwInstance.removeMenu.callCount).equals(1);
		dist_default(Object.keys(bwInstance.webContents.callbacks)).deepEquals([
			"will-attach-webview",
			"will-navigate",
			"before-input-event",
			"did-finish-load",
			"did-fail-load",
			"remote-require",
			"remote-get-global",
			"remote-get-builtin",
			"remote-get-current-web-contents",
			"remote-get-current-window",
			"did-navigate",
			"did-navigate-in-page",
			"zoom-changed",
			"update-target-url"
		])("webContents registered callbacks dont match");
		dist_default(bwInstance.webContents.session.protocol.handle.callCount).equals(3);
	});
	dist_default.test("construction, noAutoLogin", async function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w2 = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge, true);
		const bwInstance2 = electronMock.BrowserWindow.mockedInstances[0];
		await bwInstance2.__loadedUrl.promise;
		dist_default(bwInstance2.loadURL.callCount).equals(1);
		const themeJson = JSON.stringify(await themeFacade.getCurrentThemeWithFallback());
		const url$1 = new URL(bwInstance2.loadURL.args[0]);
		dist_default(url$1.searchParams.get("noAutoLogin")).equals("true");
		dist_default(url$1.searchParams.get("platformId")).equals(process.platform);
		dist_default(url$1.searchParams.get("theme")).equals(themeJson);
	});
	dist_default.test("redirect to start page after failing to load a page due to 404", async function() {
		const { wmMock, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		await bwInstance.__loadedUrl.promise;
		bwInstance.__loadedUrl = defer();
		bwInstance.webContents.callbacks["did-fail-load"]({}, -6, "ERR_FILE_NOT_FOUND");
		await bwInstance.__loadedUrl.promise;
		dist_default(bwInstance.loadURL.callCount).equals(2);
		const themeJson = JSON.stringify(await themeFacade.getCurrentThemeWithFallback());
		const url$1 = new URL(bwInstance.loadURL.args[0]);
		dist_default(url$1.searchParams.get("noAutoLogin")).equals("true");
		dist_default(url$1.searchParams.get("theme")).equals(themeJson);
		downcast(w._browserWindow.webContents).callbacks["did-fail-load"]({}, -6, "ERR_SOME_OTHER_ONE");
		await delay(10);
		dist_default(bwInstance.loadURL.callCount).equals(2);
	});
	dist_default.test("shortcut creation, linux", function() {
		nodemocker_default.setPlatform("linux");
		const { electronLocalshortcutMock, wmMock, electronMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		downcast(w._browserWindow.webContents).callbacks["did-finish-load"]();
		dist_default(Object.keys(electronLocalshortcutMock.callbacks)).deepEquals([
			"Control+F",
			"Control+P",
			"F12",
			"Control+0",
			"Control+Shift+Q",
			"F11",
			"Alt+Right",
			"Alt+Left",
			"Control+H",
			"Control+N"
		]);
	});
	dist_default.test("shortcut creation, windows", function() {
		nodemocker_default.setPlatform("win32");
		const { electronLocalshortcutMock, wmMock, electronMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		downcast(w._browserWindow.webContents).callbacks["did-finish-load"]();
		dist_default(Object.keys(electronLocalshortcutMock.callbacks)).deepEquals([
			"Control+F",
			"Control+P",
			"F12",
			"Control+0",
			"Control+Shift+Q",
			"F11",
			"Alt+Right",
			"Alt+Left",
			"Control+H",
			"Control+N"
		]);
	});
	dist_default.test("shortcut creation, mac", function() {
		nodemocker_default.setPlatform("darwin");
		const { electronLocalshortcutMock, wmMock, electronMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		downcast(w._browserWindow.webContents).callbacks["did-finish-load"]();
		dist_default(Object.keys(electronLocalshortcutMock.callbacks)).deepEquals([
			"Command+F",
			"Command+P",
			"F12",
			"Command+0",
			"Command+Q",
			"Command+Control+F"
		]);
	});
	function testShortcut(shortcuts, assertion) {
		dist_default.test("[" + shortcuts.join(" >> ") + "]", async function() {
			const sm = standardMocks();
			const { electronMock, electronLocalshortcutMock, wmMock, themeFacade, remoteBridge } = sm;
			const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			bwInstance.webContents.callbacks["did-finish-load"]();
			for (const shortcut of shortcuts) electronLocalshortcutMock.callbacks[shortcut]();
			assertion(sm);
		});
	}
	dist_default.spec("shortcuts are used, linux & win", function() {
		dist_default.beforeEach(() => nodemocker_default.setPlatform("linux"));
		testShortcut(["Control+F"], ({ desktopFacade }) => {
			verify(desktopFacade.openFindInPage());
		});
		testShortcut(["Control+P"], ({ desktopFacade }) => {
			verify(desktopFacade.print());
		});
		testShortcut(["F12"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.webContents.isDevToolsOpened.callCount).equals(1);
			dist_default(bwInstance.webContents.openDevTools.callCount).equals(1);
			dist_default(bwInstance.webContents.closeDevTools.callCount).equals(0);
			bwInstance.webContents.devToolsOpened = true;
		});
		testShortcut(["F12", "F12"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.webContents.isDevToolsOpened.callCount).equals(2);
			dist_default(bwInstance.webContents.openDevTools.callCount).equals(1);
			dist_default(bwInstance.webContents.closeDevTools.callCount).equals(1);
		});
		testShortcut(["Control+H"], ({ wmMock }) => dist_default(wmMock.minimize.callCount).equals(1));
		testShortcut(["Control+N"], ({ wmMock }) => {
			dist_default(wmMock.newWindow.callCount).equals(1);
			dist_default(wmMock.newWindow.args[0]).equals(true);
		});
		testShortcut(["F11"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.setFullScreen.callCount).equals(1);
			dist_default(bwInstance.isFullScreen.callCount).equals(1);
			dist_default(bwInstance.setFullScreen.args[0]).equals(true);
		});
		testShortcut(["Alt+Left"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.webContents.goBack.callCount).equals(1);
		});
		testShortcut(["Alt+Right"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.webContents.goForward.callCount).equals(1);
		});
	});
	dist_default.spec("shortcuts are used, mac", function() {
		dist_default.beforeEach(() => nodemocker_default.setPlatform("darwin"));
		testShortcut(["Command+F"], ({ desktopFacade }) => {
			verify(desktopFacade.openFindInPage());
		});
		testShortcut(["Command+P"], ({ desktopFacade }) => {
			verify(desktopFacade.print());
		});
		testShortcut(["F12"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.webContents.isDevToolsOpened.callCount).equals(1);
			dist_default(bwInstance.webContents.openDevTools.callCount).equals(1);
			dist_default(bwInstance.webContents.closeDevTools.callCount).equals(0);
			bwInstance.webContents.devToolsOpened = true;
		});
		testShortcut(["F12", "F12"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.webContents.isDevToolsOpened.callCount).equals(2);
			dist_default(bwInstance.webContents.openDevTools.callCount).equals(1);
			dist_default(bwInstance.webContents.closeDevTools.callCount).equals(1);
		});
		testShortcut(["Command+Control+F"], ({ electronMock }) => {
			const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
			dist_default(bwInstance.setFullScreen.callCount).equals(1);
			dist_default(bwInstance.isFullScreen.callCount).equals(1);
			dist_default(bwInstance.setFullScreen.args[0]).equals(true);
		});
	});
	dist_default.test("shortcuts are set on window reload", async function() {
		nodemocker_default.setPlatform("linux");
		const { electronMock, electronLocalshortcutMock, wmMock, themeFacade, remoteBridge, desktopFacade } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		bwInstance.webContents.callbacks["did-finish-load"]();
		verify(desktopFacade.addShortcuts(anything()));
		const initialized = defer();
		bwInstance.webContents.callbacks["did-finish-load"]();
		initialized.resolve();
		await initialized.promise;
		verify(desktopFacade.addShortcuts(anything()));
	});
	dist_default.test("will-navigate", function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const e = { preventDefault: spy() };
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		bwInstance.webContents.callbacks["will-navigate"](e, "http://test.com");
		dist_default(e.preventDefault.callCount).equals(1)("Prevent default is called");
	});
	dist_default.test("attaching webView is denied", function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		const e = { preventDefault: spy() };
		bwInstance.webContents.callbacks["will-attach-webview"](e);
		dist_default(e.preventDefault.callCount).equals(1);
		let threw = false;
		try {
			bwInstance.webContents.callbacks["will-attach-webview"]();
		} catch (e$1) {
			threw = true;
		}
		dist_default(threw).equals(true);
	});
	dist_default.spec("new window is redirected to openExternal", function() {
		let electronMock;
		let bwInstance;
		dist_default.beforeEach(function() {
			const sm = standardMocks();
			electronMock = sm.electronMock;
			let { wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = sm;
			new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
			bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		});
		dist_default.test("not url is not redirected", function() {
			const url$1 = "ba/\\.nanas";
			const result = bwInstance.webContents.windowOpenHandler({
				url: url$1,
				frameName: "frameName",
				features: "",
				disposition: "default",
				referrer: {}
			});
			dist_default(result).deepEquals({ action: "deny" });
			dist_default(electronMock.shell.openExternal.callCount).equals(0);
		});
		dist_default.test("url without protocol is not redirected", function() {
			const url$1 = "dies.ist.ne/url";
			const result = bwInstance.webContents.windowOpenHandler({
				url: url$1,
				frameName: "frameName",
				features: "",
				disposition: "default",
				referrer: {}
			});
			dist_default(result).deepEquals({ action: "deny" });
			dist_default(electronMock.shell.openExternal.callCount).equals(0);
		});
		dist_default.test("http url is redirected", function() {
			const url$1 = "http://example.com";
			const result = bwInstance.webContents.windowOpenHandler({
				url: url$1,
				frameName: "frameName",
				features: "",
				disposition: "default",
				referrer: {}
			});
			dist_default(result).deepEquals({ action: "deny" });
			dist_default(electronMock.shell.openExternal.callCount).equals(1);
			dist_default(electronMock.shell.openExternal.args[0]).equals("http://example.com/");
		});
		dist_default.test("file url is not opened nor redirected", function() {
			const url$1 = "file:///etc/shadow";
			const result = bwInstance.webContents.windowOpenHandler({
				url: url$1,
				frameName: "frameName",
				features: "",
				disposition: "default",
				referrer: {}
			});
			dist_default(result).deepEquals({ action: "deny" });
			dist_default(electronMock.shell.openExternal.callCount).equals(0);
		});
	});
	dist_default.test("context-menu is passed to handler", function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const handlerMock = nodemocker_default.spyify(() => {});
		w.setContextMenuHandler(handlerMock);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		const e = { preventDefault: spy() };
		bwInstance.webContents.callbacks["context-menu"](e, {
			linkURL: "dies.ist.ne/url",
			editFlags: "someflags"
		});
		dist_default(bwInstance.webContents.send.callCount).equals(0);
		dist_default(e.preventDefault.callCount).equals(0);
		dist_default(handlerMock.callCount).equals(1);
		dist_default(handlerMock.args).deepEquals([{
			linkURL: "dies.ist.ne/url",
			editFlags: "someflags"
		}]);
	});
	dist_default.test("openMailbox sends mailbox info and shows window", async function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge, commonNativeFacade } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		w.openMailBox({
			userId: "userId",
			mailAddress: "a@b.c"
		}, "path");
		await delay(10);
		verify(commonNativeFacade.openMailBox("userId", "a@b.c", "path"));
		dist_default(electronMock.BrowserWindow.mockedInstances[0].show.callCount).equals(1);
	});
	dist_default.test("setBounds and getBounds", async function() {
		dist_default.timeout(300);
		nodemocker_default.setPlatform("linux");
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		dist_default(w.getBounds()).deepEquals({
			rect: {
				height: 0,
				width: 0,
				x: 0,
				y: 0
			},
			fullscreen: false,
			scale: 1
		});
		w.setBounds({
			rect: {
				width: 1,
				height: 1,
				x: 1,
				y: 1
			},
			fullscreen: false,
			scale: 2
		});
		dist_default(w.getBounds()).deepEquals({
			rect: {
				width: 1,
				height: 1,
				x: 1,
				y: 1
			},
			fullscreen: false,
			scale: 1
		});
		w.setBounds({
			rect: {
				width: 0,
				height: 0,
				x: 0,
				y: 0
			},
			fullscreen: true,
			scale: 1
		});
		dist_default(w.getBounds()).deepEquals({
			rect: {
				width: 1,
				height: 1,
				x: 1,
				y: 1
			},
			fullscreen: true,
			scale: 1
		});
		w.setBounds({
			rect: {
				width: 0,
				height: 0,
				x: 0,
				y: 0
			},
			fullscreen: false,
			scale: .5
		});
		electronMock.BrowserWindow.mockedInstances[0].bounds = {
			width: 0,
			height: 0,
			x: 0,
			y: 10
		};
		await delay(250);
		dist_default(w.getBounds()).deepEquals({
			rect: {
				width: 0,
				height: 0,
				x: 0,
				y: -10
			},
			fullscreen: false,
			scale: 1
		});
	});
	dist_default.test("findInPage, setSearchOverlayState & stopFindInPage", function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const wcMock = electronMock.BrowserWindow.mockedInstances[0].webContents;
		w.stopFindInPage();
		dist_default(wcMock.stopFindInPage.callCount).equals(1);
		dist_default(wcMock.stopFindInPage.args[0]).equals("keepSelection");
		w.findInPage("searchTerm", false, false, true);
		dist_default(wcMock.findInPage.callCount).equals(1);
		dist_default(wcMock.findInPage.args[0]).equals("searchTerm");
		dist_default(wcMock.findInPage.args[1]).deepEquals({
			forward: false,
			matchCase: false,
			findNext: true
		});
		dist_default(wcMock.stopFindInPage.callCount).equals(1);
		dist_default(wcMock.stopFindInPage.args[0]).equals("keepSelection");
		wcMock.callbacks["before-input-event"]({}, {
			type: "keyDown",
			key: "Enter"
		});
		dist_default(wcMock.findInPage.callCount).equals(2);
		dist_default(wcMock.findInPage.args[1]).deepEquals({
			forward: true,
			matchCase: false,
			findNext: true
		});
		w.setSearchOverlayState(false, true);
		wcMock.callbacks["before-input-event"]({}, {
			type: "keyDown",
			key: "Enter"
		});
		dist_default(wcMock.findInPage.callCount).equals(2);
		w.findInPage("", false, false, true);
		dist_default(wcMock.findInPage.callCount).equals(2);
		dist_default(wcMock.findInPage.args[0]).equals("searchTerm");
		dist_default(wcMock.findInPage.args[1]).deepEquals({
			forward: true,
			matchCase: false,
			findNext: true
		});
		dist_default(wcMock.stopFindInPage.callCount).equals(2);
		dist_default(wcMock.stopFindInPage.args[0]).equals("keepSelection");
	});
	dist_default.test("show", function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const bwMock = electronMock.BrowserWindow.mockedInstances[0];
		dist_default(bwMock.devToolsOpened).equals(false);
		w.show();
		dist_default(bwMock.devToolsOpened).equals(false);
		dist_default(bwMock.show.callCount).equals(1);
		bwMock.devToolsOpened = true;
		w.show();
		dist_default(bwMock.devToolsOpened).equals(true);
		dist_default(bwMock.show.callCount).equals(2);
		bwMock.devToolsOpened = false;
		bwMock.minimized = true;
		w.show();
		dist_default(bwMock.devToolsOpened).equals(false);
		dist_default(bwMock.restore.callCount).equals(1);
		bwMock.devToolsOpened = true;
		w.show();
		dist_default(bwMock.devToolsOpened).equals(true);
		dist_default(bwMock.restore.callCount).equals(2);
		bwMock.focused = false;
		w.show();
		dist_default(bwMock.focus.callCount).equals(0);
		dist_default(bwMock.restore.callCount).equals(3);
		bwMock.minimized = false;
		w.show();
		dist_default(bwMock.focus.callCount).equals(1);
		dist_default(bwMock.restore.callCount).equals(3);
	});
	dist_default.test("on, once, getTitle, setZoomFactor, isFullScreen, isMinimized, minimize, hide, center, showInactive, isFocused", function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		let f = () => {};
		w.on(downcast("one-event"), f);
		dist_default(bwInstance.on.callCount).equals(4);
		dist_default(bwInstance.on.args[0]).equals("one-event");
		dist_default(bwInstance.on.args[1]).equals(f);
		w.once(downcast("two-event"), f);
		dist_default(bwInstance.once.callCount).equals(1);
		dist_default(bwInstance.once.args[0]).equals("two-event");
		dist_default(bwInstance.once.args[1]).equals(f);
		dist_default(w.getTitle()).equals("webContents Title");
		dist_default(bwInstance.webContents.getTitle.callCount).equals(1);
		dist_default(bwInstance.webContents.getTitle.args).deepEquals([]);
		w.setZoomFactor(42.42);
		dist_default(bwInstance.webContents.zoomFactor).equals(42.42);
		dist_default(w.isFullScreen()).equals(false);
		dist_default(bwInstance.isFullScreen.callCount).equals(1);
		dist_default(w.isMinimized()).equals(false);
		dist_default(bwInstance.isMinimized.callCount).equals(1);
		w.minimize();
		dist_default(bwInstance.minimize.callCount).equals(1);
		w.hide();
		dist_default(bwInstance.hide.callCount).equals(1);
		w.center();
		dist_default(bwInstance.center.callCount).equals(1);
		w.showInactive();
		dist_default(bwInstance.showInactive.callCount).equals(1);
		dist_default(w.isFocused()).equals(true);
		dist_default(bwInstance.isFocused.callCount).equals(1);
	});
	dist_default.test("when closing, windowCleanup.onCleanup is called", function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge, windowCleanup } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const userId = "123";
		w.setUserId(userId);
		const bwInstance = electronMock.BrowserWindow.mockedInstances[0];
		bwInstance.callbacks["closed"]();
		verify(windowCleanup.onCleanup(userId));
	});
	dist_default.test("when reloading, windowCleanup.onCleanup is called", async function() {
		const { electronMock, wmMock, electronLocalshortcutMock, themeFacade, remoteBridge, windowCleanup } = standardMocks();
		const w = new ApplicationWindow(wmMock, desktopHtml, icon, electronMock, electronLocalshortcutMock, themeFacade, remoteBridge);
		const userId = "123";
		w.setUserId(userId);
		await w.reload({});
		verify(windowCleanup.onCleanup(userId));
	});
});

//#endregion
//# sourceMappingURL=ApplicationWindowTest-BefKG9JY.js.map