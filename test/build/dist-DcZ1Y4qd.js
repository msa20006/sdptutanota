
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { arrayEquals, assertNotNull, base64ToBase64Url, base64ToHex, base64ToUint8Array, byteArraysToBytes, bytesToByteArrays, callWebAssemblyFunctionWithArguments, concat, hexToUint8Array, int8ArrayToBase64, mutableSecureFree, secureFree, stringToUtf8Uint8Array, uint8ArrayToArrayBuffer, uint8ArrayToBase64, uint8ArrayToHex } from "./dist-CJHwsXKY.js";
import { CryptoError } from "./CryptoError-PqdvQky4.js";

//#region ../packages/tutanota-crypto/dist/internal/sjcl.js
/** @fileOverview Javascript cryptography implementation.
*
* Crush to remove comments, shorten variable names and
* generally reduce transmission size.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/**
* The Stanford Javascript Crypto Library, top-level namespace.
* @namespace
* @type any
*/
var sjcl = {
	cipher: {},
	hash: {},
	keyexchange: {},
	mode: {},
	misc: {},
	codec: {},
	exception: {
		corrupt: function(message) {
			this.toString = function() {
				return "CORRUPT: " + this.message;
			};
			this.message = message;
		},
		invalid: function(message) {
			this.toString = function() {
				return "INVALID: " + this.message;
			};
			this.message = message;
		},
		bug: function(message) {
			this.toString = function() {
				return "BUG: " + this.message;
			};
			this.message = message;
		},
		notReady: function(message) {
			this.toString = function() {
				return "NOT READY: " + this.message;
			};
			this.message = message;
		}
	}
};
/** @fileOverview Low-level AES implementation.
*
* This file contains a low-level implementation of AES, optimized for
* size and for efficiency on several browsers.  It is based on
* OpenSSL's aes_core.c, a public-domain implementation by Vincent
* Rijmen, Antoon Bosselaers and Paulo Barreto.
*
* An older version of this implementation is available in the public
* domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
* Stanford University 2008-2010 and BSD-licensed for liability
* reasons.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/**
* Schedule out an AES key for both encryption and decryption.  This
* is a low-level class.  Use a cipher mode to do bulk encryption.
*
* @constructor
* @param {Array} key The key as an array of 4, 6 or 8 words.
*/
sjcl.cipher.aes = function(key) {
	if (!this._tables[0][0][0]) this._precompute();
	var i, j, tmp, encKey, decKey, sbox = this._tables[0][4], decTable = this._tables[1], keyLen = key.length, rcon = 1;
	if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) throw new sjcl.exception.invalid("invalid aes key size");
	this._key = [encKey = key.slice(0), decKey = []];
	for (i = keyLen; i < 4 * keyLen + 28; i++) {
		tmp = encKey[i - 1];
		if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
			tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
			if (i % keyLen === 0) {
				tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
				rcon = rcon << 1 ^ (rcon >> 7) * 283;
			}
		}
		encKey[i] = encKey[i - keyLen] ^ tmp;
	}
	for (j = 0; i; j++, i--) {
		tmp = encKey[j & 3 ? i : i - 4];
		if (i <= 4 || j < 4) decKey[j] = tmp;
else decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
	}
};
sjcl.cipher.aes.prototype = {
	encrypt: function(data) {
		return this._crypt(data, 0);
	},
	decrypt: function(data) {
		return this._crypt(data, 1);
	},
	_tables: [[
		[],
		[],
		[],
		[],
		[]
	], [
		[],
		[],
		[],
		[],
		[]
	]],
	_precompute: function() {
		var encTable = this._tables[0], decTable = this._tables[1], sbox = encTable[4], sboxInv = decTable[4], i, x, xInv, d = [], th = [], x2, x4, x8, s, tEnc, tDec;
		for (i = 0; i < 256; i++) th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
		for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
			s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
			s = s >> 8 ^ s & 255 ^ 99;
			sbox[x] = s;
			sboxInv[s] = x;
			x8 = d[x4 = d[x2 = d[x]]];
			tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
			tEnc = d[s] * 257 ^ s * 16843008;
			for (i = 0; i < 4; i++) {
				encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
				decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
			}
		}
		for (i = 0; i < 5; i++) {
			encTable[i] = encTable[i].slice(0);
			decTable[i] = decTable[i].slice(0);
		}
	},
	_crypt: function(input, dir) {
		if (input.length !== 4) throw new sjcl.exception.invalid("invalid aes block size");
		var key = this._key[dir], a = input[0] ^ key[0], b = input[dir ? 3 : 1] ^ key[1], c = input[2] ^ key[2], d = input[dir ? 1 : 3] ^ key[3], a2, b2, c2, nInnerRounds = key.length / 4 - 2, i, kIndex = 4, out = [
			0,
			0,
			0,
			0
		], table = this._tables[dir], t0 = table[0], t1 = table[1], t2 = table[2], t3 = table[3], sbox = table[4];
		for (i = 0; i < nInnerRounds; i++) {
			a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
			b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
			c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
			d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
			kIndex += 4;
			a = a2;
			b = b2;
			c = c2;
		}
		for (i = 0; i < 4; i++) {
			out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
			a2 = a;
			a = b;
			b = c;
			c = d;
			d = a2;
		}
		return out;
	}
};
/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/**
* Arrays of bits, encoded as arrays of Numbers.
* @namespace
* @description
* <p>
* These objects are the currency accepted by SJCL's crypto functions.
* </p>
*
* <p>
* Most of our crypto primitives operate on arrays of 4-byte words internally,
* but many of them can take arguments that are not a multiple of 4 bytes.
* This library encodes arrays of bits (whose size need not be a multiple of 8
* bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
* array of words, 32 bits at a time.  Since the words are double-precision
* floating point numbers, they fit some extra data.  We use this (in a private,
* possibly-changing manner) to encode the number of bits actually  present
* in the last word of the array.
* </p>
*
* <p>
* Because bitwise ops clear this out-of-band data, these arrays can be passed
* to ciphers like AES which want arrays of words.
* </p>
*/
sjcl.bitArray = {
	bitSlice: function(a, bstart, bend) {
		a = sjcl.bitArray._shiftRight(a.slice(bstart / 32), 32 - (bstart & 31)).slice(1);
		return bend === undefined ? a : sjcl.bitArray.clamp(a, bend - bstart);
	},
	extract: function(a, bstart, blength) {
		var x, sh = Math.floor(-bstart - blength & 31);
		if ((bstart + blength - 1 ^ bstart) & -32) x = a[bstart / 32 | 0] << 32 - sh ^ a[bstart / 32 + 1 | 0] >>> sh;
else x = a[bstart / 32 | 0] >>> sh;
		return x & (1 << blength) - 1;
	},
	concat: function(a1, a2) {
		if (a1.length === 0 || a2.length === 0) return a1.concat(a2);
		var last = a1[a1.length - 1], shift = sjcl.bitArray.getPartial(last);
		if (shift === 32) return a1.concat(a2);
else return sjcl.bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
	},
	bitLength: function(a) {
		var l = a.length, x;
		if (l === 0) return 0;
		x = a[l - 1];
		return (l - 1) * 32 + sjcl.bitArray.getPartial(x);
	},
	clamp: function(a, len) {
		if (a.length * 32 < len) return a;
		a = a.slice(0, Math.ceil(len / 32));
		var l = a.length;
		len = len & 31;
		if (l > 0 && len) a[l - 1] = sjcl.bitArray.partial(len, a[l - 1] & 2147483648 >> len - 1, 1);
		return a;
	},
	partial: function(len, x, _end) {
		if (len === 32) return x;
		return (_end ? x | 0 : x << 32 - len) + len * 1099511627776;
	},
	getPartial: function(x) {
		return Math.round(x / 1099511627776) || 32;
	},
	equal: function(a, b) {
		if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) return false;
		var x = 0, i;
		for (i = 0; i < a.length; i++) x |= a[i] ^ b[i];
		return x === 0;
	},
	_shiftRight: function(a, shift, carry, out) {
		var i, last2 = 0, shift2;
		if (out === undefined) out = [];
		for (; shift >= 32; shift -= 32) {
			out.push(carry);
			carry = 0;
		}
		if (shift === 0) return out.concat(a);
		for (i = 0; i < a.length; i++) {
			out.push(carry | a[i] >>> shift);
			carry = a[i] << 32 - shift;
		}
		last2 = a.length ? a[a.length - 1] : 0;
		shift2 = sjcl.bitArray.getPartial(last2);
		out.push(sjcl.bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
		return out;
	},
	_xor4: function(x, y) {
		return [
			x[0] ^ y[0],
			x[1] ^ y[1],
			x[2] ^ y[2],
			x[3] ^ y[3]
		];
	},
	byteswapM: function(a) {
		var i, v, m = 65280;
		for (i = 0; i < a.length; ++i) {
			v = a[i];
			a[i] = v >>> 24 | v >>> 8 & m | (v & m) << 8 | v << 24;
		}
		return a;
	}
};
/** @fileOverview Bit array codec implementations.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/**
* UTF-8 strings
* @namespace
*/
sjcl.codec.utf8String = {
	fromBits: function(arr) {
		var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
		for (i = 0; i < bl / 8; i++) {
			if ((i & 3) === 0) tmp = arr[i / 4];
			out += String.fromCharCode(tmp >>> 8 >>> 8 >>> 8);
			tmp <<= 8;
		}
		return decodeURIComponent(escape(out));
	},
	toBits: function(str) {
		str = unescape(encodeURIComponent(str));
		var out = [], i, tmp = 0;
		for (i = 0; i < str.length; i++) {
			tmp = tmp << 8 | str.charCodeAt(i);
			if ((i & 3) === 3) {
				out.push(tmp);
				tmp = 0;
			}
		}
		if (i & 3) out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));
		return out;
	}
};
/** @fileOverview Bit array codec implementations.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/** @fileOverview Bit array codec implementations.
*
* @author Nils Kenneweg
*/
/**
* Base32 encoding/decoding
* @namespace
*/
sjcl.codec.base32 = {
	_chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
	_hexChars: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
	BITS: 32,
	BASE: 5,
	REMAINING: 27,
	fromBits: function(arr, _noEquals, _hex) {
		var BITS = sjcl.codec.base32.BITS, BASE = sjcl.codec.base32.BASE, REMAINING = sjcl.codec.base32.REMAINING;
		var out = "", i, bits = 0, c = sjcl.codec.base32._chars, ta = 0, bl = sjcl.bitArray.bitLength(arr);
		if (_hex) c = sjcl.codec.base32._hexChars;
		for (i = 0; out.length * BASE < bl;) {
			out += c.charAt((ta ^ arr[i] >>> bits) >>> REMAINING);
			if (bits < BASE) {
				ta = arr[i] << BASE - bits;
				bits += REMAINING;
				i++;
			} else {
				ta <<= BASE;
				bits -= BASE;
			}
		}
		while (out.length & 7 && !_noEquals) out += "=";
		return out;
	},
	toBits: function(str, _hex) {
		str = str.replace(/\s|=/g, "").toUpperCase();
		var BITS = sjcl.codec.base32.BITS, BASE = sjcl.codec.base32.BASE, REMAINING = sjcl.codec.base32.REMAINING;
		var out = [], i, bits = 0, c = sjcl.codec.base32._chars, ta = 0, x, format = "base32";
		if (_hex) {
			c = sjcl.codec.base32._hexChars;
			format = "base32hex";
		}
		for (i = 0; i < str.length; i++) {
			x = c.indexOf(str.charAt(i));
			if (x < 0) {
				if (!_hex) try {
					return sjcl.codec.base32hex.toBits(str);
				} catch (e) {}
				throw new sjcl.exception.invalid("this isn't " + format + "!");
			}
			if (bits > REMAINING) {
				bits -= REMAINING;
				out.push(ta ^ x >>> bits);
				ta = x << BITS - bits;
			} else {
				bits += BASE;
				ta ^= x << BITS - bits;
			}
		}
		if (bits & 56) out.push(sjcl.bitArray.partial(bits & 56, ta, 1));
		return out;
	}
};
sjcl.codec.base32hex = {
	fromBits: function(arr, _noEquals) {
		return sjcl.codec.base32.fromBits(arr, _noEquals, 1);
	},
	toBits: function(str) {
		return sjcl.codec.base32.toBits(str, 1);
	}
};
/** @fileOverview Bit array codec implementations.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/**
* Base64 encoding/decoding
* @namespace
*/
sjcl.codec.base64 = {
	_chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	fromBits: function(arr, _noEquals, _url) {
		var out = "", i, bits = 0, c = sjcl.codec.base64._chars, ta = 0, bl = sjcl.bitArray.bitLength(arr);
		if (_url) c = c.substring(0, 62) + "-_";
		for (i = 0; out.length * 6 < bl;) {
			out += c.charAt((ta ^ arr[i] >>> bits) >>> 26);
			if (bits < 6) {
				ta = arr[i] << 6 - bits;
				bits += 26;
				i++;
			} else {
				ta <<= 6;
				bits -= 6;
			}
		}
		while (out.length & 3 && !_noEquals) out += "=";
		return out;
	},
	toBits: function(str, _url) {
		str = str.replace(/\s|=/g, "");
		var out = [], i, bits = 0, c = sjcl.codec.base64._chars, ta = 0, x;
		if (_url) c = c.substring(0, 62) + "-_";
		for (i = 0; i < str.length; i++) {
			x = c.indexOf(str.charAt(i));
			if (x < 0) throw new sjcl.exception.invalid("this isn't base64!");
			if (bits > 26) {
				bits -= 26;
				out.push(ta ^ x >>> bits);
				ta = x << 32 - bits;
			} else {
				bits += 6;
				ta ^= x << 32 - bits;
			}
		}
		if (bits & 56) out.push(sjcl.bitArray.partial(bits & 56, ta, 1));
		return out;
	}
};
/** @fileOverview Javascript SHA-256 implementation.
*
* An older version of this implementation is available in the public
* domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
* Stanford University 2008-2010 and BSD-licensed for liability
* reasons.
*
* Special thanks to Aldo Cortesi for pointing out several bugs in
* this code.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/**
* Context for a SHA-256 operation in progress.
* @constructor
*/
sjcl.hash.sha256 = function(hash) {
	if (!this._key[0]) this._precompute();
	if (hash) {
		this._h = hash._h.slice(0);
		this._buffer = hash._buffer.slice(0);
		this._length = hash._length;
	} else this.reset();
};
/**
* Hash a string or an array of words.
* @static
* @param {bitArray|String} data the data to hash.
* @return {bitArray} The hash value, an array of 16 big-endian words.
*/
sjcl.hash.sha256.hash = function(data) {
	return new sjcl.hash.sha256().update(data).finalize();
};
sjcl.hash.sha256.prototype = {
	blockSize: 512,
	reset: function() {
		this._h = this._init.slice(0);
		this._buffer = [];
		this._length = 0;
		return this;
	},
	update: function(data) {
		if (typeof data === "string") data = sjcl.codec.utf8String.toBits(data);
		var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data), ol = this._length, nl = this._length = ol + sjcl.bitArray.bitLength(data);
		if (nl > 9007199254740991) throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");
		if (typeof Uint32Array !== "undefined") {
			var c = new Uint32Array(b);
			var j = 0;
			for (i = 512 + ol - (512 + ol & 511); i <= nl; i += 512) {
				this._block(c.subarray(16 * j, 16 * (j + 1)));
				j += 1;
			}
			b.splice(0, 16 * j);
		} else for (i = 512 + ol - (512 + ol & 511); i <= nl; i += 512) this._block(b.splice(0, 16));
		return this;
	},
	finalize: function() {
		var i, b = this._buffer, h = this._h;
		b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
		for (i = b.length + 2; i & 15; i++) b.push(0);
		b.push(Math.floor(this._length / 4294967296));
		b.push(this._length | 0);
		while (b.length) this._block(b.splice(0, 16));
		this.reset();
		return h;
	},
	_init: [],
	_key: [],
	_precompute: function() {
		var i = 0, prime = 2, factor, isPrime;
		function frac(x) {
			return (x - Math.floor(x)) * 4294967296 | 0;
		}
		for (; i < 64; prime++) {
			isPrime = true;
			for (factor = 2; factor * factor <= prime; factor++) if (prime % factor === 0) {
				isPrime = false;
				break;
			}
			if (isPrime) {
				if (i < 8) this._init[i] = frac(Math.pow(prime, .5));
				this._key[i] = frac(Math.pow(prime, .3333333333333333));
				i++;
			}
		}
	},
	_block: function(w) {
		var i, tmp, a, b, h = this._h, k = this._key, h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3], h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];
		for (i = 0; i < 64; i++) {
			if (i < 16) tmp = w[i];
else {
				a = w[i + 1 & 15];
				b = w[i + 14 & 15];
				tmp = w[i & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i & 15] + w[i + 9 & 15] | 0;
			}
			tmp = tmp + h7 + (h4 >>> 6 ^ h4 >>> 11 ^ h4 >>> 25 ^ h4 << 26 ^ h4 << 21 ^ h4 << 7) + (h6 ^ h4 & (h5 ^ h6)) + k[i];
			h7 = h6;
			h6 = h5;
			h5 = h4;
			h4 = h3 + tmp | 0;
			h3 = h2;
			h2 = h1;
			h1 = h0;
			h0 = tmp + (h1 & h2 ^ h3 & (h1 ^ h2)) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10) | 0;
		}
		h[0] = h[0] + h0 | 0;
		h[1] = h[1] + h1 | 0;
		h[2] = h[2] + h2 | 0;
		h[3] = h[3] + h3 | 0;
		h[4] = h[4] + h4 | 0;
		h[5] = h[5] + h5 | 0;
		h[6] = h[6] + h6 | 0;
		h[7] = h[7] + h7 | 0;
	}
};
/** @fileOverview Javascript SHA-512 implementation.
*
* This implementation was written for CryptoJS by Jeff Mott and adapted for
* SJCL by Stefan Thomas.
*
* CryptoJS (c) 2009–2012 by Jeff Mott. All rights reserved.
* Released with New BSD License
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
* @author Jeff Mott
* @author Stefan Thomas
*/
/**
* Context for a SHA-512 operation in progress.
* @constructor
*/
sjcl.hash.sha512 = function(hash) {
	if (!this._key[0]) this._precompute();
	if (hash) {
		this._h = hash._h.slice(0);
		this._buffer = hash._buffer.slice(0);
		this._length = hash._length;
	} else this.reset();
};
/**
* Hash a string or an array of words.
* @static
* @param {bitArray|String} data the data to hash.
* @return {bitArray} The hash value, an array of 16 big-endian words.
*/
sjcl.hash.sha512.hash = function(data) {
	return new sjcl.hash.sha512().update(data).finalize();
};
sjcl.hash.sha512.prototype = {
	blockSize: 1024,
	reset: function() {
		this._h = this._init.slice(0);
		this._buffer = [];
		this._length = 0;
		return this;
	},
	update: function(data) {
		if (typeof data === "string") data = sjcl.codec.utf8String.toBits(data);
		var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data), ol = this._length, nl = this._length = ol + sjcl.bitArray.bitLength(data);
		if (nl > 9007199254740991) throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");
		if (typeof Uint32Array !== "undefined") {
			var c = new Uint32Array(b);
			var j = 0;
			for (i = 1024 + ol - (1024 + ol & 1023); i <= nl; i += 1024) {
				this._block(c.subarray(32 * j, 32 * (j + 1)));
				j += 1;
			}
			b.splice(0, 32 * j);
		} else for (i = 1024 + ol - (1024 + ol & 1023); i <= nl; i += 1024) this._block(b.splice(0, 32));
		return this;
	},
	finalize: function() {
		var i, b = this._buffer, h = this._h;
		b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
		for (i = b.length + 4; i & 31; i++) b.push(0);
		b.push(0);
		b.push(0);
		b.push(Math.floor(this._length / 4294967296));
		b.push(this._length | 0);
		while (b.length) this._block(b.splice(0, 32));
		this.reset();
		return h;
	},
	_init: [],
	_initr: [
		12372232,
		13281083,
		9762859,
		1914609,
		15106769,
		4090911,
		4308331,
		8266105
	],
	_key: [],
	_keyr: [
		2666018,
		15689165,
		5061423,
		9034684,
		4764984,
		380953,
		1658779,
		7176472,
		197186,
		7368638,
		14987916,
		16757986,
		8096111,
		1480369,
		13046325,
		6891156,
		15813330,
		5187043,
		9229749,
		11312229,
		2818677,
		10937475,
		4324308,
		1135541,
		6741931,
		11809296,
		16458047,
		15666916,
		11046850,
		698149,
		229999,
		945776,
		13774844,
		2541862,
		12856045,
		9810911,
		11494366,
		7844520,
		15576806,
		8533307,
		15795044,
		4337665,
		16291729,
		5553712,
		15684120,
		6662416,
		7413802,
		12308920,
		13816008,
		4303699,
		9366425,
		10176680,
		13195875,
		4295371,
		6546291,
		11712675,
		15708924,
		1519456,
		15772530,
		6568428,
		6495784,
		8568297,
		13007125,
		7492395,
		2515356,
		12632583,
		14740254,
		7262584,
		1535930,
		13146278,
		16321966,
		1853211,
		294276,
		13051027,
		13221564,
		1051980,
		4080310,
		6651434,
		14088940,
		4675607
	],
	_precompute: function() {
		var i = 0, prime = 2, factor, isPrime;
		function frac(x) {
			return (x - Math.floor(x)) * 4294967296 | 0;
		}
		function frac2(x) {
			return (x - Math.floor(x)) * 1099511627776 & 255;
		}
		for (; i < 80; prime++) {
			isPrime = true;
			for (factor = 2; factor * factor <= prime; factor++) if (prime % factor === 0) {
				isPrime = false;
				break;
			}
			if (isPrime) {
				if (i < 8) {
					this._init[i * 2] = frac(Math.pow(prime, .5));
					this._init[i * 2 + 1] = frac2(Math.pow(prime, .5)) << 24 | this._initr[i];
				}
				this._key[i * 2] = frac(Math.pow(prime, .3333333333333333));
				this._key[i * 2 + 1] = frac2(Math.pow(prime, .3333333333333333)) << 24 | this._keyr[i];
				i++;
			}
		}
	},
	_block: function(words) {
		var i, wrh, wrl, h = this._h, k = this._key, h0h = h[0], h0l = h[1], h1h = h[2], h1l = h[3], h2h = h[4], h2l = h[5], h3h = h[6], h3l = h[7], h4h = h[8], h4l = h[9], h5h = h[10], h5l = h[11], h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];
		var w;
		if (typeof Uint32Array !== "undefined") {
			w = Array(160);
			for (var j = 0; j < 32; j++) w[j] = words[j];
		} else w = words;
		var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
		for (i = 0; i < 80; i++) {
			if (i < 16) {
				wrh = w[i * 2];
				wrl = w[i * 2 + 1];
			} else {
				var gamma0xh = w[(i - 15) * 2];
				var gamma0xl = w[(i - 15) * 2 + 1];
				var gamma0h = (gamma0xl << 31 | gamma0xh >>> 1) ^ (gamma0xl << 24 | gamma0xh >>> 8) ^ gamma0xh >>> 7;
				var gamma0l = (gamma0xh << 31 | gamma0xl >>> 1) ^ (gamma0xh << 24 | gamma0xl >>> 8) ^ (gamma0xh << 25 | gamma0xl >>> 7);
				var gamma1xh = w[(i - 2) * 2];
				var gamma1xl = w[(i - 2) * 2 + 1];
				var gamma1h = (gamma1xl << 13 | gamma1xh >>> 19) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
				var gamma1l = (gamma1xh << 13 | gamma1xl >>> 19) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xh << 26 | gamma1xl >>> 6);
				var wr7h = w[(i - 7) * 2];
				var wr7l = w[(i - 7) * 2 + 1];
				var wr16h = w[(i - 16) * 2];
				var wr16l = w[(i - 16) * 2 + 1];
				wrl = gamma0l + wr7l;
				wrh = gamma0h + wr7h + (wrl >>> 0 < gamma0l >>> 0 ? 1 : 0);
				wrl += gamma1l;
				wrh += gamma1h + (wrl >>> 0 < gamma1l >>> 0 ? 1 : 0);
				wrl += wr16l;
				wrh += wr16h + (wrl >>> 0 < wr16l >>> 0 ? 1 : 0);
			}
			w[i * 2] = wrh |= 0;
			w[i * 2 + 1] = wrl |= 0;
			var chh = eh & fh ^ ~eh & gh;
			var chl = el & fl ^ ~el & gl;
			var majh = ah & bh ^ ah & ch ^ bh & ch;
			var majl = al & bl ^ al & cl ^ bl & cl;
			var sigma0h = (al << 4 | ah >>> 28) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
			var sigma0l = (ah << 4 | al >>> 28) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
			var sigma1h = (el << 18 | eh >>> 14) ^ (el << 14 | eh >>> 18) ^ (eh << 23 | el >>> 9);
			var sigma1l = (eh << 18 | el >>> 14) ^ (eh << 14 | el >>> 18) ^ (el << 23 | eh >>> 9);
			var krh = k[i * 2];
			var krl = k[i * 2 + 1];
			var t1l = hl + sigma1l;
			var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
			t1l += chl;
			t1h += chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
			t1l += krl;
			t1h += krh + (t1l >>> 0 < krl >>> 0 ? 1 : 0);
			t1l = t1l + wrl | 0;
			t1h += wrh + (t1l >>> 0 < wrl >>> 0 ? 1 : 0);
			var t2l = sigma0l + majl;
			var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
			hh = gh;
			hl = gl;
			gh = fh;
			gl = fl;
			fh = eh;
			fl = el;
			el = dl + t1l | 0;
			eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
			dh = ch;
			dl = cl;
			ch = bh;
			cl = bl;
			bh = ah;
			bl = al;
			al = t1l + t2l | 0;
			ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
		}
		h0l = h[1] = h0l + al | 0;
		h[0] = h0h + ah + (h0l >>> 0 < al >>> 0 ? 1 : 0) | 0;
		h1l = h[3] = h1l + bl | 0;
		h[2] = h1h + bh + (h1l >>> 0 < bl >>> 0 ? 1 : 0) | 0;
		h2l = h[5] = h2l + cl | 0;
		h[4] = h2h + ch + (h2l >>> 0 < cl >>> 0 ? 1 : 0) | 0;
		h3l = h[7] = h3l + dl | 0;
		h[6] = h3h + dh + (h3l >>> 0 < dl >>> 0 ? 1 : 0) | 0;
		h4l = h[9] = h4l + el | 0;
		h[8] = h4h + eh + (h4l >>> 0 < el >>> 0 ? 1 : 0) | 0;
		h5l = h[11] = h5l + fl | 0;
		h[10] = h5h + fh + (h5l >>> 0 < fl >>> 0 ? 1 : 0) | 0;
		h6l = h[13] = h6l + gl | 0;
		h[12] = h6h + gh + (h6l >>> 0 < gl >>> 0 ? 1 : 0) | 0;
		h7l = h[15] = h7l + hl | 0;
		h[14] = h7h + hh + (h7l >>> 0 < hl >>> 0 ? 1 : 0) | 0;
	}
};
/** @fileOverview Javascript SHA-1 implementation.
*
* Based on the implementation in RFC 3174, method 1, and on the SJCL
* SHA-256 implementation.
*
* @author Quinn Slack
*/
/**
* Context for a SHA-1 operation in progress.
* @constructor
*/
sjcl.hash.sha1 = function(hash) {
	if (hash) {
		this._h = hash._h.slice(0);
		this._buffer = hash._buffer.slice(0);
		this._length = hash._length;
	} else this.reset();
};
/**
* Hash a string or an array of words.
* @static
* @param {bitArray|String} data the data to hash.
* @return {bitArray} The hash value, an array of 5 big-endian words.
*/
sjcl.hash.sha1.hash = function(data) {
	return new sjcl.hash.sha1().update(data).finalize();
};
sjcl.hash.sha1.prototype = {
	blockSize: 512,
	reset: function() {
		this._h = this._init.slice(0);
		this._buffer = [];
		this._length = 0;
		return this;
	},
	update: function(data) {
		if (typeof data === "string") data = sjcl.codec.utf8String.toBits(data);
		var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data), ol = this._length, nl = this._length = ol + sjcl.bitArray.bitLength(data);
		if (nl > 9007199254740991) throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");
		if (typeof Uint32Array !== "undefined") {
			var c = new Uint32Array(b);
			var j = 0;
			for (i = this.blockSize + ol - (this.blockSize + ol & this.blockSize - 1); i <= nl; i += this.blockSize) {
				this._block(c.subarray(16 * j, 16 * (j + 1)));
				j += 1;
			}
			b.splice(0, 16 * j);
		} else for (i = this.blockSize + ol - (this.blockSize + ol & this.blockSize - 1); i <= nl; i += this.blockSize) this._block(b.splice(0, 16));
		return this;
	},
	finalize: function() {
		var i, b = this._buffer, h = this._h;
		b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
		for (i = b.length + 2; i & 15; i++) b.push(0);
		b.push(Math.floor(this._length / 4294967296));
		b.push(this._length | 0);
		while (b.length) this._block(b.splice(0, 16));
		this.reset();
		return h;
	},
	_init: [
		1732584193,
		4023233417,
		2562383102,
		271733878,
		3285377520
	],
	_key: [
		1518500249,
		1859775393,
		2400959708,
		3395469782
	],
	_f: function(t$1, b, c, d) {
		if (t$1 <= 19) return b & c | ~b & d;
else if (t$1 <= 39) return b ^ c ^ d;
else if (t$1 <= 59) return b & c | b & d | c & d;
else if (t$1 <= 79) return b ^ c ^ d;
	},
	_S: function(n, x) {
		return x << n | x >>> 32 - n;
	},
	_block: function(words) {
		var t$1, tmp, a, b, c, d, e, h = this._h;
		var w;
		if (typeof Uint32Array !== "undefined") {
			w = Array(80);
			for (var j = 0; j < 16; j++) w[j] = words[j];
		} else w = words;
		a = h[0];
		b = h[1];
		c = h[2];
		d = h[3];
		e = h[4];
		for (t$1 = 0; t$1 <= 79; t$1++) {
			if (t$1 >= 16) w[t$1] = this._S(1, w[t$1 - 3] ^ w[t$1 - 8] ^ w[t$1 - 14] ^ w[t$1 - 16]);
			tmp = this._S(5, a) + this._f(t$1, b, c, d) + e + w[t$1] + this._key[Math.floor(t$1 / 20)] | 0;
			e = d;
			d = c;
			c = this._S(30, b);
			b = a;
			a = tmp;
		}
		h[0] = h[0] + a | 0;
		h[1] = h[1] + b | 0;
		h[2] = h[2] + c | 0;
		h[3] = h[3] + d | 0;
		h[4] = h[4] + e | 0;
	}
};
/** @fileOverview CBC mode implementation
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/**
* Dangerous: CBC mode with PKCS#5 padding.
* @namespace
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
sjcl.mode.cbc = {
	name: "cbc",
	encrypt: function(prp, plaintext, iv, adata, usePadding) {
		if (adata && adata.length) throw new sjcl.exception.invalid("cbc can't authenticate data");
		if (sjcl.bitArray.bitLength(iv) !== 128) throw new sjcl.exception.invalid("cbc iv must be 128 bits");
		var i, w = sjcl.bitArray, xor = w._xor4, bl = w.bitLength(plaintext), bp = 0, output = [];
		if (bl & 7) throw new sjcl.exception.invalid("pkcs#5 padding only works for multiples of a byte");
		for (i = 0; bp + 128 <= bl; i += 4, bp += 128) {
			iv = prp.encrypt(xor(iv, plaintext.slice(i, i + 4)));
			output.push(iv[0], iv[1], iv[2], iv[3]);
		}
		if (usePadding) {
			bl = (16 - (bl >> 3 & 15)) * 16843009;
			iv = prp.encrypt(xor(iv, w.concat(plaintext, [
				bl,
				bl,
				bl,
				bl
			]).slice(i, i + 4)));
			output.push(iv[0], iv[1], iv[2], iv[3]);
		}
		return output;
	},
	decrypt: function(prp, ciphertext, iv, adata, usePadding) {
		if (adata && adata.length) throw new sjcl.exception.invalid("cbc can't authenticate data");
		if (sjcl.bitArray.bitLength(iv) !== 128) throw new sjcl.exception.invalid("cbc iv must be 128 bits");
		if (sjcl.bitArray.bitLength(ciphertext) & 127 || !ciphertext.length) throw new sjcl.exception.corrupt("cbc ciphertext must be a positive multiple of the block size");
		var i, w = sjcl.bitArray, xor = w._xor4, bi, bo, output = [];
		adata = adata || [];
		for (i = 0; i < ciphertext.length; i += 4) {
			bi = ciphertext.slice(i, i + 4);
			bo = xor(iv, prp.decrypt(bi));
			output.push(bo[0], bo[1], bo[2], bo[3]);
			iv = bi;
		}
		if (usePadding) {
			bi = output[i - 1] & 255;
			if (bi === 0 || bi > 16) throw new sjcl.exception.corrupt("pkcs#5 padding corrupt");
			bo = bi * 16843009;
			if (!w.equal(w.bitSlice([
				bo,
				bo,
				bo,
				bo
			], 0, bi * 8), w.bitSlice(output, output.length * 32 - bi * 8, output.length * 32))) throw new sjcl.exception.corrupt("pkcs#5 padding corrupt");
			return w.bitSlice(output, 0, output.length * 32 - bi * 8);
		} else return output;
	}
};
/** @fileOverview GCM mode implementation.
*
* @author Juho Vähä-Herttua
*/
/**
* Galois/Counter mode.
* @namespace
*/
sjcl.mode.gcm = {
	name: "gcm",
	encrypt: function(prf, plaintext, iv, adata, tlen) {
		var out, data = plaintext.slice(0), w = sjcl.bitArray;
		tlen = tlen || 128;
		adata = adata || [];
		out = sjcl.mode.gcm._ctrMode(true, prf, data, adata, iv, tlen);
		return w.concat(out.data, out.tag);
	},
	decrypt: function(prf, ciphertext, iv, adata, tlen) {
		var out, data = ciphertext.slice(0), tag, w = sjcl.bitArray, l = w.bitLength(data);
		tlen = tlen || 128;
		adata = adata || [];
		if (tlen <= l) {
			tag = w.bitSlice(data, l - tlen);
			data = w.bitSlice(data, 0, l - tlen);
		} else {
			tag = data;
			data = [];
		}
		out = sjcl.mode.gcm._ctrMode(false, prf, data, adata, iv, tlen);
		if (!w.equal(out.tag, tag)) throw new sjcl.exception.corrupt("gcm: tag doesn't match");
		return out.data;
	},
	_galoisMultiply: function(x, y) {
		var i, j, xi, Zi, Vi, lsb_Vi, w = sjcl.bitArray, xor = w._xor4;
		Zi = [
			0,
			0,
			0,
			0
		];
		Vi = y.slice(0);
		for (i = 0; i < 128; i++) {
			xi = (x[Math.floor(i / 32)] & 1 << 31 - i % 32) !== 0;
			if (xi) Zi = xor(Zi, Vi);
			lsb_Vi = (Vi[3] & 1) !== 0;
			for (j = 3; j > 0; j--) Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
			Vi[0] = Vi[0] >>> 1;
			if (lsb_Vi) Vi[0] = Vi[0] ^ -520093696;
		}
		return Zi;
	},
	_ghash: function(H, Y0, data) {
		var Yi, i, l = data.length;
		Yi = Y0.slice(0);
		for (i = 0; i < l; i += 4) {
			Yi[0] ^= 4294967295 & data[i];
			Yi[1] ^= 4294967295 & data[i + 1];
			Yi[2] ^= 4294967295 & data[i + 2];
			Yi[3] ^= 4294967295 & data[i + 3];
			Yi = sjcl.mode.gcm._galoisMultiply(Yi, H);
		}
		return Yi;
	},
	_ctrMode: function(encrypt, prf, data, adata, iv, tlen) {
		var H, J0, S0, enc, i, ctr, tag, last, l, bl, abl, ivbl, w = sjcl.bitArray;
		l = data.length;
		bl = w.bitLength(data);
		abl = w.bitLength(adata);
		ivbl = w.bitLength(iv);
		H = prf.encrypt([
			0,
			0,
			0,
			0
		]);
		if (ivbl === 96) {
			J0 = iv.slice(0);
			J0 = w.concat(J0, [1]);
		} else {
			J0 = sjcl.mode.gcm._ghash(H, [
				0,
				0,
				0,
				0
			], iv);
			J0 = sjcl.mode.gcm._ghash(H, J0, [
				0,
				0,
				Math.floor(ivbl / 4294967296),
				ivbl & 4294967295
			]);
		}
		S0 = sjcl.mode.gcm._ghash(H, [
			0,
			0,
			0,
			0
		], adata);
		ctr = J0.slice(0);
		tag = S0.slice(0);
		if (!encrypt) tag = sjcl.mode.gcm._ghash(H, S0, data);
		for (i = 0; i < l; i += 4) {
			ctr[3]++;
			enc = prf.encrypt(ctr);
			data[i] ^= enc[0];
			data[i + 1] ^= enc[1];
			data[i + 2] ^= enc[2];
			data[i + 3] ^= enc[3];
		}
		data = w.clamp(data, bl);
		if (encrypt) tag = sjcl.mode.gcm._ghash(H, S0, data);
		last = [
			Math.floor(abl / 4294967296),
			abl & 4294967295,
			Math.floor(bl / 4294967296),
			bl & 4294967295
		];
		tag = sjcl.mode.gcm._ghash(H, tag, last);
		enc = prf.encrypt(J0);
		tag[0] ^= enc[0];
		tag[1] ^= enc[1];
		tag[2] ^= enc[2];
		tag[3] ^= enc[3];
		return {
			tag: w.bitSlice(tag, 0, tlen),
			data
		};
	}
};
/** @fileOverview HMAC implementation.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
*/
/** HMAC with the specified hash function.
* @constructor
* @param {bitArray} key the key for HMAC.
* @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.
*/
sjcl.misc.hmac = function(key, Hash) {
	this._hash = Hash = Hash || sjcl.hash.sha256;
	var exKey = [[], []], i, bs = Hash.prototype.blockSize / 32;
	this._baseHash = [new Hash(), new Hash()];
	if (key.length > bs) key = Hash.hash(key);
	for (i = 0; i < bs; i++) {
		exKey[0][i] = key[i] ^ 909522486;
		exKey[1][i] = key[i] ^ 1549556828;
	}
	this._baseHash[0].update(exKey[0]);
	this._baseHash[1].update(exKey[1]);
	this._resultHash = new Hash(this._baseHash[0]);
};
/** HMAC with the specified hash function.  Also called encrypt since it's a prf.
* @param {bitArray|String} data The data to mac.
*/
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function(data) {
	if (!this._updated) {
		this.update(data);
		return this.digest(data);
	} else throw new sjcl.exception.invalid("encrypt on already updated hmac called!");
};
sjcl.misc.hmac.prototype.reset = function() {
	this._resultHash = new this._hash(this._baseHash[0]);
	this._updated = false;
};
sjcl.misc.hmac.prototype.update = function(data) {
	this._updated = true;
	this._resultHash.update(data);
};
sjcl.misc.hmac.prototype.digest = function() {
	var w = this._resultHash.finalize(), result = new this._hash(this._baseHash[1]).update(w).finalize();
	this.reset();
	return result;
};
/** @fileOverview Random number generator.
*
* @author Emily Stark
* @author Mike Hamburg
* @author Dan Boneh
* @author Michael Brooks
* @author Steve Thomas
*/
/**
* @class Random number generator
* @description
* <b>Use sjcl.random as a singleton for this class!</b>
* <p>
* This random number generator is a derivative of Ferguson and Schneier's
* generator Fortuna.  It collects entropy from various events into several
* pools, implemented by streaming SHA-256 instances.  It differs from
* ordinary Fortuna in a few ways, though.
* </p>
*
* <p>
* Most importantly, it has an entropy estimator.  This is present because
* there is a strong conflict here between making the generator available
* as soon as possible, and making sure that it doesn't "run on empty".
* In Fortuna, there is a saved state file, and the system is likely to have
* time to warm up.
* </p>
*
* <p>
* Second, because users are unlikely to stay on the page for very long,
* and to speed startup time, the number of pools increases logarithmically:
* a new pool is created when the previous one is actually used for a reseed.
* This gives the same asymptotic guarantees as Fortuna, but gives more
* entropy to early reseeds.
* </p>
*
* <p>
* The entire mechanism here feels pretty klunky.  Furthermore, there are
* several improvements that should be made, including support for
* dedicated cryptographic functions that may be present in some browsers;
* state files in local storage; cookies containing randomness; etc.  So
* look for improvements in future versions.
* </p>
* @constructor
*/
sjcl.prng = function(defaultParanoia) {
	this._pools = [new sjcl.hash.sha256()];
	this._poolEntropy = [0];
	this._reseedCount = 0;
	this._robins = {};
	this._eventId = 0;
	this._collectorIds = {};
	this._collectorIdNext = 0;
	this._strength = 0;
	this._poolStrength = 0;
	this._nextReseed = 0;
	this._key = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	this._counter = [
		0,
		0,
		0,
		0
	];
	this._defaultParanoia = defaultParanoia;
	this._NOT_READY = 0;
	this._READY = 1;
	this._REQUIRES_RESEED = 2;
	this._MAX_WORDS_PER_BURST = 65536;
	this._PARANOIA_LEVELS = [
		0,
		48,
		64,
		96,
		128,
		192,
		256,
		384,
		512,
		768,
		1024
	];
	this._MILLISECONDS_PER_RESEED = 3e4;
	this._BITS_PER_RESEED = 80;
};
sjcl.prng.prototype = {
	randomWords: function(nwords, paranoia) {
		var out = [], i, readiness = this.isReady(paranoia), g;
		if (readiness === this._NOT_READY) throw new sjcl.exception.notReady("generator isn't seeded");
else if (readiness & this._REQUIRES_RESEED) this._reseedFromPools(!(readiness & this._READY));
		for (i = 0; i < nwords; i += 4) {
			if ((i + 1) % this._MAX_WORDS_PER_BURST === 0) this._gate();
			g = this._gen4words();
			out.push(g[0], g[1], g[2], g[3]);
		}
		this._gate();
		return out.slice(0, nwords);
	},
	addEntropy: function(data, estimatedEntropy, source) {
		source = source || "user";
		var id, i, tmp, t$1 = new Date().valueOf(), robin = this._robins[source], oldReady = this.isReady(), err = 0, objName;
		id = this._collectorIds[source];
		if (id === undefined) id = this._collectorIds[source] = this._collectorIdNext++;
		if (robin === undefined) robin = this._robins[source] = 0;
		this._robins[source] = (this._robins[source] + 1) % this._pools.length;
		switch (typeof data) {
			case "number":
				if (estimatedEntropy === undefined) estimatedEntropy = 1;
				this._pools[robin].update([
					id,
					this._eventId++,
					1,
					estimatedEntropy,
					t$1,
					1,
					data | 0
				]);
				break;
			case "object":
				objName = Object.prototype.toString.call(data);
				if (objName === "[object Uint32Array]") {
					tmp = [];
					for (i = 0; i < data.length; i++) tmp.push(data[i]);
					data = tmp;
				} else {
					if (objName !== "[object Array]") err = 1;
					for (i = 0; i < data.length && !err; i++) if (typeof data[i] !== "number") err = 1;
				}
				if (!err) {
					if (estimatedEntropy === undefined) {
						estimatedEntropy = 0;
						for (i = 0; i < data.length; i++) {
							tmp = data[i];
							while (tmp > 0) {
								estimatedEntropy++;
								tmp = tmp >>> 1;
							}
						}
					}
					this._pools[robin].update([
						id,
						this._eventId++,
						2,
						estimatedEntropy,
						t$1,
						data.length
					].concat(data));
				}
				break;
			case "string":
				if (estimatedEntropy === undefined) estimatedEntropy = data.length;
				this._pools[robin].update([
					id,
					this._eventId++,
					3,
					estimatedEntropy,
					t$1,
					data.length
				]);
				this._pools[robin].update(data);
				break;
			default: err = 1;
		}
		if (err) throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
		this._poolEntropy[robin] += estimatedEntropy;
		this._poolStrength += estimatedEntropy;
	},
	isReady: function(paranoia) {
		var entropyRequired = this._PARANOIA_LEVELS[paranoia !== undefined ? paranoia : this._defaultParanoia];
		if (this._strength && this._strength >= entropyRequired) return this._poolEntropy[0] > this._BITS_PER_RESEED && new Date().valueOf() > this._nextReseed ? this._REQUIRES_RESEED | this._READY : this._READY;
else return this._poolStrength >= entropyRequired ? this._REQUIRES_RESEED | this._NOT_READY : this._NOT_READY;
	},
	_gen4words: function() {
		for (var i = 0; i < 4; i++) {
			this._counter[i] = this._counter[i] + 1 | 0;
			if (this._counter[i]) break;
		}
		return this._cipher.encrypt(this._counter);
	},
	_gate: function() {
		this._key = this._gen4words().concat(this._gen4words());
		this._cipher = new sjcl.cipher.aes(this._key);
	},
	_reseed: function(seedWords) {
		this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));
		this._cipher = new sjcl.cipher.aes(this._key);
		for (var i = 0; i < 4; i++) {
			this._counter[i] = this._counter[i] + 1 | 0;
			if (this._counter[i]) break;
		}
	},
	_reseedFromPools: function(full) {
		var reseedData = [], strength = 0, i;
		this._nextReseed = reseedData[0] = new Date().valueOf() + this._MILLISECONDS_PER_RESEED;
		for (i = 0; i < 16; i++) reseedData.push(Math.random() * 4294967296 | 0);
		for (i = 0; i < this._pools.length; i++) {
			reseedData = reseedData.concat(this._pools[i].finalize());
			strength += this._poolEntropy[i];
			this._poolEntropy[i] = 0;
			if (!full && this._reseedCount & 1 << i) break;
		}
		if (this._reseedCount >= 1 << this._pools.length) {
			this._pools.push(new sjcl.hash.sha256());
			this._poolEntropy.push(0);
		}
		this._poolStrength -= strength;
		if (strength > this._strength) this._strength = strength;
		this._reseedCount++;
		this._reseed(reseedData);
	}
};
/** an instance for the prng.
* @see sjcl.prng
*/
/**
* ArrayBuffer
* @namespace
*/
sjcl.codec.arrayBuffer = {
	fromBits: function(arr, padding, padding_count) {
		var out, i, ol, tmp, smallest;
		padding = padding == undefined ? true : padding;
		padding_count = padding_count || 8;
		if (arr.length === 0) return new ArrayBuffer(0);
		ol = sjcl.bitArray.bitLength(arr) / 8;
		if (sjcl.bitArray.bitLength(arr) % 8 !== 0) throw new sjcl.exception.invalid("Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly");
		if (padding && ol % padding_count !== 0) ol += padding_count - ol % padding_count;
		tmp = new DataView(new ArrayBuffer(arr.length * 4));
		for (i = 0; i < arr.length; i++) tmp.setUint32(i * 4, arr[i] << 32);
		out = new DataView(new ArrayBuffer(ol));
		if (out.byteLength === tmp.byteLength) return tmp.buffer;
		smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;
		for (i = 0; i < smallest; i++) out.setUint8(i, tmp.getUint8(i));
		return out.buffer;
	},
	toBits: function(buffer, byteOffset, byteLength) {
		var i, out = [], len, inView, tmp;
		if (buffer.byteLength === 0) return [];
		inView = new DataView(buffer, byteOffset, byteLength);
		len = inView.byteLength - inView.byteLength % 4;
		for (var i = 0; i < len; i += 4) out.push(inView.getUint32(i));
		if (inView.byteLength % 4 != 0) {
			tmp = new DataView(new ArrayBuffer(4));
			for (var i = 0, l = inView.byteLength % 4; i < l; i++) tmp.setUint8(i + 4 - l, inView.getUint8(len + i));
			out.push(sjcl.bitArray.partial(inView.byteLength % 4 * 8, tmp.getUint32(0)));
		}
		return out;
	}
};
var sjcl_default = sjcl;

//#endregion
//#region ../packages/tutanota-crypto/dist/random/Randomizer.js
var Randomizer = class {
	random;
	constructor() {
		this.random = new sjcl_default.prng(6);
	}
	/**
	* Adds entropy to the random number generator algorithm
	* @param entropyCache with: number Any number value, entropy The amount of entropy in the number in bit,
	* source The source of the number.
	*/
	addEntropy(entropyCache) {
		for (const entry of entropyCache) this.random.addEntropy(entry.data, entry.entropy, entry.source);
		return Promise.resolve();
	}
	addStaticEntropy(bytes) {
		for (const byte of bytes) this.random.addEntropy(byte, 8, "static");
	}
	/**
	* Not used currently because we always have enough entropy using getRandomValues()
	*/
	isReady() {
		return this.random.isReady() !== 0;
	}
	/**
	* Generates random data. The function initRandomDataGenerator must have been called prior to the first call to this function.
	* @param nbrOfBytes The number of bytes the random data shall have.
	* @return A hex coded string of random data.
	* @throws {CryptoError} if the randomizer is not seeded (isReady == false)
	*/
	generateRandomData(nbrOfBytes) {
		try {
			let nbrOfWords = Math.floor((nbrOfBytes + 3) / 4);
			let words = this.random.randomWords(nbrOfWords);
			let arrayBuffer = sjcl_default.codec.arrayBuffer.fromBits(words, false);
			return new Uint8Array(arrayBuffer, 0, nbrOfBytes);
		} catch (e) {
			throw new CryptoError("error during random number generation", e);
		}
	}
	/**
	* Generate a number that fits in the range of an n-byte integer
	*/
	generateRandomNumber(nbrOfBytes) {
		const bytes = this.generateRandomData(nbrOfBytes);
		let result = 0;
		for (let i = 0; i < bytes.length; ++i) result += bytes[i] << i * 8;
		return result;
	}
};
const random = new Randomizer();

//#endregion
//#region ../packages/tutanota-crypto/dist/hashes/Sha256.js
const sha256 = new sjcl_default.hash.sha256();
function sha256Hash(uint8Array) {
	try {
		sha256.update(sjcl_default.codec.arrayBuffer.toBits(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength));
		return new Uint8Array(sjcl_default.codec.arrayBuffer.fromBits(sha256.finalize(), false));
	} finally {
		sha256.reset();
	}
}

//#endregion
//#region ../packages/tutanota-crypto/dist/misc/Utils.js
function createAuthVerifier(passwordKey) {
	return sha256Hash(bitArrayToUint8Array(passwordKey));
}
function createAuthVerifierAsBase64Url(passwordKey) {
	return base64ToBase64Url(uint8ArrayToBase64(createAuthVerifier(passwordKey)));
}
function bitArrayToUint8Array(bits) {
	return new Uint8Array(sjcl_default.codec.arrayBuffer.fromBits(bits, false));
}
function uint8ArrayToBitArray(uint8Array) {
	return sjcl_default.codec.arrayBuffer.toBits(uint8ArrayToArrayBuffer(uint8Array));
}
function keyToBase64(key) {
	return sjcl_default.codec.base64.fromBits(key);
}
function base64ToKey(base64) {
	try {
		return sjcl_default.codec.base64.toBits(base64);
	} catch (e) {
		throw new CryptoError("hex to aes key failed", e);
	}
}
function uint8ArrayToKey(array) {
	return base64ToKey(uint8ArrayToBase64(array));
}
function keyToUint8Array(key) {
	return base64ToUint8Array(keyToBase64(key));
}
const fixedIv = hexToUint8Array("88888888888888888888888888888888");

//#endregion
//#region ../packages/tutanota-crypto/dist/hashes/Sha512.js
const sha512 = new sjcl_default.hash.sha512();
function sha512Hash(uint8Array) {
	try {
		sha512.update(sjcl_default.codec.arrayBuffer.toBits(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength));
		return new Uint8Array(sjcl_default.codec.arrayBuffer.fromBits(sha512.finalize(), false));
	} finally {
		sha512.reset();
	}
}

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/Aes.js
const ENABLE_MAC = true;
const IV_BYTE_LENGTH = 16;
const KEY_LENGTH_BYTES_AES_256 = 32;
const KEY_LENGTH_BITS_AES_256 = KEY_LENGTH_BYTES_AES_256 * 8;
const KEY_LENGTH_BYTES_AES_128 = 16;
const KEY_LENGTH_BITS_AES_128 = KEY_LENGTH_BYTES_AES_128 * 8;
const MAC_ENABLED_PREFIX = 1;
const MAC_LENGTH_BYTES = 32;
function getKeyLengthBytes(key) {
	return key.length * 4;
}
function aes256RandomKey() {
	return uint8ArrayToBitArray(random.generateRandomData(KEY_LENGTH_BYTES_AES_256));
}
function generateIV() {
	return random.generateRandomData(IV_BYTE_LENGTH);
}
function aesEncrypt(key, bytes, iv = generateIV(), usePadding = true, useMac = true) {
	verifyKeySize(key, [KEY_LENGTH_BITS_AES_128, KEY_LENGTH_BITS_AES_256]);
	if (iv.length !== IV_BYTE_LENGTH) throw new CryptoError(`Illegal IV length: ${iv.length} (expected: ${IV_BYTE_LENGTH}): ${uint8ArrayToBase64(iv)} `);
	if (!useMac && getKeyLengthBytes(key) === KEY_LENGTH_BYTES_AES_256) throw new CryptoError(`Can't use AES-256 without MAC`);
	let subKeys = getAesSubKeys(key, useMac);
	let encryptedBits = sjcl_default.mode.cbc.encrypt(new sjcl_default.cipher.aes(subKeys.cKey), uint8ArrayToBitArray(bytes), uint8ArrayToBitArray(iv), [], usePadding);
	let data = concat(iv, bitArrayToUint8Array(encryptedBits));
	if (useMac) {
		let hmac = new sjcl_default.misc.hmac(subKeys.mKey, sjcl_default.hash.sha256);
		let macBytes = bitArrayToUint8Array(hmac.encrypt(uint8ArrayToBitArray(data)));
		data = concat(new Uint8Array([MAC_ENABLED_PREFIX]), data, macBytes);
	}
	return data;
}
function aes256EncryptSearchIndexEntry(key, bytes, iv = generateIV(), usePadding = true) {
	verifyKeySize(key, [KEY_LENGTH_BITS_AES_256]);
	if (iv.length !== IV_BYTE_LENGTH) throw new CryptoError(`Illegal IV length: ${iv.length} (expected: ${IV_BYTE_LENGTH}): ${uint8ArrayToBase64(iv)} `);
	let subKeys = getAesSubKeys(key, false);
	let encryptedBits = sjcl_default.mode.cbc.encrypt(new sjcl_default.cipher.aes(subKeys.cKey), uint8ArrayToBitArray(bytes), uint8ArrayToBitArray(iv), [], usePadding);
	let data = concat(iv, bitArrayToUint8Array(encryptedBits));
	return data;
}
function aesDecrypt(key, encryptedBytes, usePadding = true) {
	const keyLength = getKeyLengthBytes(key);
	if (keyLength === KEY_LENGTH_BYTES_AES_128) return aesDecryptImpl(key, encryptedBytes, usePadding, false);
else return aesDecryptImpl(key, encryptedBytes, usePadding, true);
}
function authenticatedAesDecrypt(key, encryptedBytes, usePadding = true) {
	return aesDecryptImpl(key, encryptedBytes, usePadding, true);
}
function unauthenticatedAesDecrypt(key, encryptedBytes, usePadding = true) {
	return aesDecryptImpl(key, encryptedBytes, usePadding, false);
}
/**
* Decrypts the given words with AES-128/256 in CBC mode.
* @param key The key to use for the decryption.
* @param encryptedBytes The ciphertext encoded as bytes.
* @param usePadding If true, padding is used, otherwise no padding is used and the encrypted data must have the key size.
* @param enforceMac if true decryption will fail if there is no valid mac. we only support false for backward compatibility.
* 				 it must not be used with new cryto anymore.
* @return The decrypted bytes.
*/
function aesDecryptImpl(key, encryptedBytes, usePadding, enforceMac) {
	verifyKeySize(key, [KEY_LENGTH_BITS_AES_128, KEY_LENGTH_BITS_AES_256]);
	const hasMac = encryptedBytes.length % 2 === 1;
	if (enforceMac && !hasMac) throw new CryptoError("mac expected but not present");
	const subKeys = getAesSubKeys(key, hasMac);
	let cipherTextWithoutMac;
	if (hasMac) {
		cipherTextWithoutMac = encryptedBytes.subarray(1, encryptedBytes.length - MAC_LENGTH_BYTES);
		const providedMacBytes = encryptedBytes.subarray(encryptedBytes.length - MAC_LENGTH_BYTES);
		const hmac = new sjcl_default.misc.hmac(subKeys.mKey, sjcl_default.hash.sha256);
		const computedMacBytes = bitArrayToUint8Array(hmac.encrypt(uint8ArrayToBitArray(cipherTextWithoutMac)));
		if (!arrayEquals(providedMacBytes, computedMacBytes)) throw new CryptoError("invalid mac");
	} else cipherTextWithoutMac = encryptedBytes;
	const iv = cipherTextWithoutMac.slice(0, IV_BYTE_LENGTH);
	if (iv.length !== IV_BYTE_LENGTH) throw new CryptoError(`Invalid IV length in aesDecrypt: ${iv.length} bytes, must be 16 bytes (128 bits)`);
	const ciphertext = cipherTextWithoutMac.slice(IV_BYTE_LENGTH);
	try {
		const decrypted = sjcl_default.mode.cbc.decrypt(new sjcl_default.cipher.aes(subKeys.cKey), uint8ArrayToBitArray(ciphertext), uint8ArrayToBitArray(iv), [], usePadding);
		return new Uint8Array(bitArrayToUint8Array(decrypted));
	} catch (e) {
		throw new CryptoError("aes decryption failed", e);
	}
}
function verifyKeySize(key, bitLength) {
	if (!bitLength.includes(sjcl_default.bitArray.bitLength(key))) throw new CryptoError(`Illegal key length: ${sjcl_default.bitArray.bitLength(key)} (expected: ${bitLength})`);
}
function getAesSubKeys(key, mac) {
	if (mac) {
		let hashedKey;
		switch (getKeyLengthBytes(key)) {
			case KEY_LENGTH_BYTES_AES_128:
				hashedKey = sha256Hash(bitArrayToUint8Array(key));
				break;
			case KEY_LENGTH_BYTES_AES_256:
				hashedKey = sha512Hash(bitArrayToUint8Array(key));
				break;
			default: throw new Error(`unexpected key length ${getKeyLengthBytes(key)}`);
		}
		return {
			cKey: uint8ArrayToBitArray(hashedKey.subarray(0, hashedKey.length / 2)),
			mKey: uint8ArrayToBitArray(hashedKey.subarray(hashedKey.length / 2, hashedKey.length))
		};
	} else return {
		cKey: key,
		mKey: null
	};
}

//#endregion
//#region ../packages/tutanota-crypto/dist/internal/noble-curves-1.3.0.js
var nobleCurves = (() => {
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __export = (target, all) => {
		for (var name in all) __defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
	var input_exports = {};
	__export(input_exports, { x25519: () => x25519$1 });
	function isBytes(a) {
		return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
	}
	function bytes(b, ...lengths) {
		if (!isBytes(b)) throw new Error("Expected Uint8Array");
		if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
	}
	function exists(instance, checkFinished = true) {
		if (instance.destroyed) throw new Error("Hash instance has been destroyed");
		if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
	}
	function output(out, instance) {
		bytes(out);
		const min = instance.outputLen;
		if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
	}
	var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
	function isBytes2(a) {
		return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
	}
	var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
	var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
	if (!isLE) throw new Error("Non little-endian hardware is not supported");
	function utf8ToBytes(str) {
		if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
		return new Uint8Array(new TextEncoder().encode(str));
	}
	function toBytes(data) {
		if (typeof data === "string") data = utf8ToBytes(data);
		if (!isBytes2(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);
		return data;
	}
	function concatBytes(...arrays) {
		let sum = 0;
		for (let i = 0; i < arrays.length; i++) {
			const a = arrays[i];
			if (!isBytes2(a)) throw new Error("Uint8Array expected");
			sum += a.length;
		}
		const res = new Uint8Array(sum);
		for (let i = 0, pad = 0; i < arrays.length; i++) {
			const a = arrays[i];
			res.set(a, pad);
			pad += a.length;
		}
		return res;
	}
	var Hash = class {
		clone() {
			return this._cloneInto();
		}
	};
	var toStr = {}.toString;
	function wrapConstructor(hashCons) {
		const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
		const tmp = hashCons();
		hashC.outputLen = tmp.outputLen;
		hashC.blockLen = tmp.blockLen;
		hashC.create = () => hashCons();
		return hashC;
	}
	function randomBytes(bytesLength = 32) {
		if (crypto && typeof crypto.getRandomValues === "function") return crypto.getRandomValues(new Uint8Array(bytesLength));
		throw new Error("crypto.getRandomValues must be defined");
	}
	function setBigUint64(view, byteOffset, value, isLE2) {
		if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE2);
		const _32n2 = BigInt(32);
		const _u32_max = BigInt(4294967295);
		const wh = Number(value >> _32n2 & _u32_max);
		const wl = Number(value & _u32_max);
		const h = isLE2 ? 4 : 0;
		const l = isLE2 ? 0 : 4;
		view.setUint32(byteOffset + h, wh, isLE2);
		view.setUint32(byteOffset + l, wl, isLE2);
	}
	var SHA2 = class extends Hash {
		constructor(blockLen, outputLen, padOffset, isLE2) {
			super();
			this.blockLen = blockLen;
			this.outputLen = outputLen;
			this.padOffset = padOffset;
			this.isLE = isLE2;
			this.finished = false;
			this.length = 0;
			this.pos = 0;
			this.destroyed = false;
			this.buffer = new Uint8Array(blockLen);
			this.view = createView(this.buffer);
		}
		update(data) {
			exists(this);
			const { view, buffer, blockLen } = this;
			data = toBytes(data);
			const len = data.length;
			for (let pos = 0; pos < len;) {
				const take = Math.min(blockLen - this.pos, len - pos);
				if (take === blockLen) {
					const dataView = createView(data);
					for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
					continue;
				}
				buffer.set(data.subarray(pos, pos + take), this.pos);
				this.pos += take;
				pos += take;
				if (this.pos === blockLen) {
					this.process(view, 0);
					this.pos = 0;
				}
			}
			this.length += data.length;
			this.roundClean();
			return this;
		}
		digestInto(out) {
			exists(this);
			output(out, this);
			this.finished = true;
			const { buffer, view, blockLen, isLE: isLE2 } = this;
			let { pos } = this;
			buffer[pos++] = 128;
			this.buffer.subarray(pos).fill(0);
			if (this.padOffset > blockLen - pos) {
				this.process(view, 0);
				pos = 0;
			}
			for (let i = pos; i < blockLen; i++) buffer[i] = 0;
			setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
			this.process(view, 0);
			const oview = createView(out);
			const len = this.outputLen;
			if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
			const outLen = len / 4;
			const state = this.get();
			if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
			for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE2);
		}
		digest() {
			const { buffer, outputLen } = this;
			this.digestInto(buffer);
			const res = buffer.slice(0, outputLen);
			this.destroy();
			return res;
		}
		_cloneInto(to) {
			to || (to = new this.constructor());
			to.set(...this.get());
			const { blockLen, buffer, length, finished, destroyed, pos } = this;
			to.length = length;
			to.pos = pos;
			to.finished = finished;
			to.destroyed = destroyed;
			if (length % blockLen) to.buffer.set(buffer);
			return to;
		}
	};
	var U32_MASK64 = /* @__PURE__ */ BigInt(4294967295);
	var _32n = /* @__PURE__ */ BigInt(32);
	function fromBig(n, le = false) {
		if (le) return {
			h: Number(n & U32_MASK64),
			l: Number(n >> _32n & U32_MASK64)
		};
		return {
			h: Number(n >> _32n & U32_MASK64) | 0,
			l: Number(n & U32_MASK64) | 0
		};
	}
	function split(lst, le = false) {
		let Ah = new Uint32Array(lst.length);
		let Al = new Uint32Array(lst.length);
		for (let i = 0; i < lst.length; i++) {
			const { h, l } = fromBig(lst[i], le);
			[Ah[i], Al[i]] = [h, l];
		}
		return [Ah, Al];
	}
	var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
	var shrSH = (h, _l, s) => h >>> s;
	var shrSL = (h, l, s) => h << 32 - s | l >>> s;
	var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
	var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
	var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
	var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
	var rotr32H = (_h, l) => l;
	var rotr32L = (h, _l) => h;
	var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
	var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
	var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
	var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
	function add(Ah, Al, Bh, Bl) {
		const l = (Al >>> 0) + (Bl >>> 0);
		return {
			h: Ah + Bh + (l / 4294967296 | 0) | 0,
			l: l | 0
		};
	}
	var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
	var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 4294967296 | 0) | 0;
	var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
	var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 4294967296 | 0) | 0;
	var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
	var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 4294967296 | 0) | 0;
	var u64 = {
		fromBig,
		split,
		toBig,
		shrSH,
		shrSL,
		rotrSH,
		rotrSL,
		rotrBH,
		rotrBL,
		rotr32H,
		rotr32L,
		rotlSH,
		rotlSL,
		rotlBH,
		rotlBL,
		add,
		add3L,
		add3H,
		add4L,
		add4H,
		add5H,
		add5L
	};
	var u64_default = u64;
	var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default.split([
		"0x428a2f98d728ae22",
		"0x7137449123ef65cd",
		"0xb5c0fbcfec4d3b2f",
		"0xe9b5dba58189dbbc",
		"0x3956c25bf348b538",
		"0x59f111f1b605d019",
		"0x923f82a4af194f9b",
		"0xab1c5ed5da6d8118",
		"0xd807aa98a3030242",
		"0x12835b0145706fbe",
		"0x243185be4ee4b28c",
		"0x550c7dc3d5ffb4e2",
		"0x72be5d74f27b896f",
		"0x80deb1fe3b1696b1",
		"0x9bdc06a725c71235",
		"0xc19bf174cf692694",
		"0xe49b69c19ef14ad2",
		"0xefbe4786384f25e3",
		"0x0fc19dc68b8cd5b5",
		"0x240ca1cc77ac9c65",
		"0x2de92c6f592b0275",
		"0x4a7484aa6ea6e483",
		"0x5cb0a9dcbd41fbd4",
		"0x76f988da831153b5",
		"0x983e5152ee66dfab",
		"0xa831c66d2db43210",
		"0xb00327c898fb213f",
		"0xbf597fc7beef0ee4",
		"0xc6e00bf33da88fc2",
		"0xd5a79147930aa725",
		"0x06ca6351e003826f",
		"0x142929670a0e6e70",
		"0x27b70a8546d22ffc",
		"0x2e1b21385c26c926",
		"0x4d2c6dfc5ac42aed",
		"0x53380d139d95b3df",
		"0x650a73548baf63de",
		"0x766a0abb3c77b2a8",
		"0x81c2c92e47edaee6",
		"0x92722c851482353b",
		"0xa2bfe8a14cf10364",
		"0xa81a664bbc423001",
		"0xc24b8b70d0f89791",
		"0xc76c51a30654be30",
		"0xd192e819d6ef5218",
		"0xd69906245565a910",
		"0xf40e35855771202a",
		"0x106aa07032bbd1b8",
		"0x19a4c116b8d2d0c8",
		"0x1e376c085141ab53",
		"0x2748774cdf8eeb99",
		"0x34b0bcb5e19b48a8",
		"0x391c0cb3c5c95a63",
		"0x4ed8aa4ae3418acb",
		"0x5b9cca4f7763e373",
		"0x682e6ff3d6b2b8a3",
		"0x748f82ee5defb2fc",
		"0x78a5636f43172f60",
		"0x84c87814a1f0ab72",
		"0x8cc702081a6439ec",
		"0x90befffa23631e28",
		"0xa4506cebde82bde9",
		"0xbef9a3f7b2c67915",
		"0xc67178f2e372532b",
		"0xca273eceea26619c",
		"0xd186b8c721c0c207",
		"0xeada7dd6cde0eb1e",
		"0xf57d4f7fee6ed178",
		"0x06f067aa72176fba",
		"0x0a637dc5a2c898a6",
		"0x113f9804bef90dae",
		"0x1b710b35131c471b",
		"0x28db77f523047d84",
		"0x32caab7b40c72493",
		"0x3c9ebe0a15c9bebc",
		"0x431d67c49c100d4c",
		"0x4cc5d4becb3e42b6",
		"0x597f299cfc657e2a",
		"0x5fcb6fab3ad6faec",
		"0x6c44198c4a475817"
	].map((n) => BigInt(n))))();
	var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
	var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
	var SHA512 = class extends SHA2 {
		constructor() {
			super(128, 64, 16, false);
			this.Ah = 1779033703;
			this.Al = -205731576;
			this.Bh = -1150833019;
			this.Bl = -2067093701;
			this.Ch = 1013904242;
			this.Cl = -23791573;
			this.Dh = -1521486534;
			this.Dl = 1595750129;
			this.Eh = 1359893119;
			this.El = -1377402159;
			this.Fh = -1694144372;
			this.Fl = 725511199;
			this.Gh = 528734635;
			this.Gl = -79577749;
			this.Hh = 1541459225;
			this.Hl = 327033209;
		}
		get() {
			const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
			return [
				Ah,
				Al,
				Bh,
				Bl,
				Ch,
				Cl,
				Dh,
				Dl,
				Eh,
				El,
				Fh,
				Fl,
				Gh,
				Gl,
				Hh,
				Hl
			];
		}
		set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
			this.Ah = Ah | 0;
			this.Al = Al | 0;
			this.Bh = Bh | 0;
			this.Bl = Bl | 0;
			this.Ch = Ch | 0;
			this.Cl = Cl | 0;
			this.Dh = Dh | 0;
			this.Dl = Dl | 0;
			this.Eh = Eh | 0;
			this.El = El | 0;
			this.Fh = Fh | 0;
			this.Fl = Fl | 0;
			this.Gh = Gh | 0;
			this.Gl = Gl | 0;
			this.Hh = Hh | 0;
			this.Hl = Hl | 0;
		}
		process(view, offset) {
			for (let i = 0; i < 16; i++, offset += 4) {
				SHA512_W_H[i] = view.getUint32(offset);
				SHA512_W_L[i] = view.getUint32(offset += 4);
			}
			for (let i = 16; i < 80; i++) {
				const W15h = SHA512_W_H[i - 15] | 0;
				const W15l = SHA512_W_L[i - 15] | 0;
				const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
				const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
				const W2h = SHA512_W_H[i - 2] | 0;
				const W2l = SHA512_W_L[i - 2] | 0;
				const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
				const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
				const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
				const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
				SHA512_W_H[i] = SUMh | 0;
				SHA512_W_L[i] = SUMl | 0;
			}
			let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
			for (let i = 0; i < 80; i++) {
				const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
				const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
				const CHIh = Eh & Fh ^ ~Eh & Gh;
				const CHIl = El & Fl ^ ~El & Gl;
				const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
				const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
				const T1l = T1ll | 0;
				const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
				const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
				const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
				const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
				Hh = Gh | 0;
				Hl = Gl | 0;
				Gh = Fh | 0;
				Gl = Fl | 0;
				Fh = Eh | 0;
				Fl = El | 0;
				({h: Eh, l: El} = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
				Dh = Ch | 0;
				Dl = Cl | 0;
				Ch = Bh | 0;
				Cl = Bl | 0;
				Bh = Ah | 0;
				Bl = Al | 0;
				const All = u64_default.add3L(T1l, sigma0l, MAJl);
				Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
				Al = All | 0;
			}
			({h: Ah, l: Al} = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
			({h: Bh, l: Bl} = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
			({h: Ch, l: Cl} = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
			({h: Dh, l: Dl} = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
			({h: Eh, l: El} = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
			({h: Fh, l: Fl} = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
			({h: Gh, l: Gl} = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
			({h: Hh, l: Hl} = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
			this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
		}
		roundClean() {
			SHA512_W_H.fill(0);
			SHA512_W_L.fill(0);
		}
		destroy() {
			this.buffer.fill(0);
			this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		}
	};
	var sha512$1 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
	var _0n = BigInt(0);
	var _1n = BigInt(1);
	var _2n = BigInt(2);
	function isBytes3(a) {
		return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
	}
	var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
	function bytesToHex(bytes2) {
		if (!isBytes3(bytes2)) throw new Error("Uint8Array expected");
		let hex = "";
		for (let i = 0; i < bytes2.length; i++) hex += hexes[bytes2[i]];
		return hex;
	}
	function hexToNumber(hex) {
		if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
		return BigInt(hex === "" ? "0" : `0x${hex}`);
	}
	var asciis = {
		_0: 48,
		_9: 57,
		_A: 65,
		_F: 70,
		_a: 97,
		_f: 102
	};
	function asciiToBase16(char) {
		if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
		if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
		if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
		return;
	}
	function hexToBytes(hex) {
		if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
		const hl = hex.length;
		const al = hl / 2;
		if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
		const array = new Uint8Array(al);
		for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
			const n1 = asciiToBase16(hex.charCodeAt(hi));
			const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
			if (n1 === void 0 || n2 === void 0) {
				const char = hex[hi] + hex[hi + 1];
				throw new Error("hex string expected, got non-hex character \"" + char + "\" at index " + hi);
			}
			array[ai] = n1 * 16 + n2;
		}
		return array;
	}
	function bytesToNumberBE(bytes2) {
		return hexToNumber(bytesToHex(bytes2));
	}
	function bytesToNumberLE(bytes2) {
		if (!isBytes3(bytes2)) throw new Error("Uint8Array expected");
		return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
	}
	function numberToBytesBE(n, len) {
		return hexToBytes(n.toString(16).padStart(len * 2, "0"));
	}
	function numberToBytesLE(n, len) {
		return numberToBytesBE(n, len).reverse();
	}
	function ensureBytes(title, hex, expectedLength) {
		let res;
		if (typeof hex === "string") try {
			res = hexToBytes(hex);
		} catch (e) {
			throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
		}
else if (isBytes3(hex)) res = Uint8Array.from(hex);
else throw new Error(`${title} must be hex string or Uint8Array`);
		const len = res.length;
		if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
		return res;
	}
	function concatBytes2(...arrays) {
		let sum = 0;
		for (let i = 0; i < arrays.length; i++) {
			const a = arrays[i];
			if (!isBytes3(a)) throw new Error("Uint8Array expected");
			sum += a.length;
		}
		let res = new Uint8Array(sum);
		let pad = 0;
		for (let i = 0; i < arrays.length; i++) {
			const a = arrays[i];
			res.set(a, pad);
			pad += a.length;
		}
		return res;
	}
	var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
	var validatorFns = {
		bigint: (val) => typeof val === "bigint",
		function: (val) => typeof val === "function",
		boolean: (val) => typeof val === "boolean",
		string: (val) => typeof val === "string",
		stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
		isSafeInteger: (val) => Number.isSafeInteger(val),
		array: (val) => Array.isArray(val),
		field: (val, object) => object.Fp.isValid(val),
		hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
	};
	function validateObject(object, validators, optValidators = {}) {
		const checkField = (fieldName, type, isOptional) => {
			const checkVal = validatorFns[type];
			if (typeof checkVal !== "function") throw new Error(`Invalid validator "${type}", expected function`);
			const val = object[fieldName];
			if (isOptional && val === void 0) return;
			if (!checkVal(val, object)) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
		};
		for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);
		for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);
		return object;
	}
	var _0n2 = BigInt(0);
	var _1n2 = BigInt(1);
	var _2n2 = BigInt(2);
	var _3n = BigInt(3);
	var _4n = BigInt(4);
	var _5n = BigInt(5);
	var _8n = BigInt(8);
	var _9n = BigInt(9);
	var _16n = BigInt(16);
	function mod(a, b) {
		const result = a % b;
		return result >= _0n2 ? result : b + result;
	}
	function pow(num, power, modulo) {
		if (modulo <= _0n2 || power < _0n2) throw new Error("Expected power/modulo > 0");
		if (modulo === _1n2) return _0n2;
		let res = _1n2;
		while (power > _0n2) {
			if (power & _1n2) res = res * num % modulo;
			num = num * num % modulo;
			power >>= _1n2;
		}
		return res;
	}
	function pow2(x, power, modulo) {
		let res = x;
		while (power-- > _0n2) {
			res *= res;
			res %= modulo;
		}
		return res;
	}
	function invert(number, modulo) {
		if (number === _0n2 || modulo <= _0n2) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
		let a = mod(number, modulo);
		let b = modulo;
		let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
		while (a !== _0n2) {
			const q = b / a;
			const r = b % a;
			const m = x - u * q;
			const n = y - v * q;
			b = a, a = r, x = u, y = v, u = m, v = n;
		}
		const gcd = b;
		if (gcd !== _1n2) throw new Error("invert: does not exist");
		return mod(x, modulo);
	}
	function tonelliShanks(P) {
		const legendreC = (P - _1n2) / _2n2;
		let Q, S, Z;
		for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++);
		for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++);
		if (S === 1) {
			const p1div4 = (P + _1n2) / _4n;
			return function tonelliFast(Fp2, n) {
				const root = Fp2.pow(n, p1div4);
				if (!Fp2.eql(Fp2.sqr(root), n)) throw new Error("Cannot find square root");
				return root;
			};
		}
		const Q1div2 = (Q + _1n2) / _2n2;
		return function tonelliSlow(Fp2, n) {
			if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE)) throw new Error("Cannot find square root");
			let r = S;
			let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
			let x = Fp2.pow(n, Q1div2);
			let b = Fp2.pow(n, Q);
			while (!Fp2.eql(b, Fp2.ONE)) {
				if (Fp2.eql(b, Fp2.ZERO)) return Fp2.ZERO;
				let m = 1;
				for (let t2 = Fp2.sqr(b); m < r; m++) {
					if (Fp2.eql(t2, Fp2.ONE)) break;
					t2 = Fp2.sqr(t2);
				}
				const ge = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
				g = Fp2.sqr(ge);
				x = Fp2.mul(x, ge);
				b = Fp2.mul(b, g);
				r = m;
			}
			return x;
		};
	}
	function FpSqrt(P) {
		if (P % _4n === _3n) {
			const p1div4 = (P + _1n2) / _4n;
			return function sqrt3mod4(Fp2, n) {
				const root = Fp2.pow(n, p1div4);
				if (!Fp2.eql(Fp2.sqr(root), n)) throw new Error("Cannot find square root");
				return root;
			};
		}
		if (P % _8n === _5n) {
			const c1 = (P - _5n) / _8n;
			return function sqrt5mod8(Fp2, n) {
				const n2 = Fp2.mul(n, _2n2);
				const v = Fp2.pow(n2, c1);
				const nv = Fp2.mul(n, v);
				const i = Fp2.mul(Fp2.mul(nv, _2n2), v);
				const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
				if (!Fp2.eql(Fp2.sqr(root), n)) throw new Error("Cannot find square root");
				return root;
			};
		}
		if (P % _16n === _9n) {}
		return tonelliShanks(P);
	}
	var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
	var FIELD_FIELDS = [
		"create",
		"isValid",
		"is0",
		"neg",
		"inv",
		"sqrt",
		"sqr",
		"eql",
		"add",
		"sub",
		"mul",
		"pow",
		"div",
		"addN",
		"subN",
		"mulN",
		"sqrN"
	];
	function validateField(field) {
		const initial = {
			ORDER: "bigint",
			MASK: "bigint",
			BYTES: "isSafeInteger",
			BITS: "isSafeInteger"
		};
		const opts = FIELD_FIELDS.reduce((map, val) => {
			map[val] = "function";
			return map;
		}, initial);
		return validateObject(field, opts);
	}
	function FpPow(f, num, power) {
		if (power < _0n2) throw new Error("Expected power > 0");
		if (power === _0n2) return f.ONE;
		if (power === _1n2) return num;
		let p = f.ONE;
		let d = num;
		while (power > _0n2) {
			if (power & _1n2) p = f.mul(p, d);
			d = f.sqr(d);
			power >>= _1n2;
		}
		return p;
	}
	function FpInvertBatch(f, nums) {
		const tmp = new Array(nums.length);
		const lastMultiplied = nums.reduce((acc, num, i) => {
			if (f.is0(num)) return acc;
			tmp[i] = acc;
			return f.mul(acc, num);
		}, f.ONE);
		const inverted = f.inv(lastMultiplied);
		nums.reduceRight((acc, num, i) => {
			if (f.is0(num)) return acc;
			tmp[i] = f.mul(acc, tmp[i]);
			return f.mul(acc, num);
		}, inverted);
		return tmp;
	}
	function nLength(n, nBitLength) {
		const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
		const nByteLength = Math.ceil(_nBitLength / 8);
		return {
			nBitLength: _nBitLength,
			nByteLength
		};
	}
	function Field(ORDER, bitLen, isLE2 = false, redef = {}) {
		if (ORDER <= _0n2) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
		const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
		if (BYTES > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
		const sqrtP = FpSqrt(ORDER);
		const f = Object.freeze({
			ORDER,
			BITS,
			BYTES,
			MASK: bitMask(BITS),
			ZERO: _0n2,
			ONE: _1n2,
			create: (num) => mod(num, ORDER),
			isValid: (num) => {
				if (typeof num !== "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
				return _0n2 <= num && num < ORDER;
			},
			is0: (num) => num === _0n2,
			isOdd: (num) => (num & _1n2) === _1n2,
			neg: (num) => mod(-num, ORDER),
			eql: (lhs, rhs) => lhs === rhs,
			sqr: (num) => mod(num * num, ORDER),
			add: (lhs, rhs) => mod(lhs + rhs, ORDER),
			sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
			mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
			pow: (num, power) => FpPow(f, num, power),
			div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
			sqrN: (num) => num * num,
			addN: (lhs, rhs) => lhs + rhs,
			subN: (lhs, rhs) => lhs - rhs,
			mulN: (lhs, rhs) => lhs * rhs,
			inv: (num) => invert(num, ORDER),
			sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
			invertBatch: (lst) => FpInvertBatch(f, lst),
			cmov: (a, b, c) => c ? b : a,
			toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
			fromBytes: (bytes2) => {
				if (bytes2.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
				return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
			}
		});
		return Object.freeze(f);
	}
	function FpSqrtEven(Fp2, elm) {
		if (!Fp2.isOdd) throw new Error(`Field doesn't have isOdd`);
		const root = Fp2.sqrt(elm);
		return Fp2.isOdd(root) ? Fp2.neg(root) : root;
	}
	var _0n3 = BigInt(0);
	var _1n3 = BigInt(1);
	function wNAF(c, bits) {
		const constTimeNegate = (condition, item) => {
			const neg = item.negate();
			return condition ? neg : item;
		};
		const opts = (W) => {
			const windows = Math.ceil(bits / W) + 1;
			const windowSize = 2 ** (W - 1);
			return {
				windows,
				windowSize
			};
		};
		return {
			constTimeNegate,
			unsafeLadder(elm, n) {
				let p = c.ZERO;
				let d = elm;
				while (n > _0n3) {
					if (n & _1n3) p = p.add(d);
					d = d.double();
					n >>= _1n3;
				}
				return p;
			},
			precomputeWindow(elm, W) {
				const { windows, windowSize } = opts(W);
				const points = [];
				let p = elm;
				let base = p;
				for (let window = 0; window < windows; window++) {
					base = p;
					points.push(base);
					for (let i = 1; i < windowSize; i++) {
						base = base.add(p);
						points.push(base);
					}
					p = base.double();
				}
				return points;
			},
			wNAF(W, precomputes, n) {
				const { windows, windowSize } = opts(W);
				let p = c.ZERO;
				let f = c.BASE;
				const mask$1 = BigInt(2 ** W - 1);
				const maxNumber = 2 ** W;
				const shiftBy = BigInt(W);
				for (let window = 0; window < windows; window++) {
					const offset = window * windowSize;
					let wbits = Number(n & mask$1);
					n >>= shiftBy;
					if (wbits > windowSize) {
						wbits -= maxNumber;
						n += _1n3;
					}
					const offset1 = offset;
					const offset2 = offset + Math.abs(wbits) - 1;
					const cond1 = window % 2 !== 0;
					const cond2 = wbits < 0;
					if (wbits === 0) f = f.add(constTimeNegate(cond1, precomputes[offset1]));
else p = p.add(constTimeNegate(cond2, precomputes[offset2]));
				}
				return {
					p,
					f
				};
			},
			wNAFCached(P, precomputesMap, n, transform) {
				const W = P._WINDOW_SIZE || 1;
				let comp = precomputesMap.get(P);
				if (!comp) {
					comp = this.precomputeWindow(P, W);
					if (W !== 1) precomputesMap.set(P, transform(comp));
				}
				return this.wNAF(W, comp, n);
			}
		};
	}
	function validateBasic(curve) {
		validateField(curve.Fp);
		validateObject(curve, {
			n: "bigint",
			h: "bigint",
			Gx: "field",
			Gy: "field"
		}, {
			nBitLength: "isSafeInteger",
			nByteLength: "isSafeInteger"
		});
		return Object.freeze({
			...nLength(curve.n, curve.nBitLength),
			...curve,
			...{ p: curve.Fp.ORDER }
		});
	}
	var _0n4 = BigInt(0);
	var _1n4 = BigInt(1);
	var _2n3 = BigInt(2);
	var _8n2 = BigInt(8);
	var VERIFY_DEFAULT = { zip215: true };
	function validateOpts(curve) {
		const opts = validateBasic(curve);
		validateObject(curve, {
			hash: "function",
			a: "bigint",
			d: "bigint",
			randomBytes: "function"
		}, {
			adjustScalarBytes: "function",
			domain: "function",
			uvRatio: "function",
			mapToCurve: "function"
		});
		return Object.freeze({ ...opts });
	}
	function twistedEdwards(curveDef) {
		const CURVE = validateOpts(curveDef);
		const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
		const MASK = _2n3 << BigInt(nByteLength * 8) - _1n4;
		const modP = Fp2.create;
		const uvRatio2 = CURVE.uvRatio || ((u, v) => {
			try {
				return {
					isValid: true,
					value: Fp2.sqrt(u * Fp2.inv(v))
				};
			} catch (e) {
				return {
					isValid: false,
					value: _0n4
				};
			}
		});
		const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
		const domain = CURVE.domain || ((data, ctx, phflag) => {
			if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
			return data;
		});
		const inBig = (n) => typeof n === "bigint" && _0n4 < n;
		const inRange = (n, max) => inBig(n) && inBig(max) && n < max;
		const in0MaskRange = (n) => n === _0n4 || inRange(n, MASK);
		function assertInRange(n, max) {
			if (inRange(n, max)) return n;
			throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
		}
		function assertGE0(n) {
			return n === _0n4 ? n : assertInRange(n, CURVE_ORDER);
		}
		const pointPrecomputes = /* @__PURE__ */ new Map();
		function isPoint(other) {
			if (!(other instanceof Point)) throw new Error("ExtendedPoint expected");
		}
		class Point {
			constructor(ex, ey, ez, et) {
				this.ex = ex;
				this.ey = ey;
				this.ez = ez;
				this.et = et;
				if (!in0MaskRange(ex)) throw new Error("x required");
				if (!in0MaskRange(ey)) throw new Error("y required");
				if (!in0MaskRange(ez)) throw new Error("z required");
				if (!in0MaskRange(et)) throw new Error("t required");
			}
			get x() {
				return this.toAffine().x;
			}
			get y() {
				return this.toAffine().y;
			}
			static fromAffine(p) {
				if (p instanceof Point) throw new Error("extended point not allowed");
				const { x, y } = p || {};
				if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error("invalid affine point");
				return new Point(x, y, _1n4, modP(x * y));
			}
			static normalizeZ(points) {
				const toInv = Fp2.invertBatch(points.map((p) => p.ez));
				return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
			}
			_setWindowSize(windowSize) {
				this._WINDOW_SIZE = windowSize;
				pointPrecomputes.delete(this);
			}
			assertValidity() {
				const { a, d } = CURVE;
				if (this.is0()) throw new Error("bad point: ZERO");
				const { ex: X, ey: Y, ez: Z, et: T } = this;
				const X2 = modP(X * X);
				const Y2 = modP(Y * Y);
				const Z2 = modP(Z * Z);
				const Z4 = modP(Z2 * Z2);
				const aX2 = modP(X2 * a);
				const left = modP(Z2 * modP(aX2 + Y2));
				const right = modP(Z4 + modP(d * modP(X2 * Y2)));
				if (left !== right) throw new Error("bad point: equation left != right (1)");
				const XY = modP(X * Y);
				const ZT = modP(Z * T);
				if (XY !== ZT) throw new Error("bad point: equation left != right (2)");
			}
			equals(other) {
				isPoint(other);
				const { ex: X1, ey: Y1, ez: Z1 } = this;
				const { ex: X2, ey: Y2, ez: Z2 } = other;
				const X1Z2 = modP(X1 * Z2);
				const X2Z1 = modP(X2 * Z1);
				const Y1Z2 = modP(Y1 * Z2);
				const Y2Z1 = modP(Y2 * Z1);
				return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
			}
			is0() {
				return this.equals(Point.ZERO);
			}
			negate() {
				return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
			}
			double() {
				const { a } = CURVE;
				const { ex: X1, ey: Y1, ez: Z1 } = this;
				const A = modP(X1 * X1);
				const B = modP(Y1 * Y1);
				const C = modP(_2n3 * modP(Z1 * Z1));
				const D = modP(a * A);
				const x1y1 = X1 + Y1;
				const E = modP(modP(x1y1 * x1y1) - A - B);
				const G2 = D + B;
				const F = G2 - C;
				const H = D - B;
				const X3 = modP(E * F);
				const Y3 = modP(G2 * H);
				const T3 = modP(E * H);
				const Z3 = modP(F * G2);
				return new Point(X3, Y3, Z3, T3);
			}
			add(other) {
				isPoint(other);
				const { a, d } = CURVE;
				const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
				const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
				if (a === BigInt(-1)) {
					const A2 = modP((Y1 - X1) * (Y2 + X2));
					const B2 = modP((Y1 + X1) * (Y2 - X2));
					const F2 = modP(B2 - A2);
					if (F2 === _0n4) return this.double();
					const C2 = modP(Z1 * _2n3 * T2);
					const D2 = modP(T1 * _2n3 * Z2);
					const E2 = D2 + C2;
					const G3 = B2 + A2;
					const H2 = D2 - C2;
					const X32 = modP(E2 * F2);
					const Y32 = modP(G3 * H2);
					const T32 = modP(E2 * H2);
					const Z32 = modP(F2 * G3);
					return new Point(X32, Y32, Z32, T32);
				}
				const A = modP(X1 * X2);
				const B = modP(Y1 * Y2);
				const C = modP(T1 * d * T2);
				const D = modP(Z1 * Z2);
				const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
				const F = D - C;
				const G2 = D + C;
				const H = modP(B - a * A);
				const X3 = modP(E * F);
				const Y3 = modP(G2 * H);
				const T3 = modP(E * H);
				const Z3 = modP(F * G2);
				return new Point(X3, Y3, Z3, T3);
			}
			subtract(other) {
				return this.add(other.negate());
			}
			wNAF(n) {
				return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
			}
			multiply(scalar) {
				const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
				return Point.normalizeZ([p, f])[0];
			}
			multiplyUnsafe(scalar) {
				let n = assertGE0(scalar);
				if (n === _0n4) return I;
				if (this.equals(I) || n === _1n4) return this;
				if (this.equals(G)) return this.wNAF(n).p;
				return wnaf.unsafeLadder(this, n);
			}
			isSmallOrder() {
				return this.multiplyUnsafe(cofactor).is0();
			}
			isTorsionFree() {
				return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
			}
			toAffine(iz) {
				const { ex: x, ey: y, ez: z } = this;
				const is0 = this.is0();
				if (iz == null) iz = is0 ? _8n2 : Fp2.inv(z);
				const ax = modP(x * iz);
				const ay = modP(y * iz);
				const zz = modP(z * iz);
				if (is0) return {
					x: _0n4,
					y: _1n4
				};
				if (zz !== _1n4) throw new Error("invZ was invalid");
				return {
					x: ax,
					y: ay
				};
			}
			clearCofactor() {
				const { h: cofactor2 } = CURVE;
				if (cofactor2 === _1n4) return this;
				return this.multiplyUnsafe(cofactor2);
			}
			static fromHex(hex, zip215 = false) {
				const { d, a } = CURVE;
				const len = Fp2.BYTES;
				hex = ensureBytes("pointHex", hex, len);
				const normed = hex.slice();
				const lastByte = hex[len - 1];
				normed[len - 1] = lastByte & -129;
				const y = bytesToNumberLE(normed);
				if (y === _0n4) {} else if (zip215) assertInRange(y, MASK);
else assertInRange(y, Fp2.ORDER);
				const y2 = modP(y * y);
				const u = modP(y2 - _1n4);
				const v = modP(d * y2 - a);
				let { isValid, value: x } = uvRatio2(u, v);
				if (!isValid) throw new Error("Point.fromHex: invalid y coordinate");
				const isXOdd = (x & _1n4) === _1n4;
				const isLastByteOdd = (lastByte & 128) !== 0;
				if (!zip215 && x === _0n4 && isLastByteOdd) throw new Error("Point.fromHex: x=0 and x_0=1");
				if (isLastByteOdd !== isXOdd) x = modP(-x);
				return Point.fromAffine({
					x,
					y
				});
			}
			static fromPrivateKey(privKey) {
				return getExtendedPublicKey(privKey).point;
			}
			toRawBytes() {
				const { x, y } = this.toAffine();
				const bytes2 = numberToBytesLE(y, Fp2.BYTES);
				bytes2[bytes2.length - 1] |= x & _1n4 ? 128 : 0;
				return bytes2;
			}
			toHex() {
				return bytesToHex(this.toRawBytes());
			}
		}
		Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
		Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
		const { BASE: G, ZERO: I } = Point;
		const wnaf = wNAF(Point, nByteLength * 8);
		function modN(a) {
			return mod(a, CURVE_ORDER);
		}
		function modN_LE(hash) {
			return modN(bytesToNumberLE(hash));
		}
		function getExtendedPublicKey(key) {
			const len = nByteLength;
			key = ensureBytes("private key", key, len);
			const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
			const head = adjustScalarBytes2(hashed.slice(0, len));
			const prefix = hashed.slice(len, 2 * len);
			const scalar = modN_LE(head);
			const point = G.multiply(scalar);
			const pointBytes = point.toRawBytes();
			return {
				head,
				prefix,
				scalar,
				point,
				pointBytes
			};
		}
		function getPublicKey(privKey) {
			return getExtendedPublicKey(privKey).pointBytes;
		}
		function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
			const msg = concatBytes2(...msgs);
			return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
		}
		function sign(msg, privKey, options = {}) {
			msg = ensureBytes("message", msg);
			if (prehash) msg = prehash(msg);
			const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
			const r = hashDomainToScalar(options.context, prefix, msg);
			const R = G.multiply(r).toRawBytes();
			const k = hashDomainToScalar(options.context, R, pointBytes, msg);
			const s = modN(r + k * scalar);
			assertGE0(s);
			const res = concatBytes2(R, numberToBytesLE(s, Fp2.BYTES));
			return ensureBytes("result", res, nByteLength * 2);
		}
		const verifyOpts = VERIFY_DEFAULT;
		function verify(sig, msg, publicKey, options = verifyOpts) {
			const { context, zip215 } = options;
			const len = Fp2.BYTES;
			sig = ensureBytes("signature", sig, 2 * len);
			msg = ensureBytes("message", msg);
			if (prehash) msg = prehash(msg);
			const s = bytesToNumberLE(sig.slice(len, 2 * len));
			let A, R, SB;
			try {
				A = Point.fromHex(publicKey, zip215);
				R = Point.fromHex(sig.slice(0, len), zip215);
				SB = G.multiplyUnsafe(s);
			} catch (error) {
				return false;
			}
			if (!zip215 && A.isSmallOrder()) return false;
			const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
			const RkA = R.add(A.multiplyUnsafe(k));
			return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
		}
		G._setWindowSize(8);
		const utils = {
			getExtendedPublicKey,
			randomPrivateKey: () => randomBytes2(Fp2.BYTES),
			precompute(windowSize = 8, point = Point.BASE) {
				point._setWindowSize(windowSize);
				point.multiply(BigInt(3));
				return point;
			}
		};
		return {
			CURVE,
			getPublicKey,
			sign,
			verify,
			ExtendedPoint: Point,
			utils
		};
	}
	var _0n5 = BigInt(0);
	var _1n5 = BigInt(1);
	function validateOpts2(curve) {
		validateObject(curve, { a: "bigint" }, {
			montgomeryBits: "isSafeInteger",
			nByteLength: "isSafeInteger",
			adjustScalarBytes: "function",
			domain: "function",
			powPminus2: "function",
			Gu: "bigint"
		});
		return Object.freeze({ ...curve });
	}
	function montgomery(curveDef) {
		const CURVE = validateOpts2(curveDef);
		const { P } = CURVE;
		const modP = (n) => mod(n, P);
		const montgomeryBits = CURVE.montgomeryBits;
		const montgomeryBytes = Math.ceil(montgomeryBits / 8);
		const fieldLen = CURVE.nByteLength;
		const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
		const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));
		function cswap(swap, x_2, x_3) {
			const dummy = modP(swap * (x_2 - x_3));
			x_2 = modP(x_2 - dummy);
			x_3 = modP(x_3 + dummy);
			return [x_2, x_3];
		}
		function assertFieldElement(n) {
			if (typeof n === "bigint" && _0n5 <= n && n < P) return n;
			throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
		}
		const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
		function montgomeryLadder(pointU, scalar) {
			const u = assertFieldElement(pointU);
			const k = assertFieldElement(scalar);
			const x_1 = u;
			let x_2 = _1n5;
			let z_2 = _0n5;
			let x_3 = u;
			let z_3 = _1n5;
			let swap = _0n5;
			let sw;
			for (let t$1 = BigInt(montgomeryBits - 1); t$1 >= _0n5; t$1--) {
				const k_t = k >> t$1 & _1n5;
				swap ^= k_t;
				sw = cswap(swap, x_2, x_3);
				x_2 = sw[0];
				x_3 = sw[1];
				sw = cswap(swap, z_2, z_3);
				z_2 = sw[0];
				z_3 = sw[1];
				swap = k_t;
				const A = x_2 + z_2;
				const AA = modP(A * A);
				const B = x_2 - z_2;
				const BB = modP(B * B);
				const E = AA - BB;
				const C = x_3 + z_3;
				const D = x_3 - z_3;
				const DA = modP(D * A);
				const CB = modP(C * B);
				const dacb = DA + CB;
				const da_cb = DA - CB;
				x_3 = modP(dacb * dacb);
				z_3 = modP(x_1 * modP(da_cb * da_cb));
				x_2 = modP(AA * BB);
				z_2 = modP(E * (AA + modP(a24 * E)));
			}
			sw = cswap(swap, x_2, x_3);
			x_2 = sw[0];
			x_3 = sw[1];
			sw = cswap(swap, z_2, z_3);
			z_2 = sw[0];
			z_3 = sw[1];
			const z2 = powPminus2(z_2);
			return modP(x_2 * z2);
		}
		function encodeUCoordinate(u) {
			return numberToBytesLE(modP(u), montgomeryBytes);
		}
		function decodeUCoordinate(uEnc) {
			const u = ensureBytes("u coordinate", uEnc, montgomeryBytes);
			if (fieldLen === 32) u[31] &= 127;
			return bytesToNumberLE(u);
		}
		function decodeScalar(n) {
			const bytes2 = ensureBytes("scalar", n);
			const len = bytes2.length;
			if (len !== montgomeryBytes && len !== fieldLen) throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
			return bytesToNumberLE(adjustScalarBytes2(bytes2));
		}
		function scalarMult(scalar, u) {
			const pointU = decodeUCoordinate(u);
			const _scalar = decodeScalar(scalar);
			const pu = montgomeryLadder(pointU, _scalar);
			if (pu === _0n5) throw new Error("Invalid private or public key received");
			return encodeUCoordinate(pu);
		}
		const GuBytes = encodeUCoordinate(CURVE.Gu);
		function scalarMultBase(scalar) {
			return scalarMult(scalar, GuBytes);
		}
		return {
			scalarMult,
			scalarMultBase,
			getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
			getPublicKey: (privateKey) => scalarMultBase(privateKey),
			utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
			GuBytes
		};
	}
	var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
	var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
	var _0n6 = BigInt(0);
	var _1n6 = BigInt(1);
	var _2n4 = BigInt(2);
	var _5n2 = BigInt(5);
	var _10n = BigInt(10);
	var _20n = BigInt(20);
	var _40n = BigInt(40);
	var _80n = BigInt(80);
	function ed25519_pow_2_252_3(x) {
		const P = ED25519_P;
		const x2 = x * x % P;
		const b2 = x2 * x % P;
		const b4 = pow2(b2, _2n4, P) * b2 % P;
		const b5 = pow2(b4, _1n6, P) * x % P;
		const b10 = pow2(b5, _5n2, P) * b5 % P;
		const b20 = pow2(b10, _10n, P) * b10 % P;
		const b40 = pow2(b20, _20n, P) * b20 % P;
		const b80 = pow2(b40, _40n, P) * b40 % P;
		const b160 = pow2(b80, _80n, P) * b80 % P;
		const b240 = pow2(b160, _80n, P) * b80 % P;
		const b250 = pow2(b240, _10n, P) * b10 % P;
		const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
		return {
			pow_p_5_8,
			b2
		};
	}
	function adjustScalarBytes(bytes2) {
		bytes2[0] &= 248;
		bytes2[31] &= 127;
		bytes2[31] |= 64;
		return bytes2;
	}
	function uvRatio(u, v) {
		const P = ED25519_P;
		const v3 = mod(v * v * v, P);
		const v7 = mod(v3 * v3 * v, P);
		const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
		let x = mod(u * v3 * pow3, P);
		const vx2 = mod(v * x * x, P);
		const root1 = x;
		const root2 = mod(x * ED25519_SQRT_M1, P);
		const useRoot1 = vx2 === u;
		const useRoot2 = vx2 === mod(-u, P);
		const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
		if (useRoot1) x = root1;
		if (useRoot2 || noRoot) x = root2;
		if (isNegativeLE(x, P)) x = mod(-x, P);
		return {
			isValid: useRoot1 || useRoot2,
			value: x
		};
	}
	var Fp = Field(ED25519_P, void 0, true);
	var ed25519Defaults = {
		a: BigInt(-1),
		d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
		Fp,
		n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
		h: BigInt(8),
		Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
		Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
		hash: sha512$1,
		randomBytes,
		adjustScalarBytes,
		uvRatio
	};
	function ed25519_domain(data, ctx, phflag) {
		if (ctx.length > 255) throw new Error("Context is too big");
		return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
	}
	var ed25519ctx = /* @__PURE__ */ twistedEdwards({
		...ed25519Defaults,
		domain: ed25519_domain
	});
	var ed25519ph = /* @__PURE__ */ twistedEdwards({
		...ed25519Defaults,
		domain: ed25519_domain,
		prehash: sha512$1
	});
	var x25519$1 = /* @__PURE__ */ (() => montgomery({
		P: ED25519_P,
		a: BigInt(486662),
		montgomeryBits: 255,
		nByteLength: 32,
		Gu: BigInt(9),
		powPminus2: (x) => {
			const P = ED25519_P;
			const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
			return mod(pow2(pow_p_5_8, BigInt(3), P) * b2, P);
		},
		adjustScalarBytes,
		randomBytes
	}))();
	var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
	var ELL2_C2 = Fp.pow(_2n4, ELL2_C1);
	var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
	var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
	var ELL2_J = BigInt(486662);
	var ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664)));
	var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
	var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
	var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
	var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
	var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
	return __toCommonJS(input_exports);
})();
const x25519 = nobleCurves.x25519;

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/Ecc.js
const X25519_N_BYTE_LENGTH = 32;
function generateEccKeyPair() {
	const privateKey = clampPrivateKey(random.generateRandomData(X25519_N_BYTE_LENGTH));
	const publicKey = derivePublicKey(privateKey);
	return {
		privateKey,
		publicKey
	};
}
function eccEncapsulate(senderIdentityPrivateKey, ephemeralPrivateKey, recipientIdentityPublicKey) {
	const ephemeralSharedSecret = generateSharedSecret(ephemeralPrivateKey, recipientIdentityPublicKey);
	const authSharedSecret = generateSharedSecret(senderIdentityPrivateKey, recipientIdentityPublicKey);
	return {
		ephemeralSharedSecret,
		authSharedSecret
	};
}
function eccDecapsulate(senderIdentityPublicKey, ephemeralPublicKey, recipientIdentityPrivateKey) {
	const ephemeralSharedSecret = generateSharedSecret(recipientIdentityPrivateKey, ephemeralPublicKey);
	const authSharedSecret = generateSharedSecret(recipientIdentityPrivateKey, senderIdentityPublicKey);
	return {
		ephemeralSharedSecret,
		authSharedSecret
	};
}
/**
* Diffie-Hellman key exchange; works by combining one party's private key and the other party's public key to form a shared secret between both parties
*/
function generateSharedSecret(localPrivateKey, remotePublicKey) {
	const sharedSecret = x25519.getSharedSecret(localPrivateKey, remotePublicKey);
	if (sharedSecret.every((val) => val === 0)) throw new Error("can't get shared secret: bad key inputs");
	return sharedSecret;
}
function clampPrivateKey(privateKey) {
	privateKey[privateKey.length - 1] = privateKey[privateKey.length - 1] & 127 | 64;
	privateKey[0] &= 248;
	return privateKey;
}
function derivePublicKey(privateKey) {
	return x25519.getPublicKey(privateKey);
}

//#endregion
//#region ../packages/tutanota-crypto/dist/internal/bCrypt.js
function bCrypt() {
	this.GENSALT_DEFAULT_LOG2_ROUNDS = 10;
	this.BCRYPT_SALT_LEN = 16;
	this.BLOWFISH_NUM_ROUNDS = 16;
	this.MAX_EXECUTION_TIME = 100;
	this.P_orig = [
		608135816,
		2242054355,
		320440878,
		57701188,
		2752067618,
		698298832,
		137296536,
		3964562569,
		1160258022,
		953160567,
		3193202383,
		887688300,
		3232508343,
		3380367581,
		1065670069,
		3041331479,
		2450970073,
		2306472731
	];
	this.S_orig = [
		3509652390,
		2564797868,
		805139163,
		3491422135,
		3101798381,
		1780907670,
		3128725573,
		4046225305,
		614570311,
		3012652279,
		134345442,
		2240740374,
		1667834072,
		1901547113,
		2757295779,
		4103290238,
		227898511,
		1921955416,
		1904987480,
		2182433518,
		2069144605,
		3260701109,
		2620446009,
		720527379,
		3318853667,
		677414384,
		3393288472,
		3101374703,
		2390351024,
		1614419982,
		1822297739,
		2954791486,
		3608508353,
		3174124327,
		2024746970,
		1432378464,
		3864339955,
		2857741204,
		1464375394,
		1676153920,
		1439316330,
		715854006,
		3033291828,
		289532110,
		2706671279,
		2087905683,
		3018724369,
		1668267050,
		732546397,
		1947742710,
		3462151702,
		2609353502,
		2950085171,
		1814351708,
		2050118529,
		680887927,
		999245976,
		1800124847,
		3300911131,
		1713906067,
		1641548236,
		4213287313,
		1216130144,
		1575780402,
		4018429277,
		3917837745,
		3693486850,
		3949271944,
		596196993,
		3549867205,
		258830323,
		2213823033,
		772490370,
		2760122372,
		1774776394,
		2652871518,
		566650946,
		4142492826,
		1728879713,
		2882767088,
		1783734482,
		3629395816,
		2517608232,
		2874225571,
		1861159788,
		326777828,
		3124490320,
		2130389656,
		2716951837,
		967770486,
		1724537150,
		2185432712,
		2364442137,
		1164943284,
		2105845187,
		998989502,
		3765401048,
		2244026483,
		1075463327,
		1455516326,
		1322494562,
		910128902,
		469688178,
		1117454909,
		936433444,
		3490320968,
		3675253459,
		1240580251,
		122909385,
		2157517691,
		634681816,
		4142456567,
		3825094682,
		3061402683,
		2540495037,
		79693498,
		3249098678,
		1084186820,
		1583128258,
		426386531,
		1761308591,
		1047286709,
		322548459,
		995290223,
		1845252383,
		2603652396,
		3431023940,
		2942221577,
		3202600964,
		3727903485,
		1712269319,
		422464435,
		3234572375,
		1170764815,
		3523960633,
		3117677531,
		1434042557,
		442511882,
		3600875718,
		1076654713,
		1738483198,
		4213154764,
		2393238008,
		3677496056,
		1014306527,
		4251020053,
		793779912,
		2902807211,
		842905082,
		4246964064,
		1395751752,
		1040244610,
		2656851899,
		3396308128,
		445077038,
		3742853595,
		3577915638,
		679411651,
		2892444358,
		2354009459,
		1767581616,
		3150600392,
		3791627101,
		3102740896,
		284835224,
		4246832056,
		1258075500,
		768725851,
		2589189241,
		3069724005,
		3532540348,
		1274779536,
		3789419226,
		2764799539,
		1660621633,
		3471099624,
		4011903706,
		913787905,
		3497959166,
		737222580,
		2514213453,
		2928710040,
		3937242737,
		1804850592,
		3499020752,
		2949064160,
		2386320175,
		2390070455,
		2415321851,
		4061277028,
		2290661394,
		2416832540,
		1336762016,
		1754252060,
		3520065937,
		3014181293,
		791618072,
		3188594551,
		3933548030,
		2332172193,
		3852520463,
		3043980520,
		413987798,
		3465142937,
		3030929376,
		4245938359,
		2093235073,
		3534596313,
		375366246,
		2157278981,
		2479649556,
		555357303,
		3870105701,
		2008414854,
		3344188149,
		4221384143,
		3956125452,
		2067696032,
		3594591187,
		2921233993,
		2428461,
		544322398,
		577241275,
		1471733935,
		610547355,
		4027169054,
		1432588573,
		1507829418,
		2025931657,
		3646575487,
		545086370,
		48609733,
		2200306550,
		1653985193,
		298326376,
		1316178497,
		3007786442,
		2064951626,
		458293330,
		2589141269,
		3591329599,
		3164325604,
		727753846,
		2179363840,
		146436021,
		1461446943,
		4069977195,
		705550613,
		3059967265,
		3887724982,
		4281599278,
		3313849956,
		1404054877,
		2845806497,
		146425753,
		1854211946,
		1266315497,
		3048417604,
		3681880366,
		3289982499,
		290971e4,
		1235738493,
		2632868024,
		2414719590,
		3970600049,
		1771706367,
		1449415276,
		3266420449,
		422970021,
		1963543593,
		2690192192,
		3826793022,
		1062508698,
		1531092325,
		1804592342,
		2583117782,
		2714934279,
		4024971509,
		1294809318,
		4028980673,
		1289560198,
		2221992742,
		1669523910,
		35572830,
		157838143,
		1052438473,
		1016535060,
		1802137761,
		1753167236,
		1386275462,
		3080475397,
		2857371447,
		1040679964,
		2145300060,
		2390574316,
		1461121720,
		2956646967,
		4031777805,
		4028374788,
		33600511,
		2920084762,
		1018524850,
		629373528,
		3691585981,
		3515945977,
		2091462646,
		2486323059,
		586499841,
		988145025,
		935516892,
		3367335476,
		2599673255,
		2839830854,
		265290510,
		3972581182,
		2759138881,
		3795373465,
		1005194799,
		847297441,
		406762289,
		1314163512,
		1332590856,
		1866599683,
		4127851711,
		750260880,
		613907577,
		1450815602,
		3165620655,
		3734664991,
		3650291728,
		3012275730,
		3704569646,
		1427272223,
		778793252,
		1343938022,
		2676280711,
		2052605720,
		1946737175,
		3164576444,
		3914038668,
		3967478842,
		3682934266,
		1661551462,
		3294938066,
		4011595847,
		840292616,
		3712170807,
		616741398,
		312560963,
		711312465,
		1351876610,
		322626781,
		1910503582,
		271666773,
		2175563734,
		1594956187,
		70604529,
		3617834859,
		1007753275,
		1495573769,
		4069517037,
		2549218298,
		2663038764,
		504708206,
		2263041392,
		3941167025,
		2249088522,
		1514023603,
		1998579484,
		1312622330,
		694541497,
		2582060303,
		2151582166,
		1382467621,
		776784248,
		2618340202,
		3323268794,
		2497899128,
		2784771155,
		503983604,
		4076293799,
		907881277,
		423175695,
		432175456,
		1378068232,
		4145222326,
		3954048622,
		3938656102,
		3820766613,
		2793130115,
		2977904593,
		26017576,
		3274890735,
		3194772133,
		1700274565,
		1756076034,
		4006520079,
		3677328699,
		720338349,
		1533947780,
		354530856,
		688349552,
		3973924725,
		1637815568,
		332179504,
		3949051286,
		53804574,
		2852348879,
		3044236432,
		1282449977,
		3583942155,
		3416972820,
		4006381244,
		1617046695,
		2628476075,
		3002303598,
		1686838959,
		431878346,
		2686675385,
		1700445008,
		1080580658,
		1009431731,
		832498133,
		3223435511,
		2605976345,
		2271191193,
		2516031870,
		1648197032,
		4164389018,
		2548247927,
		300782431,
		375919233,
		238389289,
		3353747414,
		2531188641,
		2019080857,
		1475708069,
		455242339,
		2609103871,
		448939670,
		3451063019,
		1395535956,
		2413381860,
		1841049896,
		1491858159,
		885456874,
		4264095073,
		4001119347,
		1565136089,
		3898914787,
		1108368660,
		540939232,
		1173283510,
		2745871338,
		3681308437,
		4207628240,
		3343053890,
		4016749493,
		1699691293,
		1103962373,
		3625875870,
		2256883143,
		3830138730,
		1031889488,
		3479347698,
		1535977030,
		4236805024,
		3251091107,
		2132092099,
		1774941330,
		1199868427,
		1452454533,
		157007616,
		2904115357,
		342012276,
		595725824,
		1480756522,
		206960106,
		497939518,
		591360097,
		863170706,
		2375253569,
		3596610801,
		1814182875,
		2094937945,
		3421402208,
		1082520231,
		3463918190,
		2785509508,
		435703966,
		3908032597,
		1641649973,
		2842273706,
		3305899714,
		1510255612,
		2148256476,
		2655287854,
		3276092548,
		4258621189,
		236887753,
		3681803219,
		274041037,
		1734335097,
		3815195456,
		3317970021,
		1899903192,
		1026095262,
		4050517792,
		356393447,
		2410691914,
		3873677099,
		3682840055,
		3913112168,
		2491498743,
		4132185628,
		2489919796,
		1091903735,
		1979897079,
		3170134830,
		3567386728,
		3557303409,
		857797738,
		1136121015,
		1342202287,
		507115054,
		2535736646,
		337727348,
		3213592640,
		1301675037,
		2528481711,
		1895095763,
		1721773893,
		3216771564,
		62756741,
		2142006736,
		835421444,
		2531993523,
		1442658625,
		3659876326,
		2882144922,
		676362277,
		1392781812,
		170690266,
		3921047035,
		1759253602,
		3611846912,
		1745797284,
		664899054,
		1329594018,
		3901205900,
		3045908486,
		2062866102,
		2865634940,
		3543621612,
		3464012697,
		1080764994,
		553557557,
		3656615353,
		3996768171,
		991055499,
		499776247,
		1265440854,
		648242737,
		3940784050,
		980351604,
		3713745714,
		1749149687,
		3396870395,
		4211799374,
		3640570775,
		1161844396,
		3125318951,
		1431517754,
		545492359,
		4268468663,
		3499529547,
		1437099964,
		2702547544,
		3433638243,
		2581715763,
		2787789398,
		1060185593,
		1593081372,
		2418618748,
		4260947970,
		69676912,
		2159744348,
		86519011,
		2512459080,
		3838209314,
		1220612927,
		3339683548,
		133810670,
		1090789135,
		1078426020,
		1569222167,
		845107691,
		3583754449,
		4072456591,
		1091646820,
		628848692,
		1613405280,
		3757631651,
		526609435,
		236106946,
		48312990,
		2942717905,
		3402727701,
		1797494240,
		859738849,
		992217954,
		4005476642,
		2243076622,
		3870952857,
		3732016268,
		765654824,
		3490871365,
		2511836413,
		1685915746,
		3888969200,
		1414112111,
		2273134842,
		3281911079,
		4080962846,
		172450625,
		2569994100,
		980381355,
		4109958455,
		2819808352,
		2716589560,
		2568741196,
		3681446669,
		3329971472,
		1835478071,
		660984891,
		3704678404,
		4045999559,
		3422617507,
		3040415634,
		1762651403,
		1719377915,
		3470491036,
		2693910283,
		3642056355,
		3138596744,
		1364962596,
		2073328063,
		1983633131,
		926494387,
		3423689081,
		2150032023,
		4096667949,
		1749200295,
		3328846651,
		309677260,
		2016342300,
		1779581495,
		3079819751,
		111262694,
		1274766160,
		443224088,
		298511866,
		1025883608,
		3806446537,
		1145181785,
		168956806,
		3641502830,
		3584813610,
		1689216846,
		3666258015,
		3200248200,
		1692713982,
		2646376535,
		4042768518,
		1618508792,
		1610833997,
		3523052358,
		4130873264,
		2001055236,
		3610705100,
		2202168115,
		4028541809,
		2961195399,
		1006657119,
		2006996926,
		3186142756,
		1430667929,
		3210227297,
		1314452623,
		4074634658,
		4101304120,
		2273951170,
		1399257539,
		3367210612,
		3027628629,
		1190975929,
		2062231137,
		2333990788,
		2221543033,
		2438960610,
		1181637006,
		548689776,
		2362791313,
		3372408396,
		3104550113,
		3145860560,
		296247880,
		1970579870,
		3078560182,
		3769228297,
		1714227617,
		3291629107,
		3898220290,
		166772364,
		1251581989,
		493813264,
		448347421,
		195405023,
		2709975567,
		677966185,
		3703036547,
		1463355134,
		2715995803,
		1338867538,
		1343315457,
		2802222074,
		2684532164,
		233230375,
		2599980071,
		2000651841,
		3277868038,
		1638401717,
		4028070440,
		3237316320,
		6314154,
		819756386,
		300326615,
		590932579,
		1405279636,
		3267499572,
		3150704214,
		2428286686,
		3959192993,
		3461946742,
		1862657033,
		1266418056,
		963775037,
		2089974820,
		2263052895,
		1917689273,
		448879540,
		3550394620,
		3981727096,
		150775221,
		3627908307,
		1303187396,
		508620638,
		2975983352,
		2726630617,
		1817252668,
		1876281319,
		1457606340,
		908771278,
		3720792119,
		3617206836,
		2455994898,
		1729034894,
		1080033504,
		976866871,
		3556439503,
		2881648439,
		1522871579,
		1555064734,
		1336096578,
		3548522304,
		2579274686,
		3574697629,
		3205460757,
		3593280638,
		3338716283,
		3079412587,
		564236357,
		2993598910,
		1781952180,
		1464380207,
		3163844217,
		3332601554,
		1699332808,
		1393555694,
		1183702653,
		3581086237,
		1288719814,
		691649499,
		2847557200,
		2895455976,
		3193889540,
		2717570544,
		1781354906,
		1676643554,
		2592534050,
		3230253752,
		1126444790,
		2770207658,
		2633158820,
		2210423226,
		2615765581,
		2414155088,
		3127139286,
		673620729,
		2805611233,
		1269405062,
		4015350505,
		3341807571,
		4149409754,
		1057255273,
		2012875353,
		2162469141,
		2276492801,
		2601117357,
		993977747,
		3918593370,
		2654263191,
		753973209,
		36408145,
		2530585658,
		25011837,
		3520020182,
		2088578344,
		530523599,
		2918365339,
		1524020338,
		1518925132,
		3760827505,
		3759777254,
		1202760957,
		3985898139,
		3906192525,
		674977740,
		4174734889,
		2031300136,
		2019492241,
		3983892565,
		4153806404,
		3822280332,
		352677332,
		2297720250,
		60907813,
		90501309,
		3286998549,
		1016092578,
		2535922412,
		2839152426,
		457141659,
		509813237,
		4120667899,
		652014361,
		1966332200,
		2975202805,
		55981186,
		2327461051,
		676427537,
		3255491064,
		2882294119,
		3433927263,
		1307055953,
		942726286,
		933058658,
		2468411793,
		3933900994,
		4215176142,
		1361170020,
		2001714738,
		2830558078,
		3274259782,
		1222529897,
		1679025792,
		2729314320,
		3714953764,
		1770335741,
		151462246,
		3013232138,
		1682292957,
		1483529935,
		471910574,
		1539241949,
		458788160,
		3436315007,
		1807016891,
		3718408830,
		978976581,
		1043663428,
		3165965781,
		1927990952,
		4200891579,
		2372276910,
		3208408903,
		3533431907,
		1412390302,
		2931980059,
		4132332400,
		1947078029,
		3881505623,
		4168226417,
		2941484381,
		1077988104,
		1320477388,
		886195818,
		18198404,
		3786409e3,
		2509781533,
		112762804,
		3463356488,
		1866414978,
		891333506,
		18488651,
		661792760,
		1628790961,
		3885187036,
		3141171499,
		876946877,
		2693282273,
		1372485963,
		791857591,
		2686433993,
		3759982718,
		3167212022,
		3472953795,
		2716379847,
		445679433,
		3561995674,
		3504004811,
		3574258232,
		54117162,
		3331405415,
		2381918588,
		3769707343,
		4154350007,
		1140177722,
		4074052095,
		668550556,
		3214352940,
		367459370,
		261225585,
		2610173221,
		4209349473,
		3468074219,
		3265815641,
		314222801,
		3066103646,
		3808782860,
		282218597,
		3406013506,
		3773591054,
		379116347,
		1285071038,
		846784868,
		2669647154,
		3771962079,
		3550491691,
		2305946142,
		453669953,
		1268987020,
		3317592352,
		3279303384,
		3744833421,
		2610507566,
		3859509063,
		266596637,
		3847019092,
		517658769,
		3462560207,
		3443424879,
		370717030,
		4247526661,
		2224018117,
		4143653529,
		4112773975,
		2788324899,
		2477274417,
		1456262402,
		2901442914,
		1517677493,
		1846949527,
		2295493580,
		3734397586,
		2176403920,
		1280348187,
		1908823572,
		3871786941,
		846861322,
		1172426758,
		3287448474,
		3383383037,
		1655181056,
		3139813346,
		901632758,
		1897031941,
		2986607138,
		3066810236,
		3447102507,
		1393639104,
		373351379,
		950779232,
		625454576,
		3124240540,
		4148612726,
		2007998917,
		544563296,
		2244738638,
		2330496472,
		2058025392,
		1291430526,
		424198748,
		50039436,
		29584100,
		3605783033,
		2429876329,
		2791104160,
		1057563949,
		3255363231,
		3075367218,
		3463963227,
		1469046755,
		985887462
	];
	this.bf_crypt_ciphertext = [
		1332899944,
		1700884034,
		1701343084,
		1684370003,
		1668446532,
		1869963892
	];
	this.base64_code = [
		".",
		"/",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F",
		"G",
		"H",
		"I",
		"J",
		"K",
		"L",
		"M",
		"N",
		"O",
		"P",
		"Q",
		"R",
		"S",
		"T",
		"U",
		"V",
		"W",
		"X",
		"Y",
		"Z",
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"g",
		"h",
		"i",
		"j",
		"k",
		"l",
		"m",
		"n",
		"o",
		"p",
		"q",
		"r",
		"s",
		"t",
		"u",
		"v",
		"w",
		"x",
		"y",
		"z",
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9"
	];
	this.index_64 = [
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		0,
		1,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		62,
		63,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		20,
		21,
		22,
		23,
		24,
		25,
		26,
		27,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		28,
		29,
		30,
		31,
		32,
		33,
		34,
		35,
		36,
		37,
		38,
		39,
		40,
		41,
		42,
		43,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51,
		52,
		53,
		-1,
		-1,
		-1,
		-1,
		-1
	];
	this.P;
	this.S;
	this.lr;
	this.offp;
}
bCrypt.prototype.getByte = function(c) {
	var ret = 0;
	try {
		var b = c.charCodeAt(0);
	} catch (err) {
		b = c;
	}
	if (b > 127) return -128 + b % 128;
else return b;
};
bCrypt.prototype.encode_base64 = function(d, len) {
	var off = 0;
	var rs = [];
	var c1;
	var c2;
	if (len <= 0 || len > d.length) throw "Invalid len";
	while (off < len) {
		c1 = d[off++] & 255;
		rs.push(this.base64_code[c1 >> 2 & 63]);
		c1 = (c1 & 3) << 4;
		if (off >= len) {
			rs.push(this.base64_code[c1 & 63]);
			break;
		}
		c2 = d[off++] & 255;
		c1 |= c2 >> 4 & 15;
		rs.push(this.base64_code[c1 & 63]);
		c1 = (c2 & 15) << 2;
		if (off >= len) {
			rs.push(this.base64_code[c1 & 63]);
			break;
		}
		c2 = d[off++] & 255;
		c1 |= c2 >> 6 & 3;
		rs.push(this.base64_code[c1 & 63]);
		rs.push(this.base64_code[c2 & 63]);
	}
	return rs.join("");
};
bCrypt.prototype.char64 = function(x) {
	var code = x.charCodeAt(0);
	if (code < 0 || code > this.index_64.length) return -1;
	return this.index_64[code];
};
bCrypt.prototype.decode_base64 = function(s, maxolen) {
	var off = 0;
	var slen = s.length;
	var olen = 0;
	var rs = [];
	var c1, c2, c3, c4, o;
	if (maxolen <= 0) throw "Invalid maxolen";
	while (off < slen - 1 && olen < maxolen) {
		c1 = this.char64(s.charAt(off++));
		c2 = this.char64(s.charAt(off++));
		if (c1 == -1 || c2 == -1) break;
		o = this.getByte(c1 << 2);
		o |= (c2 & 48) >> 4;
		rs.push(String.fromCharCode(o));
		if (++olen >= maxolen || off >= slen) break;
		c3 = this.char64(s.charAt(off++));
		if (c3 == -1) break;
		o = this.getByte((c2 & 15) << 4);
		o |= (c3 & 60) >> 2;
		rs.push(String.fromCharCode(o));
		if (++olen >= maxolen || off >= slen) break;
		c4 = this.char64(s.charAt(off++));
		o = this.getByte((c3 & 3) << 6);
		o |= c4;
		rs.push(String.fromCharCode(o));
		++olen;
	}
	var ret = [];
	for (off = 0; off < olen; off++) ret.push(this.getByte(rs[off]));
	return ret;
};
bCrypt.prototype.encipher = function(lr, off) {
	var i;
	var n;
	var l = lr[off];
	var r = lr[off + 1];
	l ^= this.P[0];
	for (i = 0; i <= this.BLOWFISH_NUM_ROUNDS - 2;) {
		n = this.S[l >> 24 & 255];
		n += this.S[256 | l >> 16 & 255];
		n ^= this.S[512 | l >> 8 & 255];
		n += this.S[768 | l & 255];
		r ^= n ^ this.P[++i];
		n = this.S[r >> 24 & 255];
		n += this.S[256 | r >> 16 & 255];
		n ^= this.S[512 | r >> 8 & 255];
		n += this.S[768 | r & 255];
		l ^= n ^ this.P[++i];
	}
	lr[off] = r ^ this.P[this.BLOWFISH_NUM_ROUNDS + 1];
	lr[off + 1] = l;
};
bCrypt.prototype.streamtoword = function(data, offp) {
	var i;
	var word = 0;
	var off = offp;
	for (i = 0; i < 4; i++) {
		word = word << 8 | data[off] & 255;
		off = (off + 1) % data.length;
	}
	this.offp = off;
	return word;
};
bCrypt.prototype.init_key = function() {
	this.P = this.P_orig.slice();
	this.S = this.S_orig.slice();
};
bCrypt.prototype.key = function(key) {
	var i;
	this.offp = 0;
	var lr = new Array(0, 0);
	var plen = this.P.length;
	var slen = this.S.length;
	for (i = 0; i < plen; i++) this.P[i] = this.P[i] ^ this.streamtoword(key, this.offp);
	for (i = 0; i < plen; i += 2) {
		this.encipher(lr, 0);
		this.P[i] = lr[0];
		this.P[i + 1] = lr[1];
	}
	for (i = 0; i < slen; i += 2) {
		this.encipher(lr, 0);
		this.S[i] = lr[0];
		this.S[i + 1] = lr[1];
	}
};
bCrypt.prototype.ekskey = function(data, key) {
	var i;
	this.offp = 0;
	var lr = new Array(0, 0);
	var plen = this.P.length;
	var slen = this.S.length;
	for (i = 0; i < plen; i++) this.P[i] = this.P[i] ^ this.streamtoword(key, this.offp);
	this.offp = 0;
	for (i = 0; i < plen; i += 2) {
		lr[0] ^= this.streamtoword(data, this.offp);
		lr[1] ^= this.streamtoword(data, this.offp);
		this.encipher(lr, 0);
		this.P[i] = lr[0];
		this.P[i + 1] = lr[1];
	}
	for (i = 0; i < slen; i += 2) {
		lr[0] ^= this.streamtoword(data, this.offp);
		lr[1] ^= this.streamtoword(data, this.offp);
		this.encipher(lr, 0);
		this.S[i] = lr[0];
		this.S[i + 1] = lr[1];
	}
};
bCrypt.prototype.crypt_raw = function(password, salt, log_rounds) {
	var rounds;
	var j;
	var cdata = this.bf_crypt_ciphertext.slice();
	var clen = cdata.length;
	var one_percent;
	if (log_rounds < 4 || log_rounds > 31) throw "Bad number of rounds";
	if (salt.length != this.BCRYPT_SALT_LEN) throw "Bad _salt length";
	rounds = 1 << log_rounds;
	one_percent = Math.floor(rounds / 100) + 1;
	this.init_key();
	this.ekskey(salt, password);
	var obj = this;
	var i = 0;
	var roundFunction = null;
	roundFunction = function() {
		if (i < rounds) {
			var start = new Date();
			for (; i < rounds;) {
				i = i + 1;
				obj.key(password);
				obj.key(salt);
			}
			return roundFunction();
		} else {
			for (i = 0; i < 64; i++) for (j = 0; j < clen >> 1; j++) obj.encipher(cdata, j << 1);
			var ret = [];
			for (i = 0; i < clen; i++) {
				ret.push(obj.getByte(cdata[i] >> 24 & 255));
				ret.push(obj.getByte(cdata[i] >> 16 & 255));
				ret.push(obj.getByte(cdata[i] >> 8 & 255));
				ret.push(obj.getByte(cdata[i] & 255));
			}
			return ret;
		}
	};
	return roundFunction();
};
var bCrypt_default = bCrypt;

//#endregion
//#region ../packages/tutanota-crypto/dist/misc/Constants.js
var KeyLength;
(function(KeyLength$1) {
	KeyLength$1["b128"] = "128";
	KeyLength$1["b256"] = "256";
})(KeyLength || (KeyLength = {}));

//#endregion
//#region ../packages/tutanota-crypto/dist/hashes/Bcrypt.js
const logRounds = 8;
function generateRandomSalt() {
	return random.generateRandomData(16);
}
function generateKeyFromPassphrase(passphrase, salt, keyLengthType) {
	let passphraseBytes = sha256Hash(stringToUtf8Uint8Array(passphrase));
	let bytes = crypt_raw(passphraseBytes, salt, logRounds);
	if (keyLengthType === KeyLength.b128) return uint8ArrayToBitArray(bytes.slice(0, 16));
else return uint8ArrayToBitArray(sha256Hash(bytes));
}
function crypt_raw(passphraseBytes, saltBytes, logRounds$1) {
	try {
		return _signedBytesToUint8Array(new bCrypt_default().crypt_raw(_uint8ArrayToSignedBytes(passphraseBytes), _uint8ArrayToSignedBytes(saltBytes), logRounds$1));
	} catch (e) {
		const error = e;
		throw new CryptoError(error.message, error);
	}
}
/**
* Converts an array of signed byte values (-128 to 127) to an Uint8Array (values 0 to 255).
* @param signedBytes The signed byte values.
* @return The unsigned byte values.
*/
function _signedBytesToUint8Array(signedBytes) {
	return new Uint8Array(new Int8Array(signedBytes));
}
/**
* Converts an uint8Array (value 0 to 255) to an Array with unsigned bytes (-128 to 127).
* @param unsignedBytes The unsigned byte values.
* @return The signed byte values.
*/
function _uint8ArrayToSignedBytes(unsignedBytes) {
	return Array.from(new Uint8Array(new Int8Array(unsignedBytes)));
}

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/Liboqs/Kyber.js
const KYBER_RAND_AMOUNT_OF_ENTROPY = 64;
const KYBER_ALGORITHM = "Kyber1024";
const KYBER_K = 4;
const KYBER_POLYBYTES = 384;
const KYBER_POLYVECBYTES = KYBER_K * KYBER_POLYBYTES;
const KYBER_SYMBYTES = 32;
const OQS_KEM_kyber_1024_length_public_key = 1568;
const OQS_KEM_kyber_1024_length_secret_key = 3168;
const OQS_KEM_kyber_1024_length_ciphertext = 1568;
const OQS_KEM_kyber_1024_length_shared_secret = 32;
function generateKeyPair(kyberWasm, randomizer) {
	const OQS_KEM = createKem(kyberWasm);
	try {
		fillEntropyPool(kyberWasm, randomizer);
		const publicKey = new Uint8Array(OQS_KEM_kyber_1024_length_public_key);
		const privateKey = new Uint8Array(OQS_KEM_kyber_1024_length_secret_key);
		const result = callWebAssemblyFunctionWithArguments(kyberWasm.OQS_KEM_keypair, kyberWasm, OQS_KEM, mutableSecureFree(publicKey), mutableSecureFree(privateKey));
		if (result != 0) throw new Error(`OQS_KEM_keypair returned ${result}`);
		return {
			publicKey: { raw: publicKey },
			privateKey: { raw: privateKey }
		};
	} finally {
		freeKem(kyberWasm, OQS_KEM);
	}
}
function encapsulate(kyberWasm, publicKey, randomizer) {
	if (publicKey.raw.length != OQS_KEM_kyber_1024_length_public_key) throw new CryptoError(`Invalid public key length; expected ${OQS_KEM_kyber_1024_length_public_key}, got ${publicKey.raw.length}`);
	const OQS_KEM = createKem(kyberWasm);
	try {
		fillEntropyPool(kyberWasm, randomizer);
		const ciphertext = new Uint8Array(OQS_KEM_kyber_1024_length_ciphertext);
		const sharedSecret = new Uint8Array(OQS_KEM_kyber_1024_length_shared_secret);
		const result = callWebAssemblyFunctionWithArguments(kyberWasm.OQS_KEM_encaps, kyberWasm, OQS_KEM, mutableSecureFree(ciphertext), mutableSecureFree(sharedSecret), mutableSecureFree(publicKey.raw));
		if (result != 0) throw new Error(`OQS_KEM_encaps returned ${result}`);
		return {
			ciphertext,
			sharedSecret
		};
	} finally {
		freeKem(kyberWasm, OQS_KEM);
	}
}
function decapsulate(kyberWasm, privateKey, ciphertext) {
	if (privateKey.raw.length != OQS_KEM_kyber_1024_length_secret_key) throw new CryptoError(`Invalid private key length; expected ${OQS_KEM_kyber_1024_length_secret_key}, got ${privateKey.raw.length}`);
	if (ciphertext.length != OQS_KEM_kyber_1024_length_ciphertext) throw new CryptoError(`Invalid ciphertext length; expected ${OQS_KEM_kyber_1024_length_ciphertext}, got ${ciphertext.length}`);
	const OQS_KEM = createKem(kyberWasm);
	try {
		const sharedSecret = new Uint8Array(OQS_KEM_kyber_1024_length_shared_secret);
		const result = callWebAssemblyFunctionWithArguments(kyberWasm.OQS_KEM_decaps, kyberWasm, OQS_KEM, mutableSecureFree(sharedSecret), secureFree(ciphertext), secureFree(privateKey.raw));
		if (result != 0) throw new Error(`OQS_KEM_decaps returned ${result}`);
		return sharedSecret;
	} finally {
		freeKem(kyberWasm, OQS_KEM);
	}
}
function freeKem(kyberWasm, OQS_KEM) {
	callWebAssemblyFunctionWithArguments(kyberWasm.OQS_KEM_free, kyberWasm, OQS_KEM);
}
function createKem(kyberWasm) {
	return callWebAssemblyFunctionWithArguments(kyberWasm.OQS_KEM_new, kyberWasm, KYBER_ALGORITHM);
}
function fillEntropyPool(exports, randomizer) {
	const entropyAmount = randomizer.generateRandomData(KYBER_RAND_AMOUNT_OF_ENTROPY);
	const remaining = callWebAssemblyFunctionWithArguments(exports.TUTA_inject_entropy, exports, entropyAmount, entropyAmount.length);
	if (remaining < 0) console.warn(`tried to copy too much entropy: overflowed with ${-remaining} bytes; fix RAND_AMOUNT_OF_ENTROPY/generateRandomData to silence this`);
}

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/Liboqs/KyberKeyPair.js
function kyberPrivateKeyToBytes(key) {
	const keyBytes = key.raw;
	const s = keyBytes.slice(0, KYBER_POLYVECBYTES);
	const t$1 = keyBytes.slice(KYBER_POLYVECBYTES, 2 * KYBER_POLYVECBYTES);
	const rho = keyBytes.slice(2 * KYBER_POLYVECBYTES, 2 * KYBER_POLYVECBYTES + KYBER_SYMBYTES);
	const hpk = keyBytes.slice(2 * KYBER_POLYVECBYTES + KYBER_SYMBYTES, 2 * KYBER_POLYVECBYTES + 2 * KYBER_SYMBYTES);
	const nonce = keyBytes.slice(2 * KYBER_POLYVECBYTES + 2 * KYBER_SYMBYTES, 2 * KYBER_POLYVECBYTES + 3 * KYBER_SYMBYTES);
	return byteArraysToBytes([
		s,
		hpk,
		nonce,
		t$1,
		rho
	]);
}
function kyberPublicKeyToBytes(key) {
	const keyBytes = key.raw;
	const t$1 = keyBytes.slice(0, KYBER_POLYVECBYTES);
	const rho = keyBytes.slice(KYBER_POLYVECBYTES, KYBER_POLYVECBYTES + KYBER_SYMBYTES);
	return byteArraysToBytes([t$1, rho]);
}
function bytesToKyberPublicKey(encodedPublicKey) {
	const keyComponents = bytesToByteArrays(encodedPublicKey, 2);
	return { raw: concat(...keyComponents) };
}
function bytesToKyberPrivateKey(encodedPrivateKey) {
	const keyComponents = bytesToByteArrays(encodedPrivateKey, 5);
	const s = keyComponents[0];
	const hpk = keyComponents[1];
	const nonce = keyComponents[2];
	const t$1 = keyComponents[3];
	const rho = keyComponents[4];
	return { raw: concat(s, t$1, rho, hpk, nonce) };
}

//#endregion
//#region ../packages/tutanota-crypto/dist/hashes/Argon2id/Argon2id.js
const ARGON2ID_ITERATIONS = 4;
const ARGON2ID_MEMORY_IN_KiB = 32768;
const ARGON2ID_PARALLELISM = 1;
const ARGON2ID_KEY_LENGTH = 32;
async function generateKeyFromPassphrase$1(argon2, pass, salt) {
	const hash = await argon2idHashRaw(argon2, ARGON2ID_ITERATIONS, ARGON2ID_MEMORY_IN_KiB, ARGON2ID_PARALLELISM, stringToUtf8Uint8Array(pass), salt, ARGON2ID_KEY_LENGTH);
	return uint8ArrayToBitArray(hash);
}
async function argon2idHashRaw(argon2, timeCost, memoryCost, parallelism, password, salt, hashLength) {
	const hash = new Uint8Array(hashLength);
	const result = callWebAssemblyFunctionWithArguments(argon2.argon2id_hash_raw, argon2, timeCost, memoryCost, parallelism, secureFree(password), password.length, salt, salt.length, mutableSecureFree(hash), hash.length);
	if (result !== 0) throw new Error(`argon2id_hash_raw returned ${result}`);
	return hash;
}

//#endregion
//#region ../packages/tutanota-crypto/dist/random/SecureRandom.js
var SecureRandom = class {
	/**
	* Only this function is used by jsbn for getting random bytes. Each byte is a value between 0 and 255.
	* @param array An array to fill with random bytes. The length of the array defines the number of bytes to create.
	*/
	nextBytes(array) {
		let bytes = random.generateRandomData(array.length);
		for (let i = 0; i < array.length; i++) array[i] = bytes[i];
	}
};

//#endregion
//#region ../packages/tutanota-crypto/dist/internal/crypto-jsbn-2012-08-09_1.js
var dbits;
var canary = 0xdeadbeefcafe;
var j_lm = (canary & 16777215) == 15715070;
function BigInteger(a, b, c) {
	if (a != null) if ("number" == typeof a) this.fromNumber(a, b, c);
else if (b == null && "string" != typeof a) this.fromString(a, 256);
else this.fromString(a, b);
}
function nbi() {
	return new BigInteger(null);
}
function am1(i, x, w, j, c, n) {
	while (--n >= 0) {
		var v = x * this[i++] + w[j] + c;
		c = Math.floor(v / 67108864);
		w[j++] = v & 67108863;
	}
	return c;
}
function am2(i, x, w, j, c, n) {
	var xl = x & 32767, xh = x >> 15;
	while (--n >= 0) {
		var l = this[i] & 32767;
		var h = this[i++] >> 15;
		var m = xh * l + h * xl;
		l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
		c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
		w[j++] = l & 1073741823;
	}
	return c;
}
function am3(i, x, w, j, c, n) {
	var xl = x & 16383, xh = x >> 14;
	while (--n >= 0) {
		var l = this[i] & 16383;
		var h = this[i++] >> 14;
		var m = xh * l + h * xl;
		l = xl * l + ((m & 16383) << 14) + w[j] + c;
		c = (l >> 28) + (m >> 14) + xh * h;
		w[j++] = l & 268435455;
	}
	return c;
}
if (j_lm && typeof navigator === "object" && navigator.appName == "Microsoft Internet Explorer") {
	BigInteger.prototype.am = am2;
	dbits = 30;
} else if (j_lm && typeof navigator === "object" && navigator.appName != "Netscape") {
	BigInteger.prototype.am = am1;
	dbits = 26;
} else {
	BigInteger.prototype.am = am3;
	dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
function int2char(n) {
	return BI_RM.charAt(n);
}
function intAt(s, i) {
	var c = BI_RC[s.charCodeAt(i)];
	return c == null ? -1 : c;
}
function bnpCopyTo(r) {
	for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
	r.t = this.t;
	r.s = this.s;
}
function bnpFromInt(x) {
	this.t = 1;
	this.s = x < 0 ? -1 : 0;
	if (x > 0) this[0] = x;
else if (x < -1) this[0] = x + DV;
else this.t = 0;
}
function nbv(i) {
	var r = nbi();
	r.fromInt(i);
	return r;
}
function bnpFromString(s, b) {
	var k;
	if (b == 16) k = 4;
else if (b == 8) k = 3;
else if (b == 256) k = 8;
else if (b == 2) k = 1;
else if (b == 32) k = 5;
else if (b == 4) k = 2;
else {
		this.fromRadix(s, b);
		return;
	}
	this.t = 0;
	this.s = 0;
	var i = s.length, mi = false, sh = 0;
	while (--i >= 0) {
		var x = k == 8 ? s[i] & 255 : intAt(s, i);
		if (x < 0) {
			if (s.charAt(i) == "-") mi = true;
			continue;
		}
		mi = false;
		if (sh == 0) this[this.t++] = x;
else if (sh + k > this.DB) {
			this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
			this[this.t++] = x >> this.DB - sh;
		} else this[this.t - 1] |= x << sh;
		sh += k;
		if (sh >= this.DB) sh -= this.DB;
	}
	if (k == 8 && (s[0] & 128) != 0) {
		this.s = -1;
		if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
	}
	this.clamp();
	if (mi) BigInteger.ZERO.subTo(this, this);
}
function bnpClamp() {
	var c = this.s & this.DM;
	while (this.t > 0 && this[this.t - 1] == c) --this.t;
}
function bnToString(b) {
	if (this.s < 0) return "-" + this.negate().toString(b);
	var k;
	if (b == 16) k = 4;
else if (b == 8) k = 3;
else if (b == 2) k = 1;
else if (b == 32) k = 5;
else if (b == 4) k = 2;
else return this.toRadix(b);
	var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
	var p = this.DB - i * this.DB % k;
	if (i-- > 0) {
		if (p < this.DB && (d = this[i] >> p) > 0) {
			m = true;
			r = int2char(d);
		}
		while (i >= 0) {
			if (p < k) {
				d = (this[i] & (1 << p) - 1) << k - p;
				d |= this[--i] >> (p += this.DB - k);
			} else {
				d = this[i] >> (p -= k) & km;
				if (p <= 0) {
					p += this.DB;
					--i;
				}
			}
			if (d > 0) m = true;
			if (m) r += int2char(d);
		}
	}
	return m ? r : "0";
}
function bnNegate() {
	var r = nbi();
	BigInteger.ZERO.subTo(this, r);
	return r;
}
function bnAbs() {
	return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a) {
	var r = this.s - a.s;
	if (r != 0) return r;
	var i = this.t;
	r = i - a.t;
	if (r != 0) return this.s < 0 ? -r : r;
	while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
	return 0;
}
function nbits(x) {
	var r = 1, t$1;
	if ((t$1 = x >>> 16) != 0) {
		x = t$1;
		r += 16;
	}
	if ((t$1 = x >> 8) != 0) {
		x = t$1;
		r += 8;
	}
	if ((t$1 = x >> 4) != 0) {
		x = t$1;
		r += 4;
	}
	if ((t$1 = x >> 2) != 0) {
		x = t$1;
		r += 2;
	}
	if ((t$1 = x >> 1) != 0) {
		x = t$1;
		r += 1;
	}
	return r;
}
function bnBitLength() {
	if (this.t <= 0) return 0;
	return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n, r) {
	var i;
	for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
	for (i = n - 1; i >= 0; --i) r[i] = 0;
	r.t = this.t + n;
	r.s = this.s;
}
function bnpDRShiftTo(n, r) {
	for (var i = n; i < this.t; ++i) r[i - n] = this[i];
	r.t = Math.max(this.t - n, 0);
	r.s = this.s;
}
function bnpLShiftTo(n, r) {
	var bs = n % this.DB;
	var cbs = this.DB - bs;
	var bm = (1 << cbs) - 1;
	var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
	for (i = this.t - 1; i >= 0; --i) {
		r[i + ds + 1] = this[i] >> cbs | c;
		c = (this[i] & bm) << bs;
	}
	for (i = ds - 1; i >= 0; --i) r[i] = 0;
	r[ds] = c;
	r.t = this.t + ds + 1;
	r.s = this.s;
	r.clamp();
}
function bnpRShiftTo(n, r) {
	r.s = this.s;
	var ds = Math.floor(n / this.DB);
	if (ds >= this.t) {
		r.t = 0;
		return;
	}
	var bs = n % this.DB;
	var cbs = this.DB - bs;
	var bm = (1 << bs) - 1;
	r[0] = this[ds] >> bs;
	for (var i = ds + 1; i < this.t; ++i) {
		r[i - ds - 1] |= (this[i] & bm) << cbs;
		r[i - ds] = this[i] >> bs;
	}
	if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
	r.t = this.t - ds;
	r.clamp();
}
function bnpSubTo(a, r) {
	var i = 0, c = 0, m = Math.min(a.t, this.t);
	while (i < m) {
		c += this[i] - a[i];
		r[i++] = c & this.DM;
		c >>= this.DB;
	}
	if (a.t < this.t) {
		c -= a.s;
		while (i < this.t) {
			c += this[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c += this.s;
	} else {
		c += this.s;
		while (i < a.t) {
			c -= a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c -= a.s;
	}
	r.s = c < 0 ? -1 : 0;
	if (c < -1) r[i++] = this.DV + c;
else if (c > 0) r[i++] = c;
	r.t = i;
	r.clamp();
}
function bnpMultiplyTo(a, r) {
	var x = this.abs(), y = a.abs();
	var i = x.t;
	r.t = i + y.t;
	while (--i >= 0) r[i] = 0;
	for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
	r.s = 0;
	r.clamp();
	if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
}
function bnpSquareTo(r) {
	var x = this.abs();
	var i = r.t = 2 * x.t;
	while (--i >= 0) r[i] = 0;
	for (i = 0; i < x.t - 1; ++i) {
		var c = x.am(i, x[i], r, 2 * i, 0, 1);
		if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
			r[i + x.t] -= x.DV;
			r[i + x.t + 1] = 1;
		}
	}
	if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
	r.s = 0;
	r.clamp();
}
function bnpDivRemTo(m, q, r) {
	var pm = m.abs();
	if (pm.t <= 0) return;
	var pt = this.abs();
	if (pt.t < pm.t) {
		if (q != null) q.fromInt(0);
		if (r != null) this.copyTo(r);
		return;
	}
	if (r == null) r = nbi();
	var y = nbi(), ts = this.s, ms = m.s;
	var nsh = this.DB - nbits(pm[pm.t - 1]);
	if (nsh > 0) {
		pm.lShiftTo(nsh, y);
		pt.lShiftTo(nsh, r);
	} else {
		pm.copyTo(y);
		pt.copyTo(r);
	}
	var ys = y.t;
	var y0 = y[ys - 1];
	if (y0 == 0) return;
	var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
	var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
	var i = r.t, j = i - ys, t$1 = q == null ? nbi() : q;
	y.dlShiftTo(j, t$1);
	if (r.compareTo(t$1) >= 0) {
		r[r.t++] = 1;
		r.subTo(t$1, r);
	}
	BigInteger.ONE.dlShiftTo(ys, t$1);
	t$1.subTo(y, y);
	while (y.t < ys) y[y.t++] = 0;
	while (--j >= 0) {
		var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
		if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
			y.dlShiftTo(j, t$1);
			r.subTo(t$1, r);
			while (r[i] < --qd) r.subTo(t$1, r);
		}
	}
	if (q != null) {
		r.drShiftTo(ys, q);
		if (ts != ms) BigInteger.ZERO.subTo(q, q);
	}
	r.t = ys;
	r.clamp();
	if (nsh > 0) r.rShiftTo(nsh, r);
	if (ts < 0) BigInteger.ZERO.subTo(r, r);
}
function bnMod(a) {
	var r = nbi();
	this.abs().divRemTo(a, null, r);
	if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
	return r;
}
function Classic(m) {
	this.m = m;
}
function cConvert(x) {
	if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
else return x;
}
function cRevert(x) {
	return x;
}
function cReduce(x) {
	x.divRemTo(this.m, null, x);
}
function cMulTo(x, y, r) {
	x.multiplyTo(y, r);
	this.reduce(r);
}
function cSqrTo(x, r) {
	x.squareTo(r);
	this.reduce(r);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
	if (this.t < 1) return 0;
	var x = this[0];
	if ((x & 1) == 0) return 0;
	var y = x & 3;
	y = y * (2 - (x & 15) * y) & 15;
	y = y * (2 - (x & 255) * y) & 255;
	y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
	y = y * (2 - x * y % this.DV) % this.DV;
	return y > 0 ? this.DV - y : -y;
}
function Montgomery(m) {
	this.m = m;
	this.mp = m.invDigit();
	this.mpl = this.mp & 32767;
	this.mph = this.mp >> 15;
	this.um = (1 << m.DB - 15) - 1;
	this.mt2 = 2 * m.t;
}
function montConvert(x) {
	var r = nbi();
	x.abs().dlShiftTo(this.m.t, r);
	r.divRemTo(this.m, null, r);
	if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
	return r;
}
function montRevert(x) {
	var r = nbi();
	x.copyTo(r);
	this.reduce(r);
	return r;
}
function montReduce(x) {
	while (x.t <= this.mt2) x[x.t++] = 0;
	for (var i = 0; i < this.m.t; ++i) {
		var j = x[i] & 32767;
		var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
		j = i + this.m.t;
		x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
		while (x[j] >= x.DV) {
			x[j] -= x.DV;
			x[++j]++;
		}
	}
	x.clamp();
	x.drShiftTo(this.m.t, x);
	if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}
function montSqrTo(x, r) {
	x.squareTo(r);
	this.reduce(r);
}
function montMulTo(x, y, r) {
	x.multiplyTo(y, r);
	this.reduce(r);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
	return (this.t > 0 ? this[0] & 1 : this.s) == 0;
}
function bnpExp(e, z) {
	if (e > 4294967295 || e < 1) return BigInteger.ONE;
	var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
	g.copyTo(r);
	while (--i >= 0) {
		z.sqrTo(r, r2);
		if ((e & 1 << i) > 0) z.mulTo(r2, g, r);
else {
			var t$1 = r;
			r = r2;
			r2 = t$1;
		}
	}
	return z.revert(r);
}
function bnModPowInt(e, m) {
	var z;
	if (e < 256 || m.isEven()) z = new Classic(m);
else z = new Montgomery(m);
	return this.exp(e, z);
}
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
function bnClone() {
	var r = nbi();
	this.copyTo(r);
	return r;
}
function bnIntValue() {
	if (this.s < 0) {
		if (this.t == 1) return this[0] - this.DV;
else if (this.t == 0) return -1;
	} else if (this.t == 1) return this[0];
else if (this.t == 0) return 0;
	return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function bnByteValue() {
	return this.t == 0 ? this.s : this[0] << 24 >> 24;
}
function bnShortValue() {
	return this.t == 0 ? this.s : this[0] << 16 >> 16;
}
function bnpChunkSize(r) {
	return Math.floor(Math.LN2 * this.DB / Math.log(r));
}
function bnSigNum() {
	if (this.s < 0) return -1;
else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
else return 1;
}
function bnpToRadix(b) {
	if (b == null) b = 10;
	if (this.signum() == 0 || b < 2 || b > 36) return "0";
	var cs = this.chunkSize(b);
	var a = Math.pow(b, cs);
	var d = nbv(a), y = nbi(), z = nbi(), r = "";
	this.divRemTo(d, y, z);
	while (y.signum() > 0) {
		r = (a + z.intValue()).toString(b).substring(1) + r;
		y.divRemTo(d, y, z);
	}
	return z.intValue().toString(b) + r;
}
function bnpFromRadix(s, b) {
	this.fromInt(0);
	if (b == null) b = 10;
	var cs = this.chunkSize(b);
	var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
	for (var i = 0; i < s.length; ++i) {
		var x = intAt(s, i);
		if (x < 0) {
			if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
			continue;
		}
		w = b * w + x;
		if (++j >= cs) {
			this.dMultiply(d);
			this.dAddOffset(w, 0);
			j = 0;
			w = 0;
		}
	}
	if (j > 0) {
		this.dMultiply(Math.pow(b, j));
		this.dAddOffset(w, 0);
	}
	if (mi) BigInteger.ZERO.subTo(this, this);
}
function bnpFromNumber(a, b, c) {
	if ("number" == typeof b) if (a < 2) this.fromInt(1);
else {
		this.fromNumber(a, c);
		if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
		if (this.isEven()) this.dAddOffset(1, 0);
		while (!this.isProbablePrime(b)) {
			this.dAddOffset(2, 0);
			if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
		}
	}
else {
		var x = new Array(), t$1 = a & 7;
		x.length = (a >> 3) + 1;
		b.nextBytes(x);
		if (t$1 > 0) x[0] &= (1 << t$1) - 1;
else x[0] = 0;
		this.fromString(x, 256);
	}
}
function bnToByteArray() {
	var i = this.t, r = new Array();
	r[0] = this.s;
	var p = this.DB - i * this.DB % 8, d, k = 0;
	if (i-- > 0) {
		if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;
		while (i >= 0) {
			if (p < 8) {
				d = (this[i] & (1 << p) - 1) << 8 - p;
				d |= this[--i] >> (p += this.DB - 8);
			} else {
				d = this[i] >> (p -= 8) & 255;
				if (p <= 0) {
					p += this.DB;
					--i;
				}
			}
			if ((d & 128) != 0) d |= -256;
			if (k == 0 && (this.s & 128) != (d & 128)) ++k;
			if (k > 0 || d != this.s) r[k++] = d;
		}
	}
	return r;
}
function bnEquals(a) {
	return this.compareTo(a) == 0;
}
function bnMin(a) {
	return this.compareTo(a) < 0 ? this : a;
}
function bnMax(a) {
	return this.compareTo(a) > 0 ? this : a;
}
function bnpBitwiseTo(a, op, r) {
	var i, f, m = Math.min(a.t, this.t);
	for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
	if (a.t < this.t) {
		f = a.s & this.DM;
		for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
		r.t = this.t;
	} else {
		f = this.s & this.DM;
		for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
		r.t = a.t;
	}
	r.s = op(this.s, a.s);
	r.clamp();
}
function op_and(x, y) {
	return x & y;
}
function bnAnd(a) {
	var r = nbi();
	this.bitwiseTo(a, op_and, r);
	return r;
}
function op_or(x, y) {
	return x | y;
}
function bnOr(a) {
	var r = nbi();
	this.bitwiseTo(a, op_or, r);
	return r;
}
function op_xor(x, y) {
	return x ^ y;
}
function bnXor(a) {
	var r = nbi();
	this.bitwiseTo(a, op_xor, r);
	return r;
}
function op_andnot(x, y) {
	return x & ~y;
}
function bnAndNot(a) {
	var r = nbi();
	this.bitwiseTo(a, op_andnot, r);
	return r;
}
function bnNot() {
	var r = nbi();
	for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
	r.t = this.t;
	r.s = ~this.s;
	return r;
}
function bnShiftLeft(n) {
	var r = nbi();
	if (n < 0) this.rShiftTo(-n, r);
else this.lShiftTo(n, r);
	return r;
}
function bnShiftRight(n) {
	var r = nbi();
	if (n < 0) this.lShiftTo(-n, r);
else this.rShiftTo(n, r);
	return r;
}
function lbit(x) {
	if (x == 0) return -1;
	var r = 0;
	if ((x & 65535) == 0) {
		x >>= 16;
		r += 16;
	}
	if ((x & 255) == 0) {
		x >>= 8;
		r += 8;
	}
	if ((x & 15) == 0) {
		x >>= 4;
		r += 4;
	}
	if ((x & 3) == 0) {
		x >>= 2;
		r += 2;
	}
	if ((x & 1) == 0) ++r;
	return r;
}
function bnGetLowestSetBit() {
	for (var i = 0; i < this.t; ++i) if (this[i] != 0) return i * this.DB + lbit(this[i]);
	if (this.s < 0) return this.t * this.DB;
	return -1;
}
function cbit(x) {
	var r = 0;
	while (x != 0) {
		x &= x - 1;
		++r;
	}
	return r;
}
function bnBitCount() {
	var r = 0, x = this.s & this.DM;
	for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
	return r;
}
function bnTestBit(n) {
	var j = Math.floor(n / this.DB);
	if (j >= this.t) return this.s != 0;
	return (this[j] & 1 << n % this.DB) != 0;
}
function bnpChangeBit(n, op) {
	var r = BigInteger.ONE.shiftLeft(n);
	this.bitwiseTo(r, op, r);
	return r;
}
function bnSetBit(n) {
	return this.changeBit(n, op_or);
}
function bnClearBit(n) {
	return this.changeBit(n, op_andnot);
}
function bnFlipBit(n) {
	return this.changeBit(n, op_xor);
}
function bnpAddTo(a, r) {
	var i = 0, c = 0, m = Math.min(a.t, this.t);
	while (i < m) {
		c += this[i] + a[i];
		r[i++] = c & this.DM;
		c >>= this.DB;
	}
	if (a.t < this.t) {
		c += a.s;
		while (i < this.t) {
			c += this[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c += this.s;
	} else {
		c += this.s;
		while (i < a.t) {
			c += a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c += a.s;
	}
	r.s = c < 0 ? -1 : 0;
	if (c > 0) r[i++] = c;
else if (c < -1) r[i++] = this.DV + c;
	r.t = i;
	r.clamp();
}
function bnAdd(a) {
	var r = nbi();
	this.addTo(a, r);
	return r;
}
function bnSubtract(a) {
	var r = nbi();
	this.subTo(a, r);
	return r;
}
function bnMultiply(a) {
	var r = nbi();
	this.multiplyTo(a, r);
	return r;
}
function bnSquare() {
	var r = nbi();
	this.squareTo(r);
	return r;
}
function bnDivide(a) {
	var r = nbi();
	this.divRemTo(a, r, null);
	return r;
}
function bnRemainder(a) {
	var r = nbi();
	this.divRemTo(a, null, r);
	return r;
}
function bnDivideAndRemainder(a) {
	var q = nbi(), r = nbi();
	this.divRemTo(a, q, r);
	return new Array(q, r);
}
function bnpDMultiply(n) {
	this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
	++this.t;
	this.clamp();
}
function bnpDAddOffset(n, w) {
	if (n == 0) return;
	while (this.t <= w) this[this.t++] = 0;
	this[w] += n;
	while (this[w] >= this.DV) {
		this[w] -= this.DV;
		if (++w >= this.t) this[this.t++] = 0;
		++this[w];
	}
}
function NullExp() {}
function nNop(x) {
	return x;
}
function nMulTo(x, y, r) {
	x.multiplyTo(y, r);
}
function nSqrTo(x, r) {
	x.squareTo(r);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e) {
	return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(a, n, r) {
	var i = Math.min(this.t + a.t, n);
	r.s = 0;
	r.t = i;
	while (i > 0) r[--i] = 0;
	var j;
	for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
	for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
	r.clamp();
}
function bnpMultiplyUpperTo(a, n, r) {
	--n;
	var i = r.t = this.t + a.t - n;
	r.s = 0;
	while (--i >= 0) r[i] = 0;
	for (i = Math.max(n - this.t, 0); i < a.t; ++i) r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
	r.clamp();
	r.drShiftTo(1, r);
}
function Barrett(m) {
	this.r2 = nbi();
	this.q3 = nbi();
	BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
	this.mu = this.r2.divide(m);
	this.m = m;
}
function barrettConvert(x) {
	if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
else if (x.compareTo(this.m) < 0) return x;
else {
		var r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	}
}
function barrettRevert(x) {
	return x;
}
function barrettReduce(x) {
	x.drShiftTo(this.m.t - 1, this.r2);
	if (x.t > this.m.t + 1) {
		x.t = this.m.t + 1;
		x.clamp();
	}
	this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
	this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
	while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
	x.subTo(this.r2, x);
	while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}
function barrettSqrTo(x, r) {
	x.squareTo(r);
	this.reduce(r);
}
function barrettMulTo(x, y, r) {
	x.multiplyTo(y, r);
	this.reduce(r);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e, m) {
	var xHex = this.toString(16);
	var eHex = e.toString(16);
	var mHex = m.toString(16);
	var result = powMod(str2bigInt(xHex, 16), str2bigInt(eHex, 16), str2bigInt(mHex, 16));
	return new BigInteger(bigInt2str(result, 16), 16);
}
function bnGCD(a) {
	var x = this.s < 0 ? this.negate() : this.clone();
	var y = a.s < 0 ? a.negate() : a.clone();
	if (x.compareTo(y) < 0) {
		var t$1 = x;
		x = y;
		y = t$1;
	}
	var i = x.getLowestSetBit(), g = y.getLowestSetBit();
	if (g < 0) return x;
	if (i < g) g = i;
	if (g > 0) {
		x.rShiftTo(g, x);
		y.rShiftTo(g, y);
	}
	while (x.signum() > 0) {
		if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
		if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
		if (x.compareTo(y) >= 0) {
			x.subTo(y, x);
			x.rShiftTo(1, x);
		} else {
			y.subTo(x, y);
			y.rShiftTo(1, y);
		}
	}
	if (g > 0) y.lShiftTo(g, y);
	return y;
}
function bnpModInt(n) {
	if (n <= 0) return 0;
	var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
	if (this.t > 0) if (d == 0) r = this[0] % n;
else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
	return r;
}
function bnModInverse(m) {
	var ac = m.isEven();
	if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
	var u = m.clone(), v = this.clone();
	var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
	while (u.signum() != 0) {
		while (u.isEven()) {
			u.rShiftTo(1, u);
			if (ac) {
				if (!a.isEven() || !b.isEven()) {
					a.addTo(this, a);
					b.subTo(m, b);
				}
				a.rShiftTo(1, a);
			} else if (!b.isEven()) b.subTo(m, b);
			b.rShiftTo(1, b);
		}
		while (v.isEven()) {
			v.rShiftTo(1, v);
			if (ac) {
				if (!c.isEven() || !d.isEven()) {
					c.addTo(this, c);
					d.subTo(m, d);
				}
				c.rShiftTo(1, c);
			} else if (!d.isEven()) d.subTo(m, d);
			d.rShiftTo(1, d);
		}
		if (u.compareTo(v) >= 0) {
			u.subTo(v, u);
			if (ac) a.subTo(c, a);
			b.subTo(d, b);
		} else {
			v.subTo(u, v);
			if (ac) c.subTo(a, c);
			d.subTo(b, d);
		}
	}
	if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
	if (d.compareTo(m) >= 0) return d.subtract(m);
	if (d.signum() < 0) d.addTo(m, d);
else return d;
	if (d.signum() < 0) return d.add(m);
else return d;
}
var lowprimes = [
	2,
	3,
	5,
	7,
	11,
	13,
	17,
	19,
	23,
	29,
	31,
	37,
	41,
	43,
	47,
	53,
	59,
	61,
	67,
	71,
	73,
	79,
	83,
	89,
	97,
	101,
	103,
	107,
	109,
	113,
	127,
	131,
	137,
	139,
	149,
	151,
	157,
	163,
	167,
	173,
	179,
	181,
	191,
	193,
	197,
	199,
	211,
	223,
	227,
	229,
	233,
	239,
	241,
	251,
	257,
	263,
	269,
	271,
	277,
	281,
	283,
	293,
	307,
	311,
	313,
	317,
	331,
	337,
	347,
	349,
	353,
	359,
	367,
	373,
	379,
	383,
	389,
	397,
	401,
	409,
	419,
	421,
	431,
	433,
	439,
	443,
	449,
	457,
	461,
	463,
	467,
	479,
	487,
	491,
	499,
	503,
	509,
	521,
	523,
	541,
	547,
	557,
	563,
	569,
	571,
	577,
	587,
	593,
	599,
	601,
	607,
	613,
	617,
	619,
	631,
	641,
	643,
	647,
	653,
	659,
	661,
	673,
	677,
	683,
	691,
	701,
	709,
	719,
	727,
	733,
	739,
	743,
	751,
	757,
	761,
	769,
	773,
	787,
	797,
	809,
	811,
	821,
	823,
	827,
	829,
	839,
	853,
	857,
	859,
	863,
	877,
	881,
	883,
	887,
	907,
	911,
	919,
	929,
	937,
	941,
	947,
	953,
	967,
	971,
	977,
	983,
	991,
	997
];
var lplim = 67108864 / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t$1) {
	var i, x = this.abs();
	if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
		for (i = 0; i < lowprimes.length; ++i) if (x[0] == lowprimes[i]) return true;
		return false;
	}
	if (x.isEven()) return false;
	i = 1;
	while (i < lowprimes.length) {
		var m = lowprimes[i], j = i + 1;
		while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
		m = x.modInt(m);
		while (i < j) if (m % lowprimes[i++] == 0) return false;
	}
	return x.millerRabin(t$1);
}
function bnpMillerRabin(t$1) {
	var n1 = this.subtract(BigInteger.ONE);
	var k = n1.getLowestSetBit();
	if (k <= 0) return false;
	var r = n1.shiftRight(k);
	t$1 = t$1 + 1 >> 1;
	if (t$1 > lowprimes.length) t$1 = lowprimes.length;
	var a = nbi();
	for (var i = 0; i < t$1; ++i) {
		a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
		var y = a.modPow(r, this);
		if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
			var j = 1;
			while (j++ < k && y.compareTo(n1) != 0) {
				y = y.modPowInt(2, this);
				if (y.compareTo(BigInteger.ONE) == 0) return false;
			}
			if (y.compareTo(n1) != 0) return false;
		}
	}
	return true;
}
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
BigInteger.prototype.square = bnSquare;
function parseBigInt(str, r) {
	return new BigInteger(str, r);
}
function pkcs1pad2(s, n) {
	if (n < s.length + 11) {
		alert("Message too long for RSA");
		return null;
	}
	var ba = new Array();
	var i = s.length - 1;
	while (i >= 0 && n > 0) {
		var c = s.charCodeAt(i--);
		if (c < 128) ba[--n] = c;
else if (c > 127 && c < 2048) {
			ba[--n] = c & 63 | 128;
			ba[--n] = c >> 6 | 192;
		} else {
			ba[--n] = c & 63 | 128;
			ba[--n] = c >> 6 & 63 | 128;
			ba[--n] = c >> 12 | 224;
		}
	}
	ba[--n] = 0;
	var rng = new SecureRandom();
	var x = new Array();
	while (n > 2) {
		x[0] = 0;
		while (x[0] == 0) rng.nextBytes(x);
		ba[--n] = x[0];
	}
	ba[--n] = 2;
	ba[--n] = 0;
	return new BigInteger(ba);
}
function RSAKey() {
	this.n = null;
	this.e = 0;
	this.d = null;
	this.p = null;
	this.q = null;
	this.dmp1 = null;
	this.dmq1 = null;
	this.coeff = null;
}
function RSASetPublic(N, E) {
	if (N != null && E != null && N.length > 0 && E.length > 0) {
		this.n = parseBigInt(N, 16);
		this.e = parseInt(E, 16);
	} else alert("Invalid RSA public key");
}
function RSADoPublic(x) {
	return x.modPowInt(this.e, this.n);
}
function RSAEncrypt(text) {
	var m = pkcs1pad2(text, this.n.bitLength() + 7 >> 3);
	if (m == null) return null;
	var c = this.doPublic(m);
	if (c == null) return null;
	var h = c.toString(16);
	if ((h.length & 1) == 0) return h;
else return "0" + h;
}
RSAKey.prototype.doPublic = RSADoPublic;
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
function pkcs1unpad2(d, n) {
	var b = d.toByteArray();
	var i = 0;
	while (i < b.length && b[i] == 0) ++i;
	if (b.length - i != n - 1 || b[i] != 2) return null;
	++i;
	while (b[i] != 0) if (++i >= b.length) return null;
	var ret = "";
	while (++i < b.length) {
		var c = b[i] & 255;
		if (c < 128) ret += String.fromCharCode(c);
else if (c > 191 && c < 224) {
			ret += String.fromCharCode((c & 31) << 6 | b[i + 1] & 63);
			++i;
		} else {
			ret += String.fromCharCode((c & 15) << 12 | (b[i + 1] & 63) << 6 | b[i + 2] & 63);
			i += 2;
		}
	}
	return ret;
}
function RSASetPrivate(N, E, D) {
	if (N != null && E != null && N.length > 0 && E.length > 0) {
		this.n = parseBigInt(N, 16);
		this.e = parseInt(E, 16);
		this.d = parseBigInt(D, 16);
	} else alert("Invalid RSA private key");
}
function RSASetPrivateEx(N, E, D, P, Q, DP, DQ, C) {
	if (N != null && E != null && N.length > 0 && E.length > 0) {
		this.n = parseBigInt(N, 16);
		this.e = parseInt(E, 16);
		this.d = parseBigInt(D, 16);
		this.p = parseBigInt(P, 16);
		this.q = parseBigInt(Q, 16);
		this.dmp1 = parseBigInt(DP, 16);
		this.dmq1 = parseBigInt(DQ, 16);
		this.coeff = parseBigInt(C, 16);
	} else alert("Invalid RSA private key");
}
function RSAGenerate(B, E) {
	var rng = new SecureRandom();
	var qs = B >> 1;
	this.e = parseInt(E, 16);
	var ee = new BigInteger(E, 16);
	for (;;) {
		for (;;) {
			this.p = new BigInteger(B - qs, 10, rng);
			if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0) break;
		}
		for (;;) {
			this.q = new BigInteger(qs, 10, rng);
			if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0) break;
		}
		if (this.p.compareTo(this.q) <= 0) {
			var t$1 = this.p;
			this.p = this.q;
			this.q = t$1;
		}
		var p1 = this.p.subtract(BigInteger.ONE);
		var q1 = this.q.subtract(BigInteger.ONE);
		var phi = p1.multiply(q1);
		if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
			this.n = this.p.multiply(this.q);
			this.d = ee.modInverse(phi);
			this.dmp1 = this.d.mod(p1);
			this.dmq1 = this.d.mod(q1);
			this.coeff = this.q.modInverse(this.p);
			break;
		}
	}
}
function RSADoPrivate(x) {
	if (this.p == null || this.q == null) return x.modPow(this.d, this.n);
	var xp = x.mod(this.p).modPow(this.dmp1, this.p);
	var xq = x.mod(this.q).modPow(this.dmq1, this.q);
	while (xp.compareTo(xq) < 0) xp = xp.add(this.p);
	return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}
function RSADecrypt(ctext) {
	var c = parseBigInt(ctext, 16);
	var m = this.doPrivate(c);
	if (m == null) return null;
	return pkcs1unpad2(m, this.n.bitLength() + 7 >> 3);
}
RSAKey.prototype.doPrivate = RSADoPrivate;
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
var bpe = 0;
var mask = 0;
var radix = mask + 1;
const digitsStr = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_=!@#$%^&*()[]{}|;:,.<>/?`~ \\'\"+-";
for (bpe = 0; 1 << bpe + 1 > 1 << bpe; bpe++);
bpe >>= 1;
mask = (1 << bpe) - 1;
radix = mask + 1;
const one = int2bigInt(1, 1, 1);
var t = new Array(0);
var s0 = t;
var s3 = t;
var s4 = t;
var s5 = t;
var s6 = t;
var s7 = t;
var sa = t;
function expand(x, n) {
	var ans = int2bigInt(0, (x.length > n ? x.length : n) * bpe, 0);
	copy_(ans, x);
	return ans;
}
function powMod(x, y, n) {
	var ans = expand(x, n.length);
	powMod_(ans, trim(y, 2), trim(n, 2), 0);
	return trim(ans, 1);
}
function inverseModInt(x, n) {
	var a = 1, b = 0, t$1;
	for (;;) {
		if (x == 1) return a;
		if (x == 0) return 0;
		b -= a * Math.floor(n / x);
		n %= x;
		if (n == 1) return b;
		if (n == 0) return 0;
		a -= b * Math.floor(x / n);
		x %= n;
	}
}
function negative(x) {
	return x[x.length - 1] >> bpe - 1 & 1;
}
function greaterShift(x, y, shift) {
	var i, kx = x.length, ky = y.length, k = kx + shift < ky ? kx + shift : ky;
	for (i = ky - 1 - shift; i < kx && i >= 0; i++) if (x[i] > 0) return 1;
	for (i = kx - 1 + shift; i < ky; i++) if (y[i] > 0) return 0;
	for (i = k - 1; i >= shift; i--) if (x[i - shift] > y[i]) return 1;
else if (x[i - shift] < y[i]) return 0;
	return 0;
}
function greater(x, y) {
	var i;
	var k = x.length < y.length ? x.length : y.length;
	for (i = x.length; i < y.length; i++) if (y[i]) return 0;
	for (i = y.length; i < x.length; i++) if (x[i]) return 1;
	for (i = k - 1; i >= 0; i--) if (x[i] > y[i]) return 1;
else if (x[i] < y[i]) return 0;
	return 0;
}
function divide_(x, y, q, r) {
	var kx, ky;
	var i, j, y1, y2, c, a, b;
	copy_(r, x);
	for (ky = y.length; y[ky - 1] == 0; ky--);
	b = y[ky - 1];
	for (a = 0; b; a++) b >>= 1;
	a = bpe - a;
	leftShift_(y, a);
	leftShift_(r, a);
	for (kx = r.length; r[kx - 1] == 0 && kx > ky; kx--);
	copyInt_(q, 0);
	while (!greaterShift(y, r, kx - ky)) {
		subShift_(r, y, kx - ky);
		q[kx - ky]++;
	}
	for (i = kx - 1; i >= ky; i--) {
		if (r[i] == y[ky - 1]) q[i - ky] = mask;
else q[i - ky] = Math.floor((r[i] * radix + r[i - 1]) / y[ky - 1]);
		for (;;) {
			y2 = (ky > 1 ? y[ky - 2] : 0) * q[i - ky];
			c = y2 >> bpe;
			y2 = y2 & mask;
			y1 = c + q[i - ky] * y[ky - 1];
			c = y1 >> bpe;
			y1 = y1 & mask;
			if (c == r[i] ? y1 == r[i - 1] ? y2 > (i > 1 ? r[i - 2] : 0) : y1 > r[i - 1] : c > r[i]) q[i - ky]--;
else break;
		}
		linCombShift_(r, y, -q[i - ky], i - ky);
		if (negative(r)) {
			addShift_(r, y, i - ky);
			q[i - ky]--;
		}
	}
	rightShift_(y, a);
	rightShift_(r, a);
}
function modInt(x, n) {
	var i, c = 0;
	for (i = x.length - 1; i >= 0; i--) c = (c * radix + x[i]) % n;
	return c;
}
function int2bigInt(t$1, bits, minSize) {
	var i, k, buff;
	k = Math.ceil(bits / bpe) + 1;
	k = minSize > k ? minSize : k;
	buff = new Array(k);
	copyInt_(buff, t$1);
	return buff;
}
function str2bigInt(s, base, minSize) {
	var d, i, j, x, y, kk;
	var k = s.length;
	if (base == -1) {
		x = new Array(0);
		for (;;) {
			y = new Array(x.length + 1);
			for (i = 0; i < x.length; i++) y[i + 1] = x[i];
			y[0] = parseInt(s, 10);
			x = y;
			d = s.indexOf(",", 0);
			if (d < 1) break;
			s = s.substring(d + 1);
			if (s.length == 0) break;
		}
		if (x.length < minSize) {
			y = new Array(minSize);
			copy_(y, x);
			return y;
		}
		return x;
	}
	x = int2bigInt(0, base * k, 0);
	for (i = 0; i < k; i++) {
		d = digitsStr.indexOf(s.substring(i, i + 1), 0);
		if (base <= 36 && d >= 36) d -= 26;
		if (d >= base || d < 0) break;
		multInt_(x, base);
		addInt_(x, d);
	}
	for (k = x.length; k > 0 && !x[k - 1]; k--);
	k = minSize > k + 1 ? minSize : k + 1;
	y = new Array(k);
	kk = k < x.length ? k : x.length;
	for (i = 0; i < kk; i++) y[i] = x[i];
	for (; i < k; i++) y[i] = 0;
	return y;
}
function equalsInt(x, y) {
	var i;
	if (x[0] != y) return 0;
	for (i = 1; i < x.length; i++) if (x[i]) return 0;
	return 1;
}
function isZero(x) {
	var i;
	for (i = 0; i < x.length; i++) if (x[i]) return 0;
	return 1;
}
function bigInt2str(x, base) {
	var i, t$1, s = "";
	if (s6.length != x.length) s6 = dup(x);
else copy_(s6, x);
	if (base == -1) {
		for (i = x.length - 1; i > 0; i--) s += x[i] + ",";
		s += x[0];
	} else while (!isZero(s6)) {
		t$1 = divInt_(s6, base);
		s = digitsStr.substring(t$1, t$1 + 1) + s;
	}
	if (s.length == 0) s = "0";
	return s;
}
function dup(x) {
	var i, buff;
	buff = new Array(x.length);
	copy_(buff, x);
	return buff;
}
function copy_(x, y) {
	var i;
	var k = x.length < y.length ? x.length : y.length;
	for (i = 0; i < k; i++) x[i] = y[i];
	for (i = k; i < x.length; i++) x[i] = 0;
}
function copyInt_(x, n) {
	var i, c;
	for (c = n, i = 0; i < x.length; i++) {
		x[i] = c & mask;
		c >>= bpe;
	}
}
function addInt_(x, n) {
	var i, k, c, b;
	x[0] += n;
	k = x.length;
	c = 0;
	for (i = 0; i < k; i++) {
		c += x[i];
		b = 0;
		if (c < 0) {
			b = -(c >> bpe);
			c += b * radix;
		}
		x[i] = c & mask;
		c = (c >> bpe) - b;
		if (!c) return;
	}
}
function rightShift_(x, n) {
	var i;
	var k = Math.floor(n / bpe);
	if (k) {
		for (i = 0; i < x.length - k; i++) x[i] = x[i + k];
		for (; i < x.length; i++) x[i] = 0;
		n %= bpe;
	}
	for (i = 0; i < x.length - 1; i++) x[i] = mask & (x[i + 1] << bpe - n | x[i] >> n);
	x[i] >>= n;
}
function leftShift_(x, n) {
	var i;
	var k = Math.floor(n / bpe);
	if (k) {
		for (i = x.length; i >= k; i--) x[i] = x[i - k];
		for (; i >= 0; i--) x[i] = 0;
		n %= bpe;
	}
	if (!n) return;
	for (i = x.length - 1; i > 0; i--) x[i] = mask & (x[i] << n | x[i - 1] >> bpe - n);
	x[i] = mask & x[i] << n;
}
function multInt_(x, n) {
	var i, k, c, b;
	if (!n) return;
	k = x.length;
	c = 0;
	for (i = 0; i < k; i++) {
		c += x[i] * n;
		b = 0;
		if (c < 0) {
			b = -(c >> bpe);
			c += b * radix;
		}
		x[i] = c & mask;
		c = (c >> bpe) - b;
	}
}
function divInt_(x, n) {
	var i, r = 0, s;
	for (i = x.length - 1; i >= 0; i--) {
		s = r * radix + x[i];
		x[i] = Math.floor(s / n);
		r = s % n;
	}
	return r;
}
function linCombShift_(x, y, b, ys) {
	var i, c, k, kk;
	k = x.length < ys + y.length ? x.length : ys + y.length;
	kk = x.length;
	for (c = 0, i = ys; i < k; i++) {
		c += x[i] + b * y[i - ys];
		x[i] = c & mask;
		c >>= bpe;
	}
	for (i = k; c && i < kk; i++) {
		c += x[i];
		x[i] = c & mask;
		c >>= bpe;
	}
}
function addShift_(x, y, ys) {
	var i, c, k, kk;
	k = x.length < ys + y.length ? x.length : ys + y.length;
	kk = x.length;
	for (c = 0, i = ys; i < k; i++) {
		c += x[i] + y[i - ys];
		x[i] = c & mask;
		c >>= bpe;
	}
	for (i = k; c && i < kk; i++) {
		c += x[i];
		x[i] = c & mask;
		c >>= bpe;
	}
}
function subShift_(x, y, ys) {
	var i, c, k, kk;
	k = x.length < ys + y.length ? x.length : ys + y.length;
	kk = x.length;
	for (c = 0, i = ys; i < k; i++) {
		c += x[i] - y[i - ys];
		x[i] = c & mask;
		c >>= bpe;
	}
	for (i = k; c && i < kk; i++) {
		c += x[i];
		x[i] = c & mask;
		c >>= bpe;
	}
}
function sub_(x, y) {
	var i, c, k, kk;
	k = x.length < y.length ? x.length : y.length;
	for (c = 0, i = 0; i < k; i++) {
		c += x[i] - y[i];
		x[i] = c & mask;
		c >>= bpe;
	}
	for (i = k; c && i < x.length; i++) {
		c += x[i];
		x[i] = c & mask;
		c >>= bpe;
	}
}
function mod_(x, n) {
	if (s4.length != x.length) s4 = dup(x);
else copy_(s4, x);
	if (s5.length != x.length) s5 = dup(x);
	divide_(s4, n, s5, x);
}
function multMod_(x, y, n) {
	var i;
	if (s0.length != 2 * x.length) s0 = new Array(2 * x.length);
	copyInt_(s0, 0);
	for (i = 0; i < y.length; i++) if (y[i]) linCombShift_(s0, x, y[i], i);
	mod_(s0, n);
	copy_(x, s0);
}
function squareMod_(x, n) {
	var i, j, d, c, kx, kn, k;
	for (kx = x.length; kx > 0 && !x[kx - 1]; kx--);
	k = kx > n.length ? 2 * kx : 2 * n.length;
	if (s0.length != k) s0 = new Array(k);
	copyInt_(s0, 0);
	for (i = 0; i < kx; i++) {
		c = s0[2 * i] + x[i] * x[i];
		s0[2 * i] = c & mask;
		c >>= bpe;
		for (j = i + 1; j < kx; j++) {
			c = s0[i + j] + 2 * x[i] * x[j] + c;
			s0[i + j] = c & mask;
			c >>= bpe;
		}
		s0[i + kx] = c;
	}
	mod_(s0, n);
	copy_(x, s0);
}
function trim(x, k) {
	var i, y;
	for (i = x.length; i > 0 && !x[i - 1]; i--);
	y = new Array(i + k);
	copy_(y, x);
	return y;
}
function powMod_(x, y, n) {
	var k1, k2, kn, np;
	if (s7.length != n.length) s7 = dup(n);
	if ((n[0] & 1) == 0) {
		copy_(s7, x);
		copyInt_(x, 1);
		while (!equalsInt(y, 0)) {
			if (y[0] & 1) multMod_(x, s7, n);
			divInt_(y, 2);
			squareMod_(s7, n);
		}
		return;
	}
	copyInt_(s7, 0);
	for (kn = n.length; kn > 0 && !n[kn - 1]; kn--);
	np = radix - inverseModInt(modInt(n, radix), radix);
	s7[kn] = 1;
	multMod_(x, s7, n);
	if (s3.length != x.length) s3 = dup(x);
else copy_(s3, x);
	for (k1 = y.length - 1; k1 > 0 & !y[k1]; k1--);
	if (y[k1] == 0) {
		copyInt_(x, 1);
		return;
	}
	for (k2 = 1 << bpe - 1; k2 && !(y[k1] & k2); k2 >>= 1);
	for (;;) {
		k2 >>= 1;
		if (!k2) {
			k1--;
			if (k1 < 0) {
				mont_(x, one, n, np);
				return;
			}
			k2 = 1 << bpe - 1;
		}
		mont_(x, x, n, np);
		if (k2 & y[k1]) mont_(x, s3, n, np);
	}
}
function mont_(x, y, n, np) {
	var i, j, c, ui, t$1, ks;
	var kn = n.length;
	var ky = y.length;
	if (sa.length != kn) sa = new Array(kn);
	copyInt_(sa, 0);
	for (; kn > 0 && n[kn - 1] == 0; kn--);
	for (; ky > 0 && y[ky - 1] == 0; ky--);
	ks = sa.length - 1;
	for (i = 0; i < kn; i++) {
		t$1 = sa[0] + x[i] * y[0];
		ui = (t$1 & mask) * np & mask;
		c = t$1 + ui * n[0] >> bpe;
		t$1 = x[i];
		j = 1;
		for (; j < ky - 4;) {
			c += sa[j] + ui * n[j] + t$1 * y[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j] + t$1 * y[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j] + t$1 * y[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j] + t$1 * y[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j] + t$1 * y[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
		}
		for (; j < ky;) {
			c += sa[j] + ui * n[j] + t$1 * y[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
		}
		for (; j < kn - 4;) {
			c += sa[j] + ui * n[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
			c += sa[j] + ui * n[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
		}
		for (; j < kn;) {
			c += sa[j] + ui * n[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
		}
		for (; j < ks;) {
			c += sa[j];
			sa[j - 1] = c & mask;
			c >>= bpe;
			j++;
		}
		sa[j - 1] = c & mask;
	}
	if (!greater(n, sa)) sub_(sa, n);
	copy_(x, sa);
}

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/AsymmetricKeyPair.js
var KeyPairType;
(function(KeyPairType$1) {
	KeyPairType$1[KeyPairType$1["RSA"] = 0] = "RSA";
	KeyPairType$1[KeyPairType$1["RSA_AND_ECC"] = 1] = "RSA_AND_ECC";
	KeyPairType$1[KeyPairType$1["TUTA_CRYPT"] = 2] = "TUTA_CRYPT";
})(KeyPairType || (KeyPairType = {}));
function isPqKeyPairs(keyPair) {
	return keyPair.keyPairType === KeyPairType.TUTA_CRYPT;
}
function isRsaOrRsaEccKeyPair(keyPair) {
	return keyPair.keyPairType === KeyPairType.RSA || keyPair.keyPairType === KeyPairType.RSA_AND_ECC;
}
function isRsaEccKeyPair(keyPair) {
	return keyPair.keyPairType === KeyPairType.RSA_AND_ECC;
}
function isPqPublicKey(publicKey) {
	return publicKey.keyPairType === KeyPairType.TUTA_CRYPT;
}
function isRsaPublicKey(publicKey) {
	return publicKey.keyPairType === KeyPairType.RSA;
}

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/Rsa.js
const RSA_KEY_LENGTH_BITS = 2048;
const RSA_PUBLIC_EXPONENT = 65537;
function rsaEncrypt(publicKey, bytes, seed) {
	const rsa = new RSAKey();
	rsa.n = new BigInteger(new Int8Array(base64ToUint8Array(publicKey.modulus)));
	rsa.e = publicKey.publicExponent;
	const paddedBytes = oaepPad(bytes, publicKey.keyLength, seed);
	const paddedHex = uint8ArrayToHex(paddedBytes);
	const bigInt = parseBigInt(paddedHex, 16);
	let encrypted;
	try {
		encrypted = new Uint8Array(rsa.doPublic(bigInt).toByteArray());
	} catch (e) {
		throw new CryptoError("failed RSA encryption", e);
	}
	return _padAndUnpadLeadingZeros(publicKey.keyLength / 8, encrypted);
}
function rsaDecrypt(privateKey, bytes) {
	try {
		const rsa = new RSAKey();
		rsa.n = new BigInteger(new Int8Array(base64ToUint8Array(privateKey.modulus)));
		rsa.d = new BigInteger(new Int8Array(base64ToUint8Array(privateKey.privateExponent)));
		rsa.p = new BigInteger(new Int8Array(base64ToUint8Array(privateKey.primeP)));
		rsa.q = new BigInteger(new Int8Array(base64ToUint8Array(privateKey.primeQ)));
		rsa.dmp1 = new BigInteger(new Int8Array(base64ToUint8Array(privateKey.primeExponentP)));
		rsa.dmq1 = new BigInteger(new Int8Array(base64ToUint8Array(privateKey.primeExponentQ)));
		rsa.coeff = new BigInteger(new Int8Array(base64ToUint8Array(privateKey.crtCoefficient)));
		const hex = uint8ArrayToHex(bytes);
		const bigInt = parseBigInt(hex, 16);
		const decrypted = new Uint8Array(rsa.doPrivate(bigInt).toByteArray());
		const paddedDecrypted = _padAndUnpadLeadingZeros(privateKey.keyLength / 8 - 1, decrypted);
		return oaepUnpad(paddedDecrypted, privateKey.keyLength);
	} catch (e) {
		throw new CryptoError("failed RSA decryption", e);
	}
}
function _padAndUnpadLeadingZeros(targetByteLength, byteArray) {
	const result = new Uint8Array(targetByteLength);
	if (byteArray.length > result.length) {
		const lastExtraByte = byteArray[byteArray.length - result.length - 1];
		if (lastExtraByte !== 0) throw new CryptoError(`leading byte is not 0 but ${lastExtraByte}, encrypted length: ${byteArray.length}`);
		byteArray = byteArray.slice(byteArray.length - result.length);
	}
	result.set(byteArray, result.length - byteArray.length);
	return result;
}
function oaepPad(value, keyLength, seed) {
	let hashLength = 32;
	if (seed.length !== hashLength) throw new CryptoError("invalid seed length: " + seed.length + ". expected: " + hashLength + " bytes!");
	if (value.length > keyLength / 8 - hashLength - 1) throw new CryptoError("invalid value length: " + value.length + ". expected: max. " + (keyLength / 8 - hashLength - 1));
	let block = _getPSBlock(value, keyLength);
	let dbMask = mgf1(seed, block.length - hashLength);
	for (let i = hashLength; i < block.length; i++) block[i] ^= dbMask[i - hashLength];
	let seedMask = mgf1(block.slice(hashLength, block.length), hashLength);
	for (let i = 0; i < seedMask.length; i++) block[i] = seed[i] ^ seedMask[i];
	return block;
}
function oaepUnpad(value, keyLength) {
	let hashLength = 32;
	if (value.length !== keyLength / 8 - 1) throw new CryptoError("invalid value length: " + value.length + ". expected: " + (keyLength / 8 - 1) + " bytes!");
	let seedMask = mgf1(value.slice(hashLength, value.length), hashLength);
	let seed = new Uint8Array(hashLength);
	for (let i = 0; i < seedMask.length; i++) seed[i] = value[i] ^ seedMask[i];
	let dbMask = mgf1(seed, value.length - hashLength);
	for (let i = hashLength; i < value.length; i++) value[i] ^= dbMask[i - hashLength];
	let index;
	for (index = 2 * hashLength; index < value.length; index++) if (value[index] === 1) break;
else if (value[index] !== 0 || index === value.length) throw new CryptoError("invalid padding");
	return value.slice(index + 1, value.length);
}
function _getPSBlock(value, keyLength) {
	let hashLength = 32;
	let blockLength = keyLength / 8 - 1;
	let block = new Uint8Array(blockLength);
	let defHash = sha256Hash(new Uint8Array([]));
	let nbrOfZeros = block.length - (1 + value.length);
	for (let i = 0; i < block.length; i++) if (i >= hashLength && i < 2 * hashLength) block[i] = defHash[i - hashLength];
else if (i < nbrOfZeros) block[i] = 0;
else if (i === nbrOfZeros) block[i] = 1;
else block[i] = value[i - nbrOfZeros - 1];
	return block;
}
function mgf1(seed, length) {
	let C = null;
	let counter = 0;
	let T = new Uint8Array(0);
	do {
		C = i2osp(counter);
		T = concat(T, sha256Hash(concat(seed, C)));
	} while (++counter < Math.ceil(length / 32));
	return T.slice(0, length);
}
function i2osp(i) {
	return new Uint8Array([
		i >> 24 & 255,
		i >> 16 & 255,
		i >> 8 & 255,
		i >> 0 & 255
	]);
}
/********************************* Key conversion *********************************/
/**
* @param publicKey
* @returns The public key in a persistable array format
* @private
*/
function _publicKeyToArray(publicKey) {
	return [_base64ToBigInt(publicKey.modulus)];
}
/**
* @param privateKey
* @returns The private key in a persistable array format
* @private
*/
function _privateKeyToArray(privateKey) {
	return [
		_base64ToBigInt(privateKey.modulus),
		_base64ToBigInt(privateKey.privateExponent),
		_base64ToBigInt(privateKey.primeP),
		_base64ToBigInt(privateKey.primeQ),
		_base64ToBigInt(privateKey.primeExponentP),
		_base64ToBigInt(privateKey.primeExponentQ),
		_base64ToBigInt(privateKey.crtCoefficient)
	];
}
function _arrayToPublicKey(publicKey) {
	return {
		keyPairType: KeyPairType.RSA,
		version: 0,
		keyLength: RSA_KEY_LENGTH_BITS,
		modulus: int8ArrayToBase64(new Int8Array(publicKey[0].toByteArray())),
		publicExponent: RSA_PUBLIC_EXPONENT
	};
}
function _arrayToPrivateKey(privateKey) {
	return {
		version: 0,
		keyLength: RSA_KEY_LENGTH_BITS,
		modulus: int8ArrayToBase64(new Int8Array(privateKey[0].toByteArray())),
		privateExponent: int8ArrayToBase64(new Int8Array(privateKey[1].toByteArray())),
		primeP: int8ArrayToBase64(new Int8Array(privateKey[2].toByteArray())),
		primeQ: int8ArrayToBase64(new Int8Array(privateKey[3].toByteArray())),
		primeExponentP: int8ArrayToBase64(new Int8Array(privateKey[4].toByteArray())),
		primeExponentQ: int8ArrayToBase64(new Int8Array(privateKey[5].toByteArray())),
		crtCoefficient: int8ArrayToBase64(new Int8Array(privateKey[6].toByteArray()))
	};
}
function _base64ToBigInt(base64) {
	return parseBigInt(base64ToHex(base64), 16);
}
/**
* Provides the length of the given string as hex string of 4 characters length. Padding to 4 characters is done with '0'.
* @param {string} string A string to get the length of.
* @return {string} A hex string containing the length of string.
*/
function _hexLen(string) {
	let hexLen = string.length.toString(16);
	while (hexLen.length < 4) hexLen = "0" + hexLen;
	return hexLen;
}
function _keyArrayToHex(key) {
	let hex = "";
	for (let i = 0; i < key.length; i++) {
		let param = key[i].toString(16);
		if (param.length % 2 === 1) param = "0" + param;
		hex += _hexLen(param) + param;
	}
	return hex;
}
function _hexToKeyArray(hex) {
	try {
		let key = [];
		let pos = 0;
		while (pos < hex.length) {
			let nextParamLen = parseInt(hex.substring(pos, pos + 4), 16);
			pos += 4;
			key.push(parseBigInt(hex.substring(pos, pos + nextParamLen), 16));
			pos += nextParamLen;
		}
		_validateKeyLength(key);
		return key;
	} catch (e) {
		throw new CryptoError("hex to rsa key failed", e);
	}
}
function _validateKeyLength(key) {
	if (key.length !== 1 && key.length !== 7) throw new Error("invalid key params");
	if (key[0].bitLength() < RSA_KEY_LENGTH_BITS - 1 || key[0].bitLength() > RSA_KEY_LENGTH_BITS) throw new Error("invalid key length, expected: around " + RSA_KEY_LENGTH_BITS + ", but was: " + key[0].bitLength());
}
function rsaPrivateKeyToHex(privateKey) {
	return _keyArrayToHex(_privateKeyToArray(privateKey));
}
function rsaPublicKeyToHex(publicKey) {
	return _keyArrayToHex(_publicKeyToArray(publicKey));
}
function hexToRsaPrivateKey(privateKeyHex) {
	return _arrayToPrivateKey(_hexToKeyArray(privateKeyHex));
}
function hexToRsaPublicKey(publicKeyHex) {
	return _arrayToPublicKey(_hexToKeyArray(publicKeyHex));
}

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/KeyEncryption.js
function encryptKey(encryptionKey, keyToBeEncrypted) {
	const keyLength = getKeyLengthBytes(encryptionKey);
	if (keyLength === KEY_LENGTH_BYTES_AES_128) return aesEncrypt(encryptionKey, bitArrayToUint8Array(keyToBeEncrypted), fixedIv, false, false).slice(fixedIv.length);
else if (keyLength === KEY_LENGTH_BYTES_AES_256) return aesEncrypt(encryptionKey, bitArrayToUint8Array(keyToBeEncrypted), undefined, false, true);
else throw new Error(`invalid AES key length (must be 128-bit or 256-bit, got ${keyLength} bytes instead)`);
}
function decryptKey(encryptionKey, keyToBeDecrypted) {
	const keyLength = getKeyLengthBytes(encryptionKey);
	if (keyLength === KEY_LENGTH_BYTES_AES_128) return uint8ArrayToBitArray(aesDecrypt(encryptionKey, concat(fixedIv, keyToBeDecrypted), false));
else if (keyLength === KEY_LENGTH_BYTES_AES_256) return uint8ArrayToBitArray(aesDecrypt(encryptionKey, keyToBeDecrypted, false));
else throw new Error(`invalid AES key length (must be 128-bit or 256-bit, got ${keyLength} bytes instead)`);
}
function aes256DecryptWithRecoveryKey(encryptionKey, keyToBeDecrypted) {
	if (keyToBeDecrypted.length === KEY_LENGTH_BYTES_AES_128) return uint8ArrayToBitArray(unauthenticatedAesDecrypt(encryptionKey, concat(fixedIv, keyToBeDecrypted), false));
else return decryptKey(encryptionKey, keyToBeDecrypted);
}
function encryptRsaKey(encryptionKey, privateKey, iv) {
	return aesEncrypt(encryptionKey, hexToUint8Array(rsaPrivateKeyToHex(privateKey)), iv, true, true);
}
function encryptEccKey(encryptionKey, privateKey) {
	return aesEncrypt(encryptionKey, privateKey, undefined, true, true);
}
function encryptKyberKey(encryptionKey, privateKey) {
	return aesEncrypt(encryptionKey, kyberPrivateKeyToBytes(privateKey));
}
function decryptKeyPair(encryptionKey, keyPair) {
	if (keyPair.symEncPrivRsaKey) return decryptRsaOrRsaEccKeyPair(encryptionKey, keyPair);
else return decryptPQKeyPair(encryptionKey, keyPair);
}
function decryptRsaOrRsaEccKeyPair(encryptionKey, keyPair) {
	const publicKey = hexToRsaPublicKey(uint8ArrayToHex(assertNotNull(keyPair.pubRsaKey)));
	const privateKey = hexToRsaPrivateKey(uint8ArrayToHex(aesDecrypt(encryptionKey, keyPair.symEncPrivRsaKey, true)));
	if (keyPair.symEncPrivEccKey) {
		const publicEccKey = assertNotNull(keyPair.pubEccKey);
		const privateEccKey = aesDecrypt(encryptionKey, assertNotNull(keyPair.symEncPrivEccKey));
		return {
			keyPairType: KeyPairType.RSA_AND_ECC,
			publicKey,
			privateKey,
			publicEccKey,
			privateEccKey
		};
	} else return {
		keyPairType: KeyPairType.RSA,
		publicKey,
		privateKey
	};
}
function decryptPQKeyPair(encryptionKey, keyPair) {
	const eccPublicKey = assertNotNull(keyPair.pubEccKey, "expected pub ecc key for PQ keypair");
	const eccPrivateKey = aesDecrypt(encryptionKey, assertNotNull(keyPair.symEncPrivEccKey, "expected priv ecc key for PQ keypair"));
	const kyberPublicKey = bytesToKyberPublicKey(assertNotNull(keyPair.pubKyberKey, "expected pub kyber key for PQ keypair"));
	const kyberPrivateKey = bytesToKyberPrivateKey(aesDecrypt(encryptionKey, assertNotNull(keyPair.symEncPrivKyberKey, "expected enc priv kyber key for PQ keypair")));
	return {
		keyPairType: KeyPairType.TUTA_CRYPT,
		eccKeyPair: {
			publicKey: eccPublicKey,
			privateKey: eccPrivateKey
		},
		kyberKeyPair: {
			publicKey: kyberPublicKey,
			privateKey: kyberPrivateKey
		}
	};
}

//#endregion
//#region ../packages/tutanota-crypto/dist/encryption/PQKeyPairs.js
function pqKeyPairsToPublicKeys(keyPairs) {
	return {
		keyPairType: keyPairs.keyPairType,
		eccPublicKey: keyPairs.eccKeyPair.publicKey,
		kyberPublicKey: keyPairs.kyberKeyPair.publicKey
	};
}

//#endregion
//#region ../packages/tutanota-crypto/dist/hashes/Sha1.js
const sha1 = new sjcl_default.hash.sha1();

//#endregion
//#region ../packages/tutanota-crypto/dist/misc/TotpVerifier.js
let DIGITS = 6;
const DIGITS_POWER = [
	1,
	10,
	100,
	1e3,
	1e4,
	1e5,
	1e6,
	1e7,
	1e8
];
const base32 = sjcl_default.codec.base32;
var TotpVerifier = class TotpVerifier {
	_digits;
	constructor(digits = DIGITS) {
		this._digits = digits;
	}
	generateSecret() {
		let key = random.generateRandomData(16);
		let readableKey = TotpVerifier.readableKey(key);
		return {
			key,
			readableKey
		};
	}
	/**
	* This method generates a TOTP value for the given
	* set of parameters.
	*
	* @param time : a value that reflects a time
	* @param key  :  the shared secret. It is generated if it does not exist
	* @return: the key and a numeric String in base 10 that includes truncationDigits digits
	*/
	generateTotp(time, key) {
		let timeHex = time.toString(16);
		while (timeHex.length < 16) timeHex = "0" + timeHex;
		let msg = hexToUint8Array(timeHex);
		let hash = this.hmac_sha(key, msg);
		let offset = hash[hash.length - 1] & 15;
		let binary = (hash[offset] & 127) << 24 | (hash[offset + 1] & 255) << 16 | (hash[offset + 2] & 255) << 8 | hash[offset + 3] & 255;
		let code = binary % DIGITS_POWER[this._digits];
		return code;
	}
	hmac_sha(key, text) {
		let hmac = new sjcl_default.misc.hmac(uint8ArrayToBitArray(key), sjcl_default.hash.sha1);
		return bitArrayToUint8Array(hmac.encrypt(uint8ArrayToBitArray(text)));
	}
	static readableKey(key) {
		return base32.fromBits(uint8ArrayToBitArray(key)).toLowerCase().replace(/(.{4})/g, "$1 ").replace(/=/g, "").trim();
	}
};

//#endregion
//#region ../packages/tutanota-crypto/dist/hashes/MurmurHash.js
function x86fmix32(h) {
	h ^= h >>> 16;
	h = mul32(h, 2246822507);
	h ^= h >>> 13;
	h = mul32(h, 3266489909);
	h ^= h >>> 16;
	return h;
}
const x86hash32c1 = 3432918353;
const x86hash32c2 = 461845907;
function x86mix32(h, k) {
	k = mul32(k, x86hash32c1);
	k = rol32(k, 15);
	k = mul32(k, x86hash32c2);
	h ^= k;
	h = rol32(h, 13);
	h = mul32(h, 5) + 3864292196;
	return h;
}
function mul32(m, n) {
	return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
}
function rol32(n, r) {
	return n << r | n >>> 32 - r;
}
function murmurHash(value) {
	let state = 0;
	const buf = stringToUtf8Uint8Array(value);
	let h1;
	let i;
	let len;
	h1 = state;
	i = 0;
	len = 0;
	const dtv = new DataView(buf.buffer, buf.byteOffset);
	const remainder = (buf.byteLength - i) % 4;
	const bytes = buf.byteLength - i - remainder;
	len += bytes;
	for (; i < bytes; i += 4) h1 = x86mix32(h1, dtv.getUint32(i, true));
	len += remainder;
	let k1 = 0;
	switch (remainder) {
		case 3: k1 ^= buf[i + 2] << 16;
		case 2: k1 ^= buf[i + 1] << 8;
		case 1:
			k1 ^= buf[i];
			k1 = mul32(k1, x86hash32c1);
			k1 = rol32(k1, 15);
			k1 = mul32(k1, x86hash32c2);
			h1 ^= k1;
	}
	h1 ^= len & 4294967295;
	h1 = x86fmix32(h1);
	return h1 >>> 0;
}

//#endregion
//#region ../packages/tutanota-crypto/dist/hashes/HKDF.js
function hkdf(salt, inputKeyMaterial, info, lengthInBytes) {
	const saltHmac = new sjcl_default.misc.hmac(uint8ArrayToBitArray(salt), sjcl_default.hash.sha256);
	const key = saltHmac.mac(uint8ArrayToBitArray(inputKeyMaterial));
	const hashLen = sjcl_default.bitArray.bitLength(key);
	const loops = Math.ceil(lengthInBytes * 8 / hashLen);
	if (loops > 255) throw new sjcl_default.exception.invalid("key bit length is too large for hkdf");
	const inputKeyMaterialHmac = new sjcl_default.misc.hmac(key, sjcl_default.hash.sha256);
	let curOut = [];
	let ret = [];
	for (let i = 1; i <= loops; i++) {
		inputKeyMaterialHmac.update(curOut);
		inputKeyMaterialHmac.update(uint8ArrayToBitArray(info));
		inputKeyMaterialHmac.update([sjcl_default.bitArray.partial(8, i)]);
		curOut = inputKeyMaterialHmac.digest();
		ret = sjcl_default.bitArray.concat(ret, curOut);
	}
	return bitArrayToUint8Array(sjcl_default.bitArray.clamp(ret, lengthInBytes * 8));
}

//#endregion
export { ENABLE_MAC, IV_BYTE_LENGTH, KEY_LENGTH_BYTES_AES_256, KYBER_RAND_AMOUNT_OF_ENTROPY, KeyLength, KeyPairType, TotpVerifier, aes256DecryptWithRecoveryKey, aes256EncryptSearchIndexEntry, aes256RandomKey, aesDecrypt, aesEncrypt, authenticatedAesDecrypt, base64ToKey, bitArrayToUint8Array, bytesToKyberPrivateKey, bytesToKyberPublicKey, createAuthVerifier, createAuthVerifierAsBase64Url, decapsulate, decryptKey, decryptKeyPair, eccDecapsulate, eccEncapsulate, encapsulate, encryptEccKey, encryptKey, encryptKyberKey, encryptRsaKey, fixedIv, generateEccKeyPair, generateIV, generateKeyFromPassphrase$1 as generateKeyFromPassphrase, generateKeyFromPassphrase as generateKeyFromPassphrase$1, generateKeyPair, generateRandomSalt, getKeyLengthBytes, hexToRsaPrivateKey, hexToRsaPublicKey, hkdf, isPqKeyPairs, isPqPublicKey, isRsaEccKeyPair, isRsaOrRsaEccKeyPair, isRsaPublicKey, keyToBase64, keyToUint8Array, kyberPrivateKeyToBytes, kyberPublicKeyToBytes, murmurHash, pqKeyPairsToPublicKeys, random, rsaDecrypt, rsaEncrypt, rsaPrivateKeyToHex, rsaPublicKeyToHex, sha256Hash, uint8ArrayToBitArray, uint8ArrayToKey, unauthenticatedAesDecrypt };
//# sourceMappingURL=dist-DcZ1Y4qd.js.map