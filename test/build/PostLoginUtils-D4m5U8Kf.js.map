{"version":3,"file":"PostLoginUtils-D4m5U8Kf.js","names":["notification: OutOfOfficeNotification","currentDate: Date","notification: OutOfOfficeNotification | null","userController: UserController","date: Date","userManagementFacade: UserManagementFacade","customerFacade: CustomerFacade","usedStorageInBytes: number","availableStorageInBytes: number"],"sources":["../../src/common/misc/OutOfOfficeNotificationUtils.ts","../../src/common/login/PostLoginUtils.ts"],"sourcesContent":["import type { OutOfOfficeNotification } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { OutOfOfficeNotificationTypeRef } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { formatDate } from \"./Formatter\"\nimport { lang } from \"./LanguageViewModel\"\nimport { locator } from \"../api/main/CommonLocator\"\nimport { MailboxGroupRootTypeRef } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { getDayShifted } from \"@tutao/tutanota-utils\"\n\n/**\n * Returns true if notifications are currently sent.\n */\nexport function isNotificationCurrentlyActive(notification: OutOfOfficeNotification, currentDate: Date): boolean {\n\tif (notification.enabled) {\n\t\tif (notification.startDate && !notification.endDate) {\n\t\t\treturn currentDate >= notification.startDate\n\t\t} else if (notification.startDate && notification.endDate) {\n\t\t\treturn currentDate >= notification.startDate && currentDate < notification.endDate\n\t\t} else {\n\t\t\t// no dates specified but enabled\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\treturn false\n\t}\n}\n\nexport function formatActivateState(notification: OutOfOfficeNotification | null): string {\n\tif (notification && notification.enabled) {\n\t\tlet timeRange = \"\"\n\n\t\tif (notification.startDate) {\n\t\t\ttimeRange += \" (\" + formatDate(notification.startDate)\n\n\t\t\tif (notification.endDate) {\n\t\t\t\t// end dates are stored as the beginning of the following date. We subtract one day to show the correct date to the user.\n\t\t\t\tconst shiftedEndDate = getDayShifted(notification.endDate, -1)\n\t\t\t\ttimeRange += \" - \" + formatDate(shiftedEndDate)\n\t\t\t}\n\n\t\t\ttimeRange += \")\"\n\t\t}\n\n\t\treturn lang.get(\"activated_label\") + timeRange\n\t} else {\n\t\treturn lang.get(\"deactivated_label\")\n\t}\n}\n\n/**\n *\n * @param organizationMessageEnabled true if a special messagesfor senders from the same organization is setup\n * @returns {string} the label for default notifications (depends on whether only default notifications or both default and same organization notifications are enabled)\n */\nexport function getDefaultNotificationLabel(organizationMessageEnabled: boolean): string {\n\tif (organizationMessageEnabled) {\n\t\treturn lang.get(\"outOfOfficeExternal_msg\")\n\t} else {\n\t\treturn lang.get(\"outOfOfficeEveryone_msg\")\n\t}\n}\n\n/**\n * Loads the out of office notification from the server and shifts the end date (from the first second of the following day to the first second of the last day)\n * which is needed to display the correct end date.\n */\nexport function loadOutOfOfficeNotification(): Promise<OutOfOfficeNotification | null> {\n\tconst mailMembership = locator.logins.getUserController().getUserMailGroupMembership()\n\treturn locator.entityClient.load(MailboxGroupRootTypeRef, mailMembership.group).then((grouproot) => {\n\t\tif (grouproot.outOfOfficeNotification) {\n\t\t\treturn locator.entityClient.load<OutOfOfficeNotification>(OutOfOfficeNotificationTypeRef, grouproot.outOfOfficeNotification)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t})\n}\n","import { isIOSApp } from \"../api/common/Env.js\"\nimport { Const } from \"../api/common/TutanotaConstants.js\"\nimport { UserController } from \"../api/main/UserController.js\"\nimport { assertNotNull } from \"@tutao/tutanota-utils\"\nimport { UserManagementFacade } from \"../api/worker/facades/lazy/UserManagementFacade.js\"\nimport { CustomerFacade } from \"../api/worker/facades/lazy/CustomerFacade.js\"\n\n// the customer may have been reminded when they were a free account, so we can't use lastUpgradeReminder being null as a marker.\n// we use a date that's shortly before we started issuing reminders for legacy accounts and after we started only allowing new plans as upgrades.\n// anyone who is still legacy and was reminded before this date must have seen the last reminder when they were a free account.\n// if we end up wanting to repeat this down the line, update this to some later date.\nexport const reminderCutoffDate = new Date(\"2023-09-20T13:00:00.000Z\")\n\nexport async function shouldShowUpgradeReminder(userController: UserController, date: Date): Promise<boolean> {\n\t// * do not show to normal users, they can't upgrade their account\n\t// * do not show to new plans, they already switched\n\t// * do not show in ios app, they can't upgrade there.\n\tif (!userController.isGlobalAdmin() || (await userController.isNewPaidPlan()) || isIOSApp()) return false\n\n\tconst customerInfo = await userController.loadCustomerInfo()\n\tconst customerProperties = await userController.loadCustomerProperties()\n\n\tif (userController.isFreeAccount()) {\n\t\t// i'm any non-paying user - show repeatedly until upgraded, but only after INITIAL_UPGRADE_REMINDER_INTERVAL_MS\n\t\tconst isOldEnoughForInitialReminder =\n\t\t\tcustomerProperties.lastUpgradeReminder == null && date.getTime() - customerInfo.creationTime.getTime() > Const.INITIAL_UPGRADE_REMINDER_INTERVAL_MS\n\t\t// If we've shown the reminder before show it again every REPEATED_UPGRADE_REMINDER_INTERVAL_MS.\n\t\tconst wasRemindedLongAgo =\n\t\t\tcustomerProperties.lastUpgradeReminder != null &&\n\t\t\tdate.getTime() - customerProperties.lastUpgradeReminder.getTime() > Const.REPEATED_UPGRADE_REMINDER_INTERVAL_MS\n\t\treturn isOldEnoughForInitialReminder || wasRemindedLongAgo\n\t} else if (!(await userController.loadCustomer()).businessUse) {\n\t\t// i'm a private legacy paid account. show once.\n\t\t// we don't have to check account age - all legacy accounts are old enough by now.\n\t\treturn customerProperties.lastUpgradeReminder == null || customerProperties.lastUpgradeReminder.getTime() < reminderCutoffDate.getTime()\n\t} else {\n\t\t// i'm a business legacy paid account, so we don't show the reminder.\n\t\treturn false\n\t}\n}\n\nexport async function shouldShowStorageWarning(\n\tuserController: UserController,\n\tuserManagementFacade: UserManagementFacade,\n\tcustomerFacade: CustomerFacade,\n): Promise<boolean> {\n\tconst customerInfo = await userController.loadCustomerInfo()\n\t// New plans have per-user storage limits.\n\tif ((await userController.isNewPaidPlan()) || userController.isFreeAccount()) {\n\t\tconst usedStorage = await userManagementFacade.readUsedUserStorage(userController.user)\n\t\treturn isOverStorageLimit(usedStorage, Number(customerInfo.perUserStorageCapacity) * Const.MEMORY_GB_FACTOR)\n\t} else {\n\t\t// Legacy plans have per-account storage limits.\n\t\tif (!userController.isGlobalAdmin()) {\n\t\t\treturn false\n\t\t}\n\t\tconst customerId = assertNotNull(userController.user.customer)\n\t\tconst usedStorage = await customerFacade.readUsedCustomerStorage(customerId)\n\t\tif (Number(usedStorage) > Const.MEMORY_GB_FACTOR * Const.MEMORY_WARNING_FACTOR) {\n\t\t\tconst availableStorage = await customerFacade.readAvailableCustomerStorage(customerId)\n\t\t\treturn isOverStorageLimit(usedStorage, availableStorage)\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunction isOverStorageLimit(usedStorageInBytes: number, availableStorageInBytes: number) {\n\treturn usedStorageInBytes > availableStorageInBytes * Const.MEMORY_WARNING_FACTOR\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWO,SAAS,8BAA8BA,cAAuCC,aAA4B;AAChH,KAAI,aAAa,QAChB,KAAI,aAAa,cAAc,aAAa,QAC3C,QAAO,eAAe,aAAa;SACzB,aAAa,aAAa,aAAa,QACjD,QAAO,eAAe,aAAa,aAAa,cAAc,aAAa;IAG3E,QAAO;IAGR,QAAO;AAER;AAEM,SAAS,oBAAoBC,cAAsD;AACzF,KAAI,gBAAgB,aAAa,SAAS;EACzC,IAAI,YAAY;AAEhB,MAAI,aAAa,WAAW;AAC3B,gBAAa,OAAO,WAAW,aAAa,UAAU;AAEtD,OAAI,aAAa,SAAS;IAEzB,MAAM,iBAAiB,cAAc,aAAa,SAAS,GAAG;AAC9D,iBAAa,QAAQ,WAAW,eAAe;GAC/C;AAED,gBAAa;EACb;AAED,SAAO,KAAK,IAAI,kBAAkB,GAAG;CACrC,MACA,QAAO,KAAK,IAAI,oBAAoB;AAErC;AAmBM,SAAS,8BAAuE;CACtF,MAAM,iBAAiB,QAAQ,OAAO,mBAAmB,CAAC,4BAA4B;AACtF,QAAO,QAAQ,aAAa,KAAK,yBAAyB,eAAe,MAAM,CAAC,KAAK,CAAC,cAAc;AACnG,MAAI,UAAU,wBACb,QAAO,QAAQ,aAAa,KAA8B,gCAAgC,UAAU,wBAAwB;IAE5H,QAAO;CAER,EAAC;AACF;;;;MC/DY,qBAAqB,IAAI,KAAK;AAEpC,eAAe,0BAA0BC,gBAAgCC,MAA8B;AAI7G,MAAK,eAAe,eAAe,IAAK,MAAM,eAAe,eAAe,IAAK,UAAU,CAAE,QAAO;CAEpG,MAAM,eAAe,MAAM,eAAe,kBAAkB;CAC5D,MAAM,qBAAqB,MAAM,eAAe,wBAAwB;AAExE,KAAI,eAAe,eAAe,EAAE;EAEnC,MAAM,gCACL,mBAAmB,uBAAuB,QAAQ,KAAK,SAAS,GAAG,aAAa,aAAa,SAAS,GAAG,MAAM;EAEhH,MAAM,qBACL,mBAAmB,uBAAuB,QAC1C,KAAK,SAAS,GAAG,mBAAmB,oBAAoB,SAAS,GAAG,MAAM;AAC3E,SAAO,iCAAiC;CACxC,aAAY,MAAM,eAAe,cAAc,EAAE,YAGjD,QAAO,mBAAmB,uBAAuB,QAAQ,mBAAmB,oBAAoB,SAAS,GAAG,mBAAmB,SAAS;IAGxI,QAAO;AAER;AAEM,eAAe,yBACrBD,gBACAE,sBACAC,gBACmB;CACnB,MAAM,eAAe,MAAM,eAAe,kBAAkB;AAE5D,KAAK,MAAM,eAAe,eAAe,IAAK,eAAe,eAAe,EAAE;EAC7E,MAAM,cAAc,MAAM,qBAAqB,oBAAoB,eAAe,KAAK;AACvF,SAAO,mBAAmB,aAAa,OAAO,aAAa,uBAAuB,GAAG,MAAM,iBAAiB;CAC5G,OAAM;AAEN,OAAK,eAAe,eAAe,CAClC,QAAO;EAER,MAAM,aAAa,cAAc,eAAe,KAAK,SAAS;EAC9D,MAAM,cAAc,MAAM,eAAe,wBAAwB,WAAW;AAC5E,MAAI,OAAO,YAAY,GAAG,MAAM,mBAAmB,MAAM,uBAAuB;GAC/E,MAAM,mBAAmB,MAAM,eAAe,6BAA6B,WAAW;AACtF,UAAO,mBAAmB,aAAa,iBAAiB;EACxD,MACA,QAAO;CAER;AACD;AAED,SAAS,mBAAmBC,oBAA4BC,yBAAiC;AACxF,QAAO,qBAAqB,0BAA0B,MAAM;AAC5D"}