
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __toESM } from "./chunk-D_5_n1c4.js";
import { stringToUtf8Uint8Array, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import "./CryptoError-PqdvQky4.js";
import { KeyPermanentlyInvalidatedError } from "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import { bitArrayToUint8Array, uint8ArrayToBitArray } from "./dist-DcZ1Y4qd.js";
import { CredentialEncryptionMode } from "./CredentialEncryptionMode-BR0DkQpJ.js";
import { CredentialType } from "./CredentialType-DXeA2MQH.js";
import { dist_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { SUPPORTED_MODES, assertDesktopEncryptionMode, assertSupportedEncryptionMode } from "./CredentialCommons-BObczrxd.js";

//#region ../src/common/desktop/credentials/DesktopNativeCredentialsFacade.ts
var DesktopNativeCredentialsFacade = class {
	constructor(crypto, credentialDb, keychainEncryption) {
		this.crypto = crypto;
		this.credentialDb = credentialDb;
		this.keychainEncryption = keychainEncryption;
	}
	async getSupportedEncryptionModes() {
		return SUPPORTED_MODES;
	}
	async deleteByUserId(id) {
		this.credentialDb.deleteByUserId(id);
	}
	async getCredentialEncryptionMode() {
		return this.credentialDb.getCredentialEncryptionMode();
	}
	getDesktopCredentialEncryptionMode() {
		const retVal = this.credentialDb.getCredentialEncryptionMode();
		return retVal ? CredentialEncryptionMode[retVal] : null;
	}
	async loadAll() {
		return this.credentialDb.getAllCredentials();
	}
	async loadByUserId(id) {
		const credentialsKey = await this.getCredentialsEncryptionKey();
		if (credentialsKey == null) throw new KeyPermanentlyInvalidatedError("Credentials key is missing, cannot decrypt credentials");
		const encryptedCredentials = this.credentialDb.getCredentialsByUserId(id);
		return encryptedCredentials ? this.decryptCredentials(encryptedCredentials, credentialsKey) : null;
	}
	decryptCredentials(persistedCredentials, credentialsKey) {
		try {
			return {
				credentialInfo: persistedCredentials.credentialInfo,
				encryptedPassword: persistedCredentials.encryptedPassword,
				accessToken: utf8Uint8ArrayToString(this.crypto.aesDecryptBytes(credentialsKey, persistedCredentials.accessToken)),
				databaseKey: persistedCredentials.databaseKey ? this.crypto.aesDecryptBytes(credentialsKey, persistedCredentials.databaseKey) : null,
				encryptedPassphraseKey: persistedCredentials.encryptedPassphraseKey
			};
		} catch (e) {
			throw new KeyPermanentlyInvalidatedError("Failed AES decrypt: " + e);
		}
	}
	encryptCredentials(unencryptedCredentials, credentialsEncryptionKey) {
		return {
			credentialInfo: unencryptedCredentials.credentialInfo,
			accessToken: this.crypto.aesEncryptBytes(credentialsEncryptionKey, stringToUtf8Uint8Array(unencryptedCredentials.accessToken)),
			databaseKey: unencryptedCredentials.databaseKey ? this.crypto.aesEncryptBytes(credentialsEncryptionKey, unencryptedCredentials.databaseKey) : null,
			encryptedPassphraseKey: unencryptedCredentials.encryptedPassphraseKey,
			encryptedPassword: unencryptedCredentials.encryptedPassword
		};
	}
	async setCredentialEncryptionMode(encryptionMode) {
		assertDesktopEncryptionMode(encryptionMode);
		const decryptedKey = await this.getOrCreateCredentialEncryptionKey();
		const encryptedKey = await this.keychainEncryption.encryptUsingKeychain(bitArrayToUint8Array(decryptedKey), encryptionMode);
		this.credentialDb.setCredentialEncryptionMode(encryptionMode);
		this.credentialDb.setCredentialEncryptionKey(encryptedKey);
	}
	async store(credentials) {
		const credentialsEncryptionKey = await this.getOrCreateCredentialEncryptionKey();
		const encryptedCredentials = this.encryptCredentials(credentials, credentialsEncryptionKey);
		return this.storeEncrypted(encryptedCredentials);
	}
	async clear() {
		this.credentialDb.deleteAllCredentials();
		this.credentialDb.setCredentialEncryptionKey(null);
		this.credentialDb.setCredentialEncryptionMode(null);
	}
	async migrateToNativeCredentials(credentials, encryptionMode, credentialsKey) {
		assertSupportedEncryptionMode(encryptionMode);
		this.credentialDb.setCredentialEncryptionMode(encryptionMode);
		this.credentialDb.setCredentialEncryptionKey(credentialsKey);
		for (const credential of credentials) await this.storeEncrypted(credential);
	}
	async storeEncrypted(credentials) {
		this.credentialDb.store(credentials);
	}
	async getOrCreateCredentialEncryptionKey() {
		const existingKey = await this.getCredentialsEncryptionKey();
		if (existingKey != null) return existingKey;
else {
			const encryptionMode = this.getDesktopCredentialEncryptionMode() ?? CredentialEncryptionMode.DEVICE_LOCK;
			const newKey = bitArrayToUint8Array(this.crypto.generateDeviceKey());
			const encryptedKey = await this.keychainEncryption.encryptUsingKeychain(newKey, encryptionMode);
			this.credentialDb.setCredentialEncryptionKey(encryptedKey);
			return uint8ArrayToBitArray(newKey);
		}
	}
	async getCredentialsEncryptionKey() {
		const encryptionMode = this.getDesktopCredentialEncryptionMode() ?? CredentialEncryptionMode.DEVICE_LOCK;
		const keyChainEncCredentialsKey = this.credentialDb.getCredentialEncryptionKey();
		if (keyChainEncCredentialsKey != null) {
			const credentialsKey = await this.keychainEncryption.decryptUsingKeychain(keyChainEncCredentialsKey, encryptionMode);
			return uint8ArrayToBitArray(credentialsKey);
		} else return null;
	}
};

//#endregion
//#region tests/desktop/credentials/DesktopNativeCredentialsFacadeTest.ts
var import_testdouble = __toESM(require_testdouble(), 1);
dist_default.spec("DesktopNativeCredentialsFacade", () => {
	const crypto = (0, import_testdouble.object)();
	const credentialsDb = (0, import_testdouble.object)();
	const keychainEncryption = (0, import_testdouble.object)();
	let facade;
	const encryptedCredentials1 = {
		credentialInfo: {
			login: "login1@test.com",
			type: CredentialType.Internal,
			userId: "user1"
		},
		encryptedPassword: "pw1",
		encryptedPassphraseKey: null,
		databaseKey: new Uint8Array([
			1,
			13,
			14
		]),
		accessToken: new Uint8Array([
			1,
			10,
			14
		])
	};
	const decryptedCredentials1 = {
		credentialInfo: {
			login: "login1@test.com",
			type: CredentialType.Internal,
			userId: "user1"
		},
		encryptedPassword: "pw1",
		encryptedPassphraseKey: null,
		databaseKey: new Uint8Array([
			1,
			13,
			13
		]),
		accessToken: "decAccessToken1"
	};
	const encryptedCredentials2 = {
		credentialInfo: {
			login: "login2@test.com",
			type: CredentialType.Internal,
			userId: "user2"
		},
		encryptedPassword: "pw2",
		encryptedPassphraseKey: new Uint8Array([
			2,
			11,
			14
		]),
		databaseKey: new Uint8Array([
			2,
			13,
			14
		]),
		accessToken: new Uint8Array([
			2,
			10,
			14
		])
	};
	const decryptedCredentials2 = {
		credentialInfo: {
			login: "login2@test.com",
			type: CredentialType.Internal,
			userId: "user2"
		},
		encryptedPassword: "pw2",
		encryptedPassphraseKey: new Uint8Array([
			2,
			11,
			14
		]),
		databaseKey: new Uint8Array([
			2,
			13,
			13
		]),
		accessToken: "decAccessToken2"
	};
	const encCredentialsKey = new Uint8Array([14]);
	const decCredentialsKey = new Uint8Array([13]);
	dist_default.beforeEach(() => {
		facade = new DesktopNativeCredentialsFacade(crypto, credentialsDb, keychainEncryption);
	});
	dist_default.test("deleteByUserId deletes it from the db", async () => {
		const userId = "user1";
		await facade.deleteByUserId(userId);
		(0, import_testdouble.verify)(credentialsDb.deleteByUserId(userId));
	});
	dist_default.test("getCredentialEncryptionMode returns null from the db", async () => {
		(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionMode()).thenReturn(null);
		dist_default(await facade.getCredentialEncryptionMode()).equals(null);
	});
	dist_default.test("getCredentialEncryptionMode returns mode from the db", async () => {
		(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionMode()).thenReturn(CredentialEncryptionMode.APP_PASSWORD);
		dist_default(await facade.getCredentialEncryptionMode()).equals(CredentialEncryptionMode.APP_PASSWORD);
	});
	dist_default.test("loadAll returns credentials from the db", async () => {
		const credentials = [encryptedCredentials1, encryptedCredentials2];
		(0, import_testdouble.when)(credentialsDb.getAllCredentials()).thenReturn(credentials);
		dist_default(await facade.loadAll()).deepEquals(credentials);
	});
	dist_default.spec("loadByUserId", () => {
		dist_default.test("when there is a key it is used to decrypt credentials w/o passphrase key", async () => {
			(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionKey()).thenReturn(encCredentialsKey);
			(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionMode()).thenReturn(CredentialEncryptionMode.DEVICE_LOCK);
			(0, import_testdouble.when)(credentialsDb.getCredentialsByUserId("user1")).thenReturn(encryptedCredentials1);
			(0, import_testdouble.when)(keychainEncryption.decryptUsingKeychain(encCredentialsKey, CredentialEncryptionMode.DEVICE_LOCK)).thenResolve(decCredentialsKey);
			(0, import_testdouble.when)(crypto.aesDecryptBytes(uint8ArrayToBitArray(decCredentialsKey), encryptedCredentials1.databaseKey)).thenReturn(decryptedCredentials1.databaseKey);
			(0, import_testdouble.when)(crypto.aesDecryptBytes(uint8ArrayToBitArray(decCredentialsKey), encryptedCredentials1.accessToken)).thenReturn(stringToUtf8Uint8Array(decryptedCredentials1.accessToken));
			const decryptedCredentials = await facade.loadByUserId("user1");
			dist_default(decryptedCredentials).deepEquals(decryptedCredentials1);
		});
		dist_default.test("when there is a key it is used to decrypt credentials w/ passphrase key", async () => {
			(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionKey()).thenReturn(encCredentialsKey);
			(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionMode()).thenReturn(CredentialEncryptionMode.DEVICE_LOCK);
			(0, import_testdouble.when)(credentialsDb.getCredentialsByUserId("user2")).thenReturn(encryptedCredentials2);
			(0, import_testdouble.when)(keychainEncryption.decryptUsingKeychain(encCredentialsKey, CredentialEncryptionMode.DEVICE_LOCK)).thenResolve(decCredentialsKey);
			(0, import_testdouble.when)(crypto.aesDecryptBytes(uint8ArrayToBitArray(decCredentialsKey), encryptedCredentials2.databaseKey)).thenReturn(decryptedCredentials2.databaseKey);
			(0, import_testdouble.when)(crypto.aesDecryptBytes(uint8ArrayToBitArray(decCredentialsKey), encryptedCredentials2.accessToken)).thenReturn(stringToUtf8Uint8Array(decryptedCredentials2.accessToken));
			const decryptedCredentials = await facade.loadByUserId("user2");
			dist_default(decryptedCredentials).deepEquals(decryptedCredentials2);
		});
		dist_default.test("when another mode is selected it is used", async () => {
			(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionKey()).thenReturn(encCredentialsKey);
			(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionMode()).thenReturn(CredentialEncryptionMode.APP_PASSWORD);
			(0, import_testdouble.when)(credentialsDb.getCredentialsByUserId("user1")).thenReturn(encryptedCredentials1);
			(0, import_testdouble.when)(keychainEncryption.decryptUsingKeychain(encCredentialsKey, CredentialEncryptionMode.APP_PASSWORD)).thenResolve(decCredentialsKey);
			(0, import_testdouble.when)(crypto.aesDecryptBytes(uint8ArrayToBitArray(decCredentialsKey), encryptedCredentials1.databaseKey)).thenReturn(decryptedCredentials1.databaseKey);
			(0, import_testdouble.when)(crypto.aesDecryptBytes(uint8ArrayToBitArray(decCredentialsKey), encryptedCredentials1.accessToken)).thenReturn(stringToUtf8Uint8Array(decryptedCredentials1.accessToken));
			const decryptedCredentials = await facade.loadByUserId("user1");
			dist_default(decryptedCredentials).deepEquals(decryptedCredentials1);
		});
		dist_default.spec("store", () => {
			dist_default.test("when there is a key, it is used", async () => {
				(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionKey()).thenReturn(encCredentialsKey);
				(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionMode()).thenReturn(CredentialEncryptionMode.DEVICE_LOCK);
				(0, import_testdouble.when)(credentialsDb.getCredentialsByUserId("user1")).thenReturn(encryptedCredentials1);
				(0, import_testdouble.when)(keychainEncryption.decryptUsingKeychain(encCredentialsKey, CredentialEncryptionMode.DEVICE_LOCK)).thenResolve(decCredentialsKey);
				(0, import_testdouble.when)(crypto.aesEncryptBytes(uint8ArrayToBitArray(decCredentialsKey), decryptedCredentials1.databaseKey)).thenReturn(encryptedCredentials1.databaseKey);
				(0, import_testdouble.when)(crypto.aesEncryptBytes(uint8ArrayToBitArray(decCredentialsKey), stringToUtf8Uint8Array(decryptedCredentials1.accessToken))).thenReturn(encryptedCredentials1.accessToken);
				await facade.store(decryptedCredentials1);
				(0, import_testdouble.verify)(credentialsDb.store(encryptedCredentials1));
			});
			dist_default.test("when there is no key, it generates and stores one", async () => {
				(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionKey()).thenReturn(null);
				(0, import_testdouble.when)(crypto.generateDeviceKey()).thenReturn(uint8ArrayToBitArray(decCredentialsKey));
				(0, import_testdouble.when)(credentialsDb.getCredentialEncryptionMode()).thenReturn(CredentialEncryptionMode.DEVICE_LOCK);
				(0, import_testdouble.when)(credentialsDb.getCredentialsByUserId("user1")).thenReturn(encryptedCredentials1);
				(0, import_testdouble.when)(crypto.aesEncryptBytes(uint8ArrayToBitArray(decCredentialsKey), decryptedCredentials1.databaseKey)).thenReturn(encryptedCredentials1.databaseKey);
				(0, import_testdouble.when)(crypto.aesEncryptBytes(uint8ArrayToBitArray(decCredentialsKey), stringToUtf8Uint8Array(decryptedCredentials1.accessToken))).thenReturn(encryptedCredentials1.accessToken);
				(0, import_testdouble.when)(keychainEncryption.encryptUsingKeychain(decCredentialsKey, CredentialEncryptionMode.DEVICE_LOCK)).thenResolve(encCredentialsKey);
				await facade.store(decryptedCredentials1);
				(0, import_testdouble.verify)(credentialsDb.store(encryptedCredentials1));
				(0, import_testdouble.verify)(credentialsDb.setCredentialEncryptionKey(encCredentialsKey));
			});
		});
		dist_default.test("migrate stores everything", async () => {
			await facade.migrateToNativeCredentials([encryptedCredentials1, encryptedCredentials2], CredentialEncryptionMode.APP_PASSWORD, encCredentialsKey);
			(0, import_testdouble.verify)(credentialsDb.setCredentialEncryptionMode(CredentialEncryptionMode.APP_PASSWORD));
			(0, import_testdouble.verify)(credentialsDb.setCredentialEncryptionKey(encCredentialsKey));
			(0, import_testdouble.verify)(credentialsDb.store(encryptedCredentials1));
			(0, import_testdouble.verify)(credentialsDb.store(encryptedCredentials2));
		});
	});
});

//#endregion
//# sourceMappingURL=DesktopNativeCredentialsFacadeTest-CV9nQp4l.js.map