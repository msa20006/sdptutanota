
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { assertNotNull, splitUint8ArrayInChunks, stringToUtf8Uint8Array, uint8ArrayToBase64, uint8ArrayToHex } from "./dist-CJHwsXKY.js";
import { lang } from "./LanguageViewModel-BNC5ekpO.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import { FileOpenError } from "./FileOpenError-C1_8yoXr.js";
import { sha256Hash } from "./dist-DcZ1Y4qd.js";
import { BuildConfigKey, DesktopConfigKey } from "./ConfigKeys-B1UD5FwS.js";
import { log } from "./DesktopLog-yAgEoQsh.js";
import { looksExecutable, nonClobberingFilename } from "./PathUtils-DFfSo_TG.js";
import path from "node:path";
import url from "node:url";
import { Buffer } from "node:buffer";
import stream from "node:stream";

//#region ../src/common/desktop/files/DesktopFileFacade.ts
const TAG = "[DesktopFileFacade]";
var DesktopFileFacade = class {
	/** We don't want to spam opening file manager all the time so we throttle it. This field is set to the last time we opened it. */
	lastOpenedFileManagerAt;
	constructor(win, conf, dateProvider, fetch, electron, tfs, fs) {
		this.win = win;
		this.conf = conf;
		this.dateProvider = dateProvider;
		this.fetch = fetch;
		this.electron = electron;
		this.tfs = tfs;
		this.fs = fs;
		this.lastOpenedFileManagerAt = null;
	}
	clearFileData() {
		this.tfs.clear();
		return Promise.resolve();
	}
	async deleteFile(filename) {
		return await this.fs.promises.unlink(filename);
	}
	async download(sourceUrl, fileName, headers) {
		const { status, headers: headersIncoming, body } = await this.fetch(sourceUrl, {
			method: "GET",
			headers
		});
		let encryptedFilePath;
		if (status == 200 && body != null) {
			const downloadDirectory = await this.tfs.ensureEncryptedDir();
			encryptedFilePath = path.join(downloadDirectory, fileName);
			const readable = bodyToReadable(body);
			await this.pipeIntoFile(readable, encryptedFilePath);
		} else encryptedFilePath = null;
		const result = {
			statusCode: status,
			encryptedFileUri: encryptedFilePath,
			errorId: getHttpHeader(headersIncoming, "error-id"),
			precondition: getHttpHeader(headersIncoming, "precondition"),
			suspensionTime: getHttpHeader(headersIncoming, "suspension-time") ?? getHttpHeader(headersIncoming, "retry-after")
		};
		log.info(TAG, "Download finished", result.statusCode, result.suspensionTime);
		return result;
	}
	async pipeIntoFile(response, encryptedFilePath) {
		const fileStream = this.fs.createWriteStream(encryptedFilePath, { emitClose: true });
		try {
			await pipeStream(response, fileStream);
			await closeFileStream(fileStream);
		} catch (e) {
			await closeFileStream(fileStream);
			await this.fs.promises.unlink(encryptedFilePath);
			throw e;
		}
	}
	async getMimeType(file) {
		return await getMimeTypeForFile(file);
	}
	async getName(file) {
		return path.basename(file);
	}
	async getSize(fileUri) {
		const stats = await this.fs.promises.stat(fileUri);
		return stats.size;
	}
	async hashFile(fileUri) {
		const data = await this.fs.promises.readFile(fileUri);
		const checksum = sha256Hash(data).slice(0, 6);
		return uint8ArrayToBase64(checksum);
	}
	async joinFiles(filename, files) {
		const downloadDirectory = await this.tfs.ensureUnencrytpedDir();
		const filesInDirectory = await this.fs.promises.readdir(downloadDirectory);
		const newFilename = nonClobberingFilename(filesInDirectory, filename);
		const fileUri = path.join(downloadDirectory, newFilename);
		const outStream = this.fs.createWriteStream(fileUri, { autoClose: false });
		for (const infile of files) await new Promise((resolve, reject) => {
			const readStream = this.fs.createReadStream(infile);
			readStream.on("end", resolve);
			readStream.on("error", reject);
			readStream.pipe(outStream, { end: false });
		});
		await closeFileStream(outStream);
		return fileUri;
	}
	open(location) {
		const tryOpen = () => this.electron.shell.openPath(location).catch(() => "failed to open path.").then((errMsg) => errMsg === "" ? Promise.resolve() : Promise.reject(new FileOpenError("Could not open " + location + ", " + errMsg)));
		if (process.platform === "win32" && looksExecutable(location)) return this.electron.dialog.showMessageBox({
			type: "warning",
			buttons: [lang.get("yes_label"), lang.get("no_label")],
			title: lang.get("executableOpen_label"),
			message: lang.get("executableOpen_msg"),
			defaultId: 1
		}).then(({ response }) => {
			if (response === 0) return tryOpen();
else return Promise.resolve();
		});
else return tryOpen();
	}
	async openFileChooser(boundingRect, filter) {
		const opts = { properties: ["openFile", "multiSelections"] };
		if (filter != null) opts.filters = [{
			name: "Filter",
			extensions: filter.slice()
		}];
		const { filePaths } = await this.electron.dialog.showOpenDialog(this.win._browserWindow, opts);
		return filePaths;
	}
	openFolderChooser() {
		return this.electron.dialog.showOpenDialog(this.win._browserWindow, { properties: ["openDirectory"] }).then(({ filePaths }) => filePaths[0] ?? null);
	}
	async putFileIntoDownloadsFolder(localFileUri, fileNameToUse) {
		const savePath = await this.pickSavePath(fileNameToUse);
		await this.fs.promises.mkdir(path.dirname(savePath), { recursive: true });
		await this.fs.promises.copyFile(localFileUri, savePath);
		await this.showInFileExplorer(savePath);
		return savePath;
	}
	async splitFile(fileUri, maxChunkSizeBytes) {
		const tempDir = await this.tfs.ensureUnencrytpedDir();
		const fullBytes = await this.fs.promises.readFile(fileUri);
		const chunks = splitUint8ArrayInChunks(maxChunkSizeBytes, fullBytes);
		const filenameHash = uint8ArrayToHex(sha256Hash(stringToUtf8Uint8Array(fileUri)));
		const chunkPaths = [];
		for (let i = 0; i < chunks.length; i++) {
			const chunk = chunks[i];
			const fileName = `${filenameHash}.${i}.blob`;
			const chunkPath = path.join(tempDir, fileName);
			await this.fs.promises.writeFile(chunkPath, chunk);
			chunkPaths.push(chunkPath);
		}
		return chunkPaths;
	}
	async upload(fileUri, targetUrl, method, headers) {
		const fileStream = this.fs.createReadStream(fileUri);
		const stat = await this.fs.promises.stat(fileUri);
		headers["Content-Length"] = `${stat.size}`;
		const response = await this.fetch(targetUrl, {
			method,
			headers,
			body: fileStream
		});
		let responseBody;
		if ((response.status == 200 || response.status == 201) && response.body != null) {
			const readable = bodyToReadable(response.body);
			responseBody = await readStreamToBuffer(readable);
		} else responseBody = new Uint8Array([]);
		return {
			statusCode: assertNotNull(response.status),
			errorId: getHttpHeader(response.headers, "error-id"),
			precondition: getHttpHeader(response.headers, "precondition"),
			suspensionTime: getHttpHeader(response.headers, "suspension-time") ?? getHttpHeader(response.headers, "retry-after"),
			responseBody
		};
	}
	async writeDataFile(file) {
		return await this.tfs.writeToDisk(file.data, "decrypted");
	}
	async writeDataFileToDirectory(file, directory) {
		const filePath = path.join(directory, file.name);
		await this.fs.promises.writeFile(filePath, file.data);
		return filePath;
	}
	async readDataFile(uriOrPath) {
		try {
			uriOrPath = url.fileURLToPath(uriOrPath);
		} catch (e) {}
		const name = path.basename(uriOrPath);
		try {
			const [data, mimeType] = await Promise.all([this.fs.promises.readFile(uriOrPath), this.getMimeType(uriOrPath)]);
			if (data == null) return null;
			return {
				_type: "DataFile",
				data,
				name,
				mimeType,
				size: data.length,
				id: undefined
			};
		} catch (e) {
			return null;
		}
	}
	/** select a non-colliding name in the configured downloadPath, preferably with the given file name
	* public for testing */
	async pickSavePath(filename) {
		const defaultDownloadPath = await this.conf.getVar(DesktopConfigKey.defaultDownloadPath);
		if (defaultDownloadPath != null) {
			const fileName = path.basename(filename);
			return path.join(defaultDownloadPath, nonClobberingFilename(await this.fs.promises.readdir(defaultDownloadPath), fileName));
		} else {
			const { canceled, filePath } = await this.electron.dialog.showSaveDialog({ defaultPath: path.join(this.electron.app.getPath("downloads"), filename) });
			if (canceled) throw new CancelledError("Path selection cancelled");
else return assertNotNull(filePath);
		}
	}
	/** public for testing */
	async showInFileExplorer(savePath) {
		const lastOpenedFileManagerAt = this.lastOpenedFileManagerAt;
		const fileManagerTimeout = await this.conf.getConst(BuildConfigKey.fileManagerTimeout);
		if (lastOpenedFileManagerAt == null || this.dateProvider.now() - lastOpenedFileManagerAt > fileManagerTimeout) {
			this.lastOpenedFileManagerAt = this.dateProvider.now();
			await this.electron.shell.openPath(path.dirname(savePath));
		}
	}
};
async function getMimeTypeForFile(file) {
	const ext = path.extname(file).slice(1);
	const { mimes } = await import("./flat-mimes-DZbizB8i.js");
	const candidates = mimes[ext];
	return candidates != null ? candidates[0] : "application/octet-stream";
}
function closeFileStream(stream$1) {
	return new Promise((resolve) => {
		stream$1.on("close", resolve);
		stream$1.close();
	});
}
async function readStreamToBuffer(stream$1) {
	return new Promise((resolve, reject) => {
		const data = [];
		stream$1.on("data", (chunk) => {
			data.push(chunk);
		});
		stream$1.on("end", () => {
			resolve(Buffer.concat(data));
		});
		stream$1.on("error", (err) => {
			reject(err);
		});
	});
}
function getHttpHeader(headers, name) {
	return headers.get(name.toLowerCase());
}
function pipeStream(stream$1, into) {
	return new Promise((resolve, reject) => {
		stream$1.on("error", reject);
		stream$1.pipe(into);
		into.on("finish", resolve);
		into.on("error", reject);
	});
}
function bodyToReadable(body) {
	return stream.Readable.fromWeb(body);
}

//#endregion
export { DesktopFileFacade, getMimeTypeForFile };
//# sourceMappingURL=DesktopFileFacade-o-Coc2Lq.js.map