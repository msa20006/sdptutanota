{"version":3,"file":"Urlifier-0Ec01nef.js","names":["nextState","defaultRender","scheme","tokenize","EntityParser","EventedTokenizer","Tokenizer","html: string"],"sources":["../../libs/linkify.js","../../libs/linkify-html.js","../../src/common/api/worker/Urlifier.ts"],"sourcesContent":["// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\n * @template A\n * @template B\n * @param {A} target\n * @param {B} properties\n * @return {A & B}\n */\nconst assign = (target, properties) => {\n  for (const key in properties) {\n    target[key] = properties[key];\n  }\n  return target;\n};\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nconst numeric = 'numeric';\nconst ascii = 'ascii';\nconst alpha = 'alpha';\nconst asciinumeric = 'asciinumeric';\nconst alphanumeric = 'alphanumeric';\nconst domain = 'domain';\nconst emoji = 'emoji';\nconst scheme = 'scheme';\nconst slashscheme = 'slashscheme';\nconst whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (const k in flags) {\n    const group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  const result = {};\n  for (const c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State(token) {\n  if (token === void 0) {\n    token = null;\n  }\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go(input) {\n    const state = this;\n    const nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (let i = 0; i < state.jr.length; i++) {\n      const regex = state.jr[i][0];\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (nextState && regex.test(input)) {\n        return nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has(input, exactOnly) {\n    if (exactOnly === void 0) {\n      exactOnly = false;\n    }\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta(inputs, next, flags, groups) {\n    for (let i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    let nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts(input, next, flags, groups) {\n    let state = this;\n    const len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (let i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    const state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    const t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    let nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          const allFlags = assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nconst WORD = 'WORD'; // only contains a-z\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\n\n// Special case of word\nconst LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nconst NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nconst WS = 'WS';\n\n// New line (unix style)\nconst NL$1 = 'NL'; // \\n\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nconst OPENBRACE = 'OPENBRACE'; // {\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\nconst OPENBRACKET = 'OPENBRACKET'; // [\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nconst OPENPAREN = 'OPENPAREN'; // (\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nconst FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // （\nconst FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // ）\nconst LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // 「\nconst RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // 」\nconst LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // 『\nconst RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // 』\nconst FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // ＜\nconst FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // ＞\n\n// Various symbols\nconst AMPERSAND = 'AMPERSAND'; // &\nconst APOSTROPHE = 'APOSTROPHE'; // '\nconst ASTERISK = 'ASTERISK'; // *\nconst AT = 'AT'; // @\nconst BACKSLASH = 'BACKSLASH'; // \\\nconst BACKTICK = 'BACKTICK'; // `\nconst CARET = 'CARET'; // ^\nconst COLON = 'COLON'; // :\nconst COMMA = 'COMMA'; // ,\nconst DOLLAR = 'DOLLAR'; // $\nconst DOT = 'DOT'; // .\nconst EQUALS = 'EQUALS'; // =\nconst EXCLAMATION = 'EXCLAMATION'; // !\nconst HYPHEN = 'HYPHEN'; // -\nconst PERCENT = 'PERCENT'; // %\nconst PIPE = 'PIPE'; // |\nconst PLUS = 'PLUS'; // +\nconst POUND = 'POUND'; // #\nconst QUERY = 'QUERY'; // ?\nconst QUOTE = 'QUOTE'; // \"\n\nconst SEMI = 'SEMI'; // ;\nconst SLASH = 'SLASH'; // /\nconst TILDE = 'TILDE'; // ~\nconst UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nconst EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nconst SYM = 'SYM';\n\nvar tk = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tWORD: WORD,\n\tUWORD: UWORD,\n\tLOCALHOST: LOCALHOST,\n\tTLD: TLD,\n\tUTLD: UTLD,\n\tSCHEME: SCHEME,\n\tSLASH_SCHEME: SLASH_SCHEME,\n\tNUM: NUM,\n\tWS: WS,\n\tNL: NL$1,\n\tOPENBRACE: OPENBRACE,\n\tCLOSEBRACE: CLOSEBRACE,\n\tOPENBRACKET: OPENBRACKET,\n\tCLOSEBRACKET: CLOSEBRACKET,\n\tOPENPAREN: OPENPAREN,\n\tCLOSEPAREN: CLOSEPAREN,\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n\tFULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n\tFULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n\tLEFTCORNERBRACKET: LEFTCORNERBRACKET,\n\tRIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n\tLEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n\tRIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n\tFULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n\tFULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n\tAMPERSAND: AMPERSAND,\n\tAPOSTROPHE: APOSTROPHE,\n\tASTERISK: ASTERISK,\n\tAT: AT,\n\tBACKSLASH: BACKSLASH,\n\tBACKTICK: BACKTICK,\n\tCARET: CARET,\n\tCOLON: COLON,\n\tCOMMA: COMMA,\n\tDOLLAR: DOLLAR,\n\tDOT: DOT,\n\tEQUALS: EQUALS,\n\tEXCLAMATION: EXCLAMATION,\n\tHYPHEN: HYPHEN,\n\tPERCENT: PERCENT,\n\tPIPE: PIPE,\n\tPLUS: PLUS,\n\tPOUND: POUND,\n\tQUERY: QUERY,\n\tQUOTE: QUOTE,\n\tSEMI: SEMI,\n\tSLASH: SLASH,\n\tTILDE: TILDE,\n\tUNDERSCORE: UNDERSCORE,\n\tEMOJI: EMOJI$1,\n\tSYM: SYM\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\n\nvar regexp = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tASCII_LETTER: ASCII_LETTER,\n\tLETTER: LETTER,\n\tEMOJI: EMOJI,\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\n\tDIGIT: DIGIT,\n\tSPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\nconst NL = '\\n'; // New line character\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\n\nlet tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2(customSchemes) {\n  if (customSchemes === void 0) {\n    customSchemes = [];\n  }\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  const groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  const Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, '（', FULLWIDTHLEFTPAREN);\n  tt(Start, '）', FULLWIDTHRIGHTPAREN);\n  tt(Start, '「', LEFTCORNERBRACKET);\n  tt(Start, '」', RIGHTCORNERBRACKET);\n  tt(Start, '『', LEFTWHITECORNERBRACKET);\n  tt(Start, '』', RIGHTWHITECORNERBRACKET);\n  tt(Start, '＜', FULLWIDTHLESSTHAN);\n  tt(Start, '＞', FULLWIDTHGREATERTHAN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  const Num = tr(Start, DIGIT, NUM, {\n    [numeric]: true\n  });\n  tr(Num, DIGIT, Num);\n\n  // State which emits a word token\n  const Word = tr(Start, ASCII_LETTER, WORD, {\n    [ascii]: true\n  });\n  tr(Word, ASCII_LETTER, Word);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  const UWord = tr(Start, LETTER, UWORD, {\n    [alpha]: true\n  });\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, LETTER, UWord);\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  const Ws = tr(Start, SPACE, WS, {\n    [whitespace]: true\n  });\n  tt(Start, NL, NL$1, {\n    [whitespace]: true\n  });\n  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\n    [emoji]: true\n  });\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  const wordjr = [[ASCII_LETTER, Word]];\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];\n  for (let i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (let i = 0; i < utlds.length; i++) {\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  for (let i = 0; i < customSchemes.length; i++) {\n    const sch = customSchemes[i][0];\n    const optionalSlashSlash = customSchemes[i][1];\n    const flags = optionalSlashSlash ? {\n      [scheme]: true\n    } : {\n      [slashscheme]: true\n    };\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: assign({\n      groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\n  const charCount = iterable.length; // <= len if there are emojis, etc\n  const tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  let cursor = 0;\n\n  // Cursor through the array-representation of the string\n  let charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    let state = start;\n    let nextState = null;\n    let tokenLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    let charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  const result = [];\n  const len = str.length;\n  let index = 0;\n  while (index < len) {\n    let first = str.charCodeAt(index);\n    let second;\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  let next;\n  const len = input.length;\n  for (let i = 0; i < len - 1; i++) {\n    const char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  const words = [];\n  const stack = [];\n  let i = 0;\n  let digits = '0123456789';\n  while (i < encoded.length) {\n    let popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nconst defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts, defaultRender) {\n  if (defaultRender === void 0) {\n    defaultRender = null;\n  }\n  let o = assign({}, defaults);\n  if (opts) {\n    o = assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  const ignoredTags = o.ignoreTags;\n  const uppercaseIgnoredTags = [];\n  for (let i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get(key, operator, token) {\n    const isCallable = operator != null;\n    let option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj(key, operator, token) {\n    let obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render(token) {\n    const ir = token.render(this); // intermediate representation\n    const renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\n\nvar options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefaults: defaults,\n\tOptions: Options,\n\tassign: assign\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n  */\n  toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString(options) {\n    const val = this.toString();\n    const truncate = options.get('truncate', val, this);\n    const formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject(protocol) {\n    if (protocol === void 0) {\n      protocol = defaults.defaultProtocol;\n    }\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render(options) {\n    const token = this;\n    const href = this.toHref(options.get('defaultProtocol'));\n    const formattedHref = options.get('formatHref', href, this);\n    const tagName = options.get('tagName', href, token);\n    const content = this.toFormattedString(options);\n    const attributes = {};\n    const className = options.get('className', href, token);\n    const target = options.get('target', href, token);\n    const rel = options.get('rel', href, token);\n    const attrs = options.getObj('attributes', href, token);\n    const eventListeners = options.getObj('events', href, token);\n    attributes.href = formattedHref;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      assign(attributes, attrs);\n    }\n    return {\n      tagName,\n      attributes,\n      content,\n      eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  class Token extends MultiToken {\n    constructor(value, tokens) {\n      super(value, tokens);\n      this.t = type;\n    }\n  }\n  for (const p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nconst Email = createTokenClass('email', {\n  isLink: true,\n  toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nconst Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nconst Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nconst Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref(scheme) {\n    if (scheme === void 0) {\n      scheme = defaults.defaultProtocol;\n    }\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol() {\n    const tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\n\nvar multi = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tMultiToken: MultiToken,\n\tBase: MultiToken,\n\tcreateTokenClass: createTokenClass,\n\tEmail: Email,\n\tText: Text,\n\tNl: Nl,\n\tUrl: Url\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\nconst makeState = arg => new State(arg);\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1(_ref) {\n  let {\n    groups\n  } = _ref;\n  // Types of characters the URL can definitely end in\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  const Start = makeState();\n  const Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  const Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  const EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  const Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(SchemeColon, groups.domain, Url$1);\n  tt(SchemeColon, SLASH, Url$1);\n  ta(UriPrefix, groups.domain, Url$1);\n  ta(UriPrefix, qsAccepting, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n  const bracketPairs = [[OPENBRACE, CLOSEBRACE],\n  // {}\n  [OPENBRACKET, CLOSEBRACKET],\n  // []\n  [OPENPAREN, CLOSEPAREN],\n  // ()\n  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],\n  // <>\n  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],\n  // （）\n  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],\n  // 「」\n  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],\n  // 『』\n  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // ＜＞\n  ];\n\n  for (let i = 0; i < bracketPairs.length; i++) {\n    const [OPEN, CLOSE] = bracketPairs[i];\n    const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n\n    // Continue not accepting for open brackets\n    tt(UrlNonaccept, OPEN, UrlOpen);\n\n    // Closing bracket component. This character WILL be included in the URL\n    tt(UrlOpen, CLOSE, Url$1);\n\n    // URL that beings with an opening bracket, followed by a symbols.\n    // Note that the final state can still be `UrlOpen` (if the URL has a\n    // single opening bracket for some reason).\n    const UrlOpenQ = makeState(Url);\n    ta(UrlOpen, qsAccepting, UrlOpenQ);\n    const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n    ta(UrlOpen, qsNonAccepting);\n\n    // URL that begins with an opening bracket, followed by some symbols\n    ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n\n    // Close brace/bracket to become regular URL\n    tt(UrlOpenQ, CLOSE, Url$1);\n    tt(UrlOpenSyms, CLOSE, Url$1);\n  }\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL$1, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  let len = tokens.length;\n  let cursor = 0;\n  let multis = [];\n  let textTokens = [];\n  while (cursor < len) {\n    let state = start;\n    let secondState = null;\n    let nextState = null;\n    let multiLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      const Multi = latestAccepting.t;\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  const startIdx = tokens[0].s;\n  const endIdx = tokens[tokens.length - 1].e;\n  const value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\n\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nconst INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} protocol\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash) {\n  if (optionalSlashSlash === void 0) {\n    optionalSlashSlash = false;\n  }\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error(`linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat`);\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    INIT.pluginQueue[i][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */\nfunction find(str, type, opts) {\n  if (type === void 0) {\n    type = null;\n  }\n  if (opts === void 0) {\n    opts = null;\n  }\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n    }\n    opts = type;\n    type = null;\n  }\n  const options = new Options(opts);\n  const tokens = tokenize(str);\n  const filtered = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.isLink && (!type || token.t === type) && options.check(token)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str, type) {\n  if (type === void 0) {\n    type = null;\n  }\n  const tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, tokenize };\n","import { Options, tokenize as tokenize$1 } from 'linkifyjs';\n\n/**\n * generated from https://raw.githubusercontent.com/w3c/html/26b5126f96f736f796b9e29718138919dd513744/entities.json\n * do not edit\n */\nvar HTML5NamedCharRefs = {\n  // We don't need the complete named character reference because linkifyHtml\n  // does not modify the escape sequences. We do need &nbsp; so that\n  // whitespace is parsed properly. Other types of whitespace should already\n  // be accounted for. &gt; &lt; and &quot; are also frequently relevant ones\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  nbsp: \" \",\n  quot: \"\\\"\"\n};\nvar HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;\nvar CHARCODE = /^#([0-9]+)$/;\nvar NAMED = /^([A-Za-z0-9]+)$/;\nvar EntityParser = /** @class */function () {\n  function EntityParser(named) {\n    this.named = named;\n  }\n  EntityParser.prototype.parse = function (entity) {\n    if (!entity) {\n      return;\n    }\n    var matches = entity.match(HEXCHARCODE);\n    if (matches) {\n      return String.fromCharCode(parseInt(matches[1], 16));\n    }\n    matches = entity.match(CHARCODE);\n    if (matches) {\n      return String.fromCharCode(parseInt(matches[1], 10));\n    }\n    matches = entity.match(NAMED);\n    if (matches) {\n      return this.named[matches[1]] || \"&\" + matches[1] + \";\";\n    }\n  };\n  return EntityParser;\n}();\nvar WSP = /[\\t\\n\\f ]/;\nvar ALPHA = /[A-Za-z]/;\nvar CRLF = /\\r\\n?/g;\nfunction isSpace(char) {\n  return WSP.test(char);\n}\nfunction isAlpha(char) {\n  return ALPHA.test(char);\n}\nfunction preprocessInput(input) {\n  return input.replace(CRLF, '\\n');\n}\nvar EventedTokenizer = /** @class */function () {\n  function EventedTokenizer(delegate, entityParser, mode) {\n    if (mode === void 0) {\n      mode = 'precompile';\n    }\n    this.delegate = delegate;\n    this.entityParser = entityParser;\n    this.mode = mode;\n    this.state = \"beforeData\" /* beforeData */;\n    this.line = -1;\n    this.column = -1;\n    this.input = '';\n    this.index = -1;\n    this.tagNameBuffer = '';\n    this.states = {\n      beforeData: function () {\n        var char = this.peek();\n        if (char === '<' && !this.isIgnoredEndTag()) {\n          this.transitionTo(\"tagOpen\" /* tagOpen */);\n          this.markTagStart();\n          this.consume();\n        } else {\n          if (this.mode === 'precompile' && char === '\\n') {\n            var tag = this.tagNameBuffer.toLowerCase();\n            if (tag === 'pre' || tag === 'textarea') {\n              this.consume();\n            }\n          }\n          this.transitionTo(\"data\" /* data */);\n          this.delegate.beginData();\n        }\n      },\n      data: function () {\n        var char = this.peek();\n        var tag = this.tagNameBuffer;\n        if (char === '<' && !this.isIgnoredEndTag()) {\n          this.delegate.finishData();\n          this.transitionTo(\"tagOpen\" /* tagOpen */);\n          this.markTagStart();\n          this.consume();\n        } else if (char === '&' && tag !== 'script' && tag !== 'style') {\n          this.consume();\n          this.delegate.appendToData(this.consumeCharRef() || '&');\n        } else {\n          this.consume();\n          this.delegate.appendToData(char);\n        }\n      },\n      tagOpen: function () {\n        var char = this.consume();\n        if (char === '!') {\n          this.transitionTo(\"markupDeclarationOpen\" /* markupDeclarationOpen */);\n        } else if (char === '/') {\n          this.transitionTo(\"endTagOpen\" /* endTagOpen */);\n        } else if (char === '@' || char === ':' || isAlpha(char)) {\n          this.transitionTo(\"tagName\" /* tagName */);\n          this.tagNameBuffer = '';\n          this.delegate.beginStartTag();\n          this.appendToTagName(char);\n        }\n      },\n      markupDeclarationOpen: function () {\n        var char = this.consume();\n        if (char === '-' && this.peek() === '-') {\n          this.consume();\n          this.transitionTo(\"commentStart\" /* commentStart */);\n          this.delegate.beginComment();\n        } else {\n          var maybeDoctype = char.toUpperCase() + this.input.substring(this.index, this.index + 6).toUpperCase();\n          if (maybeDoctype === 'DOCTYPE') {\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.transitionTo(\"doctype\" /* doctype */);\n            if (this.delegate.beginDoctype) this.delegate.beginDoctype();\n          }\n        }\n      },\n      doctype: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeDoctypeName\" /* beforeDoctypeName */);\n        }\n      },\n\n      beforeDoctypeName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else {\n          this.transitionTo(\"doctypeName\" /* doctypeName */);\n          if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());\n        }\n      },\n      doctypeName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"afterDoctypeName\" /* afterDoctypeName */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());\n        }\n      },\n      afterDoctypeName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          var nextSixChars = char.toUpperCase() + this.input.substring(this.index, this.index + 5).toUpperCase();\n          var isPublic = nextSixChars.toUpperCase() === 'PUBLIC';\n          var isSystem = nextSixChars.toUpperCase() === 'SYSTEM';\n          if (isPublic || isSystem) {\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n          }\n          if (isPublic) {\n            this.transitionTo(\"afterDoctypePublicKeyword\" /* afterDoctypePublicKeyword */);\n          } else if (isSystem) {\n            this.transitionTo(\"afterDoctypeSystemKeyword\" /* afterDoctypeSystemKeyword */);\n          }\n        }\n      },\n\n      afterDoctypePublicKeyword: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeDoctypePublicIdentifier\" /* beforeDoctypePublicIdentifier */);\n          this.consume();\n        } else if (char === '\"') {\n          this.transitionTo(\"doctypePublicIdentifierDoubleQuoted\" /* doctypePublicIdentifierDoubleQuoted */);\n          this.consume();\n        } else if (char === \"'\") {\n          this.transitionTo(\"doctypePublicIdentifierSingleQuoted\" /* doctypePublicIdentifierSingleQuoted */);\n          this.consume();\n        } else if (char === '>') {\n          this.consume();\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        }\n      },\n\n      doctypePublicIdentifierDoubleQuoted: function () {\n        var char = this.consume();\n        if (char === '\"') {\n          this.transitionTo(\"afterDoctypePublicIdentifier\" /* afterDoctypePublicIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);\n        }\n      },\n      doctypePublicIdentifierSingleQuoted: function () {\n        var char = this.consume();\n        if (char === \"'\") {\n          this.transitionTo(\"afterDoctypePublicIdentifier\" /* afterDoctypePublicIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);\n        }\n      },\n      afterDoctypePublicIdentifier: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"betweenDoctypePublicAndSystemIdentifiers\" /* betweenDoctypePublicAndSystemIdentifiers */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '\"') {\n          this.transitionTo(\"doctypeSystemIdentifierDoubleQuoted\" /* doctypeSystemIdentifierDoubleQuoted */);\n        } else if (char === \"'\") {\n          this.transitionTo(\"doctypeSystemIdentifierSingleQuoted\" /* doctypeSystemIdentifierSingleQuoted */);\n        }\n      },\n\n      betweenDoctypePublicAndSystemIdentifiers: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '\"') {\n          this.transitionTo(\"doctypeSystemIdentifierDoubleQuoted\" /* doctypeSystemIdentifierDoubleQuoted */);\n        } else if (char === \"'\") {\n          this.transitionTo(\"doctypeSystemIdentifierSingleQuoted\" /* doctypeSystemIdentifierSingleQuoted */);\n        }\n      },\n\n      doctypeSystemIdentifierDoubleQuoted: function () {\n        var char = this.consume();\n        if (char === '\"') {\n          this.transitionTo(\"afterDoctypeSystemIdentifier\" /* afterDoctypeSystemIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);\n        }\n      },\n      doctypeSystemIdentifierSingleQuoted: function () {\n        var char = this.consume();\n        if (char === \"'\") {\n          this.transitionTo(\"afterDoctypeSystemIdentifier\" /* afterDoctypeSystemIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);\n        }\n      },\n      afterDoctypeSystemIdentifier: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        }\n      },\n\n      commentStart: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentStartDash\" /* commentStartDash */);\n        } else if (char === '>') {\n          this.delegate.finishComment();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.appendToCommentData(char);\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      commentStartDash: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentEnd\" /* commentEnd */);\n        } else if (char === '>') {\n          this.delegate.finishComment();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.appendToCommentData('-');\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      comment: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentEndDash\" /* commentEndDash */);\n        } else {\n          this.delegate.appendToCommentData(char);\n        }\n      },\n      commentEndDash: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentEnd\" /* commentEnd */);\n        } else {\n          this.delegate.appendToCommentData('-' + char);\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      commentEnd: function () {\n        var char = this.consume();\n        if (char === '>') {\n          this.delegate.finishComment();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.appendToCommentData('--' + char);\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      tagName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        } else if (char === '/') {\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '>') {\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.appendToTagName(char);\n        }\n      },\n      endTagName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n          this.tagNameBuffer = '';\n        } else if (char === '/') {\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n          this.tagNameBuffer = '';\n        } else if (char === '>') {\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n          this.tagNameBuffer = '';\n        } else {\n          this.appendToTagName(char);\n        }\n      },\n      beforeAttributeName: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n          return;\n        } else if (char === '/') {\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n          this.consume();\n        } else if (char === '>') {\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '=') {\n          this.delegate.reportSyntaxError('attribute name cannot start with equals sign');\n          this.transitionTo(\"attributeName\" /* attributeName */);\n          this.delegate.beginAttribute();\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        } else {\n          this.transitionTo(\"attributeName\" /* attributeName */);\n          this.delegate.beginAttribute();\n        }\n      },\n      attributeName: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.transitionTo(\"afterAttributeName\" /* afterAttributeName */);\n          this.consume();\n        } else if (char === '/') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '=') {\n          this.transitionTo(\"beforeAttributeValue\" /* beforeAttributeValue */);\n          this.consume();\n        } else if (char === '>') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '\"' || char === \"'\" || char === '<') {\n          this.delegate.reportSyntaxError(char + ' is not a valid character within attribute names');\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        } else {\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        }\n      },\n      afterAttributeName: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n          return;\n        } else if (char === '/') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '=') {\n          this.consume();\n          this.transitionTo(\"beforeAttributeValue\" /* beforeAttributeValue */);\n        } else if (char === '>') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.transitionTo(\"attributeName\" /* attributeName */);\n          this.delegate.beginAttribute();\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        }\n      },\n      beforeAttributeValue: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n        } else if (char === '\"') {\n          this.transitionTo(\"attributeValueDoubleQuoted\" /* attributeValueDoubleQuoted */);\n          this.delegate.beginAttributeValue(true);\n          this.consume();\n        } else if (char === \"'\") {\n          this.transitionTo(\"attributeValueSingleQuoted\" /* attributeValueSingleQuoted */);\n          this.delegate.beginAttributeValue(true);\n          this.consume();\n        } else if (char === '>') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.transitionTo(\"attributeValueUnquoted\" /* attributeValueUnquoted */);\n          this.delegate.beginAttributeValue(false);\n          this.consume();\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      attributeValueDoubleQuoted: function () {\n        var char = this.consume();\n        if (char === '\"') {\n          this.delegate.finishAttributeValue();\n          this.transitionTo(\"afterAttributeValueQuoted\" /* afterAttributeValueQuoted */);\n        } else if (char === '&') {\n          this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');\n        } else {\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      attributeValueSingleQuoted: function () {\n        var char = this.consume();\n        if (char === \"'\") {\n          this.delegate.finishAttributeValue();\n          this.transitionTo(\"afterAttributeValueQuoted\" /* afterAttributeValueQuoted */);\n        } else if (char === '&') {\n          this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');\n        } else {\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      attributeValueUnquoted: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        } else if (char === '/') {\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '&') {\n          this.consume();\n          this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');\n        } else if (char === '>') {\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.consume();\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      afterAttributeValueQuoted: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        } else if (char === '/') {\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '>') {\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        }\n      },\n\n      selfClosingStartTag: function () {\n        var char = this.peek();\n        if (char === '>') {\n          this.consume();\n          this.delegate.markTagAsSelfClosing();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        }\n      },\n\n      endTagOpen: function () {\n        var char = this.consume();\n        if (char === '@' || char === ':' || isAlpha(char)) {\n          this.transitionTo(\"endTagName\" /* endTagName */);\n          this.tagNameBuffer = '';\n          this.delegate.beginEndTag();\n          this.appendToTagName(char);\n        }\n      }\n    };\n    this.reset();\n  }\n  EventedTokenizer.prototype.reset = function () {\n    this.transitionTo(\"beforeData\" /* beforeData */);\n    this.input = '';\n    this.tagNameBuffer = '';\n    this.index = 0;\n    this.line = 1;\n    this.column = 0;\n    this.delegate.reset();\n  };\n  EventedTokenizer.prototype.transitionTo = function (state) {\n    this.state = state;\n  };\n  EventedTokenizer.prototype.tokenize = function (input) {\n    this.reset();\n    this.tokenizePart(input);\n    this.tokenizeEOF();\n  };\n  EventedTokenizer.prototype.tokenizePart = function (input) {\n    this.input += preprocessInput(input);\n    while (this.index < this.input.length) {\n      var handler = this.states[this.state];\n      if (handler !== undefined) {\n        handler.call(this);\n      } else {\n        throw new Error(\"unhandled state \" + this.state);\n      }\n    }\n  };\n  EventedTokenizer.prototype.tokenizeEOF = function () {\n    this.flushData();\n  };\n  EventedTokenizer.prototype.flushData = function () {\n    if (this.state === 'data') {\n      this.delegate.finishData();\n      this.transitionTo(\"beforeData\" /* beforeData */);\n    }\n  };\n\n  EventedTokenizer.prototype.peek = function () {\n    return this.input.charAt(this.index);\n  };\n  EventedTokenizer.prototype.consume = function () {\n    var char = this.peek();\n    this.index++;\n    if (char === '\\n') {\n      this.line++;\n      this.column = 0;\n    } else {\n      this.column++;\n    }\n    return char;\n  };\n  EventedTokenizer.prototype.consumeCharRef = function () {\n    var endIndex = this.input.indexOf(';', this.index);\n    if (endIndex === -1) {\n      return;\n    }\n    var entity = this.input.slice(this.index, endIndex);\n    var chars = this.entityParser.parse(entity);\n    if (chars) {\n      var count = entity.length;\n      // consume the entity chars\n      while (count) {\n        this.consume();\n        count--;\n      }\n      // consume the `;`\n      this.consume();\n      return chars;\n    }\n  };\n  EventedTokenizer.prototype.markTagStart = function () {\n    this.delegate.tagOpen();\n  };\n  EventedTokenizer.prototype.appendToTagName = function (char) {\n    this.tagNameBuffer += char;\n    this.delegate.appendToTagName(char);\n  };\n  EventedTokenizer.prototype.isIgnoredEndTag = function () {\n    var tag = this.tagNameBuffer;\n    return tag === 'title' && this.input.substring(this.index, this.index + 8) !== '</title>' || tag === 'style' && this.input.substring(this.index, this.index + 8) !== '</style>' || tag === 'script' && this.input.substring(this.index, this.index + 9) !== '</script>';\n  };\n  return EventedTokenizer;\n}();\nvar Tokenizer = /** @class */function () {\n  function Tokenizer(entityParser, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.options = options;\n    this.token = null;\n    this.startLine = 1;\n    this.startColumn = 0;\n    this.tokens = [];\n    this.tokenizer = new EventedTokenizer(this, entityParser, options.mode);\n    this._currentAttribute = undefined;\n  }\n  Tokenizer.prototype.tokenize = function (input) {\n    this.tokens = [];\n    this.tokenizer.tokenize(input);\n    return this.tokens;\n  };\n  Tokenizer.prototype.tokenizePart = function (input) {\n    this.tokens = [];\n    this.tokenizer.tokenizePart(input);\n    return this.tokens;\n  };\n  Tokenizer.prototype.tokenizeEOF = function () {\n    this.tokens = [];\n    this.tokenizer.tokenizeEOF();\n    return this.tokens[0];\n  };\n  Tokenizer.prototype.reset = function () {\n    this.token = null;\n    this.startLine = 1;\n    this.startColumn = 0;\n  };\n  Tokenizer.prototype.current = function () {\n    var token = this.token;\n    if (token === null) {\n      throw new Error('token was unexpectedly null');\n    }\n    if (arguments.length === 0) {\n      return token;\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      if (token.type === arguments[i]) {\n        return token;\n      }\n    }\n    throw new Error(\"token type was unexpectedly \" + token.type);\n  };\n  Tokenizer.prototype.push = function (token) {\n    this.token = token;\n    this.tokens.push(token);\n  };\n  Tokenizer.prototype.currentAttribute = function () {\n    return this._currentAttribute;\n  };\n  Tokenizer.prototype.addLocInfo = function () {\n    if (this.options.loc) {\n      this.current().loc = {\n        start: {\n          line: this.startLine,\n          column: this.startColumn\n        },\n        end: {\n          line: this.tokenizer.line,\n          column: this.tokenizer.column\n        }\n      };\n    }\n    this.startLine = this.tokenizer.line;\n    this.startColumn = this.tokenizer.column;\n  };\n  // Data\n  Tokenizer.prototype.beginDoctype = function () {\n    this.push({\n      type: \"Doctype\" /* Doctype */,\n      name: ''\n    });\n  };\n  Tokenizer.prototype.appendToDoctypeName = function (char) {\n    this.current(\"Doctype\" /* Doctype */).name += char;\n  };\n  Tokenizer.prototype.appendToDoctypePublicIdentifier = function (char) {\n    var doctype = this.current(\"Doctype\" /* Doctype */);\n    if (doctype.publicIdentifier === undefined) {\n      doctype.publicIdentifier = char;\n    } else {\n      doctype.publicIdentifier += char;\n    }\n  };\n  Tokenizer.prototype.appendToDoctypeSystemIdentifier = function (char) {\n    var doctype = this.current(\"Doctype\" /* Doctype */);\n    if (doctype.systemIdentifier === undefined) {\n      doctype.systemIdentifier = char;\n    } else {\n      doctype.systemIdentifier += char;\n    }\n  };\n  Tokenizer.prototype.endDoctype = function () {\n    this.addLocInfo();\n  };\n  Tokenizer.prototype.beginData = function () {\n    this.push({\n      type: \"Chars\" /* Chars */,\n      chars: ''\n    });\n  };\n  Tokenizer.prototype.appendToData = function (char) {\n    this.current(\"Chars\" /* Chars */).chars += char;\n  };\n  Tokenizer.prototype.finishData = function () {\n    this.addLocInfo();\n  };\n  // Comment\n  Tokenizer.prototype.beginComment = function () {\n    this.push({\n      type: \"Comment\" /* Comment */,\n      chars: ''\n    });\n  };\n  Tokenizer.prototype.appendToCommentData = function (char) {\n    this.current(\"Comment\" /* Comment */).chars += char;\n  };\n  Tokenizer.prototype.finishComment = function () {\n    this.addLocInfo();\n  };\n  // Tags - basic\n  Tokenizer.prototype.tagOpen = function () {};\n  Tokenizer.prototype.beginStartTag = function () {\n    this.push({\n      type: \"StartTag\" /* StartTag */,\n      tagName: '',\n      attributes: [],\n      selfClosing: false\n    });\n  };\n  Tokenizer.prototype.beginEndTag = function () {\n    this.push({\n      type: \"EndTag\" /* EndTag */,\n      tagName: ''\n    });\n  };\n  Tokenizer.prototype.finishTag = function () {\n    this.addLocInfo();\n  };\n  Tokenizer.prototype.markTagAsSelfClosing = function () {\n    this.current(\"StartTag\" /* StartTag */).selfClosing = true;\n  };\n  // Tags - name\n  Tokenizer.prototype.appendToTagName = function (char) {\n    this.current(\"StartTag\" /* StartTag */, \"EndTag\" /* EndTag */).tagName += char;\n  };\n  // Tags - attributes\n  Tokenizer.prototype.beginAttribute = function () {\n    this._currentAttribute = ['', '', false];\n  };\n  Tokenizer.prototype.appendToAttributeName = function (char) {\n    this.currentAttribute()[0] += char;\n  };\n  Tokenizer.prototype.beginAttributeValue = function (isQuoted) {\n    this.currentAttribute()[2] = isQuoted;\n  };\n  Tokenizer.prototype.appendToAttributeValue = function (char) {\n    this.currentAttribute()[1] += char;\n  };\n  Tokenizer.prototype.finishAttributeValue = function () {\n    this.current(\"StartTag\" /* StartTag */).attributes.push(this._currentAttribute);\n  };\n  Tokenizer.prototype.reportSyntaxError = function (message) {\n    this.current().syntaxError = message;\n  };\n  return Tokenizer;\n}();\nfunction tokenize(input, options) {\n  var tokenizer = new Tokenizer(new EntityParser(HTML5NamedCharRefs), options);\n  return tokenizer.tokenize(input);\n}\n\nconst LinkifyResult = 'LinkifyResult';\nconst StartTag = 'StartTag';\nconst EndTag = 'EndTag';\nconst Chars = 'Chars';\nconst Comment = 'Comment';\nconst Doctype = 'Doctype';\n\n/**\n * @param {string} str html string to link\n * @param {import('linkifyjs').Opts} [opts] linkify options\n * @returns {string} resulting string\n */\nfunction linkifyHtml(str, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // `tokens` and `token` in this section refer to tokens generated by the\n  // HTML parser, not linkify's parser\n  const tokens = tokenize(str);\n  const linkifiedTokens = [];\n  const linkified = [];\n  const options = new Options(opts, defaultRender);\n\n  // Linkify the tokens given by the parser\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type === StartTag) {\n      linkifiedTokens.push(token);\n\n      // Ignore all the contents of ignored tags\n      const tagName = token.tagName.toUpperCase();\n      const isIgnored = tagName === 'A' || options.ignoreTags.indexOf(tagName) >= 0;\n      if (!isIgnored) {\n        continue;\n      }\n      let preskipLen = linkifiedTokens.length;\n      skipTagTokens(tagName, tokens, ++i, linkifiedTokens);\n      i += linkifiedTokens.length - preskipLen - 1;\n    } else if (token.type !== Chars) {\n      // Skip this token, it's not important\n      linkifiedTokens.push(token);\n    } else {\n      // Valid text token, linkify it!\n      const linkifedChars = linkifyChars(token.chars, options);\n      linkifiedTokens.push.apply(linkifiedTokens, linkifedChars);\n    }\n  }\n\n  // Convert the tokens back into a string\n  for (let i = 0; i < linkifiedTokens.length; i++) {\n    const token = linkifiedTokens[i];\n    switch (token.type) {\n      case LinkifyResult:\n        linkified.push(token.rendered);\n        break;\n      case StartTag:\n        {\n          let link = '<' + token.tagName;\n          if (token.attributes.length > 0) {\n            link += ' ' + attributeArrayToStrings(token.attributes).join(' ');\n          }\n          if (token.selfClosing) {\n            link += ' /';\n          }\n          link += '>';\n          linkified.push(link);\n          break;\n        }\n      case EndTag:\n        linkified.push(`</${token.tagName}>`);\n        break;\n      case Chars:\n        linkified.push(escapeText(token.chars));\n        break;\n      case Comment:\n        linkified.push(`<!--${escapeText(token.chars)}-->`);\n        break;\n      case Doctype:\n        {\n          let doctype = `<!DOCTYPE ${token.name}`;\n          if (token.publicIdentifier) {\n            doctype += ` PUBLIC \"${token.publicIdentifier}\"`;\n          }\n          if (token.systemIdentifier) {\n            doctype += ` \"${token.systemIdentifier}\"`;\n          }\n          doctype += '>';\n          linkified.push(doctype);\n          break;\n        }\n    }\n  }\n  return linkified.join('');\n}\n\n/**\n\t`tokens` and `token` in this section referes to tokens returned by\n\t`linkify.tokenize`. `linkified` will contain HTML Parser-style tokens\n\t@param {string}\n\t@param {import('linkifyjs').Options}\n*/\nfunction linkifyChars(str, options) {\n  const tokens = tokenize$1(str);\n  const result = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.t === 'nl' && options.get('nl2br')) {\n      result.push({\n        type: StartTag,\n        tagName: 'br',\n        attributes: [],\n        selfClosing: true\n      });\n    } else if (!token.isLink || !options.check(token)) {\n      result.push({\n        type: Chars,\n        chars: token.toString()\n      });\n    } else {\n      result.push({\n        type: LinkifyResult,\n        rendered: options.render(token)\n      });\n    }\n  }\n  return result;\n}\n\n/**\n\tReturns a list of tokens skipped until the closing tag of tagName.\n\n\t* `tagName` is the closing tag which will prompt us to stop skipping\n\t* `tokens` is the array of tokens generated by HTML5Tokenizer which\n\t* `i` is the index immediately after the opening tag to skip\n\t* `skippedTokens` is an array which skipped tokens are being pushed into\n\n\tCaveats\n\n\t* Assumes that i is the first token after the given opening tagName\n\t* The closing tag will be skipped, but nothing after it\n\t* Will track whether there is a nested tag of the same type\n*/\nfunction skipTagTokens(tagName, tokens, i, skippedTokens) {\n  // number of tokens of this type on the [fictional] stack\n  let stackCount = 1;\n  while (i < tokens.length && stackCount > 0) {\n    let token = tokens[i];\n    if (token.type === StartTag && token.tagName.toUpperCase() === tagName) {\n      // Nested tag of the same type, \"add to stack\"\n      stackCount++;\n    } else if (token.type === EndTag && token.tagName.toUpperCase() === tagName) {\n      // Closing tag\n      stackCount--;\n    }\n    skippedTokens.push(token);\n    i++;\n  }\n\n  // Note that if stackCount > 0 here, the HTML is probably invalid\n  return skippedTokens;\n}\nfunction defaultRender(_ref) {\n  let {\n    tagName,\n    attributes,\n    content\n  } = _ref;\n  return `<${tagName} ${attributesToString(attributes)}>${escapeText(content)}</${tagName}>`;\n}\nfunction escapeText(text) {\n  return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\nfunction escapeAttr(attr) {\n  return attr.replace(/\"/g, '&quot;');\n}\nfunction attributesToString(attributes) {\n  const result = [];\n  for (const attr in attributes) {\n    const val = attributes[attr] + '';\n    result.push(`${attr}=\"${escapeAttr(val)}\"`);\n  }\n  return result.join(' ');\n}\nfunction attributeArrayToStrings(attrs) {\n  const attrStrs = [];\n  for (let i = 0; i < attrs.length; i++) {\n    const name = attrs[i][0];\n    const value = attrs[i][1] + '';\n    attrStrs.push(`${name}=\"${escapeAttr(value)}\"`);\n  }\n  return attrStrs;\n}\n\nexport { linkifyHtml as default };\n","import linkifyHtml from \"linkifyjs/html\"\n\n/**\n * Replaces plain text links in the given text by html links. Already existing html links are not changed.\n * @param html The text to be checked for links.\n * @returns {string} The text with html links.\n */\nexport function urlify(html: string): string {\n\treturn linkifyHtml(html, {\n\t\tdefaultProtocol: \"https\",\n\t\tattributes: {\n\t\t\trel: \"noopener noreferrer\",\n\t\t},\n\t\ttarget: \"_blank\",\n\t})\n}\n"],"mappings":"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"}