{"version":3,"file":"IndexerCore-CrLYpsA5.js","names":["message: string","db: Db","queue: EventQueue","browserData: BrowserData","instance: Record<string, any>","attributes: AttributeHandler[]","indexEntries: Map<string, SearchIndexEntry>[]","attributeKeyToIndexMap: Map<string, SearchIndexEntry>","id: IdTuple","ownerGroup: Id","keyToIndexEntries: Map<string, SearchIndexEntry[]>","indexUpdate: IndexUpdate","encWordsB64: string[]","event: EntityUpdate","batches: QueuedBatch[]","dataPerGroup: Array<{\n\t\t\tgroupId: Id\n\t\t\tindexTimestamp: number\n\t\t}>","groupId: Id","batchId: Id","updateGroupData: (t: DbTransaction) => $Promisable<void>","rowKeys: EncWordToMetaRow | null","e","operation: WriteOperation","visible: boolean","transaction: DbTransaction","metaRowKey: number","instanceInfos: EncInstanceIdWithTimestamp[]","rangesToRemove: Array<[number, number]>","encWordToMetaRow: EncWordToMetaRow","promises: Promise<unknown>[]","appId: number","typeId: number","encWordB64: B64EncIndexKey","encryptedEntries: Array<EncSearchIndexEntryWithTimestamp>","metaData: SearchIndexMetaDataRow","entries: Array<EncSearchIndexEntryWithTimestamp>","startIndex: number","timestamp: number","metaEntryIndex: number","binaryBlock: SearchIndexDbRow | null","timestampToEntries: Map<number, Array<Uint8Array>>","timestampToEntries: Map<number, Array<EncryptedSearchIndexEntry>>","preferFirst: boolean","encryptedSearchIndexEntries: Array<EncSearchIndexEntryWithTimestamp>","oldestTimestamp: number","encWordBase64: B64EncIndexKey","metaData: SearchIndexMetaDataDbRow | null","metaTemplate: Partial<SearchIndexMetaDataDbRow>","groupData: GroupData | null"],"sources":["../../src/common/api/common/error/InvalidDatabaseStateError.ts","../../src/mail-app/workerUtils/index/IndexerCore.ts"],"sourcesContent":["//@bundleInto:common-min\n\nimport { TutanotaError } from \"@tutao/tutanota-error\"\n\nexport class InvalidDatabaseStateError extends TutanotaError {\n\tconstructor(message: string) {\n\t\tsuper(\"InvalidDatabaseStateError\", message)\n\t}\n}\n","import type { DbTransaction } from \"../../../common/api/worker/search/DbFacade.js\"\nimport type { $Promisable, DeferredObject, PromiseMapFn } from \"@tutao/tutanota-utils\"\nimport {\n\tarrayHash,\n\tbyteLength,\n\tdefer,\n\tfindLastIndex,\n\tgetFromMap,\n\tgroupByAndMap,\n\tlastThrow,\n\tmergeMaps,\n\tneverNull,\n\tnoOp,\n\tPromisableWrapper,\n\tpromiseMapCompat,\n\ttokenize,\n\tTypeRef,\n\tuint8ArrayToBase64,\n} from \"@tutao/tutanota-utils\"\nimport { elementIdPart, firstBiggerThanSecond, generatedIdToTimestamp, listIdPart } from \"../../../common/api/common/utils/EntityUtils.js\"\nimport {\n\tcompareMetaEntriesOldest,\n\tdecryptIndexKey,\n\tdecryptMetaData,\n\tencryptIndexKeyBase64,\n\tencryptIndexKeyUint8Array,\n\tencryptMetaData,\n\tencryptSearchIndexEntry,\n\tgetIdFromEncSearchIndexEntry,\n\tgetPerformanceTimestamp,\n\ttypeRefToTypeInfo,\n} from \"../../../common/api/worker/search/IndexUtils.js\"\nimport type {\n\tAttributeHandler,\n\tB64EncIndexKey,\n\tDb,\n\tEncInstanceIdWithTimestamp,\n\tEncryptedSearchIndexEntry,\n\tEncSearchIndexEntryWithTimestamp,\n\tEncWordToMetaRow,\n\tGroupData,\n\tIndexUpdate,\n\tSearchIndexDbRow,\n\tSearchIndexEntry,\n\tSearchIndexMetaDataDbRow,\n\tSearchIndexMetadataEntry,\n\tSearchIndexMetaDataRow,\n} from \"../../../common/api/worker/search/SearchTypes.js\"\nimport type { QueuedBatch } from \"../../../common/api/worker/EventQueue.js\"\nimport { EventQueue } from \"../../../common/api/worker/EventQueue.js\"\nimport { CancelledError } from \"../../../common/api/common/error/CancelledError.js\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError.js\"\nimport type { BrowserData } from \"../../../common/misc/ClientConstants.js\"\nimport { InvalidDatabaseStateError } from \"../../../common/api/common/error/InvalidDatabaseStateError.js\"\nimport {\n\tappendBinaryBlocks,\n\tcalculateNeededSpaceForNumbers,\n\tdecodeNumbers,\n\tencodeNumbers,\n\titerateBinaryBlocks,\n\tremoveBinaryBlockRanges,\n} from \"../../../common/api/worker/search/SearchIndexEncoding.js\"\nimport type { EntityUpdate } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { aes256EncryptSearchIndexEntry, unauthenticatedAesDecrypt } from \"@tutao/tutanota-crypto\"\nimport {\n\tElementDataOS,\n\tGroupDataOS,\n\tMetaDataOS,\n\tSearchIndexMetaDataOS,\n\tSearchIndexOS,\n\tSearchIndexWordsIndex,\n} from \"../../../common/api/worker/search/IndexTables.js\"\n\nconst SEARCH_INDEX_ROW_LENGTH = 1000\n\n/**\n * Object to store the current indexedDb write operation. In case of background mode on iOS we have to abort the current write\n * and restart the write after app goes to foreground again.\n */\ntype WriteOperation = {\n\ttransaction: DbTransaction | null\n\toperation: (transaction: DbTransaction) => Promise<void>\n\ttransactionFactory: () => Promise<DbTransaction>\n\tdeferred: DeferredObject<void>\n\tisAbortedForBackgroundMode: boolean\n}\n\n/**\n * Class which executes operation on the indexing tables.\n *\n * Some functions return null instead of Promise because\n * IndexedDB transaction usually lives only till the end\n * of the event loop iteration and promise scheduling\n * somehow manages to break that and commit transaction\n * too early.\n */\nexport class IndexerCore {\n\tqueue: EventQueue\n\tdb: Db\n\tprivate _isStopped: boolean\n\tprivate _promiseMapCompat: PromiseMapFn\n\tprivate _needsExplicitIds: boolean\n\tprivate _explicitIdStart: number\n\tprivate _currentWriteOperation: WriteOperation | null = null\n\t_stats!: {\n\t\tindexingTime: number\n\t\tstorageTime: number\n\t\tpreparingTime: number\n\t\tmailcount: number\n\t\tstoredBytes: number\n\t\tencryptionTime: number\n\t\twriteRequests: number\n\t\tlargestColumn: number\n\t\twords: number\n\t\tindexedBytes: number\n\t}\n\n\tconstructor(db: Db, queue: EventQueue, browserData: BrowserData) {\n\t\tthis.queue = queue\n\t\tthis.db = db\n\t\tthis._isStopped = false\n\t\tthis._promiseMapCompat = promiseMapCompat(browserData.needsMicrotaskHack)\n\t\tthis._needsExplicitIds = browserData.needsExplicitIDBIds\n\t\tthis._explicitIdStart = Date.now()\n\t\tthis.resetStats()\n\t}\n\n\t/****************************************** Preparing the update ***********************************************/\n\n\t/**\n\t * Converts an instances into a map from words to a list of SearchIndexEntries.\n\t */\n\tcreateIndexEntriesForAttributes(instance: Record<string, any>, attributes: AttributeHandler[]): Map<string, SearchIndexEntry[]> {\n\t\tlet indexEntries: Map<string, SearchIndexEntry>[] = attributes.map((attributeHandler) => {\n\t\t\tif (typeof attributeHandler.value !== \"function\") {\n\t\t\t\tthrow new ProgrammingError(\"Value for attributeHandler is not a function: \" + JSON.stringify(attributeHandler.attribute))\n\t\t\t}\n\n\t\t\tlet value = attributeHandler.value()\n\t\t\tlet tokens = tokenize(value)\n\t\t\tthis._stats.indexedBytes += byteLength(value)\n\t\t\tlet attributeKeyToIndexMap: Map<string, SearchIndexEntry> = new Map()\n\n\t\t\tfor (let index = 0; index < tokens.length; index++) {\n\t\t\t\tlet token = tokens[index]\n\n\t\t\t\tif (!attributeKeyToIndexMap.has(token)) {\n\t\t\t\t\tattributeKeyToIndexMap.set(token, {\n\t\t\t\t\t\tid: instance._id instanceof Array ? instance._id[1] : instance._id,\n\t\t\t\t\t\tattribute: attributeHandler.attribute.id,\n\t\t\t\t\t\tpositions: [index],\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tneverNull(attributeKeyToIndexMap.get(token)).positions.push(index)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn attributeKeyToIndexMap\n\t\t})\n\t\treturn mergeMaps(indexEntries)\n\t}\n\n\t/**\n\t * Encrypt search index entries created by {@link createIndexEntriesForAttributes} and put them into the {@param indexUpdate}.\n\t * @param id of the instance\n\t * @param ownerGroup of the instance\n\t * @param keyToIndexEntries map from search index keys (words which you can search for) to index entries\n\t * @param indexUpdate IndexUpdate for which {@code create} fields will be populated\n\t */\n\tencryptSearchIndexEntries(id: IdTuple, ownerGroup: Id, keyToIndexEntries: Map<string, SearchIndexEntry[]>, indexUpdate: IndexUpdate): void {\n\t\tconst encryptionTimeStart = getPerformanceTimestamp()\n\t\tconst listId = listIdPart(id)\n\t\tconst encInstanceId = encryptIndexKeyUint8Array(this.db.key, elementIdPart(id), this.db.iv)\n\t\tconst encInstanceIdB64 = uint8ArrayToBase64(encInstanceId)\n\t\tconst elementIdTimestamp = generatedIdToTimestamp(elementIdPart(id))\n\t\tconst encWordsB64: string[] = []\n\t\tfor (const [indexKey, value] of keyToIndexEntries.entries()) {\n\t\t\tconst encWordB64 = encryptIndexKeyBase64(this.db.key, indexKey, this.db.iv)\n\t\t\tencWordsB64.push(encWordB64)\n\t\t\tconst encIndexEntries = getFromMap(indexUpdate.create.indexMap, encWordB64, () => [])\n\t\t\tfor (const indexEntry of value)\n\t\t\t\tencIndexEntries.push({\n\t\t\t\t\tentry: encryptSearchIndexEntry(this.db.key, indexEntry, encInstanceId),\n\t\t\t\t\ttimestamp: elementIdTimestamp,\n\t\t\t\t})\n\t\t}\n\t\tindexUpdate.create.encInstanceIdToElementData.set(encInstanceIdB64, {\n\t\t\tlistId,\n\t\t\tencWordsB64,\n\t\t\townerGroup,\n\t\t})\n\t\tthis._stats.encryptionTime += getPerformanceTimestamp() - encryptionTimeStart\n\t}\n\n\t/**\n\t * Process delete event before applying to the index.\n\t */\n\tasync _processDeleted(event: EntityUpdate, indexUpdate: IndexUpdate): Promise<void> {\n\t\tconst encInstanceIdPlain = encryptIndexKeyUint8Array(this.db.key, event.instanceId, this.db.iv)\n\t\tconst encInstanceIdB64 = uint8ArrayToBase64(encInstanceIdPlain)\n\t\tconst { appId, typeId } = typeRefToTypeInfo(new TypeRef(event.application, event.type))\n\t\tconst transaction = await this.db.dbFacade.createTransaction(true, [ElementDataOS])\n\t\tconst elementData = await transaction.get(ElementDataOS, encInstanceIdB64)\n\t\tif (!elementData) {\n\t\t\treturn\n\t\t}\n\n\t\t// We need to find SearchIndex rows which we want to update. In the ElementData we have references to the metadata and we can find\n\t\t// corresponding SearchIndex row in it.\n\t\tconst metaDataRowKeysBinary = unauthenticatedAesDecrypt(this.db.key, elementData[1], true)\n\t\t// For every word we have a metadata reference and we want to update them all.\n\t\tconst metaDataRowKeys = decodeNumbers(metaDataRowKeysBinary)\n\t\tfor (const metaDataRowKey of metaDataRowKeys) {\n\t\t\t// We add current instance into list of instances to delete for each word\n\t\t\tconst ids = getFromMap(indexUpdate.delete.searchMetaRowToEncInstanceIds, metaDataRowKey, () => [])\n\t\t\tids.push({\n\t\t\t\tencInstanceId: encInstanceIdPlain,\n\t\t\t\tappId,\n\t\t\t\ttypeId,\n\t\t\t\ttimestamp: generatedIdToTimestamp(event.instanceId),\n\t\t\t})\n\t\t}\n\t\tindexUpdate.delete.encInstanceIds.push(encInstanceIdB64)\n\t}\n\n\t/********************************************* Manipulating the state ***********************************************/\n\tstopProcessing() {\n\t\tthis._isStopped = true\n\t\tthis.queue.clear()\n\t}\n\n\tisStoppedProcessing(): boolean {\n\t\treturn this._isStopped\n\t}\n\n\tstartProcessing() {\n\t\tthis._isStopped = false\n\t}\n\n\taddBatchesToQueue(batches: QueuedBatch[]): void {\n\t\tif (!this._isStopped) {\n\t\t\tthis.queue.addBatches(batches)\n\t\t}\n\t}\n\n\t/*********************************************** Writing index update ***********************************************/\n\n\t/**\n\t * Apply populated {@param indexUpdate} to the database.\n\t */\n\twriteIndexUpdate(\n\t\tdataPerGroup: Array<{\n\t\t\tgroupId: Id\n\t\t\tindexTimestamp: number\n\t\t}>,\n\t\tindexUpdate: IndexUpdate,\n\t): Promise<void> {\n\t\treturn this._writeIndexUpdate(indexUpdate, (t) => this._updateGroupDataIndexTimestamp(dataPerGroup, t))\n\t}\n\n\twriteIndexUpdateWithBatchId(groupId: Id, batchId: Id, indexUpdate: IndexUpdate): Promise<void> {\n\t\treturn this._writeIndexUpdate(indexUpdate, (t) => this._updateGroupDataBatchId(groupId, batchId, t))\n\t}\n\n\t_writeIndexUpdate(indexUpdate: IndexUpdate, updateGroupData: (t: DbTransaction) => $Promisable<void>): Promise<void> {\n\t\treturn this._executeOperation({\n\t\t\ttransaction: null,\n\t\t\ttransactionFactory: () => this.db.dbFacade.createTransaction(false, [SearchIndexOS, SearchIndexMetaDataOS, ElementDataOS, MetaDataOS, GroupDataOS]),\n\t\t\toperation: (transaction) => {\n\t\t\t\tlet startTimeStorage = getPerformanceTimestamp()\n\n\t\t\t\tif (this._isStopped) {\n\t\t\t\t\treturn Promise.reject(new CancelledError(\"mail indexing cancelled\"))\n\t\t\t\t}\n\n\t\t\t\treturn (\n\t\t\t\t\tthis._moveIndexedInstance(indexUpdate, transaction)\n\t\t\t\t\t\t.thenOrApply(() => this._deleteIndexedInstance(indexUpdate, transaction))\n\t\t\t\t\t\t.thenOrApply(() => this._insertNewIndexEntries(indexUpdate, transaction))\n\t\t\t\t\t\t.thenOrApply((rowKeys: EncWordToMetaRow | null) => rowKeys && this._insertNewElementData(indexUpdate, transaction, rowKeys))\n\t\t\t\t\t\t.thenOrApply(() => updateGroupData(transaction))\n\t\t\t\t\t\t.thenOrApply(() => {\n\t\t\t\t\t\t\treturn transaction.wait().then(() => {\n\t\t\t\t\t\t\t\tthis._stats.storageTime += getPerformanceTimestamp() - startTimeStorage\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}) // a la catch(). Must be done in the next step because didReject is not invoked for the current Promise, only for the previous one.\n\t\t\t\t\t\t// It's probably a bad idea to convert to the Promise first and then catch because it may do Promise.resolve() and this will schedule to\n\t\t\t\t\t\t// the next event loop iteration and the context will be closed and it will be too late to abort(). Even worse, it will be commited to\n\t\t\t\t\t\t// IndexedDB already and it will be inconsistent (oops).\n\t\t\t\t\t\t.thenOrApply(noOp, (e) => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!transaction.aborted) transaction.abort()\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tconsole.warn(\"abort has failed: \", e) // Ignore if abort has failed\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.toPromise()\n\t\t\t\t)\n\t\t\t},\n\t\t\tdeferred: defer(),\n\t\t\tisAbortedForBackgroundMode: false,\n\t\t})\n\t}\n\n\t_executeOperation(operation: WriteOperation): Promise<void> {\n\t\tthis._currentWriteOperation = operation\n\t\treturn operation.transactionFactory().then((transaction) => {\n\t\t\toperation.transaction = transaction\n\t\t\toperation\n\t\t\t\t.operation(transaction)\n\t\t\t\t.then((it) => {\n\t\t\t\t\tthis._currentWriteOperation = null\n\t\t\t\t\toperation.deferred.resolve()\n\t\t\t\t\treturn it\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tif (operation.isAbortedForBackgroundMode) {\n\t\t\t\t\t\tconsole.log(\"transaction has been aborted because of background mode\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (env.mode !== \"Test\") {\n\t\t\t\t\t\t\tconsole.log(\"rejecting operation with error\", e)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toperation.deferred.reject(e)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\treturn operation.deferred.promise\n\t\t})\n\t}\n\n\tonVisibilityChanged(visible: boolean) {\n\t\tconst operation = this._currentWriteOperation\n\n\t\tif (!visible && operation && operation.transaction) {\n\t\t\tconsole.log(\"abort indexedDb transaction operation because background mode\")\n\n\t\t\ttry {\n\t\t\t\tneverNull(operation.transaction).abort()\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"Error when aborting on visibility change\", e)\n\t\t\t}\n\n\t\t\toperation.isAbortedForBackgroundMode = true\n\t\t}\n\n\t\tif (visible && operation) {\n\t\t\tconsole.log(\"restart indexedDb transaction operation after background mode\")\n\t\t\toperation.isAbortedForBackgroundMode = false\n\n\t\t\tthis._executeOperation(operation)\n\t\t}\n\t}\n\n\t_moveIndexedInstance(indexUpdate: IndexUpdate, transaction: DbTransaction): PromisableWrapper<void> {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (indexUpdate.move.length === 0) return PromisableWrapper.from(undefined) // keep transaction context open (only for Safari)\n\n\t\tconst promise = Promise.all(\n\t\t\tindexUpdate.move.map((moveInstance) => {\n\t\t\t\treturn transaction.get(ElementDataOS, moveInstance.encInstanceId).then((elementData) => {\n\t\t\t\t\tif (elementData) {\n\t\t\t\t\t\telementData[0] = moveInstance.newListId\n\t\t\t\t\t\ttransaction.put(ElementDataOS, moveInstance.encInstanceId, elementData)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}),\n\t\t).then(noOp)\n\t\treturn PromisableWrapper.from(promise)\n\t}\n\n\t/**\n\t * Apply \"delete\" updates to the database\n\t * @private\n\t */\n\t_deleteIndexedInstance(indexUpdate: IndexUpdate, transaction: DbTransaction): Promise<void> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (indexUpdate.delete.searchMetaRowToEncInstanceIds.size === 0) return null // keep transaction context open\n\n\t\tlet deleteElementDataPromise = Promise.all(indexUpdate.delete.encInstanceIds.map((encInstanceId) => transaction.delete(ElementDataOS, encInstanceId)))\n\t\t// For each word we have list of instances we want to remove\n\t\treturn Promise.all(\n\t\t\tArray.from(indexUpdate.delete.searchMetaRowToEncInstanceIds).map(([metaRowKey, encInstanceIds]) =>\n\t\t\t\tthis._deleteSearchIndexEntries(transaction, metaRowKey, encInstanceIds),\n\t\t\t),\n\t\t)\n\t\t\t.then(() => deleteElementDataPromise)\n\t\t\t.then(noOp)\n\t}\n\n\t/**\n\t * Remove all {@param instanceInfos} from the SearchIndex entries and metadata entreis specified by the {@param metaRowKey}.\n\t * @private\n\t */\n\t_deleteSearchIndexEntries(transaction: DbTransaction, metaRowKey: number, instanceInfos: EncInstanceIdWithTimestamp[]): Promise<any> {\n\t\tthis._cancelIfNeeded()\n\n\t\t// Collect hashes of all instances we want to delete to check it faster later\n\t\tconst encInstanceIdSet = new Set(instanceInfos.map((e) => arrayHash(e.encInstanceId)))\n\t\treturn transaction.get(SearchIndexMetaDataOS, metaRowKey).then((encMetaDataRow) => {\n\t\t\tif (!encMetaDataRow) {\n\t\t\t\t// already deleted\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst metaDataRow = decryptMetaData(this.db.key, encMetaDataRow)\n\t\t\t// add meta data to set to only update meta data once when deleting multiple instances\n\t\t\tconst metaDataEntriesSet = new Set() as Set<SearchIndexMetadataEntry>\n\t\t\tfor (const info of instanceInfos) {\n\t\t\t\t// For each instance we find SearchIndex row it belongs to by timestamp\n\t\t\t\tconst entryIndex = this._findMetaDataEntryByTimestamp(metaDataRow, info.timestamp, info.appId, info.typeId)\n\n\t\t\t\tif (entryIndex === -1) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\"could not find MetaDataEntry, info:\",\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\"rows: \",\n\t\t\t\t\t\tmetaDataRow.rows.map((r) => JSON.stringify(r)),\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tmetaDataEntriesSet.add(metaDataRow.rows[entryIndex])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For each SearchIndex row we need to update...\n\t\t\tconst updateSearchIndex = this._promiseMapCompat(Array.from(metaDataEntriesSet), (metaEntry) => {\n\t\t\t\treturn transaction.get(SearchIndexOS, metaEntry.key).then((indexEntriesRow) => {\n\t\t\t\t\tif (!indexEntriesRow) return\n\t\t\t\t\t// Find all entries we need to remove by hash of the encrypted ID\n\t\t\t\t\tconst rangesToRemove: Array<[number, number]> = []\n\t\t\t\t\titerateBinaryBlocks(indexEntriesRow, (block, start, end) => {\n\t\t\t\t\t\tif (encInstanceIdSet.has(arrayHash(getIdFromEncSearchIndexEntry(block)))) {\n\t\t\t\t\t\t\trangesToRemove.push([start, end])\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tif (rangesToRemove.length === 0) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else if (metaEntry.size === rangesToRemove.length) {\n\t\t\t\t\t\tmetaEntry.size = 0\n\t\t\t\t\t\treturn transaction.delete(SearchIndexOS, metaEntry.key)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst trimmed = removeBinaryBlockRanges(indexEntriesRow, rangesToRemove)\n\t\t\t\t\t\tmetaEntry.size -= rangesToRemove.length\n\t\t\t\t\t\treturn transaction.put(SearchIndexOS, metaEntry.key, trimmed)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\n\t\t\treturn updateSearchIndex.thenOrApply(() => {\n\t\t\t\tmetaDataRow.rows = metaDataRow.rows.filter((r) => r.size > 0)\n\n\t\t\t\tif (metaDataRow.rows.length === 0) {\n\t\t\t\t\treturn transaction.delete(SearchIndexMetaDataOS, metaDataRow.id)\n\t\t\t\t} else {\n\t\t\t\t\treturn transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(this.db.key, metaDataRow))\n\t\t\t\t}\n\t\t\t}).value\n\t\t})\n\t}\n\n\t_insertNewElementData(indexUpdate: IndexUpdate, transaction: DbTransaction, encWordToMetaRow: EncWordToMetaRow): Promise<unknown> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (indexUpdate.create.encInstanceIdToElementData.size === 0) return null // keep transaction context open (only in Safari)\n\n\t\tlet promises: Promise<unknown>[] = []\n\t\tfor (const [b64EncInstanceId, elementDataSurrogate] of indexUpdate.create.encInstanceIdToElementData.entries()) {\n\t\t\tconst metaRows = elementDataSurrogate.encWordsB64.map((w) => encWordToMetaRow[w])\n\t\t\tconst rowKeysBinary = new Uint8Array(calculateNeededSpaceForNumbers(metaRows))\n\t\t\tencodeNumbers(metaRows, rowKeysBinary)\n\t\t\tconst encMetaRowKeys = aes256EncryptSearchIndexEntry(this.db.key, rowKeysBinary)\n\t\t\tpromises.push(transaction.put(ElementDataOS, b64EncInstanceId, [elementDataSurrogate.listId, encMetaRowKeys, elementDataSurrogate.ownerGroup]))\n\t\t}\n\t\treturn Promise.all(promises)\n\t}\n\n\t_insertNewIndexEntries(indexUpdate: IndexUpdate, transaction: DbTransaction): Promise<EncWordToMetaRow> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tlet keys = [...indexUpdate.create.indexMap.keys()]\n\t\tconst encWordToMetaRow: EncWordToMetaRow = {}\n\n\t\tconst result = this._promiseMapCompat(\n\t\t\tkeys,\n\t\t\t(encWordB64) => {\n\t\t\t\tconst encryptedEntries = neverNull(indexUpdate.create.indexMap.get(encWordB64))\n\t\t\t\treturn this._putEncryptedEntity(\n\t\t\t\t\tindexUpdate.typeInfo.appId,\n\t\t\t\t\tindexUpdate.typeInfo.typeId,\n\t\t\t\t\ttransaction,\n\t\t\t\t\tencWordB64,\n\t\t\t\t\tencWordToMetaRow,\n\t\t\t\t\tencryptedEntries,\n\t\t\t\t)\n\t\t\t},\n\t\t\t{\n\t\t\t\tconcurrency: 2,\n\t\t\t},\n\t\t).value\n\n\t\treturn result instanceof Promise ? result.then(() => encWordToMetaRow) : null\n\t}\n\n\t_putEncryptedEntity(\n\t\tappId: number,\n\t\ttypeId: number,\n\t\ttransaction: DbTransaction,\n\t\tencWordB64: B64EncIndexKey,\n\t\tencWordToMetaRow: EncWordToMetaRow,\n\t\tencryptedEntries: Array<EncSearchIndexEntryWithTimestamp>,\n\t): Promise<unknown> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (encryptedEntries.length <= 0) {\n\t\t\treturn null\n\t\t}\n\n\t\treturn this._getOrCreateSearchIndexMeta(transaction, encWordB64)\n\t\t\t.then((metaData: SearchIndexMetaDataRow) => {\n\t\t\t\tencryptedEntries.sort((a, b) => a.timestamp - b.timestamp)\n\n\t\t\t\tconst writeResult = this._writeEntries(transaction, encryptedEntries, metaData, appId, typeId)\n\n\t\t\t\treturn writeResult.thenOrApply(() => metaData).value\n\t\t\t})\n\t\t\t.then((metaData) => {\n\t\t\t\tconst columnSize = metaData.rows.reduce((result, metaDataEntry) => result + metaDataEntry.size, 0)\n\t\t\t\tthis._stats.writeRequests += 1\n\t\t\t\tthis._stats.largestColumn = columnSize > this._stats.largestColumn ? columnSize : this._stats.largestColumn\n\t\t\t\tthis._stats.storedBytes += encryptedEntries.reduce((sum, e) => sum + e.entry.length, 0)\n\t\t\t\tencWordToMetaRow[encWordB64] = metaData.id\n\t\t\t\treturn transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(this.db.key, metaData))\n\t\t\t})\n\t}\n\n\t/**\n\t * Insert {@param entries} into the database for the corresponding {@param metaData}.\n\t * Metadata entries for each type are sorted from oldest to newest. Each metadata entry has oldest element timestamp. Timestamps of newer entries make a\n\t * time border for the newest. Timestamp for entry is considered fixed (unless it's the first entry).\n\t * The strategy is following:\n\t * First, try to find matching row by the oldest id of the entries we want to insert.\n\t * If we've found one, put everything that matches time frame of this row into it (it's bounded by the next row, if present). Put the rest into newer\n\t * rows.\n\t * If we didn't find one, we may try to extend the oldest row, because it's not bounded by the other row.\n\t * When we append something to the row, we check if its size would exceed {@link SEARCH_INDEX_ROW_LENGTH}. If it is, we do splitting,\n\t * {@see _appendIndexEntriesToRow}.\n\t * @private\n\t */\n\t_writeEntries(\n\t\ttransaction: DbTransaction,\n\t\tentries: Array<EncSearchIndexEntryWithTimestamp>,\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\tappId: number,\n\t\ttypeId: number,\n\t): PromisableWrapper<void> {\n\t\tif (entries.length === 0) {\n\t\t\t// Prevent IDB timeouts in Safari casued by Promise.resolve()\n\t\t\treturn PromisableWrapper.from(undefined)\n\t\t}\n\n\t\tconst oldestTimestamp = entries[0].timestamp\n\n\t\tconst indexOfMetaEntry = this._findMetaDataEntryByTimestamp(metaData, oldestTimestamp, appId, typeId)\n\n\t\tif (indexOfMetaEntry !== -1) {\n\t\t\tconst nextEntry = this._nextEntryOfType(metaData, indexOfMetaEntry + 1, appId, typeId)\n\n\t\t\tif (!nextEntry) {\n\t\t\t\treturn this._appendIndexEntriesToRow(transaction, metaData, indexOfMetaEntry, entries)\n\t\t\t} else {\n\t\t\t\tconst [toCurrentOne, toNextOnes] = this._splitByTimestamp(entries, nextEntry.oldestElementTimestamp)\n\n\t\t\t\treturn this._appendIndexEntriesToRow(transaction, metaData, indexOfMetaEntry, toCurrentOne).thenOrApply(() =>\n\t\t\t\t\tthis._writeEntries(transaction, toNextOnes, metaData, appId, typeId),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\t// we have not found any entry which oldest id is lower than oldest id to add but there can be other entries\n\t\t\tconst firstEntry = this._nextEntryOfType(metaData, 0, appId, typeId)\n\n\t\t\t// 1. We have a first entry.\n\t\t\t//   i: We have a second entry. Check how much fits into the first block\n\t\t\t//     a. It's not oversized. Write to it.\n\t\t\t//     b. It is oversized. Create a new block.\n\t\t\t//   ii: We don't have a second entry. Check if we can fit everything into the first block\n\t\t\t//     a. It's not eversized. Write to it.\n\t\t\t//     b. It's oversized. Create a new one.\n\t\t\t// 2. We don't have a first entry. Just create a new row with everything.\n\t\t\tif (firstEntry) {\n\t\t\t\tconst indexOfFirstEntry = metaData.rows.indexOf(firstEntry)\n\n\t\t\t\tconst secondEntry = this._nextEntryOfType(metaData, indexOfFirstEntry + 1, appId, typeId)\n\n\t\t\t\tconst [toFirstOne, toNextOnes] = secondEntry ? this._splitByTimestamp(entries, secondEntry.oldestElementTimestamp) : [entries, []]\n\n\t\t\t\tif (firstEntry.size + toFirstOne.length < SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t\t\treturn this._appendIndexEntriesToRow(transaction, metaData, indexOfFirstEntry, toFirstOne).thenOrApply(() =>\n\t\t\t\t\t\tthis._writeEntries(transaction, toNextOnes, metaData, appId, typeId),\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tconst [toNewOne, toCurrentOne] = this._splitByTimestamp(toFirstOne, firstEntry.oldestElementTimestamp)\n\n\t\t\t\t\treturn PromisableWrapper.from(this._createNewRow(transaction, metaData, toNewOne, oldestTimestamp, appId, typeId)).thenOrApply(() =>\n\t\t\t\t\t\tthis._writeEntries(transaction, toCurrentOne.concat(toNextOnes), metaData, appId, typeId),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this._createNewRow(transaction, metaData, entries, oldestTimestamp, appId, typeId)\n\t\t\t}\n\t\t}\n\t}\n\n\t_nextEntryOfType(metaData: SearchIndexMetaDataRow, startIndex: number, appId: number, typeId: number): SearchIndexMetadataEntry | null {\n\t\tfor (let i = startIndex; i < metaData.rows.length; i++) {\n\t\t\tif (metaData.rows[i].app === appId && metaData.rows[i].type === typeId) {\n\t\t\t\treturn metaData.rows[i]\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\t/**\n\t * Split {@param entries} (must be sorted!) into two arrays: before and after the timestamp.\n\t * @private\n\t */\n\t_splitByTimestamp(\n\t\tentries: Array<EncSearchIndexEntryWithTimestamp>,\n\t\ttimestamp: number,\n\t): [Array<EncSearchIndexEntryWithTimestamp>, Array<EncSearchIndexEntryWithTimestamp>] {\n\t\tconst indexOfSplit = entries.findIndex((entry) => entry.timestamp >= timestamp)\n\n\t\tif (indexOfSplit === -1) {\n\t\t\treturn [entries, []]\n\t\t}\n\n\t\tconst below = entries.slice(0, indexOfSplit)\n\t\tconst above = entries.slice(indexOfSplit)\n\t\treturn [below, above]\n\t}\n\n\t/**\n\t * Append {@param entries} to the row specified by the {@param metaEntryIndex}. If the row size exceeds {@link SEARCH_INDEX_ROW_LENGTH}, then\n\t * split it into two rows.\n\t * @private\n\t */\n\t_appendIndexEntriesToRow(\n\t\ttransaction: DbTransaction,\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\tmetaEntryIndex: number,\n\t\tentries: Array<EncSearchIndexEntryWithTimestamp>,\n\t): PromisableWrapper<void> {\n\t\tif (entries.length === 0) {\n\t\t\treturn new PromisableWrapper(undefined)\n\t\t}\n\n\t\tconst metaEntry = metaData.rows[metaEntryIndex]\n\n\t\tif (metaEntry.size + entries.length > SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t// load existing row\n\t\t\t// decrypt ids\n\t\t\t// sort by id\n\t\t\t// split\n\t\t\treturn PromisableWrapper.from(\n\t\t\t\ttransaction.get(SearchIndexOS, metaEntry.key).then((binaryBlock: SearchIndexDbRow | null) => {\n\t\t\t\t\tif (!binaryBlock) {\n\t\t\t\t\t\tthrow new InvalidDatabaseStateError(\"non existing index row\")\n\t\t\t\t\t}\n\n\t\t\t\t\tconst timestampToEntries: Map<number, Array<Uint8Array>> = new Map()\n\t\t\t\t\tconst existingIds = new Set()\n\t\t\t\t\t// Iterate all entries in a block, decrypt id of each and put it into the map\n\t\t\t\t\titerateBinaryBlocks(binaryBlock, (encSearchIndexEntry) => {\n\t\t\t\t\t\tconst encId = getIdFromEncSearchIndexEntry(encSearchIndexEntry)\n\t\t\t\t\t\texistingIds.add(arrayHash(encId))\n\t\t\t\t\t\tconst decId = decryptIndexKey(this.db.key, encId, this.db.iv)\n\t\t\t\t\t\tconst timeStamp = generatedIdToTimestamp(decId)\n\t\t\t\t\t\tgetFromMap(timestampToEntries, timeStamp, () => []).push(encSearchIndexEntry)\n\t\t\t\t\t})\n\t\t\t\t\t// Also add new entries\n\t\t\t\t\tfor (const { entry, timestamp } of entries) {\n\t\t\t\t\t\tgetFromMap(timestampToEntries, timestamp, () => []).push(entry)\n\t\t\t\t\t}\n\t\t\t\t\t// Prefer to put entries into the first row if it's not initial indexing (we are likely to grow second row in the future)\n\t\t\t\t\t// Prefer to put entries into the second row if it's initial indexing (we are likely to grow the first row because we move back in time)\n\t\t\t\t\tconst isLastEntry = this._nextEntryOfType(metaData, metaEntryIndex + 1, metaEntry.app, metaEntry.type) == null\n\n\t\t\t\t\tconst rows = this._distributeEntities(timestampToEntries, isLastEntry)\n\n\t\t\t\t\t// keep the oldest timestamp in the existing meta data entry to ensure that when continuing search we don't get the same meta data entry twice.\n\t\t\t\t\tconst [appendRow, newRows] = [rows[0], rows.slice(1)]\n\t\t\t\t\tconst firstRowBinary = appendBinaryBlocks(appendRow.row)\n\t\t\t\t\tconst requestPromises = [\n\t\t\t\t\t\ttransaction.put(SearchIndexOS, metaEntry.key, firstRowBinary).then(() => {\n\t\t\t\t\t\t\tmetaEntry.size = appendRow.row.length\n\t\t\t\t\t\t\tmetaEntry.oldestElementTimestamp = appendRow.oldestElementTimestamp\n\t\t\t\t\t\t\treturn metaEntry.key\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tthis._promiseMapCompat(\n\t\t\t\t\t\t\tnewRows,\n\t\t\t\t\t\t\t(row) => {\n\t\t\t\t\t\t\t\tconst binaryRow = appendBinaryBlocks(row.row)\n\t\t\t\t\t\t\t\treturn transaction.put(SearchIndexOS, null, binaryRow).then((newSearchIndexRowId) => {\n\t\t\t\t\t\t\t\t\tmetaData.rows.push({\n\t\t\t\t\t\t\t\t\t\tkey: newSearchIndexRowId,\n\t\t\t\t\t\t\t\t\t\tsize: row.row.length,\n\t\t\t\t\t\t\t\t\t\tapp: metaEntry.app,\n\t\t\t\t\t\t\t\t\t\ttype: metaEntry.type,\n\t\t\t\t\t\t\t\t\t\toldestElementTimestamp: row.oldestElementTimestamp,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconcurrency: 2,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t).value,\n\t\t\t\t\t]\n\t\t\t\t\treturn Promise.all(requestPromises).then(() => {\n\t\t\t\t\t\tmetaData.rows.sort(compareMetaEntriesOldest)\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\treturn PromisableWrapper.from(\n\t\t\t\ttransaction.get(SearchIndexOS, metaEntry.key).then((indexEntriesRow) => {\n\t\t\t\t\tlet safeRow = indexEntriesRow || new Uint8Array(0)\n\t\t\t\t\tconst resultRow = appendBinaryBlocks(\n\t\t\t\t\t\tentries.map((e) => e.entry),\n\t\t\t\t\t\tsafeRow,\n\t\t\t\t\t)\n\t\t\t\t\treturn transaction.put(SearchIndexOS, metaEntry.key, resultRow).then(() => {\n\t\t\t\t\t\tmetaEntry.size += entries.length\n\t\t\t\t\t\t// when adding entries to an existing row it is guaranteed that all added elements are newer.\n\t\t\t\t\t\t// We don't have to update oldestTimestamp of the meta data.\n\t\t\t\t\t\t// ...except when we're growing the first row, then we should do that\n\t\t\t\t\t\tmetaEntry.oldestElementTimestamp = Math.min(entries[0].timestamp, metaEntry.oldestElementTimestamp)\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n\n\t_distributeEntities(\n\t\ttimestampToEntries: Map<number, Array<EncryptedSearchIndexEntry>>,\n\t\tpreferFirst: boolean,\n\t): Array<{\n\t\trow: Array<Uint8Array>\n\t\toldestElementTimestamp: number\n\t}> {\n\t\tconst sortedTimestamps = Array.from(timestampToEntries.keys()).sort((l, r) => l - r)\n\n\t\t// If we append to the newest IDs, then try to saturate older rows\n\t\tif (preferFirst) {\n\t\t\tconst rows = [\n\t\t\t\t{\n\t\t\t\t\trow: [] as Array<EncryptedSearchIndexEntry>,\n\t\t\t\t\toldestElementTimestamp: sortedTimestamps[0],\n\t\t\t\t},\n\t\t\t]\n\t\t\tfor (const id of sortedTimestamps) {\n\t\t\t\tconst encryptedEntries = neverNull(timestampToEntries.get(id))\n\n\t\t\t\tif (lastThrow(rows).row.length + encryptedEntries.length > SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t\t\trows.push({\n\t\t\t\t\t\trow: [],\n\t\t\t\t\t\toldestElementTimestamp: id,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tlastThrow(rows).row.push(...encryptedEntries)\n\t\t\t}\n\t\t\treturn rows\n\t\t} else {\n\t\t\t// If we append in the middle, then try to saturate new row\n\t\t\tconst rows = [\n\t\t\t\t{\n\t\t\t\t\trow: [] as EncryptedSearchIndexEntry[],\n\t\t\t\t\toldestElementTimestamp: Number.MAX_SAFE_INTEGER,\n\t\t\t\t},\n\t\t\t]\n\t\t\tconst reveresId = sortedTimestamps.slice().reverse()\n\t\t\tfor (const id of reveresId) {\n\t\t\t\tconst encryptedEntries = neverNull(timestampToEntries.get(id))\n\n\t\t\t\tif (rows[0].row.length + encryptedEntries.length > SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t\t\trows.unshift({\n\t\t\t\t\t\trow: [],\n\t\t\t\t\t\toldestElementTimestamp: id,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\trows[0].row.unshift(...encryptedEntries)\n\t\t\t\trows[0].oldestElementTimestamp = Math.min(rows[0].oldestElementTimestamp, id)\n\t\t\t}\n\t\t\treturn rows\n\t\t}\n\t}\n\n\t_createNewRow(\n\t\ttransaction: DbTransaction,\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\tencryptedSearchIndexEntries: Array<EncSearchIndexEntryWithTimestamp>,\n\t\toldestTimestamp: number,\n\t\tappId: number,\n\t\ttypeId: number,\n\t): PromisableWrapper<void> {\n\t\tconst byTimestamp = groupByAndMap(\n\t\t\tencryptedSearchIndexEntries,\n\t\t\t(e) => e.timestamp,\n\t\t\t(e) => e.entry,\n\t\t)\n\n\t\tconst distributed = this._distributeEntities(byTimestamp, false)\n\n\t\treturn this._promiseMapCompat(\n\t\t\tdistributed,\n\t\t\t({ row, oldestElementTimestamp }) => {\n\t\t\t\tconst binaryRow = appendBinaryBlocks(row)\n\t\t\t\treturn transaction.put(SearchIndexOS, null, binaryRow).then((newRowId) => {\n\t\t\t\t\t// Oldest entries come in front\n\t\t\t\t\tmetaData.rows.push({\n\t\t\t\t\t\tkey: newRowId,\n\t\t\t\t\t\tsize: row.length,\n\t\t\t\t\t\tapp: appId,\n\t\t\t\t\t\ttype: typeId,\n\t\t\t\t\t\toldestElementTimestamp,\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t\t{\n\t\t\t\tconcurrency: 2,\n\t\t\t},\n\t\t).thenOrApply(() => {\n\t\t\tmetaData.rows.sort(compareMetaEntriesOldest)\n\t\t})\n\t}\n\n\t_findMetaDataEntryByTimestamp(metaData: SearchIndexMetaDataRow, oldestTimestamp: number, appId: number, typeId: number): number {\n\t\treturn findLastIndex(metaData.rows, (r) => r.app === appId && r.type === typeId && r.oldestElementTimestamp <= oldestTimestamp)\n\t}\n\n\t_getOrCreateSearchIndexMeta(transaction: DbTransaction, encWordBase64: B64EncIndexKey): Promise<SearchIndexMetaDataRow> {\n\t\treturn transaction.get(SearchIndexMetaDataOS, encWordBase64, SearchIndexWordsIndex).then((metaData: SearchIndexMetaDataDbRow | null) => {\n\t\t\tif (metaData) {\n\t\t\t\treturn decryptMetaData(this.db.key, metaData)\n\t\t\t} else {\n\t\t\t\tconst metaTemplate: Partial<SearchIndexMetaDataDbRow> = {\n\t\t\t\t\tword: encWordBase64,\n\t\t\t\t\trows: new Uint8Array(0),\n\t\t\t\t}\n\n\t\t\t\tif (this._needsExplicitIds) {\n\t\t\t\t\tmetaTemplate.id = this._explicitIdStart++\n\t\t\t\t}\n\n\t\t\t\treturn transaction.put(SearchIndexMetaDataOS, null, metaTemplate).then((rowId) => {\n\t\t\t\t\tthis._stats.words += 1\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: rowId,\n\t\t\t\t\t\tword: encWordBase64,\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\t_updateGroupDataIndexTimestamp(\n\t\tdataPerGroup: Array<{\n\t\t\tgroupId: Id\n\t\t\tindexTimestamp: number\n\t\t}>,\n\t\ttransaction: DbTransaction,\n\t): $Promisable<void> {\n\t\treturn this._promiseMapCompat(dataPerGroup, (data) => {\n\t\t\tconst { groupId, indexTimestamp } = data\n\t\t\treturn transaction.get(GroupDataOS, groupId).then((groupData: GroupData | null) => {\n\t\t\t\tif (!groupData) {\n\t\t\t\t\tthrow new InvalidDatabaseStateError(\"GroupData not available for group \" + groupId)\n\t\t\t\t}\n\n\t\t\t\tgroupData.indexTimestamp = indexTimestamp\n\t\t\t\treturn transaction.put(GroupDataOS, groupId, groupData)\n\t\t\t})\n\t\t}).thenOrApply(() => {}).value\n\t}\n\n\t_updateGroupDataBatchId(groupId: Id, batchId: Id, transaction: DbTransaction): Promise<void> {\n\t\treturn transaction.get(GroupDataOS, groupId).then((groupData: GroupData | null) => {\n\t\t\tif (!groupData) {\n\t\t\t\tthrow new InvalidDatabaseStateError(\"GroupData not available for group \" + groupId)\n\t\t\t}\n\n\t\t\tif (groupData.lastBatchIds.length > 0 && groupData.lastBatchIds.indexOf(batchId) !== -1) {\n\t\t\t\t// concurrent indexing (multiple tabs)\n\t\t\t\tconsole.warn(\"Abort transaction on updating group data: concurrent access\", groupId, batchId)\n\t\t\t\ttransaction.abort()\n\t\t\t} else {\n\t\t\t\tlet newIndex = groupData.lastBatchIds.findIndex((indexedBatchId) => firstBiggerThanSecond(batchId, indexedBatchId))\n\n\t\t\t\tif (newIndex !== -1) {\n\t\t\t\t\tgroupData.lastBatchIds.splice(newIndex, 0, batchId)\n\t\t\t\t} else {\n\t\t\t\t\tgroupData.lastBatchIds.push(batchId) // new batch is oldest of all stored batches\n\t\t\t\t}\n\n\t\t\t\tif (groupData.lastBatchIds.length > 1000) {\n\t\t\t\t\tgroupData.lastBatchIds = groupData.lastBatchIds.slice(0, 1000)\n\t\t\t\t}\n\n\t\t\t\treturn transaction.put(GroupDataOS, groupId, groupData)\n\t\t\t}\n\t\t})\n\t}\n\n\t_cancelIfNeeded() {\n\t\tif (this._isStopped) {\n\t\t\tthrow new CancelledError(\"indexing cancelled\")\n\t\t}\n\t}\n\n\tresetStats() {\n\t\tthis._stats = {\n\t\t\tindexingTime: 0,\n\t\t\tstorageTime: 0,\n\t\t\tpreparingTime: 0,\n\t\t\tmailcount: 0,\n\t\t\tstoredBytes: 0,\n\t\t\tencryptionTime: 0,\n\t\t\twriteRequests: 0,\n\t\t\tlargestColumn: 0,\n\t\t\twords: 0,\n\t\t\tindexedBytes: 0,\n\t\t}\n\t}\n\n\tprintStatus() {\n\t\tconst totalTime = this._stats.storageTime + this._stats.preparingTime\n\t\tconst statsWithDownloading = Object.assign({}, this._stats, {\n\t\t\tdownloadingTime: this._stats.preparingTime - this._stats.indexingTime - this._stats.encryptionTime,\n\t\t})\n\t\tconsole.log(JSON.stringify(statsWithDownloading), \"total time: \", totalTime)\n\t}\n}\n"],"mappings":"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"}