{"version":3,"file":"KeychainEncryptionTest-BKGX2Eet.js","names":["appPassHandler: AppPassHandler","crypto: DesktopNativeCryptoFacade","desktopKeyStoreFacade: DesktopKeyStoreFacade","encryptedDataWithAppPassWrapper: Uint8Array","encryptionMode: DesktopCredentialsMode","data: Uint8Array","encryption: KeychainEncryption","appPassHandler: AppPassHandler","crypto: DesktopNativeCryptoFacade","keystore: DesktopKeyStoreFacade"],"sources":["../../src/common/desktop/credentials/KeychainEncryption.ts","../tests/desktop/credentials/KeychainEncryptionTest.ts"],"sourcesContent":["import { KeyPermanentlyInvalidatedError } from \"../../api/common/error/KeyPermanentlyInvalidatedError.js\"\nimport { assertSupportedEncryptionMode, DesktopCredentialsMode } from \"./CredentialCommons.js\"\nimport { DesktopKeyStoreFacade } from \"../DesktopKeyStoreFacade.js\"\nimport { AppPassHandler } from \"./AppPassHandler.js\"\nimport { DesktopNativeCryptoFacade } from \"../DesktopNativeCryptoFacade.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\n\nexport class KeychainEncryption {\n\tconstructor(\n\t\tprivate readonly appPassHandler: AppPassHandler,\n\t\tprivate readonly crypto: DesktopNativeCryptoFacade,\n\t\tprivate readonly desktopKeyStoreFacade: DesktopKeyStoreFacade,\n\t) {}\n\n\tasync decryptUsingKeychain(encryptedDataWithAppPassWrapper: Uint8Array, encryptionMode: DesktopCredentialsMode): Promise<Uint8Array> {\n\t\ttry {\n\t\t\tassertSupportedEncryptionMode(encryptionMode)\n\t\t\tconst encryptedData = await this.appPassHandler.removeAppPassWrapper(encryptedDataWithAppPassWrapper, encryptionMode)\n\t\t\tconst keyChainKey = await this.desktopKeyStoreFacade.getKeyChainKey()\n\t\t\treturn this.crypto.unauthenticatedAes256DecryptKey(keyChainKey, encryptedData)\n\t\t} catch (e) {\n\t\t\tif (e instanceof CryptoError) {\n\t\t\t\t// If the key could not be decrypted it means that something went very wrong. We will probably not be able to do anything about it so just\n\t\t\t\t// delete everything.\n\t\t\t\tthrow new KeyPermanentlyInvalidatedError(`Could not decrypt credentials: ${e.stack ?? e.message}`)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tasync encryptUsingKeychain(data: Uint8Array, encryptionMode: DesktopCredentialsMode): Promise<Uint8Array> {\n\t\ttry {\n\t\t\tassertSupportedEncryptionMode(encryptionMode)\n\t\t\tconst keyChainKey = await this.desktopKeyStoreFacade.getKeyChainKey()\n\t\t\tconst encryptedData = this.crypto.aes256EncryptKey(keyChainKey, data)\n\t\t\treturn this.appPassHandler.addAppPassWrapper(encryptedData, encryptionMode)\n\t\t} catch (e) {\n\t\t\tif (e instanceof CryptoError) {\n\t\t\t\t// If the key could not be decrypted it means that something went very wrong. We will probably not be able to do anything about it so just\n\t\t\t\t// delete everything.\n\t\t\t\tthrow new KeyPermanentlyInvalidatedError(`Could not encrypt credentials: ${e.stack ?? e.message}`)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n}\n","import o from \"@tutao/otest\"\nimport { KeychainEncryption } from \"../../../../src/common/desktop/credentials/KeychainEncryption.js\"\nimport { object, when } from \"testdouble\"\nimport { AppPassHandler } from \"../../../../src/common/desktop/credentials/AppPassHandler.js\"\nimport { DesktopNativeCryptoFacade } from \"../../../../src/common/desktop/DesktopNativeCryptoFacade.js\"\nimport { DesktopKeyStoreFacade } from \"../../../../src/common/desktop/DesktopKeyStoreFacade.js\"\nimport { CredentialEncryptionMode } from \"../../../../src/common/misc/credentials/CredentialEncryptionMode.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { KeyPermanentlyInvalidatedError } from \"../../../../src/common/api/common/error/KeyPermanentlyInvalidatedError.js\"\n\no.spec(\"KeychainEncryption\", () => {\n\tlet encryption: KeychainEncryption\n\tconst appPassHandler: AppPassHandler = object()\n\tconst crypto: DesktopNativeCryptoFacade = object()\n\tconst keystore: DesktopKeyStoreFacade = object()\n\tconst unencryptedData = new Uint8Array([0x0d, 0x0a, 0x07, 0x0a])\n\tconst encryptedData = new Uint8Array([0x0e, 0x04, 0x0c, 0x01, 0x03])\n\tconst wrappedData = new Uint8Array([0x03, 0x01, 0x03, 0x0a, 0x07, 0x07, 0x0e, 0x0d])\n\tconst keychainKey = [0x02, 0x0e, 0x04, 0x0c, 0x04, 0x0a, 0x01, 0x04]\n\n\to.beforeEach(() => {\n\t\tencryption = new KeychainEncryption(appPassHandler, crypto, keystore)\n\t})\n\n\to.test(\"encryptUsingKeychain\", async () => {\n\t\twhen(keystore.getKeyChainKey()).thenResolve(keychainKey)\n\t\twhen(crypto.aes256EncryptKey(keychainKey, unencryptedData)).thenReturn(encryptedData)\n\t\twhen(appPassHandler.addAppPassWrapper(encryptedData, CredentialEncryptionMode.DEVICE_LOCK)).thenResolve(wrappedData)\n\t\tconst result = await encryption.encryptUsingKeychain(unencryptedData, CredentialEncryptionMode.DEVICE_LOCK)\n\t\to(result).deepEquals(wrappedData)\n\t})\n\n\to.test(\"decryptUsingKeychain\", async () => {\n\t\twhen(appPassHandler.removeAppPassWrapper(wrappedData, CredentialEncryptionMode.DEVICE_LOCK)).thenResolve(encryptedData)\n\t\twhen(keystore.getKeyChainKey()).thenResolve(keychainKey)\n\t\twhen(crypto.unauthenticatedAes256DecryptKey(keychainKey, encryptedData)).thenReturn(unencryptedData)\n\n\t\tconst result = await encryption.decryptUsingKeychain(wrappedData, CredentialEncryptionMode.DEVICE_LOCK)\n\t\to(result).deepEquals(unencryptedData)\n\t})\n\n\to.test(\"when decrypt fails it throws correct error\", async () => {\n\t\twhen(keystore.getKeyChainKey()).thenResolve(keychainKey)\n\t\twhen(appPassHandler.removeAppPassWrapper(wrappedData, CredentialEncryptionMode.DEVICE_LOCK)).thenResolve(encryptedData)\n\t\twhen(crypto.unauthenticatedAes256DecryptKey(keychainKey, encryptedData)).thenThrow(new CryptoError(\"test\"))\n\n\t\tawait o(() => encryption.decryptUsingKeychain(wrappedData, CredentialEncryptionMode.DEVICE_LOCK)).asyncThrows(KeyPermanentlyInvalidatedError)\n\t})\n})\n"],"mappings":"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"}