{"version":3,"file":"SharedMailUtils-AmFaSJP6.js","names":["blobFacade: BlobFacade","observeProgress: ProgressObserver","tutanotaFiles: TutanotaFile[]","action: DownloadPostProcessing","progress?: stream<number>","downloadedFiles: Array<FileReference | DataFile>","file: TutanotaFile","files: Array<TutanotaFile>","e: Error","errorAction: (msg: TranslationKey) => R","nativeFiles: Array<File>","evt: ProgressEvent","target: any","allowMultiple: boolean","allowedExtensions?: Array<string>","promise: Promise<Array<DataFile>>","e: Event","e","dataFiles: Array<DataFile>","name: string","dataFile: DataFile","url","downloadPromise: Promise<void>","fileTypes?: Array<string>","isFileOnly: boolean","readFiles: DataFile[]","user: User","mailAddress: string","name: string","name: string | null","preferNameOnly: boolean","mailboxDetail: MailboxDetail","userGroupInfo: GroupInfo","mailboxDetails: MailboxDetail","logins: LoginController","address: string","userController: UserController","sortedLanguages: Array<Language>","entityClient: EntityClient","loginController: LoginController","conversationType: ConversationType","key: TranslationKey","files: ReadonlyArray<Attachment>","maxAttachmentSize: number","attachableFiles: Array<Attachment>","tooBigFiles: Array<string>","ev: Event","handler: ImageHandler","tooBig: DataFile[]"],"sources":["../../src/common/file/FileController.ts","../../src/common/mailFunctionality/SharedMailUtils.ts"],"sourcesContent":["import { Dialog } from \"../gui/base/Dialog.js\"\nimport { convertToDataFile, createDataFile, DataFile } from \"../api/common/DataFile\"\nimport { assertMainOrNode, isApp } from \"../api/common/Env\"\nimport { assertNotNull, neverNull, promiseMap } from \"@tutao/tutanota-utils\"\nimport { lang, TranslationKey } from \"../misc/LanguageViewModel.js\"\nimport { BrowserType } from \"../misc/ClientConstants.js\"\nimport { client } from \"../misc/ClientDetector.js\"\nimport { File as TutanotaFile } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { deduplicateFilenames, FileReference, sanitizeFilename } from \"../api/common/utils/FileUtils\"\n\nimport { BlobFacade } from \"../api/worker/facades/lazy/BlobFacade.js\"\nimport { ArchiveDataType } from \"../api/common/TutanotaConstants.js\"\nimport stream from \"mithril/stream\"\nimport Stream from \"mithril/stream\"\nimport { showProgressDialog } from \"../gui/dialogs/ProgressDialog.js\"\nimport { CancelledError } from \"../api/common/error/CancelledError.js\"\nimport { ConnectionError } from \"../api/common/error/RestError.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { isOfflineError } from \"../api/common/utils/ErrorUtils.js\"\nimport { locator } from \"../api/main/CommonLocator.js\"\nimport { PermissionError } from \"../api/common/error/PermissionError.js\"\nimport { FileNotFoundError } from \"../api/common/error/FileNotFoundError.js\"\nimport { createReferencingInstance } from \"../api/common/utils/BlobUtils.js\"\n\nassertMainOrNode()\nexport const CALENDAR_MIME_TYPE = \"text/calendar\"\n\n// We want to handle both types of vCards\nexport enum VCARD_MIME_TYPES {\n\tX_VCARD = \"text/x-vcard\",\n\tVCARD = \"text/vcard\",\n}\n\nexport enum MAIL_MIME_TYPES {\n\tEML = \"message/rfc822\",\n\tMBOX = \"application/mbox\",\n}\n\nconst enum DownloadPostProcessing {\n\tOpen,\n\tWrite,\n}\n\nexport type ProgressObserver = (somePromise: Promise<void>, progress?: Stream<number>) => Promise<void>\n\n/**\n * coordinates single and multiple downloads on different platforms\n */\nexport abstract class FileController {\n\tprotected constructor(protected readonly blobFacade: BlobFacade, protected readonly observeProgress: ProgressObserver) {}\n\n\tprivate async doDownload(tutanotaFiles: TutanotaFile[], action: DownloadPostProcessing, progress?: stream<number>): Promise<void> {\n\t\tconst downloadedFiles: Array<FileReference | DataFile> = []\n\t\ttry {\n\t\t\tlet isOffline = false\n\t\t\tfor (const file of tutanotaFiles) {\n\t\t\t\ttry {\n\t\t\t\t\tconst downloadedFile = await this.downloadAndDecrypt(file)\n\t\t\t\t\tdownloadedFiles.push(downloadedFile)\n\t\t\t\t\tif (progress != null) {\n\t\t\t\t\t\tprogress(((tutanotaFiles.indexOf(file) + 1) / tutanotaFiles.length) * 100)\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tawait handleDownloadErrors(e, (msg) => {\n\t\t\t\t\t\tif (msg === \"couldNotAttachFile_msg\") {\n\t\t\t\t\t\t\tisOffline = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDialog.message(lang.makeTranslation(\"error_msg\", lang.get(msg) + \" \" + file.name))\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (isOffline) break // don't try to download more files, but the previous ones (if any) will still be downloaded\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (downloadedFiles.length > 0) {\n\t\t\t\tif (action === DownloadPostProcessing.Open) {\n\t\t\t\t\tthis.openDownloadedFiles(downloadedFiles)\n\t\t\t\t} else {\n\t\t\t\t\tawait this.writeDownloadedFiles(downloadedFiles)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOffline) {\n\t\t\t\tthrow new ConnectionError(\"currently offline\")\n\t\t\t}\n\t\t} finally {\n\t\t\t// we don't necessarily know when the user is done with the temporary file that was opened\n\t\t\t// because we don't have a handle to the opening application/process.\n\t\t\tif (action !== DownloadPostProcessing.Open) await this.cleanUp(downloadedFiles)\n\t\t}\n\t}\n\n\t/**\n\t * get the referenced TutanotaFile as a DataFile without writing anything to disk\n\t */\n\tasync getAsDataFile(file: TutanotaFile): Promise<DataFile> {\n\t\t// using the browser's built-in download since we don't want to write anything to disk here\n\t\treturn downloadAndDecryptDataFile(file, this.blobFacade)\n\t}\n\n\t/**\n\t * Save a DataFile locally\n\t */\n\tabstract saveDataFile(file: DataFile): Promise<void>\n\n\t/**\n\t * Download a file from the server to the filesystem\n\t */\n\tasync download(file: TutanotaFile) {\n\t\tawait this.observeProgress(this.doDownload([file], DownloadPostProcessing.Write))\n\t}\n\n\t/**\n\t * Download all provided files\n\t *\n\t * Temporary files are deleted afterwards in apps.\n\t */\n\tasync downloadAll(files: Array<TutanotaFile>): Promise<void> {\n\t\tconst progress = stream(0)\n\t\tawait this.observeProgress(this.doDownload(files, DownloadPostProcessing.Write, progress), progress)\n\t}\n\n\t/**\n\t * Open a file in the host system\n\t * Temporary files are deleted afterwards in apps.\n\t */\n\tasync open(file: TutanotaFile) {\n\t\tawait this.observeProgress(this.doDownload([file], DownloadPostProcessing.Open))\n\t}\n\n\tprotected abstract writeDownloadedFiles(downloadedFiles: Array<FileReference | DataFile>): Promise<void>\n\n\tprotected abstract openDownloadedFiles(downloadedFiles: Array<FileReference | DataFile>): Promise<void>\n\n\tprotected abstract cleanUp(downloadedFiles: Array<FileReference | DataFile>): Promise<void>\n\n\t/**\n\t * Get a file from the server and decrypt it\n\t */\n\tprotected abstract downloadAndDecrypt(file: TutanotaFile): Promise<FileReference | DataFile>\n}\n\nexport function handleDownloadErrors<R>(e: Error, errorAction: (msg: TranslationKey) => R): R {\n\tif (isOfflineError(e)) {\n\t\treturn errorAction(\"couldNotAttachFile_msg\")\n\t} else if (e instanceof CryptoError) {\n\t\treturn errorAction(\"corrupted_msg\")\n\t} else {\n\t\tthrow e\n\t}\n}\n\nexport function readLocalFiles(nativeFiles: Array<File>): Promise<Array<DataFile>> {\n\treturn promiseMap(\n\t\tnativeFiles,\n\t\t(nativeFile) => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tlet reader = new FileReader()\n\n\t\t\t\treader.onloadend = function (evt: ProgressEvent) {\n\t\t\t\t\tconst target: any = evt.target\n\n\t\t\t\t\tif (target.readyState === reader.DONE && target.result) {\n\t\t\t\t\t\t// DONE == 2\n\t\t\t\t\t\tresolve(convertToDataFile(nativeFile, new Uint8Array(target.result)))\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(new Error(\"could not load file\"))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treader.readAsArrayBuffer(nativeFile)\n\t\t\t})\n\t\t},\n\t\t{\n\t\t\tconcurrency: 5,\n\t\t},\n\t)\n}\n\n/**\n * @param allowMultiple allow selecting multiple files\n * @param allowedExtensions Array of extensions strings without \".\"\n */\nexport function showFileChooser(allowMultiple: boolean, allowedExtensions?: Array<string>): Promise<Array<DataFile>> {\n\t// each time when called create a new file chooser to make sure that the same file can be selected twice directly after another\n\t// remove the last file input\n\tconst fileInput = document.getElementById(\"hiddenFileChooser\")\n\tconst body = neverNull(document.body)\n\n\tif (fileInput) {\n\t\t// remove the old one because it may contain a file already\n\t\tbody.removeChild(fileInput)\n\t}\n\n\tconst newFileInput = document.createElement(\"input\")\n\tnewFileInput.setAttribute(\"type\", \"file\")\n\n\tif (allowMultiple) {\n\t\tnewFileInput.setAttribute(\"multiple\", \"multiple\")\n\t}\n\n\tnewFileInput.setAttribute(\"id\", \"hiddenFileChooser\")\n\n\tif (allowedExtensions) {\n\t\tnewFileInput.setAttribute(\"accept\", allowedExtensions.map((e) => \".\" + e).join(\",\"))\n\t}\n\n\tnewFileInput.style.display = \"none\"\n\tconst promise: Promise<Array<DataFile>> = new Promise((resolve) => {\n\t\tnewFileInput.addEventListener(\"change\", (e: Event) => {\n\t\t\treadLocalFiles((e.target as any).files)\n\t\t\t\t.then(resolve)\n\t\t\t\t.catch(async (e) => {\n\t\t\t\t\tconsole.log(e)\n\t\t\t\t\tawait Dialog.message(\"couldNotAttachFile_msg\")\n\t\t\t\t\tresolve([])\n\t\t\t\t})\n\t\t})\n\t\tnewFileInput.addEventListener(\"cancel\", () => resolve([]))\n\t})\n\t// the file input must be put into the dom, otherwise it does not work in IE\n\tbody.appendChild(newFileInput)\n\tnewFileInput.click()\n\treturn promise\n}\n\n/**\n * takes a list of DataFiles and creates one DataFile from them that represents a zip\n * containing the the other files\n *\n * currently waits on all DataFiles being available before starting to add them to the zip.\n * It may be even faster to create the zip asap and adding the datafiles as they resolve.\n *\n * duplicate file names lead to the second file added overwriting the first one.\n *\n * @param dataFiles Promise resolving to an array of DataFiles\n * @param name the name of the new zip file\n */\nexport async function zipDataFiles(dataFiles: Array<DataFile>, name: string): Promise<DataFile> {\n\tconst jsZip = await import(\"jszip\")\n\tconst zip = jsZip.default()\n\tconst deduplicatedMap = deduplicateFilenames(dataFiles.map((df) => sanitizeFilename(df.name)))\n\tfor (let file of dataFiles) {\n\t\tconst filename = assertNotNull(deduplicatedMap[file.name].shift())\n\t\tzip.file(sanitizeFilename(filename), file.data, { binary: true })\n\t}\n\tconst zipData = await zip.generateAsync({ type: \"uint8array\" })\n\treturn createDataFile(name, \"application/zip\", zipData)\n}\n\nexport async function openDataFileInBrowser(dataFile: DataFile): Promise<void> {\n\ttry {\n\t\tconst URL = window.URL ?? window.webkitURL\n\n\t\t// Workaround for new behaviour in firefox 98 where PDF attachments open in the same tab by default\n\t\t// Users can always change their settings to \"always ask\" or somesuch, but it's very not nice for this to happen at all\n\t\t// because the app gets clobbered, logging users out as well as losing their non-persistent sessions\n\t\t// There is a bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=1756980\n\t\t// It is unclear whether this will be fixed on the firefox side as it seems that they consider it to be expected behaviour\n\t\t// Maybe it will gain enough traction that it will be reverted\n\t\t// It's unclear to me why target=_blank is being ignored. If there is a way to ensure that it always opens a new tab,\n\t\t// Then we should do that instead of this, because it's preferable to keep the mime type.\n\t\tconst needsPdfWorkaround = dataFile.mimeType === \"application/pdf\" && client.browser === BrowserType.FIREFOX && client.browserVersion >= 98\n\n\t\tconst mimeType = needsPdfWorkaround ? \"application/octet-stream\" : dataFile.mimeType\n\n\t\tconst blob = new Blob([dataFile.data], { type: mimeType })\n\t\tconst url = URL.createObjectURL(blob)\n\t\tconst a = document.createElement(\"a\")\n\n\t\tif (typeof a.download !== \"undefined\") {\n\t\t\ta.href = url\n\t\t\ta.download = dataFile.name\n\t\t\ta.style.display = \"none\"\n\t\t\ta.target = \"_blank\"\n\t\t\tdocument.body.appendChild(a)\n\t\t\ta.click()\n\t\t\tdocument.body.removeChild(a)\n\t\t\t// Do not revoke object URL right away so that the browser has a chance to open it\n\t\t\tsetTimeout(() => {\n\t\t\t\twindow.URL.revokeObjectURL(url)\n\t\t\t}, 2000)\n\t\t} else {\n\t\t\tif (client.isIos() && client.browser === BrowserType.CHROME && typeof FileReader === \"function\") {\n\t\t\t\tconst reader = new FileReader()\n\t\t\t\tconst downloadPromise = new Promise((resolve) => {\n\t\t\t\t\treader.onloadend = async function () {\n\t\t\t\t\t\tconst url = reader.result as any\n\t\t\t\t\t\tresolve(await Dialog.legacyDownload(dataFile.name, url))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treader.readAsDataURL(blob)\n\t\t\t\tawait downloadPromise\n\t\t\t} else {\n\t\t\t\t// if the download attribute is not supported try to open the link in a new tab.\n\t\t\t\tawait Dialog.legacyDownload(dataFile.name, url)\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tconsole.log(e)\n\t\treturn Dialog.message(\"canNotOpenFileOnDevice_msg\")\n\t}\n}\n\nexport async function downloadAndDecryptDataFile(file: TutanotaFile, blobFacade: BlobFacade): Promise<DataFile> {\n\tconst bytes = await blobFacade.downloadAndDecrypt(ArchiveDataType.Attachments, createReferencingInstance(file))\n\treturn convertToDataFile(file, bytes)\n}\n\nexport async function guiDownload(downloadPromise: Promise<void>, progress?: stream<number>): Promise<void> {\n\ttry {\n\t\tawait showProgressDialog(\"pleaseWait_msg\", downloadPromise, progress)\n\t} catch (e) {\n\t\t// handle the user cancelling the dialog\n\t\tif (e instanceof CancelledError) {\n\t\t\treturn\n\t\t}\n\t\tconsole.log(\"downloadAndOpen error\", e.message)\n\t\tawait handleDownloadErrors(e, Dialog.message)\n\t}\n}\n\nexport async function showNativeFilePicker(fileTypes?: Array<string>, isFileOnly: boolean = false): Promise<ReadonlyArray<DataFile>> {\n\tif (isApp()) {\n\t\tconst rect = { width: 0, height: 0, left: 0, top: 0 } as DOMRect\n\t\ttry {\n\t\t\tconst fileApp = locator.fileApp\n\t\t\tconst fileList = await fileApp.openFileChooser(rect, fileTypes, isFileOnly)\n\t\t\tconst readFiles: DataFile[] = []\n\t\t\tfor (const file of fileList) {\n\t\t\t\tconst data = await fileApp.readDataFile(file.location)\n\n\t\t\t\tif (!data) continue\n\n\t\t\t\treadFiles.push(data)\n\t\t\t}\n\n\t\t\treturn Promise.resolve(readFiles)\n\t\t} catch (err) {\n\t\t\tif (err instanceof PermissionError) {\n\t\t\t\tDialog.message(\"fileAccessDeniedMobile_msg\")\n\t\t\t} else if (err instanceof FileNotFoundError) {\n\t\t\t\tDialog.message(\"couldNotAttachFile_msg\")\n\t\t\t}\n\n\t\t\tconsole.log(\"Failed read files\", err)\n\t\t}\n\t}\n\n\treturn Promise.resolve([])\n}\n","import { assertMainOrNode } from \"../api/common/Env.js\"\nimport { CustomerPropertiesTypeRef, GroupInfo, User } from \"../api/entities/sys/TypeRefs.js\"\nimport { Contact, createContact, createContactMailAddress, Mail } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { fullNameToFirstAndLastName, mailAddressToFirstAndLastName } from \"../misc/parsing/MailAddressParser.js\"\nimport { assertNotNull, contains, neverNull, uint8ArrayToBase64 } from \"@tutao/tutanota-utils\"\nimport {\n\tALLOWED_IMAGE_FORMATS,\n\tContactAddressType,\n\tConversationType,\n\tEncryptionAuthStatus,\n\tGroupType,\n\tMailState,\n\tMAX_ATTACHMENT_SIZE,\n\tMAX_BASE64_IMAGE_SIZE,\n\tSYSTEM_GROUP_MAIL_ADDRESS,\n\tTUTA_MAIL_ADDRESS_DOMAINS,\n} from \"../api/common/TutanotaConstants.js\"\nimport { UserController } from \"../api/main/UserController.js\"\nimport { getEnabledMailAddressesForGroupInfo, getGroupInfoDisplayName } from \"../api/common/utils/GroupUtils.js\"\nimport { lang, Language, Translation, TranslationKey } from \"../misc/LanguageViewModel.js\"\nimport { MailboxDetail } from \"./MailboxModel.js\"\nimport { LoginController } from \"../api/main/LoginController.js\"\nimport { EntityClient } from \"../api/common/EntityClient.js\"\nimport { Attachment } from \"./SendMailModel.js\"\nimport { showFileChooser } from \"../file/FileController.js\"\nimport { DataFile } from \"../api/common/DataFile.js\"\nimport { Dialog } from \"../gui/base/Dialog.js\"\n\nassertMainOrNode()\nexport const LINE_BREAK = \"<br>\"\n\n/**\n * Creates a contact with an email address and a name.\n * @param mailAddress The mail address of the contact. Type is OTHER.\n * @param name The name of the contact. If an empty string is provided, the name is parsed from the mail address.\n * @return The contact.\n */\nexport function createNewContact(user: User, mailAddress: string, name: string): Contact {\n\t// prepare some contact information. it is only saved if the mail is sent securely\n\t// use the name or mail address to extract first and last name. first part is used as first name, all other parts as last name\n\tlet firstAndLastName = name.trim() !== \"\" ? fullNameToFirstAndLastName(name) : mailAddressToFirstAndLastName(mailAddress)\n\tlet contact = createContact({\n\t\t_ownerGroup: assertNotNull(\n\t\t\tuser.memberships.find((m) => m.groupType === GroupType.Contact),\n\t\t\t\"called createNewContact as user without contact group mship\",\n\t\t).group,\n\t\tfirstName: firstAndLastName.firstName,\n\t\tlastName: firstAndLastName.lastName,\n\t\tmailAddresses: [\n\t\t\tcreateContactMailAddress({\n\t\t\t\taddress: mailAddress,\n\t\t\t\ttype: ContactAddressType.OTHER,\n\t\t\t\tcustomTypeName: \"\",\n\t\t\t}),\n\t\t],\n\t\tbirthdayIso: null,\n\t\tcomment: \"\",\n\t\tcompany: \"\",\n\t\tnickname: null,\n\t\toldBirthdayDate: null,\n\t\tpresharedPassword: null,\n\t\trole: \"\",\n\t\ttitle: null,\n\t\taddresses: [],\n\t\toldBirthdayAggregate: null,\n\t\tphoneNumbers: [],\n\t\tphoto: null,\n\t\tsocialIds: [],\n\t\tdepartment: null,\n\t\tmiddleName: null,\n\t\tnameSuffix: null,\n\t\tphoneticFirst: null,\n\t\tphoneticLast: null,\n\t\tphoneticMiddle: null,\n\t\tcustomDate: [],\n\t\tmessengerHandles: [],\n\t\tpronouns: [],\n\t\trelationships: [],\n\t\twebsites: [],\n\t})\n\treturn contact\n}\n\nexport function getMailAddressDisplayText(name: string | null, mailAddress: string, preferNameOnly: boolean): string {\n\tif (!name) {\n\t\treturn mailAddress\n\t} else if (preferNameOnly) {\n\t\treturn name\n\t} else {\n\t\treturn name + \" <\" + mailAddress + \">\"\n\t}\n}\n\nexport function getEnabledMailAddressesWithUser(mailboxDetail: MailboxDetail, userGroupInfo: GroupInfo): Array<string> {\n\tif (isUserMailbox(mailboxDetail)) {\n\t\treturn getEnabledMailAddressesForGroupInfo(userGroupInfo)\n\t} else {\n\t\treturn getEnabledMailAddressesForGroupInfo(mailboxDetail.mailGroupInfo)\n\t}\n}\n\nexport function isUserMailbox(mailboxDetails: MailboxDetail): boolean {\n\treturn mailboxDetails.mailGroup != null && mailboxDetails.mailGroup.user != null\n}\n\nexport function getDefaultSender(logins: LoginController, mailboxDetails: MailboxDetail): string {\n\tif (isUserMailbox(mailboxDetails)) {\n\t\tlet props = logins.getUserController().props\n\t\treturn props.defaultSender && contains(getEnabledMailAddressesWithUser(mailboxDetails, logins.getUserController().userGroupInfo), props.defaultSender)\n\t\t\t? props.defaultSender\n\t\t\t: assertNotNull(logins.getUserController().userGroupInfo.mailAddress)\n\t} else {\n\t\treturn assertNotNull(mailboxDetails.mailGroupInfo.mailAddress)\n\t}\n}\n\nexport function isUserEmail(logins: LoginController, mailboxDetails: MailboxDetail, address: string): boolean {\n\tif (isUserMailbox(mailboxDetails)) {\n\t\treturn (\n\t\t\tcontains(getEnabledMailAddressesWithUser(mailboxDetails, logins.getUserController().userGroupInfo), address) ||\n\t\t\tlogins.getUserController().userGroupInfo.mailAddress === address\n\t\t)\n\t} else {\n\t\treturn mailboxDetails.mailGroupInfo.mailAddress === address\n\t}\n}\n\nexport function getSenderNameForUser(mailboxDetails: MailboxDetail, userController: UserController): string {\n\tif (isUserMailbox(mailboxDetails)) {\n\t\t// external users do not have access to the user group info\n\t\treturn userController.userGroupInfo.name\n\t} else {\n\t\treturn mailboxDetails.mailGroupInfo ? mailboxDetails.mailGroupInfo.name : \"\"\n\t}\n}\n\nexport function getMailboxName(logins: LoginController, mailboxDetails: MailboxDetail): string {\n\tif (!logins.isInternalUserLoggedIn()) {\n\t\treturn lang.get(\"mailbox_label\")\n\t} else if (isUserMailbox(mailboxDetails)) {\n\t\treturn getDefaultSender(logins, mailboxDetails)\n\t} else {\n\t\treturn getGroupInfoDisplayName(assertNotNull(mailboxDetails.mailGroupInfo, \"mailboxDetails without mailGroupInfo?\"))\n\t}\n}\n\nexport interface ImageHandler {\n\tinsertImage(srcAttr: string, attrs?: Record<string, string>): HTMLElement\n}\n\nexport function getTemplateLanguages(sortedLanguages: Array<Language>, entityClient: EntityClient, loginController: LoginController): Promise<Array<Language>> {\n\treturn loginController\n\t\t.getUserController()\n\t\t.loadCustomer()\n\t\t.then((customer) => entityClient.load(CustomerPropertiesTypeRef, neverNull(customer.properties)))\n\t\t.then((customerProperties) => {\n\t\t\treturn sortedLanguages.filter((sL) => customerProperties.notificationMailTemplates.find((nmt) => nmt.language === sL.code))\n\t\t})\n\t\t.catch(() => [])\n}\n\nexport function dialogTitleTranslationKey(conversationType: ConversationType): TranslationKey {\n\tlet key: TranslationKey\n\n\tswitch (conversationType) {\n\t\tcase ConversationType.NEW:\n\t\t\tkey = \"newMail_action\"\n\t\t\tbreak\n\n\t\tcase ConversationType.REPLY:\n\t\t\tkey = \"reply_action\"\n\t\t\tbreak\n\n\t\tcase ConversationType.FORWARD:\n\t\t\tkey = \"forward_action\"\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tkey = \"emptyString_msg\"\n\t}\n\n\treturn key\n}\n\ntype AttachmentSizeCheckResult = {\n\tattachableFiles: Array<Attachment>\n\ttooBigFiles: Array<string>\n}\n\n/**\n * @param files the files that shall be attached.\n * @param maxAttachmentSize the maximum size the new files may have in total to be attached successfully.\n */\nexport function checkAttachmentSize(files: ReadonlyArray<Attachment>, maxAttachmentSize: number = MAX_ATTACHMENT_SIZE): AttachmentSizeCheckResult {\n\tlet totalSize = 0\n\tconst attachableFiles: Array<Attachment> = []\n\tconst tooBigFiles: Array<string> = []\n\tfor (const file of files) {\n\t\tif (totalSize + Number(file.size) > maxAttachmentSize) {\n\t\t\ttooBigFiles.push(file.name)\n\t\t} else {\n\t\t\ttotalSize += Number(file.size)\n\t\t\tattachableFiles.push(file)\n\t\t}\n\t}\n\treturn {\n\t\tattachableFiles,\n\t\ttooBigFiles,\n\t}\n}\n\nexport enum RecipientField {\n\tTO = \"to\",\n\tCC = \"cc\",\n\tBCC = \"bcc\",\n}\n\nexport function isTutaMailAddress(mailAddress: string): boolean {\n\treturn TUTA_MAIL_ADDRESS_DOMAINS.some((tutaDomain) => mailAddress.endsWith(\"@\" + tutaDomain))\n}\n\nexport function hasValidEncryptionAuthForTeamOrSystemMail({ encryptionAuthStatus }: Mail): boolean {\n\tswitch (encryptionAuthStatus) {\n\t\t// emails before tuta-crypt had no encryptionAuthStatus\n\t\tcase null:\n\t\tcase undefined:\n\t\tcase EncryptionAuthStatus.RSA_NO_AUTHENTICATION:\n\t\tcase EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED:\n\t\tcase EncryptionAuthStatus.TUTACRYPT_SENDER: // should only be set for sent NOT received mails\n\t\t\treturn true\n\t\tcase EncryptionAuthStatus.AES_NO_AUTHENTICATION:\n\t\tcase EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED:\n\t\tdefault:\n\t\t\t// we have to be able to handle future cases, to be safe we say that they are not valid encryptionAuth\n\t\t\treturn false\n\t}\n}\n\n/**\n * Is this a system notification?\n */\nexport function isSystemNotification(mail: Mail): boolean {\n\tconst { confidential, sender, state } = mail\n\treturn (\n\t\tstate === MailState.RECEIVED &&\n\t\tconfidential &&\n\t\thasValidEncryptionAuthForTeamOrSystemMail(mail) &&\n\t\t(sender.address === SYSTEM_GROUP_MAIL_ADDRESS ||\n\t\t\t// New emails will have sender set to system and will only have replyTo set to no-reply\n\t\t\t// but we should keep displaying old emails correctly.\n\t\t\tisNoReplyTeamAddress(sender.address))\n\t)\n}\n\nexport function isNoReplyTeamAddress(address: string): boolean {\n\treturn address === \"no-reply@tutao.de\" || address === \"no-reply@tutanota.de\"\n}\n\nexport function insertInlineImageB64ClickHandler(ev: Event, handler: ImageHandler) {\n\tshowFileChooser(true, ALLOWED_IMAGE_FORMATS).then((files) => {\n\t\tconst tooBig: DataFile[] = []\n\n\t\tfor (let file of files) {\n\t\t\tif (file.size > MAX_BASE64_IMAGE_SIZE) {\n\t\t\t\ttooBig.push(file)\n\t\t\t} else {\n\t\t\t\tconst b64 = uint8ArrayToBase64(file.data)\n\t\t\t\tconst dataUrlString = `data:${file.mimeType};base64,${b64}`\n\t\t\t\thandler.insertImage(dataUrlString, {\n\t\t\t\t\tstyle: \"max-width: 100%\",\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tif (tooBig.length > 0) {\n\t\t\tDialog.message(\n\t\t\t\tlang.getTranslation(\"tooBigInlineImages_msg\", {\n\t\t\t\t\t\"{size}\": MAX_BASE64_IMAGE_SIZE / 1024,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t})\n}\n\n// .msg export is handled in DesktopFileExport because it uses APIs that can't be loaded web side\nexport type MailExportMode = \"msg\" | \"eml\"\n/**\n * Used to pass all downloaded mail stuff to the desktop side to be exported as a file\n * Ideally this would just be {Mail, Headers, Body, FileReference[]}\n * but we can't send Dates over to the native side, so we may as well just extract everything here\n */\nexport type MailBundleRecipient = {\n\taddress: string\n\tname?: string\n}\n\nexport type MailBundle = {\n\tmailId: IdTuple\n\tsubject: string\n\tbody: string\n\tsender: MailBundleRecipient\n\tto: MailBundleRecipient[]\n\tcc: MailBundleRecipient[]\n\tbcc: MailBundleRecipient[]\n\treplyTo: MailBundleRecipient[]\n\tisDraft: boolean\n\tisRead: boolean\n\tsentOn: number\n\t// UNIX timestamp\n\treceivedOn: number // UNIX timestamp,\n\theaders: string | null\n\tattachments: DataFile[]\n}\n"],"mappings":"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"}