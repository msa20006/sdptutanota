{"version":3,"file":"FileUtils-W-u2-gZz.js","names":["fileName: string","filename: string","filenames: Array<string>","_taken: ReadonlySet<string>","name: string","number: number","out: Record<string, string[]>","duplicateCounts: Record<string, number>","file: Attachment","TutanotaFileTypeRef","files: Array<Attachment>","fileList: FileList","nativeFiles: File[]"],"sources":["../../src/common/api/common/utils/FileUtils.ts"],"sourcesContent":["import { downcast, intersection, isSameTypeRef, toLowerCase } from \"@tutao/tutanota-utils\"\nimport type { File as TutanotaFile } from \"../../entities/tutanota/TypeRefs.js\"\nimport { FileTypeRef as TutanotaFileTypeRef } from \"../../entities/tutanota/TypeRefs.js\"\nimport { DataFile } from \"../DataFile\"\nimport type { Attachment } from \"../../../mailFunctionality/SendMailModel.js\"\n\ntype StringPredicate = (arg0: string) => boolean\n\n/**\n * a reference by path to a file on disk\n */\nexport interface FileReference {\n\treadonly _type: \"FileReference\"\n\tname: string\n\tmimeType: string\n\tlocation: string\n\tsize: number\n\tcid?: string\n}\n\nconst _false: StringPredicate = () => false\n\n/**\n * Get the file extension of a filename\n * so\n *  file.txt -> .txt\n *  archive.tar.gz -> .tar.gz\n * @param fileName\n */\nexport function getFileExtension(fileName: string): string {\n\treturn (fileName.match(/\\..+$/) || [\"\"])[0]\n}\n\n/**\n * The inverse of getTrailingFileExtension\n * @param fileName\n */\nexport function getFileBaseName(fileName: string): string {\n\tconst extension = getFileExtension(fileName)\n\treturn fileName.substring(0, extension ? fileName.lastIndexOf(extension) : fileName.length)\n}\n\nexport function unreserveFileName(fileName: string): string {\n\tif (fileName === \".\" || fileName === \"..\") {\n\t\treturn `${fileName}_`\n\t}\n\n\t// CON, CON.txt, COM0 etc. (windows device files)\n\tconst winReservedRe = /^(CON|PRN|LPT[0-9]|COM[0-9]|AUX|NUL)($|\\..*$)/i\n\tconst extension = getFileExtension(fileName)\n\tconst baseName = getFileBaseName(fileName)\n\treturn env.platformId === \"win32\" && winReservedRe.test(baseName) ? `${baseName}_${extension}` : fileName\n}\n\n/**\n * removes invalid characters from the given filename\n * by replacing them with underscores (non-platform-specific)\n */\nexport function sanitizeFilename(filename: string): string {\n\t// / ? < > \\ : * | \"\n\tconst illegalRe = /[/?<>\\\\:*|\"]/g\n\t// unicode control codes\n\tconst controlRe = /[\\x00-\\x1f\\x80-\\x9f]/g\n\t// trailing period in windows file names\n\t// this is valid in linux but can't be checked from the browser\n\tconst windowsTrailingRe = /[. ]+$/\n\treturn unreserveFileName(filename).replace(illegalRe, \"_\").replace(controlRe, \"_\").replace(windowsTrailingRe, \"_\")\n}\n\n/**\n * Uniqueify all the names in fileNames, case-insensitively\n * @param filenames\n * @param _taken: file names that are taken but won't be included in the output\n */\nexport function deduplicateFilenames(filenames: Array<string>, _taken: ReadonlySet<string> = new Set()): Record<string, Array<string>> {\n\t// make taken lowercase aswell for case insensitivity\n\tconst taken = new Set(Array.from(_taken).map(toLowerCase))\n\t// Check first if we need to do a deduplication\n\tconst deduplicatedNames = new Set(filenames.map(toLowerCase))\n\n\t// None of the filenames were duplicated or taken\n\tif (deduplicatedNames.size === filenames.length && intersection(deduplicatedNames, taken).size === 0) {\n\t\t// if all file names are good then just return an identity map\n\t\treturn Object.fromEntries(filenames.map((f) => [f, [f]])) // convert into map oldname -> [newname]\n\t}\n\n\tconst suffix = (name: string, number: number) => {\n\t\tconst basename = name.substring(0, name.indexOf(\".\")) || name\n\t\t// get the file extension or an empty string\n\t\tconst ext = (name.match(/\\..+$/) || [\"\"])[0]\n\t\treturn `${basename} (${number})${ext}`\n\t}\n\n\t// do the deduplication\n\tconst out: Record<string, string[]> = {}\n\tconst duplicateCounts: Record<string, number> = {}\n\n\tfor (let name of filenames) {\n\t\tconst lower = name.toLowerCase()\n\t\tlet dedupName\n\n\t\tif (duplicateCounts[lower] === undefined) {\n\t\t\tduplicateCounts[lower] = 0\n\t\t\tdedupName = taken.has(lower) ? suffix(name, ++duplicateCounts[lower]) : name\n\t\t} else {\n\t\t\tdedupName = suffix(name, ++duplicateCounts[lower])\n\t\t}\n\n\t\tif (!out[name]) {\n\t\t\tout[name] = []\n\t\t}\n\n\t\tout[name].push(dedupName)\n\t}\n\n\treturn out\n}\n\n/**\n * checks if the given filename is a reserved filename on the current platform\n * @param filename\n * @returns {boolean}\n * @private\n */\nexport function isReservedFilename(filename: string): boolean {\n\t// CON, CON.txt, COM0 etc. (windows device files)\n\tconst winReservedRe = /^(CON|PRN|LPT[0-9]|COM[0-9]|AUX|NUL)($|\\..*$)/i\n\t// .. and .\n\tconst reservedRe = /^\\.{1,2}$/\n\treturn (env.platformId === \"win32\" && winReservedRe.test(filename)) || reservedRe.test(filename)\n}\n\nexport function isTutanotaFile(file: Attachment): file is TutanotaFile {\n\treturn (\n\t\tfile._type &&\n\t\ttypeof file._type === \"object\" &&\n\t\tObject.hasOwn(file._type, \"app\") &&\n\t\tObject.hasOwn(file._type, \"type\") &&\n\t\tisSameTypeRef(downcast(file._type), TutanotaFileTypeRef)\n\t)\n}\n\nexport function isDataFile(file: Attachment): file is DataFile {\n\treturn file._type === \"DataFile\"\n}\n\nexport function isFileReference(file: Attachment): file is FileReference {\n\treturn file._type === \"FileReference\"\n}\n\nexport function assertOnlyFileReferences(files: Array<Attachment>): asserts files is Array<FileReference> {\n\tif (files.some((f) => !isFileReference(f))) throw new TypeError(\"not only FileReference\")\n}\n\nexport function assertOnlyDataFiles(files: Array<Attachment>): asserts files is Array<DataFile> {\n\tif (files.some((f) => !isDataFile(f))) throw new TypeError(\"not only DataFiles\")\n}\n\nexport function fileListToArray(fileList: FileList): Array<File> {\n\t// create an array of files form the FileList because we can not iterate the FileList directly\n\tlet nativeFiles: File[] = []\n\n\tfor (let i = 0; i < fileList.length; i++) {\n\t\tnativeFiles.push(fileList[i])\n\t}\n\n\treturn nativeFiles\n}\n"],"mappings":"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"}