{"version":3,"file":"CalendarInvites-BycZJjjH.js","names":["fileData: DataFile","file: TutanotaFile","invitedConfidentially: boolean","mailboxModel: MailboxModel","calendarModel: CalendarModel","logins: LoginController","calendarNotificationSender: CalendarNotificationSender","sendMailModelFactory: (mailboxDetails: MailboxDetail, mailboxProperties: MailboxProperties) => Promise<SendMailModel>","event: CalendarEvent","attendee: CalendarEventAttendee","decision: CalendarAttendeeStatus","previousMail: Mail","mailboxDetails: MailboxDetail","responder: string"],"sources":["../../src/calendar-app/calendar/view/CalendarInvites.ts"],"sourcesContent":["import { parseCalendarFile } from \"../../../common/calendar/import/CalendarImporter.js\"\nimport type { CalendarEvent, CalendarEventAttendee, File as TutanotaFile, Mail, MailboxProperties } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { locator } from \"../../../common/api/main/CommonLocator.js\"\nimport { CalendarAttendeeStatus, CalendarMethod, ConversationType, FeatureType, getAsEnumValue } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { assert, assertNotNull, clone, filterInt, noOp, Require } from \"@tutao/tutanota-utils\"\nimport { findFirstPrivateCalendar } from \"../../../common/calendar/date/CalendarUtils.js\"\nimport { CalendarNotificationSender } from \"./CalendarNotificationSender.js\"\nimport { Dialog } from \"../../../common/gui/base/Dialog.js\"\nimport { UserError } from \"../../../common/api/main/UserError.js\"\nimport { DataFile } from \"../../../common/api/common/DataFile.js\"\nimport { findAttendeeInAddresses } from \"../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { Recipient } from \"../../../common/api/common/recipients/Recipient.js\"\nimport { CalendarEventModel, CalendarOperation, EventType } from \"../gui/eventeditor-model/CalendarEventModel.js\"\nimport { CalendarNotificationModel } from \"../gui/eventeditor-model/CalendarNotificationModel.js\"\nimport { ResolveMode } from \"../../../common/api/main/RecipientsModel.js\"\nimport { isCustomizationEnabledForCustomer } from \"../../../common/api/common/utils/CustomerUtils.js\"\nimport { getEventType } from \"../gui/CalendarGuiUtils.js\"\nimport { CalendarModel } from \"../model/CalendarModel.js\"\nimport { LoginController } from \"../../../common/api/main/LoginController.js\"\nimport type { MailboxDetail, MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { SendMailModel } from \"../../../common/mailFunctionality/SendMailModel.js\"\nimport { RecipientField } from \"../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel.js\"\n\n// not picking the status directly from CalendarEventAttendee because it's a NumberString\nexport type Guest = Recipient & { status: CalendarAttendeeStatus }\n\nexport type ParsedIcalFileContent =\n\t| {\n\t\t\tmethod: CalendarMethod\n\t\t\tevents: Array<CalendarEvent>\n\t\t\tuid: string\n\t  }\n\t| None\n\nasync function getParsedEvent(fileData: DataFile): Promise<ParsedIcalFileContent> {\n\ttry {\n\t\tconst { contents, method } = await parseCalendarFile(fileData)\n\t\tconst uid = contents[0].event.uid\n\t\tif (uid == null) return null\n\t\tassert(!contents.some((c) => c.event.uid !== uid), \"received invite with multiple events, but mismatched UIDs\")\n\t\treturn {\n\t\t\tevents: contents.map((c) => c.event),\n\t\t\tuid,\n\t\t\tmethod: getAsEnumValue(CalendarMethod, method) || CalendarMethod.PUBLISH,\n\t\t}\n\t} catch (e) {\n\t\tconsole.log(e)\n\t\treturn null\n\t}\n}\n\nexport async function showEventDetails(event: CalendarEvent, eventBubbleRect: ClientRect, mail: Mail | null): Promise<void> {\n\tconst [latestEvent, { CalendarEventPopup }, { CalendarEventPreviewViewModel }, { htmlSanitizer }] = await Promise.all([\n\t\tgetLatestEvent(event),\n\t\timport(\"../gui/eventpopup/CalendarEventPopup.js\"),\n\t\timport(\"../gui/eventpopup/CalendarEventPreviewViewModel.js\"),\n\t\timport(\"../../../common/misc/HtmlSanitizer.js\"),\n\t])\n\n\tlet eventType: EventType\n\tlet editModelsFactory: (mode: CalendarOperation) => Promise<CalendarEventModel | null>\n\tlet hasBusinessFeature: boolean\n\tlet ownAttendee: CalendarEventAttendee | null = null\n\tconst lazyIndexEntry = async () => (latestEvent.uid != null ? locator.calendarFacade.getEventsByUid(latestEvent.uid) : null)\n\tif (!locator.logins.getUserController().isInternalUser()) {\n\t\t// external users cannot delete/edit events as they have no calendar.\n\t\teventType = EventType.EXTERNAL\n\t\teditModelsFactory = () => new Promise(noOp)\n\t\thasBusinessFeature = false\n\t} else {\n\t\tconst [calendarInfos, mailboxDetails, customer] = await Promise.all([\n\t\t\t(await locator.calendarModel()).getCalendarInfos(),\n\t\t\tlocator.mailboxModel.getUserMailboxDetails(),\n\t\t\tlocator.logins.getUserController().loadCustomer(),\n\t\t])\n\t\tconst mailboxProperties = await locator.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot)\n\t\tconst ownMailAddresses = mailboxProperties.mailAddressProperties.map(({ mailAddress }) => mailAddress)\n\t\townAttendee = findAttendeeInAddresses(latestEvent.attendees, ownMailAddresses)\n\t\teventType = getEventType(latestEvent, calendarInfos, ownMailAddresses, locator.logins.getUserController())\n\t\teditModelsFactory = (mode: CalendarOperation) => locator.calendarEventModel(mode, latestEvent, mailboxDetails, mailboxProperties, mail)\n\t\thasBusinessFeature =\n\t\t\tisCustomizationEnabledForCustomer(customer, FeatureType.BusinessFeatureEnabled) || (await locator.logins.getUserController().isNewPaidPlan())\n\t}\n\n\tconst viewModel = new CalendarEventPreviewViewModel(\n\t\tlatestEvent,\n\t\tawait locator.calendarModel(),\n\t\teventType,\n\t\thasBusinessFeature,\n\t\townAttendee,\n\t\tlazyIndexEntry,\n\t\teditModelsFactory,\n\t)\n\tnew CalendarEventPopup(viewModel, eventBubbleRect, htmlSanitizer).show()\n}\n\nexport async function getEventsFromFile(file: TutanotaFile, invitedConfidentially: boolean): Promise<ParsedIcalFileContent> {\n\tconst dataFile = await locator.fileController.getAsDataFile(file)\n\tconst contents = await getParsedEvent(dataFile)\n\tfor (const event of contents?.events ?? []) {\n\t\tevent.invitedConfidentially = invitedConfidentially\n\t}\n\treturn contents\n}\n\n/**\n * Returns the latest version for the given event by uid and recurrenceId. If the event is not in\n * any calendar (because it has not been stored yet, e.g. in case of invite)\n * the given event is returned.\n */\nexport async function getLatestEvent(event: CalendarEvent): Promise<CalendarEvent> {\n\tconst uid = event.uid\n\tif (uid == null) return event\n\tconst existingEvents = await locator.calendarFacade.getEventsByUid(uid)\n\n\t// If the file we are opening is newer than the one which we have on the server, update server version.\n\t// Should not happen normally but can happen when e.g. reply and update were sent one after another before we accepted\n\t// the invite. Then accepting first invite and then opening update should give us updated version.\n\tconst existingEvent =\n\t\tevent.recurrenceId == null\n\t\t\t? existingEvents?.progenitor // the progenitor does not have a recurrence id and is always first in uid index\n\t\t\t: existingEvents?.alteredInstances.find((e) => e.recurrenceId === event.recurrenceId)\n\n\tif (existingEvent == null) return event\n\n\tif (filterInt(existingEvent.sequence) < filterInt(event.sequence)) {\n\t\tconst calendarModel = await locator.calendarModel()\n\t\treturn await calendarModel.updateEventWithExternal(existingEvent, event)\n\t} else {\n\t\treturn existingEvent\n\t}\n}\n\nexport const enum ReplyResult {\n\tReplyNotSent,\n\tReplySent,\n}\n\nexport class CalendarInviteHandler {\n\tconstructor(\n\t\tprivate readonly mailboxModel: MailboxModel,\n\t\tprivate readonly calendarModel: CalendarModel,\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly calendarNotificationSender: CalendarNotificationSender,\n\t\tprivate sendMailModelFactory: (mailboxDetails: MailboxDetail, mailboxProperties: MailboxProperties) => Promise<SendMailModel>,\n\t) {}\n\n\t/**\n\t * Sends a quick reply for the given event and saves the event to the first private calendar.\n\t * @param event the CalendarEvent to respond to, will be serialized and sent back with updated status, then saved.\n\t * @param attendee the attendee that should respond to the mail\n\t * @param decision the new status of the attendee\n\t * @param previousMail the mail to respond to\n\t */\n\tasync replyToEventInvitation(\n\t\tevent: CalendarEvent,\n\t\tattendee: CalendarEventAttendee,\n\t\tdecision: CalendarAttendeeStatus,\n\t\tpreviousMail: Mail,\n\t\tmailboxDetails: MailboxDetail,\n\t): Promise<ReplyResult> {\n\t\tconst eventClone = clone(event)\n\t\tconst foundAttendee = assertNotNull(findAttendeeInAddresses(eventClone.attendees, [attendee.address.address]), \"attendee was not found in event clone\")\n\t\tfoundAttendee.status = decision\n\n\t\tconst notificationModel = new CalendarNotificationModel(this.calendarNotificationSender, this.logins)\n\t\t//NOTE: mailDetails are getting passed through because the calendar does not have access to the mail folder structure\n\t\t//\twhich is needed to find mailboxdetails by mail. This may be fixed by static mail ids which are being worked on currently.\n\t\t//  This function is only called by EventBanner from the mail app so this should be okay.\n\t\tconst responseModel = await this.getResponseModelForMail(previousMail, mailboxDetails, attendee.address.address)\n\n\t\ttry {\n\t\t\tawait notificationModel.send(eventClone, [], { responseModel, inviteModel: null, cancelModel: null, updateModel: null })\n\t\t} catch (e) {\n\t\t\tif (e instanceof UserError) {\n\t\t\t\tawait Dialog.message(lang.makeTranslation(\"confirm_msg\", e.message))\n\t\t\t\treturn ReplyResult.ReplyNotSent\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t\tconst calendars = await this.calendarModel.getCalendarInfos()\n\t\tconst type = getEventType(event, calendars, [attendee.address.address], this.logins.getUserController())\n\t\tif (type === EventType.SHARED_RO || type === EventType.LOCKED) {\n\t\t\t// if the Event type is shared read only, the event will be updated by the response, trying to update the calendar here will result in error\n\t\t\t// since there is no write permission. (Same issue can happen with locked, no write permission)\n\t\t\treturn ReplyResult.ReplySent\n\t\t}\n\t\tconst calendar = findFirstPrivateCalendar(calendars)\n\t\tif (calendar == null) return ReplyResult.ReplyNotSent\n\t\tif (decision !== CalendarAttendeeStatus.DECLINED && eventClone.uid != null) {\n\t\t\tconst dbEvents = await this.calendarModel.getEventsByUid(eventClone.uid)\n\t\t\tawait this.calendarModel.processCalendarEventMessage(\n\t\t\t\tpreviousMail.sender.address,\n\t\t\t\tCalendarMethod.REQUEST,\n\t\t\t\teventClone as Require<\"uid\", CalendarEvent>,\n\t\t\t\t[],\n\t\t\t\tdbEvents ?? { ownerGroup: calendar.group._id, progenitor: null, alteredInstances: [] },\n\t\t\t)\n\t\t}\n\t\treturn ReplyResult.ReplySent\n\t}\n\n\tasync getResponseModelForMail(previousMail: Mail, mailboxDetails: MailboxDetail, responder: string): Promise<SendMailModel | null> {\n\t\t//NOTE: mailDetails are getting passed through because the calendar does not have access to the mail folder structure\n\t\t//\twhich is needed to find mailboxdetails by mail. This may be fixed by static mail ids which are being worked on currently\n\t\tconst mailboxProperties = await this.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot)\n\t\tconst model = await this.sendMailModelFactory(mailboxDetails, mailboxProperties)\n\t\tawait model.initAsResponse(\n\t\t\t{\n\t\t\t\tpreviousMail,\n\t\t\t\tconversationType: ConversationType.REPLY,\n\t\t\t\tsenderMailAddress: responder,\n\t\t\t\trecipients: [],\n\t\t\t\tattachments: [],\n\t\t\t\tsubject: \"\",\n\t\t\t\tbodyText: \"\",\n\t\t\t\treplyTos: [],\n\t\t\t},\n\t\t\tnew Map(),\n\t\t)\n\t\tawait model.addRecipient(RecipientField.TO, previousMail.sender, ResolveMode.Eager)\n\t\t// Send confidential reply to confidential mails and the other way around.\n\t\t// If the contact is removed or the password is not there the user would see an error but they wouldn't be\n\t\t// able to reply anyway (unless they fix it).\n\t\tmodel.setConfidential(previousMail.confidential)\n\t\treturn model\n\t}\n}\n"],"mappings":"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"}