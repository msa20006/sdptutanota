{"version":3,"file":"SecretStorageTest-BBj-FLCX.js","names":["electron: typeof Electron.CrossProcessExports","fs: typeof FsModule","path: typeof PathModule","service: string","account: string","password: string","electron: ElectronExports","fs: FsExports","subject: SafeStorageSecretStorage"],"sources":["../../src/common/desktop/sse/SecretStorage.ts","../tests/desktop/sse/SecretStorageTest.ts"],"sourcesContent":["import * as PathModule from \"node:path\"\nimport * as FsModule from \"node:fs\"\nimport { DeviceStorageUnavailableError } from \"../../api/common/error/DeviceStorageUnavailableError.js\"\n\nexport function preselectGnomeLibsecret(electron: typeof Electron.CrossProcessExports) {\n\t// this is how chromium selects a backend:\n\t// https://chromium.googlesource.com/chromium/src/+/main/components/os_crypt/sync/key_storage_util_linux.cc\n\t// also for DE detection, which happens before:\n\t// https://chromium.googlesource.com/chromium/src/+/main/base/nix/xdg_util.cc\n\t// I'm 90% sure that it's the deprecated \"GNOME_DESKTOP_SESSION_ID\" env var that's set once you have logged into gnome\n\t// and back out that makes it suddenly work with i3 since chromium falls back to that if none of the more modern vars\n\t// contain something it recognizes.\n\t// if no explicit backend is given, we default to trying gnome-libsecret since that was what we required before.\n\tif (process.platform === \"linux\" && !process.argv.some((a) => a.startsWith(\"--password-store=\"))) {\n\t\telectron.app.commandLine.appendSwitch(\"password-store\", \"gnome-libsecret\")\n\t}\n}\n\nexport interface SecretStorage {\n\tgetPassword(service: string, account: string): Promise<string | null>\n\n\tsetPassword(service: string, account: string, password: string): Promise<void>\n}\n\n/**\n * Secret Storage impl using the electron 15+ SafeStorage API\n *\n * Note: the main thread will be blocked while the keychain is being unlocked,\n * potentially for as long as the user takes to enter a password.\n * We're asking for access before any windows are created, which should prevent\n * any weirdness arising from that.\n */\nexport class SafeStorageSecretStorage implements SecretStorage {\n\tprivate initialized = false\n\n\tconstructor(\n\t\tprivate readonly electron: typeof Electron.CrossProcessExports,\n\t\tprivate readonly fs: typeof FsModule,\n\t\tprivate readonly path: typeof PathModule,\n\t) {}\n\n\tasync getPassword(service: string, account: string): Promise<string | null> {\n\t\tawait this.assertAvailable()\n\t\tconst keyPath = this.getKeyPath(service, account)\n\t\ttry {\n\t\t\tconst encPwBuffer = await this.fs.promises.readFile(keyPath)\n\t\t\treturn this.electron.safeStorage.decryptString(encPwBuffer)\n\t\t} catch (e) {\n\t\t\tif (e.code === \"ENOENT\") {\n\t\t\t\t// the key wasn't created yet\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tasync setPassword(service: string, account: string, password: string): Promise<void> {\n\t\tawait this.assertAvailable()\n\t\tconst keyPath = this.getKeyPath(service, account)\n\t\tconst cypherBuffer = this.electron.safeStorage.encryptString(password)\n\t\treturn this.fs.promises.writeFile(keyPath, cypherBuffer)\n\t}\n\n\tprivate getKeyPath(service: string, account: string): string {\n\t\tconst fname = service.concat(\"-\", account)\n\t\tconst safeStoragePath = this.getSafeStoragePath()\n\t\treturn this.path.join(safeStoragePath, fname)\n\t}\n\n\t/**\n\t * this should always be a path inside the user's home directory (or equivalent)\n\t * @private\n\t */\n\tprivate getSafeStoragePath(): string {\n\t\treturn this.path.join(this.electron.app.getPath(\"userData\"), \"safe_storage\")\n\t}\n\n\t/**\n\t * ensures that the safe_storage directory exists and that we can use the\n\t * safeStorage API\n\t * @private\n\t */\n\tprivate async assertAvailable(): Promise<void> {\n\t\tawait this.electron.app.whenReady()\n\t\tawait this.fs.promises.mkdir(this.getSafeStoragePath(), { recursive: true })\n\n\t\tconst onLinux = process.platform === \"linux\"\n\t\tconst backend = onLinux ? this.electron.safeStorage.getSelectedStorageBackend() : null\n\n\t\tif (!this.initialized && backend === \"basic_text\") {\n\t\t\t// this will force isEncryptionAvailable to return true\n\t\t\tthis.electron.safeStorage.setUsePlainTextEncryption(true)\n\n\t\t\t// note that `basic_text` uses a hardcoded key which is insecure\n\t\t\tconsole.warn(\n\t\t\t\t`Detected safeStorage backend is insecure: ${backend}. Consider choosing a different one via command line args, or set up an app password to protect local data`,\n\t\t\t)\n\t\t}\n\n\t\tif (this.electron.safeStorage.isEncryptionAvailable()) {\n\t\t\tif (!this.initialized && onLinux) {\n\t\t\t\t// only linux has variable backends\n\t\t\t\tthis.initialized = true\n\t\t\t\tconsole.log(\"using safeStorage with backend\", backend)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tthrow new DeviceStorageUnavailableError(\"safeStorage API is not available\", null)\n\t}\n}\n","import o from \"@tutao/otest\"\nimport { SafeStorageSecretStorage } from \"../../../../src/common/desktop/sse/SecretStorage.js\"\nimport type { ElectronExports, FsExports } from \"../../../../src/common/desktop/ElectronExportTypes.js\"\nimport path from \"node:path\"\nimport { matchers, object, when } from \"testdouble\"\nimport { assertThrows } from \"@tutao/tutanota-test-utils\"\nimport { DeviceStorageUnavailableError } from \"../../../../src/common/api/common/error/DeviceStorageUnavailableError.js\"\n\no.spec(\"SecretStorage\", function () {\n\to.spec(\"SafeStorageSecretStorage\", function () {\n\t\tlet electron: ElectronExports\n\t\tlet fs: FsExports\n\t\tlet subject: SafeStorageSecretStorage\n\t\to.beforeEach(() => {\n\t\t\telectron = object()\n\t\t\tfs = object()\n\t\t\tsubject = new SafeStorageSecretStorage(electron, fs, path)\n\t\t})\n\n\t\to(\"will throw an error if there is no safeStorage available\", async function () {\n\t\t\twhen(electron.safeStorage.isEncryptionAvailable()).thenReturn(false)\n\t\t\twhen(electron.app.getPath(matchers.anything())).thenReturn(\"/any/path\")\n\t\t\tawait assertThrows(DeviceStorageUnavailableError, () => subject.getPassword(\"service\", \"account\"))\n\t\t\tawait assertThrows(DeviceStorageUnavailableError, () => subject.setPassword(\"service\", \"account\", \"password\"))\n\t\t})\n\t})\n})\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAgCa,2BAAN,MAAwD;CAC9D,AAAQ,cAAc;CAEtB,YACkBA,UACAC,IACAC,QAChB;EAuEF,KA1EkB;EA0EjB,KAzEiB;EAyEhB,KAxEgB;CACd;CAEJ,MAAM,YAAYC,SAAiBC,SAAyC;AAC3E,QAAM,KAAK,iBAAiB;EAC5B,MAAM,UAAU,KAAK,WAAW,SAAS,QAAQ;AACjD,MAAI;GACH,MAAM,cAAc,MAAM,KAAK,GAAG,SAAS,SAAS,QAAQ;AAC5D,UAAO,KAAK,SAAS,YAAY,cAAc,YAAY;EAC3D,SAAQ,GAAG;AACX,OAAI,EAAE,SAAS,SAEd,QAAO;AAER,SAAM;EACN;CACD;CAED,MAAM,YAAYD,SAAiBC,SAAiBC,UAAiC;AACpF,QAAM,KAAK,iBAAiB;EAC5B,MAAM,UAAU,KAAK,WAAW,SAAS,QAAQ;EACjD,MAAM,eAAe,KAAK,SAAS,YAAY,cAAc,SAAS;AACtE,SAAO,KAAK,GAAG,SAAS,UAAU,SAAS,aAAa;CACxD;CAED,AAAQ,WAAWF,SAAiBC,SAAyB;EAC5D,MAAM,QAAQ,QAAQ,OAAO,KAAK,QAAQ;EAC1C,MAAM,kBAAkB,KAAK,oBAAoB;AACjD,SAAO,KAAK,KAAK,KAAK,iBAAiB,MAAM;CAC7C;;;;;CAMD,AAAQ,qBAA6B;AACpC,SAAO,KAAK,KAAK,KAAK,KAAK,SAAS,IAAI,QAAQ,WAAW,EAAE,eAAe;CAC5E;;;;;;CAOD,MAAc,kBAAiC;AAC9C,QAAM,KAAK,SAAS,IAAI,WAAW;AACnC,QAAM,KAAK,GAAG,SAAS,MAAM,KAAK,oBAAoB,EAAE,EAAE,WAAW,KAAM,EAAC;EAE5E,MAAM,UAAU,QAAQ,aAAa;EACrC,MAAM,UAAU,UAAU,KAAK,SAAS,YAAY,2BAA2B,GAAG;AAElF,OAAK,KAAK,eAAe,YAAY,cAAc;AAElD,QAAK,SAAS,YAAY,0BAA0B,KAAK;AAGzD,WAAQ,MACN,4CAA4C,QAAQ,4GACrD;EACD;AAED,MAAI,KAAK,SAAS,YAAY,uBAAuB,EAAE;AACtD,QAAK,KAAK,eAAe,SAAS;AAEjC,SAAK,cAAc;AACnB,YAAQ,IAAI,kCAAkC,QAAQ;GACtD;AACD;EACA;AACD,QAAM,IAAI,8BAA8B,oCAAoC;CAC5E;AACD;;;;;ACrGD,aAAE,KAAK,iBAAiB,WAAY;AACnC,cAAE,KAAK,4BAA4B,WAAY;EAC9C,IAAIE;EACJ,IAAIC;EACJ,IAAIC;AACJ,eAAE,WAAW,MAAM;AAClB,cAAW,+BAAQ;AACnB,QAAK,+BAAQ;AACb,aAAU,IAAI,yBAAyB,UAAU,IAAI;EACrD,EAAC;AAEF,eAAE,4DAA4D,iBAAkB;AAC/E,+BAAK,SAAS,YAAY,uBAAuB,CAAC,CAAC,WAAW,MAAM;AACpE,+BAAK,SAAS,IAAI,QAAQ,2BAAS,UAAU,CAAC,CAAC,CAAC,WAAW,YAAY;AACvE,SAAM,aAAa,+BAA+B,MAAM,QAAQ,YAAY,WAAW,UAAU,CAAC;AAClG,SAAM,aAAa,+BAA+B,MAAM,QAAQ,YAAY,WAAW,WAAW,WAAW,CAAC;EAC9G,EAAC;CACF,EAAC;AACF,EAAC"}