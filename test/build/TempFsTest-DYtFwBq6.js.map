{"version":3,"file":"TempFsTest-DYtFwBq6.js","names":["fs: FsExports","electron: ElectronExports","cryptoFunctions: CryptoFunctions","contents: string | Uint8Array","subfolder: TmpSub","option?: { encoding: BufferEncoding; mode: number }","subFolder: string","fs: any","app: any","electron: any","cryptoFns: any"],"sources":["../../src/common/desktop/files/TempFs.ts","../tests/desktop/files/TempFsTest.ts"],"sourcesContent":["import path from \"node:path\"\nimport { ElectronExports, FsExports } from \"../ElectronExportTypes.js\"\nimport { CryptoFunctions } from \"../CryptoFns.js\"\nimport { base64ToBase64Url, uint8ArrayToBase64, uint8ArrayToHex } from \"@tutao/tutanota-utils\"\n\ntype TmpSub = \"reg\" | \"encrypted\" | \"decrypted\"\n\n/**\n * wrapper to access the tmp scratch file system used for downloading, uploading, encrypting and decrypting files before\n * putting them into the user's desired location.\n *\n * this currently randomizes file names before uploading files. ideally, we would prevent\n * file name collisions generally by always randomizing any file names written into this temp\n * location - the calling site has the actual file names and uses them for uploading and\n * putting files into the user's download folder.\n * */\nexport class TempFs {\n\tprivate readonly topLevelTempDir = \"tutanota\"\n\t/** we store all temporary files in a directory with a random name, so that the download location is not predictable */\n\tprivate readonly randomDirectoryName: string\n\n\tconstructor(private readonly fs: FsExports, private readonly electron: ElectronExports, private readonly cryptoFunctions: CryptoFunctions) {\n\t\tthis.randomDirectoryName = base64ToBase64Url(uint8ArrayToBase64(cryptoFunctions.randomBytes(16)))\n\t}\n\n\tclear() {\n\t\tconst topLvlTmpDir = path.join(this.electron.app.getPath(\"temp\"), this.topLevelTempDir)\n\t\ttry {\n\t\t\tconst tmps = this.fs.readdirSync(topLvlTmpDir)\n\t\t\tfor (const tmp of tmps) {\n\t\t\t\tconst tmpSubPath = path.join(topLvlTmpDir, tmp)\n\t\t\t\ttry {\n\t\t\t\t\tthis.fs.rmSync(tmpSubPath, { recursive: true })\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// ignore if the file was deleted between readdir and delete\n\t\t\t\t\t// or if it's not our tmp dir\n\t\t\t\t\tif (e.code !== \"ENOENT\" && e.code !== \"EACCES\") throw e\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// the tmp dir doesn't exist, everything's fine\n\t\t\tif (e.code !== \"ENOENT\") throw e\n\t\t}\n\t}\n\n\t/**\n\t * Get a path to the tutanota temporary directory\n\t * the hierarchy is\n\t * [electron tmp dir]\n\t * [tutanota tmp]\n\t *\n\t * the directory will be created if it doesn't already exist\n\t *\n\t * a randomly named subdirectory will be included\n\t *\n\t * if `noRandomDirectory` then random directory will not be included in the path,\n\t * and the whole directory will not be created\n\t * @returns {string}\n\t */\n\tgetTutanotaTempPath(): string {\n\t\tconst directory = path.join(this.electron.app.getPath(\"temp\"), this.topLevelTempDir, this.randomDirectoryName)\n\n\t\t// only readable by owner (current user)\n\t\tthis.fs.mkdirSync(directory, { recursive: true, mode: 0o700 })\n\n\t\treturn path.join(directory)\n\t}\n\n\tasync acquireSingleInstanceLock(): Promise<boolean> {\n\t\tconst lockfilePath = this.getLockFilePath()\n\t\t// first, put down a file in temp that contains our version.\n\t\t// will overwrite if it already exists.\n\t\t// errors are ignored and we fall back to a version agnostic single instance lock.\n\t\ttry {\n\t\t\tawait this.fs.promises.writeFile(lockfilePath, this.electron.app.getVersion(), \"utf8\")\n\t\t} catch (e) {\n\t\t\t// ignored!\n\t\t}\n\t\t// try to get the lock, if there's already an instance running,\n\t\t// it will get a message about this.\n\t\treturn this.electron.app.requestSingleInstanceLock()\n\t}\n\n\tprivate getLockFilePath() {\n\t\t// don't get temp dir path from DesktopDownloadManager because the path returned from there may be deleted at some point,\n\t\t// we want to put the lockfile in root tmp so it persists\n\t\treturn path.join(this.electron.app.getPath(\"temp\"), \"tutanota_desktop_lockfile\")\n\t}\n\n\t/**\n\t * reads the lockfile and then writes the own version into the lockfile\n\t * @returns {Promise<boolean>} whether the lock was overridden by another version since the last read\n\t */\n\tasync singleInstanceLockOverridden(): Promise<boolean> {\n\t\tconst lockfilePath = this.getLockFilePath()\n\t\tconst version = await this.fs.promises.readFile(lockfilePath, \"utf8\")\n\t\ttry {\n\t\t\tawait this.fs.promises.writeFile(lockfilePath, this.electron.app.getVersion(), \"utf8\")\n\t\t\treturn version !== this.electron.app.getVersion()\n\t\t} catch (e) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t/**\n\t * Writes contents with a random file name into the tmp directory\n\t * @param contents the contents of the file to write\n\t * @param subfolder the subfolder of the tmp files to write to\n\t * @param option the options for write file as encoding and file permissions\n\t * @returns path to the written file\n\t */\n\tasync writeToDisk(contents: string | Uint8Array, subfolder: TmpSub, option?: { encoding: BufferEncoding; mode: number }): Promise<string> {\n\t\tconst tmpPath = path.join(this.getTutanotaTempPath(), subfolder)\n\t\tawait this.fs.promises.mkdir(tmpPath, { recursive: true })\n\n\t\tconst filename = uint8ArrayToHex(this.cryptoFunctions.randomBytes(12))\n\t\tconst filePath = path.join(tmpPath, filename)\n\n\t\tawait this.fs.promises.writeFile(filePath, contents, option)\n\n\t\treturn filePath\n\t}\n\n\t/** removes the given subfolder of our tmp directory with all its contents */\n\tasync clearTmpSub(subFolder: string): Promise<void> {\n\t\tconst tmpPath = path.join(this.getTutanotaTempPath(), subFolder)\n\t\tthis.fs.rmSync(tmpPath, { force: true, recursive: true, maxRetries: 3 })\n\t}\n\n\tasync ensureEncryptedDir(): Promise<string> {\n\t\tconst downloadDirectory = this.getEncryptedTempDir()\n\t\tawait this.fs.promises.mkdir(downloadDirectory, { recursive: true })\n\t\treturn downloadDirectory\n\t}\n\n\tasync ensureUnencrytpedDir(): Promise<string> {\n\t\tconst downloadDirectory = this.getUnencryptedTempDir()\n\t\tawait this.fs.promises.mkdir(downloadDirectory, { recursive: true })\n\t\treturn downloadDirectory\n\t}\n\n\tprivate getEncryptedTempDir() {\n\t\treturn path.join(this.getTutanotaTempPath(), \"encrypted\")\n\t}\n\n\tprivate getUnencryptedTempDir() {\n\t\treturn path.join(this.getTutanotaTempPath(), \"decrypted\")\n\t}\n}\n","import o from \"@tutao/otest\"\nimport { matchers, object, verify, when } from \"testdouble\"\nimport { base64ToUint8Array, base64UrlToBase64 } from \"@tutao/tutanota-utils\"\nimport { TempFs } from \"../../../../src/common/desktop/files/TempFs.js\"\n\no.spec(\"TempFsTest\", function () {\n\to(\"delete tutanotaTempDir can handle multiple subfolders, some of which aren't ours\", function () {\n\t\tconst fs: any = object()\n\t\tconst app: any = object()\n\t\tconst electron: any = { app }\n\t\tconst cryptoFns: any = object()\n\t\twhen(cryptoFns.randomBytes(matchers.anything())).thenReturn(base64ToUint8Array(base64UrlToBase64(\"9E9u8bnXUGWYCk05eF0Xjw\")))\n\t\twhen(app.getPath(\"temp\")).thenReturn(\"/tmp\")\n\t\twhen(fs.readdirSync(\"/tmp/tutanota\")).thenReturn([\"mine\", \"thine\", \"anothermine\", \"removed\", \"lastmine\"])\n\t\twhen(fs.rmSync(\"/tmp/tutanota/thine\", { recursive: true })).thenThrow({ code: \"EACCES\" } as any)\n\t\twhen(fs.rmSync(\"/tmp/tutanota/mine\", { recursive: true })).thenReturn(null)\n\t\twhen(fs.rmSync(\"/tmp/tutanota/anothermine\", { recursive: true })).thenReturn(null)\n\t\twhen(fs.rmSync(\"/tmp/tutanota/removed\", { recursive: true })).thenThrow({ code: \"ENOENT\" } as any)\n\t\twhen(fs.rmSync(\"/tmp/tutanota/lastmine\", { recursive: true })).thenReturn(null)\n\t\tconst tfs = new TempFs(fs, electron, cryptoFns)\n\t\ttfs.clear()\n\t\tverify(fs.rmSync(matchers.anything(), { recursive: true }), { times: 5 })\n\t})\n})\n"],"mappings":"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"}