{"version":3,"file":"PageContextLoginListener-dgY8O-YX.js","names":["secondFactorHandler: SecondFactorHandler","credentialsProvider: CredentialsProvider","_sessionType: SessionType","_cacheInfo: CacheInfo","credentials: Credentials","persistedCredentials: PersistedCredentials","reason: LoginFailReason","sessionId: IdTuple","challenges: ReadonlyArray<Challenge>","mailAddress: string | null"],"sources":["../../src/common/api/main/PageContextLoginListener.ts"],"sourcesContent":["import { SecondFactorHandler } from \"../../misc/2fa/SecondFactorHandler.js\"\nimport { arrayEquals, assertNotNull, defer, DeferredObject } from \"@tutao/tutanota-utils\"\nimport { Challenge } from \"../entities/sys/TypeRefs.js\"\nimport { CacheInfo, LoginListener } from \"../worker/facades/LoginFacade.js\"\nimport { SessionType } from \"../common/SessionType.js\"\nimport { CredentialsProvider } from \"../../misc/credentials/CredentialsProvider.js\"\nimport { Credentials } from \"../../misc/credentials/Credentials.js\"\nimport { PersistedCredentials } from \"../../native/common/generatedipc/PersistedCredentials.js\"\n\nexport const enum LoginFailReason {\n\tSessionExpired,\n\tError,\n}\n\n/** Listener for the login events from the worker side. */\nexport class PageContextLoginListener implements LoginListener {\n\tprivate loginPromise: DeferredObject<void> = defer()\n\tprivate fullLoginFailed: boolean = false\n\n\tconstructor(private readonly secondFactorHandler: SecondFactorHandler, private readonly credentialsProvider: CredentialsProvider) {}\n\n\t/** e.g. after temp logout */\n\treset() {\n\t\tthis.loginPromise = defer()\n\t\tthis.fullLoginFailed = false\n\t}\n\n\twaitForFullLogin(): Promise<void> {\n\t\treturn this.loginPromise.promise\n\t}\n\n\t/**\n\t * Full login reached: any network requests can be made\n\t */\n\tasync onFullLoginSuccess(_sessionType: SessionType, _cacheInfo: CacheInfo, credentials: Credentials): Promise<void> {\n\t\tthis.fullLoginFailed = false\n\n\t\t// Update the credentials after the full login.\n\t\t// It is needed because we added encryptedPassphraseKey to credentials which is only\n\t\t// available after the full login which happens async.\n\n\t\t// First fetch encrypted credentials for the user to figure out if the credentials are stored but are also missing\n\t\t// a passphrase key, and then update if so.\n\n\t\tconst persistedCredentials = (await this.credentialsProvider.getAllInternalCredentials()).find((a) => a.credentialInfo.userId === credentials.userId)\n\t\tif (persistedCredentials != null && this.isPassphraseKeyUpdatedNeeded(persistedCredentials, credentials)) {\n\t\t\tawait this.credentialsProvider.replacePassword(\n\t\t\t\tpersistedCredentials.credentialInfo,\n\t\t\t\tassertNotNull(credentials.encryptedPassword),\n\t\t\t\tassertNotNull(credentials.encryptedPassphraseKey),\n\t\t\t)\n\t\t}\n\n\t\tthis.loginPromise.resolve()\n\t}\n\n\t/**\n\t * It is possible that a KDF migration was executed by a different client. This would change the passphrase key, so we need to check if we have to update the stored one.\n\t * @private\n\t */\n\tprivate isPassphraseKeyUpdatedNeeded(persistedCredentials: PersistedCredentials, credentials: Credentials) {\n\t\tconst persistedEncryptedPassphraseKey = persistedCredentials.encryptedPassphraseKey\n\t\tconst credentialsEncryptedPassphraseKey = credentials.encryptedPassphraseKey\n\t\tif (persistedCredentials.encryptedPassword != credentials.encryptedPassword) {\n\t\t\t// we only want to update the encrypted passwordKey if we changed the kdf function.\n\t\t\t// In this case we have the same endryptedPassword but a different password key.\n\t\t\treturn false\n\t\t}\n\t\tif (persistedEncryptedPassphraseKey != null && credentialsEncryptedPassphraseKey != null) {\n\t\t\treturn !arrayEquals(persistedEncryptedPassphraseKey, credentialsEncryptedPassphraseKey)\n\t\t} else if (persistedEncryptedPassphraseKey == null && credentialsEncryptedPassphraseKey == null) {\n\t\t\t// both are null so nothing has changed.\n\t\t\treturn false\n\t\t} else {\n\t\t\t// one is null and the other is not\n\t\t\treturn true\n\t\t}\n\t}\n\n\t/**\n\t * call when the login fails for invalid session or other reasons\n\t */\n\tasync onLoginFailure(reason: LoginFailReason): Promise<void> {\n\t\tthis.fullLoginFailed = true\n\t\tif (reason === LoginFailReason.SessionExpired) {\n\t\t\tconst { reloginForExpiredSession } = await import(\"../../misc/ErrorHandlerImpl.js\")\n\t\t\tawait reloginForExpiredSession()\n\t\t}\n\t}\n\n\t/**\n\t * call when retrying full login\n\t */\n\tonRetryLogin(): void {\n\t\tthis.fullLoginFailed = false\n\t}\n\n\t/**\n\t * Shows a dialog with possibility to use second factor and with a message that the login can be approved from another client.\n\t */\n\tonSecondFactorChallenge(sessionId: IdTuple, challenges: ReadonlyArray<Challenge>, mailAddress: string | null): Promise<void> {\n\t\treturn this.secondFactorHandler.showSecondFactorAuthenticationDialog(sessionId, challenges, mailAddress)\n\t}\n\n\t/**\n\t * true if the last full login attempt failed\n\t * may revert to false when retrying.\n\t */\n\tgetFullLoginFailed(): boolean {\n\t\treturn this.fullLoginFailed\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IASkB,8CAAX;AACN;AACA;;AACA;IAGY,2BAAN,MAAwD;CAC9D,AAAQ,eAAqC,OAAO;CACpD,AAAQ,kBAA2B;CAEnC,YAA6BA,qBAA2DC,qBAA0C;EA6FlI,KA7F6B;EA6F5B,KA7FuF;CAA4C;;CAGpI,QAAQ;AACP,OAAK,eAAe,OAAO;AAC3B,OAAK,kBAAkB;CACvB;CAED,mBAAkC;AACjC,SAAO,KAAK,aAAa;CACzB;;;;CAKD,MAAM,mBAAmBC,cAA2BC,YAAuBC,aAAyC;AACnH,OAAK,kBAAkB;EASvB,MAAM,uBAAuB,CAAC,MAAM,KAAK,oBAAoB,2BAA2B,EAAE,KAAK,CAAC,MAAM,EAAE,eAAe,WAAW,YAAY,OAAO;AACrJ,MAAI,wBAAwB,QAAQ,KAAK,6BAA6B,sBAAsB,YAAY,CACvG,OAAM,KAAK,oBAAoB,gBAC9B,qBAAqB,gBACrB,cAAc,YAAY,kBAAkB,EAC5C,cAAc,YAAY,uBAAuB,CACjD;AAGF,OAAK,aAAa,SAAS;CAC3B;;;;;CAMD,AAAQ,6BAA6BC,sBAA4CD,aAA0B;EAC1G,MAAM,kCAAkC,qBAAqB;EAC7D,MAAM,oCAAoC,YAAY;AACtD,MAAI,qBAAqB,qBAAqB,YAAY,kBAGzD,QAAO;AAER,MAAI,mCAAmC,QAAQ,qCAAqC,KACnF,SAAQ,YAAY,iCAAiC,kCAAkC;SAC7E,mCAAmC,QAAQ,qCAAqC,KAE1F,QAAO;IAGP,QAAO;CAER;;;;CAKD,MAAM,eAAeE,QAAwC;AAC5D,OAAK,kBAAkB;AACvB,MAAI,WAAW,gBAAgB,gBAAgB;GAC9C,MAAM,EAAE,0BAA0B,GAAG,MAAM,OAAO;AAClD,SAAM,0BAA0B;EAChC;CACD;;;;CAKD,eAAqB;AACpB,OAAK,kBAAkB;CACvB;;;;CAKD,wBAAwBC,WAAoBC,YAAsCC,aAA2C;AAC5H,SAAO,KAAK,oBAAoB,qCAAqC,WAAW,YAAY,YAAY;CACxG;;;;;CAMD,qBAA8B;AAC7B,SAAO,KAAK;CACZ;AACD"}