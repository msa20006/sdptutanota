
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import "./mithril-Csg4iNnm.js";
import { assertNotNull, count, debounce, first, groupBy, isNotEmpty, lastThrow, lazyMemoized, mapWith, mapWithout, memoized, ofClass, pMap } from "./dist-CJHwsXKY.js";
import "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import "./LanguageViewModel-BNC5ekpO.js";
import "./HtmlUtils-C-ecR7U7.js";
import "./ClientDetector-D0v6Vqu6.js";
import { ImportStatus, MailSetKind, OperationType, getMailSetKind } from "./TutanotaConstants-3bwAESYA.js";
import "./Icon-BuqNK7vz.js";
import "./Icons-Dl3nFav5.js";
import "./KeyManager-B0OGXEyJ.js";
import "./WindowFacade-B9kSBKw7.js";
import "./Modal-g4c-b9IU.js";
import "./Dialog-B6-HFvZd.js";
import "./CountryList-DkVQtcTj.js";
import "./IconButton-DsU60HJ_.js";
import { NotAuthorizedError, NotFoundError, PreconditionFailedError } from "./RestError-D17JEBMr.js";
import "./SuspensionError-okvIjE4H.js";
import "./LoginIncompleteError-CpiW0a0l.js";
import "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import { isOfflineError } from "./ErrorUtils-o1-v67Dd.js";
import "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import "./ParserCombinator-D38ofgFx.js";
import "./ExportError-DzgStBnl.js";
import "./stream-u2PttBAC.js";
import "./luxon-D6cgmg6Q.js";
import { deconstructMailSetEntryId, elementIdPart, firstBiggerThanSecond, getElementId, isSameId, listIdPart } from "./EntityUtils-RQxXZlcV.js";
import "./CommonCalendarUtils-DKaO7v1K.js";
import "./Formatter-zB15D6XI.js";
import "./TypeModels-XIXYys8J.js";
import { ImportMailStateTypeRef, ImportedMailTypeRef, MailSetEntryTypeRef, MailTypeRef } from "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import "./TypeRefs-BP1jvX9p.js";
import "./CalendarUtils-C6jeYrj9.js";
import "./ProgressMonitor-HBfOF56H.js";
import "./Notifications-DLibQbV7.js";
import "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import "./ModelInfo-DEa-Yxv2.js";
import "./EntityClient-B0RSdk2i.js";
import "./SetupMultipleError-B6uY8P-x.js";
import "./Services-DCx-CeM7.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-B5iTKMk4.js";
import "./CommonLocator-Csg4iNnm.js";
import "./ImportExportUtils-B1MoOmZ0.js";
import "./FormatValidator-2BBermUe.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import "./MailAddressParser-BgYy6oyp.js";
import "./GroupUtils-0ZkLIAeC.js";
import "./DataFile-CY7uuk9j.js";
import "./FileUtils-W-u2-gZz.js";
import "./ProgressDialog-CJfJjh62.js";
import "./BlobUtils-D5ADcckZ.js";
import "./SharedMailUtils-AmFaSJP6.js";
import "./PasswordUtils-C4jlV9GF.js";
import "./Recipient-BFxhfecW.js";
import "./BirthdayUtils-BcCMglSq.js";
import "./ContactUtils-Bbon2oOk.js";
import "./SubscriptionDialogs-DAlWs68I.js";
import "./ExternalLink-rsCBSC7U.js";
import "./ToggleButton-DxuDa0rS.js";
import "./ErrorHandler-DbW1lJbv.js";
import "./SnackBar-CoP3lSVs.js";
import "./Credentials-BM35X_na.js";
import "./NotificationOverlay-C-YNCUiT.js";
import "./Checkbox-WCw-l_7A.js";
import "./Expander-Bautb1_0.js";
import "./ClipboardUtils-mz40UK5S.js";
import "./ErrorReporter-7sfLhWZg.js";
import "./Services-CupYet_j.js";
import "./BubbleButton-DGGInJMg.js";
import "./SessionType-rxSDsswH.js";
import "./PasswordField-CPKPoLq8.js";
import "./PasswordRequestDialog-B7ZIVTVw.js";
import "./ErrorHandlerImpl-DRpk8tE9.js";
import "./DeviceConfig-payZM407.js";
import "./List-CdKNFQkI.js";
import "./CustomerUtils-DmaZpb7Y.js";
import "./EventQueue-c-5UmjJa.js";
import { CacheMode, WsConnectionState } from "./EntityRestClient--6dT7ZRF.js";
import "./MessageDispatcher-wJwFhXWv.js";
import "./SqlValue-CkGu32Qd.js";
import "./Sql-C9YhYNym.js";
import "./RestClient-CmoHrId4.js";
import "./LoginViewModel-BX-8ry63.js";
import "./LoginButton-DzCRy0Yt.js";
import "./UsageTestModel-CjGx3RZo.js";
import "./inlineImagesUtils-BekMwI7k.js";
import "./CommonMailUtils-DNufl6ib.js";
import "./PermissionType-Bwii3hCe.js";
import "./AttachmentBubble-CloIefNF.js";
import "./RouteChange-im6yOAT2.js";
import "./SearchUtils-Cu31OiTT.js";
import "./mailLocator-CrvEYt1k.js";
import "./PageContextLoginListener-dgY8O-YX.js";
import "./Scheduler-B2H65_EO.js";
import { assertSystemFolderOfType } from "./MailUtils-ChhZAFAd.js";
import "./FolderSystem-DLrUB8MO.js";
import { isOfTypeOrSubfolderOf, isSpamOrTrashFolder, isSubfolderOfType } from "./MailChecks-PhVUoR7f.js";
import { MailFilterType, getMailFilterForType } from "./MailViewerViewModel-D_nVDgz3.js";
import "./emlUtils-afBEUvhM.js";
import "./LoadingState-DqrMrOAm.js";
import "./ListModel-jYF3dysm.js";
import { MailListModel } from "./MailListModel-BwcGCBzp.js";

//#region ../src/mail-app/mail/view/MailViewModel.ts
const TAG = "MailVM";
var MailViewModel = class {
	_folder = null;
	/** id of the mail that was requested to be displayed, independent of the list state. */
	stickyMailId = null;
	/**
	* When the URL contains both folder id and mail id we will try to select that mail but we might need to load the list until we find it.
	* This is that mail id that we are loading.
	*/
	loadingTargetId = null;
	conversationViewModel = null;
	_filterType = null;
	/**
	* We remember the last URL used for each folder so if we switch between folders we can keep the selected mail.
	* There's a similar (but different) hacky mechanism where we store last URL but per each top-level view: navButtonRoutes. This one is per folder.
	*/
	mailFolderElementIdToSelectedMailId = new Map();
	listStreamSubscription = null;
	conversationPref = false;
	/** A slightly hacky marker to avoid concurrent URL updates. */
	currentShowTargetMarker = {};
	constructor(mailboxModel, mailModel, entityClient, eventController, connectivityModel, cacheStorage, conversationViewModelFactory, mailOpenedListener, conversationPrefProvider, inboxRuleHandler, router, updateUi) {
		this.mailboxModel = mailboxModel;
		this.mailModel = mailModel;
		this.entityClient = entityClient;
		this.eventController = eventController;
		this.connectivityModel = connectivityModel;
		this.cacheStorage = cacheStorage;
		this.conversationViewModelFactory = conversationViewModelFactory;
		this.mailOpenedListener = mailOpenedListener;
		this.conversationPrefProvider = conversationPrefProvider;
		this.inboxRuleHandler = inboxRuleHandler;
		this.router = router;
		this.updateUi = updateUi;
	}
	getSelectedMailSetKind() {
		return this._folder ? getMailSetKind(this._folder) : null;
	}
	get filterType() {
		return this._filterType;
	}
	setFilter(filter) {
		this._filterType = filter;
		this.listModel?.setFilter(getMailFilterForType(filter));
	}
	async showMailWithMailSetId(mailsetId, mailId) {
		const showMailMarker = {};
		this.currentShowTargetMarker = showMailMarker;
		if (mailsetId) {
			const mailset = await this.mailModel.getMailSetById(mailsetId);
			if (showMailMarker !== this.currentShowTargetMarker) return;
			if (mailset) return this.showMail(mailset, mailId);
		}
		return this.showMail(null, mailId);
	}
	async showStickyMail(fullMailId, onMissingExplicitMailTarget) {
		const [listId, elementId] = fullMailId;
		if (this.conversationViewModel && isSameId(this.conversationViewModel.primaryMail._id, elementId)) return;
		if (isSameId(this.stickyMailId, fullMailId)) return;
		console.log(TAG, "Loading sticky mail", listId, elementId);
		this.stickyMailId = fullMailId;
		await this.loadExplicitMailTarget(listId, elementId, onMissingExplicitMailTarget);
	}
	async resetOrInitializeList(stickyMailId) {
		if (this._folder != null) this.listModel?.selectNone();
else {
			const userInbox = await this.getFolderForUserInbox();
			if (this.didStickyMailChange(stickyMailId, "after loading user inbox ID")) return;
			this.setListId(userInbox);
		}
	}
	async showMail(folder, mailId) {
		if (folder != null && mailId != null && this.conversationViewModel && isSameId(elementIdPart(this.conversationViewModel.primaryMail._id), mailId)) return;
		if (folder != null && mailId != null && this._folder && this.loadingTargetId && isSameId(folder._id, this._folder._id) && isSameId(this.loadingTargetId, mailId)) return;
		console.log(TAG, "showMail", folder?._id, mailId);
		const loadingTargetId = mailId ?? null;
		this.loadingTargetId = loadingTargetId;
		this.stickyMailId = null;
		const folderToUse = await this.selectFolderToUse(folder ?? null);
		if (this.loadingTargetId !== loadingTargetId) return;
		this.setListId(folderToUse);
		if (loadingTargetId) {
			this.mailFolderElementIdToSelectedMailId = mapWith(this.mailFolderElementIdToSelectedMailId, getElementId(folderToUse), loadingTargetId);
			try {
				await this.loadAndSelectMail(folderToUse, loadingTargetId);
			} finally {
				this.loadingTargetId = null;
			}
		} else if (folder == null) this.updateUrl();
	}
	async selectFolderToUse(folderArgument) {
		if (folderArgument) {
			const mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(folderArgument);
			if (mailboxDetail) return folderArgument;
else return await this.getFolderForUserInbox();
		} else return this._folder ?? await this.getFolderForUserInbox();
	}
	async loadExplicitMailTarget(listId, mailId, onMissingTargetEmail) {
		const expectedStickyMailId = [listId, mailId];
		const mailInList = this.listModel?.getMail(mailId);
		if (mailInList) {
			console.log(TAG, "opening mail from list", mailId);
			this.listModel?.onSingleSelection(mailInList);
			return;
		}
		const cached = await this.cacheStorage.get(MailTypeRef, listId, mailId);
		if (this.didStickyMailChange(expectedStickyMailId, "after loading cached")) return;
		if (cached) {
			console.log(TAG, "displaying cached mail", mailId);
			await this.displayExplicitMailTarget(cached);
		}
		let mail;
		try {
			mail = await this.entityClient.load(MailTypeRef, [listId, mailId], { cacheMode: CacheMode.WriteOnly });
		} catch (e) {
			if (isOfflineError(e)) return;
else if (e instanceof NotFoundError || e instanceof NotAuthorizedError) mail = null;
else throw e;
		}
		if (this.didStickyMailChange(expectedStickyMailId, "after loading from entity client")) return;
		let movedSetsSinceLastSync = false;
		if (mail != null && cached != null && cached.sets.length > 0) {
			const currentFolderId = elementIdPart(assertNotNull(this._folder, "cached was displayed earlier, thus folder would have been set")._id);
			const cachedMailInFolder = cached.sets.some((id) => elementIdPart(id) === currentFolderId);
			movedSetsSinceLastSync = cachedMailInFolder && !mail.sets.some((id) => elementIdPart(id) === currentFolderId);
		}
		if (!movedSetsSinceLastSync && mail != null) {
			console.log(TAG, "opening mail from entity client", mailId);
			await this.displayExplicitMailTarget(mail);
		} else {
			if (mail != null) console.log(TAG, "Explicit mail target moved sets", listId, mailId);
else console.log(TAG, "Explicit mail target not found", listId, mailId);
			onMissingTargetEmail();
			this.stickyMailId = null;
			this.updateUrl();
		}
	}
	async displayExplicitMailTarget(mail) {
		await this.resetOrInitializeList(mail._id);
		this.createConversationViewModel({
			mail,
			showFolder: false
		});
		this.updateUi();
	}
	didStickyMailChange(expectedId, message) {
		const changed = !isSameId(this.stickyMailId, expectedId);
		if (changed) console.log(TAG, "target mail id changed", message, expectedId, this.stickyMailId);
		return changed;
	}
	async loadAndSelectMail(folder, mailId) {
		const foundMail = await this.listModel?.loadAndSelect(mailId, () => this.getFolder() !== folder || !this.listModel || this.loadingTargetId !== mailId || this.listModel.items.length > 0 && firstBiggerThanSecond(mailId, getElementId(lastThrow(this.listModel.items))));
		if (foundMail == null) console.log("did not find mail", folder, mailId);
	}
	async getFolderForUserInbox() {
		const mailboxDetail = await this.mailboxModel.getUserMailboxDetails();
		const folders = await this.mailModel.getMailboxFoldersForId(assertNotNull(mailboxDetail.mailbox.folders)._id);
		return assertSystemFolderOfType(folders, MailSetKind.INBOX);
	}
	init() {
		this.singInit();
		const conversationEnabled = this.conversationPrefProvider.getConversationViewShowOnlySelectedMail();
		if (this.conversationViewModel && this.conversationPref !== conversationEnabled) {
			const mail = this.conversationViewModel.primaryMail;
			this.createConversationViewModel({
				mail,
				showFolder: false,
				delayBodyRenderingUntil: Promise.resolve()
			});
			this.mailOpenedListener.onEmailOpened(mail);
		}
		this.conversationPref = conversationEnabled;
	}
	singInit = lazyMemoized(() => {
		this.eventController.addEntityListener((updates) => this.entityEventsReceived(updates));
	});
	get listModel() {
		return this._folder ? this.listModelForFolder(getElementId(this._folder)) : null;
	}
	getMailFolderToSelectedMail() {
		return this.mailFolderElementIdToSelectedMailId;
	}
	getFolder() {
		return this._folder;
	}
	getLabelsForMail(mail) {
		return this.listModel?.getLabelsForMail(mail) ?? [];
	}
	setListId(folder) {
		if (folder === this._folder) return;
		this.listModel?.cancelLoadAll();
		this._filterType = null;
		this._folder = folder;
		this.listStreamSubscription?.end(true);
		this.listStreamSubscription = this.listModel.stateStream.map((state) => this.onListStateChange(state));
		this.listModel.loadInitial().then(() => {
			if (this.listModel != null && this._folder === folder) this.fixCounterIfNeeded(folder, this.listModel.items);
		});
	}
	getConversationViewModel() {
		return this.conversationViewModel;
	}
	listModelForFolder = memoized((_folderId) => {
		const folder = assertNotNull(this._folder);
		return new MailListModel(folder, this.conversationPrefProvider, this.entityClient, this.mailModel, this.inboxRuleHandler, this.cacheStorage);
	});
	fixCounterIfNeeded = debounce(2e3, async (folder, itemsWhenCalled) => {
		const ourFolder = this.getFolder();
		if (ourFolder == null || this._filterType != null && this.filterType !== MailFilterType.Unread) return;
		if (!isSameId(getElementId(ourFolder), getElementId(folder)) || this.connectivityModel.wsConnection()() !== WsConnectionState.connected) return;
		if (this.listModel?.items !== itemsWhenCalled) {
			console.log(`list changed, trying again later`);
			return this.fixCounterIfNeeded(folder, this.listModel?.items ?? []);
		}
		const unreadMailsCount = count(this.listModel.items, (e) => e.unread);
		const counterValue = await this.mailModel.getCounterValue(folder);
		if (counterValue != null && counterValue !== unreadMailsCount) {
			console.log(`fixing up counter for folder ${folder._id}`);
			await this.mailModel.fixupCounterForFolder(folder, unreadMailsCount);
		} else console.log(`same counter, no fixup on folder ${folder._id}`);
	});
	onListStateChange(newState) {
		const displayedMailId = this.conversationViewModel?.primaryViewModel()?.mail._id;
		if (!(displayedMailId && isSameId(displayedMailId, this.stickyMailId))) {
			const targetItem = this.stickyMailId ? newState.items.find((item) => isSameId(this.stickyMailId, item._id)) : !newState.inMultiselect && newState.selectedItems.size === 1 ? first(this.listModel.getSelectedAsArray()) : null;
			if (targetItem != null) {
				this.mailFolderElementIdToSelectedMailId = mapWith(this.mailFolderElementIdToSelectedMailId, getElementId(assertNotNull(this.getFolder())), getElementId(targetItem));
				if (!this.conversationViewModel || !isSameId(this.conversationViewModel?.primaryMail._id, targetItem._id)) {
					this.createConversationViewModel({
						mail: targetItem,
						showFolder: false
					});
					this.mailOpenedListener.onEmailOpened(targetItem);
				}
			} else {
				this.conversationViewModel?.dispose();
				this.conversationViewModel = null;
				this.mailFolderElementIdToSelectedMailId = mapWithout(this.mailFolderElementIdToSelectedMailId, getElementId(assertNotNull(this.getFolder())));
			}
		}
		this.updateUrl();
		this.updateUi();
	}
	updateUrl() {
		const folder = this._folder;
		const folderId = folder ? getElementId(folder) : null;
		const mailId = this.loadingTargetId ?? (folderId ? this.getMailFolderToSelectedMail().get(folderId) : null);
		const stickyMail = this.stickyMailId;
		if (mailId != null) this.router.routeTo("/mail/:folderId/:mailId", this.addStickyMailParam({
			folderId,
			mailId,
			mail: stickyMail
		}));
else this.router.routeTo("/mail/:folderId", this.addStickyMailParam({ folderId: folderId ?? "" }));
	}
	addStickyMailParam(params) {
		if (this.stickyMailId) params.mail = this.stickyMailId.join(",");
		return params;
	}
	createConversationViewModel(viewModelParams) {
		this.conversationViewModel?.dispose();
		this.conversationViewModel = this.conversationViewModelFactory(viewModelParams);
	}
	async entityEventsReceived(updates) {
		const folder = this._folder;
		const listModel = this.listModel;
		if (!folder || !listModel) return;
		let importMailStateUpdates = [];
		for (const update of updates) {
			if (isUpdateForTypeRef(MailSetEntryTypeRef, update) && isSameId(folder.entries, update.instanceListId)) {
				if (update.operation === OperationType.DELETE && this.stickyMailId != null) {
					const { mailId } = deconstructMailSetEntryId(update.instanceId);
					if (isSameId(mailId, elementIdPart(this.stickyMailId))) this.stickyMailId = null;
				}
			} else if (isUpdateForTypeRef(ImportMailStateTypeRef, update) && (update.operation == OperationType.CREATE || update.operation == OperationType.UPDATE)) importMailStateUpdates.push(update);
			await listModel.handleEntityUpdate(update);
			await pMap(importMailStateUpdates, (update$1) => this.processImportedMails(update$1));
		}
	}
	async processImportedMails(update) {
		const importMailState = await this.entityClient.load(ImportMailStateTypeRef, [update.instanceListId, update.instanceId]);
		const listModelOfImport = this.listModelForFolder(elementIdPart(importMailState.targetFolder));
		let status = parseInt(importMailState.status);
		if (status === ImportStatus.Finished || status === ImportStatus.Canceled) {
			let importedMailEntries = await this.entityClient.loadAll(ImportedMailTypeRef, importMailState.importedMails);
			if (importedMailEntries.length === 0) return Promise.resolve();
			let mailSetEntryIds = importedMailEntries.map((importedMail) => elementIdPart(importedMail.mailSetEntry));
			const mailSetEntryListId = listIdPart(importedMailEntries[0].mailSetEntry);
			const importedMailSetEntries = await this.entityClient.loadMultiple(MailSetEntryTypeRef, mailSetEntryListId, mailSetEntryIds);
			if (isNotEmpty(importedMailSetEntries)) {
				await this.preloadMails(importedMailSetEntries);
				await pMap(importedMailSetEntries, (importedMailSetEntry) => {
					return listModelOfImport.handleEntityUpdate({
						instanceListId: listIdPart(importedMailSetEntry._id),
						instanceId: elementIdPart(importedMailSetEntry._id),
						operation: OperationType.CREATE,
						type: MailSetEntryTypeRef.type,
						application: MailSetEntryTypeRef.app
					});
				});
			}
		}
	}
	async preloadMails(importedMailSetEntries) {
		const mailIds = importedMailSetEntries.map((mse) => mse.mail);
		const mailsByList = groupBy(mailIds, (m) => listIdPart(m));
		for (const [listId, mailIds$1] of mailsByList.entries()) {
			const mailElementIds = mailIds$1.map((m) => elementIdPart(m));
			await this.entityClient.loadMultiple(MailTypeRef, listId, mailElementIds);
		}
	}
	async switchToFolder(folderType) {
		const state = {};
		this.currentShowTargetMarker = state;
		const mailboxDetail = assertNotNull(await this.getMailboxDetails());
		if (this.currentShowTargetMarker !== state) return;
		if (mailboxDetail == null || mailboxDetail.mailbox.folders == null) return;
		const folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id);
		if (this.currentShowTargetMarker !== state) return;
		const folder = assertSystemFolderOfType(folders, folderType);
		await this.showMail(folder, this.mailFolderElementIdToSelectedMailId.get(getElementId(folder)));
	}
	async getMailboxDetails() {
		const folder = this.getFolder();
		return await this.mailboxDetailForListWithFallback(folder);
	}
	async showingDraftsFolder() {
		if (!this._folder) return false;
		const mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(this._folder);
		const selectedFolder = this.getFolder();
		if (selectedFolder && mailboxDetail && mailboxDetail.mailbox.folders) {
			const folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id);
			return isOfTypeOrSubfolderOf(folders, selectedFolder, MailSetKind.DRAFT);
		} else return false;
	}
	async showingTrashOrSpamFolder() {
		const folder = this.getFolder();
		if (folder) {
			const mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(folder);
			if (folder && mailboxDetail && mailboxDetail.mailbox.folders) {
				const folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id);
				return isSpamOrTrashFolder(folders, folder);
			}
		}
		return false;
	}
	async mailboxDetailForListWithFallback(folder) {
		const mailboxDetailForListId = folder ? await this.mailModel.getMailboxDetailsForMailFolder(folder) : null;
		return mailboxDetailForListId ?? await this.mailboxModel.getUserMailboxDetails();
	}
	async finallyDeleteAllMailsInSelectedFolder(folder) {
		this.listModel?.selectNone();
		const mailboxDetail = await this.getMailboxDetails();
		if (folder.folderType === MailSetKind.TRASH || folder.folderType === MailSetKind.SPAM) return this.mailModel.clearFolder(folder).catch(ofClass(PreconditionFailedError, () => {
			throw new UserError("operationStillActive_msg");
		}));
else {
			const folders = await this.mailModel.getMailboxFoldersForId(assertNotNull(mailboxDetail.mailbox.folders)._id);
			if (isSubfolderOfType(folders, folder, MailSetKind.TRASH) || isSubfolderOfType(folders, folder, MailSetKind.SPAM)) return this.mailModel.finallyDeleteCustomMailFolder(folder).catch(ofClass(PreconditionFailedError, () => {
				throw new UserError("operationStillActive_msg");
			}));
else throw new ProgrammingError(`Cannot delete mails in folder ${String(folder._id)} with type ${folder.folderType}`);
		}
	}
	onSingleSelection(mail) {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.onSingleSelection(mail);
	}
	areAllSelected() {
		return this.listModel?.areAllSelected() ?? false;
	}
	selectNone() {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.selectNone();
	}
	selectAll() {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.selectAll();
	}
	onSingleInclusiveSelection(mail, clearSelectionOnMultiSelectStart) {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.onSingleInclusiveSelection(mail, clearSelectionOnMultiSelectStart);
	}
	onRangeSelectionTowards(mail) {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.selectRangeTowards(mail);
	}
	selectPrevious(multiselect) {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.selectPrevious(multiselect);
	}
	selectNext(multiselect) {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.selectNext(multiselect);
	}
	onSingleExclusiveSelection(mail) {
		this.stickyMailId = null;
		this.loadingTargetId = null;
		this.listModel?.onSingleExclusiveSelection(mail);
	}
	async createLabel(mailbox, labelData) {
		await this.mailModel.createLabel(assertNotNull(mailbox._ownerGroup), labelData);
	}
	async editLabel(label, newData) {
		await this.mailModel.updateLabel(label, newData);
	}
	async deleteLabel(label) {
		await this.mailModel.deleteLabel(label);
	}
};

//#endregion
export { MailViewModel };
//# sourceMappingURL=MailViewModel-BI0SdEEY.js.map