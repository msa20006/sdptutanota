{"version":3,"file":"Sql-C9YhYNym.js","names":["queryParts: TemplateStringsArray","params: TaggedSqlValue[]","i: number","params: SqlValue[]","text: string"],"sources":["../../src/common/api/worker/offline/Sql.ts"],"sourcesContent":["import { FormattedQuery, SqlValue, TaggedSqlValue, tagSqlValue } from \"./SqlValue.js\"\n\n/**\n * this tagged template function exists because android doesn't allow us to define SQL functions, so we have made a way to inline\n * SQL fragments into queries.\n * to make it less error-prone, we automate the generation of the params array for the actual sql call.\n * In this way, we offload the escaping of actual user content to the SQL engine, which makes this safe from an SQLI point of view.\n *\n * usage example:\n * const type = \"sys/User\"\n * const listId = \"someList\"\n * const startId = \"ABC\"\n * sql`SELECT entity FROM list_entities WHERE type = ${type} AND listId = ${listId} AND ${firstIdBigger(startId, \"elementId\")}`\n *\n * this will result in\n * const {query, params} = {\n *     query: `SELECT entity FROM list_entities WHERE type = ? AND listId = ? AND (CASE WHEN length(?) > length(elementId) THEN 1 WHEN length(?) < length(elementId) THEN 0 ELSE ? > elementId END)`,\n *     params: [\n *     \t\t{type: SqlType.String, value: \"sys/User\"},\n *     \t\t{type: SqlType.String, value: \"someList\"},\n *     \t\t{type: SqlType.String, value: \"ABC\"},\n *     \t\t{type: SqlType.String, value: \"ABC\"},\n *     \t\t{type: SqlType.String, value: \"ABC\"}\n *     ]\n * }\n *\n * which can be consumed by sql.run(query, params).\n *\n * It is important that the caller ensures that the amount of SQL variables does not exceed MAX_SAFE_SQL_VARS!\n * Violating this rule will lead to an uncaught error with bad stack traces.\n */\nexport function sql(queryParts: TemplateStringsArray, ...paramInstances: (SqlValue | SqlFragment)[]): FormattedQuery {\n\tlet query = \"\"\n\tlet params: TaggedSqlValue[] = []\n\tlet i: number\n\tfor (i = 0; i < paramInstances.length; i++) {\n\t\tquery += queryParts[i]\n\t\tconst param = paramInstances[i]\n\t\tif (param instanceof SqlFragment) {\n\t\t\tquery += param.text\n\t\t\tparams.push(...param.params.map(tagSqlValue))\n\t\t} else {\n\t\t\tquery += \"?\"\n\t\t\tparams.push(tagSqlValue(param))\n\t\t}\n\t}\n\tquery += queryParts[i]\n\treturn { query, params }\n}\n\nexport type UntaggedQuery = { query: string; params: readonly SqlValue[] }\n\n/**\n * Like {@link sql} but without tagging the values\n */\nexport function usql(queryParts: TemplateStringsArray, ...paramInstances: (SqlValue | SqlFragment)[]): UntaggedQuery {\n\tlet query = \"\"\n\tlet params: SqlValue[] = []\n\tlet i: number\n\tfor (i = 0; i < paramInstances.length; i++) {\n\t\tquery += queryParts[i]\n\t\tconst param = paramInstances[i]\n\t\tif (param instanceof SqlFragment) {\n\t\t\tquery += param.text\n\t\t\tparams.push(...param.params)\n\t\t} else {\n\t\t\tquery += \"?\"\n\t\t\tparams.push(param)\n\t\t}\n\t}\n\tquery += queryParts[i]\n\treturn { query, params }\n}\n\nexport class SqlFragment {\n\tconstructor(readonly text: string, readonly params: SqlValue[]) {}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BO,SAAS,IAAIA,YAAkC,GAAG,gBAA4D;CACpH,IAAI,QAAQ;CACZ,IAAIC,SAA2B,CAAE;CACjC,IAAIC;AACJ,MAAK,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC3C,WAAS,WAAW;EACpB,MAAM,QAAQ,eAAe;AAC7B,MAAI,iBAAiB,aAAa;AACjC,YAAS,MAAM;AACf,UAAO,KAAK,GAAG,MAAM,OAAO,IAAI,YAAY,CAAC;EAC7C,OAAM;AACN,YAAS;AACT,UAAO,KAAK,YAAY,MAAM,CAAC;EAC/B;CACD;AACD,UAAS,WAAW;AACpB,QAAO;EAAE;EAAO;CAAQ;AACxB;AAOM,SAAS,KAAKF,YAAkC,GAAG,gBAA2D;CACpH,IAAI,QAAQ;CACZ,IAAIG,SAAqB,CAAE;CAC3B,IAAID;AACJ,MAAK,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC3C,WAAS,WAAW;EACpB,MAAM,QAAQ,eAAe;AAC7B,MAAI,iBAAiB,aAAa;AACjC,YAAS,MAAM;AACf,UAAO,KAAK,GAAG,MAAM,OAAO;EAC5B,OAAM;AACN,YAAS;AACT,UAAO,KAAK,MAAM;EAClB;CACD;AACD,UAAS,WAAW;AACpB,QAAO;EAAE;EAAO;CAAQ;AACxB;IAEY,cAAN,MAAkB;CACxB,YAAqBE,MAAuBD,QAAoB;EAEhE,KAFqB;EAEpB,KAF2C;CAAsB;AAClE"}