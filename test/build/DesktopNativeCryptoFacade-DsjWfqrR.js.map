{"version":3,"file":"DesktopNativeCryptoFacade-DsjWfqrR.js","names":["fs: FsExports","cryptoFns: CryptoFunctions","tfs: TempFs","argon2: Promise<Argon2IDExports>","encryptionKey: Aes256Key","object: number | string | boolean | ReadonlyArray<unknown> | object","serializedObject: string","key: Uint8Array","fileUri: string","encryptedFileUri: FileUri","keyToDecrypt: Uint8Array","keyToEncrypt: Uint8Array","data: Uint8Array","model: TypeModel","instance: Record<string, any>","piSessionKey: Uint8Array","piSessionKeyEncSessionKey: Uint8Array","byteLength: number","pem: string","sig: Uint8Array","count: number","privateKey: RsaPrivateKey","publicKey: RsaPublicKey","seed: Uint8Array","passphrase: string","salt: Uint8Array","publicKey: KyberPublicKey","privateKey: KyberPrivateKey","ciphertext: Uint8Array"],"sources":["../../src/common/desktop/DesktopNativeCryptoFacade.ts"],"sourcesContent":["import { base64ToBase64Url, base64ToUint8Array, stringToUtf8Uint8Array, uint8ArrayToBase64, utf8Uint8ArrayToString } from \"@tutao/tutanota-utils\"\nimport type { CryptoFunctions } from \"./CryptoFns.js\"\nimport type { TypeModel } from \"../api/common/EntityTypes.js\"\nimport type * as FsModule from \"node:fs\"\nimport { Aes256Key, Argon2IDExports, bitArrayToUint8Array, generateKeyFromPassphraseArgon2id, uint8ArrayToKey } from \"@tutao/tutanota-crypto\"\nimport { FileUri } from \"../native/common/FileApp.js\"\nimport path from \"node:path\"\nimport { NativeCryptoFacade } from \"../native/common/generatedipc/NativeCryptoFacade.js\"\nimport { EncryptedFileInfo } from \"../native/common/generatedipc/EncryptedFileInfo.js\"\nimport { RsaPrivateKey } from \"../native/common/generatedipc/RsaPrivateKey.js\"\nimport { RsaPublicKey } from \"../native/common/generatedipc/RsaPublicKey.js\"\nimport { nonClobberingFilename } from \"./PathUtils.js\"\nimport { TempFs } from \"./files/TempFs.js\"\nimport { KyberKeyPair } from \"../native/common/generatedipc/KyberKeyPair.js\"\nimport { KyberPublicKey } from \"../native/common/generatedipc/KyberPublicKey.js\"\nimport { KyberEncapsulation } from \"../native/common/generatedipc/KyberEncapsulation.js\"\nimport { KyberPrivateKey } from \"../native/common/generatedipc/KyberPrivateKey.js\"\n\ntype FsExports = typeof FsModule\n\nexport class DesktopNativeCryptoFacade implements NativeCryptoFacade {\n\tconstructor(\n\t\tprivate readonly fs: FsExports,\n\t\tprivate readonly cryptoFns: CryptoFunctions,\n\t\tprivate readonly tfs: TempFs,\n\t\tprivate readonly argon2: Promise<Argon2IDExports>,\n\t) {}\n\n\taesEncryptObject(encryptionKey: Aes256Key, object: number | string | boolean | ReadonlyArray<unknown> | object): string {\n\t\tconst serializedObject = JSON.stringify(object)\n\t\tconst encryptedBytes = this.cryptoFns.aesEncrypt(encryptionKey, stringToUtf8Uint8Array(serializedObject))\n\t\treturn uint8ArrayToBase64(encryptedBytes)\n\t}\n\n\taesDecryptObject(encryptionKey: Aes256Key, serializedObject: string): number | string | boolean | ReadonlyArray<unknown> | object {\n\t\tconst encryptedBytes = base64ToUint8Array(serializedObject)\n\t\tconst decryptedBytes = this.cryptoFns.aesDecrypt(encryptionKey, encryptedBytes, true)\n\t\tconst stringObject = utf8Uint8ArrayToString(decryptedBytes)\n\t\treturn JSON.parse(stringObject)\n\t}\n\n\tasync aesEncryptFile(key: Uint8Array, fileUri: string): Promise<EncryptedFileInfo> {\n\t\t// at the moment, this is randomized if the file to be encrypted\n\t\t// was created with FileFacade.writeDataFile.\n\t\t// to make it safe in all conditions, we should re-generate a random file name.\n\t\t// we're also not checking if the file to be encrypted is actually located in\n\t\t// the temp scratch space\n\t\tconst bytes = await this.fs.promises.readFile(fileUri)\n\t\tconst keyBits = this.cryptoFns.bytesToKey(key)\n\t\tconst encrypted = this.cryptoFns.aesEncrypt(keyBits, bytes)\n\t\tconst targetDir = await this.tfs.ensureEncryptedDir()\n\t\tconst writtenFileName = path.basename(fileUri)\n\t\tconst filePath = path.join(targetDir, writtenFileName)\n\t\tawait this.fs.promises.writeFile(filePath, encrypted)\n\t\treturn {\n\t\t\turi: filePath,\n\t\t\tunencryptedSize: bytes.length,\n\t\t}\n\t}\n\n\t/**\n\t * decrypts a file and returns the decrypted files path\n\t */\n\tasync aesDecryptFile(key: Uint8Array, encryptedFileUri: FileUri): Promise<FileUri> {\n\t\tconst targetDir = await this.tfs.ensureUnencrytpedDir()\n\t\tconst encData = await this.fs.promises.readFile(encryptedFileUri)\n\t\tconst bitKey = this.cryptoFns.bytesToKey(key)\n\t\tconst decData = this.cryptoFns.aesDecrypt(bitKey, encData, true)\n\n\t\tconst filesInDirectory = await this.fs.promises.readdir(targetDir)\n\t\t// since we're working purely in scratch space until putFileIntoDownloadsFolder\n\t\t// is called, we could re-generate a random name here.\n\t\tconst writtenFileName = path.basename(encryptedFileUri)\n\t\tconst newFilename = nonClobberingFilename(filesInDirectory, writtenFileName)\n\t\tconst decryptedFileUri = path.join(targetDir, newFilename)\n\t\tawait this.fs.promises.writeFile(decryptedFileUri, decData, {\n\t\t\tencoding: \"binary\",\n\t\t})\n\t\treturn decryptedFileUri\n\t}\n\n\tunauthenticatedAes256DecryptKey(encryptionKey: Aes256Key, keyToDecrypt: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.unauthenticatedAesDecrypt(encryptionKey, keyToDecrypt, false)\n\t}\n\n\taes256EncryptKey(encryptionKey: Aes256Key, keyToEncrypt: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.aesEncrypt(encryptionKey, keyToEncrypt, undefined, false)\n\t}\n\n\taesDecryptBytes(encryptionKey: Aes256Key, data: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.aesDecrypt(encryptionKey, data, true)\n\t}\n\n\taesEncryptBytes(encryptionKey: Aes256Key, data: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.aesEncrypt(encryptionKey, data, undefined, true, true)\n\t}\n\n\tdecryptAndMapToInstance<T>(model: TypeModel, instance: Record<string, any>, piSessionKey: Uint8Array, piSessionKeyEncSessionKey: Uint8Array): Promise<T> {\n\t\tconst sk = this.cryptoFns.decryptKey(uint8ArrayToKey(piSessionKey), piSessionKeyEncSessionKey)\n\t\treturn this.cryptoFns.decryptAndMapToInstance(model, instance, sk)\n\t}\n\n\tgenerateId(byteLength: number): string {\n\t\treturn base64ToBase64Url(uint8ArrayToBase64(this.cryptoFns.randomBytes(byteLength)))\n\t}\n\n\tverifySignature(pem: string, data: Uint8Array, sig: Uint8Array): boolean {\n\t\treturn this.cryptoFns.verifySignature(pem, data, sig)\n\t}\n\n\tgenerateDeviceKey(): Aes256Key {\n\t\treturn this.cryptoFns.aes256RandomKey()\n\t}\n\n\trandomBytes(count: number): Uint8Array {\n\t\treturn this.cryptoFns.randomBytes(count)\n\t}\n\n\tasync rsaDecrypt(privateKey: RsaPrivateKey, data: Uint8Array): Promise<Uint8Array> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tasync rsaEncrypt(publicKey: RsaPublicKey, data: Uint8Array, seed: Uint8Array): Promise<Uint8Array> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tasync argon2idGeneratePassphraseKey(passphrase: string, salt: Uint8Array): Promise<Uint8Array> {\n\t\tconst hash = await generateKeyFromPassphraseArgon2id(await this.argon2, passphrase, salt)\n\t\treturn bitArrayToUint8Array(hash)\n\t}\n\n\tgenerateKyberKeypair(seed: Uint8Array): Promise<KyberKeyPair> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tkyberEncapsulate(publicKey: KyberPublicKey, seed: Uint8Array): Promise<KyberEncapsulation> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tkyberDecapsulate(privateKey: KyberPrivateKey, ciphertext: Uint8Array): Promise<Uint8Array> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n}\n"],"mappings":"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"}