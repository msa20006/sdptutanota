{"version":3,"file":"WorkerLocator-vHg_-eJs.js","names":["infoMessageHandler: InfoMessageHandler","systemTimeout: SystemTimeout","suspensionDurationSeconds: number","resourceURL: URL","request: () => Promise<any>","deviceKey: Uint8Array","data: Uint8Array","encryptedData: Uint8Array","nativeCryptoFacade: NativeCryptoFacade","random: Randomizer","key: AesKey","fileUrl: FileUri","transport: NativeInterface","native: NativeInterface","publicKey: RsaPublicKey","bytes: Uint8Array","privateKey: RsaPrivateKey","rsa: RsaImplementation","pqFacade: PQFacade","keyLoaderFacade: KeyLoaderFacade","cryptoWrapper: CryptoWrapper","serviceExecutor: IServiceExecutor","identifier: PublicKeyIdentifier","senderIdentityPubKey: Uint8Array","senderKeyVersion: number","recipientKeyPair: AsymmetricKeyPair","pubEncKeyData: PubEncKeyData","senderIdentifier: PublicKeyIdentifier","cryptoProtocolVersion: CryptoProtocolVersion","pubEncSymKey: Uint8Array","privateKey: RsaPrivateKey","recipientKeyPairGroupId: Id","recipientKeyVersion: number","keyPair: AsymmetricKeyPair","symKey: AesKey","recipientPublicKeys: Versioned<PublicKeys>","senderGroupId: Id","senderEccKeyPair: Versioned<EccKeyPair>","recipientPublicKey: Versioned<PQPublicKeys>","publicKeys: PublicKeys","senderKeyPair: AsymmetricKeyPair","keyGroupId: Id","publicKeyGetOut: PublicKeyGetOut","userFacade: UserFacade","entityClient: EntityClient","restClient: RestClient","serviceExecutor: IServiceExecutor","instanceMapper: InstanceMapper","ownerEncSessionKeysUpdateQueue: OwnerEncSessionKeysUpdateQueue","cache: DefaultEntityRestCache | null","keyLoaderFacade: KeyLoaderFacade","asymmetricCryptoFacade: AsymmetricCryptoFacade","decryptedInstance: T","instance: SomeEntity","instance: Record<string, any>","ownerKey: AesKey","key: Uint8Array | string","ownerEncSessionKey: VersionedEncryptedKey","typeModel: TypeModel","typeRef: TypeRef<T>","data: Record<string, any>","bucketKeyInstanceOrLiteral: Record<string, any>","bucketKey: BucketKey","decryptedBucketKey: AesKey","unencryptedSenderAuthStatus: EncryptionAuthStatus | null","pqMessageSenderKey: EccPublicKey | null","value: string","keyGroup: Id","groupKeyVersion: number","groupEncBucketKey: Uint8Array","g: GroupMembership","unmappedInstance: UnmappedOwnerGroupInstance","key: VersionedEncryptedKey","ownerGroup?: Id","instance: Instance","elementOrLiteral: Record<string, any>","listPermissions: Permission[]","symmetricPermission: Permission | null","decBucketKey: number[]","instanceElementId: string","encryptionAuthStatus: EncryptionAuthStatus | null","resolvedSessionKeyForInstance: AesKey | undefined","encryptionAuthStatus:\n\t\t\t| EncryptionAuthStatus\n\t\t\t| null\n\t\t\t| EncryptionAuthStatus.RSA_NO_AUTHENTICATION\n\t\t\t| EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED\n\t\t\t| EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED\n\t\t\t| EncryptionAuthStatus.AES_NO_AUTHENTICATION","pqMessageSenderKey: Uint8Array | null","pqMessageSenderKeyVersion: number | null","resolvedSessionKeyForInstance: number[]","instanceSessionKeyWithOwnerEncSessionKey: InstanceSessionKey","decryptedSessionKey: number[]","senderMailAddress: string","pqMessageSenderKey: Uint8Array","bucketPermission: BucketPermission","pubOrExtPermission: Permission","model: TypeModel","entity: Record<string, any>","keyToEncryptSessionKey?: VersionedKey","senderUserGroupId: Id","bucketKey: AesKey","recipientMailAddress: string","notFoundRecipients: Array<string>","publicKeyGetOut: PublicKeyGetOut","senderGroupId: Id","permission: Permission","permissionOwnerGroupKey: VersionedKey","sessionKey: AesKey","mainInstance: Record<string, any>","childInstances: readonly File[]","ownerGroupKey: VersionedKey","alt: Record<string, any>","model: TypeModel","instance: Record<string, any>","sk: AesKey | null","decrypted: any","instance: T","encrypted: Record<string, unknown>","valueName: string","valueType: ModelValue","value: any","iv: Uint8Array","value: (Base64 | null) | string","type: Values<typeof ValueType>","value: Base64 | string","uncompressed: string","compressed: Uint8Array","value: unknown","batch: QueuedBatch","instance: T","_typeRef: TypeRef<T>","_id: PropertyType<T, \"_id\">","_opts: EntityRestClientLoadOptions","typeRef: TypeRef<T>","listId: Id | null","elementIds: Array<Id>","listId: Id","start: Id","count: number","reverse: boolean","extraHeaders?: Dict","instances: Array<T>","groupId: Id","batchId: Id","scheduler: Scheduler","dateProvider: DateProvider","onSleep: Thunk","typeRef: TypeRef<T>","listId: Id | null","elementId: Id","TypeId","typeModel: TypeModel","id: Id","entity: T","listId: Id","originalEntity: SomeEntity","typeRef: TypeRef<BlobElementEntity>","entity: BlobElementEntity","typeRef: TypeRef<ListElementEntity>","entity: ListElementEntity","allRange: Array<Id>","startElementId: Id","count: number","reverse: boolean","ids: Id[]","result: T[]","elementIds: Id[]","upperId: Id","lowerId: Id","lower: Id","upper: Id","groupId: Id","batchId: Id","value: number","entityRestClient: EntityRestClient","owner: Id","cacheForType: Map<Id, ListCache | BlobElementCache>","owner: string","listIdsToDelete: string[]","listId: string","sendError: (error: Error) => Promise<void>","offlineStorageProvider: () => Promise<null | OfflineStorage>","args: OfflineStorageArgs | EphemeralStorageArgs","storage","typeRef: TypeRef<T>","listId: Id | null","id: Id","listId: Id","groupId: Id","start: Id","count: number","reverse: boolean","listId: string","elementIds: string[]","originalEntity: SomeEntity","batchId: Id","value: number","lower: Id","upper: Id","entityRestClient: EntityRestClient","owner: Id","restClient: RestClient","authDataProvider: AuthDataProvider","instanceMapper: InstanceMapper","cryptoFacade: lazy<CryptoFacade>","service: S","data: ParamTypeFromRef<S[\"get\"][\"data\"]>","params?: ExtraServiceParams","data: ParamTypeFromRef<S[\"post\"][\"data\"]>","data: ParamTypeFromRef<S[\"put\"][\"data\"]>","data: ParamTypeFromRef<S[\"delete\"][\"data\"]>","service: AnyService","method: HttpMethod","requestEntity: Entity | null","params: ExtraServiceParams | undefined","data: string | undefined","methodDefinition: MethodDefinition","params: ExtraServiceParams | null","typeRef: TypeRef<T>","data: string","keyCache: KeyCache","cryptoWrapper: CryptoWrapper","accessToken: string | null","user: User","userPassphraseKey: AesKey","userPassphraseKey: number[]","userGroupId: Id","groupId: Id","g: GroupMembership","groupType: GroupType","status: WebsocketLeaderStatus","userGroupKeyDistribution: UserGroupKeyDistribution","transport: NativeInterface","userFacade: UserFacade","serviceExecutor: IServiceExecutor","random: Randomizer","lazyKeyLoaderFacade: lazy<KeyLoaderFacade>","entropy: EntropyDataChunk[]","tutanotaProperties: TutanotaProperties","serviceExecutor: IServiceExecutor","authDataProvider: AuthDataProvider","dateProvider: DateProvider","archiveDataType: ArchiveDataType","ownerGroupId: Id","ownerGroupId: string","referencingInstances: readonly BlobReferencingInstance[]","blobLoadOptions: BlobLoadOptions","referencingInstance: BlobReferencingInstance","referencingInstances: BlobReferencingInstance[]","archiveId: Id","blobServerAccessInfo: BlobServerAccessInfo","additionalRequestParams: Dict","typeRef: TypeRef<any>","archiveOrGroupKey: Id | null","instanceIds: readonly Id[]","loader: () => Promise<BlobServerAccessInfo>","id: Id","ids: Id[]","userFacade: UserFacade","serviceExecutor: IServiceExecutor","debounceTimeoutMs: number","instanceSessionKeys: Array<InstanceSessionKey>","typeModel: TypeModel","connectivityListener: WebsocketConnectivityListener","mailFacade: lazyAsync<MailFacade>","userFacade: UserFacade","entityClient: EntityClient","eventController: ExposedEventController","configurationDatabase: lazyAsync<ConfigurationDatabase>","keyRotationFacade: KeyRotationFacade","cacheManagementFacade: lazyAsync<CacheManagementFacade>","sendError: (error: Error) => Promise<void>","appSpecificBatchHandling: (queuedBatch: QueuedBatch[]) => void","state: WsConnectionState","events: EntityUpdate[]","batchId: Id","groupId: Id","markers: ReportedMailFieldMarker[]","tutanotaError: Error","leaderStatus: WebsocketLeaderStatus","counter: WebsocketCounterData","data: EntityUpdate[]","groupKeyUpdates: IdTuple[]","html: string","passphrase: string","salt: Uint8Array","nativeCryptoFacade: NativeCryptoFacade","testWASM?: LibOQSExports","publicKey: KyberPublicKey","privateKey: KyberPrivateKey","ciphertext: Uint8Array","nativeCryptoFacade: NativeCryptoFacade","encoded: Uint8Array","kyberFacade: KyberFacade","senderIdentityKeyPair: EccKeyPair","ephemeralKeyPair: EccKeyPair","recipientPublicKeys: PQPublicKeys","bucketKey: Uint8Array","encodedPQMessage: Uint8Array","recipientKeys: PQKeyPairs","message: PQMessage","senderIdentityPublicKey: EccPublicKey","ephemeralPublicKey: EccPublicKey","kyberCipherText: Uint8Array","kyberSharedSecret: Uint8Array","eccSharedSecret: EccSharedSecrets","cryptoProtocolVersion: CryptoProtocolVersion","keyCache: KeyCache","userFacade: UserFacade","entityClient: EntityClient","cacheManagementFacade: lazyAsync<CacheManagementFacade>","groupId: Id","requestedVersion: number","currentGroupKey?: VersionedKey","keyPairGroupId: Id","group: Group","currentGroupKey: VersionedKey","keyPair: KeyPair | null","symGroupKey: AesKey","targetKeyVersion: number","formerKeys: GroupKey[]","lastGroupKeyInstance: GroupKey | null","id: Id","groupKey: AesKey","entityClient: EntityClient","keyLoaderFacade: KeyLoaderFacade","pqFacade: PQFacade","serviceExecutor: IServiceExecutor","cryptoWrapper: CryptoWrapper","recoverCodeFacade: lazyAsync<RecoverCodeFacade>","userFacade: UserFacade","cryptoFacade: CryptoFacade","shareFacade: lazyAsync<ShareFacade>","groupManagementFacade: lazyAsync<GroupManagementFacade>","asymmetricCryptoFacade: AsymmetricCryptoFacade","pwKey: Aes256Key","modernKdfType: boolean","user: User","adminOrUserGroupKeyRotationArray: Array<KeyRotation>","invitationData: GroupInvitationPostData[]","passphraseKey: Aes256Key","keyRotation: KeyRotation","preparedReInvites: GroupInvitationPostData[]","currentUserGroupKey: VersionedKey","currentAdminGroupKey: VersionedKey","pubEccKey: Uint8Array","pubKyberKey: Uint8Array","adminGroupKeyVersion: number","adminGroupId: Id","customerId: Id","groupToExclude: Id","keyHashes: AdminGroupKeyAuthenticationData[]","userGroupId: Id","userGroupKey: VersionedKey","adminGroupId: string","userEncNewGroupKey: VersionedEncryptedKey","targetGroupId: string","targetGroup: Group","userGroup: Group","newUserGroupKeys: GeneratedGroupKeys","newAdminGroupKeys: GeneratedGroupKeys","passphraseKey: AesKey","recoverCodeData: RecoverCodeData | null","currentGroupKey: VersionedKey","newTargetGroupKey: VersionedKey","preparedReInvitations: Array<GroupInvitationPostData>","mailAddresses: string[]","group: Group","newGroupKey: VersionedKey","groupId: Id","otherMembers: GroupMember[]","notFoundRecipients: Array<string>","newKeys: GeneratedGroupKeys","adminGroupKeys: VersionedKey","userId: Id","groupToRotate: Group","newSymmetricGroupKey: Aes256Key","pendingKeyRotations: PendingKeyRotation","groupKeyUpdateIds: IdTuple[]","groupKeyUpdate: GroupKeyUpdate","pwKey: AesKey","userGroupKeyRotation: KeyRotation","publicKeyGetOut: PublicKeyGetOut","adminPubKeys: Versioned<PublicKeys>","pqKeyPair: PQKeyPairs","key: AesKey","keyPair: EncryptedPqKeyPairs | null","newUserGroupKey: VersionedKey","userGroupKeyDistributionKey: Aes256Key","groupId: Id","keyLoader: () => Promise<VersionedKey>","user: User","shiftByDays: number","locator: WorkerLocatorType","worker: WorkerImpl","browserData: BrowserData","error: Error","cache: DefaultEntityRestCache | null","dateProvider","loginListener: LoginListener","sessionType: SessionType","cacheInfo: CacheInfo","credentials: Credentials","reason: LoginFailReason","sessionId: IdTuple","challenges: ReadonlyArray<Challenge>","mailAddress: string | null","argon2idFacade: Argon2idFacade","queuedBatch: QueuedBatch[]","keyLoaderFacade: KeyLoaderFacade"],"sources":["../../src/common/api/worker/SuspensionHandler.ts","../../src/common/api/worker/facades/DeviceEncryptionFacade.ts","../../src/common/native/worker/AesApp.ts","../../src/common/native/common/generatedipc/NativeCryptoFacadeSendDispatcher.ts","../../src/common/api/worker/crypto/RsaImplementation.ts","../../src/common/api/worker/crypto/AsymmetricCryptoFacade.ts","../../src/common/api/worker/crypto/CryptoFacade.ts","../../src/common/api/worker/crypto/InstanceMapper.ts","../../src/common/api/worker/rest/AdminClientDummyEntityRestCache.ts","../../src/common/api/worker/utils/SleepDetector.ts","../../src/common/api/worker/rest/EphemeralCacheStorage.ts","../../src/common/api/worker/rest/CacheStorageProxy.ts","../../src/common/api/worker/rest/ServiceExecutor.ts","../../src/common/api/worker/facades/UserFacade.ts","../../src/common/native/common/generatedipc/SqlCipherFacadeSendDispatcher.ts","../../src/common/api/worker/facades/EntropyFacade.ts","../../src/common/api/worker/facades/BlobAccessTokenFacade.ts","../../src/common/api/worker/crypto/OwnerEncSessionKeysUpdateQueue.ts","../../src/common/api/worker/EventBusEventCoordinator.ts","../../src/common/api/worker/facades/WorkerFacade.ts","../../src/common/api/worker/facades/Argon2idFacade.ts","../../src/common/api/worker/facades/KyberFacade.ts","../../src/common/api/worker/facades/PQMessage.ts","../../src/common/api/worker/facades/PQFacade.ts","../../src/common/api/worker/facades/KeyLoaderFacade.ts","../../src/common/api/worker/facades/KeyRotationFacade.ts","../../src/common/api/worker/facades/KeyCache.ts","../../src/common/api/worker/DateProvider.ts","../../src/mail-app/workerUtils/worker/WorkerLocator.ts"],"sourcesContent":["import type { DeferredObject } from \"@tutao/tutanota-utils\"\nimport { defer, noOp } from \"@tutao/tutanota-utils\"\nimport type { SystemTimeout } from \"../common/utils/Scheduler.js\"\nimport { InfoMessageHandler } from \"../../gui/InfoMessageHandler.js\"\n\nexport class SuspensionHandler {\n\t_isSuspended: boolean\n\t_suspendedUntil: number\n\t_deferredRequests: Array<DeferredObject<any>>\n\t_hasSentInfoMessage: boolean\n\t_timeout: SystemTimeout\n\n\tconstructor(private readonly infoMessageHandler: InfoMessageHandler, systemTimeout: SystemTimeout) {\n\t\tthis._isSuspended = false\n\t\tthis._suspendedUntil = 0\n\t\tthis._deferredRequests = []\n\t\tthis._hasSentInfoMessage = false\n\t\tthis._timeout = systemTimeout\n\t}\n\n\t/**\n\t * Activates suspension states for the given amount of seconds. After the end of the suspension time all deferred requests are executed.\n\t */\n\t// if already suspended do we want to ignore incoming suspensions?\n\tactivateSuspensionIfInactive(suspensionDurationSeconds: number, resourceURL: URL) {\n\t\tif (!this.isSuspended()) {\n\t\t\tconsole.log(`Activating suspension (${resourceURL}):  ${suspensionDurationSeconds}s`)\n\t\t\tthis._isSuspended = true\n\t\t\tconst suspensionStartTime = Date.now()\n\n\t\t\tthis._timeout.setTimeout(async () => {\n\t\t\t\tthis._isSuspended = false\n\t\t\t\tconsole.log(`Suspension released after ${(Date.now() - suspensionStartTime) / 1000}s`)\n\t\t\t\tawait this._onSuspensionComplete()\n\t\t\t}, suspensionDurationSeconds * 1000)\n\n\t\t\tif (!this._hasSentInfoMessage) {\n\t\t\t\tthis.infoMessageHandler.onInfoMessage({\n\t\t\t\t\ttranslationKey: \"clientSuspensionWait_label\",\n\t\t\t\t\targs: {},\n\t\t\t\t})\n\n\t\t\t\tthis._hasSentInfoMessage = true\n\t\t\t}\n\t\t}\n\t}\n\n\tisSuspended(): boolean {\n\t\treturn this._isSuspended\n\t}\n\n\t/**\n\t * Adds a request to the deferred queue.\n\t * @param request\n\t * @returns {Promise<T>}\n\t */\n\tdeferRequest(request: () => Promise<any>): Promise<any> {\n\t\tif (this._isSuspended) {\n\t\t\tconst deferredObject = defer()\n\n\t\t\tthis._deferredRequests.push(deferredObject)\n\n\t\t\t// assign request promise to deferred object\n\t\t\tdeferredObject.promise = deferredObject.promise.then(() => request())\n\t\t\treturn deferredObject.promise\n\t\t} else {\n\t\t\t// if suspension is not activated then immediately execute the request\n\t\t\treturn request()\n\t\t}\n\t}\n\n\tasync _onSuspensionComplete() {\n\t\tconst deferredRequests = this._deferredRequests\n\t\tthis._deferredRequests = []\n\n\t\t// do wee need to delay those requests?\n\t\tfor (let deferredRequest of deferredRequests) {\n\t\t\tdeferredRequest.resolve(null)\n\t\t\t// Ignore all errors here, any errors should be caught by whoever is handling the deferred request\n\t\t\tawait deferredRequest.promise.catch(noOp)\n\t\t}\n\t}\n}\n","import { aes256RandomKey, aesDecrypt, aesEncrypt, bitArrayToUint8Array, uint8ArrayToBitArray } from \"@tutao/tutanota-crypto\"\n\nexport class DeviceEncryptionFacade {\n\t/**\n\t * Generates an encryption key.\n\t */\n\tasync generateKey(): Promise<Uint8Array> {\n\t\treturn bitArrayToUint8Array(aes256RandomKey())\n\t}\n\n\t/**\n\t * Encrypts {@param data} using {@param deviceKey}.\n\t * @param deviceKey Key used for encryption\n\t * @param data Data to encrypt.\n\t */\n\tasync encrypt(deviceKey: Uint8Array, data: Uint8Array): Promise<Uint8Array> {\n\t\treturn aesEncrypt(uint8ArrayToBitArray(deviceKey), data)\n\t}\n\n\t/**\n\t * Decrypts {@param encryptedData} using {@param deviceKey}.\n\t * @param deviceKey Key used for encryption\n\t * @param encryptedData Data to be decrypted.\n\t */\n\tasync decrypt(deviceKey: Uint8Array, encryptedData: Uint8Array): Promise<Uint8Array> {\n\t\treturn aesDecrypt(uint8ArrayToBitArray(deviceKey), encryptedData)\n\t}\n}\n","import { AesKey, IV_BYTE_LENGTH, keyToUint8Array, Randomizer } from \"@tutao/tutanota-crypto\"\nimport { FileUri } from \"../common/FileApp\"\nimport { NativeCryptoFacade } from \"../common/generatedipc/NativeCryptoFacade\"\nimport { EncryptedFileInfo } from \"../common/generatedipc/EncryptedFileInfo\"\n\nexport class AesApp {\n\tconstructor(private readonly nativeCryptoFacade: NativeCryptoFacade, private readonly random: Randomizer) {}\n\n\t/**\n\t * Encrypts a file with the provided key\n\t * @return Returns the URI of the decrypted file. Resolves to an exception if the encryption failed.\n\t */\n\taesEncryptFile(key: AesKey, fileUrl: FileUri): Promise<EncryptedFileInfo> {\n\t\tconst iv = this.random.generateRandomData(IV_BYTE_LENGTH)\n\t\tconst encodedKey = keyToUint8Array(key)\n\t\treturn this.nativeCryptoFacade.aesEncryptFile(encodedKey, fileUrl, iv)\n\t}\n\n\t/**\n\t * Decrypt bytes with the provided key\n\t * @return Returns the URI of the decrypted file. Resolves to an exception if the encryption failed.\n\t */\n\taesDecryptFile(key: AesKey, fileUrl: FileUri): Promise<FileUri> {\n\t\tconst encodedKey = keyToUint8Array(key)\n\t\treturn this.nativeCryptoFacade.aesDecryptFile(encodedKey, fileUrl)\n\t}\n}\n","/* generated file, don't edit. */\n\nimport { NativeCryptoFacade } from \"./NativeCryptoFacade.js\"\n\ninterface NativeInterface {\n\tinvokeNative(requestType: string, args: unknown[]): Promise<any>\n}\nexport class NativeCryptoFacadeSendDispatcher implements NativeCryptoFacade {\n\tconstructor(private readonly transport: NativeInterface) {}\n\tasync rsaEncrypt(...args: Parameters<NativeCryptoFacade[\"rsaEncrypt\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"rsaEncrypt\", ...args])\n\t}\n\tasync rsaDecrypt(...args: Parameters<NativeCryptoFacade[\"rsaDecrypt\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"rsaDecrypt\", ...args])\n\t}\n\tasync aesEncryptFile(...args: Parameters<NativeCryptoFacade[\"aesEncryptFile\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"aesEncryptFile\", ...args])\n\t}\n\tasync aesDecryptFile(...args: Parameters<NativeCryptoFacade[\"aesDecryptFile\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"aesDecryptFile\", ...args])\n\t}\n\tasync argon2idGeneratePassphraseKey(...args: Parameters<NativeCryptoFacade[\"argon2idGeneratePassphraseKey\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"argon2idGeneratePassphraseKey\", ...args])\n\t}\n\tasync generateKyberKeypair(...args: Parameters<NativeCryptoFacade[\"generateKyberKeypair\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"generateKyberKeypair\", ...args])\n\t}\n\tasync kyberEncapsulate(...args: Parameters<NativeCryptoFacade[\"kyberEncapsulate\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"kyberEncapsulate\", ...args])\n\t}\n\tasync kyberDecapsulate(...args: Parameters<NativeCryptoFacade[\"kyberDecapsulate\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"NativeCryptoFacade\", \"kyberDecapsulate\", ...args])\n\t}\n}\n","import type { NativeInterface } from \"../../../native/common/NativeInterface\"\nimport { isApp } from \"../../common/Env\"\nimport type { RsaPrivateKey, RsaPublicKey } from \"@tutao/tutanota-crypto\"\nimport { random, rsaDecrypt, rsaEncrypt } from \"@tutao/tutanota-crypto\"\nimport { NativeCryptoFacadeSendDispatcher } from \"../../../native/common/generatedipc/NativeCryptoFacadeSendDispatcher\"\n\nexport async function createRsaImplementation(native: NativeInterface): Promise<RsaImplementation> {\n\tif (isApp()) {\n\t\tconst { RsaApp } = await import(\"../../../native/worker/RsaApp\")\n\t\treturn new RsaApp(new NativeCryptoFacadeSendDispatcher(native), random)\n\t} else {\n\t\treturn new RsaWeb()\n\t}\n}\n\nexport interface RsaImplementation {\n\tencrypt(publicKey: RsaPublicKey, bytes: Uint8Array): Promise<Uint8Array>\n\n\tdecrypt(privateKey: RsaPrivateKey, bytes: Uint8Array): Promise<Uint8Array>\n}\n\nexport class RsaWeb implements RsaImplementation {\n\tasync encrypt(publicKey: RsaPublicKey, bytes: Uint8Array): Promise<Uint8Array> {\n\t\tconst seed = random.generateRandomData(32)\n\t\treturn rsaEncrypt(publicKey, bytes, seed)\n\t}\n\n\tasync decrypt(privateKey: RsaPrivateKey, bytes: Uint8Array): Promise<Uint8Array> {\n\t\treturn rsaDecrypt(privateKey, bytes)\n\t}\n}\n","import { assertWorkerOrNode } from \"../../common/Env\"\nimport {\n\tAesKey,\n\tAsymmetricKeyPair,\n\tAsymmetricPublicKey,\n\tbitArrayToUint8Array,\n\tEccKeyPair,\n\tEccPublicKey,\n\thexToRsaPublicKey,\n\tisPqKeyPairs,\n\tisPqPublicKey,\n\tisRsaEccKeyPair,\n\tisRsaOrRsaEccKeyPair,\n\tisRsaPublicKey,\n\tKeyPairType,\n\tPQPublicKeys,\n\tRsaPrivateKey,\n\tuint8ArrayToBitArray,\n} from \"@tutao/tutanota-crypto\"\nimport type { RsaImplementation } from \"./RsaImplementation\"\nimport { PQFacade } from \"../facades/PQFacade.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { asCryptoProtoocolVersion, CryptoProtocolVersion, EncryptionAuthStatus, PublicKeyIdentifierType } from \"../../common/TutanotaConstants.js\"\nimport { arrayEquals, assertNotNull, uint8ArrayToHex, Versioned } from \"@tutao/tutanota-utils\"\nimport { KeyLoaderFacade } from \"../facades/KeyLoaderFacade.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { createPublicKeyGetIn, createPublicKeyPutIn, PubEncKeyData, type PublicKeyGetOut } from \"../../entities/sys/TypeRefs.js\"\nimport { CryptoWrapper } from \"./CryptoWrapper.js\"\nimport { PublicKeyService } from \"../../entities/sys/Services.js\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest.js\"\n\nassertWorkerOrNode()\n\nexport type DecapsulatedAesKey = {\n\tdecryptedAesKey: AesKey\n\tsenderIdentityPubKey: EccPublicKey | null // for authentication: null for rsa only\n}\n\nexport type PublicKeyIdentifier = {\n\tidentifier: string\n\tidentifierType: PublicKeyIdentifierType\n}\n\nexport type PubEncSymKey = {\n\tpubEncSymKeyBytes: Uint8Array\n\tcryptoProtocolVersion: CryptoProtocolVersion\n\tsenderKeyVersion: number | null\n\trecipientKeyVersion: number\n}\nexport type PublicKeys = {\n\tpubRsaKey: null | Uint8Array\n\tpubEccKey: null | Uint8Array\n\tpubKyberKey: null | Uint8Array\n}\n\n/**\n * This class is responsible for asymmetric encryption and decryption.\n * It tries to hide the complexity behind handling different asymmetric protocol versions such as RSA and TutaCrypt.\n */\nexport class AsymmetricCryptoFacade {\n\tconstructor(\n\t\tprivate readonly rsa: RsaImplementation,\n\t\tprivate readonly pqFacade: PQFacade,\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t\tprivate readonly cryptoWrapper: CryptoWrapper,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t) {}\n\n\t/**\n\t * Verifies whether the key that the public key service returns is the same as the one used for encryption.\n\t * When we have key verification we should stop verifying against the PublicKeyService but against the verified key.\n\t *\n\t * @param identifier the identifier to load the public key to verify that it matches the one used in the protocol run.\n\t * @param senderIdentityPubKey the senderIdentityPubKey that was used to encrypt/authenticate the data.\n\t * @param senderKeyVersion the version of the senderIdentityPubKey.\n\t */\n\tasync authenticateSender(identifier: PublicKeyIdentifier, senderIdentityPubKey: Uint8Array, senderKeyVersion: number): Promise<EncryptionAuthStatus> {\n\t\tconst keyData = createPublicKeyGetIn({\n\t\t\tidentifier: identifier.identifier,\n\t\t\tidentifierType: identifier.identifierType,\n\t\t\tversion: senderKeyVersion.toString(),\n\t\t})\n\t\tconst publicKeyGetOut = await this.serviceExecutor.get(PublicKeyService, keyData)\n\t\treturn publicKeyGetOut.pubEccKey != null && arrayEquals(publicKeyGetOut.pubEccKey, senderIdentityPubKey)\n\t\t\t? EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED\n\t\t\t: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED\n\t}\n\n\t/**\n\t * Decrypts the pubEncSymKey with the recipientKeyPair and authenticates it if the protocol supports authentication.\n\t * If the protocol does not support authentication this method will only decrypt.\n\t * @param recipientKeyPair the recipientKeyPair. Must match the cryptoProtocolVersion and must be of the required recipientKeyVersion.\n\t * @param pubEncKeyData the encrypted symKey with the metadata (versions, group identifier etc.) for decryption and authentication.\n\t * @param senderIdentifier the identifier for the sender's key group\n\t * @throws CryptoError in case the authentication fails.\n\t */\n\tasync decryptSymKeyWithKeyPairAndAuthenticate(\n\t\trecipientKeyPair: AsymmetricKeyPair,\n\t\tpubEncKeyData: PubEncKeyData,\n\t\tsenderIdentifier: PublicKeyIdentifier,\n\t): Promise<DecapsulatedAesKey> {\n\t\tconst cryptoProtocolVersion = asCryptoProtoocolVersion(pubEncKeyData.protocolVersion)\n\t\tconst decapsulatedAesKey = await this.decryptSymKeyWithKeyPair(recipientKeyPair, cryptoProtocolVersion, pubEncKeyData.pubEncSymKey)\n\t\tif (cryptoProtocolVersion === CryptoProtocolVersion.TUTA_CRYPT) {\n\t\t\tconst encryptionAuthStatus = await this.authenticateSender(\n\t\t\t\tsenderIdentifier,\n\t\t\t\tassertNotNull(decapsulatedAesKey.senderIdentityPubKey),\n\t\t\t\tNumber(assertNotNull(pubEncKeyData.senderKeyVersion)),\n\t\t\t)\n\t\t\tif (encryptionAuthStatus !== EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED) {\n\t\t\t\tthrow new CryptoError(\"the provided public key could not be authenticated\")\n\t\t\t}\n\t\t}\n\t\treturn decapsulatedAesKey\n\t}\n\n\t/**\n\t * Decrypts the pubEncSymKey with the recipientKeyPair.\n\t * @param pubEncSymKey the asymmetrically encrypted session key\n\t * @param cryptoProtocolVersion asymmetric protocol to decrypt pubEncSymKey (RSA or TutaCrypt)\n\t * @param recipientKeyPair the recipientKeyPair. Must match the cryptoProtocolVersion.\n\t */\n\tasync decryptSymKeyWithKeyPair(\n\t\trecipientKeyPair: AsymmetricKeyPair,\n\t\tcryptoProtocolVersion: CryptoProtocolVersion,\n\t\tpubEncSymKey: Uint8Array,\n\t): Promise<DecapsulatedAesKey> {\n\t\tswitch (cryptoProtocolVersion) {\n\t\t\tcase CryptoProtocolVersion.RSA: {\n\t\t\t\tif (!isRsaOrRsaEccKeyPair(recipientKeyPair)) {\n\t\t\t\t\tthrow new CryptoError(\"wrong key type. expected rsa. got \" + recipientKeyPair.keyPairType)\n\t\t\t\t}\n\t\t\t\tconst privateKey: RsaPrivateKey = recipientKeyPair.privateKey\n\t\t\t\tconst decryptedSymKey = await this.rsa.decrypt(privateKey, pubEncSymKey)\n\t\t\t\treturn {\n\t\t\t\t\tdecryptedAesKey: uint8ArrayToBitArray(decryptedSymKey),\n\t\t\t\t\tsenderIdentityPubKey: null,\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CryptoProtocolVersion.TUTA_CRYPT: {\n\t\t\t\tif (!isPqKeyPairs(recipientKeyPair)) {\n\t\t\t\t\tthrow new CryptoError(\"wrong key type. expected TutaCrypt. got \" + recipientKeyPair.keyPairType)\n\t\t\t\t}\n\t\t\t\tconst { decryptedSymKeyBytes, senderIdentityPubKey } = await this.pqFacade.decapsulateEncoded(pubEncSymKey, recipientKeyPair)\n\t\t\t\treturn {\n\t\t\t\t\tdecryptedAesKey: uint8ArrayToBitArray(decryptedSymKeyBytes),\n\t\t\t\t\tsenderIdentityPubKey,\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new CryptoError(\"invalid cryptoProtocolVersion: \" + cryptoProtocolVersion)\n\t\t}\n\t}\n\n\t/**\n\t * Loads the recipient key pair in the required version and decrypts the pubEncSymKey with it.\n\t */\n\tasync loadKeyPairAndDecryptSymKey(\n\t\trecipientKeyPairGroupId: Id,\n\t\trecipientKeyVersion: number,\n\t\tcryptoProtocolVersion: CryptoProtocolVersion,\n\t\tpubEncSymKey: Uint8Array,\n\t): Promise<DecapsulatedAesKey> {\n\t\tconst keyPair: AsymmetricKeyPair = await this.keyLoaderFacade.loadKeypair(recipientKeyPairGroupId, recipientKeyVersion)\n\t\treturn await this.decryptSymKeyWithKeyPair(keyPair, cryptoProtocolVersion, pubEncSymKey)\n\t}\n\n\t/**\n\t * Encrypts the symKey asymmetrically with the provided public keys.\n\t * @param symKey the symmetric key  to be encrypted\n\t * @param recipientPublicKeys the public key(s) of the recipient in the current version\n\t * @param senderGroupId the group id of the sender. will only be used in case we also need the sender's key pair, e.g. with TutaCrypt.\n\t */\n\tasync asymEncryptSymKey(symKey: AesKey, recipientPublicKeys: Versioned<PublicKeys>, senderGroupId: Id): Promise<PubEncSymKey> {\n\t\tconst recipientPublicKey = this.extractRecipientPublicKey(recipientPublicKeys.object)\n\t\tconst keyPairType = recipientPublicKey.keyPairType\n\n\t\tif (isPqPublicKey(recipientPublicKey)) {\n\t\t\tconst senderKeyPair = await this.keyLoaderFacade.loadCurrentKeyPair(senderGroupId)\n\t\t\tconst senderEccKeyPair = await this.getOrMakeSenderIdentityKeyPair(senderKeyPair.object, senderGroupId)\n\t\t\treturn this.tutaCryptEncryptSymKeyImpl({ object: recipientPublicKey, version: recipientPublicKeys.version }, symKey, {\n\t\t\t\tobject: senderEccKeyPair,\n\t\t\t\tversion: senderKeyPair.version,\n\t\t\t})\n\t\t} else if (isRsaPublicKey(recipientPublicKey)) {\n\t\t\tconst pubEncSymKeyBytes = await this.rsa.encrypt(recipientPublicKey, bitArrayToUint8Array(symKey))\n\t\t\treturn {\n\t\t\t\tpubEncSymKeyBytes,\n\t\t\t\tcryptoProtocolVersion: CryptoProtocolVersion.RSA,\n\t\t\t\tsenderKeyVersion: null,\n\t\t\t\trecipientKeyVersion: recipientPublicKeys.version,\n\t\t\t}\n\t\t}\n\t\tthrow new CryptoError(\"unknown public key type: \" + keyPairType)\n\t}\n\n\t/**\n\t * Encrypts the symKey asymmetrically with the provided public keys using the TutaCrypt protocol.\n\t * @param symKey the key to be encrypted\n\t * @param recipientPublicKeys MUST be a pq key pair\n\t * @param senderEccKeyPair the sender's key pair (needed for authentication)\n\t * @throws ProgrammingError if the recipientPublicKeys are not suitable for TutaCrypt\n\t */\n\tasync tutaCryptEncryptSymKey(symKey: AesKey, recipientPublicKeys: Versioned<PublicKeys>, senderEccKeyPair: Versioned<EccKeyPair>): Promise<PubEncSymKey> {\n\t\tconst recipientPublicKey = this.extractRecipientPublicKey(recipientPublicKeys.object)\n\t\tif (!isPqPublicKey(recipientPublicKey)) {\n\t\t\tthrow new ProgrammingError(\"the recipient does not have pq key pairs\")\n\t\t}\n\t\treturn this.tutaCryptEncryptSymKeyImpl(\n\t\t\t{\n\t\t\t\tobject: recipientPublicKey,\n\t\t\t\tversion: recipientPublicKeys.version,\n\t\t\t},\n\t\t\tsymKey,\n\t\t\tsenderEccKeyPair,\n\t\t)\n\t}\n\n\tprivate async tutaCryptEncryptSymKeyImpl(\n\t\trecipientPublicKey: Versioned<PQPublicKeys>,\n\t\tsymKey: AesKey,\n\t\tsenderEccKeyPair: Versioned<EccKeyPair>,\n\t): Promise<PubEncSymKey> {\n\t\tconst ephemeralKeyPair = this.cryptoWrapper.generateEccKeyPair()\n\t\tconst pubEncSymKeyBytes = await this.pqFacade.encapsulateAndEncode(\n\t\t\tsenderEccKeyPair.object,\n\t\t\tephemeralKeyPair,\n\t\t\trecipientPublicKey.object,\n\t\t\tbitArrayToUint8Array(symKey),\n\t\t)\n\t\tconst senderKeyVersion = senderEccKeyPair.version\n\t\treturn { pubEncSymKeyBytes, cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT, senderKeyVersion, recipientKeyVersion: recipientPublicKey.version }\n\t}\n\n\tprivate extractRecipientPublicKey(publicKeys: PublicKeys): AsymmetricPublicKey {\n\t\tif (publicKeys.pubRsaKey) {\n\t\t\t// we ignore ecc keys as this is only used for the recipient keys\n\t\t\treturn hexToRsaPublicKey(uint8ArrayToHex(publicKeys.pubRsaKey))\n\t\t} else if (publicKeys.pubKyberKey && publicKeys.pubEccKey) {\n\t\t\tconst eccPublicKey = publicKeys.pubEccKey\n\t\t\tconst kyberPublicKey = this.cryptoWrapper.bytesToKyberPublicKey(publicKeys.pubKyberKey)\n\t\t\treturn {\n\t\t\t\tkeyPairType: KeyPairType.TUTA_CRYPT,\n\t\t\t\teccPublicKey,\n\t\t\t\tkyberPublicKey,\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Inconsistent Keypair\")\n\t\t}\n\t}\n\n\t/**\n\t * Returns the SenderIdentityKeyPair that is either already on the KeyPair that is being passed in,\n\t * or creates a new one and writes it to the respective Group.\n\t * @param senderKeyPair\n\t * @param keyGroupId Id for the Group that Public Key Service might write a new IdentityKeyPair for.\n\t * \t\t\t\t\t\tThis is necessary as a User might send an E-Mail from a shared mailbox,\n\t * \t\t\t\t\t\tfor which the KeyPair should be created.\n\t */\n\tprivate async getOrMakeSenderIdentityKeyPair(senderKeyPair: AsymmetricKeyPair, keyGroupId: Id): Promise<EccKeyPair> {\n\t\tconst algo = senderKeyPair.keyPairType\n\t\tif (isPqKeyPairs(senderKeyPair)) {\n\t\t\treturn senderKeyPair.eccKeyPair\n\t\t} else if (isRsaEccKeyPair(senderKeyPair)) {\n\t\t\treturn { publicKey: senderKeyPair.publicEccKey, privateKey: senderKeyPair.privateEccKey }\n\t\t} else if (isRsaOrRsaEccKeyPair(senderKeyPair)) {\n\t\t\t// there is no ecc key pair yet, so we have to genrate and upload one\n\t\t\tconst symGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(keyGroupId)\n\t\t\tconst newIdentityKeyPair = this.cryptoWrapper.generateEccKeyPair()\n\t\t\tconst symEncPrivEccKey = this.cryptoWrapper.encryptEccKey(symGroupKey.object, newIdentityKeyPair.privateKey)\n\t\t\tconst data = createPublicKeyPutIn({ pubEccKey: newIdentityKeyPair.publicKey, symEncPrivEccKey, keyGroup: keyGroupId })\n\t\t\tawait this.serviceExecutor.put(PublicKeyService, data)\n\t\t\treturn newIdentityKeyPair\n\t\t} else {\n\t\t\tthrow new CryptoError(\"unknown key pair type: \" + algo)\n\t\t}\n\t}\n}\n\nexport function convertToVersionedPublicKeys(publicKeyGetOut: PublicKeyGetOut): Versioned<PublicKeys> {\n\treturn {\n\t\tobject: {\n\t\t\tpubRsaKey: publicKeyGetOut.pubRsaKey,\n\t\t\tpubKyberKey: publicKeyGetOut.pubKyberKey,\n\t\t\tpubEccKey: publicKeyGetOut.pubEccKey,\n\t\t},\n\t\tversion: Number(publicKeyGetOut.pubKeyVersion),\n\t}\n}\n","import {\n\tassertNotNull,\n\tbase64ToUint8Array,\n\tdowncast,\n\tisSameTypeRef,\n\tisSameTypeRefByAttr,\n\tneverNull,\n\tofClass,\n\tpromiseMap,\n\tstringToUtf8Uint8Array,\n\tTypeRef,\n\tuint8ArrayToBase64,\n} from \"@tutao/tutanota-utils\"\nimport {\n\tAccountType,\n\tasCryptoProtoocolVersion,\n\tassertEnumValue,\n\tBucketPermissionType,\n\tCryptoProtocolVersion,\n\tEncryptionAuthStatus,\n\tGroupType,\n\tPermissionType,\n\tPublicKeyIdentifierType,\n\tSYSTEM_GROUP_MAIL_ADDRESS,\n} from \"../../common/TutanotaConstants\"\nimport { HttpMethod, resolveTypeReference } from \"../../common/EntityFunctions\"\nimport type { BucketKey, BucketPermission, GroupMembership, InstanceSessionKey, Permission, PublicKeyGetOut } from \"../../entities/sys/TypeRefs.js\"\nimport {\n\tBucketKeyTypeRef,\n\tBucketPermissionTypeRef,\n\tcreateInstanceSessionKey,\n\tcreatePublicKeyGetIn,\n\tcreateUpdatePermissionKeyData,\n\tGroupInfoTypeRef,\n\tGroupTypeRef,\n\tPermissionTypeRef,\n\tPushIdentifierTypeRef,\n} from \"../../entities/sys/TypeRefs.js\"\nimport {\n\tContact,\n\tContactTypeRef,\n\tcreateEncryptTutanotaPropertiesData,\n\tcreateInternalRecipientKeyData,\n\tcreateSymEncInternalRecipientKeyData,\n\tFile,\n\tFileTypeRef,\n\tInternalRecipientKeyData,\n\tMail,\n\tMailTypeRef,\n\tSymEncInternalRecipientKeyData,\n\tTutanotaPropertiesTypeRef,\n} from \"../../entities/tutanota/TypeRefs.js\"\nimport { typeRefToPath } from \"../rest/EntityRestClient\"\nimport { LockedError, NotFoundError, PayloadTooLargeError, TooManyRequestsError } from \"../../common/error/RestError\"\nimport { SessionKeyNotFoundError } from \"../../common/error/SessionKeyNotFoundError\"\nimport { birthdayToIsoDate, oldBirthdayToBirthday } from \"../../common/utils/BirthdayUtils\"\nimport type { Entity, Instance, SomeEntity, TypeModel } from \"../../common/EntityTypes\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport type { EntityClient } from \"../../common/EntityClient\"\nimport { RestClient } from \"../rest/RestClient\"\nimport { Aes256Key, aes256RandomKey, aesEncrypt, AesKey, bitArrayToUint8Array, decryptKey, EccPublicKey, encryptKey, sha256Hash } from \"@tutao/tutanota-crypto\"\nimport { RecipientNotResolvedError } from \"../../common/error/RecipientNotResolvedError\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { EncryptTutanotaPropertiesService } from \"../../entities/tutanota/Services\"\nimport { PublicKeyService, UpdatePermissionKeyService } from \"../../entities/sys/Services\"\nimport { UserFacade } from \"../facades/UserFacade\"\nimport { elementIdPart, getElementId, getListId } from \"../../common/utils/EntityUtils.js\"\nimport { InstanceMapper } from \"./InstanceMapper.js\"\nimport { OwnerEncSessionKeysUpdateQueue } from \"./OwnerEncSessionKeysUpdateQueue.js\"\nimport { DefaultEntityRestCache } from \"../rest/DefaultEntityRestCache.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { KeyLoaderFacade } from \"../facades/KeyLoaderFacade.js\"\nimport { encryptKeyWithVersionedKey, VersionedEncryptedKey, VersionedKey } from \"./CryptoWrapper.js\"\nimport { AsymmetricCryptoFacade, convertToVersionedPublicKeys } from \"./AsymmetricCryptoFacade.js\"\n\nassertWorkerOrNode()\n\n// Unmapped encrypted owner group instance\ntype UnmappedOwnerGroupInstance = {\n\t_ownerEncSessionKey: string\n\t_ownerKeyVersion: NumberString\n\t_ownerGroup: Id\n}\n\ntype ResolvedSessionKeys = {\n\tresolvedSessionKeyForInstance: AesKey\n\tinstanceSessionKeys: Array<InstanceSessionKey>\n}\n\nexport class CryptoFacade {\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly ownerEncSessionKeysUpdateQueue: OwnerEncSessionKeysUpdateQueue,\n\t\tprivate readonly cache: DefaultEntityRestCache | null,\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t\tprivate readonly asymmetricCryptoFacade: AsymmetricCryptoFacade,\n\t) {}\n\n\tasync applyMigrationsForInstance<T>(decryptedInstance: T): Promise<T> {\n\t\tconst instanceType = downcast<Entity>(decryptedInstance)._type\n\n\t\tif (isSameTypeRef(instanceType, ContactTypeRef)) {\n\t\t\tconst contact = downcast<Contact>(decryptedInstance)\n\n\t\t\ttry {\n\t\t\t\tif (!contact.birthdayIso && contact.oldBirthdayAggregate) {\n\t\t\t\t\tcontact.birthdayIso = birthdayToIsoDate(contact.oldBirthdayAggregate)\n\t\t\t\t\tcontact.oldBirthdayAggregate = null\n\t\t\t\t\tcontact.oldBirthdayDate = null\n\t\t\t\t\tawait this.entityClient.update(contact)\n\t\t\t\t} else if (!contact.birthdayIso && contact.oldBirthdayDate) {\n\t\t\t\t\tcontact.birthdayIso = birthdayToIsoDate(oldBirthdayToBirthday(contact.oldBirthdayDate))\n\t\t\t\t\tcontact.oldBirthdayDate = null\n\t\t\t\t\tawait this.entityClient.update(contact)\n\t\t\t\t} else if (contact.birthdayIso && (contact.oldBirthdayAggregate || contact.oldBirthdayDate)) {\n\t\t\t\t\tcontact.oldBirthdayAggregate = null\n\t\t\t\t\tcontact.oldBirthdayDate = null\n\t\t\t\t\tawait this.entityClient.update(contact)\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (!(e instanceof LockedError)) {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn decryptedInstance\n\t}\n\n\tasync resolveSessionKeyForInstance(instance: SomeEntity): Promise<AesKey | null> {\n\t\tconst typeModel = await resolveTypeReference(instance._type)\n\t\treturn this.resolveSessionKey(typeModel, instance)\n\t}\n\n\t/** Helper for the rare cases when we needed it on the client side. */\n\tasync resolveSessionKeyForInstanceBinary(instance: SomeEntity): Promise<Uint8Array | null> {\n\t\tconst key = await this.resolveSessionKeyForInstance(instance)\n\t\treturn key == null ? null : bitArrayToUint8Array(key)\n\t}\n\n\t/** Resolve a session key an {@param instance} using an already known {@param ownerKey}. */\n\tresolveSessionKeyWithOwnerKey(instance: Record<string, any>, ownerKey: AesKey): AesKey {\n\t\tlet key: Uint8Array | string = instance._ownerEncSessionKey\n\t\tif (typeof key === \"string\") {\n\t\t\tkey = base64ToUint8Array(key)\n\t\t}\n\n\t\treturn decryptKey(ownerKey, key)\n\t}\n\n\tasync decryptSessionKey(instance: Record<string, any>, ownerEncSessionKey: VersionedEncryptedKey): Promise<AesKey> {\n\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(instance._ownerGroup, ownerEncSessionKey.encryptingKeyVersion)\n\t\treturn decryptKey(gk, ownerEncSessionKey.key)\n\t}\n\n\t/**\n\t * Returns the session key for the provided type/instance:\n\t * * null, if the instance is unencrypted\n\t * * the decrypted _ownerEncSessionKey, if it is available\n\t * * the public decrypted session key, otherwise\n\t *\n\t * @param typeModel the type model of the instance\n\t * @param instance The unencrypted (client-side) instance or encrypted (server-side) object literal\n\t */\n\tasync resolveSessionKey(typeModel: TypeModel, instance: Record<string, any>): Promise<AesKey | null> {\n\t\ttry {\n\t\t\tif (!typeModel.encrypted) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tif (instance.bucketKey) {\n\t\t\t\t// if we have a bucket key, then we need to cache the session keys stored in the bucket key for details, files, etc.\n\t\t\t\t// we need to do this BEFORE we check the owner enc session key\n\t\t\t\tconst bucketKey = await this.convertBucketKeyToInstanceIfNecessary(instance.bucketKey)\n\t\t\t\tconst resolvedSessionKeys = await this.resolveWithBucketKey(bucketKey, instance, typeModel)\n\t\t\t\treturn resolvedSessionKeys.resolvedSessionKeyForInstance\n\t\t\t} else if (instance._ownerEncSessionKey && this.userFacade.isFullyLoggedIn() && this.userFacade.hasGroup(instance._ownerGroup)) {\n\t\t\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(instance._ownerGroup, Number(instance._ownerKeyVersion ?? 0))\n\t\t\t\treturn this.resolveSessionKeyWithOwnerKey(instance, gk)\n\t\t\t} else if (instance.ownerEncSessionKey) {\n\t\t\t\t// Likely a DataTransferType, so this is a service.\n\t\t\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(this.userFacade.getGroupId(GroupType.Mail), Number(instance.ownerKeyVersion ?? 0))\n\t\t\t\treturn this.resolveSessionKeyWithOwnerKey(instance, gk)\n\t\t\t} else {\n\t\t\t\t// See PermissionType jsdoc for more info on permissions\n\t\t\t\tconst permissions = await this.entityClient.loadAll(PermissionTypeRef, instance._permissions)\n\t\t\t\treturn (await this.trySymmetricPermission(permissions)) ?? (await this.resolveWithPublicOrExternalPermission(permissions, instance, typeModel))\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof CryptoError) {\n\t\t\t\tconsole.log(\"failed to resolve session key\", e)\n\t\t\t\tthrow new SessionKeyNotFoundError(\"Crypto error while resolving session key for instance \" + instance._id)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Takes a freshly JSON-parsed, unmapped object and apply migrations as necessary\n\t * @param typeRef\n\t * @param data\n\t * @return the unmapped and still encrypted instance\n\t */\n\tasync applyMigrations<T extends SomeEntity>(typeRef: TypeRef<T>, data: Record<string, any>): Promise<Record<string, any>> {\n\t\tif (isSameTypeRef(typeRef, GroupInfoTypeRef) && data._ownerGroup == null) {\n\t\t\treturn this.applyCustomerGroupOwnershipToGroupInfo(data)\n\t\t} else if (isSameTypeRef(typeRef, TutanotaPropertiesTypeRef) && data._ownerEncSessionKey == null) {\n\t\t\treturn this.encryptTutanotaProperties(data)\n\t\t} else if (isSameTypeRef(typeRef, PushIdentifierTypeRef) && data._ownerEncSessionKey == null) {\n\t\t\treturn this.addSessionKeyToPushIdentifier(data)\n\t\t} else {\n\t\t\treturn data\n\t\t}\n\t}\n\n\t/**\n\t * In case the given bucketKey is a literal the literal will be converted to an instance and return. In case the BucketKey is already an instance the\n\t * instance is returned.\n\t * @param bucketKeyInstanceOrLiteral The bucket key as literal or instance\n\t */\n\tasync convertBucketKeyToInstanceIfNecessary(bucketKeyInstanceOrLiteral: Record<string, any>): Promise<BucketKey> {\n\t\tif (this.isLiteralInstance(bucketKeyInstanceOrLiteral)) {\n\t\t\t// decryptAndMapToInstance is misleading here (it's not going to be decrypted), but we want to map the BucketKey aggregate and its session key from\n\t\t\t// a literal to an instance to have the encrypted keys in binary format and not as base 64. There is actually no decryption ongoing, just\n\t\t\t// mapToInstance.\n\t\t\tconst bucketKeyTypeModel = await resolveTypeReference(BucketKeyTypeRef)\n\t\t\treturn (await this.instanceMapper.decryptAndMapToInstance(bucketKeyTypeModel, bucketKeyInstanceOrLiteral, null)) as BucketKey\n\t\t} else {\n\t\t\t// bucket key was already decoded\n\t\t\treturn bucketKeyInstanceOrLiteral as BucketKey\n\t\t}\n\t}\n\n\tpublic async resolveWithBucketKey(bucketKey: BucketKey, instance: Record<string, any>, typeModel: TypeModel): Promise<ResolvedSessionKeys> {\n\t\tconst instanceElementId = this.getElementIdFromInstance(instance)\n\t\tlet decryptedBucketKey: AesKey\n\t\tlet unencryptedSenderAuthStatus: EncryptionAuthStatus | null = null\n\t\tlet pqMessageSenderKey: EccPublicKey | null = null\n\t\tif (bucketKey.keyGroup && bucketKey.pubEncBucketKey) {\n\t\t\t// bucket key is encrypted with public key for internal recipient\n\t\t\tconst { decryptedAesKey, senderIdentityPubKey } = await this.asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(\n\t\t\t\tbucketKey.keyGroup,\n\t\t\t\tNumber(bucketKey.recipientKeyVersion),\n\t\t\t\tasCryptoProtoocolVersion(bucketKey.protocolVersion),\n\t\t\t\tbucketKey.pubEncBucketKey,\n\t\t\t)\n\t\t\tdecryptedBucketKey = decryptedAesKey\n\t\t\tpqMessageSenderKey = senderIdentityPubKey\n\t\t} else if (bucketKey.groupEncBucketKey) {\n\t\t\t// received as secure external recipient or reply from secure external sender\n\t\t\tlet keyGroup\n\t\t\tconst groupKeyVersion = Number(bucketKey.recipientKeyVersion)\n\t\t\tif (bucketKey.keyGroup) {\n\t\t\t\t// 1. Uses when receiving confidential replies from external users.\n\t\t\t\t// 2. legacy code path for old external clients that used to encrypt bucket keys with user group keys.\n\t\t\t\tkeyGroup = bucketKey.keyGroup\n\t\t\t} else {\n\t\t\t\t// by default, we try to decrypt the bucket key with the ownerGroupKey (e.g. secure external recipient)\n\t\t\t\tkeyGroup = neverNull(instance._ownerGroup)\n\t\t\t}\n\n\t\t\tdecryptedBucketKey = await this.resolveWithGroupReference(keyGroup, groupKeyVersion, bucketKey.groupEncBucketKey)\n\t\t\tunencryptedSenderAuthStatus = EncryptionAuthStatus.AES_NO_AUTHENTICATION\n\t\t} else {\n\t\t\tthrow new SessionKeyNotFoundError(`encrypted bucket key not set on instance ${typeModel.name}`)\n\t\t}\n\t\tconst resolvedSessionKeys = await this.collectAllInstanceSessionKeysAndAuthenticate(\n\t\t\tbucketKey,\n\t\t\tdecryptedBucketKey,\n\t\t\tinstanceElementId,\n\t\t\tinstance,\n\t\t\ttypeModel,\n\t\t\tunencryptedSenderAuthStatus,\n\t\t\tpqMessageSenderKey,\n\t\t)\n\n\t\tawait this.ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(resolvedSessionKeys.instanceSessionKeys, typeModel)\n\n\t\t// for symmetrically encrypted instances _ownerEncSessionKey is sent from the server.\n\t\t// in this case it is not yet and we need to set it because the rest of the app expects it.\n\t\tconst groupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(instance._ownerGroup) // get current key for encrypting\n\t\tthis.setOwnerEncSessionKeyUnmapped(\n\t\t\tinstance as UnmappedOwnerGroupInstance,\n\t\t\tencryptKeyWithVersionedKey(groupKey, resolvedSessionKeys.resolvedSessionKeyForInstance),\n\t\t)\n\t\treturn resolvedSessionKeys\n\t}\n\n\t/**\n\t * Calculates the SHA-256 checksum of a string value as UTF-8 bytes and returns it as a base64-encoded string\n\t */\n\tpublic async sha256(value: string): Promise<string> {\n\t\treturn uint8ArrayToBase64(sha256Hash(stringToUtf8Uint8Array(value)))\n\t}\n\n\t/**\n\t * Decrypts the given encrypted bucket key with the group key of the given group. In case the current user is not\n\t * member of the key group the function tries to resolve the group key using the adminEncGroupKey.\n\t * This is necessary for resolving the BucketKey when receiving a reply from an external Mailbox.\n\t * @param keyGroup The group that holds the encryption key.\n\t * @param groupKeyVersion the version of the key from the keyGroup\n\t * @param groupEncBucketKey The group key encrypted bucket key.\n\t */\n\tprivate async resolveWithGroupReference(keyGroup: Id, groupKeyVersion: number, groupEncBucketKey: Uint8Array): Promise<AesKey> {\n\t\tif (this.userFacade.hasGroup(keyGroup)) {\n\t\t\t// the logged-in user (most likely external) is a member of that group. Then we have the group key from the memberships\n\t\t\tconst groupKey = await this.keyLoaderFacade.loadSymGroupKey(keyGroup, groupKeyVersion)\n\t\t\treturn decryptKey(groupKey, groupEncBucketKey)\n\t\t} else {\n\t\t\t// internal user receiving a mail from secure external:\n\t\t\t// internal user group key -> external user group key -> external mail group key -> bucket key\n\t\t\tconst externalMailGroupId = keyGroup\n\t\t\tconst externalMailGroupKeyVersion = groupKeyVersion\n\t\t\tconst externalMailGroup = await this.entityClient.load(GroupTypeRef, externalMailGroupId)\n\n\t\t\tconst externalUserGroupdId = externalMailGroup.admin\n\t\t\tif (!externalUserGroupdId) {\n\t\t\t\tthrow new SessionKeyNotFoundError(\"no admin group on key group: \" + externalMailGroupId)\n\t\t\t}\n\t\t\tconst externalUserGroupKeyVersion = Number(externalMailGroup.adminGroupKeyVersion ?? 0)\n\t\t\tconst externalUserGroup = await this.entityClient.load(GroupTypeRef, externalUserGroupdId)\n\n\t\t\tconst internalUserGroupId = externalUserGroup.admin\n\t\t\tconst internalUserGroupKeyVersion = Number(externalUserGroup.adminGroupKeyVersion ?? 0)\n\t\t\tif (!(internalUserGroupId && this.userFacade.hasGroup(internalUserGroupId))) {\n\t\t\t\tthrow new SessionKeyNotFoundError(\"no admin group or no membership of admin group: \" + internalUserGroupId)\n\t\t\t}\n\n\t\t\tconst internalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(internalUserGroupId, internalUserGroupKeyVersion)\n\n\t\t\tconst currentExternalUserGroupKey = decryptKey(internalUserGroupKey, assertNotNull(externalUserGroup.adminGroupEncGKey))\n\t\t\tconst externalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(externalUserGroupdId, externalUserGroupKeyVersion, {\n\t\t\t\tobject: currentExternalUserGroupKey,\n\t\t\t\tversion: Number(externalUserGroup.groupKeyVersion),\n\t\t\t})\n\n\t\t\tconst currentExternalMailGroupKey = decryptKey(externalUserGroupKey, assertNotNull(externalMailGroup.adminGroupEncGKey))\n\t\t\tconst externalMailGroupKey = await this.keyLoaderFacade.loadSymGroupKey(externalMailGroupId, externalMailGroupKeyVersion, {\n\t\t\t\tobject: currentExternalMailGroupKey,\n\t\t\t\tversion: Number(externalMailGroup.groupKeyVersion),\n\t\t\t})\n\n\t\t\treturn decryptKey(externalMailGroupKey, groupEncBucketKey)\n\t\t}\n\t}\n\n\tprivate async addSessionKeyToPushIdentifier(data: Record<string, any>): Promise<Record<string, any>> {\n\t\tconst userGroupKey = this.userFacade.getCurrentUserGroupKey()\n\n\t\t// set sessionKey for allowing encryption when old instance (< v43) is updated\n\t\tconst typeModel = await resolveTypeReference(PushIdentifierTypeRef)\n\t\tawait this.updateOwnerEncSessionKey(typeModel, data, userGroupKey, aes256RandomKey())\n\t\treturn data\n\t}\n\n\tprivate async encryptTutanotaProperties(data: Record<string, any>): Promise<Record<string, any>> {\n\t\tconst userGroupKey = this.userFacade.getCurrentUserGroupKey()\n\n\t\t// EncryptTutanotaPropertiesService could be removed and replaced with a Migration that writes the key\n\t\tconst groupEncSessionKey = encryptKeyWithVersionedKey(userGroupKey, aes256RandomKey())\n\t\tthis.setOwnerEncSessionKeyUnmapped(data as UnmappedOwnerGroupInstance, groupEncSessionKey, this.userFacade.getUserGroupId())\n\t\tconst migrationData = createEncryptTutanotaPropertiesData({\n\t\t\tproperties: data._id,\n\t\t\tsymKeyVersion: String(groupEncSessionKey.encryptingKeyVersion),\n\t\t\tsymEncSessionKey: groupEncSessionKey.key,\n\t\t})\n\t\tawait this.serviceExecutor.post(EncryptTutanotaPropertiesService, migrationData)\n\t\treturn data\n\t}\n\n\tprivate async applyCustomerGroupOwnershipToGroupInfo(data: Record<string, any>): Promise<Record<string, any>> {\n\t\tconst customerGroupMembership = assertNotNull(\n\t\t\tthis.userFacade.getLoggedInUser().memberships.find((g: GroupMembership) => g.groupType === GroupType.Customer),\n\t\t)\n\t\tconst listPermissions = await this.entityClient.loadAll(PermissionTypeRef, data._id[0])\n\t\tconst customerGroupPermission = listPermissions.find((p) => p.group === customerGroupMembership.group)\n\n\t\tif (!customerGroupPermission) throw new SessionKeyNotFoundError(\"Permission not found, could not apply OwnerGroup migration\")\n\t\tconst customerGroupKeyVersion = Number(customerGroupPermission.symKeyVersion ?? 0)\n\t\tconst customerGroupKey = await this.keyLoaderFacade.loadSymGroupKey(customerGroupMembership.group, customerGroupKeyVersion)\n\t\tconst versionedCustomerGroupKey = { object: customerGroupKey, version: customerGroupKeyVersion }\n\t\tconst listKey = decryptKey(customerGroupKey, assertNotNull(customerGroupPermission.symEncSessionKey))\n\t\tconst groupInfoSk = decryptKey(listKey, base64ToUint8Array(data._listEncSessionKey))\n\n\t\tthis.setOwnerEncSessionKeyUnmapped(\n\t\t\tdata as UnmappedOwnerGroupInstance,\n\t\t\tencryptKeyWithVersionedKey(versionedCustomerGroupKey, groupInfoSk),\n\t\t\tcustomerGroupMembership.group,\n\t\t)\n\t\treturn data\n\t}\n\n\tprivate setOwnerEncSessionKeyUnmapped(unmappedInstance: UnmappedOwnerGroupInstance, key: VersionedEncryptedKey, ownerGroup?: Id) {\n\t\tunmappedInstance._ownerEncSessionKey = uint8ArrayToBase64(key.key)\n\t\tunmappedInstance._ownerKeyVersion = key.encryptingKeyVersion.toString()\n\t\tif (ownerGroup) {\n\t\t\tunmappedInstance._ownerGroup = ownerGroup\n\t\t}\n\t}\n\n\tprivate setOwnerEncSessionKey(instance: Instance, key: VersionedEncryptedKey) {\n\t\tinstance._ownerEncSessionKey = key.key\n\t\tinstance._ownerKeyVersion = key.encryptingKeyVersion.toString()\n\t}\n\n\t/**\n\t * @return Whether the {@param elementOrLiteral} is a unmapped type, as used in JSON for transport or if it's a runtime representation of a type.\n\t */\n\tprivate isLiteralInstance(elementOrLiteral: Record<string, any>): boolean {\n\t\treturn typeof elementOrLiteral._type === \"undefined\"\n\t}\n\n\tprivate async trySymmetricPermission(listPermissions: Permission[]): Promise<AesKey | null> {\n\t\tconst symmetricPermission: Permission | null =\n\t\t\tlistPermissions.find(\n\t\t\t\t(p) =>\n\t\t\t\t\t(p.type === PermissionType.Public_Symmetric || p.type === PermissionType.Symmetric) &&\n\t\t\t\t\tp._ownerGroup &&\n\t\t\t\t\tthis.userFacade.hasGroup(p._ownerGroup),\n\t\t\t) ?? null\n\n\t\tif (symmetricPermission) {\n\t\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(\n\t\t\t\tassertNotNull(symmetricPermission._ownerGroup),\n\t\t\t\tNumber(symmetricPermission._ownerKeyVersion ?? 0),\n\t\t\t)\n\t\t\treturn decryptKey(gk, assertNotNull(symmetricPermission._ownerEncSessionKey))\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Resolves the session key for the provided instance and collects all other instances'\n\t * session keys in order to update them.\n\t */\n\tprivate async collectAllInstanceSessionKeysAndAuthenticate(\n\t\tbucketKey: BucketKey,\n\t\tdecBucketKey: number[],\n\t\tinstanceElementId: string,\n\t\tinstance: Record<string, any>,\n\t\ttypeModel: TypeModel,\n\t\tencryptionAuthStatus: EncryptionAuthStatus | null,\n\t\tpqMessageSenderKey: EccPublicKey | null,\n\t): Promise<ResolvedSessionKeys> {\n\t\tlet resolvedSessionKeyForInstance: AesKey | undefined = undefined\n\t\tconst instanceSessionKeys = await promiseMap(bucketKey.bucketEncSessionKeys, async (instanceSessionKey) => {\n\t\t\tconst decryptedSessionKey = decryptKey(decBucketKey, instanceSessionKey.symEncSessionKey)\n\t\t\tconst groupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(instance._ownerGroup)\n\t\t\tconst ownerEncSessionKey = encryptKeyWithVersionedKey(groupKey, decryptedSessionKey)\n\t\t\tconst instanceSessionKeyWithOwnerEncSessionKey = createInstanceSessionKey(instanceSessionKey)\n\t\t\tif (instanceElementId == instanceSessionKey.instanceId) {\n\t\t\t\tresolvedSessionKeyForInstance = decryptedSessionKey\n\t\t\t\t// we can only authenticate once we have the session key\n\t\t\t\t// because we need to check if the confidential flag is set, which is encrypted still\n\t\t\t\t// we need to do it here at the latest because we must write the flag when updating the session key on the instance\n\t\t\t\tawait this.authenticateMainInstance(\n\t\t\t\t\ttypeModel,\n\t\t\t\t\tencryptionAuthStatus,\n\t\t\t\t\tpqMessageSenderKey,\n\t\t\t\t\tbucketKey.protocolVersion === CryptoProtocolVersion.TUTA_CRYPT ? Number(bucketKey.senderKeyVersion ?? 0) : null,\n\t\t\t\t\tinstance,\n\t\t\t\t\tresolvedSessionKeyForInstance,\n\t\t\t\t\tinstanceSessionKeyWithOwnerEncSessionKey,\n\t\t\t\t\tdecryptedSessionKey,\n\t\t\t\t)\n\t\t\t}\n\t\t\tinstanceSessionKeyWithOwnerEncSessionKey.symEncSessionKey = ownerEncSessionKey.key\n\t\t\tinstanceSessionKeyWithOwnerEncSessionKey.symKeyVersion = String(ownerEncSessionKey.encryptingKeyVersion)\n\t\t\treturn instanceSessionKeyWithOwnerEncSessionKey\n\t\t})\n\n\t\tif (resolvedSessionKeyForInstance) {\n\t\t\treturn { resolvedSessionKeyForInstance, instanceSessionKeys }\n\t\t} else {\n\t\t\tthrow new SessionKeyNotFoundError(\"no session key for instance \" + instance._id)\n\t\t}\n\t}\n\n\tprivate async authenticateMainInstance(\n\t\ttypeModel: TypeModel,\n\t\tencryptionAuthStatus:\n\t\t\t| EncryptionAuthStatus\n\t\t\t| null\n\t\t\t| EncryptionAuthStatus.RSA_NO_AUTHENTICATION\n\t\t\t| EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED\n\t\t\t| EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED\n\t\t\t| EncryptionAuthStatus.AES_NO_AUTHENTICATION,\n\t\tpqMessageSenderKey: Uint8Array | null,\n\t\tpqMessageSenderKeyVersion: number | null,\n\t\tinstance: Record<string, any>,\n\t\tresolvedSessionKeyForInstance: number[],\n\t\tinstanceSessionKeyWithOwnerEncSessionKey: InstanceSessionKey,\n\t\tdecryptedSessionKey: number[],\n\t) {\n\t\t// we only authenticate mail instances\n\t\tconst isMailInstance = isSameTypeRefByAttr(MailTypeRef, typeModel.app, typeModel.name)\n\t\tif (isMailInstance) {\n\t\t\tif (!encryptionAuthStatus) {\n\t\t\t\tif (!pqMessageSenderKey) {\n\t\t\t\t\tencryptionAuthStatus = EncryptionAuthStatus.RSA_NO_AUTHENTICATION\n\t\t\t\t} else {\n\t\t\t\t\tconst mail = this.isLiteralInstance(instance)\n\t\t\t\t\t\t? ((await this.instanceMapper.decryptAndMapToInstance(typeModel, instance, resolvedSessionKeyForInstance)) as Mail)\n\t\t\t\t\t\t: (instance as Mail)\n\t\t\t\t\tconst senderMailAddress = mail.confidential ? mail.sender.address : SYSTEM_GROUP_MAIL_ADDRESS\n\t\t\t\t\tencryptionAuthStatus = await this.tryAuthenticateSenderOfMainInstance(senderMailAddress, pqMessageSenderKey, pqMessageSenderKeyVersion)\n\t\t\t\t}\n\t\t\t}\n\t\t\tinstanceSessionKeyWithOwnerEncSessionKey.encryptionAuthStatus = aesEncrypt(decryptedSessionKey, stringToUtf8Uint8Array(encryptionAuthStatus))\n\t\t}\n\t}\n\n\tprivate async tryAuthenticateSenderOfMainInstance(senderMailAddress: string, pqMessageSenderKey: Uint8Array, pqMessageSenderKeyVersion: number | null) {\n\t\ttry {\n\t\t\treturn await this.asymmetricCryptoFacade.authenticateSender(\n\t\t\t\t{\n\t\t\t\t\tidentifier: senderMailAddress,\n\t\t\t\t\tidentifierType: PublicKeyIdentifierType.MAIL_ADDRESS,\n\t\t\t\t},\n\t\t\t\tpqMessageSenderKey,\n\t\t\t\tassertNotNull(pqMessageSenderKeyVersion),\n\t\t\t)\n\t\t} catch (e) {\n\t\t\t// we do not want to fail mail decryption here, e.g. in case an alias was removed we would get a permanent NotFoundError.\n\t\t\t// in those cases we will just show a warning banner but still want to display the mail\n\t\t\tconsole.error(\"Could not authenticate sender\", e)\n\t\t\treturn EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED\n\t\t}\n\t}\n\n\tprivate async resolveWithPublicOrExternalPermission(listPermissions: Permission[], instance: Record<string, any>, typeModel: TypeModel): Promise<AesKey> {\n\t\tconst pubOrExtPermission = listPermissions.find((p) => p.type === PermissionType.Public || p.type === PermissionType.External) ?? null\n\n\t\tif (pubOrExtPermission == null) {\n\t\t\tconst typeName = `${typeModel.app}/${typeModel.name}`\n\t\t\tthrow new SessionKeyNotFoundError(`could not find permission for instance of type ${typeName} with id ${this.getElementIdFromInstance(instance)}`)\n\t\t}\n\n\t\tconst bucketPermissions = await this.entityClient.loadAll(BucketPermissionTypeRef, assertNotNull(pubOrExtPermission.bucket).bucketPermissions)\n\t\tconst bucketPermission = bucketPermissions.find(\n\t\t\t(bp) => (bp.type === BucketPermissionType.Public || bp.type === BucketPermissionType.External) && pubOrExtPermission._ownerGroup === bp._ownerGroup,\n\t\t)\n\n\t\t// find the bucket permission with the same group as the permission and public type\n\t\tif (bucketPermission == null) {\n\t\t\tthrow new SessionKeyNotFoundError(\"no corresponding bucket permission found\")\n\t\t}\n\n\t\tif (bucketPermission.type === BucketPermissionType.External) {\n\t\t\treturn this.decryptWithExternalBucket(bucketPermission, pubOrExtPermission, instance)\n\t\t} else {\n\t\t\treturn this.decryptWithPublicBucketWithoutAuthentication(bucketPermission, instance, pubOrExtPermission, typeModel)\n\t\t}\n\t}\n\n\tprivate async decryptWithExternalBucket(\n\t\tbucketPermission: BucketPermission,\n\t\tpubOrExtPermission: Permission,\n\t\tinstance: Record<string, any>,\n\t): Promise<AesKey> {\n\t\tlet bucketKey\n\n\t\tif (bucketPermission.ownerEncBucketKey != null) {\n\t\t\tconst ownerGroupKey = await this.keyLoaderFacade.loadSymGroupKey(\n\t\t\t\tneverNull(bucketPermission._ownerGroup),\n\t\t\t\tNumber(bucketPermission.ownerKeyVersion ?? 0),\n\t\t\t)\n\t\t\tbucketKey = decryptKey(ownerGroupKey, bucketPermission.ownerEncBucketKey)\n\t\t} else if (bucketPermission.symEncBucketKey) {\n\t\t\t// legacy case: for very old email sent to external user we used symEncBucketKey on the bucket permission.\n\t\t\t// The bucket key is encrypted with the user group key of the external user.\n\t\t\t// We maintain this code as we still have some old BucketKeys in some external mailboxes.\n\t\t\t// Can be removed if we finished mail details migration or when we do cleanup of external mailboxes.\n\t\t\tconst userGroupKey = await this.keyLoaderFacade.loadSymUserGroupKey(Number(bucketPermission.symKeyVersion ?? 0))\n\t\t\tbucketKey = decryptKey(userGroupKey, bucketPermission.symEncBucketKey)\n\t\t} else {\n\t\t\tthrow new SessionKeyNotFoundError(\n\t\t\t\t`BucketEncSessionKey is not defined for Permission ${pubOrExtPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`,\n\t\t\t)\n\t\t}\n\n\t\treturn decryptKey(bucketKey, neverNull(pubOrExtPermission.bucketEncSessionKey))\n\t}\n\n\tprivate async decryptWithPublicBucketWithoutAuthentication(\n\t\tbucketPermission: BucketPermission,\n\t\tinstance: Record<string, any>,\n\t\tpubOrExtPermission: Permission,\n\t\ttypeModel: TypeModel,\n\t): Promise<AesKey> {\n\t\tconst pubEncBucketKey = bucketPermission.pubEncBucketKey\n\t\tif (pubEncBucketKey == null) {\n\t\t\tthrow new SessionKeyNotFoundError(\n\t\t\t\t`PubEncBucketKey is not defined for BucketPermission ${bucketPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`,\n\t\t\t)\n\t\t}\n\t\tconst bucketEncSessionKey = pubOrExtPermission.bucketEncSessionKey\n\t\tif (bucketEncSessionKey == null) {\n\t\t\tthrow new SessionKeyNotFoundError(\n\t\t\t\t`BucketEncSessionKey is not defined for Permission ${pubOrExtPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`,\n\t\t\t)\n\t\t}\n\n\t\tconst { decryptedAesKey } = await this.asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(\n\t\t\tbucketPermission.group,\n\t\t\tNumber(bucketPermission.pubKeyVersion ?? 0),\n\t\t\tasCryptoProtoocolVersion(bucketPermission.protocolVersion),\n\t\t\tpubEncBucketKey,\n\t\t)\n\n\t\tconst sk = decryptKey(decryptedAesKey, bucketEncSessionKey)\n\n\t\tif (bucketPermission._ownerGroup) {\n\t\t\t// is not defined for some old AccountingInfos\n\t\t\tlet bucketPermissionOwnerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(neverNull(bucketPermission._ownerGroup)) // get current key for encrypting\n\t\t\tawait this.updateWithSymPermissionKey(typeModel, instance, pubOrExtPermission, bucketPermission, bucketPermissionOwnerGroupKey, sk).catch(\n\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\tconsole.log(\"w> could not find instance to update permission\")\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t\treturn sk\n\t}\n\n\t/**\n\t * Returns the session key for the provided service response:\n\t * * null, if the instance is unencrypted\n\t * * the decrypted _ownerPublicEncSessionKey, if it is available\n\t * @param instance The unencrypted (client-side) or encrypted (server-side) instance\n\t *\n\t */\n\tasync resolveServiceSessionKey(instance: Record<string, any>): Promise<Aes256Key | null> {\n\t\tif (instance._ownerPublicEncSessionKey) {\n\t\t\t// we assume the server uses the current key pair of the recipient\n\t\t\tconst keypair = await this.keyLoaderFacade.loadCurrentKeyPair(instance._ownerGroup)\n\t\t\t// we do not authenticate as we could remove data transfer type encryption altogether and only rely on tls\n\t\t\treturn (\n\t\t\t\tawait this.asymmetricCryptoFacade.decryptSymKeyWithKeyPair(\n\t\t\t\t\tkeypair.object,\n\t\t\t\t\tassertEnumValue(CryptoProtocolVersion, instance._publicCryptoProtocolVersion),\n\t\t\t\t\tbase64ToUint8Array(instance._ownerPublicEncSessionKey),\n\t\t\t\t)\n\t\t\t).decryptedAesKey\n\t\t}\n\t\treturn null\n\t}\n\n\t/**\n\t * Creates a new _ownerEncSessionKey and assigns it to the provided entity\n\t * the entity must already have an _ownerGroup\n\t * @returns the generated key\n\t */\n\tasync setNewOwnerEncSessionKey(model: TypeModel, entity: Record<string, any>, keyToEncryptSessionKey?: VersionedKey): Promise<AesKey | null> {\n\t\tif (!entity._ownerGroup) {\n\t\t\tthrow new Error(`no owner group set  ${JSON.stringify(entity)}`)\n\t\t}\n\n\t\tif (model.encrypted) {\n\t\t\tif (entity._ownerEncSessionKey) {\n\t\t\t\tthrow new Error(`ownerEncSessionKey already set ${JSON.stringify(entity)}`)\n\t\t\t}\n\n\t\t\tconst sessionKey = aes256RandomKey()\n\t\t\tconst effectiveKeyToEncryptSessionKey = keyToEncryptSessionKey ?? (await this.keyLoaderFacade.getCurrentSymGroupKey(entity._ownerGroup))\n\t\t\tconst encryptedSessionKey = encryptKeyWithVersionedKey(effectiveKeyToEncryptSessionKey, sessionKey)\n\t\t\tthis.setOwnerEncSessionKey(entity as Instance, encryptedSessionKey)\n\t\t\treturn sessionKey\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync encryptBucketKeyForInternalRecipient(\n\t\tsenderUserGroupId: Id,\n\t\tbucketKey: AesKey,\n\t\trecipientMailAddress: string,\n\t\tnotFoundRecipients: Array<string>,\n\t): Promise<InternalRecipientKeyData | SymEncInternalRecipientKeyData | null> {\n\t\tconst keyData = createPublicKeyGetIn({\n\t\t\tidentifier: recipientMailAddress,\n\t\t\tidentifierType: PublicKeyIdentifierType.MAIL_ADDRESS,\n\t\t\tversion: null,\n\t\t})\n\t\ttry {\n\t\t\tconst publicKeyGetOut = await this.serviceExecutor.get(PublicKeyService, keyData)\n\t\t\t// We do not create any key data in case there is one not found recipient, but we want to\n\t\t\t// collect ALL not found recipients when iterating a recipient list.\n\t\t\tif (notFoundRecipients.length !== 0) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tconst isExternalSender = this.userFacade.getUser()?.accountType === AccountType.EXTERNAL\n\t\t\t// we only encrypt symmetric as external sender if the recipient supports tuta-crypt.\n\t\t\t// Clients need to support symmetric decryption from external users. We can always encrypt symmetricly when old clients are deactivated that don't support tuta-crypt.\n\t\t\tif (publicKeyGetOut.pubKyberKey && isExternalSender) {\n\t\t\t\treturn this.createSymEncInternalRecipientKeyData(recipientMailAddress, bucketKey)\n\t\t\t} else {\n\t\t\t\treturn this.createPubEncInternalRecipientKeyData(bucketKey, recipientMailAddress, publicKeyGetOut, senderUserGroupId)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\tnotFoundRecipients.push(recipientMailAddress)\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof TooManyRequestsError) {\n\t\t\t\tthrow new RecipientNotResolvedError(\"\")\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async createPubEncInternalRecipientKeyData(bucketKey: AesKey, recipientMailAddress: string, publicKeyGetOut: PublicKeyGetOut, senderGroupId: Id) {\n\t\tconst recipientPublicKeys = convertToVersionedPublicKeys(publicKeyGetOut)\n\t\tconst pubEncBucketKey = await this.asymmetricCryptoFacade.asymEncryptSymKey(bucketKey, recipientPublicKeys, senderGroupId)\n\t\treturn createInternalRecipientKeyData({\n\t\t\tmailAddress: recipientMailAddress,\n\t\t\tpubEncBucketKey: pubEncBucketKey.pubEncSymKeyBytes,\n\t\t\trecipientKeyVersion: pubEncBucketKey.recipientKeyVersion.toString(),\n\t\t\tsenderKeyVersion: pubEncBucketKey.senderKeyVersion != null ? pubEncBucketKey.senderKeyVersion.toString() : null,\n\t\t\tprotocolVersion: pubEncBucketKey.cryptoProtocolVersion,\n\t\t})\n\t}\n\n\tprivate async createSymEncInternalRecipientKeyData(recipientMailAddress: string, bucketKey: AesKey) {\n\t\tconst keyGroup = this.userFacade.getGroupId(GroupType.Mail)\n\t\tconst externalMailGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(keyGroup)\n\t\treturn createSymEncInternalRecipientKeyData({\n\t\t\tmailAddress: recipientMailAddress,\n\t\t\tsymEncBucketKey: encryptKey(externalMailGroupKey.object, bucketKey),\n\t\t\tkeyGroup,\n\t\t\tsymKeyVersion: String(externalMailGroupKey.version),\n\t\t})\n\t}\n\n\t/**\n\t * Updates the given public permission with the given symmetric key for faster access if the client is the leader and otherwise does nothing.\n\t * @param typeModel The type model of the instance\n\t * @param instance The unencrypted (client-side) or encrypted (server-side) instance\n\t * @param permission The permission.\n\t * @param bucketPermission The bucket permission.\n\t * @param permissionOwnerGroupKey The symmetric group key for the owner group on the permission.\n\t * @param sessionKey The symmetric session key.\n\t */\n\tprivate async updateWithSymPermissionKey(\n\t\ttypeModel: TypeModel,\n\t\tinstance: Record<string, any>,\n\t\tpermission: Permission,\n\t\tbucketPermission: BucketPermission,\n\t\tpermissionOwnerGroupKey: VersionedKey,\n\t\tsessionKey: AesKey,\n\t): Promise<void> {\n\t\tif (!this.isLiteralInstance(instance) || !this.userFacade.isLeader()) {\n\t\t\t// do not update the session key in case of an unencrypted (client-side) instance\n\t\t\t// or in case we are not the leader client\n\t\t\treturn\n\t\t}\n\n\t\tif (!instance._ownerEncSessionKey && permission._ownerGroup === instance._ownerGroup) {\n\t\t\treturn this.updateOwnerEncSessionKey(typeModel, instance, permissionOwnerGroupKey, sessionKey)\n\t\t} else {\n\t\t\t// instances shared via permissions (e.g. body)\n\t\t\tconst encryptedKey = encryptKeyWithVersionedKey(permissionOwnerGroupKey, sessionKey)\n\t\t\tlet updateService = createUpdatePermissionKeyData({\n\t\t\t\townerKeyVersion: String(encryptedKey.encryptingKeyVersion),\n\t\t\t\townerEncSessionKey: encryptedKey.key,\n\t\t\t\tpermission: permission._id,\n\t\t\t\tbucketPermission: bucketPermission._id,\n\t\t\t})\n\t\t\tawait this.serviceExecutor.post(UpdatePermissionKeyService, updateService)\n\t\t}\n\t}\n\n\t/**\n\t * Resolves the ownerEncSessionKey of a mail. This might be needed if it wasn't updated yet\n\t * by the OwnerEncSessionKeysUpdateQueue but the file is already downloaded.\n\t * @param mainInstance the instance that has the bucketKey\n\t * @param childInstances the files that belong to the mainInstance\n\t */\n\tasync enforceSessionKeyUpdateIfNeeded(mainInstance: Record<string, any>, childInstances: readonly File[]): Promise<File[]> {\n\t\tif (!childInstances.some((f) => f._ownerEncSessionKey == null)) {\n\t\t\treturn childInstances.slice()\n\t\t}\n\t\tconst typeModel = await resolveTypeReference(mainInstance._type)\n\t\tconst outOfSyncInstances = childInstances.filter((f) => f._ownerEncSessionKey == null)\n\t\tif (mainInstance.bucketKey) {\n\t\t\t// invoke updateSessionKeys service in case a bucket key is still available\n\t\t\tconst bucketKey = await this.convertBucketKeyToInstanceIfNecessary(mainInstance.bucketKey)\n\t\t\tconst resolvedSessionKeys = await this.resolveWithBucketKey(bucketKey, mainInstance, typeModel)\n\t\t\tawait this.ownerEncSessionKeysUpdateQueue.postUpdateSessionKeysService(resolvedSessionKeys.instanceSessionKeys)\n\t\t} else {\n\t\t\tconsole.warn(\"files are out of sync refreshing\", outOfSyncInstances.map((f) => f._id).join(\", \"))\n\t\t}\n\t\tfor (const childInstance of outOfSyncInstances) {\n\t\t\tawait this.cache?.deleteFromCacheIfExists(FileTypeRef, getListId(childInstance), getElementId(childInstance))\n\t\t}\n\t\t// we have a caching entity client, so this re-inserts the deleted instances\n\t\treturn await this.entityClient.loadMultiple(\n\t\t\tFileTypeRef,\n\t\t\tgetListId(childInstances[0]),\n\t\t\tchildInstances.map((childInstance) => getElementId(childInstance)),\n\t\t)\n\t}\n\n\tprivate updateOwnerEncSessionKey(typeModel: TypeModel, instance: Record<string, any>, ownerGroupKey: VersionedKey, sessionKey: AesKey): Promise<void> {\n\t\tthis.setOwnerEncSessionKeyUnmapped(instance as UnmappedOwnerGroupInstance, encryptKeyWithVersionedKey(ownerGroupKey, sessionKey))\n\t\t// we have to call the rest client directly because instance is still the encrypted server-side version\n\t\tconst path = typeRefToPath(new TypeRef(typeModel.app, typeModel.name)) + \"/\" + (instance._id instanceof Array ? instance._id.join(\"/\") : instance._id)\n\t\tconst headers = this.userFacade.createAuthHeaders()\n\t\theaders.v = typeModel.version\n\t\treturn this.restClient\n\t\t\t.request(path, HttpMethod.PUT, {\n\t\t\t\theaders,\n\t\t\t\tbody: JSON.stringify(instance),\n\t\t\t\tqueryParams: { updateOwnerEncSessionKey: \"true\" },\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(PayloadTooLargeError, (e) => {\n\t\t\t\t\tconsole.log(\"Could not update owner enc session key - PayloadTooLargeError\", e)\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\tprivate getElementIdFromInstance(instance: Record<string, any>): Id {\n\t\tif (typeof instance._id === \"string\") {\n\t\t\treturn instance._id\n\t\t} else {\n\t\t\tconst idTuple = instance._id as IdTuple\n\t\t\treturn elementIdPart(idTuple)\n\t\t}\n\t}\n}\n\nif (!(\"toJSON\" in Error.prototype)) {\n\tObject.defineProperty(Error.prototype as any, \"toJSON\", {\n\t\tvalue: function () {\n\t\t\tconst alt: Record<string, any> = {}\n\t\t\tfor (let key of Object.getOwnPropertyNames(this)) {\n\t\t\t\talt[key] = this[key]\n\t\t\t}\n\t\t\treturn alt\n\t\t},\n\t\tconfigurable: true,\n\t\twritable: true,\n\t})\n}\n","import { resolveTypeReference } from \"../../common/EntityFunctions\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport type { Base64 } from \"@tutao/tutanota-utils\"\nimport {\n\tassertNotNull,\n\tbase64ToBase64Url,\n\tbase64ToUint8Array,\n\tdowncast,\n\tpromiseMap,\n\tstringToUtf8Uint8Array,\n\tTypeRef,\n\tuint8ArrayToBase64,\n\tutf8Uint8ArrayToString,\n} from \"@tutao/tutanota-utils\"\nimport { AssociationType, Cardinality, Type, ValueType } from \"../../common/EntityConstants.js\"\nimport { compress, uncompress } from \"../Compression\"\nimport type { ModelValue, TypeModel } from \"../../common/EntityTypes\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport { aesDecrypt, aesEncrypt, AesKey, ENABLE_MAC, IV_BYTE_LENGTH, random } from \"@tutao/tutanota-crypto\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\n\nassertWorkerOrNode()\n\nexport class InstanceMapper {\n\t/**\n\t * Decrypts an object literal as received from the DB and maps it to an entity class (e.g. Mail)\n\t * @param model The TypeModel of the instance\n\t * @param instance The object literal as received from the DB\n\t * @param sk The session key, must be provided for encrypted instances\n\t * @returns The decrypted and mapped instance\n\t */\n\tdecryptAndMapToInstance<T>(model: TypeModel, instance: Record<string, any>, sk: AesKey | null): Promise<T> {\n\t\tlet decrypted: any = {\n\t\t\t_type: new TypeRef(model.app, model.name),\n\t\t}\n\n\t\tfor (let key of Object.keys(model.values)) {\n\t\t\tlet valueType = model.values[key]\n\t\t\tlet value = instance[key]\n\n\t\t\ttry {\n\t\t\t\tdecrypted[key] = decryptValue(key, valueType, value, sk)\n\t\t\t} catch (e) {\n\t\t\t\tif (decrypted._errors == null) {\n\t\t\t\t\tdecrypted._errors = {}\n\t\t\t\t}\n\n\t\t\t\tdecrypted._errors[key] = JSON.stringify(e)\n\t\t\t\tconsole.log(\"error when decrypting value on type:\", `[${model.app},${model.name}]`, \"key:\", key, e)\n\t\t\t} finally {\n\t\t\t\tif (valueType.encrypted) {\n\t\t\t\t\tif (valueType.final) {\n\t\t\t\t\t\t// we have to store the encrypted value to be able to restore it when updating the instance. this is not needed for data transfer types, but it does not hurt\n\t\t\t\t\t\tdecrypted[\"_finalEncrypted_\" + key] = value\n\t\t\t\t\t} else if (value === \"\") {\n\t\t\t\t\t\t// we have to store the default value to make sure that updates do not cause more storage use\n\t\t\t\t\t\tdecrypted[\"_defaultEncrypted_\" + key] = decrypted[key]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn promiseMap(Object.keys(model.associations), async (associationName) => {\n\t\t\tif (model.associations[associationName].type === AssociationType.Aggregation) {\n\t\t\t\tconst dependency = model.associations[associationName].dependency\n\t\t\t\tconst aggregateTypeModel = await resolveTypeReference(new TypeRef(dependency || model.app, model.associations[associationName].refType))\n\t\t\t\tlet aggregation = model.associations[associationName]\n\n\t\t\t\tif (aggregation.cardinality === Cardinality.ZeroOrOne && instance[associationName] == null) {\n\t\t\t\t\tdecrypted[associationName] = null\n\t\t\t\t} else if (instance[associationName] == null) {\n\t\t\t\t\tthrow new ProgrammingError(`Undefined aggregation ${model.name}:${associationName}`)\n\t\t\t\t} else if (aggregation.cardinality === Cardinality.Any) {\n\t\t\t\t\treturn promiseMap(instance[associationName], (aggregate) => {\n\t\t\t\t\t\treturn this.decryptAndMapToInstance(aggregateTypeModel, downcast<Record<string, any>>(aggregate), sk)\n\t\t\t\t\t}).then((decryptedAggregates) => {\n\t\t\t\t\t\tdecrypted[associationName] = decryptedAggregates\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\treturn this.decryptAndMapToInstance(aggregateTypeModel, instance[associationName], sk).then((decryptedAggregate) => {\n\t\t\t\t\t\tdecrypted[associationName] = decryptedAggregate\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdecrypted[associationName] = instance[associationName]\n\t\t\t}\n\t\t}).then(() => {\n\t\t\treturn decrypted\n\t\t})\n\t}\n\n\tencryptAndMapToLiteral<T>(model: TypeModel, instance: T, sk: AesKey | null): Promise<Record<string, unknown>> {\n\t\tif (model.encrypted && sk == null) {\n\t\t\tthrow new ProgrammingError(`Encrypting ${model.app}/${model.name} requires a session key!`)\n\t\t}\n\t\tlet encrypted: Record<string, unknown> = {}\n\t\tlet i = instance as any\n\n\t\tfor (let key of Object.keys(model.values)) {\n\t\t\tlet valueType = model.values[key]\n\t\t\tlet value = i[key]\n\n\t\t\tlet encryptedValue\n\t\t\t// restore the original encrypted value if it exists. it does not exist if this is a data transfer type or a newly created entity. check against null explicitely because \"\" is allowed\n\t\t\tif (valueType.encrypted && valueType.final && i[\"_finalEncrypted_\" + key] != null) {\n\t\t\t\tencryptedValue = i[\"_finalEncrypted_\" + key]\n\t\t\t} else if (valueType.encrypted && (i[\"_finalIvs\"]?.[key] as Uint8Array | null)?.length === 0 && isDefaultValue(valueType.type, value)) {\n\t\t\t\t// restore the default encrypted value because it has not changed\n\t\t\t\t// note: this brunch must be checked *before* the one which reuses IVs as this one checks\n\t\t\t\t// the length.\n\t\t\t\tencryptedValue = \"\"\n\t\t\t} else if (valueType.encrypted && valueType.final && i[\"_finalIvs\"]?.[key] != null) {\n\t\t\t\tconst finalIv = i[\"_finalIvs\"][key]\n\t\t\t\tencryptedValue = encryptValue(key, valueType, value, sk, finalIv)\n\t\t\t} else if (valueType.encrypted && i[\"_defaultEncrypted_\" + key] === value) {\n\t\t\t\t// restore the default encrypted value because it has not changed\n\t\t\t\tencryptedValue = \"\"\n\t\t\t} else {\n\t\t\t\tencryptedValue = encryptValue(key, valueType, value, sk)\n\t\t\t}\n\t\t\tencrypted[key] = encryptedValue\n\t\t}\n\n\t\tif (model.type === Type.Aggregated && !encrypted._id) {\n\t\t\tencrypted._id = base64ToBase64Url(uint8ArrayToBase64(random.generateRandomData(4)))\n\t\t}\n\n\t\treturn promiseMap(Object.keys(model.associations), async (associationName) => {\n\t\t\tif (model.associations[associationName].type === AssociationType.Aggregation) {\n\t\t\t\tconst dependency = model.associations[associationName].dependency\n\t\t\t\tconst aggregateTypeModel = await resolveTypeReference(new TypeRef(dependency || model.app, model.associations[associationName].refType))\n\t\t\t\tlet aggregation = model.associations[associationName]\n\t\t\t\tif (aggregation.cardinality === Cardinality.ZeroOrOne && i[associationName] == null) {\n\t\t\t\t\tencrypted[associationName] = null\n\t\t\t\t} else if (i[associationName] == null) {\n\t\t\t\t\tthrow new ProgrammingError(`Undefined attribute ${model.name}:${associationName}`)\n\t\t\t\t} else if (aggregation.cardinality === Cardinality.Any) {\n\t\t\t\t\treturn promiseMap(i[associationName], (aggregate) => {\n\t\t\t\t\t\treturn this.encryptAndMapToLiteral(aggregateTypeModel, aggregate, sk)\n\t\t\t\t\t}).then((encryptedAggregates) => {\n\t\t\t\t\t\tencrypted[associationName] = encryptedAggregates\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\treturn this.encryptAndMapToLiteral(aggregateTypeModel, i[associationName], sk).then((encryptedAggregate) => {\n\t\t\t\t\t\tencrypted[associationName] = encryptedAggregate\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tencrypted[associationName] = i[associationName]\n\t\t\t}\n\t\t}).then(() => {\n\t\t\treturn encrypted\n\t\t})\n\t}\n}\n\n// Exported for testing\nexport function encryptValue(\n\tvalueName: string,\n\tvalueType: ModelValue,\n\tvalue: any,\n\tsk: AesKey | null,\n\tiv: Uint8Array = random.generateRandomData(IV_BYTE_LENGTH),\n): string | Base64 | null {\n\tif (valueName === \"_id\" || valueName === \"_permissions\") {\n\t\treturn value\n\t} else if (value == null) {\n\t\tif (valueType.cardinality === Cardinality.ZeroOrOne) {\n\t\t\treturn null\n\t\t} else {\n\t\t\tthrow new ProgrammingError(`Value ${valueName} with cardinality ONE can not be null`)\n\t\t}\n\t} else if (valueType.encrypted) {\n\t\tlet bytes = value\n\n\t\tif (valueType.type !== ValueType.Bytes) {\n\t\t\tconst dbType = assertNotNull(convertJsToDbType(valueType.type, value))\n\t\t\tbytes = typeof dbType === \"string\" ? stringToUtf8Uint8Array(dbType) : dbType\n\t\t}\n\n\t\treturn uint8ArrayToBase64(aesEncrypt(assertNotNull(sk), bytes, iv, true, ENABLE_MAC))\n\t} else {\n\t\tconst dbType = convertJsToDbType(valueType.type, value)\n\n\t\tif (typeof dbType === \"string\") {\n\t\t\treturn dbType\n\t\t} else {\n\t\t\treturn uint8ArrayToBase64(dbType)\n\t\t}\n\t}\n}\n\n// Exported for testing\nexport function decryptValue(valueName: string, valueType: ModelValue, value: (Base64 | null) | string, sk: AesKey | null): any {\n\tif (value == null) {\n\t\tif (valueType.cardinality === Cardinality.ZeroOrOne) {\n\t\t\treturn null\n\t\t} else {\n\t\t\tthrow new ProgrammingError(`Value ${valueName} with cardinality ONE can not be null`)\n\t\t}\n\t} else if (valueType.cardinality === Cardinality.One && value === \"\") {\n\t\treturn valueToDefault(valueType.type) // Migration for values added after the Type has been defined initially\n\t} else if (valueType.encrypted) {\n\t\tif (sk == null) {\n\t\t\tthrow new CryptoError(\"session key is null, but value is encrypted. valueName: \" + valueName + \" valueType: \" + valueType)\n\t\t}\n\t\tlet decryptedBytes = aesDecrypt(sk, base64ToUint8Array(value))\n\n\t\tif (valueType.type === ValueType.Bytes) {\n\t\t\treturn decryptedBytes\n\t\t} else if (valueType.type === ValueType.CompressedString) {\n\t\t\treturn decompressString(decryptedBytes)\n\t\t} else {\n\t\t\treturn convertDbToJsType(valueType.type, utf8Uint8ArrayToString(decryptedBytes))\n\t\t}\n\t} else {\n\t\treturn convertDbToJsType(valueType.type, value)\n\t}\n}\n\n/**\n * Returns bytes when the type === Bytes or type === CompressedString, otherwise returns a string\n * @param type\n * @param value\n * @returns {string|string|NodeJS.Global.Uint8Array|*}\n */\nfunction convertJsToDbType(type: Values<typeof ValueType>, value: any): Uint8Array | string {\n\tif (type === ValueType.Bytes && value != null) {\n\t\treturn value\n\t} else if (type === ValueType.Boolean) {\n\t\treturn value ? \"1\" : \"0\"\n\t} else if (type === ValueType.Date) {\n\t\treturn value.getTime().toString()\n\t} else if (type === ValueType.CompressedString) {\n\t\treturn compressString(value)\n\t} else {\n\t\treturn value\n\t}\n}\n\nfunction convertDbToJsType(type: Values<typeof ValueType>, value: Base64 | string): any {\n\tif (type === ValueType.Bytes) {\n\t\treturn base64ToUint8Array(value as any)\n\t} else if (type === ValueType.Boolean) {\n\t\treturn value !== \"0\"\n\t} else if (type === ValueType.Date) {\n\t\treturn new Date(parseInt(value))\n\t} else if (type === ValueType.CompressedString) {\n\t\treturn decompressString(base64ToUint8Array(value))\n\t} else {\n\t\treturn value\n\t}\n}\n\nfunction compressString(uncompressed: string): Uint8Array {\n\treturn compress(stringToUtf8Uint8Array(uncompressed))\n}\n\nfunction decompressString(compressed: Uint8Array): string {\n\tif (compressed.length === 0) {\n\t\treturn \"\"\n\t}\n\n\tconst output = uncompress(compressed)\n\treturn utf8Uint8ArrayToString(output)\n}\n\nfunction valueToDefault(type: Values<typeof ValueType>): Date | Uint8Array | string | boolean {\n\tswitch (type) {\n\t\tcase ValueType.String:\n\t\t\treturn \"\"\n\n\t\tcase ValueType.Number:\n\t\t\treturn \"0\"\n\n\t\tcase ValueType.Bytes:\n\t\t\treturn new Uint8Array(0)\n\n\t\tcase ValueType.Date:\n\t\t\treturn new Date(0)\n\n\t\tcase ValueType.Boolean:\n\t\t\treturn false\n\n\t\tcase ValueType.CompressedString:\n\t\t\treturn \"\"\n\n\t\tdefault:\n\t\t\tthrow new ProgrammingError(`${type} is not a valid value type`)\n\t}\n}\n\nfunction isDefaultValue(type: Values<typeof ValueType>, value: unknown): boolean {\n\tswitch (type) {\n\t\tcase ValueType.String:\n\t\t\treturn value === \"\"\n\n\t\tcase ValueType.Number:\n\t\t\treturn value === \"0\"\n\n\t\tcase ValueType.Bytes:\n\t\t\treturn (value as Uint8Array).length === 0\n\n\t\tcase ValueType.Date:\n\t\t\treturn (value as Date).getTime() === 0\n\n\t\tcase ValueType.Boolean:\n\t\t\treturn value === false\n\n\t\tcase ValueType.CompressedString:\n\t\t\treturn value === \"\"\n\n\t\tdefault:\n\t\t\tthrow new ProgrammingError(`${type} is not a valid value type`)\n\t}\n}\n","import { QueuedBatch } from \"../EventQueue.js\"\nimport { EntityUpdate } from \"../../entities/sys/TypeRefs.js\"\nimport { ListElementEntity, SomeEntity } from \"../../common/EntityTypes\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { TypeRef } from \"@tutao/tutanota-utils\"\nimport { EntityRestCache } from \"./DefaultEntityRestCache.js\"\nimport { EntityRestClientLoadOptions } from \"./EntityRestClient.js\"\n\nexport class AdminClientDummyEntityRestCache implements EntityRestCache {\n\tasync entityEventsReceived(batch: QueuedBatch): Promise<Array<EntityUpdate>> {\n\t\treturn batch.events\n\t}\n\n\tasync erase<T extends SomeEntity>(instance: T): Promise<void> {\n\t\tthrow new ProgrammingError(\"erase not implemented\")\n\t}\n\n\tasync load<T extends SomeEntity>(_typeRef: TypeRef<T>, _id: PropertyType<T, \"_id\">, _opts: EntityRestClientLoadOptions): Promise<T> {\n\t\tthrow new ProgrammingError(\"load not implemented\")\n\t}\n\n\tasync loadMultiple<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, elementIds: Array<Id>): Promise<Array<T>> {\n\t\tthrow new ProgrammingError(\"loadMultiple not implemented\")\n\t}\n\n\tasync loadRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, start: Id, count: number, reverse: boolean): Promise<T[]> {\n\t\tthrow new ProgrammingError(\"loadRange not implemented\")\n\t}\n\n\tasync purgeStorage(): Promise<void> {\n\t\treturn\n\t}\n\n\tasync setup<T extends SomeEntity>(listId: Id | null, instance: T, extraHeaders?: Dict): Promise<Id> {\n\t\tthrow new ProgrammingError(\"setup not implemented\")\n\t}\n\n\tasync setupMultiple<T extends SomeEntity>(listId: Id | null, instances: Array<T>): Promise<Array<Id>> {\n\t\tthrow new ProgrammingError(\"setupMultiple not implemented\")\n\t}\n\n\tasync update<T extends SomeEntity>(instance: T): Promise<void> {\n\t\tthrow new ProgrammingError(\"update not implemented\")\n\t}\n\n\tasync getLastEntityEventBatchForGroup(groupId: Id): Promise<Id | null> {\n\t\treturn null\n\t}\n\n\tasync setLastEntityEventBatchForGroup(groupId: Id, batchId: Id): Promise<void> {\n\t\treturn\n\t}\n\n\tasync recordSyncTime(): Promise<void> {\n\t\treturn\n\t}\n\n\tasync timeSinceLastSyncMs(): Promise<number | null> {\n\t\treturn null\n\t}\n\n\tasync isOutOfSync(): Promise<boolean> {\n\t\treturn false\n\t}\n}\n","import { Thunk } from \"@tutao/tutanota-utils\"\nimport { Scheduler } from \"../../common/utils/Scheduler.js\"\nimport { DateProvider } from \"../../common/DateProvider.js\"\n\n// exported for testing\n/** How often do we check for sleep. */\nexport const CHECK_INTERVAL = 5000\n/** How much time should have passed for us to assume that the app was suspended. */\nexport const SLEEP_INTERVAL = 15000\n\ninterface ScheduledState {\n\tscheduledId: number\n\tlastTime: number\n\treadonly onSleep: Thunk\n}\n\n/**\n * Class for detecting suspension state of the app/device.\n * When the device is entering the sleep mode the browser would pause the page. For most of the app it looks like no time has passed at all but when there\n * are external factors e.g. websocket connection we might need to know whether it happens.\n *\n * We detect such situation by scheduling periodic timer and measuring the time in between.\n *\n * Currently is only capable of having one sleep action at a time.\n */\nexport class SleepDetector {\n\tprivate scheduledState: ScheduledState | null = null\n\n\tconstructor(private readonly scheduler: Scheduler, private readonly dateProvider: DateProvider) {}\n\n\tstart(onSleep: Thunk): void {\n\t\tthis.stop()\n\t\tthis.scheduledState = {\n\t\t\tscheduledId: this.scheduler.schedulePeriodic(() => this.check(), CHECK_INTERVAL),\n\t\t\tlastTime: this.dateProvider.now(),\n\t\t\tonSleep,\n\t\t}\n\t}\n\n\tprivate check() {\n\t\tif (this.scheduledState == null) return\n\n\t\tconst now = this.dateProvider.now()\n\t\tif (now - this.scheduledState.lastTime > SLEEP_INTERVAL) {\n\t\t\tthis.scheduledState.onSleep()\n\t\t}\n\t\tthis.scheduledState.lastTime = now\n\t}\n\n\tstop(): void {\n\t\tif (this.scheduledState) {\n\t\t\tthis.scheduler.unschedulePeriodic(this.scheduledState.scheduledId)\n\t\t\tthis.scheduledState = null\n\t\t}\n\t}\n}\n","import { BlobElementEntity, ElementEntity, ListElementEntity, SomeEntity, TypeModel } from \"../../common/EntityTypes.js\"\nimport { EntityRestClient, typeRefToPath } from \"./EntityRestClient.js\"\nimport { firstBiggerThanSecond } from \"../../common/utils/EntityUtils.js\"\nimport { CacheStorage, expandId, ExposedCacheStorage, LastUpdateTime } from \"./DefaultEntityRestCache.js\"\nimport { assertNotNull, clone, getFromMap, remove, TypeRef } from \"@tutao/tutanota-utils\"\nimport { CustomCacheHandlerMap } from \"./CustomCacheHandler.js\"\nimport { resolveTypeReference } from \"../../common/EntityFunctions.js\"\nimport { Type as TypeId } from \"../../common/EntityConstants.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { customIdToBase64Url, ensureBase64Ext } from \"../offline/OfflineStorage.js\"\n\n/** Cache for a single list. */\ntype ListCache = {\n\t/** All entities loaded inside the range. */\n\tallRange: Id[]\n\tlowerRangeId: Id\n\tupperRangeId: Id\n\t/** All the entities loaded, inside or outside the range (e.g. load for a single entity). */\n\telements: Map<Id, ListElementEntity>\n}\n\n/** Map from list id to list cache. */\ntype ListTypeCache = Map<Id, ListCache>\n\ntype BlobElementCache = {\n\t/** All the entities loaded, inside or outside the range (e.g. load for a single entity). */\n\telements: Map<Id, BlobElementEntity>\n}\n\n/** Map from list id to list cache. */\ntype BlobElementTypeCache = Map<Id, BlobElementCache>\n\nexport interface EphemeralStorageInitArgs {\n\tuserId: Id\n}\n\nexport class EphemeralCacheStorage implements CacheStorage {\n\t/** Path to id to entity map. */\n\tprivate readonly entities: Map<string, Map<Id, ElementEntity>> = new Map()\n\tprivate readonly lists: Map<string, ListTypeCache> = new Map()\n\tprivate readonly blobEntities: Map<string, BlobElementTypeCache> = new Map()\n\tprivate readonly customCacheHandlerMap: CustomCacheHandlerMap = new CustomCacheHandlerMap()\n\tprivate lastUpdateTime: number | null = null\n\tprivate userId: Id | null = null\n\tprivate lastBatchIdPerGroup = new Map<Id, Id>()\n\n\tinit({ userId }: EphemeralStorageInitArgs) {\n\t\tthis.userId = userId\n\t}\n\n\tdeinit() {\n\t\tthis.userId = null\n\t\tthis.entities.clear()\n\t\tthis.lists.clear()\n\t\tthis.blobEntities.clear()\n\t\tthis.lastUpdateTime = null\n\t\tthis.lastBatchIdPerGroup.clear()\n\t}\n\n\t/**\n\t * Get a given entity from the cache, expects that you have already checked for existence\n\t */\n\tasync get<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, elementId: Id): Promise<T | null> {\n\t\t// We downcast because we can't prove that map has correct entity on the type level\n\t\tconst path = typeRefToPath(typeRef)\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\telementId = ensureBase64Ext(typeModel, elementId)\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element:\n\t\t\t\treturn clone((this.entities.get(path)?.get(elementId) as T | undefined) ?? null)\n\t\t\tcase TypeId.ListElement:\n\t\t\t\treturn clone((this.lists.get(path)?.get(assertNotNull(listId))?.elements.get(elementId) as T | undefined) ?? null)\n\t\t\tcase TypeId.BlobElement:\n\t\t\t\treturn clone((this.blobEntities.get(path)?.get(assertNotNull(listId))?.elements.get(elementId) as T | undefined) ?? null)\n\t\t\tdefault:\n\t\t\t\tthrow new ProgrammingError(\"must be a persistent type\")\n\t\t}\n\t}\n\n\tasync deleteIfExists<T>(typeRef: TypeRef<T>, listId: Id | null, elementId: Id): Promise<void> {\n\t\tconst path = typeRefToPath(typeRef)\n\t\tlet typeModel: TypeModel\n\t\ttypeModel = await resolveTypeReference(typeRef)\n\t\telementId = ensureBase64Ext(typeModel, elementId)\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element:\n\t\t\t\tthis.entities.get(path)?.delete(elementId)\n\t\t\t\tbreak\n\t\t\tcase TypeId.ListElement: {\n\t\t\t\tconst cache = this.lists.get(path)?.get(assertNotNull(listId))\n\t\t\t\tif (cache != null) {\n\t\t\t\t\tcache.elements.delete(elementId)\n\t\t\t\t\tremove(cache.allRange, elementId)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase TypeId.BlobElement:\n\t\t\t\tthis.blobEntities.get(path)?.get(assertNotNull(listId))?.elements.delete(elementId)\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new ProgrammingError(\"must be a persistent type\")\n\t\t}\n\t}\n\n\tprivate addElementEntity<T extends ElementEntity>(typeRef: TypeRef<T>, id: Id, entity: T) {\n\t\tgetFromMap(this.entities, typeRefToPath(typeRef), () => new Map()).set(id, entity)\n\t}\n\n\tasync isElementIdInCacheRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, elementId: Id): Promise<boolean> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\telementId = ensureBase64Ext(typeModel, elementId)\n\n\t\tconst cache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\t\treturn cache != null && !firstBiggerThanSecond(elementId, cache.upperRangeId) && !firstBiggerThanSecond(cache.lowerRangeId, elementId)\n\t}\n\n\tasync put(originalEntity: SomeEntity): Promise<void> {\n\t\tconst entity = clone(originalEntity)\n\t\tconst typeRef = entity._type\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tlet { listId, elementId } = expandId(originalEntity._id)\n\t\telementId = ensureBase64Ext(typeModel, elementId)\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element: {\n\t\t\t\tconst elementEntity = entity as ElementEntity\n\t\t\t\tthis.addElementEntity(elementEntity._type, elementId, elementEntity)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase TypeId.ListElement: {\n\t\t\t\tconst listElementEntity = entity as ListElementEntity\n\t\t\t\tconst listElementTypeRef = typeRef as TypeRef<ListElementEntity>\n\t\t\t\tlistId = listId as Id\n\t\t\t\tawait this.putListElement(listElementTypeRef, listId, elementId, listElementEntity)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase TypeId.BlobElement: {\n\t\t\t\tconst blobElementEntity = entity as BlobElementEntity\n\t\t\t\tconst blobTypeRef = typeRef as TypeRef<BlobElementEntity>\n\t\t\t\tlistId = listId as Id\n\t\t\t\tawait this.putBlobElement(blobTypeRef, listId, elementId, blobElementEntity)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new ProgrammingError(\"must be a persistent type\")\n\t\t}\n\t}\n\n\tprivate async putBlobElement(typeRef: TypeRef<BlobElementEntity>, listId: Id, elementId: Id, entity: BlobElementEntity) {\n\t\tconst cache = this.blobEntities.get(typeRefToPath(typeRef))?.get(listId)\n\t\tif (cache == null) {\n\t\t\t// first element in this list\n\t\t\tconst newCache = {\n\t\t\t\telements: new Map([[elementId, entity]]),\n\t\t\t}\n\t\t\tgetFromMap(this.blobEntities, typeRefToPath(typeRef), () => new Map()).set(listId, newCache)\n\t\t} else {\n\t\t\t// if the element already exists in the cache, overwrite it\n\t\t\tcache.elements.set(elementId, entity)\n\t\t}\n\t}\n\n\t/** prcondition: elementId is converted to base64ext if necessary */\n\tprivate async putListElement(typeRef: TypeRef<ListElementEntity>, listId: Id, elementId: Id, entity: ListElementEntity) {\n\t\tconst cache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\t\tif (cache == null) {\n\t\t\t// first element in this list\n\t\t\tconst newCache = {\n\t\t\t\tallRange: [elementId],\n\t\t\t\tlowerRangeId: elementId,\n\t\t\t\tupperRangeId: elementId,\n\t\t\t\telements: new Map([[elementId, entity]]),\n\t\t\t}\n\t\t\tgetFromMap(this.lists, typeRefToPath(typeRef), () => new Map()).set(listId, newCache)\n\t\t} else {\n\t\t\t// if the element already exists in the cache, overwrite it\n\t\t\t// add new element to existing list if necessary\n\t\t\tcache.elements.set(elementId, entity)\n\t\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\t\tif (await this.isElementIdInCacheRange(typeRef, listId, customIdToBase64Url(typeModel, elementId))) {\n\t\t\t\tthis.insertIntoRange(cache.allRange, elementId)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** precondition: elementId is converted to base64ext if necessary */\n\tprivate insertIntoRange(allRange: Array<Id>, elementId: Id) {\n\t\tfor (let i = 0; i < allRange.length; i++) {\n\t\t\tconst rangeElement = allRange[i]\n\t\t\tif (firstBiggerThanSecond(rangeElement, elementId)) {\n\t\t\t\tallRange.splice(i, 0, elementId)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (rangeElement === elementId) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tallRange.push(elementId)\n\t}\n\n\tasync provideFromRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, startElementId: Id, count: number, reverse: boolean): Promise<T[]> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tstartElementId = ensureBase64Ext(typeModel, startElementId)\n\n\t\tconst listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\n\t\tif (listCache == null) {\n\t\t\treturn []\n\t\t}\n\n\t\tlet range = listCache.allRange\n\t\tlet ids: Id[] = []\n\t\tif (reverse) {\n\t\t\tlet i\n\t\t\tfor (i = range.length - 1; i >= 0; i--) {\n\t\t\t\tif (firstBiggerThanSecond(startElementId, range[i])) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= 0) {\n\t\t\t\tlet startIndex = i + 1 - count\n\t\t\t\tif (startIndex < 0) {\n\t\t\t\t\t// startElementId index may be negative if more elements have been requested than available when getting elements reverse.\n\t\t\t\t\tstartIndex = 0\n\t\t\t\t}\n\t\t\t\tids = range.slice(startIndex, i + 1)\n\t\t\t\tids.reverse()\n\t\t\t} else {\n\t\t\t\tids = []\n\t\t\t}\n\t\t} else {\n\t\t\tconst i = range.findIndex((id) => firstBiggerThanSecond(id, startElementId))\n\t\t\tids = range.slice(i, i + count)\n\t\t}\n\t\tlet result: T[] = []\n\t\tfor (let a = 0; a < ids.length; a++) {\n\t\t\tresult.push(clone(listCache.elements.get(ids[a]) as T))\n\t\t}\n\t\treturn result\n\t}\n\n\tasync provideMultiple<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, elementIds: Id[]): Promise<Array<T>> {\n\t\tconst listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\telementIds = elementIds.map((el) => ensureBase64Ext(typeModel, el))\n\n\t\tif (listCache == null) {\n\t\t\treturn []\n\t\t}\n\t\tlet result: T[] = []\n\t\tfor (let a = 0; a < elementIds.length; a++) {\n\t\t\tresult.push(clone(listCache.elements.get(elementIds[a]) as T))\n\t\t}\n\t\treturn result\n\t}\n\n\tasync getRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<{ lower: Id; upper: Id } | null> {\n\t\tconst listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\n\t\tif (listCache == null) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\treturn {\n\t\t\tlower: customIdToBase64Url(typeModel, listCache.lowerRangeId),\n\t\t\tupper: customIdToBase64Url(typeModel, listCache.upperRangeId),\n\t\t}\n\t}\n\n\tasync setUpperRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, upperId: Id): Promise<void> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tupperId = ensureBase64Ext(typeModel, upperId)\n\t\tconst listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\t\tif (listCache == null) {\n\t\t\tthrow new Error(\"list does not exist\")\n\t\t}\n\t\tlistCache.upperRangeId = upperId\n\t}\n\n\tasync setLowerRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, lowerId: Id): Promise<void> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tlowerId = ensureBase64Ext(typeModel, lowerId)\n\t\tconst listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\t\tif (listCache == null) {\n\t\t\tthrow new Error(\"list does not exist\")\n\t\t}\n\t\tlistCache.lowerRangeId = lowerId\n\t}\n\n\t/**\n\t * Creates a new list cache if there is none. Resets everything but elements.\n\t * @param typeRef\n\t * @param listId\n\t * @param lower\n\t * @param upper\n\t */\n\tasync setNewRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, lower: Id, upper: Id): Promise<void> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tlower = ensureBase64Ext(typeModel, lower)\n\t\tupper = ensureBase64Ext(typeModel, upper)\n\n\t\tconst listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\t\tif (listCache == null) {\n\t\t\tgetFromMap(this.lists, typeRefToPath(typeRef), () => new Map()).set(listId, {\n\t\t\t\tallRange: [],\n\t\t\t\tlowerRangeId: lower,\n\t\t\t\tupperRangeId: upper,\n\t\t\t\telements: new Map(),\n\t\t\t})\n\t\t} else {\n\t\t\tlistCache.lowerRangeId = lower\n\t\t\tlistCache.upperRangeId = upper\n\t\t\tlistCache.allRange = []\n\t\t}\n\t}\n\n\tasync getIdsInRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<Id>> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\treturn (\n\t\t\tthis.lists\n\t\t\t\t.get(typeRefToPath(typeRef))\n\t\t\t\t?.get(listId)\n\t\t\t\t?.allRange.map((elementId) => {\n\t\t\t\t\treturn customIdToBase64Url(typeModel, elementId)\n\t\t\t\t}) ?? []\n\t\t)\n\t}\n\n\tasync getLastBatchIdForGroup(groupId: Id): Promise<Id | null> {\n\t\treturn this.lastBatchIdPerGroup.get(groupId) ?? null\n\t}\n\n\tasync putLastBatchIdForGroup(groupId: Id, batchId: Id): Promise<void> {\n\t\tthis.lastBatchIdPerGroup.set(groupId, batchId)\n\t}\n\n\tpurgeStorage(): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n\n\tasync getLastUpdateTime(): Promise<LastUpdateTime> {\n\t\treturn this.lastUpdateTime ? { type: \"recorded\", time: this.lastUpdateTime } : { type: \"never\" }\n\t}\n\n\tasync putLastUpdateTime(value: number): Promise<void> {\n\t\tthis.lastUpdateTime = value\n\t}\n\n\tasync getWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<T>> {\n\t\tconst listCache = this.lists.get(typeRefToPath(typeRef))?.get(listId)\n\n\t\tif (listCache == null) {\n\t\t\treturn []\n\t\t}\n\n\t\treturn listCache.allRange.map((id) => clone(listCache.elements.get(id) as T))\n\t}\n\n\tgetCustomCacheHandlerMap(entityRestClient: EntityRestClient): CustomCacheHandlerMap {\n\t\treturn this.customCacheHandlerMap\n\t}\n\n\tgetUserId(): Id {\n\t\treturn assertNotNull(this.userId, \"No user id, not initialized?\")\n\t}\n\n\tasync deleteAllOwnedBy(owner: Id): Promise<void> {\n\t\tfor (const typeMap of this.entities.values()) {\n\t\t\tfor (const [id, entity] of typeMap.entries()) {\n\t\t\t\tif (entity._ownerGroup === owner) {\n\t\t\t\t\ttypeMap.delete(id)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cacheForType of this.lists.values()) {\n\t\t\tthis.deleteAllOwnedByFromCache(cacheForType, owner)\n\t\t}\n\t\tfor (const cacheForType of this.blobEntities.values()) {\n\t\t\tthis.deleteAllOwnedByFromCache(cacheForType, owner)\n\t\t}\n\t\tthis.lastBatchIdPerGroup.delete(owner)\n\t}\n\n\tasync deleteWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<void> {\n\t\tthis.lists.get(typeRef.type)?.delete(listId)\n\t}\n\n\tprivate deleteAllOwnedByFromCache(cacheForType: Map<Id, ListCache | BlobElementCache>, owner: string) {\n\t\t// If we find at least one element in the list that is owned by our target owner, we delete the entire list.\n\t\t// This is OK in most cases because the vast majority of lists are single owner.\n\t\t// For the other cases, we are just clearing the cache a bit sooner than needed.\n\t\tconst listIdsToDelete: string[] = []\n\t\tfor (const [listId, listCache] of cacheForType.entries()) {\n\t\t\tfor (const [id, element] of listCache.elements.entries()) {\n\t\t\t\tif (element._ownerGroup === owner) {\n\t\t\t\t\tlistIdsToDelete.push(listId)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const listId of listIdsToDelete) {\n\t\t\tcacheForType.delete(listId)\n\t\t}\n\t}\n\n\tclearExcludedData(): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" db when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId)\n\t * @param listId the mail list that we want to lock\n\t */\n\tlockRangesDbAccess(listId: string): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(listId)\"\n\t * @param listId the mail list that we want to unlock\n\t */\n\tunlockRangesDbAccess(listId: string): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n}\n","import { CacheStorage, LastUpdateTime, Range } from \"./DefaultEntityRestCache.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { ListElementEntity, SomeEntity } from \"../../common/EntityTypes\"\nimport { TypeRef } from \"@tutao/tutanota-utils\"\nimport { OfflineStorage, OfflineStorageInitArgs } from \"../offline/OfflineStorage.js\"\nimport { EphemeralCacheStorage, EphemeralStorageInitArgs } from \"./EphemeralCacheStorage\"\nimport { EntityRestClient } from \"./EntityRestClient.js\"\nimport { CustomCacheHandlerMap } from \"./CustomCacheHandler.js\"\n\nexport interface EphemeralStorageArgs extends EphemeralStorageInitArgs {\n\ttype: \"ephemeral\"\n}\n\nexport type OfflineStorageArgs = OfflineStorageInitArgs & {\n\ttype: \"offline\"\n}\n\ninterface CacheStorageInitReturn {\n\t/** If the created storage is an OfflineStorage */\n\tisPersistent: boolean\n\t/** If a OfflineStorage was created, whether or not the backing database was created fresh or already existed */\n\tisNewOfflineDb: boolean\n}\n\nexport interface CacheStorageLateInitializer {\n\tinitialize(args: OfflineStorageArgs | EphemeralStorageArgs): Promise<CacheStorageInitReturn>\n\n\tdeInitialize(): Promise<void>\n}\n\ntype SomeStorage = OfflineStorage | EphemeralCacheStorage\n\n/**\n * This is necessary so that we can release offline storage mode without having to rewrite the credentials handling system. Since it's possible that\n * a desktop user might not use a persistent session, and we won't know until they try to log in, we can only decide what kind of cache storage to use at login\n * This implementation allows us to avoid modifying too much of the worker public API. Once we make this obsolete, all we will have to do is\n * remove the initialize parameter from the LoginFacade, and tidy up the WorkerLocator init\n *\n * Create a proxy to a cache storage object.\n * It will be uninitialized, and unusable until {@method CacheStorageLateInitializer.initializeCacheStorage} has been called on the returned object\n * Once it is initialized, then it is safe to use\n * @param factory A factory function to get a CacheStorage implementation when initialize is called\n * @return {CacheStorageLateInitializer} The uninitialized proxy and a function to initialize it\n */\nexport class LateInitializedCacheStorageImpl implements CacheStorageLateInitializer, CacheStorage {\n\tprivate _inner: SomeStorage | null = null\n\n\tconstructor(private readonly sendError: (error: Error) => Promise<void>, private readonly offlineStorageProvider: () => Promise<null | OfflineStorage>) {}\n\n\tprivate get inner(): CacheStorage {\n\t\tif (this._inner == null) {\n\t\t\tthrow new ProgrammingError(\"Cache storage is not initialized\")\n\t\t}\n\n\t\treturn this._inner\n\t}\n\n\tasync initialize(args: OfflineStorageArgs | EphemeralStorageArgs): Promise<CacheStorageInitReturn> {\n\t\t// We might call this multiple times.\n\t\t// This happens when persistent credentials login fails and we need to start with new cache for new login.\n\t\tconst { storage, isPersistent, isNewOfflineDb } = await this.getStorage(args)\n\t\tthis._inner = storage\n\t\treturn {\n\t\t\tisPersistent,\n\t\t\tisNewOfflineDb,\n\t\t}\n\t}\n\n\tasync deInitialize(): Promise<void> {\n\t\tthis._inner?.deinit()\n\t}\n\n\tprivate async getStorage(\n\t\targs: OfflineStorageArgs | EphemeralStorageArgs,\n\t): Promise<{ storage: SomeStorage; isPersistent: boolean; isNewOfflineDb: boolean }> {\n\t\tif (args.type === \"offline\") {\n\t\t\ttry {\n\t\t\t\tconst storage = await this.offlineStorageProvider()\n\t\t\t\tif (storage != null) {\n\t\t\t\t\tconst isNewOfflineDb = await storage.init(args)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstorage,\n\t\t\t\t\t\tisPersistent: true,\n\t\t\t\t\t\tisNewOfflineDb,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Precaution in case something bad happens to offline database. We want users to still be able to log in.\n\t\t\t\tconsole.error(\"Error while initializing offline cache storage\", e)\n\t\t\t\tthis.sendError(e)\n\t\t\t}\n\t\t}\n\t\t// both \"else\" case and fallback for unavailable storage and error cases\n\t\tconst storage = new EphemeralCacheStorage()\n\t\tawait storage.init(args)\n\t\treturn {\n\t\t\tstorage,\n\t\t\tisPersistent: false,\n\t\t\tisNewOfflineDb: false,\n\t\t}\n\t}\n\n\tdeleteIfExists<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<void> {\n\t\treturn this.inner.deleteIfExists(typeRef, listId, id)\n\t}\n\n\tget<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<T | null> {\n\t\treturn this.inner.get(typeRef, listId, id)\n\t}\n\n\tgetIdsInRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<Id>> {\n\t\treturn this.inner.getIdsInRange(typeRef, listId)\n\t}\n\n\tgetLastBatchIdForGroup(groupId: Id): Promise<Id | null> {\n\t\treturn this.inner.getLastBatchIdForGroup(groupId)\n\t}\n\n\tasync getLastUpdateTime(): Promise<LastUpdateTime> {\n\t\treturn this._inner ? this.inner.getLastUpdateTime() : { type: \"uninitialized\" }\n\t}\n\n\tgetRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Range | null> {\n\t\treturn this.inner.getRangeForList(typeRef, listId)\n\t}\n\n\tisElementIdInCacheRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<boolean> {\n\t\treturn this.inner.isElementIdInCacheRange(typeRef, listId, id)\n\t}\n\n\tprovideFromRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, start: Id, count: number, reverse: boolean): Promise<T[]> {\n\t\treturn this.inner.provideFromRange(typeRef, listId, start, count, reverse)\n\t}\n\n\tprovideMultiple<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: string, elementIds: string[]): Promise<T[]> {\n\t\treturn this.inner.provideMultiple(typeRef, listId, elementIds)\n\t}\n\n\tgetWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<T>> {\n\t\treturn this.inner.getWholeList(typeRef, listId)\n\t}\n\n\tpurgeStorage(): Promise<void> {\n\t\treturn this.inner.purgeStorage()\n\t}\n\n\tput(originalEntity: SomeEntity): Promise<void> {\n\t\treturn this.inner.put(originalEntity)\n\t}\n\n\tputLastBatchIdForGroup(groupId: Id, batchId: Id): Promise<void> {\n\t\treturn this.inner.putLastBatchIdForGroup(groupId, batchId)\n\t}\n\n\tputLastUpdateTime(value: number): Promise<void> {\n\t\treturn this.inner.putLastUpdateTime(value)\n\t}\n\n\tsetLowerRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<void> {\n\t\treturn this.inner.setLowerRangeForList(typeRef, listId, id)\n\t}\n\n\tsetNewRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, lower: Id, upper: Id): Promise<void> {\n\t\treturn this.inner.setNewRangeForList(typeRef, listId, lower, upper)\n\t}\n\n\tsetUpperRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<void> {\n\t\treturn this.inner.setUpperRangeForList(typeRef, listId, id)\n\t}\n\n\tgetCustomCacheHandlerMap(entityRestClient: EntityRestClient): CustomCacheHandlerMap {\n\t\treturn this.inner.getCustomCacheHandlerMap(entityRestClient)\n\t}\n\n\tgetUserId(): Id {\n\t\treturn this.inner.getUserId()\n\t}\n\n\tasync deleteAllOwnedBy(owner: Id): Promise<void> {\n\t\treturn this.inner.deleteAllOwnedBy(owner)\n\t}\n\n\tasync deleteWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<void> {\n\t\treturn this.inner.deleteWholeList(typeRef, listId)\n\t}\n\n\tclearExcludedData(): Promise<void> {\n\t\treturn this.inner.clearExcludedData()\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" db when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId)\n\t * @param listId the mail list that we want to lock\n\t */\n\tlockRangesDbAccess(listId: Id): Promise<void> {\n\t\treturn this.inner.lockRangesDbAccess(listId)\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(listId)\"\n\t * @param listId the mail list that we want to unlock\n\t */\n\tunlockRangesDbAccess(listId: Id): Promise<void> {\n\t\treturn this.inner.unlockRangesDbAccess(listId)\n\t}\n}\n","import { HttpMethod, MediaType, resolveTypeReference } from \"../../common/EntityFunctions\"\nimport {\n\tDeleteService,\n\tExtraServiceParams,\n\tGetService,\n\tIServiceExecutor,\n\tMethodDefinition,\n\tParamTypeFromRef,\n\tPostService,\n\tPutService,\n\tReturnTypeFromRef,\n} from \"../../common/ServiceRequest.js\"\nimport { Entity } from \"../../common/EntityTypes\"\nimport { isSameTypeRef, lazy, TypeRef } from \"@tutao/tutanota-utils\"\nimport { RestClient } from \"./RestClient\"\nimport { InstanceMapper } from \"../crypto/InstanceMapper\"\nimport { CryptoFacade } from \"../crypto/CryptoFacade\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { AuthDataProvider } from \"../facades/UserFacade\"\nimport { LoginIncompleteError } from \"../../common/error/LoginIncompleteError.js\"\n\nassertWorkerOrNode()\n\ntype AnyService = GetService | PostService | PutService | DeleteService\n\nexport class ServiceExecutor implements IServiceExecutor {\n\tconstructor(\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly authDataProvider: AuthDataProvider,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly cryptoFacade: lazy<CryptoFacade>,\n\t) {}\n\n\tget<S extends GetService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"get\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"get\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.GET, data, params)\n\t}\n\n\tpost<S extends PostService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"post\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"post\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.POST, data, params)\n\t}\n\n\tput<S extends PutService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"put\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"put\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.PUT, data, params)\n\t}\n\n\tdelete<S extends DeleteService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"delete\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"delete\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.DELETE, data, params)\n\t}\n\n\tprivate async executeServiceRequest(\n\t\tservice: AnyService,\n\t\tmethod: HttpMethod,\n\t\trequestEntity: Entity | null,\n\t\tparams: ExtraServiceParams | undefined,\n\t): Promise<any> {\n\t\tconst methodDefinition = this.getMethodDefinition(service, method)\n\t\tif (\n\t\t\tmethodDefinition.return &&\n\t\t\tparams?.sessionKey == null &&\n\t\t\t(await resolveTypeReference(methodDefinition.return)).encrypted &&\n\t\t\t!this.authDataProvider.isFullyLoggedIn()\n\t\t) {\n\t\t\t// Short-circuit before we do an actual request which we can't decrypt\n\t\t\t// If we have a session key passed it doesn't mean that it is for the return type but it is likely\n\t\t\t// so we allow the request.\n\t\t\tthrow new LoginIncompleteError(`Tried to make service request with encrypted return type but is not fully logged in yet, service: ${service.name}`)\n\t\t}\n\n\t\tconst modelVersion = await this.getModelVersion(methodDefinition)\n\n\t\tconst path = `/rest/${service.app.toLowerCase()}/${service.name.toLowerCase()}`\n\t\tconst headers = { ...this.authDataProvider.createAuthHeaders(), ...params?.extraHeaders, v: modelVersion }\n\n\t\tconst encryptedEntity = await this.encryptDataIfNeeded(methodDefinition, requestEntity, service, method, params ?? null)\n\n\t\tconst data: string | undefined = await this.restClient.request(path, method, {\n\t\t\tqueryParams: params?.queryParams,\n\t\t\theaders,\n\t\t\tresponseType: MediaType.Json,\n\t\t\tbody: encryptedEntity ?? undefined,\n\t\t\tsuspensionBehavior: params?.suspensionBehavior,\n\t\t\tbaseUrl: params?.baseUrl,\n\t\t})\n\n\t\tif (methodDefinition.return) {\n\t\t\treturn await this.decryptResponse(methodDefinition.return, data as string, params)\n\t\t}\n\t}\n\n\tprivate getMethodDefinition(service: AnyService, method: HttpMethod): MethodDefinition {\n\t\tswitch (method) {\n\t\t\tcase HttpMethod.GET:\n\t\t\t\treturn (service as GetService)[\"get\"]\n\t\t\tcase HttpMethod.POST:\n\t\t\t\treturn (service as PostService)[\"post\"]\n\t\t\tcase HttpMethod.PUT:\n\t\t\t\treturn (service as PutService)[\"put\"]\n\t\t\tcase HttpMethod.DELETE:\n\t\t\t\treturn (service as DeleteService)[\"delete\"]\n\t\t}\n\t}\n\n\tprivate async getModelVersion(methodDefinition: MethodDefinition): Promise<string> {\n\t\t// This is some kind of a hack because we don't generate data for the whole model anywhere (unfortunately).\n\t\tconst someTypeRef = methodDefinition.data ?? methodDefinition.return\n\t\tif (someTypeRef == null) {\n\t\t\tthrow new ProgrammingError(\"Need either data or return for the service method!\")\n\t\t}\n\t\tconst model = await resolveTypeReference(someTypeRef)\n\t\treturn model.version\n\t}\n\n\tprivate async encryptDataIfNeeded(\n\t\tmethodDefinition: MethodDefinition,\n\t\trequestEntity: Entity | null,\n\t\tservice: AnyService,\n\t\tmethod: HttpMethod,\n\t\tparams: ExtraServiceParams | null,\n\t): Promise<string | null> {\n\t\tif (methodDefinition.data != null) {\n\t\t\tif (requestEntity == null || !isSameTypeRef(methodDefinition.data, requestEntity._type)) {\n\t\t\t\tthrow new ProgrammingError(`Invalid service data! ${service.name} ${method}`)\n\t\t\t}\n\n\t\t\tconst requestTypeModel = await resolveTypeReference(methodDefinition.data)\n\t\t\tif (requestTypeModel.encrypted && params?.sessionKey == null) {\n\t\t\t\tthrow new ProgrammingError(\"Must provide a session key for an encrypted data transfer type!: \" + service)\n\t\t\t}\n\n\t\t\tconst encryptedEntity = await this.instanceMapper.encryptAndMapToLiteral(requestTypeModel, requestEntity, params?.sessionKey ?? null)\n\t\t\treturn JSON.stringify(encryptedEntity)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tprivate async decryptResponse<T extends Entity>(typeRef: TypeRef<T>, data: string, params: ExtraServiceParams | undefined): Promise<T> {\n\t\tconst responseTypeModel = await resolveTypeReference(typeRef)\n\t\t// Filter out __proto__ to avoid prototype pollution.\n\t\tconst instance = JSON.parse(data, (k, v) => (k === \"__proto__\" ? undefined : v))\n\t\tconst resolvedSessionKey = await this.cryptoFacade().resolveServiceSessionKey(instance)\n\t\treturn this.instanceMapper.decryptAndMapToInstance(responseTypeModel, instance, resolvedSessionKey ?? params?.sessionKey ?? null)\n\t}\n}\n","import { GroupType } from \"../../common/TutanotaConstants\"\nimport { AesKey, decryptKey } from \"@tutao/tutanota-crypto\"\nimport { assertNotNull } from \"@tutao/tutanota-utils\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { createWebsocketLeaderStatus, GroupMembership, User, UserGroupKeyDistribution, WebsocketLeaderStatus } from \"../../entities/sys/TypeRefs\"\nimport { LoginIncompleteError } from \"../../common/error/LoginIncompleteError\"\nimport { isSameId } from \"../../common/utils/EntityUtils.js\"\nimport { KeyCache } from \"./KeyCache.js\"\nimport { CryptoWrapper, VersionedKey } from \"../crypto/CryptoWrapper.js\"\n\nexport interface AuthDataProvider {\n\t/**\n\t * @return The map which contains authentication data for the logged-in user.\n\t */\n\tcreateAuthHeaders(): Dict\n\n\tisFullyLoggedIn(): boolean\n}\n\n/** Holder for the user and session-related data on the worker side. */\nexport class UserFacade implements AuthDataProvider {\n\tprivate user: User | null = null\n\tprivate accessToken: string | null = null\n\tprivate leaderStatus!: WebsocketLeaderStatus\n\n\tconstructor(private readonly keyCache: KeyCache, private readonly cryptoWrapper: CryptoWrapper) {\n\t\tthis.reset()\n\t}\n\n\t// Login process is somehow multi-step, and we don't use a separate network stack for it. So we have to break up setters.\n\t// 1. We need to download user. For that we need to set access token already (to authenticate the request for the server as it is passed in headers).\n\t// 2. We need to get group keys. For that we need to unlock userGroupKey with userPassphraseKey\n\t// so this leads to this steps in UserFacade:\n\t// 1. Access token is set\n\t// 2. User is set\n\t// 3. UserGroupKey is unlocked\n\tsetAccessToken(accessToken: string | null) {\n\t\tthis.accessToken = accessToken\n\t}\n\n\tgetAccessToken(): string | null {\n\t\treturn this.accessToken\n\t}\n\n\tsetUser(user: User) {\n\t\tif (this.accessToken == null) {\n\t\t\tthrow new ProgrammingError(\"invalid state: no access token\")\n\t\t}\n\t\tthis.user = user\n\t}\n\n\tunlockUserGroupKey(userPassphraseKey: AesKey) {\n\t\tif (this.user == null) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: no user\")\n\t\t}\n\t\tconst userGroupMembership = this.user.userGroup\n\t\tconst currentUserGroupKey = {\n\t\t\tversion: Number(userGroupMembership.groupKeyVersion),\n\t\t\tobject: decryptKey(userPassphraseKey, userGroupMembership.symEncGKey),\n\t\t}\n\t\tthis.keyCache.setCurrentUserGroupKey(currentUserGroupKey)\n\t\tthis.setUserGroupKeyDistributionKey(userPassphraseKey)\n\t}\n\n\tsetUserGroupKeyDistributionKey(userPassphraseKey: number[]) {\n\t\tif (this.user == null) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: no user\")\n\t\t}\n\t\tconst userGroupMembership = this.user.userGroup\n\t\tconst userGroupKeyDistributionKey = this.deriveUserGroupKeyDistributionKey(userGroupMembership.group, userPassphraseKey)\n\t\tthis.keyCache.setUserGroupKeyDistributionKey(userGroupKeyDistributionKey)\n\t}\n\n\tderiveUserGroupKeyDistributionKey(userGroupId: Id, userPassphraseKey: AesKey): AesKey {\n\t\t// we prepare a key to encrypt potential user group key rotations with\n\t\t// when passwords are changed clients are logged-out of other sessions\n\t\t// this key is only needed by the logged-in clients, so it should be reliable enough to assume that userPassphraseKey is in sync\n\n\t\t// we bind this to userGroupId and the domain separator userGroupKeyDistributionKey from crypto package\n\t\t// the hkdf salt does not have to be secret but should be unique per user and carry some additional entropy which sha256 ensures\n\n\t\treturn this.cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: userGroupId,\n\t\t\tkey: userPassphraseKey,\n\t\t\tcontext: \"userGroupKeyDistributionKey\",\n\t\t})\n\t}\n\n\tasync updateUser(user: User) {\n\t\tif (this.user == null) {\n\t\t\tthrow new ProgrammingError(\"Update user is called without logging in. This function is not for you.\")\n\t\t}\n\t\tthis.user = user\n\t\tawait this.keyCache.removeOutdatedGroupKeys(user)\n\t}\n\n\tgetUser(): User | null {\n\t\treturn this.user\n\t}\n\n\t/**\n\t * @return The map which contains authentication data for the logged-in user.\n\t */\n\tcreateAuthHeaders(): Dict {\n\t\treturn this.accessToken\n\t\t\t? {\n\t\t\t\t\taccessToken: this.accessToken,\n\t\t\t  }\n\t\t\t: {}\n\t}\n\n\tgetUserGroupId(): Id {\n\t\treturn this.getLoggedInUser().userGroup.group\n\t}\n\n\tgetAllGroupIds(): Id[] {\n\t\tlet groups = this.getLoggedInUser().memberships.map((membership) => membership.group)\n\t\tgroups.push(this.getLoggedInUser().userGroup.group)\n\t\treturn groups\n\t}\n\n\tgetCurrentUserGroupKey(): VersionedKey {\n\t\t// the userGroupKey is always written after the login to this.currentUserGroupKey\n\t\t//if the user has only logged in offline this has not happened\n\t\tconst currentUserGroupKey = this.keyCache.getCurrentUserGroupKey()\n\t\tif (currentUserGroupKey == null) {\n\t\t\tif (this.isPartiallyLoggedIn()) {\n\t\t\t\tthrow new LoginIncompleteError(\"userGroupKey not available\")\n\t\t\t} else {\n\t\t\t\tthrow new ProgrammingError(\"Invalid state: userGroupKey is not available\")\n\t\t\t}\n\t\t}\n\t\treturn currentUserGroupKey\n\t}\n\n\tgetMembership(groupId: Id): GroupMembership {\n\t\tlet membership = this.getLoggedInUser().memberships.find((g: GroupMembership) => isSameId(g.group, groupId))\n\n\t\tif (!membership) {\n\t\t\tthrow new Error(`No group with groupId ${groupId} found!`)\n\t\t}\n\n\t\treturn membership\n\t}\n\n\thasGroup(groupId: Id): boolean {\n\t\tif (!this.user) {\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn groupId === this.user.userGroup.group || this.user.memberships.some((m) => m.group === groupId)\n\t\t}\n\t}\n\n\tgetGroupId(groupType: GroupType): Id {\n\t\tif (groupType === GroupType.User) {\n\t\t\treturn this.getUserGroupId()\n\t\t} else {\n\t\t\tlet membership = this.getLoggedInUser().memberships.find((m) => m.groupType === groupType)\n\n\t\t\tif (!membership) {\n\t\t\t\tthrow new Error(\"could not find groupType \" + groupType + \" for user \" + this.getLoggedInUser()._id)\n\t\t\t}\n\n\t\t\treturn membership.group\n\t\t}\n\t}\n\n\tgetGroupIds(groupType: GroupType): Id[] {\n\t\treturn this.getLoggedInUser()\n\t\t\t.memberships.filter((m) => m.groupType === groupType)\n\t\t\t.map((gm) => gm.group)\n\t}\n\n\tisPartiallyLoggedIn(): boolean {\n\t\treturn this.user != null\n\t}\n\n\tisFullyLoggedIn(): boolean {\n\t\t// We have userGroupKey, and we can decrypt any other key - we are good to go\n\t\treturn this.keyCache.getCurrentUserGroupKey() != null\n\t}\n\n\tgetLoggedInUser(): User {\n\t\treturn assertNotNull(this.user)\n\t}\n\n\tsetLeaderStatus(status: WebsocketLeaderStatus) {\n\t\tthis.leaderStatus = status\n\t\tconsole.log(\"New leader status set:\", status.leaderStatus)\n\t}\n\n\tisLeader(): boolean {\n\t\treturn this.leaderStatus.leaderStatus\n\t}\n\n\treset() {\n\t\tthis.user = null\n\t\tthis.accessToken = null\n\t\tthis.keyCache.reset()\n\t\tthis.leaderStatus = createWebsocketLeaderStatus({\n\t\t\tleaderStatus: false,\n\t\t})\n\t}\n\n\tupdateUserGroupKey(userGroupKeyDistribution: UserGroupKeyDistribution) {\n\t\tconst userGroupKeyDistributionKey = this.keyCache.getUserGroupKeyDistributionKey()\n\t\tif (userGroupKeyDistributionKey == null) {\n\t\t\tconsole.log(\"could not update userGroupKey because distribution key is not available\")\n\t\t\treturn\n\t\t}\n\t\tlet newUserGroupKeyBytes\n\t\ttry {\n\t\t\tnewUserGroupKeyBytes = decryptKey(userGroupKeyDistributionKey, userGroupKeyDistribution.distributionEncUserGroupKey)\n\t\t} catch (e) {\n\t\t\t// this may happen during offline storage synchronisation when the event queue contains user group key rotation and a password change.\n\t\t\t// We can ignore this error as we already have the latest user group key after connecting the offline client\n\t\t\tconsole.log(`Could not decrypt userGroupKeyUpdate`, e)\n\t\t\treturn\n\t\t}\n\t\tconst newUserGroupKey = {\n\t\t\tobject: newUserGroupKeyBytes,\n\t\t\tversion: Number(userGroupKeyDistribution.userGroupKeyVersion),\n\t\t}\n\t\tconsole.log(`updating userGroupKey. new version: ${userGroupKeyDistribution.userGroupKeyVersion}`)\n\t\tthis.keyCache.setCurrentUserGroupKey(newUserGroupKey)\n\t}\n}\n","/* generated file, don't edit. */\n\nimport { SqlCipherFacade } from \"./SqlCipherFacade.js\"\n\ninterface NativeInterface {\n\tinvokeNative(requestType: string, args: unknown[]): Promise<any>\n}\nexport class SqlCipherFacadeSendDispatcher implements SqlCipherFacade {\n\tconstructor(private readonly transport: NativeInterface) {}\n\tasync openDb(...args: Parameters<SqlCipherFacade[\"openDb\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"openDb\", ...args])\n\t}\n\tasync closeDb(...args: Parameters<SqlCipherFacade[\"closeDb\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"closeDb\", ...args])\n\t}\n\tasync deleteDb(...args: Parameters<SqlCipherFacade[\"deleteDb\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"deleteDb\", ...args])\n\t}\n\tasync run(...args: Parameters<SqlCipherFacade[\"run\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"run\", ...args])\n\t}\n\tasync get(...args: Parameters<SqlCipherFacade[\"get\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"get\", ...args])\n\t}\n\tasync all(...args: Parameters<SqlCipherFacade[\"all\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"all\", ...args])\n\t}\n\tasync lockRangesDbAccess(...args: Parameters<SqlCipherFacade[\"lockRangesDbAccess\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"lockRangesDbAccess\", ...args])\n\t}\n\tasync unlockRangesDbAccess(...args: Parameters<SqlCipherFacade[\"unlockRangesDbAccess\"]>) {\n\t\treturn this.transport.invokeNative(\"ipc\", [\"SqlCipherFacade\", \"unlockRangesDbAccess\", ...args])\n\t}\n}\n","import { authenticatedAesDecrypt, EntropySource, random, Randomizer } from \"@tutao/tutanota-crypto\"\nimport { UserFacade } from \"./UserFacade.js\"\nimport { createEntropyData, TutanotaProperties } from \"../../entities/tutanota/TypeRefs.js\"\nimport { EntropyService } from \"../../entities/tutanota/Services.js\"\nimport { lazy, noOp, ofClass } from \"@tutao/tutanota-utils\"\nimport { ConnectionError, LockedError, ServiceUnavailableError } from \"../../common/error/RestError.js\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest.js\"\nimport { KeyLoaderFacade } from \"./KeyLoaderFacade.js\"\nimport { encryptBytes } from \"../crypto/CryptoWrapper.js\"\n\nexport interface EntropyDataChunk {\n\tsource: EntropySource\n\tentropy: number\n\tdata: number | Array<number>\n}\n\n/** A class which accumulates the entropy and stores it on the server. */\nexport class EntropyFacade {\n\tprivate newEntropy: number = -1\n\tprivate lastEntropyUpdate: number = Date.now()\n\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly random: Randomizer,\n\t\tprivate readonly lazyKeyLoaderFacade: lazy<KeyLoaderFacade>,\n\t) {}\n\n\t/**\n\t * Adds entropy to the randomizer. Updated the stored entropy for a user when enough entropy has been collected.\n\t */\n\taddEntropy(entropy: EntropyDataChunk[]): Promise<void> {\n\t\ttry {\n\t\t\treturn this.random.addEntropy(entropy)\n\t\t} finally {\n\t\t\tthis.newEntropy = this.newEntropy + entropy.reduce((sum, value) => value.entropy + sum, 0)\n\t\t\tconst now = new Date().getTime()\n\n\t\t\tif (this.newEntropy > 5000 && now - this.lastEntropyUpdate > 1000 * 60 * 5) {\n\t\t\t\tthis.lastEntropyUpdate = now\n\t\t\t\tthis.newEntropy = 0\n\t\t\t\tthis.storeEntropy()\n\t\t\t}\n\t\t}\n\t}\n\n\tstoreEntropy(): Promise<void> {\n\t\t// We only store entropy to the server if we are the leader\n\t\tif (!this.userFacade.isFullyLoggedIn() || !this.userFacade.isLeader()) return Promise.resolve()\n\t\tconst userGroupKey = this.userFacade.getCurrentUserGroupKey()\n\t\tconst entropyData = createEntropyData({\n\t\t\tuserEncEntropy: encryptBytes(userGroupKey.object, this.random.generateRandomData(32)),\n\t\t\tuserKeyVersion: userGroupKey.version.toString(),\n\t\t})\n\t\treturn this.serviceExecutor\n\t\t\t.put(EntropyService, entropyData)\n\t\t\t.catch(ofClass(LockedError, noOp))\n\t\t\t.catch(\n\t\t\t\tofClass(ConnectionError, (e) => {\n\t\t\t\t\tconsole.log(\"could not store entropy\", e)\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(ServiceUnavailableError, (e) => {\n\t\t\t\t\tconsole.log(\"could not store entropy\", e)\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\t/**\n\t * Loads entropy from the last logout.\n\t */\n\tpublic async loadEntropy(tutanotaProperties: TutanotaProperties): Promise<void> {\n\t\tif (tutanotaProperties.userEncEntropy) {\n\t\t\ttry {\n\t\t\t\tconst keyLoaderFacade = this.lazyKeyLoaderFacade()\n\t\t\t\tconst userGroupKey = await keyLoaderFacade.loadSymUserGroupKey(Number(tutanotaProperties.userKeyVersion ?? 0))\n\t\t\t\tconst entropy = authenticatedAesDecrypt(userGroupKey, tutanotaProperties.userEncEntropy)\n\t\t\t\trandom.addStaticEntropy(entropy)\n\t\t\t} catch (error) {\n\t\t\t\tconsole.log(\"could not decrypt entropy\", error)\n\t\t\t}\n\t\t}\n\t}\n}\n","import { ArchiveDataType, BlobAccessTokenKind } from \"../../common/TutanotaConstants\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport { BlobAccessTokenService } from \"../../entities/storage/Services\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { BlobServerAccessInfo, createBlobAccessTokenPostIn, createBlobReadData, createBlobWriteData, createInstanceId } from \"../../entities/storage/TypeRefs\"\nimport { DateProvider } from \"../../common/DateProvider.js\"\nimport { resolveTypeReference } from \"../../common/EntityFunctions.js\"\nimport { AuthDataProvider } from \"./UserFacade.js\"\nimport { deduplicate, first, isEmpty, lazyMemoized, TypeRef } from \"@tutao/tutanota-utils\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { BlobLoadOptions } from \"./lazy/BlobFacade.js\"\nimport { BlobReferencingInstance } from \"../../common/utils/BlobUtils.js\"\n\nassertWorkerOrNode()\n\n/**\n * The BlobAccessTokenFacade requests blobAccessTokens from the BlobAccessTokenService to get or post to the BlobService (binary blobs)\n * or DefaultBlobElementResource (instances).\n *\n * All tokens are cached.\n */\nexport class BlobAccessTokenFacade {\n\t// cache for blob access tokens that are valid for the whole archive (key:<archiveId>)\n\t// cache for blob access tokens that are valid for blobs from a given instance were the user does not own the archive (key:<instanceElementId>).\n\tprivate readonly readCache: BlobAccessTokenCache\n\t// cache for upload requests are valid for the whole archive (key:<ownerGroup + archiveDataType>).\n\tprivate readonly writeCache: BlobAccessTokenCache\n\n\tconstructor(private readonly serviceExecutor: IServiceExecutor, private readonly authDataProvider: AuthDataProvider, dateProvider: DateProvider) {\n\t\tthis.readCache = new BlobAccessTokenCache(dateProvider)\n\t\tthis.writeCache = new BlobAccessTokenCache(dateProvider)\n\t}\n\n\t/**\n\t * Requests a token that allows uploading blobs for the given ArchiveDataType and ownerGroup.\n\t * @param archiveDataType The type of data that should be stored.\n\t * @param ownerGroupId The ownerGroup were the data belongs to (e.g. group of type mail)\n\t */\n\tasync requestWriteToken(archiveDataType: ArchiveDataType, ownerGroupId: Id): Promise<BlobServerAccessInfo> {\n\t\tconst requestNewToken = async () => {\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType,\n\t\t\t\twrite: createBlobWriteData({\n\t\t\t\t\tarchiveOwnerGroup: ownerGroupId,\n\t\t\t\t}),\n\t\t\t\tread: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest)\n\t\t\treturn blobAccessInfo\n\t\t}\n\t\tconst key = this.makeWriteCacheKey(ownerGroupId, archiveDataType)\n\t\treturn this.writeCache.getToken(key, [], requestNewToken)\n\t}\n\n\tprivate makeWriteCacheKey(ownerGroupId: string, archiveDataType: ArchiveDataType) {\n\t\treturn ownerGroupId + archiveDataType\n\t}\n\n\t/**\n\t * Remove a given write token from the cache.\n\t * @param archiveDataType\n\t * @param ownerGroupId\n\t */\n\tevictWriteToken(archiveDataType: ArchiveDataType, ownerGroupId: Id): void {\n\t\tconst key = this.makeWriteCacheKey(ownerGroupId, archiveDataType)\n\t\tthis.writeCache.evictArchiveOrGroupKey(key)\n\t}\n\n\t/**\n\t * Requests a token that grants read access to all blobs that are referenced by the given instances.\n\t * A user must be owner of the instance but must not be owner of the archive where the blobs are stored in.\n\t *\n\t * @param archiveDataType specify the data type\n\t * @param referencingInstances the instances that references the blobs\n\t * @param blobLoadOptions load options when loading blobs\n\t * @throws ProgrammingError if instances are not part of the same list or blobs are not part of the same archive.\n\t */\n\tasync requestReadTokenMultipleInstances(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstances: readonly BlobReferencingInstance[],\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<BlobServerAccessInfo> {\n\t\tif (isEmpty(referencingInstances)) {\n\t\t\tthrow new ProgrammingError(\"Must pass at least one referencing instance\")\n\t\t}\n\t\tconst instanceListId = referencingInstances[0].listId\n\t\tif (!referencingInstances.every((instance) => instance.listId === instanceListId)) {\n\t\t\tthrow new ProgrammingError(\"All referencing instances must be part of the same list\")\n\t\t}\n\n\t\tconst archiveId = this.getArchiveId(referencingInstances)\n\n\t\tconst requestNewToken = lazyMemoized(async () => {\n\t\t\tconst instanceIds = referencingInstances.map(({ elementId }) => createInstanceId({ instanceId: elementId }))\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType,\n\t\t\t\tread: createBlobReadData({\n\t\t\t\t\tarchiveId,\n\t\t\t\t\tinstanceListId,\n\t\t\t\t\tinstanceIds,\n\t\t\t\t}),\n\t\t\t\twrite: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest, blobLoadOptions)\n\t\t\treturn blobAccessInfo\n\t\t})\n\n\t\treturn this.readCache.getToken(\n\t\t\tarchiveId,\n\t\t\treferencingInstances.map((instance) => instance.elementId),\n\t\t\trequestNewToken,\n\t\t)\n\t}\n\n\t/**\n\t * Requests a token that grants read access to all blobs that are referenced by the given instance.\n\t * A user must be owner of the instance but must not be owner of the archive were the blobs are stored in.\n\t * @param archiveDataType specify the data type\n\t * @param referencingInstance the instance that references the blobs\n\t * @param blobLoadOptions load options when loading blobs\n\t */\n\tasync requestReadTokenBlobs(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstance: BlobReferencingInstance,\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<BlobServerAccessInfo> {\n\t\tconst archiveId = this.getArchiveId([referencingInstance])\n\t\tconst requestNewToken = async () => {\n\t\t\tconst instanceListId = referencingInstance.listId\n\t\t\tconst instanceId = referencingInstance.elementId\n\t\t\tconst instanceIds = [createInstanceId({ instanceId })]\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType,\n\t\t\t\tread: createBlobReadData({\n\t\t\t\t\tarchiveId,\n\t\t\t\t\tinstanceListId,\n\t\t\t\t\tinstanceIds,\n\t\t\t\t}),\n\t\t\t\twrite: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest, blobLoadOptions)\n\t\t\treturn blobAccessInfo\n\t\t}\n\t\treturn this.readCache.getToken(archiveId, [referencingInstance.elementId], requestNewToken)\n\t}\n\n\t/**\n\t * Remove a given read blobs token from the cache.\n\t * @param referencingInstance\n\t */\n\tevictReadBlobsToken(referencingInstance: BlobReferencingInstance): void {\n\t\tthis.readCache.evictInstanceId(referencingInstance.elementId)\n\t\tconst archiveId = this.getArchiveId([referencingInstance])\n\t\tthis.readCache.evictArchiveOrGroupKey(archiveId)\n\t}\n\n\t/**\n\t * Remove a given read blobs token from the cache.\n\t * @param referencingInstances\n\t */\n\tevictReadBlobsTokenMultipleBlobs(referencingInstances: BlobReferencingInstance[]): void {\n\t\tthis.readCache.evictAll(referencingInstances.map((instance) => instance.elementId))\n\t\tconst archiveId = this.getArchiveId(referencingInstances)\n\t\tthis.readCache.evictArchiveOrGroupKey(archiveId)\n\t}\n\n\t/**\n\t * Requests a token that grants access to all blobs stored in the given archive. The user must own the archive (member of group)\n\t * @param archiveId ID for the archive to read blobs from\n\t */\n\tasync requestReadTokenArchive(archiveId: Id): Promise<BlobServerAccessInfo> {\n\t\tconst requestNewToken = async () => {\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType: null,\n\t\t\t\tread: createBlobReadData({\n\t\t\t\t\tarchiveId,\n\t\t\t\t\tinstanceIds: [],\n\t\t\t\t\tinstanceListId: null,\n\t\t\t\t}),\n\t\t\t\twrite: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest)\n\t\t\treturn blobAccessInfo\n\t\t}\n\t\treturn this.readCache.getToken(archiveId, [], requestNewToken)\n\t}\n\n\t/**\n\t * Remove a given read archive token from the cache.\n\t * @param archiveId\n\t */\n\tevictArchiveToken(archiveId: Id): void {\n\t\tthis.readCache.evictArchiveOrGroupKey(archiveId)\n\t}\n\n\tprivate getArchiveId(referencingInstances: readonly BlobReferencingInstance[]): Id {\n\t\tif (isEmpty(referencingInstances)) {\n\t\t\tthrow new ProgrammingError(\"Must pass at least one referencing instance\")\n\t\t}\n\t\tconst archiveIds = new Set<Id>()\n\t\tfor (const referencingInstance of referencingInstances) {\n\t\t\tif (isEmpty(referencingInstance.blobs)) {\n\t\t\t\tthrow new ProgrammingError(\"must pass blobs\")\n\t\t\t}\n\t\t\tfor (const blob of referencingInstance.blobs) {\n\t\t\t\tarchiveIds.add(blob.archiveId)\n\t\t\t}\n\t\t}\n\n\t\tif (archiveIds.size != 1) {\n\t\t\tthrow new Error(`only one archive id allowed, but was ${archiveIds}`)\n\t\t}\n\t\treturn referencingInstances[0].blobs[0].archiveId\n\t}\n\n\t/**\n\t *\n\t * @param blobServerAccessInfo\n\t * @param additionalRequestParams\n\t * @param typeRef the typeRef that shall be used to determine the correct model version\n\t */\n\tpublic async createQueryParams(blobServerAccessInfo: BlobServerAccessInfo, additionalRequestParams: Dict, typeRef: TypeRef<any>): Promise<Dict> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\treturn Object.assign(\n\t\t\tadditionalRequestParams,\n\t\t\t{\n\t\t\t\tblobAccessToken: blobServerAccessInfo.blobAccessToken,\n\t\t\t\tv: typeModel.version,\n\t\t\t},\n\t\t\tthis.authDataProvider.createAuthHeaders(),\n\t\t)\n\t}\n}\n\n/**\n * Checks if the given access token can be used for another blob service requests.\n * @param blobServerAccessInfo\n * @param dateProvider\n */\nfunction canBeUsedForAnotherRequest(blobServerAccessInfo: BlobServerAccessInfo, dateProvider: DateProvider): boolean {\n\treturn blobServerAccessInfo.expires.getTime() > dateProvider.now()\n}\n\nclass BlobAccessTokenCache {\n\tprivate readonly instanceMap: Map<Id, BlobServerAccessInfo> = new Map()\n\tprivate readonly archiveMap: Map<Id, BlobServerAccessInfo> = new Map()\n\n\tconstructor(private readonly dateProvider: DateProvider) {}\n\n\t/**\n\t * Get a token from the cache or from {@param loader}.\n\t * First will try to use the token keyed by {@param archiveOrGroupKey}, otherwise it will try to find a token valid for all of {@param instanceIds}.\n\t */\n\tpublic async getToken(\n\t\tarchiveOrGroupKey: Id | null,\n\t\tinstanceIds: readonly Id[],\n\t\tloader: () => Promise<BlobServerAccessInfo>,\n\t): Promise<BlobServerAccessInfo> {\n\t\tconst archiveToken = archiveOrGroupKey ? this.archiveMap.get(archiveOrGroupKey) : null\n\t\tif (archiveToken != null && canBeUsedForAnotherRequest(archiveToken, this.dateProvider)) {\n\t\t\treturn archiveToken\n\t\t}\n\n\t\tconst tokens = deduplicate(instanceIds.map((id) => this.instanceMap.get(id) ?? null))\n\t\tconst firstTokenFound = first(tokens)\n\t\tif (tokens.length != 1 || firstTokenFound == null || !canBeUsedForAnotherRequest(firstTokenFound, this.dateProvider)) {\n\t\t\tconst newToken = await loader()\n\t\t\tif (archiveOrGroupKey != null && newToken.tokenKind === BlobAccessTokenKind.Archive) {\n\t\t\t\tthis.archiveMap.set(archiveOrGroupKey, newToken)\n\t\t\t} else {\n\t\t\t\tfor (const id of instanceIds) {\n\t\t\t\t\tthis.instanceMap.set(id, newToken)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newToken\n\t\t} else {\n\t\t\treturn firstTokenFound\n\t\t}\n\t}\n\n\tpublic evictInstanceId(id: Id): void {\n\t\tthis.evictAll([id])\n\t}\n\n\tpublic evictArchiveOrGroupKey(id: Id): void {\n\t\tthis.archiveMap.delete(id)\n\t}\n\n\tpublic evictAll(ids: Id[]): void {\n\t\tfor (const id of ids) {\n\t\t\tthis.instanceMap.delete(id)\n\t\t}\n\t}\n}\n","import { debounce } from \"@tutao/tutanota-utils\"\nimport { createUpdateSessionKeysPostIn, GroupKeyUpdateTypeRef, InstanceSessionKey } from \"../../entities/sys/TypeRefs.js\"\nimport { LockedError } from \"../../common/error/RestError\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { UpdateSessionKeysService } from \"../../entities/sys/Services\"\nimport { UserFacade } from \"../facades/UserFacade\"\nimport { TypeModel } from \"../../common/EntityTypes.js\"\nimport { resolveTypeReference } from \"../../common/EntityFunctions.js\"\n\nassertWorkerOrNode()\n\nexport const UPDATE_SESSION_KEYS_SERVICE_DEBOUNCE_MS = 50\n\n/**\n * This queue collects updates for ownerEncSessionKeys and debounces the update request to the UpdateSessionKeysService,\n * in order to update as many instances in one request as possible.\n *\n * In case of LockedErrors it will retry. In case of other errors it will discard the update.\n * (The next time the instance session key is resolved using the bucket key a new update attempt will be made for those instances.)\n */\nexport class OwnerEncSessionKeysUpdateQueue {\n\tprivate updateInstanceSessionKeyQueue: Array<InstanceSessionKey> = []\n\tprivate readonly invokeUpdateSessionKeyService: () => Promise<void>\n\tprivate senderAuthStatusForMailInstance: { authenticated: boolean; instanceElementId: Id } | null = null\n\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\t// allow passing the timeout for testability\n\t\tdebounceTimeoutMs: number = UPDATE_SESSION_KEYS_SERVICE_DEBOUNCE_MS,\n\t) {\n\t\tthis.invokeUpdateSessionKeyService = debounce(debounceTimeoutMs, () => this.sendUpdateRequest())\n\t}\n\n\t/**\n\t * Add the ownerEncSessionKey updates to the queue and debounce the update request.\n\t *\n\t * @param instanceSessionKeys all instanceSessionKeys from one bucketKey containing the ownerEncSessionKey as symEncSessionKey\n\t * @param typeModel of the main instance that we are updating session keys for\n\t */\n\tasync updateInstanceSessionKeys(instanceSessionKeys: Array<InstanceSessionKey>, typeModel: TypeModel) {\n\t\tif (this.userFacade.isLeader()) {\n\t\t\tconst groupKeyUpdateTypeModel = await resolveTypeReference(GroupKeyUpdateTypeRef)\n\t\t\tif (groupKeyUpdateTypeModel.id !== typeModel.id) {\n\t\t\t\tthis.updateInstanceSessionKeyQueue.push(...instanceSessionKeys)\n\t\t\t\tthis.invokeUpdateSessionKeyService()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendUpdateRequest(): Promise<void> {\n\t\tconst instanceSessionKeys = this.updateInstanceSessionKeyQueue\n\t\tthis.updateInstanceSessionKeyQueue = []\n\t\ttry {\n\t\t\tif (instanceSessionKeys.length > 0) {\n\t\t\t\tawait this.postUpdateSessionKeysService(instanceSessionKeys)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof LockedError) {\n\t\t\t\tthis.updateInstanceSessionKeyQueue.push(...instanceSessionKeys)\n\t\t\t\tthis.invokeUpdateSessionKeyService()\n\t\t\t} else {\n\t\t\t\tconsole.log(\"error during session key update:\", e.name, instanceSessionKeys.length)\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tasync postUpdateSessionKeysService(instanceSessionKeys: Array<InstanceSessionKey>) {\n\t\tconst input = createUpdateSessionKeysPostIn({ ownerEncSessionKeys: instanceSessionKeys })\n\t\tawait this.serviceExecutor.post(UpdateSessionKeysService, input)\n\t}\n}\n","import { EventBusListener } from \"./EventBusClient.js\"\nimport { WsConnectionState } from \"../main/WorkerClient.js\"\nimport {\n\tEntityUpdate,\n\tGroupKeyUpdateTypeRef,\n\tUserGroupKeyDistributionTypeRef,\n\tUserTypeRef,\n\tWebsocketCounterData,\n\tWebsocketLeaderStatus,\n} from \"../entities/sys/TypeRefs.js\"\nimport { ReportedMailFieldMarker } from \"../entities/tutanota/TypeRefs.js\"\nimport { WebsocketConnectivityListener } from \"../../misc/WebsocketConnectivityModel.js\"\nimport { isAdminClient, isTest } from \"../common/Env.js\"\nimport { MailFacade } from \"./facades/lazy/MailFacade.js\"\nimport { UserFacade } from \"./facades/UserFacade.js\"\nimport { EntityClient } from \"../common/EntityClient.js\"\nimport { AccountType, OperationType } from \"../common/TutanotaConstants.js\"\nimport { isSameTypeRefByAttr, lazyAsync } from \"@tutao/tutanota-utils\"\nimport { isSameId } from \"../common/utils/EntityUtils.js\"\nimport { ExposedEventController } from \"../main/EventController.js\"\nimport { ConfigurationDatabase } from \"./facades/lazy/ConfigurationDatabase.js\"\nimport { KeyRotationFacade } from \"./facades/KeyRotationFacade.js\"\nimport { CacheManagementFacade } from \"./facades/lazy/CacheManagementFacade.js\"\nimport type { QueuedBatch } from \"./EventQueue.js\"\n\n/** A bit of glue to distribute event bus events across the app. */\nexport class EventBusEventCoordinator implements EventBusListener {\n\tconstructor(\n\t\tprivate readonly connectivityListener: WebsocketConnectivityListener,\n\t\tprivate readonly mailFacade: lazyAsync<MailFacade>,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly eventController: ExposedEventController,\n\t\tprivate readonly configurationDatabase: lazyAsync<ConfigurationDatabase>,\n\t\tprivate readonly keyRotationFacade: KeyRotationFacade,\n\t\tprivate readonly cacheManagementFacade: lazyAsync<CacheManagementFacade>,\n\t\tprivate readonly sendError: (error: Error) => Promise<void>,\n\t\tprivate readonly appSpecificBatchHandling: (queuedBatch: QueuedBatch[]) => void,\n\t) {}\n\n\tonWebsocketStateChanged(state: WsConnectionState) {\n\t\tthis.connectivityListener.updateWebSocketState(state)\n\t}\n\n\tasync onEntityEventsReceived(events: EntityUpdate[], batchId: Id, groupId: Id): Promise<void> {\n\t\tawait this.entityEventsReceived(events)\n\t\tawait (await this.mailFacade()).entityEventsReceived(events)\n\t\tawait this.eventController.onEntityUpdateReceived(events, groupId)\n\t\t// Call the indexer in this last step because now the processed event is stored and the indexer has a separate event queue that\n\t\t// shall not receive the event twice.\n\t\tif (!isTest() && !isAdminClient()) {\n\t\t\tconst queuedBatch = { groupId, batchId, events }\n\t\t\tconst configurationDatabase = await this.configurationDatabase()\n\t\t\tawait configurationDatabase.onEntityEventsReceived(queuedBatch)\n\t\t\tthis.appSpecificBatchHandling([queuedBatch])\n\t\t}\n\t}\n\n\t/**\n\t * @param markers only phishing (not spam) marker will be sent as websocket updates\n\t */\n\tasync onPhishingMarkersReceived(markers: ReportedMailFieldMarker[]) {\n\t\t;(await this.mailFacade()).phishingMarkersUpdateReceived(markers)\n\t}\n\n\tonError(tutanotaError: Error) {\n\t\tthis.sendError(tutanotaError)\n\t}\n\n\tonLeaderStatusChanged(leaderStatus: WebsocketLeaderStatus) {\n\t\tthis.connectivityListener.onLeaderStatusChanged(leaderStatus)\n\t\tif (!isAdminClient()) {\n\t\t\tconst user = this.userFacade.getUser()\n\t\t\tif (leaderStatus.leaderStatus && user && user.accountType !== AccountType.EXTERNAL) {\n\t\t\t\tthis.keyRotationFacade.processPendingKeyRotationsAndUpdates(user)\n\t\t\t} else {\n\t\t\t\tthis.keyRotationFacade.reset()\n\t\t\t}\n\t\t}\n\t}\n\n\tonCounterChanged(counter: WebsocketCounterData) {\n\t\tthis.eventController.onCountersUpdateReceived(counter)\n\t}\n\n\tprivate async entityEventsReceived(data: EntityUpdate[]): Promise<void> {\n\t\t// This is a compromise to not add entityClient to UserFacade which would introduce a circular dep.\n\t\tconst groupKeyUpdates: IdTuple[] = [] // GroupKeyUpdates all in the same list\n\t\tconst user = this.userFacade.getUser()\n\t\tif (user == null) return\n\t\tfor (const update of data) {\n\t\t\tif (\n\t\t\t\tupdate.operation === OperationType.UPDATE &&\n\t\t\t\tisSameTypeRefByAttr(UserTypeRef, update.application, update.type) &&\n\t\t\t\tisSameId(user._id, update.instanceId)\n\t\t\t) {\n\t\t\t\tawait this.userFacade.updateUser(await this.entityClient.load(UserTypeRef, user._id))\n\t\t\t} else if (\n\t\t\t\t(update.operation === OperationType.CREATE || update.operation === OperationType.UPDATE) &&\n\t\t\t\tisSameTypeRefByAttr(UserGroupKeyDistributionTypeRef, update.application, update.type) &&\n\t\t\t\tisSameId(user.userGroup.group, update.instanceId)\n\t\t\t) {\n\t\t\t\tawait (await this.cacheManagementFacade()).tryUpdatingUserGroupKey()\n\t\t\t} else if (update.operation === OperationType.CREATE && isSameTypeRefByAttr(GroupKeyUpdateTypeRef, update.application, update.type)) {\n\t\t\t\tgroupKeyUpdates.push([update.instanceListId, update.instanceId])\n\t\t\t}\n\t\t}\n\t\tawait this.keyRotationFacade.updateGroupMemberships(groupKeyUpdates)\n\t}\n}\n","import { aes256RandomKey, keyToBase64 } from \"@tutao/tutanota-crypto\"\nimport { Logger } from \"../../common/Logger.js\"\n\n/**\n *  Loose collection of functions that should be run on the worker side e.g. because they take too much time and don't belong anywhere else.\n *  (read: kitchen sink).\n */\nexport class WorkerFacade {\n\tasync generateSsePushIdentifer(): Promise<string> {\n\t\treturn keyToBase64(aes256RandomKey())\n\t}\n\n\tasync getLog(): Promise<string[]> {\n\t\tconst global = self as any\n\t\tconst logger = global.logger as Logger | undefined\n\n\t\tif (logger) {\n\t\t\treturn logger.getEntries()\n\t\t} else {\n\t\t\treturn []\n\t\t}\n\t}\n\n\tasync urlify(html: string): Promise<string> {\n\t\tconst { urlify } = await import(\"../Urlifier.js\")\n\t\treturn urlify(html)\n\t}\n}\n","import { Aes256Key, Argon2IDExports, generateKeyFromPassphraseArgon2id, uint8ArrayToBitArray } from \"@tutao/tutanota-crypto\"\nimport { LazyLoaded, stringToUtf8Uint8Array } from \"@tutao/tutanota-utils\"\nimport { NativeCryptoFacade } from \"../../../native/common/generatedipc/NativeCryptoFacade.js\"\nimport { assertWorkerOrNode } from \"../../common/Env.js\"\nimport { loadWasm } from \"argon2.wasm\"\n\nassertWorkerOrNode()\n\n/**\n * Abstract interface for generating Argon2id passphrase keys using the preferred implementation (i.e. native or WASM)\n */\nexport interface Argon2idFacade {\n\t/**\n\t * Generate a key from a passphrase\n\t * @param passphrase\n\t * @param salt\n\t * @return bit array of the resulting key\n\t */\n\tgenerateKeyFromPassphrase(passphrase: string, salt: Uint8Array): Promise<Aes256Key>\n}\n\n/**\n * WebAssembly implementation of Argon2id\n */\nexport class WASMArgon2idFacade implements Argon2idFacade {\n\t// loads argon2 WASM\n\tprivate argon2: LazyLoaded<Argon2IDExports> = new LazyLoaded(async () => {\n\t\treturn await loadWasm()\n\t})\n\n\tasync generateKeyFromPassphrase(passphrase: string, salt: Uint8Array): Promise<Aes256Key> {\n\t\treturn generateKeyFromPassphraseArgon2id(await this.argon2.getAsync(), passphrase, salt)\n\t}\n}\n\n/**\n * Native implementation of Argon2id\n */\nexport class NativeArgon2idFacade implements Argon2idFacade {\n\tconstructor(private readonly nativeCryptoFacade: NativeCryptoFacade) {}\n\n\tasync generateKeyFromPassphrase(passphrase: string, salt: Uint8Array): Promise<Aes256Key> {\n\t\tconst hash = await this.nativeCryptoFacade.argon2idGeneratePassphraseKey(passphrase, salt)\n\t\treturn uint8ArrayToBitArray(hash)\n\t}\n}\n","import { LazyLoaded } from \"@tutao/tutanota-utils\"\nimport { NativeCryptoFacade } from \"../../../native/common/generatedipc/NativeCryptoFacade.js\"\nimport { assertWorkerOrNode } from \"../../common/Env.js\"\nimport {\n\tdecapsulateKyber,\n\tencapsulateKyber,\n\tgenerateKeyPairKyber,\n\tKYBER_RAND_AMOUNT_OF_ENTROPY,\n\tKyberEncapsulation,\n\tKyberKeyPair,\n\tKyberPrivateKey,\n\tKyberPublicKey,\n\tLibOQSExports,\n\trandom,\n} from \"@tutao/tutanota-crypto\"\nimport { loadWasm } from \"liboqs.wasm\"\n\nassertWorkerOrNode()\n\n/**\n * Abstract interface for the Liboqs crypto system.\n */\nexport interface KyberFacade {\n\t/**\n\t * Generate a key new random key pair\n\t */\n\tgenerateKeypair(): Promise<KyberKeyPair>\n\n\t/**\n\t *\n\t * @param publicKey the public key to encapsulate the secret with\n\t * @returns the ciphertext and the shared secret\n\t */\n\tencapsulate(publicKey: KyberPublicKey): Promise<KyberEncapsulation>\n\n\t/**\n\t *\n\t * @param privateKey the corresponding private key to the public key used to encapsulate the cipher text\n\t * @param ciphertext the encapsulated ciphertext\n\t * @returns the shared secret\n\t */\n\tdecapsulate(privateKey: KyberPrivateKey, ciphertext: Uint8Array): Promise<Uint8Array>\n}\n\n/**\n * WebAssembly implementation of Liboqs\n */\nexport class WASMKyberFacade implements KyberFacade {\n\tconstructor(private readonly testWASM?: LibOQSExports) {}\n\n\t// loads liboqs WASM\n\tprivate liboqs: LazyLoaded<LibOQSExports> = new LazyLoaded(async () => {\n\t\tif (this.testWASM) {\n\t\t\treturn this.testWASM\n\t\t}\n\n\t\treturn await loadWasm()\n\t})\n\n\tasync generateKeypair(): Promise<KyberKeyPair> {\n\t\treturn generateKeyPairKyber(await this.liboqs.getAsync(), random)\n\t}\n\n\tasync encapsulate(publicKey: KyberPublicKey): Promise<KyberEncapsulation> {\n\t\treturn encapsulateKyber(await this.liboqs.getAsync(), publicKey, random)\n\t}\n\n\tasync decapsulate(privateKey: KyberPrivateKey, ciphertext: Uint8Array): Promise<Uint8Array> {\n\t\treturn decapsulateKyber(await this.liboqs.getAsync(), privateKey, ciphertext)\n\t}\n}\n\n/**\n * Native implementation of Liboqs\n */\nexport class NativeKyberFacade implements KyberFacade {\n\tconstructor(private readonly nativeCryptoFacade: NativeCryptoFacade) {}\n\n\tgenerateKeypair(): Promise<KyberKeyPair> {\n\t\treturn this.nativeCryptoFacade.generateKyberKeypair(random.generateRandomData(KYBER_RAND_AMOUNT_OF_ENTROPY))\n\t}\n\n\tencapsulate(publicKey: KyberPublicKey): Promise<KyberEncapsulation> {\n\t\treturn this.nativeCryptoFacade.kyberEncapsulate(publicKey, random.generateRandomData(KYBER_RAND_AMOUNT_OF_ENTROPY))\n\t}\n\n\tdecapsulate(privateKey: KyberPrivateKey, ciphertext: Uint8Array): Promise<Uint8Array> {\n\t\treturn this.nativeCryptoFacade.kyberDecapsulate(privateKey, ciphertext)\n\t}\n}\n","import { EccPublicKey } from \"@tutao/tutanota-crypto\"\nimport { byteArraysToBytes, bytesToByteArrays } from \"@tutao/tutanota-utils/dist/Encoding.js\"\n\nexport type PQMessage = {\n\tsenderIdentityPubKey: EccPublicKey\n\tephemeralPubKey: EccPublicKey\n\tencapsulation: PQBucketKeyEncapsulation\n}\n\nexport type PQBucketKeyEncapsulation = {\n\tkyberCipherText: Uint8Array\n\tkekEncBucketKey: Uint8Array\n}\n\nexport function decodePQMessage(encoded: Uint8Array): PQMessage {\n\tconst pqMessageParts = bytesToByteArrays(encoded, 4)\n\treturn {\n\t\tsenderIdentityPubKey: pqMessageParts[0],\n\t\tephemeralPubKey: pqMessageParts[1],\n\t\tencapsulation: {\n\t\t\tkyberCipherText: pqMessageParts[2],\n\t\t\tkekEncBucketKey: pqMessageParts[3],\n\t\t},\n\t}\n}\n\nexport function encodePQMessage({ senderIdentityPubKey, ephemeralPubKey, encapsulation }: PQMessage): Uint8Array {\n\treturn byteArraysToBytes([senderIdentityPubKey, ephemeralPubKey, encapsulation.kyberCipherText, encapsulation.kekEncBucketKey])\n}\n","import { KyberFacade } from \"./KyberFacade.js\"\nimport {\n\tAes256Key,\n\taesEncrypt,\n\tauthenticatedAesDecrypt,\n\teccDecapsulate,\n\teccEncapsulate,\n\tEccKeyPair,\n\tEccPublicKey,\n\tEccSharedSecrets,\n\tgenerateEccKeyPair,\n\thkdf,\n\tKEY_LENGTH_BYTES_AES_256,\n\tKeyPairType,\n\tkyberPublicKeyToBytes,\n\tPQKeyPairs,\n\tpqKeyPairsToPublicKeys,\n\tPQPublicKeys,\n\tuint8ArrayToKey,\n} from \"@tutao/tutanota-crypto\"\nimport { concat, stringToUtf8Uint8Array } from \"@tutao/tutanota-utils\"\nimport { decodePQMessage, encodePQMessage, PQMessage } from \"./PQMessage.js\"\nimport { CryptoProtocolVersion } from \"../../common/TutanotaConstants.js\"\n\nexport type DecapsulatedSymKey = {\n\tsenderIdentityPubKey: EccPublicKey\n\tdecryptedSymKeyBytes: Uint8Array\n}\n\nexport class PQFacade {\n\tconstructor(private readonly kyberFacade: KyberFacade) {}\n\n\tpublic async generateKeyPairs(): Promise<PQKeyPairs> {\n\t\treturn {\n\t\t\tkeyPairType: KeyPairType.TUTA_CRYPT,\n\t\t\teccKeyPair: generateEccKeyPair(),\n\t\t\tkyberKeyPair: await this.kyberFacade.generateKeypair(),\n\t\t}\n\t}\n\n\tpublic async encapsulateAndEncode(\n\t\tsenderIdentityKeyPair: EccKeyPair,\n\t\tephemeralKeyPair: EccKeyPair,\n\t\trecipientPublicKeys: PQPublicKeys,\n\t\tbucketKey: Uint8Array,\n\t): Promise<Uint8Array> {\n\t\tconst encapsulated = await this.encapsulate(senderIdentityKeyPair, ephemeralKeyPair, recipientPublicKeys, bucketKey)\n\t\treturn encodePQMessage(encapsulated)\n\t}\n\n\t/**\n\t * @VisibleForTesting\n\t */\n\tasync encapsulate(\n\t\tsenderIdentityKeyPair: EccKeyPair,\n\t\tephemeralKeyPair: EccKeyPair,\n\t\trecipientPublicKeys: PQPublicKeys,\n\t\tbucketKey: Uint8Array,\n\t): Promise<PQMessage> {\n\t\tconst eccSharedSecret = eccEncapsulate(senderIdentityKeyPair.privateKey, ephemeralKeyPair.privateKey, recipientPublicKeys.eccPublicKey)\n\t\tconst kyberEncapsulation = await this.kyberFacade.encapsulate(recipientPublicKeys.kyberPublicKey)\n\t\tconst kyberCipherText = kyberEncapsulation.ciphertext\n\n\t\tconst kek = this.derivePQKEK(\n\t\t\tsenderIdentityKeyPair.publicKey,\n\t\t\tephemeralKeyPair.publicKey,\n\t\t\trecipientPublicKeys,\n\t\t\tkyberCipherText,\n\t\t\tkyberEncapsulation.sharedSecret,\n\t\t\teccSharedSecret,\n\t\t\tCryptoProtocolVersion.TUTA_CRYPT,\n\t\t)\n\n\t\tconst kekEncBucketKey = aesEncrypt(kek, bucketKey)\n\t\treturn {\n\t\t\tsenderIdentityPubKey: senderIdentityKeyPair.publicKey,\n\t\t\tephemeralPubKey: ephemeralKeyPair.publicKey,\n\t\t\tencapsulation: {\n\t\t\t\tkyberCipherText,\n\t\t\t\tkekEncBucketKey: kekEncBucketKey,\n\t\t\t},\n\t\t}\n\t}\n\n\tpublic async decapsulateEncoded(encodedPQMessage: Uint8Array, recipientKeys: PQKeyPairs): Promise<DecapsulatedSymKey> {\n\t\tconst decoded = decodePQMessage(encodedPQMessage)\n\t\treturn { decryptedSymKeyBytes: await this.decapsulate(decoded, recipientKeys), senderIdentityPubKey: decoded.senderIdentityPubKey }\n\t}\n\n\t/**\n\t * @VisibleForTesting\n\t */\n\tasync decapsulate(message: PQMessage, recipientKeys: PQKeyPairs): Promise<Uint8Array> {\n\t\tconst kyberCipherText = message.encapsulation.kyberCipherText\n\t\tconst eccSharedSecret = eccDecapsulate(message.senderIdentityPubKey, message.ephemeralPubKey, recipientKeys.eccKeyPair.privateKey)\n\t\tconst kyberSharedSecret = await this.kyberFacade.decapsulate(recipientKeys.kyberKeyPair.privateKey, kyberCipherText)\n\n\t\tconst kek = this.derivePQKEK(\n\t\t\tmessage.senderIdentityPubKey,\n\t\t\tmessage.ephemeralPubKey,\n\t\t\tpqKeyPairsToPublicKeys(recipientKeys),\n\t\t\tkyberCipherText,\n\t\t\tkyberSharedSecret,\n\t\t\teccSharedSecret,\n\t\t\tCryptoProtocolVersion.TUTA_CRYPT,\n\t\t)\n\n\t\treturn authenticatedAesDecrypt(kek, message.encapsulation.kekEncBucketKey)\n\t}\n\n\tprivate derivePQKEK(\n\t\tsenderIdentityPublicKey: EccPublicKey,\n\t\tephemeralPublicKey: EccPublicKey,\n\t\trecipientPublicKeys: PQPublicKeys,\n\t\tkyberCipherText: Uint8Array,\n\t\tkyberSharedSecret: Uint8Array,\n\t\teccSharedSecret: EccSharedSecrets,\n\t\tcryptoProtocolVersion: CryptoProtocolVersion,\n\t): Aes256Key {\n\t\tconst context = concat(\n\t\t\tsenderIdentityPublicKey,\n\t\t\tephemeralPublicKey,\n\t\t\trecipientPublicKeys.eccPublicKey,\n\t\t\tkyberPublicKeyToBytes(recipientPublicKeys.kyberPublicKey),\n\t\t\tkyberCipherText,\n\t\t\tnew Uint8Array([Number(cryptoProtocolVersion)]),\n\t\t)\n\n\t\tconst inputKeyMaterial = concat(eccSharedSecret.ephemeralSharedSecret, eccSharedSecret.authSharedSecret, kyberSharedSecret)\n\n\t\tconst kekBytes = hkdf(context, inputKeyMaterial, stringToUtf8Uint8Array(\"kek\"), KEY_LENGTH_BYTES_AES_256)\n\t\treturn uint8ArrayToKey(kekBytes)\n\t}\n}\n","import { EntityClient } from \"../../common/EntityClient.js\"\nimport { AesKey, AsymmetricKeyPair, decryptKey, decryptKeyPair, EncryptedKeyPairs } from \"@tutao/tutanota-crypto\"\nimport { Group, GroupKey, GroupKeyTypeRef, GroupTypeRef, KeyPair } from \"../../entities/sys/TypeRefs.js\"\nimport { Versioned } from \"@tutao/tutanota-utils/dist/Utils.js\"\nimport { UserFacade } from \"./UserFacade.js\"\nimport { NotFoundError } from \"../../common/error/RestError.js\"\nimport { customIdToString, getElementId, isSameId, stringToCustomId } from \"../../common/utils/EntityUtils.js\"\nimport { KeyCache } from \"./KeyCache.js\"\nimport { assertNotNull, lazyAsync } from \"@tutao/tutanota-utils\"\nimport { CacheManagementFacade } from \"./lazy/CacheManagementFacade.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { VersionedKey } from \"../crypto/CryptoWrapper.js\"\n\n/**\n * Load symmetric and asymmetric keys and decrypt them.\n * Handle group key versioning.\n */\nexport class KeyLoaderFacade {\n\tconstructor(\n\t\tprivate readonly keyCache: KeyCache,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly cacheManagementFacade: lazyAsync<CacheManagementFacade>,\n\t) {}\n\n\t/**\n\t * Load the symmetric group key for the groupId with the provided requestedVersion.\n\t * @param groupId the id of the group\n\t * @param requestedVersion the requestedVersion of the key to be loaded\n\t * @param currentGroupKey needs to be set if the user is not a member of the group (e.g. an admin)\n\t */\n\tasync loadSymGroupKey(groupId: Id, requestedVersion: number, currentGroupKey?: VersionedKey): Promise<AesKey> {\n\t\tif (currentGroupKey != null && currentGroupKey.version < requestedVersion) {\n\t\t\t// we might not have the membership for this group. so the caller needs to handle it by refreshing the cache\n\t\t\tthrow new Error(\n\t\t\t\t`Provided current group key is too old (${currentGroupKey.version}) to load the requested version ${requestedVersion} for group ${groupId}`,\n\t\t\t)\n\t\t}\n\t\tconst groupKey = currentGroupKey ?? (await this.getCurrentSymGroupKey(groupId))\n\n\t\tif (groupKey.version === requestedVersion) {\n\t\t\treturn groupKey.object\n\t\t} else if (groupKey.version < requestedVersion) {\n\t\t\t// the latest key is not cached, so we update the user and try again\n\t\t\t// this can still fail as we might be too slow with processing some update e.g. a GroupKeyUpdate\n\t\t\t// (we are member of a shared group rotated by someone else and the new membership is not yet on the user)\n\t\t\tawait (await this.cacheManagementFacade()).refreshKeyCache(groupId)\n\t\t\t// There is no point in re-trying with the outdated current group key\n\t\t\tconst refreshedGroupKey = await this.getCurrentSymGroupKey(groupId) // we pass the currentGroupKey to break the recursion\n\t\t\treturn this.loadSymGroupKey(groupId, requestedVersion, refreshedGroupKey)\n\t\t} else {\n\t\t\t// we load a former key as the cached one is newer: groupKey.requestedVersion > requestedVersion\n\t\t\tconst group = await this.entityClient.load(GroupTypeRef, groupId)\n\t\t\tconst { symmetricGroupKey } = await this.findFormerGroupKey(group, groupKey, requestedVersion)\n\t\t\treturn symmetricGroupKey\n\t\t}\n\t}\n\n\tasync getCurrentSymGroupKey(groupId: Id): Promise<VersionedKey> {\n\t\t// The current user group key should not be included in the map of current keys, because we only keep a copy in userFacade\n\t\tif (isSameId(groupId, this.userFacade.getUserGroupId())) {\n\t\t\treturn this.getCurrentSymUserGroupKey()\n\t\t}\n\t\treturn this.keyCache.getCurrentGroupKey(groupId, () => this.loadAndDecryptCurrentSymGroupKey(groupId))\n\t}\n\n\tasync loadSymUserGroupKey(requestedVersion: number): Promise<AesKey> {\n\t\t// we provide the current user group key to break a possibly infinite recursion\n\t\tlet currentUserGroupKey = this.getCurrentSymUserGroupKey()\n\t\tif (currentUserGroupKey.version < requestedVersion) {\n\t\t\tawait (await this.cacheManagementFacade()).refreshKeyCache(this.userFacade.getUserGroupId())\n\t\t\tcurrentUserGroupKey = this.getCurrentSymUserGroupKey()\n\t\t\t// if the key is still outdated loadSymGroupKey will throw - we tried our best.\n\t\t}\n\t\treturn this.loadSymGroupKey(this.userFacade.getUserGroupId(), requestedVersion, currentUserGroupKey)\n\t}\n\n\tgetCurrentSymUserGroupKey(): VersionedKey {\n\t\treturn this.userFacade.getCurrentUserGroupKey()\n\t}\n\n\tasync loadKeypair(keyPairGroupId: Id, requestedVersion: number): Promise<AsymmetricKeyPair> {\n\t\tlet group = await this.entityClient.load(GroupTypeRef, keyPairGroupId)\n\t\tlet currentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId)\n\n\t\tif (requestedVersion > currentGroupKey.version) {\n\t\t\tgroup = (await (await this.cacheManagementFacade()).refreshKeyCache(keyPairGroupId)).group\n\t\t\tcurrentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId)\n\t\t}\n\t\treturn await this.loadKeyPairImpl(group, requestedVersion, currentGroupKey)\n\t}\n\n\tasync loadCurrentKeyPair(groupId: Id): Promise<Versioned<AsymmetricKeyPair>> {\n\t\tlet group = await this.entityClient.load(GroupTypeRef, groupId)\n\n\t\tlet currentGroupKey = await this.getCurrentSymGroupKey(groupId)\n\t\tif (Number(group.groupKeyVersion) !== currentGroupKey.version) {\n\t\t\t// There is a race condition after rotating the group key were the group entity in the cache is not in sync with current key version in the key cache.\n\t\t\t// group.groupKeyVersion might be newer than currentGroupKey.version.\n\t\t\t// We reload group and user and refresh entity and key cache to synchronize both caches.\n\t\t\tgroup = (await (await this.cacheManagementFacade()).refreshKeyCache(groupId)).group\n\t\t\tcurrentGroupKey = await this.getCurrentSymGroupKey(groupId)\n\t\t\tif (Number(group.groupKeyVersion) !== currentGroupKey.version) {\n\t\t\t\t// we still do not have the proper state to get the current key pair\n\t\t\t\tthrow new Error(`inconsistent key version state in cache and key cache for group ${groupId}`)\n\t\t\t}\n\t\t}\n\t\treturn { object: this.validateAndDecryptKeyPair(group.currentKeys, groupId, currentGroupKey.object), version: Number(group.groupKeyVersion) }\n\t}\n\n\tprivate async loadKeyPairImpl(group: Group, requestedVersion: number, currentGroupKey: VersionedKey) {\n\t\tconst keyPairGroupId = group._id\n\t\tlet keyPair: KeyPair | null\n\t\tlet symGroupKey: AesKey\n\t\tif (requestedVersion > currentGroupKey.version) {\n\t\t\tthrow new Error(`Not possible to get newer key version than is cached for group ${keyPairGroupId}`)\n\t\t} else if (requestedVersion === currentGroupKey.version) {\n\t\t\tsymGroupKey = currentGroupKey.object\n\t\t\tif (Number(group.groupKeyVersion) === currentGroupKey.version) {\n\t\t\t\tkeyPair = group.currentKeys\n\t\t\t} else {\n\t\t\t\tconst formerKeysList = assertNotNull(group.formerGroupKeys).list\n\t\t\t\t// we load by the version and thus can be sure that we are able to decrypt this key\n\t\t\t\tconst formerGroupKey = await this.entityClient.load(GroupKeyTypeRef, [formerKeysList, stringToCustomId(String(currentGroupKey.version))])\n\t\t\t\tkeyPair = formerGroupKey.keyPair\n\t\t\t}\n\t\t} else {\n\t\t\t// load a former key pair: groupKeyVersion < groupKey.version\n\t\t\tconst { symmetricGroupKey, groupKeyInstance } = await this.findFormerGroupKey(group, currentGroupKey, requestedVersion)\n\t\t\tkeyPair = groupKeyInstance.keyPair\n\t\t\tsymGroupKey = symmetricGroupKey\n\t\t}\n\t\treturn this.validateAndDecryptKeyPair(keyPair, keyPairGroupId, symGroupKey)\n\t}\n\n\t/**\n\t *\n\t * @param groupId MUST NOT be the user group id!\n\t * @private\n\t */\n\tprivate async loadAndDecryptCurrentSymGroupKey(groupId: Id) {\n\t\tif (isSameId(groupId, this.userFacade.getUserGroupId())) {\n\t\t\tthrow new ProgrammingError(\"Must not add the user group to the regular group key cache\")\n\t\t}\n\t\tconst groupMembership = this.userFacade.getMembership(groupId)\n\t\tconst requiredUserGroupKey = await this.loadSymUserGroupKey(Number(groupMembership.symKeyVersion))\n\t\treturn {\n\t\t\tversion: Number(groupMembership.groupKeyVersion),\n\t\t\tobject: decryptKey(requiredUserGroupKey, groupMembership.symEncGKey),\n\t\t}\n\t}\n\n\tprivate async findFormerGroupKey(\n\t\tgroup: Group,\n\t\tcurrentGroupKey: VersionedKey,\n\t\ttargetKeyVersion: number,\n\t): Promise<{ symmetricGroupKey: AesKey; groupKeyInstance: GroupKey }> {\n\t\tconst formerKeysList = assertNotNull(group.formerGroupKeys).list\n\t\t// start id is not included in the result of the range request, so we need to start at current version.\n\t\tconst startId = stringToCustomId(String(currentGroupKey.version))\n\t\tconst amountOfKeysIncludingTarget = currentGroupKey.version - targetKeyVersion\n\n\t\tconst formerKeys: GroupKey[] = await this.entityClient.loadRange(GroupKeyTypeRef, formerKeysList, startId, amountOfKeysIncludingTarget, true)\n\n\t\tlet lastVersion = currentGroupKey.version\n\t\tlet lastGroupKey = currentGroupKey.object\n\t\tlet lastGroupKeyInstance: GroupKey | null = null\n\n\t\tfor (const formerKey of formerKeys) {\n\t\t\tconst version = this.decodeGroupKeyVersion(getElementId(formerKey))\n\t\t\tif (version + 1 > lastVersion) {\n\t\t\t\tcontinue\n\t\t\t} else if (version + 1 === lastVersion) {\n\t\t\t\tlastGroupKey = decryptKey(lastGroupKey, formerKey.ownerEncGKey)\n\t\t\t\tlastVersion = version\n\t\t\t\tlastGroupKeyInstance = formerKey\n\t\t\t\tif (lastVersion <= targetKeyVersion) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(`unexpected version ${version}; expected ${lastVersion}`)\n\t\t\t}\n\t\t}\n\n\t\tif (lastVersion !== targetKeyVersion || !lastGroupKeyInstance) {\n\t\t\tthrow new Error(`could not get version (last version is ${lastVersion} of ${formerKeys.length} key(s) loaded from list ${formerKeysList})`)\n\t\t}\n\n\t\treturn { symmetricGroupKey: lastGroupKey, groupKeyInstance: lastGroupKeyInstance }\n\t}\n\n\tprivate decodeGroupKeyVersion(id: Id): number {\n\t\treturn Number(customIdToString(id))\n\t}\n\n\tprivate validateAndDecryptKeyPair(keyPair: KeyPair | null, groupId: Id, groupKey: AesKey) {\n\t\tif (keyPair == null) {\n\t\t\tthrow new NotFoundError(`no key pair on group ${groupId}`)\n\t\t}\n\t\t// this cast is acceptable as those are the constraints we have on KeyPair. we just cannot know which one we have statically\n\t\treturn decryptKeyPair(groupKey, keyPair as EncryptedKeyPairs)\n\t}\n}\n","import { EntityClient } from \"../../common/EntityClient.js\"\nimport {\n\tAdminGroupKeyAuthenticationData,\n\tAdminGroupKeyRotationPostIn,\n\tcreateAdminGroupKeyAuthenticationData,\n\tcreateAdminGroupKeyRotationPostIn,\n\tcreateGroupKeyRotationData,\n\tcreateGroupKeyRotationPostIn,\n\tcreateGroupKeyUpdateData,\n\tcreateGroupMembershipKeyData,\n\tcreateGroupMembershipUpdateData,\n\tcreateKeyPair,\n\tcreateMembershipPutIn,\n\tcreatePubEncKeyData,\n\tcreatePublicKeyGetIn,\n\tcreateRecoverCodeData,\n\tcreateUserGroupKeyRotationData,\n\tcreateUserGroupKeyRotationPostIn,\n\tCustomerTypeRef,\n\tGroup,\n\tGroupInfoTypeRef,\n\tGroupKeyRotationData,\n\tGroupKeyUpdate,\n\tGroupKeyUpdateData,\n\tGroupKeyUpdateTypeRef,\n\tGroupMember,\n\tGroupMembershipKeyData,\n\tGroupMembershipUpdateData,\n\tGroupMemberTypeRef,\n\tGroupTypeRef,\n\tKeyPair,\n\tKeyRotation,\n\tKeyRotationTypeRef,\n\tPubEncKeyData,\n\tPublicKeyGetOut,\n\tRecoverCodeData,\n\tSentGroupInvitationTypeRef,\n\tUser,\n\tUserGroupRootTypeRef,\n\tUserTypeRef,\n} from \"../../entities/sys/TypeRefs.js\"\nimport { assertEnumValue, GroupKeyRotationType, GroupType, PublicKeyIdentifierType } from \"../../common/TutanotaConstants.js\"\nimport {\n\tarrayEquals,\n\tassertNotNull,\n\tconcat,\n\tdefer,\n\tDeferredObject,\n\tdowncast,\n\tgetFirstOrThrow,\n\tgroupBy,\n\tisEmpty,\n\tisNotNull,\n\tisSameTypeRef,\n\tlazyAsync,\n\tpromiseMap,\n\tVersioned,\n} from \"@tutao/tutanota-utils\"\nimport { customIdToUint8array, elementIdPart, isSameId, listIdPart } from \"../../common/utils/EntityUtils.js\"\nimport { KeyLoaderFacade } from \"./KeyLoaderFacade.js\"\nimport {\n\tAes256Key,\n\tAesKey,\n\tbitArrayToUint8Array,\n\tcreateAuthVerifier,\n\tEncryptedPqKeyPairs,\n\tgetKeyLengthBytes,\n\tKEY_LENGTH_BYTES_AES_256,\n\tPQKeyPairs,\n\tuint8ArrayToKey,\n} from \"@tutao/tutanota-crypto\"\nimport { PQFacade } from \"./PQFacade.js\"\nimport {\n\tAdminGroupKeyRotationService,\n\tGroupKeyRotationInfoService,\n\tGroupKeyRotationService,\n\tMembershipService,\n\tPublicKeyService,\n\tUserGroupKeyRotationService,\n} from \"../../entities/sys/Services.js\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest.js\"\nimport { CryptoFacade } from \"../crypto/CryptoFacade.js\"\nimport { assertWorkerOrNode } from \"../../common/Env.js\"\nimport { CryptoWrapper, VersionedEncryptedKey, VersionedKey } from \"../crypto/CryptoWrapper.js\"\nimport { getUserGroupMemberships } from \"../../common/utils/GroupUtils.js\"\nimport { RecoverCodeFacade } from \"./lazy/RecoverCodeFacade.js\"\nimport { UserFacade } from \"./UserFacade.js\"\nimport { GroupInvitationPostData, type InternalRecipientKeyData, InternalRecipientKeyDataTypeRef } from \"../../entities/tutanota/TypeRefs.js\"\nimport { ShareFacade } from \"./lazy/ShareFacade.js\"\nimport { GroupManagementFacade } from \"./lazy/GroupManagementFacade.js\"\nimport { RecipientsNotFoundError } from \"../../common/error/RecipientsNotFoundError.js\"\nimport { LockedError } from \"../../common/error/RestError.js\"\nimport { AsymmetricCryptoFacade, PublicKeys } from \"../crypto/AsymmetricCryptoFacade.js\"\n\nassertWorkerOrNode()\n\n/**\n * Type to keep a pending key rotation and the password key in memory as long as the key rotation has not been processed.\n */\ntype PendingKeyRotation = {\n\tpwKey: Aes256Key | null\n\t//If we rotate the admin group we always want to rotate the user group for the admin user.\n\t// Therefore, we do not need to save two different key rotations for this case.\n\tadminOrUserGroupKeyRotation: KeyRotation | null\n\tteamOrCustomerGroupKeyRotations: Array<KeyRotation>\n\tuserAreaGroupsKeyRotations: Array<KeyRotation>\n}\n\ntype PreparedUserAreaGroupKeyRotation = {\n\tgroupKeyRotationData: GroupKeyRotationData\n\tpreparedReInvitations: GroupInvitationPostData[]\n}\n\ntype GeneratedGroupKeys = {\n\tsymGroupKey: VersionedKey\n\tencryptedKeyPair: EncryptedPqKeyPairs | null\n}\n\ntype EncryptedGroupKeys = {\n\tnewGroupKeyEncCurrentGroupKey: VersionedEncryptedKey\n\tkeyPair: EncryptedPqKeyPairs | null\n\tadminGroupKeyEncNewGroupKey: VersionedEncryptedKey | null\n}\n\ntype EncryptedUserGroupKeys = {\n\tnewUserGroupKeyEncCurrentGroupKey: VersionedEncryptedKey\n\tpassphraseKeyEncNewUserGroupKey: VersionedEncryptedKey\n\tkeyPair: KeyPair\n\trecoverCodeData: RecoverCodeData | null\n\tnewAdminGroupKeyEncNewUserGroupKey: VersionedEncryptedKey\n\tdistributionKeyEncNewUserGroupKey: Uint8Array\n\tauthVerifier: Uint8Array\n}\n\n/**\n * Facade to handle key rotation requests. Maintains and processes @PendingKeyRotation\n */\nexport class KeyRotationFacade {\n\t/**\n\t * @VisibleForTesting\n\t */\n\tpendingKeyRotations: PendingKeyRotation\n\tprivate readonly facadeInitializedDeferredObject: DeferredObject<void>\n\tprivate pendingGroupKeyUpdateIds: IdTuple[] // already rotated groups for which we need to update the memberships (GroupKeyUpdateIds all in one list)\n\n\tconstructor(\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t\tprivate readonly pqFacade: PQFacade,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly cryptoWrapper: CryptoWrapper,\n\t\tprivate readonly recoverCodeFacade: lazyAsync<RecoverCodeFacade>,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly shareFacade: lazyAsync<ShareFacade>,\n\t\tprivate readonly groupManagementFacade: lazyAsync<GroupManagementFacade>,\n\t\tprivate readonly asymmetricCryptoFacade: AsymmetricCryptoFacade,\n\t) {\n\t\tthis.pendingKeyRotations = {\n\t\t\tpwKey: null,\n\t\t\tadminOrUserGroupKeyRotation: null,\n\t\t\tteamOrCustomerGroupKeyRotations: [],\n\t\t\tuserAreaGroupsKeyRotations: [],\n\t\t}\n\t\tthis.facadeInitializedDeferredObject = defer<void>()\n\t\tthis.pendingGroupKeyUpdateIds = []\n\t}\n\n\t/**\n\t * Initialize the facade with the data it needs to perform rotations later.\n\t * Needs to be called during login when the password key is still available.\n\t * @param pwKey the user's passphrase key. May or may not be kept in memory, depending on whether a UserGroup key rotation is scheduled.\n\t * @param modernKdfType true if argon2id. no admin or user key rotation should be executed if false.\n\t */\n\tpublic async initialize(pwKey: Aes256Key, modernKdfType: boolean) {\n\t\tconst result = await this.serviceExecutor.get(GroupKeyRotationInfoService, null)\n\t\tif (result.userOrAdminGroupKeyRotationScheduled && modernKdfType) {\n\t\t\t// If we have not migrated to argon2 we postpone key rotation until next login.\n\t\t\tthis.pendingKeyRotations.pwKey = pwKey\n\t\t}\n\t\tthis.pendingGroupKeyUpdateIds = result.groupKeyUpdates\n\t\tthis.facadeInitializedDeferredObject.resolve()\n\t}\n\n\t/**\n\t * Processes pending key rotations and performs follow-up tasks such as updating memberships for groups rotated by another user.\n\t * @param user\n\t */\n\tasync processPendingKeyRotationsAndUpdates(user: User): Promise<void> {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait this.loadPendingKeyRotations(user)\n\t\t\t\tawait this.processPendingKeyRotation(user)\n\t\t\t} finally {\n\t\t\t\t// we still try updating memberships if there was an error with rotations\n\t\t\t\tawait this.updateGroupMemberships(this.pendingGroupKeyUpdateIds)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof LockedError) {\n\t\t\t\t// we catch here so that we also catch errors in the finally block\n\t\t\t\tconsole.log(\"error when processing key rotation or group key update\", e)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Queries the server for pending key rotations for a given user and saves them and optionally the given password key (in case an admin or user group needs to be rotated).\n\t *\n\t * Note that this function currently makes 2 server requests to load the key rotation list and check if a key rotation is needed.\n\t * This routine should be optimized in the future by saving a flag on the user to determine whether a key rotation is required or not.\n\t * @VisibleForTesting\n\t */\n\tasync loadPendingKeyRotations(user: User) {\n\t\tconst userGroupRoot = await this.entityClient.load(UserGroupRootTypeRef, user.userGroup.group)\n\t\tif (userGroupRoot.keyRotations != null) {\n\t\t\tconst pendingKeyRotations = await this.entityClient.loadAll(KeyRotationTypeRef, userGroupRoot.keyRotations.list)\n\t\t\tconst keyRotationsByType = groupBy(pendingKeyRotations, (keyRotation) => keyRotation.groupKeyRotationType)\n\t\t\tlet adminOrUserGroupKeyRotationArray: Array<KeyRotation> = [\n\t\t\t\tkeyRotationsByType.get(GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount),\n\t\t\t\tkeyRotationsByType.get(GroupKeyRotationType.AdminGroupKeyRotationMultipleUserAccount),\n\t\t\t\tkeyRotationsByType.get(GroupKeyRotationType.AdminGroupKeyRotationMultipleAdminAccount),\n\t\t\t\tkeyRotationsByType.get(GroupKeyRotationType.User),\n\t\t\t]\n\t\t\t\t.flat()\n\t\t\t\t.filter(isNotNull)\n\t\t\tlet customerGroupKeyRotationArray = keyRotationsByType.get(GroupKeyRotationType.Customer) || []\n\t\t\tconst adminOrUserGroupKeyRotation = adminOrUserGroupKeyRotationArray[0]\n\t\t\tthis.pendingKeyRotations = {\n\t\t\t\tpwKey: this.pendingKeyRotations.pwKey,\n\t\t\t\tadminOrUserGroupKeyRotation: adminOrUserGroupKeyRotation ? adminOrUserGroupKeyRotation : null,\n\t\t\t\tteamOrCustomerGroupKeyRotations: customerGroupKeyRotationArray.concat(keyRotationsByType.get(GroupKeyRotationType.Team) || []),\n\t\t\t\tuserAreaGroupsKeyRotations: keyRotationsByType.get(GroupKeyRotationType.UserArea) || [],\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Processes the internal list of @PendingKeyRotation. Key rotations and (if existent) password keys are deleted after processing.\n\t * @VisibleForTesting\n\t */\n\tasync processPendingKeyRotation(user: User) {\n\t\tawait this.facadeInitializedDeferredObject.promise\n\t\t// first admin, then user and then user area\n\t\ttry {\n\t\t\tif (this.pendingKeyRotations.adminOrUserGroupKeyRotation && this.pendingKeyRotations.pwKey) {\n\t\t\t\tconst groupKeyRotationType = assertEnumValue(GroupKeyRotationType, this.pendingKeyRotations.adminOrUserGroupKeyRotation.groupKeyRotationType)\n\t\t\t\tswitch (groupKeyRotationType) {\n\t\t\t\t\tcase GroupKeyRotationType.AdminGroupKeyRotationMultipleAdminAccount:\n\t\t\t\t\t\tconsole.log(\"Rotating the admin group with multiple members is not yet implemented\")\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount:\n\t\t\t\t\tcase GroupKeyRotationType.AdminGroupKeyRotationMultipleUserAccount:\n\t\t\t\t\t\tawait this.rotateAdminGroupKeys(user, this.pendingKeyRotations.pwKey, this.pendingKeyRotations.adminOrUserGroupKeyRotation)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase GroupKeyRotationType.User:\n\t\t\t\t\t\tawait this.rotateUserGroupKey(user, this.pendingKeyRotations.pwKey, this.pendingKeyRotations.adminOrUserGroupKeyRotation)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tthis.pendingKeyRotations.adminOrUserGroupKeyRotation = null\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.pendingKeyRotations.pwKey = null\n\t\t}\n\n\t\t//user area, team and customer key rotations are send in a single request, so that they can be processed in parallel\n\t\tconst serviceData = createGroupKeyRotationPostIn({ groupKeyUpdates: [] })\n\t\tif (!isEmpty(this.pendingKeyRotations.teamOrCustomerGroupKeyRotations)) {\n\t\t\tconst groupKeyRotationData = await this.rotateCustomerOrTeamGroupKeys(user)\n\t\t\tif (groupKeyRotationData != null) {\n\t\t\t\tserviceData.groupKeyUpdates = groupKeyRotationData\n\t\t\t}\n\t\t\tthis.pendingKeyRotations.teamOrCustomerGroupKeyRotations = []\n\t\t}\n\n\t\tlet invitationData: GroupInvitationPostData[] = []\n\t\tif (!isEmpty(this.pendingKeyRotations.userAreaGroupsKeyRotations)) {\n\t\t\tconst { groupKeyRotationData, preparedReInvites } = await this.rotateUserAreaGroupKeys(user)\n\t\t\tinvitationData = preparedReInvites\n\t\t\tif (groupKeyRotationData != null) {\n\t\t\t\tserviceData.groupKeyUpdates = serviceData.groupKeyUpdates.concat(groupKeyRotationData)\n\t\t\t}\n\t\t\tthis.pendingKeyRotations.userAreaGroupsKeyRotations = []\n\t\t}\n\t\tif (serviceData.groupKeyUpdates.length <= 0) {\n\t\t\treturn\n\t\t}\n\t\tawait this.serviceExecutor.post(GroupKeyRotationService, serviceData)\n\n\t\tif (!isEmpty(invitationData)) {\n\t\t\tconst shareFacade = await this.shareFacade()\n\t\t\tawait promiseMap(invitationData, (preparedInvite) => shareFacade.sendGroupInvitationRequest(preparedInvite))\n\t\t}\n\t}\n\n\t/**\n\t * @VisibleForTesting\n\t */\n\tasync rotateAdminGroupKeys(user: User, passphraseKey: Aes256Key, keyRotation: KeyRotation) {\n\t\tif (hasNonQuantumSafeKeys(passphraseKey)) {\n\t\t\tconsole.log(\"Not allowed to rotate admin group keys with a bcrypt password key\")\n\t\t\treturn\n\t\t}\n\t\tconst currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey()\n\t\tconst adminGroupMembership = getFirstOrThrow(getUserGroupMemberships(user, GroupType.Admin))\n\t\tconst currentAdminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupMembership.group)\n\t\tconst adminKeyRotationData = await this.prepareKeyRotationForAdminGroup(keyRotation, user, currentUserGroupKey, currentAdminGroupKey, passphraseKey)\n\t\treturn this.serviceExecutor.post(AdminGroupKeyRotationService, adminKeyRotationData)\n\t}\n\n\t//We assume that the logged-in user is an admin user and that the key encrypting the group key are already pq secure\n\tprivate async rotateUserAreaGroupKeys(user: User): Promise<{\n\t\tgroupKeyRotationData: GroupKeyRotationData[]\n\t\tpreparedReInvites: GroupInvitationPostData[]\n\t}> {\n\t\t// * the encrypting keys are 128-bit keys. (user group key)\n\t\tconst currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey()\n\t\tif (hasNonQuantumSafeKeys(currentUserGroupKey.object)) {\n\t\t\t// user or admin group key rotation should be scheduled first on the server, so this should not happen\n\t\t\tconsole.log(\"Keys cannot be rotated as the encrypting keys are not pq secure\")\n\t\t\treturn { groupKeyRotationData: [], preparedReInvites: [] }\n\t\t}\n\n\t\tconst groupKeyUpdates = new Array<GroupKeyRotationData>()\n\t\tlet preparedReInvites: GroupInvitationPostData[] = []\n\t\tfor (const keyRotation of this.pendingKeyRotations.userAreaGroupsKeyRotations) {\n\t\t\tconst { groupKeyRotationData, preparedReInvitations } = await this.prepareKeyRotationForAreaGroup(keyRotation, currentUserGroupKey, user)\n\t\t\tgroupKeyUpdates.push(groupKeyRotationData)\n\t\t\tpreparedReInvites = preparedReInvites.concat(preparedReInvitations)\n\t\t}\n\n\t\treturn { groupKeyRotationData: groupKeyUpdates, preparedReInvites }\n\t}\n\n\t//We assume that the logged-in user is an admin user and that the key encrypting the group key are already pq secure\n\tprivate async rotateCustomerOrTeamGroupKeys(user: User) {\n\t\t//group key rotation is skipped if\n\t\t// * user is not an admin user\n\t\tconst adminGroupMembership = user.memberships.find((m) => m.groupType === GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount)\n\t\tif (adminGroupMembership == null) {\n\t\t\tconsole.log(\"Only admin user can rotate the group\")\n\t\t\treturn\n\t\t}\n\n\t\t// * the encrypting keys are 128-bit keys. (user group key, admin group key)\n\t\tconst currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey()\n\t\tconst currentAdminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupMembership.group)\n\t\tif (hasNonQuantumSafeKeys(currentUserGroupKey.object, currentAdminGroupKey.object)) {\n\t\t\t// admin group key rotation should be scheduled first on the server, so this should not happen\n\t\t\tconsole.log(\"Keys cannot be rotated as the encrypting keys are not pq secure\")\n\t\t\treturn\n\t\t}\n\n\t\tconst groupKeyUpdates = new Array<GroupKeyRotationData>()\n\t\tfor (const keyRotation of this.pendingKeyRotations.teamOrCustomerGroupKeyRotations) {\n\t\t\tconst groupKeyRotationData = await this.prepareKeyRotationForCustomerOrTeamGroup(keyRotation, currentUserGroupKey, currentAdminGroupKey, user)\n\t\t\tgroupKeyUpdates.push(groupKeyRotationData)\n\t\t}\n\t\treturn groupKeyUpdates\n\t}\n\n\tprivate async prepareKeyRotationForAdminGroup(\n\t\tkeyRotation: KeyRotation,\n\t\tuser: User,\n\t\tcurrentUserGroupKey: VersionedKey,\n\t\tcurrentAdminGroupKey: VersionedKey,\n\t\tpassphraseKey: Aes256Key,\n\t): Promise<AdminGroupKeyRotationPostIn> {\n\t\tconst adminGroupId = this.getTargetGroupId(keyRotation)\n\t\tconst userGroupMembership = user.userGroup\n\t\tconst userGroupId = userGroupMembership.group\n\t\tconsole.log(`KeyRotationFacade: rotate key for group: ${adminGroupId}, groupKeyRotationType: ${keyRotation.groupKeyRotationType}`)\n\n\t\tconst adminGroup = await this.entityClient.load(GroupTypeRef, adminGroupId)\n\t\tconst userGroup = await this.entityClient.load(GroupTypeRef, userGroupId)\n\n\t\tconst newAdminGroupKeys = await this.generateGroupKeys(adminGroup)\n\t\tconst adminKeyPair = assertNotNull(newAdminGroupKeys.encryptedKeyPair)\n\t\tconst pubEccKey = assertNotNull(adminKeyPair.pubEccKey)\n\t\tconst pubKyberKey = assertNotNull(adminKeyPair.pubKyberKey)\n\t\tconst adminGroupKeyAuthenticationDataList = await this.generateEncryptedKeyHashes(\n\t\t\tpubEccKey,\n\t\t\tpubKyberKey,\n\t\t\tnewAdminGroupKeys.symGroupKey.version,\n\t\t\tadminGroupId,\n\t\t\tassertNotNull(user.customer),\n\t\t\tuserGroupId,\n\t\t)\n\n\t\tconst newUserGroupKeys = await this.generateGroupKeys(userGroup)\n\t\tconst encryptedAdminKeys = await this.encryptGroupKeys(adminGroup, currentAdminGroupKey, newAdminGroupKeys, newAdminGroupKeys.symGroupKey)\n\t\tconst encryptedUserKeys = await this.encryptUserGroupKey(userGroup, currentUserGroupKey, newUserGroupKeys, passphraseKey, newAdminGroupKeys, user)\n\t\tconst membershipEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newUserGroupKeys.symGroupKey, newAdminGroupKeys.symGroupKey.object)\n\n\t\tconst adminGroupKeyData = createGroupKeyRotationData({\n\t\t\tadminGroupEncGroupKey: assertNotNull(encryptedAdminKeys.adminGroupKeyEncNewGroupKey).key,\n\t\t\tadminGroupKeyVersion: String(assertNotNull(encryptedAdminKeys.adminGroupKeyEncNewGroupKey).encryptingKeyVersion),\n\t\t\tgroupEncPreviousGroupKey: encryptedAdminKeys.newGroupKeyEncCurrentGroupKey.key,\n\t\t\tgroupKeyVersion: String(newAdminGroupKeys.symGroupKey.version),\n\t\t\tgroup: adminGroup._id,\n\t\t\tkeyPair: makeKeyPair(encryptedAdminKeys.keyPair),\n\t\t\tgroupKeyUpdatesForMembers: [], // we only rotated for admin groups with only one member,\n\t\t\tgroupMembershipUpdateData: [\n\t\t\t\tcreateGroupMembershipUpdateData({\n\t\t\t\t\tuserId: user._id,\n\t\t\t\t\tuserEncGroupKey: membershipEncNewGroupKey.key,\n\t\t\t\t\tuserKeyVersion: String(membershipEncNewGroupKey.encryptingKeyVersion),\n\t\t\t\t}),\n\t\t\t],\n\t\t})\n\n\t\tconst userGroupKeyData = createUserGroupKeyRotationData({\n\t\t\trecoverCodeData: encryptedUserKeys.recoverCodeData,\n\t\t\tdistributionKeyEncUserGroupKey: encryptedUserKeys.distributionKeyEncNewUserGroupKey,\n\t\t\tauthVerifier: encryptedUserKeys.authVerifier,\n\t\t\tgroup: userGroup._id,\n\t\t\tuserGroupEncPreviousGroupKey: encryptedUserKeys.newUserGroupKeyEncCurrentGroupKey.key,\n\t\t\tuserGroupKeyVersion: String(newUserGroupKeys.symGroupKey.version),\n\t\t\tkeyPair: encryptedUserKeys.keyPair,\n\t\t\tadminGroupEncUserGroupKey: encryptedUserKeys.newAdminGroupKeyEncNewUserGroupKey.key,\n\t\t\tadminGroupKeyVersion: String(encryptedUserKeys.newAdminGroupKeyEncNewUserGroupKey.encryptingKeyVersion),\n\t\t\tpassphraseEncUserGroupKey: encryptedUserKeys.passphraseKeyEncNewUserGroupKey.key,\n\t\t\tpubAdminGroupEncUserGroupKey: null,\n\t\t})\n\n\t\treturn createAdminGroupKeyRotationPostIn({ adminGroupKeyData, userGroupKeyData, adminGroupKeyAuthenticationDataList })\n\t}\n\n\tprivate async generateEncryptedKeyHashes(\n\t\tpubEccKey: Uint8Array,\n\t\tpubKyberKey: Uint8Array,\n\t\tadminGroupKeyVersion: number,\n\t\tadminGroupId: Id,\n\t\tcustomerId: Id,\n\t\tgroupToExclude: Id,\n\t): Promise<Array<AdminGroupKeyAuthenticationData>> {\n\t\tconst keyHash = this.generateKeyHash(adminGroupKeyVersion, adminGroupId, pubEccKey, pubKyberKey)\n\t\tconst keyHashes: AdminGroupKeyAuthenticationData[] = []\n\n\t\tconst customer = await this.entityClient.load(CustomerTypeRef, customerId)\n\t\tconst userGroupInfos = await this.entityClient.loadAll(GroupInfoTypeRef, customer.userGroups)\n\n\t\tfor (const userGroupInfo of userGroupInfos) {\n\t\t\tif (isSameId(userGroupInfo.group, groupToExclude)) continue\n\t\t\tlet gmf = await this.groupManagementFacade()\n\t\t\tconst userGroupKey = await gmf.getCurrentGroupKeyViaAdminEncGKey(userGroupInfo.group)\n\t\t\tconst authKey = this.deriveRotationHashKey(userGroupInfo.group, userGroupKey)\n\t\t\tconst encryptedKeyHash = this.cryptoWrapper.aesEncrypt(authKey, keyHash)\n\t\t\tconst publicKeyHash = createAdminGroupKeyAuthenticationData({\n\t\t\t\tuserGroup: userGroupInfo.group,\n\t\t\t\tauthKeyEncAdminRotationHash: encryptedKeyHash,\n\t\t\t\tversion: String(adminGroupKeyVersion),\n\t\t\t})\n\t\t\tkeyHashes.push(publicKeyHash)\n\t\t}\n\n\t\treturn keyHashes\n\t}\n\n\tprivate deriveRotationHashKey(userGroupId: Id, userGroupKey: VersionedKey) {\n\t\treturn this.cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: userGroupId,\n\t\t\tkey: userGroupKey.object,\n\t\t\tcontext: \"adminGroupKeyRotationHash\",\n\t\t})\n\t}\n\n\tprivate generateKeyHash(adminGroupKeyVersion: number, adminGroupId: string, pubEccKey: Uint8Array, pubKyberKey: Uint8Array) {\n\t\tconst versionByte = Uint8Array.from([0])\n\t\tconst adminKeyVersion = Uint8Array.from([adminGroupKeyVersion])\n\t\tconst identifierType = Uint8Array.from([Number(PublicKeyIdentifierType.GROUP_ID)])\n\t\tconst identifier = customIdToUint8array(adminGroupId) // also works for generated IDs\n\t\t//Format:  versionbyte, pubEccKey, pubKyberKey, groupKeyVersion, identifier, identifierType\n\t\tconst hashData = concat(versionByte, pubEccKey, pubKyberKey, adminKeyVersion, identifier, identifierType)\n\t\treturn this.cryptoWrapper.sha256Hash(hashData)\n\t}\n\n\tprivate async prepareKeyRotationForAreaGroup(\n\t\tkeyRotation: KeyRotation,\n\t\tcurrentUserGroupKey: VersionedKey,\n\t\tuser: User,\n\t): Promise<PreparedUserAreaGroupKeyRotation> {\n\t\tconst targetGroupId = this.getTargetGroupId(keyRotation)\n\t\tconsole.log(`KeyRotationFacade: rotate key for group: ${targetGroupId}, groupKeyRotationType: ${keyRotation.groupKeyRotationType}`)\n\t\tconst targetGroup = await this.entityClient.load(GroupTypeRef, targetGroupId)\n\t\tconst currentGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(targetGroupId)\n\n\t\tconst newGroupKeys = await this.generateGroupKeys(targetGroup)\n\t\tconst groupEncPreviousGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newGroupKeys.symGroupKey, currentGroupKey.object)\n\t\tconst membershipSymEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(currentUserGroupKey, newGroupKeys.symGroupKey.object)\n\t\tconst preparedReInvitations = await this.handlePendingInvitations(targetGroup, newGroupKeys.symGroupKey)\n\n\t\tconst groupKeyUpdatesForMembers = await this.createGroupKeyUpdatesForMembers(targetGroup, newGroupKeys.symGroupKey)\n\n\t\tconst groupKeyRotationData = createGroupKeyRotationData({\n\t\t\tadminGroupEncGroupKey: null, // for user area groups we do not have an adminGroupEncGroupKey so we set it always to null.\n\t\t\tadminGroupKeyVersion: null,\n\t\t\tgroup: targetGroupId,\n\t\t\tgroupKeyVersion: String(newGroupKeys.symGroupKey.version),\n\t\t\tgroupEncPreviousGroupKey: groupEncPreviousGroupKey.key,\n\t\t\tkeyPair: makeKeyPair(newGroupKeys.encryptedKeyPair),\n\t\t\tgroupKeyUpdatesForMembers,\n\t\t\tgroupMembershipUpdateData: [\n\t\t\t\tcreateGroupMembershipUpdateData({\n\t\t\t\t\tuserId: user._id,\n\t\t\t\t\tuserEncGroupKey: membershipSymEncNewGroupKey.key,\n\t\t\t\t\tuserKeyVersion: String(currentUserGroupKey.version),\n\t\t\t\t}),\n\t\t\t],\n\t\t})\n\t\treturn {\n\t\t\tgroupKeyRotationData,\n\t\t\tpreparedReInvitations,\n\t\t}\n\t}\n\n\tprivate async prepareKeyRotationForCustomerOrTeamGroup(\n\t\tkeyRotation: KeyRotation,\n\t\tcurrentUserGroupKey: VersionedKey,\n\t\tcurrentAdminGroupKey: VersionedKey,\n\t\tuser: User,\n\t) {\n\t\tconst targetGroupId = this.getTargetGroupId(keyRotation)\n\t\tconsole.log(`KeyRotationFacade: rotate key for group: ${targetGroupId}, groupKeyRotationType: ${keyRotation.groupKeyRotationType}`)\n\t\tconst targetGroup = await this.entityClient.load(GroupTypeRef, targetGroupId)\n\n\t\tconst members = await this.entityClient.loadAll(GroupMemberTypeRef, targetGroup.members)\n\t\tconst ownMember = members.find((member) => member.user == user._id)\n\t\tconst otherMembers = members.filter((member) => member.user != user._id)\n\t\tlet currentGroupKey = await this.getCurrentGroupKey(targetGroupId, targetGroup)\n\t\tconst newGroupKeys = await this.generateGroupKeys(targetGroup)\n\t\tconst encryptedGroupKeys = await this.encryptGroupKeys(targetGroup, currentGroupKey, newGroupKeys, currentAdminGroupKey)\n\n\t\tconst groupMembershipUpdateData = new Array<GroupMembershipUpdateData>()\n\n\t\t//for team groups the admin user might not be a member of the group\n\t\tif (ownMember) {\n\t\t\tconst membershipSymEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(currentUserGroupKey, newGroupKeys.symGroupKey.object)\n\t\t\tgroupMembershipUpdateData.push(\n\t\t\t\tcreateGroupMembershipUpdateData({\n\t\t\t\t\tuserId: user._id,\n\t\t\t\t\tuserEncGroupKey: membershipSymEncNewGroupKey.key,\n\t\t\t\t\tuserKeyVersion: String(currentUserGroupKey.version),\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t\tfor (const member of otherMembers) {\n\t\t\tconst userEncNewGroupKey: VersionedEncryptedKey = await this.encryptGroupKeyForOtherUsers(member.user, newGroupKeys.symGroupKey)\n\t\t\tlet groupMembershipUpdate = createGroupMembershipUpdateData({\n\t\t\t\tuserId: member.user,\n\t\t\t\tuserEncGroupKey: userEncNewGroupKey.key,\n\t\t\t\tuserKeyVersion: String(userEncNewGroupKey.encryptingKeyVersion),\n\t\t\t})\n\t\t\tgroupMembershipUpdateData.push(groupMembershipUpdate)\n\t\t}\n\n\t\treturn createGroupKeyRotationData({\n\t\t\tadminGroupEncGroupKey: encryptedGroupKeys.adminGroupKeyEncNewGroupKey ? encryptedGroupKeys.adminGroupKeyEncNewGroupKey.key : null,\n\t\t\tadminGroupKeyVersion: encryptedGroupKeys.adminGroupKeyEncNewGroupKey\n\t\t\t\t? String(encryptedGroupKeys.adminGroupKeyEncNewGroupKey.encryptingKeyVersion)\n\t\t\t\t: null,\n\t\t\tgroup: targetGroupId,\n\t\t\tgroupKeyVersion: String(newGroupKeys.symGroupKey.version),\n\t\t\tgroupEncPreviousGroupKey: encryptedGroupKeys.newGroupKeyEncCurrentGroupKey.key,\n\t\t\tkeyPair: makeKeyPair(encryptedGroupKeys.keyPair),\n\t\t\tgroupKeyUpdatesForMembers: [],\n\t\t\tgroupMembershipUpdateData: groupMembershipUpdateData,\n\t\t})\n\t}\n\n\tprivate async getCurrentGroupKey(targetGroupId: string, targetGroup: Group): Promise<VersionedKey> {\n\t\ttry {\n\t\t\treturn await this.keyLoaderFacade.getCurrentSymGroupKey(targetGroupId)\n\t\t} catch (e) {\n\t\t\t//if we cannot get/decrypt the group key via membership we try via adminEncGroupKey\n\t\t\tconst groupManagementFacade = await this.groupManagementFacade()\n\t\t\tconst currentKey = await groupManagementFacade.getGroupKeyViaAdminEncGKey(targetGroupId, Number(targetGroup.groupKeyVersion))\n\t\t\treturn { object: currentKey, version: Number(targetGroup.groupKeyVersion) }\n\t\t}\n\t}\n\n\tprivate async encryptUserGroupKey(\n\t\tuserGroup: Group,\n\t\tcurrentUserGroupKey: VersionedKey,\n\t\tnewUserGroupKeys: GeneratedGroupKeys,\n\t\tpassphraseKey: Aes256Key,\n\t\tnewAdminGroupKeys: GeneratedGroupKeys,\n\t\tuser: User,\n\t): Promise<EncryptedUserGroupKeys> {\n\t\tconst { membershipSymEncNewGroupKey, distributionKeyEncNewUserGroupKey, authVerifier } = this.encryptUserGroupKeyForUser(\n\t\t\tpassphraseKey,\n\t\t\tnewUserGroupKeys,\n\t\t\tuserGroup,\n\t\t\tcurrentUserGroupKey,\n\t\t)\n\n\t\tconst encryptedUserKeys = await this.encryptGroupKeys(userGroup, currentUserGroupKey, newUserGroupKeys, newAdminGroupKeys.symGroupKey)\n\t\tconst recoverCodeData = await this.reencryptRecoverCodeIfExists(user, passphraseKey, newUserGroupKeys)\n\n\t\treturn {\n\t\t\tnewUserGroupKeyEncCurrentGroupKey: encryptedUserKeys.newGroupKeyEncCurrentGroupKey,\n\t\t\tnewAdminGroupKeyEncNewUserGroupKey: assertNotNull(encryptedUserKeys.adminGroupKeyEncNewGroupKey),\n\t\t\tkeyPair: assertNotNull(makeKeyPair(encryptedUserKeys.keyPair)),\n\t\t\tpassphraseKeyEncNewUserGroupKey: membershipSymEncNewGroupKey,\n\t\t\trecoverCodeData,\n\t\t\tdistributionKeyEncNewUserGroupKey,\n\t\t\tauthVerifier,\n\t\t}\n\t}\n\n\tprivate async reencryptRecoverCodeIfExists(user: User, passphraseKey: AesKey, newUserGroupKeys: GeneratedGroupKeys): Promise<RecoverCodeData | null> {\n\t\tlet recoverCodeData: RecoverCodeData | null = null\n\t\tif (user.auth?.recoverCode != null) {\n\t\t\tconst recoverCodeFacade = await this.recoverCodeFacade()\n\t\t\tconst recoverCode = await recoverCodeFacade.getRawRecoverCode(passphraseKey)\n\t\t\tconst recoverData = recoverCodeFacade.encryptRecoveryCode(recoverCode, newUserGroupKeys.symGroupKey)\n\t\t\trecoverCodeData = createRecoverCodeData({\n\t\t\t\trecoveryCodeVerifier: recoverData.recoveryCodeVerifier,\n\t\t\t\tuserEncRecoveryCode: recoverData.userEncRecoverCode,\n\t\t\t\tuserKeyVersion: String(recoverData.userKeyVersion),\n\t\t\t\trecoveryCodeEncUserGroupKey: recoverData.recoverCodeEncUserGroupKey,\n\t\t\t})\n\t\t}\n\t\treturn recoverCodeData\n\t}\n\n\tprivate encryptUserGroupKeyForUser(passphraseKey: AesKey, newUserGroupKeys: GeneratedGroupKeys, userGroup: Group, currentGroupKey: VersionedKey) {\n\t\tconst versionedPassphraseKey = {\n\t\t\tobject: passphraseKey,\n\t\t\tversion: 0, // dummy\n\t\t}\n\t\tconst membershipSymEncNewGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(versionedPassphraseKey, newUserGroupKeys.symGroupKey.object)\n\t\tconst userGroupKeyDistributionKey = this.userFacade.deriveUserGroupKeyDistributionKey(userGroup._id, passphraseKey)\n\t\tconst distributionKeyEncNewUserGroupKey = this.cryptoWrapper.encryptKey(userGroupKeyDistributionKey, newUserGroupKeys.symGroupKey.object)\n\t\tconst authVerifier = createAuthVerifier(passphraseKey)\n\t\tconst newGroupKeyEncCurrentGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newUserGroupKeys.symGroupKey, currentGroupKey.object)\n\t\treturn { membershipSymEncNewGroupKey, distributionKeyEncNewUserGroupKey, authVerifier, newGroupKeyEncCurrentGroupKey }\n\t}\n\n\tprivate async handlePendingInvitations(targetGroup: Group, newTargetGroupKey: VersionedKey) {\n\t\tconst preparedReInvitations: Array<GroupInvitationPostData> = []\n\t\tconst targetGroupInfo = await this.entityClient.load(GroupInfoTypeRef, targetGroup.groupInfo)\n\t\tconst pendingInvitations = await this.entityClient.loadAll(SentGroupInvitationTypeRef, targetGroup.invitations)\n\t\tconst sentInvitationsByCapability = groupBy(pendingInvitations, (invitation) => invitation.capability)\n\t\tconst shareFacade = await this.shareFacade()\n\t\tfor (const [capability, sentInvitations] of sentInvitationsByCapability) {\n\t\t\tconst inviteeMailAddresses = sentInvitations.map((invite) => invite.inviteeMailAddress)\n\t\t\tconst prepareGroupReInvites = async (mailAddresses: string[]) => {\n\t\t\t\tconst preparedInvitation = await shareFacade.prepareGroupInvitation(newTargetGroupKey, targetGroupInfo, mailAddresses, downcast(capability))\n\t\t\t\tpreparedReInvitations.push(preparedInvitation)\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait prepareGroupReInvites(inviteeMailAddresses)\n\t\t\t} catch (e) {\n\t\t\t\t// we accept removing pending invitations that we cannot send again (e.g. because the user was deactivated)\n\t\t\t\tif (e instanceof RecipientsNotFoundError) {\n\t\t\t\t\tconst notFoundRecipients = e.message.split(\"\\n\")\n\t\t\t\t\tconst reducedInviteeAddresses = inviteeMailAddresses.filter((address) => !notFoundRecipients.includes(address))\n\t\t\t\t\tif (reducedInviteeAddresses.length) {\n\t\t\t\t\t\tawait prepareGroupReInvites(reducedInviteeAddresses)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn preparedReInvitations\n\t}\n\n\tprivate async createGroupKeyUpdatesForMembers(group: Group, newGroupKey: VersionedKey): Promise<Array<GroupKeyUpdateData>> {\n\t\tconst members = await this.entityClient.loadAll(GroupMemberTypeRef, group.members)\n\t\tconst otherMembers = members.filter((member) => member.user != this.userFacade.getUser()?._id)\n\t\treturn await this.tryCreatingGroupKeyUpdatesForMembers(group._id, otherMembers, newGroupKey)\n\t}\n\n\tprivate async tryCreatingGroupKeyUpdatesForMembers(groupId: Id, otherMembers: GroupMember[], newGroupKey: VersionedKey): Promise<GroupKeyUpdateData[]> {\n\t\tconst groupKeyUpdates = new Array<GroupKeyUpdateData>()\n\t\t// try to reduce the amount of requests\n\t\tconst groupedMembers = groupBy(otherMembers, (member) => listIdPart(member.userGroupInfo))\n\t\tconst membersToRemove = new Array<GroupMember>()\n\t\tfor (const [listId, members] of groupedMembers) {\n\t\t\tconst userGroupInfos = await this.entityClient.loadMultiple(\n\t\t\t\tGroupInfoTypeRef,\n\t\t\t\tlistId,\n\t\t\t\tmembers.map((member) => elementIdPart(member.userGroupInfo)),\n\t\t\t)\n\t\t\tfor (const member of members) {\n\t\t\t\tconst userGroupInfoForMember = userGroupInfos.find((ugi) => isSameId(ugi._id, member.userGroupInfo))\n\t\t\t\tconst memberMailAddress = assertNotNull(userGroupInfoForMember?.mailAddress) // user group info must always have a mail address\n\t\t\t\tconst bucketKey = this.cryptoWrapper.aes256RandomKey()\n\t\t\t\tconst sessionKey = this.cryptoWrapper.aes256RandomKey()\n\t\t\t\t// always pass an empty list because we don't want the encryption to be skipped in case other recipients weren't found\n\t\t\t\t// recipients that are not found will be null anyway, and added to membersToRemove\n\t\t\t\tconst notFoundRecipients: Array<string> = []\n\t\t\t\tconst recipientKeyData = await this.cryptoFacade.encryptBucketKeyForInternalRecipient(\n\t\t\t\t\tthis.userFacade.getUserGroupId(),\n\t\t\t\t\tbucketKey,\n\t\t\t\t\tmemberMailAddress,\n\t\t\t\t\tnotFoundRecipients,\n\t\t\t\t)\n\t\t\t\tif (recipientKeyData != null && isSameTypeRef(recipientKeyData._type, InternalRecipientKeyDataTypeRef)) {\n\t\t\t\t\tconst keyData = recipientKeyData as InternalRecipientKeyData\n\t\t\t\t\tconst pubEncKeyData = createPubEncKeyData({\n\t\t\t\t\t\trecipientIdentifier: keyData.mailAddress,\n\t\t\t\t\t\trecipientIdentifierType: PublicKeyIdentifierType.MAIL_ADDRESS,\n\t\t\t\t\t\tpubEncSymKey: keyData.pubEncBucketKey,\n\t\t\t\t\t\trecipientKeyVersion: keyData.recipientKeyVersion,\n\t\t\t\t\t\tsenderKeyVersion: keyData.senderKeyVersion,\n\t\t\t\t\t\tprotocolVersion: keyData.protocolVersion,\n\t\t\t\t\t})\n\t\t\t\t\tconst groupKeyUpdateData = createGroupKeyUpdateData({\n\t\t\t\t\t\tsessionKeyEncGroupKey: this.cryptoWrapper.encryptBytes(sessionKey, bitArrayToUint8Array(newGroupKey.object)),\n\t\t\t\t\t\tsessionKeyEncGroupKeyVersion: String(newGroupKey.version),\n\t\t\t\t\t\tbucketKeyEncSessionKey: this.cryptoWrapper.encryptKey(bucketKey, sessionKey),\n\t\t\t\t\t\tpubEncBucketKeyData: pubEncKeyData,\n\t\t\t\t\t})\n\t\t\t\t\tgroupKeyUpdates.push(groupKeyUpdateData)\n\t\t\t\t} else {\n\t\t\t\t\tmembersToRemove.push(member)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst groupManagementFacade = await this.groupManagementFacade()\n\t\tif (membersToRemove.length !== 0) {\n\t\t\tfor (const member of membersToRemove) {\n\t\t\t\tawait groupManagementFacade.removeUserFromGroup(member.user, groupId)\n\t\t\t}\n\t\t\tconst reducedMembers = otherMembers.filter((member) => !membersToRemove.includes(member))\n\t\t\t// retry without the removed members\n\t\t\treturn this.tryCreatingGroupKeyUpdatesForMembers(groupId, reducedMembers, newGroupKey)\n\t\t} else {\n\t\t\treturn groupKeyUpdates\n\t\t}\n\t}\n\n\t/**\n\t * Get the ID of the group we want to rotate the keys for.\n\t */\n\tprivate getTargetGroupId(keyRotation: KeyRotation) {\n\t\t// The KeyRotation is a list element type whose list element ID part is the target group ID,\n\t\t// i.e., an indirect reference to Group.\n\t\treturn elementIdPart(keyRotation._id)\n\t}\n\n\tprivate async encryptGroupKeys(\n\t\tgroup: Group,\n\t\tcurrentGroupKey: VersionedKey,\n\t\tnewKeys: GeneratedGroupKeys,\n\t\tadminGroupKeys: VersionedKey,\n\t): Promise<EncryptedGroupKeys> {\n\t\tconst newGroupKeyEncCurrentGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(newKeys.symGroupKey, currentGroupKey.object)\n\t\tconst adminGroupKeyEncNewGroupKey = (await this.groupManagementFacade()).hasAdminEncGKey(group)\n\t\t\t? this.cryptoWrapper.encryptKeyWithVersionedKey(adminGroupKeys, newKeys.symGroupKey.object)\n\t\t\t: null\n\n\t\treturn {\n\t\t\tnewGroupKeyEncCurrentGroupKey: newGroupKeyEncCurrentGroupKey,\n\t\t\tkeyPair: newKeys.encryptedKeyPair,\n\t\t\tadminGroupKeyEncNewGroupKey: adminGroupKeyEncNewGroupKey,\n\t\t}\n\t}\n\n\t/*\n\tGets the userGroupKey for the given userId via the adminEncGKey and symmetrically encrypts the given newGroupKey with it. Note that the logged-in user needs\n\t to be the admin of the same customer that the uer with userId belongs to.\n\t */\n\tprivate async encryptGroupKeyForOtherUsers(userId: Id, newGroupKey: VersionedKey): Promise<VersionedEncryptedKey> {\n\t\tconst groupManagementFacade = await this.groupManagementFacade()\n\t\tconst user = await this.entityClient.load(UserTypeRef, userId)\n\t\tconst userGroupKey = await groupManagementFacade.getGroupKeyViaAdminEncGKey(user.userGroup.group, Number(user.userGroup.groupKeyVersion))\n\t\tconst encrypteNewGroupKey = this.cryptoWrapper.encryptKey(userGroupKey, newGroupKey.object)\n\t\treturn { key: encrypteNewGroupKey, encryptingKeyVersion: Number(user.userGroup.groupKeyVersion) }\n\t}\n\n\tprivate async generateGroupKeys(group: Group): Promise<GeneratedGroupKeys> {\n\t\tconst symGroupKeyBytes = this.cryptoWrapper.aes256RandomKey()\n\t\tconst keyPair = await this.createNewKeyPairValue(group, symGroupKeyBytes)\n\t\treturn {\n\t\t\tsymGroupKey: {\n\t\t\t\tobject: symGroupKeyBytes,\n\t\t\t\tversion: Number(group.groupKeyVersion) + 1,\n\t\t\t},\n\t\t\tencryptedKeyPair: keyPair,\n\t\t}\n\t}\n\n\t/**\n\t * Not all groups have key pairs, but if they do we need to rotate them as well.\n\t */\n\tprivate async createNewKeyPairValue(groupToRotate: Group, newSymmetricGroupKey: Aes256Key): Promise<EncryptedPqKeyPairs | null> {\n\t\tif (groupToRotate.currentKeys) {\n\t\t\tconst newPqPairs = await this.pqFacade.generateKeyPairs()\n\t\t\treturn {\n\t\t\t\tpubRsaKey: null,\n\t\t\t\tsymEncPrivRsaKey: null,\n\t\t\t\tpubEccKey: newPqPairs.eccKeyPair.publicKey,\n\t\t\t\tsymEncPrivEccKey: this.cryptoWrapper.encryptEccKey(newSymmetricGroupKey, newPqPairs.eccKeyPair.privateKey),\n\t\t\t\tpubKyberKey: this.cryptoWrapper.kyberPublicKeyToBytes(newPqPairs.kyberKeyPair.publicKey),\n\t\t\t\tsymEncPrivKyberKey: this.cryptoWrapper.encryptKyberKey(newSymmetricGroupKey, newPqPairs.kyberKeyPair.privateKey),\n\t\t\t}\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * @VisibleForTesting\n\t * @private\n\t */\n\tsetPendingKeyRotations(pendingKeyRotations: PendingKeyRotation) {\n\t\tthis.pendingKeyRotations = pendingKeyRotations\n\t\tthis.facadeInitializedDeferredObject.resolve()\n\t}\n\n\tasync reset() {\n\t\tawait this.facadeInitializedDeferredObject.promise\n\t\tthis.pendingKeyRotations = {\n\t\t\tpwKey: null,\n\t\t\tadminOrUserGroupKeyRotation: null,\n\t\t\tteamOrCustomerGroupKeyRotations: [],\n\t\t\tuserAreaGroupsKeyRotations: [],\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param groupKeyUpdateIds MUST be in the same list\n\t */\n\tasync updateGroupMemberships(groupKeyUpdateIds: IdTuple[]): Promise<void> {\n\t\tif (groupKeyUpdateIds.length < 1) return\n\t\tconsole.log(\"handling group key update for groups: \", groupKeyUpdateIds)\n\t\tconst groupKeyUpdateInstances = await this.entityClient.loadMultiple(\n\t\t\tGroupKeyUpdateTypeRef,\n\t\t\tlistIdPart(groupKeyUpdateIds[0]),\n\t\t\tgroupKeyUpdateIds.map((id) => elementIdPart(id)),\n\t\t)\n\t\tconst groupKeyUpdates = groupKeyUpdateInstances.map((update) => this.prepareGroupMembershipUpdate(update))\n\t\tconst membershipPutIn = createMembershipPutIn({\n\t\t\tgroupKeyUpdates,\n\t\t})\n\t\treturn this.serviceExecutor.put(MembershipService, membershipPutIn)\n\t}\n\n\tprivate prepareGroupMembershipUpdate(groupKeyUpdate: GroupKeyUpdate): GroupMembershipKeyData {\n\t\tconst userGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey()\n\t\tconst symEncGroupKey = this.cryptoWrapper.encryptKeyWithVersionedKey(userGroupKey, uint8ArrayToKey(groupKeyUpdate.groupKey))\n\t\treturn createGroupMembershipKeyData({\n\t\t\tgroup: elementIdPart(groupKeyUpdate._id),\n\t\t\tsymEncGKey: symEncGroupKey.key,\n\t\t\tgroupKeyVersion: groupKeyUpdate.groupKeyVersion,\n\t\t\tsymKeyVersion: String(userGroupKey.version),\n\t\t})\n\t}\n\n\t/**\n\t * This function is responsible for upgrading the encryption keys of any user according to a GroupKeyRotation object\n\t * Before rotating the keys the user will check that the admin hash created by the admin and encrypted with this user\n\t * group key matches the hash generated by the user for this rotation.\n\t *\n\t * @param user\n\t * @param pwKey\n\t * @param userGroupKeyRotation\n\t * @private\n\t */\n\tprivate async rotateUserGroupKey(user: User, pwKey: AesKey, userGroupKeyRotation: KeyRotation) {\n\t\tconst userGroupMembership = user.userGroup\n\t\tconst userGroupId = userGroupMembership.group\n\t\tconst currentUserGroupKey = this.keyLoaderFacade.getCurrentSymUserGroupKey()\n\t\tconsole.log(`KeyRotationFacade: rotate key for group: ${userGroupId}, groupKeyRotationType: ${userGroupKeyRotation.groupKeyRotationType}`)\n\t\t// check hashes\n\t\tif (userGroupKeyRotation.adminGroupKeyAuthenticationData == null) {\n\t\t\tthrow new Error(\"The hash encrypted by admin is not present in the user group key rotation !\")\n\t\t}\n\t\tconst { version: adminGroupKeyVersion, authKeyEncAdminRotationHash } = userGroupKeyRotation.adminGroupKeyAuthenticationData\n\n\t\tconst authKey = this.deriveRotationHashKey(userGroupId, currentUserGroupKey)\n\t\tconst decryptedAdminHash = this.cryptoWrapper.aesDecrypt(authKey, authKeyEncAdminRotationHash, true)\n\n\t\tconst userGroup: Group = await this.entityClient.load(GroupTypeRef, userGroupId)\n\n\t\t// get admin group public keys\n\t\tconst adminGroupId = assertNotNull(userGroup.admin)\n\t\tconst adminPublicKeyGetIn = createPublicKeyGetIn({\n\t\t\tidentifier: adminGroupId,\n\t\t\tidentifierType: PublicKeyIdentifierType.GROUP_ID,\n\t\t\tversion: null,\n\t\t})\n\t\tconst adminPublicKeyGetOut = await this.serviceExecutor.get(PublicKeyService, adminPublicKeyGetIn)\n\t\tconst { pubEccKey, pubKyberKey } = adminPublicKeyGetOut\n\t\tif (pubEccKey == null) {\n\t\t\tthrow new Error(\"tried to generate a keyhash when rotating but received an empty public ecc key!\")\n\t\t}\n\t\tif (pubKyberKey == null) {\n\t\t\tthrow new Error(\"tried to generate a keyhash when rotating but received an empty public kyber key!\")\n\t\t}\n\t\tconst clientGeneratedKeyHash = this.generateKeyHash(Number(adminGroupKeyVersion), adminGroupId, pubEccKey, pubKyberKey)\n\t\t// at this point the decrypted admin key hash MUST equal the one that we generated for this key rotation\n\t\tif (!arrayEquals(decryptedAdminHash, clientGeneratedKeyHash)) {\n\t\t\tthrow new Error(\"mismatch between client generated hash and encrypted admin hash, aborting rotation\")\n\t\t}\n\t\tconst newUserGroupKeys = await this.generateGroupKeys(userGroup)\n\n\t\tconst { membershipSymEncNewGroupKey, distributionKeyEncNewUserGroupKey, authVerifier, newGroupKeyEncCurrentGroupKey } = this.encryptUserGroupKeyForUser(\n\t\t\tpwKey,\n\t\t\tnewUserGroupKeys,\n\t\t\tuserGroup,\n\t\t\tcurrentUserGroupKey,\n\t\t)\n\t\tconst recoverCodeData = await this.reencryptRecoverCodeIfExists(user, pwKey, newUserGroupKeys)\n\n\t\tconst pubAdminGroupEncUserGroupKey = await this.encryptUserGroupKeyForAdmin(newUserGroupKeys, adminPublicKeyGetOut, adminGroupId)\n\n\t\tconst userGroupKeyData = createUserGroupKeyRotationData({\n\t\t\tuserGroupKeyVersion: String(newUserGroupKeys.symGroupKey.version),\n\t\t\tuserGroupEncPreviousGroupKey: newGroupKeyEncCurrentGroupKey.key,\n\t\t\tpassphraseEncUserGroupKey: membershipSymEncNewGroupKey.key,\n\t\t\tgroup: userGroupId,\n\t\t\tdistributionKeyEncUserGroupKey: distributionKeyEncNewUserGroupKey,\n\t\t\tkeyPair: assertNotNull(makeKeyPair(newUserGroupKeys.encryptedKeyPair)),\n\t\t\tauthVerifier,\n\t\t\tadminGroupKeyVersion: pubAdminGroupEncUserGroupKey.recipientKeyVersion,\n\t\t\tpubAdminGroupEncUserGroupKey,\n\t\t\tadminGroupEncUserGroupKey: null,\n\t\t\trecoverCodeData: recoverCodeData,\n\t\t})\n\n\t\tawait this.serviceExecutor.post(UserGroupKeyRotationService, createUserGroupKeyRotationPostIn({ userGroupKeyData }))\n\t}\n\n\tprivate async encryptUserGroupKeyForAdmin(\n\t\tnewUserGroupKeys: GeneratedGroupKeys,\n\t\tpublicKeyGetOut: PublicKeyGetOut,\n\t\tadminGroupId: Id,\n\t): Promise<PubEncKeyData> {\n\t\tconst adminPubKeys: Versioned<PublicKeys> = {\n\t\t\tversion: Number(publicKeyGetOut.pubKeyVersion),\n\t\t\tobject: {\n\t\t\t\tpubEccKey: publicKeyGetOut.pubEccKey,\n\t\t\t\tpubKyberKey: publicKeyGetOut.pubKyberKey,\n\t\t\t\tpubRsaKey: null,\n\t\t\t},\n\t\t}\n\n\t\t// we want to authenticate with new sender key pair. so we just decrypt it again\n\t\tconst pqKeyPair: PQKeyPairs = this.cryptoWrapper.decryptKeyPair(newUserGroupKeys.symGroupKey.object, assertNotNull(newUserGroupKeys.encryptedKeyPair))\n\n\t\tconst pubEncSymKey = await this.asymmetricCryptoFacade.tutaCryptEncryptSymKey(newUserGroupKeys.symGroupKey.object, adminPubKeys, {\n\t\t\tversion: newUserGroupKeys.symGroupKey.version,\n\t\t\tobject: pqKeyPair.eccKeyPair,\n\t\t})\n\n\t\treturn createPubEncKeyData({\n\t\t\trecipientIdentifier: adminGroupId,\n\t\t\trecipientIdentifierType: PublicKeyIdentifierType.GROUP_ID,\n\t\t\tpubEncSymKey: pubEncSymKey.pubEncSymKeyBytes,\n\t\t\tprotocolVersion: pubEncSymKey.cryptoProtocolVersion,\n\t\t\tsenderKeyVersion: pubEncSymKey.senderKeyVersion != null ? pubEncSymKey.senderKeyVersion.toString() : null,\n\t\t\trecipientKeyVersion: pubEncSymKey.recipientKeyVersion.toString(),\n\t\t})\n\t}\n}\n\n/**\n * We require AES keys to be 256-bit long to be quantum-safe because of Grover's algorithm.\n */\nfunction isQuantumSafe(key: AesKey) {\n\treturn getKeyLengthBytes(key) === KEY_LENGTH_BYTES_AES_256\n}\n\nfunction hasNonQuantumSafeKeys(...keys: AesKey[]) {\n\treturn keys.some((key) => !isQuantumSafe(key))\n}\n\nfunction makeKeyPair(keyPair: EncryptedPqKeyPairs | null): KeyPair | null {\n\treturn keyPair != null ? createKeyPair(keyPair) : null\n}\n","import { getFromMap, neverNull } from \"@tutao/tutanota-utils\"\nimport { User } from \"../../entities/sys/TypeRefs.js\"\nimport { VersionedKey } from \"../crypto/CryptoWrapper.js\"\nimport { Aes256Key } from \"@tutao/tutanota-crypto\"\n\n/**\n * A cache for decrypted current keys of each group. Encrypted keys are stored on membership.symEncGKey.\n * */\nexport class KeyCache {\n\tprivate currentGroupKeys: Map<Id, Promise<VersionedKey>> = new Map<Id, Promise<VersionedKey>>()\n\t// the user group key is password encrypted and stored on a special membership\n\t// also it is used to decrypt the rest of the keys therefore it requires some special handling\n\tprivate currentUserGroupKey: VersionedKey | null = null\n\t// the new user group key will be re-encrypted with this key to distribute the rotated user group key without asking for the password\n\tprivate userGroupKeyDistributionKey: Aes256Key | null = null\n\n\tsetCurrentUserGroupKey(newUserGroupKey: VersionedKey) {\n\t\tif (this.currentUserGroupKey != null && this.currentUserGroupKey.version > newUserGroupKey.version) {\n\t\t\tconsole.log(\"Tried to set an outdated user group key\")\n\t\t\treturn\n\t\t}\n\t\tthis.currentUserGroupKey = newUserGroupKey\n\t}\n\n\tgetCurrentUserGroupKey(): VersionedKey | null {\n\t\treturn this.currentUserGroupKey\n\t}\n\n\tsetUserGroupKeyDistributionKey(userGroupKeyDistributionKey: Aes256Key) {\n\t\tthis.userGroupKeyDistributionKey = userGroupKeyDistributionKey\n\t}\n\n\tgetUserGroupKeyDistributionKey(): Aes256Key | null {\n\t\treturn this.userGroupKeyDistributionKey\n\t}\n\n\t/**\n\t *\n\t * @param groupId MUST NOT be the user group id\n\t * @param keyLoader a function to load and decrypt the group key if it is not cached\n\t */\n\tgetCurrentGroupKey(groupId: Id, keyLoader: () => Promise<VersionedKey>): Promise<VersionedKey> {\n\t\treturn getFromMap(this.currentGroupKeys, groupId, async () => {\n\t\t\treturn keyLoader()\n\t\t})\n\t}\n\n\treset() {\n\t\tthis.currentGroupKeys = new Map<Id, Promise<VersionedKey>>()\n\t\tthis.currentUserGroupKey = null\n\t\tthis.userGroupKeyDistributionKey = null\n\t}\n\n\t/**\n\t * Clears keys from the cache which are outdated or where we do no longer hava a membership.\n\t * An outdated user membership is ignored and should be processed by the UserGroupKeyDistribution update.\n\t * @param user updated user with up-to-date memberships\n\t */\n\tasync removeOutdatedGroupKeys(user: User) {\n\t\tconst currentUserGroupKeyVersion = neverNull(this.getCurrentUserGroupKey()).version\n\t\tconst receivedUserGroupKeyVersion = Number(user.userGroup.groupKeyVersion)\n\t\tif (receivedUserGroupKeyVersion > currentUserGroupKeyVersion) {\n\t\t\t//we just ignore this as the same batch MUST have a UserGroupKeyDistribution entity event update\n\t\t\tconsole.log(`Received user update with new user group key version: ${currentUserGroupKeyVersion} -> ${receivedUserGroupKeyVersion}`)\n\t\t}\n\n\t\tconst newCurrentGroupKeyCache = new Map<Id, Promise<VersionedKey>>()\n\t\tfor (const membership of user.memberships) {\n\t\t\tconst cachedGroupKey = this.currentGroupKeys.get(membership.group)\n\t\t\tif (cachedGroupKey != null && Number(membership.groupKeyVersion) === (await cachedGroupKey).version) {\n\t\t\t\tawait getFromMap(newCurrentGroupKeyCache, membership.group, () => cachedGroupKey)\n\t\t\t}\n\t\t}\n\t\tthis.currentGroupKeys = newCurrentGroupKeyCache\n\t}\n}\n","import { getDayShifted, getStartOfDay } from \"@tutao/tutanota-utils\"\n\nexport interface DateProvider {\n\tgetStartOfDayShiftedBy(shiftByDays: number): Date\n}\n\nexport class LocalTimeDateProvider implements DateProvider {\n\tgetStartOfDayShiftedBy(shiftByDays: number): Date {\n\t\treturn getStartOfDay(getDayShifted(new Date(), shiftByDays))\n\t}\n}\n","import { CacheInfo, LoginFacade, LoginListener } from \"../../../common/api/worker/facades/LoginFacade.js\"\nimport type { WorkerImpl } from \"./WorkerImpl.js\"\nimport type { Indexer } from \"../index/Indexer.js\"\nimport type { EntityRestInterface } from \"../../../common/api/worker/rest/EntityRestClient.js\"\nimport { EntityRestClient } from \"../../../common/api/worker/rest/EntityRestClient.js\"\nimport type { UserManagementFacade } from \"../../../common/api/worker/facades/lazy/UserManagementFacade.js\"\nimport { CacheStorage, DefaultEntityRestCache } from \"../../../common/api/worker/rest/DefaultEntityRestCache.js\"\nimport type { GroupManagementFacade } from \"../../../common/api/worker/facades/lazy/GroupManagementFacade.js\"\nimport type { MailFacade } from \"../../../common/api/worker/facades/lazy/MailFacade.js\"\nimport type { MailAddressFacade } from \"../../../common/api/worker/facades/lazy/MailAddressFacade.js\"\nimport type { CustomerFacade } from \"../../../common/api/worker/facades/lazy/CustomerFacade.js\"\nimport type { CounterFacade } from \"../../../common/api/worker/facades/lazy/CounterFacade.js\"\nimport { EventBusClient } from \"../../../common/api/worker/EventBusClient.js\"\nimport {\n\tassertWorkerOrNode,\n\tgetWebsocketBaseUrl,\n\tisAdminClient,\n\tisAndroidApp,\n\tisBrowser,\n\tisIOSApp,\n\tisOfflineStorageAvailable,\n\tisTest,\n} from \"../../../common/api/common/Env.js\"\nimport { Const } from \"../../../common/api/common/TutanotaConstants.js\"\nimport type { BrowserData } from \"../../../common/misc/ClientConstants.js\"\nimport type { CalendarFacade } from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport type { ShareFacade } from \"../../../common/api/worker/facades/lazy/ShareFacade.js\"\nimport { RestClient } from \"../../../common/api/worker/rest/RestClient.js\"\nimport { SuspensionHandler } from \"../../../common/api/worker/SuspensionHandler.js\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport type { GiftCardFacade } from \"../../../common/api/worker/facades/lazy/GiftCardFacade.js\"\nimport type { ConfigurationDatabase } from \"../../../common/api/worker/facades/lazy/ConfigurationDatabase.js\"\nimport { DeviceEncryptionFacade } from \"../../../common/api/worker/facades/DeviceEncryptionFacade.js\"\nimport type { NativeInterface } from \"../../../common/native/common/NativeInterface.js\"\nimport { NativeFileApp } from \"../../../common/native/common/FileApp.js\"\nimport { AesApp } from \"../../../common/native/worker/AesApp.js\"\nimport type { RsaImplementation } from \"../../../common/api/worker/crypto/RsaImplementation.js\"\nimport { createRsaImplementation } from \"../../../common/api/worker/crypto/RsaImplementation.js\"\nimport { CryptoFacade } from \"../../../common/api/worker/crypto/CryptoFacade.js\"\nimport { InstanceMapper } from \"../../../common/api/worker/crypto/InstanceMapper.js\"\nimport { AdminClientDummyEntityRestCache } from \"../../../common/api/worker/rest/AdminClientDummyEntityRestCache.js\"\nimport { SleepDetector } from \"../../../common/api/worker/utils/SleepDetector.js\"\nimport { SchedulerImpl } from \"../../../common/api/common/utils/Scheduler.js\"\nimport { NoZoneDateProvider } from \"../../../common/api/common/utils/NoZoneDateProvider.js\"\nimport { LateInitializedCacheStorageImpl } from \"../../../common/api/worker/rest/CacheStorageProxy.js\"\nimport { IServiceExecutor } from \"../../../common/api/common/ServiceRequest.js\"\nimport { ServiceExecutor } from \"../../../common/api/worker/rest/ServiceExecutor.js\"\nimport type { BookingFacade } from \"../../../common/api/worker/facades/lazy/BookingFacade.js\"\nimport type { BlobFacade } from \"../../../common/api/worker/facades/lazy/BlobFacade.js\"\nimport { UserFacade } from \"../../../common/api/worker/facades/UserFacade.js\"\nimport { OfflineStorage } from \"../../../common/api/worker/offline/OfflineStorage.js\"\nimport { OFFLINE_STORAGE_MIGRATIONS, OfflineStorageMigrator } from \"../../../common/api/worker/offline/OfflineStorageMigrator.js\"\nimport { modelInfos } from \"../../../common/api/common/EntityFunctions.js\"\nimport { FileFacadeSendDispatcher } from \"../../../common/native/common/generatedipc/FileFacadeSendDispatcher.js\"\nimport { NativePushFacadeSendDispatcher } from \"../../../common/native/common/generatedipc/NativePushFacadeSendDispatcher.js\"\nimport { NativeCryptoFacadeSendDispatcher } from \"../../../common/native/common/generatedipc/NativeCryptoFacadeSendDispatcher.js\"\nimport { random } from \"@tutao/tutanota-crypto\"\nimport { ExportFacadeSendDispatcher } from \"../../../common/native/common/generatedipc/ExportFacadeSendDispatcher.js\"\nimport { assertNotNull, delay, lazyAsync, lazyMemoized } from \"@tutao/tutanota-utils\"\nimport { InterWindowEventFacadeSendDispatcher } from \"../../../common/native/common/generatedipc/InterWindowEventFacadeSendDispatcher.js\"\nimport { SqlCipherFacadeSendDispatcher } from \"../../../common/native/common/generatedipc/SqlCipherFacadeSendDispatcher.js\"\nimport { EntropyFacade } from \"../../../common/api/worker/facades/EntropyFacade.js\"\nimport { BlobAccessTokenFacade } from \"../../../common/api/worker/facades/BlobAccessTokenFacade.js\"\nimport { OwnerEncSessionKeysUpdateQueue } from \"../../../common/api/worker/crypto/OwnerEncSessionKeysUpdateQueue.js\"\nimport { EventBusEventCoordinator } from \"../../../common/api/worker/EventBusEventCoordinator.js\"\nimport { WorkerFacade } from \"../../../common/api/worker/facades/WorkerFacade.js\"\nimport { SqlCipherFacade } from \"../../../common/native/common/generatedipc/SqlCipherFacade.js\"\nimport type { SearchFacade } from \"../index/SearchFacade.js\"\nimport { Challenge } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { LoginFailReason } from \"../../../common/api/main/PageContextLoginListener.js\"\nimport { ConnectionError, ServiceUnavailableError } from \"../../../common/api/common/error/RestError.js\"\nimport { SessionType } from \"../../../common/api/common/SessionType.js\"\nimport { Argon2idFacade, NativeArgon2idFacade, WASMArgon2idFacade } from \"../../../common/api/worker/facades/Argon2idFacade.js\"\nimport { DomainConfigProvider } from \"../../../common/api/common/DomainConfigProvider.js\"\nimport { KyberFacade, NativeKyberFacade, WASMKyberFacade } from \"../../../common/api/worker/facades/KyberFacade.js\"\nimport { PQFacade } from \"../../../common/api/worker/facades/PQFacade.js\"\nimport { PdfWriter } from \"../../../common/api/worker/pdf/PdfWriter.js\"\nimport { ContactFacade } from \"../../../common/api/worker/facades/lazy/ContactFacade.js\"\nimport { KeyLoaderFacade } from \"../../../common/api/worker/facades/KeyLoaderFacade.js\"\nimport { KeyRotationFacade } from \"../../../common/api/worker/facades/KeyRotationFacade.js\"\nimport { KeyCache } from \"../../../common/api/worker/facades/KeyCache.js\"\nimport { CryptoWrapper } from \"../../../common/api/worker/crypto/CryptoWrapper.js\"\nimport { RecoverCodeFacade } from \"../../../common/api/worker/facades/lazy/RecoverCodeFacade.js\"\nimport { CacheManagementFacade } from \"../../../common/api/worker/facades/lazy/CacheManagementFacade.js\"\nimport { MailOfflineCleaner } from \"../offline/MailOfflineCleaner.js\"\nimport type { QueuedBatch } from \"../../../common/api/worker/EventQueue.js\"\nimport { Credentials } from \"../../../common/misc/credentials/Credentials.js\"\nimport { AsymmetricCryptoFacade } from \"../../../common/api/worker/crypto/AsymmetricCryptoFacade.js\"\nimport { EphemeralCacheStorage } from \"../../../common/api/worker/rest/EphemeralCacheStorage.js\"\nimport { LocalTimeDateProvider } from \"../../../common/api/worker/DateProvider.js\"\nimport { BulkMailLoader } from \"../index/BulkMailLoader.js\"\nimport type { MailExportFacade } from \"../../../common/api/worker/facades/lazy/MailExportFacade\"\n\nassertWorkerOrNode()\n\nexport type WorkerLocatorType = {\n\t// network & encryption\n\trestClient: RestClient\n\tserviceExecutor: IServiceExecutor\n\tcryptoWrapper: CryptoWrapper\n\tasymmetricCrypto: AsymmetricCryptoFacade\n\tcrypto: CryptoFacade\n\tinstanceMapper: InstanceMapper\n\tcacheStorage: CacheStorage\n\tcache: EntityRestInterface\n\tcachingEntityClient: EntityClient\n\teventBusClient: EventBusClient\n\trsa: RsaImplementation\n\tkyberFacade: KyberFacade\n\tpqFacade: PQFacade\n\tentropyFacade: EntropyFacade\n\tblobAccessToken: BlobAccessTokenFacade\n\tkeyCache: KeyCache\n\tkeyLoader: KeyLoaderFacade\n\tkeyRotation: KeyRotationFacade\n\n\t// login\n\tuser: UserFacade\n\tlogin: LoginFacade\n\n\t// domains\n\tblob: lazyAsync<BlobFacade>\n\tmail: lazyAsync<MailFacade>\n\tcalendar: lazyAsync<CalendarFacade>\n\tcounters: lazyAsync<CounterFacade>\n\tConst: Record<string, any>\n\n\t// search & indexing\n\tindexer: lazyAsync<Indexer>\n\tsearch: lazyAsync<SearchFacade>\n\n\t// management facades\n\tgroupManagement: lazyAsync<GroupManagementFacade>\n\tuserManagement: lazyAsync<UserManagementFacade>\n\trecoverCode: lazyAsync<RecoverCodeFacade>\n\tcustomer: lazyAsync<CustomerFacade>\n\tgiftCards: lazyAsync<GiftCardFacade>\n\tmailAddress: lazyAsync<MailAddressFacade>\n\tbooking: lazyAsync<BookingFacade>\n\tshare: lazyAsync<ShareFacade>\n\tcacheManagement: lazyAsync<CacheManagementFacade>\n\n\t// misc & native\n\tconfigFacade: lazyAsync<ConfigurationDatabase>\n\tdeviceEncryptionFacade: DeviceEncryptionFacade\n\tnative: NativeInterface\n\tworkerFacade: WorkerFacade\n\tsqlCipherFacade: SqlCipherFacade\n\tpdfWriter: lazyAsync<PdfWriter>\n\tbulkMailLoader: lazyAsync<BulkMailLoader>\n\tmailExportFacade: lazyAsync<MailExportFacade>\n\n\t// used to cache between resets\n\t_worker: WorkerImpl\n\t_browserData: BrowserData\n\n\t//contact\n\tcontactFacade: lazyAsync<ContactFacade>\n}\nexport const locator: WorkerLocatorType = {} as any\n\nexport async function initLocator(worker: WorkerImpl, browserData: BrowserData) {\n\tlocator._worker = worker\n\tlocator._browserData = browserData\n\tlocator.keyCache = new KeyCache()\n\tlocator.cryptoWrapper = new CryptoWrapper()\n\tlocator.user = new UserFacade(locator.keyCache, locator.cryptoWrapper)\n\tlocator.workerFacade = new WorkerFacade()\n\tconst dateProvider = new NoZoneDateProvider()\n\n\tconst mainInterface = worker.getMainInterface()\n\n\tconst suspensionHandler = new SuspensionHandler(mainInterface.infoMessageHandler, self)\n\tlocator.instanceMapper = new InstanceMapper()\n\tlocator.rsa = await createRsaImplementation(worker)\n\n\tconst domainConfig = new DomainConfigProvider().getCurrentDomainConfig()\n\n\tlocator.restClient = new RestClient(suspensionHandler, domainConfig)\n\tlocator.serviceExecutor = new ServiceExecutor(locator.restClient, locator.user, locator.instanceMapper, () => locator.crypto)\n\tlocator.entropyFacade = new EntropyFacade(locator.user, locator.serviceExecutor, random, () => locator.keyLoader)\n\tlocator.blobAccessToken = new BlobAccessTokenFacade(locator.serviceExecutor, locator.user, dateProvider)\n\tconst entityRestClient = new EntityRestClient(locator.user, locator.restClient, () => locator.crypto, locator.instanceMapper, locator.blobAccessToken)\n\n\tlocator.native = worker\n\tlocator.booking = lazyMemoized(async () => {\n\t\tconst { BookingFacade } = await import(\"../../../common/api/worker/facades/lazy/BookingFacade.js\")\n\t\treturn new BookingFacade(locator.serviceExecutor)\n\t})\n\n\tlet offlineStorageProvider\n\tif (isOfflineStorageAvailable() && !isAdminClient()) {\n\t\tlocator.sqlCipherFacade = new SqlCipherFacadeSendDispatcher(locator.native)\n\t\tofflineStorageProvider = async () => {\n\t\t\treturn new OfflineStorage(\n\t\t\t\tlocator.sqlCipherFacade,\n\t\t\t\tnew InterWindowEventFacadeSendDispatcher(worker),\n\t\t\t\tdateProvider,\n\t\t\t\tnew OfflineStorageMigrator(OFFLINE_STORAGE_MIGRATIONS, modelInfos),\n\t\t\t\tnew MailOfflineCleaner(),\n\t\t\t)\n\t\t}\n\t} else {\n\t\tofflineStorageProvider = async () => null\n\t}\n\tlocator.pdfWriter = async () => {\n\t\tconst { PdfWriter } = await import(\"../../../common/api/worker/pdf/PdfWriter.js\")\n\t\treturn new PdfWriter(new TextEncoder(), undefined)\n\t}\n\n\tconst maybeUninitializedStorage = new LateInitializedCacheStorageImpl(async (error: Error) => {\n\t\tawait worker.sendError(error)\n\t}, offlineStorageProvider)\n\n\tlocator.cacheStorage = maybeUninitializedStorage\n\n\tconst fileApp = new NativeFileApp(new FileFacadeSendDispatcher(worker), new ExportFacadeSendDispatcher(worker))\n\n\t// We don't want to cache within the admin client\n\tlet cache: DefaultEntityRestCache | null = null\n\tif (!isAdminClient()) {\n\t\tcache = new DefaultEntityRestCache(entityRestClient, maybeUninitializedStorage)\n\t}\n\n\tlocator.cache = cache ?? entityRestClient\n\n\tlocator.cachingEntityClient = new EntityClient(locator.cache)\n\tconst nonCachingEntityClient = new EntityClient(entityRestClient)\n\n\tlocator.cacheManagement = lazyMemoized(async () => {\n\t\tconst { CacheManagementFacade } = await import(\"../../../common/api/worker/facades/lazy/CacheManagementFacade.js\")\n\t\treturn new CacheManagementFacade(locator.user, locator.cachingEntityClient, assertNotNull(cache))\n\t})\n\n\t/** Slightly annoying two-stage init: first import bulk loader, then we can have a factory for it. */\n\tconst prepareBulkLoaderFactory = async () => {\n\t\tconst { BulkMailLoader } = await import(\"../index/BulkMailLoader.js\")\n\t\treturn () => {\n\t\t\t// On platforms with offline cache we just use cache as we are not bounded by memory.\n\t\t\tif (isOfflineStorageAvailable()) {\n\t\t\t\treturn new BulkMailLoader(locator.cachingEntityClient, locator.cachingEntityClient, null)\n\t\t\t} else {\n\t\t\t\t// On platforms without offline cache we use new ephemeral cache storage for mails only and uncached storage for the rest\n\t\t\t\tconst cacheStorage = new EphemeralCacheStorage()\n\t\t\t\treturn new BulkMailLoader(\n\t\t\t\t\tnew EntityClient(new DefaultEntityRestCache(entityRestClient, cacheStorage)),\n\t\t\t\t\tnew EntityClient(entityRestClient),\n\t\t\t\t\tcacheStorage,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\tlocator.bulkMailLoader = async () => {\n\t\tconst factory = await prepareBulkLoaderFactory()\n\t\treturn factory()\n\t}\n\n\tlocator.indexer = lazyMemoized(async () => {\n\t\tconst { Indexer } = await import(\"../index/Indexer.js\")\n\t\tconst { MailIndexer } = await import(\"../index/MailIndexer.js\")\n\t\tconst mailFacade = await locator.mail()\n\t\tconst bulkLoaderFactory = await prepareBulkLoaderFactory()\n\t\treturn new Indexer(entityRestClient, mainInterface.infoMessageHandler, browserData, locator.cache as DefaultEntityRestCache, (core, db) => {\n\t\t\tconst dateProvider = new LocalTimeDateProvider()\n\t\t\treturn new MailIndexer(core, db, mainInterface.infoMessageHandler, bulkLoaderFactory, locator.cachingEntityClient, dateProvider, mailFacade)\n\t\t})\n\t})\n\n\tif (isIOSApp() || isAndroidApp()) {\n\t\tlocator.kyberFacade = new NativeKyberFacade(new NativeCryptoFacadeSendDispatcher(worker))\n\t} else {\n\t\tlocator.kyberFacade = new WASMKyberFacade()\n\t}\n\n\tlocator.pqFacade = new PQFacade(locator.kyberFacade)\n\n\tlocator.keyLoader = new KeyLoaderFacade(locator.keyCache, locator.user, locator.cachingEntityClient, locator.cacheManagement)\n\n\tlocator.asymmetricCrypto = new AsymmetricCryptoFacade(locator.rsa, locator.pqFacade, locator.keyLoader, locator.cryptoWrapper, locator.serviceExecutor)\n\n\tlocator.crypto = new CryptoFacade(\n\t\tlocator.user,\n\t\tlocator.cachingEntityClient,\n\t\tlocator.restClient,\n\t\tlocator.serviceExecutor,\n\t\tlocator.instanceMapper,\n\t\tnew OwnerEncSessionKeysUpdateQueue(locator.user, locator.serviceExecutor),\n\t\tcache,\n\t\tlocator.keyLoader,\n\t\tlocator.asymmetricCrypto,\n\t)\n\n\tlocator.recoverCode = lazyMemoized(async () => {\n\t\tconst { RecoverCodeFacade } = await import(\"../../../common/api/worker/facades/lazy/RecoverCodeFacade.js\")\n\t\treturn new RecoverCodeFacade(locator.user, locator.cachingEntityClient, locator.login, locator.keyLoader)\n\t})\n\tlocator.share = lazyMemoized(async () => {\n\t\tconst { ShareFacade } = await import(\"../../../common/api/worker/facades/lazy/ShareFacade.js\")\n\t\treturn new ShareFacade(locator.user, locator.crypto, locator.serviceExecutor, locator.cachingEntityClient, locator.keyLoader)\n\t})\n\tlocator.counters = lazyMemoized(async () => {\n\t\tconst { CounterFacade } = await import(\"../../../common/api/worker/facades/lazy/CounterFacade.js\")\n\t\treturn new CounterFacade(locator.serviceExecutor)\n\t})\n\tlocator.groupManagement = lazyMemoized(async () => {\n\t\tconst { GroupManagementFacade } = await import(\"../../../common/api/worker/facades/lazy/GroupManagementFacade.js\")\n\t\treturn new GroupManagementFacade(\n\t\t\tlocator.user,\n\t\t\tawait locator.counters(),\n\t\t\tlocator.cachingEntityClient,\n\t\t\tlocator.serviceExecutor,\n\t\t\tlocator.pqFacade,\n\t\t\tlocator.keyLoader,\n\t\t\tawait locator.cacheManagement(),\n\t\t\tlocator.asymmetricCrypto,\n\t\t\tlocator.cryptoWrapper,\n\t\t)\n\t})\n\tlocator.keyRotation = new KeyRotationFacade(\n\t\tlocator.cachingEntityClient,\n\t\tlocator.keyLoader,\n\t\tlocator.pqFacade,\n\t\tlocator.serviceExecutor,\n\t\tlocator.cryptoWrapper,\n\t\tlocator.recoverCode,\n\t\tlocator.user,\n\t\tlocator.crypto,\n\t\tlocator.share,\n\t\tlocator.groupManagement,\n\t\tlocator.asymmetricCrypto,\n\t)\n\n\tconst loginListener: LoginListener = {\n\t\tonFullLoginSuccess(sessionType: SessionType, cacheInfo: CacheInfo, credentials: Credentials): Promise<void> {\n\t\t\tif (!isTest() && sessionType !== SessionType.Temporary && !isAdminClient()) {\n\t\t\t\t// index new items in background\n\t\t\t\tconsole.log(\"initIndexer after log in\")\n\n\t\t\t\tinitIndexer(worker, cacheInfo, locator.keyLoader)\n\t\t\t}\n\n\t\t\treturn mainInterface.loginListener.onFullLoginSuccess(sessionType, cacheInfo, credentials)\n\t\t},\n\n\t\tonLoginFailure(reason: LoginFailReason): Promise<void> {\n\t\t\treturn mainInterface.loginListener.onLoginFailure(reason)\n\t\t},\n\n\t\tonSecondFactorChallenge(sessionId: IdTuple, challenges: ReadonlyArray<Challenge>, mailAddress: string | null): Promise<void> {\n\t\t\treturn mainInterface.loginListener.onSecondFactorChallenge(sessionId, challenges, mailAddress)\n\t\t},\n\t}\n\n\tlet argon2idFacade: Argon2idFacade\n\tif (!isBrowser()) {\n\t\targon2idFacade = new NativeArgon2idFacade(new NativeCryptoFacadeSendDispatcher(worker))\n\t} else {\n\t\targon2idFacade = new WASMArgon2idFacade()\n\t}\n\n\tlocator.deviceEncryptionFacade = new DeviceEncryptionFacade()\n\tconst { DatabaseKeyFactory } = await import(\"../../../common/misc/credentials/DatabaseKeyFactory.js\")\n\n\tlocator.login = new LoginFacade(\n\t\tlocator.restClient,\n\t\t/**\n\t\t * we don't want to try to use the cache in the login facade, because it may not be available (when no user is logged in)\n\t\t */\n\t\tnew EntityClient(locator.cache),\n\t\tloginListener,\n\t\tlocator.instanceMapper,\n\t\tlocator.crypto,\n\t\tlocator.keyRotation,\n\t\tmaybeUninitializedStorage,\n\t\tlocator.serviceExecutor,\n\t\tlocator.user,\n\t\tlocator.blobAccessToken,\n\t\tlocator.entropyFacade,\n\t\tnew DatabaseKeyFactory(locator.deviceEncryptionFacade),\n\t\targon2idFacade,\n\t\tnonCachingEntityClient,\n\t\tasync (error: Error) => {\n\t\t\tawait worker.sendError(error)\n\t\t},\n\t\tlocator.cacheManagement,\n\t)\n\n\tlocator.search = lazyMemoized(async () => {\n\t\tconst { SearchFacade } = await import(\"../index/SearchFacade.js\")\n\t\tconst indexer = await locator.indexer()\n\t\tconst suggestionFacades = [indexer._contact.suggestionFacade]\n\t\treturn new SearchFacade(locator.user, indexer.db, indexer._mail, suggestionFacades, browserData, locator.cachingEntityClient)\n\t})\n\tlocator.userManagement = lazyMemoized(async () => {\n\t\tconst { UserManagementFacade } = await import(\"../../../common/api/worker/facades/lazy/UserManagementFacade.js\")\n\t\treturn new UserManagementFacade(\n\t\t\tlocator.user,\n\t\t\tawait locator.groupManagement(),\n\t\t\tawait locator.counters(),\n\t\t\tlocator.cachingEntityClient,\n\t\t\tlocator.serviceExecutor,\n\t\t\tmainInterface.operationProgressTracker,\n\t\t\tlocator.login,\n\t\t\tlocator.pqFacade,\n\t\t\tlocator.keyLoader,\n\t\t\tawait locator.recoverCode(),\n\t\t)\n\t})\n\tlocator.customer = lazyMemoized(async () => {\n\t\tconst { CustomerFacade } = await import(\"../../../common/api/worker/facades/lazy/CustomerFacade.js\")\n\t\treturn new CustomerFacade(\n\t\t\tlocator.user,\n\t\t\tawait locator.groupManagement(),\n\t\t\tawait locator.userManagement(),\n\t\t\tawait locator.counters(),\n\t\t\tlocator.rsa,\n\t\t\tlocator.cachingEntityClient,\n\t\t\tlocator.serviceExecutor,\n\t\t\tawait locator.booking(),\n\t\t\tlocator.crypto,\n\t\t\tmainInterface.operationProgressTracker,\n\t\t\tlocator.pdfWriter,\n\t\t\tlocator.pqFacade,\n\t\t\tlocator.keyLoader,\n\t\t\tawait locator.recoverCode(),\n\t\t\tlocator.asymmetricCrypto,\n\t\t)\n\t})\n\tconst aesApp = new AesApp(new NativeCryptoFacadeSendDispatcher(worker), random)\n\tlocator.blob = lazyMemoized(async () => {\n\t\tconst { BlobFacade } = await import(\"../../../common/api/worker/facades/lazy/BlobFacade.js\")\n\t\treturn new BlobFacade(locator.restClient, suspensionHandler, fileApp, aesApp, locator.instanceMapper, locator.crypto, locator.blobAccessToken)\n\t})\n\tlocator.mail = lazyMemoized(async () => {\n\t\tconst { MailFacade } = await import(\"../../../common/api/worker/facades/lazy/MailFacade.js\")\n\t\treturn new MailFacade(\n\t\t\tlocator.user,\n\t\t\tlocator.cachingEntityClient,\n\t\t\tlocator.crypto,\n\t\t\tlocator.serviceExecutor,\n\t\t\tawait locator.blob(),\n\t\t\tfileApp,\n\t\t\tlocator.login,\n\t\t\tlocator.keyLoader,\n\t\t)\n\t})\n\tconst nativePushFacade = new NativePushFacadeSendDispatcher(worker)\n\tlocator.calendar = lazyMemoized(async () => {\n\t\tconst { CalendarFacade } = await import(\"../../../common/api/worker/facades/lazy/CalendarFacade.js\")\n\t\treturn new CalendarFacade(\n\t\t\tlocator.user,\n\t\t\tawait locator.groupManagement(),\n\t\t\tassertNotNull(cache),\n\t\t\tnonCachingEntityClient, // without cache\n\t\t\tnativePushFacade,\n\t\t\tmainInterface.operationProgressTracker,\n\t\t\tlocator.instanceMapper,\n\t\t\tlocator.serviceExecutor,\n\t\t\tlocator.crypto,\n\t\t\tmainInterface.infoMessageHandler,\n\t\t)\n\t})\n\n\tlocator.mailAddress = lazyMemoized(async () => {\n\t\tconst { MailAddressFacade } = await import(\"../../../common/api/worker/facades/lazy/MailAddressFacade.js\")\n\t\treturn new MailAddressFacade(\n\t\t\tlocator.user,\n\t\t\tawait locator.groupManagement(),\n\t\t\tlocator.serviceExecutor,\n\t\t\tnonCachingEntityClient, // without cache\n\t\t)\n\t})\n\tconst scheduler = new SchedulerImpl(dateProvider, self, self)\n\n\tlocator.configFacade = lazyMemoized(async () => {\n\t\tconst { ConfigurationDatabase } = await import(\"../../../common/api/worker/facades/lazy/ConfigurationDatabase.js\")\n\t\treturn new ConfigurationDatabase(locator.keyLoader, locator.user)\n\t})\n\n\tconst eventBusCoordinator = new EventBusEventCoordinator(\n\t\tmainInterface.wsConnectivityListener,\n\t\tlocator.mail,\n\t\tlocator.user,\n\t\tlocator.cachingEntityClient,\n\t\tmainInterface.eventController,\n\t\tlocator.configFacade,\n\t\tlocator.keyRotation,\n\t\tlocator.cacheManagement,\n\t\tasync (error: Error) => {\n\t\t\tawait worker.sendError(error)\n\t\t},\n\t\tasync (queuedBatch: QueuedBatch[]) => {\n\t\t\tconst indexer = await locator.indexer()\n\t\t\tindexer.addBatchesToQueue(queuedBatch)\n\t\t\tindexer.startProcessing()\n\t\t},\n\t)\n\n\tlocator.eventBusClient = new EventBusClient(\n\t\teventBusCoordinator,\n\t\tcache ?? new AdminClientDummyEntityRestCache(),\n\t\tlocator.user,\n\t\tlocator.cachingEntityClient,\n\t\tlocator.instanceMapper,\n\t\t(path) => new WebSocket(getWebsocketBaseUrl(domainConfig) + path),\n\t\tnew SleepDetector(scheduler, dateProvider),\n\t\tmainInterface.progressTracker,\n\t)\n\tlocator.login.init(locator.eventBusClient)\n\tlocator.Const = Const\n\tlocator.giftCards = lazyMemoized(async () => {\n\t\tconst { GiftCardFacade } = await import(\"../../../common/api/worker/facades/lazy/GiftCardFacade.js\")\n\t\treturn new GiftCardFacade(locator.user, await locator.customer(), locator.serviceExecutor, locator.crypto, locator.keyLoader)\n\t})\n\tlocator.contactFacade = lazyMemoized(async () => {\n\t\tconst { ContactFacade } = await import(\"../../../common/api/worker/facades/lazy/ContactFacade.js\")\n\t\treturn new ContactFacade(new EntityClient(locator.cache))\n\t})\n\tlocator.mailExportFacade = lazyMemoized(async () => {\n\t\tconst { MailExportFacade } = await import(\"../../../common/api/worker/facades/lazy/MailExportFacade.js\")\n\t\tconst { MailExportTokenFacade } = await import(\"../../../common/api/worker/facades/lazy/MailExportTokenFacade.js\")\n\t\tconst mailExportTokenFacade = new MailExportTokenFacade(locator.serviceExecutor)\n\t\treturn new MailExportFacade(mailExportTokenFacade, await locator.bulkMailLoader(), await locator.blob(), locator.crypto, locator.blobAccessToken)\n\t})\n}\n\nconst RETRY_TIMOUT_AFTER_INIT_INDEXER_ERROR_MS = 30000\n\nasync function initIndexer(worker: WorkerImpl, cacheInfo: CacheInfo, keyLoaderFacade: KeyLoaderFacade): Promise<void> {\n\tconst indexer = await locator.indexer()\n\ttry {\n\t\tawait indexer.init({\n\t\t\tuser: assertNotNull(locator.user.getUser()),\n\t\t\tcacheInfo,\n\t\t\tkeyLoaderFacade,\n\t\t})\n\t} catch (e) {\n\t\tif (e instanceof ServiceUnavailableError) {\n\t\t\tconsole.log(\"Retry init indexer in 30 seconds after ServiceUnavailableError\")\n\t\t\tawait delay(RETRY_TIMOUT_AFTER_INIT_INDEXER_ERROR_MS)\n\t\t\tconsole.log(\"_initIndexer after ServiceUnavailableError\")\n\t\t\treturn initIndexer(worker, cacheInfo, keyLoaderFacade)\n\t\t} else if (e instanceof ConnectionError) {\n\t\t\tconsole.log(\"Retry init indexer in 30 seconds after ConnectionError\")\n\t\t\tawait delay(RETRY_TIMOUT_AFTER_INIT_INDEXER_ERROR_MS)\n\t\t\tconsole.log(\"_initIndexer after ConnectionError\")\n\t\t\treturn initIndexer(worker, cacheInfo, keyLoaderFacade)\n\t\t} else {\n\t\t\t// not awaiting\n\t\t\tworker.sendError(e)\n\t\t\treturn\n\t\t}\n\t}\n\tif (cacheInfo.isPersistent && cacheInfo.isNewOfflineDb) {\n\t\t// not awaiting\n\t\tindexer.enableMailIndexing()\n\t}\n}\n\nexport async function resetLocator(): Promise<void> {\n\tawait locator.login.resetSession()\n\tawait initLocator(locator._worker, locator._browserData)\n}\n\nif (typeof self !== \"undefined\") {\n\t;(self as unknown as WorkerGlobalScope).locator = locator // export in worker scope\n}\n\n/*\n * @returns true if webassembly is supported\n */\nexport function isWebAssemblySupported() {\n\treturn typeof WebAssembly === \"object\" && typeof WebAssembly.instantiate === \"function\"\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAKa,oBAAN,MAAwB;CAC9B;CACA;CACA;CACA;CACA;CAEA,YAA6BA,oBAAwCC,eAA8B;EAuEnG,KAvE6B;AAC5B,OAAK,eAAe;AACpB,OAAK,kBAAkB;AACvB,OAAK,oBAAoB,CAAE;AAC3B,OAAK,sBAAsB;AAC3B,OAAK,WAAW;CAChB;;;;CAMD,6BAA6BC,2BAAmCC,aAAkB;AACjF,OAAK,KAAK,aAAa,EAAE;AACxB,WAAQ,KAAK,yBAAyB,YAAY,MAAM,0BAA0B,GAAG;AACrF,QAAK,eAAe;GACpB,MAAM,sBAAsB,KAAK,KAAK;AAEtC,QAAK,SAAS,WAAW,YAAY;AACpC,SAAK,eAAe;AACpB,YAAQ,KAAK,6BAA6B,KAAK,KAAK,GAAG,uBAAuB,IAAK,GAAG;AACtF,UAAM,KAAK,uBAAuB;GAClC,GAAE,4BAA4B,IAAK;AAEpC,QAAK,KAAK,qBAAqB;AAC9B,SAAK,mBAAmB,cAAc;KACrC,gBAAgB;KAChB,MAAM,CAAE;IACR,EAAC;AAEF,SAAK,sBAAsB;GAC3B;EACD;CACD;CAED,cAAuB;AACtB,SAAO,KAAK;CACZ;;;;;;CAOD,aAAaC,SAA2C;AACvD,MAAI,KAAK,cAAc;GACtB,MAAM,iBAAiB,OAAO;AAE9B,QAAK,kBAAkB,KAAK,eAAe;AAG3C,kBAAe,UAAU,eAAe,QAAQ,KAAK,MAAM,SAAS,CAAC;AACrE,UAAO,eAAe;EACtB,MAEA,QAAO,SAAS;CAEjB;CAED,MAAM,wBAAwB;EAC7B,MAAM,mBAAmB,KAAK;AAC9B,OAAK,oBAAoB,CAAE;AAG3B,OAAK,IAAI,mBAAmB,kBAAkB;AAC7C,mBAAgB,QAAQ,KAAK;AAE7B,SAAM,gBAAgB,QAAQ,MAAM,KAAK;EACzC;CACD;AACD;;;;IChFY,yBAAN,MAA6B;;;;CAInC,MAAM,cAAmC;AACxC,SAAO,qBAAqB,iBAAiB,CAAC;CAC9C;;;;;;CAOD,MAAM,QAAQC,WAAuBC,MAAuC;AAC3E,SAAO,WAAW,qBAAqB,UAAU,EAAE,KAAK;CACxD;;;;;;CAOD,MAAM,QAAQD,WAAuBE,eAAgD;AACpF,SAAO,WAAW,qBAAqB,UAAU,EAAE,cAAc;CACjE;AACD;;;;ICtBY,SAAN,MAAa;CACnB,YAA6BC,oBAAyDC,UAAoB;EAqB1G,KArB6B;EAqB5B,KArBqF;CAAsB;;;;;CAM5G,eAAeC,KAAaC,SAA8C;EACzE,MAAM,KAAK,KAAK,OAAO,mBAAmB,eAAe;EACzD,MAAM,aAAa,gBAAgB,IAAI;AACvC,SAAO,KAAK,mBAAmB,eAAe,YAAY,SAAS,GAAG;CACtE;;;;;CAMD,eAAeD,KAAaC,SAAoC;EAC/D,MAAM,aAAa,gBAAgB,IAAI;AACvC,SAAO,KAAK,mBAAmB,eAAe,YAAY,QAAQ;CAClE;AACD;;;;ICnBY,mCAAN,MAAqE;CAC3E,YAA6BC,WAA4B;EA0BzD,KA1B6B;CAA8B;CAC3D,MAAM,WAAW,GAAG,MAAoD;AACvE,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAc,GAAG;EAAK,EAAC;CACxF;CACD,MAAM,WAAW,GAAG,MAAoD;AACvE,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAc,GAAG;EAAK,EAAC;CACxF;CACD,MAAM,eAAe,GAAG,MAAwD;AAC/E,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAkB,GAAG;EAAK,EAAC;CAC5F;CACD,MAAM,eAAe,GAAG,MAAwD;AAC/E,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAkB,GAAG;EAAK,EAAC;CAC5F;CACD,MAAM,8BAA8B,GAAG,MAAuE;AAC7G,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAiC,GAAG;EAAK,EAAC;CAC3G;CACD,MAAM,qBAAqB,GAAG,MAA8D;AAC3F,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAwB,GAAG;EAAK,EAAC;CAClG;CACD,MAAM,iBAAiB,GAAG,MAA0D;AACnF,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAoB,GAAG;EAAK,EAAC;CAC9F;CACD,MAAM,iBAAiB,GAAG,MAA0D;AACnF,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAsB;GAAoB,GAAG;EAAK,EAAC;CAC9F;AACD;;;;AC3BM,eAAe,wBAAwBC,QAAqD;AAClG,KAAI,OAAO,EAAE;EACZ,MAAM,EAAE,QAAQ,GAAG,MAAM,OAAO;AAChC,SAAO,IAAI,OAAO,IAAI,iCAAiC,SAAS;CAChE,MACA,QAAO,IAAI;AAEZ;IAQY,SAAN,MAA0C;CAChD,MAAM,QAAQC,WAAyBC,OAAwC;EAC9E,MAAM,OAAO,OAAO,mBAAmB,GAAG;AAC1C,SAAO,WAAW,WAAW,OAAO,KAAK;CACzC;CAED,MAAM,QAAQC,YAA2BD,OAAwC;AAChF,SAAO,WAAW,YAAY,MAAM;CACpC;AACD;;;;ACCD,oBAAoB;IA4BP,yBAAN,MAA6B;CACnC,YACkBE,KACAC,UACAC,iBACAC,eACAC,iBAChB;EA+NF,KApOkB;EAoOjB,KAnOiB;EAmOhB,KAlOgB;EAkOf,KAjOe;EAiOd,KAhOc;CACd;;;;;;;;;CAUJ,MAAM,mBAAmBC,YAAiCC,sBAAkCC,kBAAyD;EACpJ,MAAM,UAAU,qBAAqB;GACpC,YAAY,WAAW;GACvB,gBAAgB,WAAW;GAC3B,SAAS,iBAAiB,UAAU;EACpC,EAAC;EACF,MAAM,kBAAkB,MAAM,KAAK,gBAAgB,IAAI,kBAAkB,QAAQ;AACjF,SAAO,gBAAgB,aAAa,QAAQ,YAAY,gBAAgB,WAAW,qBAAqB,GACrG,qBAAqB,qCACrB,qBAAqB;CACxB;;;;;;;;;CAUD,MAAM,wCACLC,kBACAC,eACAC,kBAC8B;EAC9B,MAAM,wBAAwB,yBAAyB,cAAc,gBAAgB;EACrF,MAAM,qBAAqB,MAAM,KAAK,yBAAyB,kBAAkB,uBAAuB,cAAc,aAAa;AACnI,MAAI,0BAA0B,sBAAsB,YAAY;GAC/D,MAAM,uBAAuB,MAAM,KAAK,mBACvC,kBACA,cAAc,mBAAmB,qBAAqB,EACtD,OAAO,cAAc,cAAc,iBAAiB,CAAC,CACrD;AACD,OAAI,yBAAyB,qBAAqB,mCACjD,OAAM,IAAI,YAAY;EAEvB;AACD,SAAO;CACP;;;;;;;CAQD,MAAM,yBACLF,kBACAG,uBACAC,cAC8B;AAC9B,UAAQ,uBAAR;AACC,QAAK,sBAAsB,KAAK;AAC/B,SAAK,qBAAqB,iBAAiB,CAC1C,OAAM,IAAI,YAAY,uCAAuC,iBAAiB;IAE/E,MAAMC,aAA4B,iBAAiB;IACnD,MAAM,kBAAkB,MAAM,KAAK,IAAI,QAAQ,YAAY,aAAa;AACxE,WAAO;KACN,iBAAiB,qBAAqB,gBAAgB;KACtD,sBAAsB;IACtB;GACD;AACD,QAAK,sBAAsB,YAAY;AACtC,SAAK,aAAa,iBAAiB,CAClC,OAAM,IAAI,YAAY,6CAA6C,iBAAiB;IAErF,MAAM,EAAE,sBAAsB,sBAAsB,GAAG,MAAM,KAAK,SAAS,mBAAmB,cAAc,iBAAiB;AAC7H,WAAO;KACN,iBAAiB,qBAAqB,qBAAqB;KAC3D;IACA;GACD;AACD,WACC,OAAM,IAAI,YAAY,oCAAoC;EAC3D;CACD;;;;CAKD,MAAM,4BACLC,yBACAC,qBACAJ,uBACAC,cAC8B;EAC9B,MAAMI,UAA6B,MAAM,KAAK,gBAAgB,YAAY,yBAAyB,oBAAoB;AACvH,SAAO,MAAM,KAAK,yBAAyB,SAAS,uBAAuB,aAAa;CACxF;;;;;;;CAQD,MAAM,kBAAkBC,QAAgBC,qBAA4CC,eAA0C;EAC7H,MAAM,qBAAqB,KAAK,0BAA0B,oBAAoB,OAAO;EACrF,MAAM,cAAc,mBAAmB;AAEvC,MAAI,cAAc,mBAAmB,EAAE;GACtC,MAAM,gBAAgB,MAAM,KAAK,gBAAgB,mBAAmB,cAAc;GAClF,MAAM,mBAAmB,MAAM,KAAK,+BAA+B,cAAc,QAAQ,cAAc;AACvG,UAAO,KAAK,2BAA2B;IAAE,QAAQ;IAAoB,SAAS,oBAAoB;GAAS,GAAE,QAAQ;IACpH,QAAQ;IACR,SAAS,cAAc;GACvB,EAAC;EACF,WAAU,eAAe,mBAAmB,EAAE;GAC9C,MAAM,oBAAoB,MAAM,KAAK,IAAI,QAAQ,oBAAoB,qBAAqB,OAAO,CAAC;AAClG,UAAO;IACN;IACA,uBAAuB,sBAAsB;IAC7C,kBAAkB;IAClB,qBAAqB,oBAAoB;GACzC;EACD;AACD,QAAM,IAAI,YAAY,8BAA8B;CACpD;;;;;;;;CASD,MAAM,uBAAuBF,QAAgBC,qBAA4CE,kBAAgE;EACxJ,MAAM,qBAAqB,KAAK,0BAA0B,oBAAoB,OAAO;AACrF,OAAK,cAAc,mBAAmB,CACrC,OAAM,IAAI,iBAAiB;AAE5B,SAAO,KAAK,2BACX;GACC,QAAQ;GACR,SAAS,oBAAoB;EAC7B,GACD,QACA,iBACA;CACD;CAED,MAAc,2BACbC,oBACAJ,QACAG,kBACwB;EACxB,MAAM,mBAAmB,KAAK,cAAc,oBAAoB;EAChE,MAAM,oBAAoB,MAAM,KAAK,SAAS,qBAC7C,iBAAiB,QACjB,kBACA,mBAAmB,QACnB,qBAAqB,OAAO,CAC5B;EACD,MAAM,mBAAmB,iBAAiB;AAC1C,SAAO;GAAE;GAAmB,uBAAuB,sBAAsB;GAAY;GAAkB,qBAAqB,mBAAmB;EAAS;CACxJ;CAED,AAAQ,0BAA0BE,YAA6C;AAC9E,MAAI,WAAW,UAEd,QAAO,kBAAkB,gBAAgB,WAAW,UAAU,CAAC;SACrD,WAAW,eAAe,WAAW,WAAW;GAC1D,MAAM,eAAe,WAAW;GAChC,MAAM,iBAAiB,KAAK,cAAc,sBAAsB,WAAW,YAAY;AACvF,UAAO;IACN,aAAa,YAAY;IACzB;IACA;GACA;EACD,MACA,OAAM,IAAI,MAAM;CAEjB;;;;;;;;;CAUD,MAAc,+BAA+BC,eAAkCC,YAAqC;EACnH,MAAM,OAAO,cAAc;AAC3B,MAAI,aAAa,cAAc,CAC9B,QAAO,cAAc;SACX,gBAAgB,cAAc,CACxC,QAAO;GAAE,WAAW,cAAc;GAAc,YAAY,cAAc;EAAe;SAC/E,qBAAqB,cAAc,EAAE;GAE/C,MAAM,cAAc,MAAM,KAAK,gBAAgB,sBAAsB,WAAW;GAChF,MAAM,qBAAqB,KAAK,cAAc,oBAAoB;GAClE,MAAM,mBAAmB,KAAK,cAAc,cAAc,YAAY,QAAQ,mBAAmB,WAAW;GAC5G,MAAM,OAAO,qBAAqB;IAAE,WAAW,mBAAmB;IAAW;IAAkB,UAAU;GAAY,EAAC;AACtH,SAAM,KAAK,gBAAgB,IAAI,kBAAkB,KAAK;AACtD,UAAO;EACP,MACA,OAAM,IAAI,YAAY,4BAA4B;CAEnD;AACD;AAEM,SAAS,6BAA6BC,iBAAyD;AACrG,QAAO;EACN,QAAQ;GACP,WAAW,gBAAgB;GAC3B,aAAa,gBAAgB;GAC7B,WAAW,gBAAgB;EAC3B;EACD,SAAS,OAAO,gBAAgB,cAAc;CAC9C;AACD;;;;ACrND,oBAAoB;IAcP,eAAN,MAAmB;CACzB,YACkBC,YACAC,cACAC,YACAC,iBACAC,gBACAC,gCACAC,OACAC,iBACAC,wBAChB;EA6uBF,KAtvBkB;EAsvBjB,KArvBiB;EAqvBhB,KApvBgB;EAovBf,KAnvBe;EAmvBd,KAlvBc;EAkvBb,KAjvBa;EAivBZ,KAhvBY;EAgvBX,KA/uBW;EA+uBV,KA9uBU;CACd;CAEJ,MAAM,2BAA8BC,mBAAkC;EACrE,MAAM,eAAe,SAAiB,kBAAkB,CAAC;AAEzD,MAAI,cAAc,cAAc,eAAe,EAAE;GAChD,MAAM,UAAU,SAAkB,kBAAkB;AAEpD,OAAI;AACH,SAAK,QAAQ,eAAe,QAAQ,sBAAsB;AACzD,aAAQ,cAAc,kBAAkB,QAAQ,qBAAqB;AACrE,aAAQ,uBAAuB;AAC/B,aAAQ,kBAAkB;AAC1B,WAAM,KAAK,aAAa,OAAO,QAAQ;IACvC,YAAW,QAAQ,eAAe,QAAQ,iBAAiB;AAC3D,aAAQ,cAAc,kBAAkB,sBAAsB,QAAQ,gBAAgB,CAAC;AACvF,aAAQ,kBAAkB;AAC1B,WAAM,KAAK,aAAa,OAAO,QAAQ;IACvC,WAAU,QAAQ,gBAAgB,QAAQ,wBAAwB,QAAQ,kBAAkB;AAC5F,aAAQ,uBAAuB;AAC/B,aAAQ,kBAAkB;AAC1B,WAAM,KAAK,aAAa,OAAO,QAAQ;IACvC;GACD,SAAQ,GAAG;AACX,UAAM,aAAa,aAClB,OAAM;GAEP;EACD;AAED,SAAO;CACP;CAED,MAAM,6BAA6BC,UAA8C;EAChF,MAAM,YAAY,MAAM,qBAAqB,SAAS,MAAM;AAC5D,SAAO,KAAK,kBAAkB,WAAW,SAAS;CAClD;;CAGD,MAAM,mCAAmCA,UAAkD;EAC1F,MAAM,MAAM,MAAM,KAAK,6BAA6B,SAAS;AAC7D,SAAO,OAAO,OAAO,OAAO,qBAAqB,IAAI;CACrD;;CAGD,8BAA8BC,UAA+BC,UAA0B;EACtF,IAAIC,MAA2B,SAAS;AACxC,aAAW,QAAQ,SAClB,OAAM,mBAAmB,IAAI;AAG9B,SAAO,WAAW,UAAU,IAAI;CAChC;CAED,MAAM,kBAAkBF,UAA+BG,oBAA4D;EAClH,MAAM,KAAK,MAAM,KAAK,gBAAgB,gBAAgB,SAAS,aAAa,mBAAmB,qBAAqB;AACpH,SAAO,WAAW,IAAI,mBAAmB,IAAI;CAC7C;;;;;;;;;;CAWD,MAAM,kBAAkBC,WAAsBJ,UAAuD;AACpG,MAAI;AACH,QAAK,UAAU,UACd,QAAO;AAER,OAAI,SAAS,WAAW;IAGvB,MAAM,YAAY,MAAM,KAAK,sCAAsC,SAAS,UAAU;IACtF,MAAM,sBAAsB,MAAM,KAAK,qBAAqB,WAAW,UAAU,UAAU;AAC3F,WAAO,oBAAoB;GAC3B,WAAU,SAAS,uBAAuB,KAAK,WAAW,iBAAiB,IAAI,KAAK,WAAW,SAAS,SAAS,YAAY,EAAE;IAC/H,MAAM,KAAK,MAAM,KAAK,gBAAgB,gBAAgB,SAAS,aAAa,OAAO,SAAS,oBAAoB,EAAE,CAAC;AACnH,WAAO,KAAK,8BAA8B,UAAU,GAAG;GACvD,WAAU,SAAS,oBAAoB;IAEvC,MAAM,KAAK,MAAM,KAAK,gBAAgB,gBAAgB,KAAK,WAAW,WAAW,UAAU,KAAK,EAAE,OAAO,SAAS,mBAAmB,EAAE,CAAC;AACxI,WAAO,KAAK,8BAA8B,UAAU,GAAG;GACvD,OAAM;IAEN,MAAM,cAAc,MAAM,KAAK,aAAa,QAAQ,mBAAmB,SAAS,aAAa;AAC7F,WAAQ,MAAM,KAAK,uBAAuB,YAAY,IAAM,MAAM,KAAK,sCAAsC,aAAa,UAAU,UAAU;GAC9I;EACD,SAAQ,GAAG;AACX,OAAI,aAAa,aAAa;AAC7B,YAAQ,IAAI,iCAAiC,EAAE;AAC/C,UAAM,IAAI,wBAAwB,2DAA2D,SAAS;GACtG,MACA,OAAM;EAEP;CACD;;;;;;;CAQD,MAAM,gBAAsCK,SAAqBC,MAAyD;AACzH,MAAI,cAAc,SAAS,iBAAiB,IAAI,KAAK,eAAe,KACnE,QAAO,KAAK,uCAAuC,KAAK;SAC9C,cAAc,SAAS,0BAA0B,IAAI,KAAK,uBAAuB,KAC3F,QAAO,KAAK,0BAA0B,KAAK;SACjC,cAAc,SAAS,sBAAsB,IAAI,KAAK,uBAAuB,KACvF,QAAO,KAAK,8BAA8B,KAAK;IAE/C,QAAO;CAER;;;;;;CAOD,MAAM,sCAAsCC,4BAAqE;AAChH,MAAI,KAAK,kBAAkB,2BAA2B,EAAE;GAIvD,MAAM,qBAAqB,MAAM,qBAAqB,iBAAiB;AACvE,UAAQ,MAAM,KAAK,eAAe,wBAAwB,oBAAoB,4BAA4B,KAAK;EAC/G,MAEA,QAAO;CAER;CAED,MAAa,qBAAqBC,WAAsBR,UAA+BI,WAAoD;EAC1I,MAAM,oBAAoB,KAAK,yBAAyB,SAAS;EACjE,IAAIK;EACJ,IAAIC,8BAA2D;EAC/D,IAAIC,qBAA0C;AAC9C,MAAI,UAAU,YAAY,UAAU,iBAAiB;GAEpD,MAAM,EAAE,iBAAiB,sBAAsB,GAAG,MAAM,KAAK,uBAAuB,4BACnF,UAAU,UACV,OAAO,UAAU,oBAAoB,EACrC,yBAAyB,UAAU,gBAAgB,EACnD,UAAU,gBACV;AACD,wBAAqB;AACrB,wBAAqB;EACrB,WAAU,UAAU,mBAAmB;GAEvC,IAAI;GACJ,MAAM,kBAAkB,OAAO,UAAU,oBAAoB;AAC7D,OAAI,UAAU,SAGb,YAAW,UAAU;IAGrB,YAAW,UAAU,SAAS,YAAY;AAG3C,wBAAqB,MAAM,KAAK,0BAA0B,UAAU,iBAAiB,UAAU,kBAAkB;AACjH,iCAA8B,qBAAqB;EACnD,MACA,OAAM,IAAI,yBAAyB,2CAA2C,UAAU,KAAK;EAE9F,MAAM,sBAAsB,MAAM,KAAK,6CACtC,WACA,oBACA,mBACA,UACA,WACA,6BACA,mBACA;AAED,QAAM,KAAK,+BAA+B,0BAA0B,oBAAoB,qBAAqB,UAAU;EAIvH,MAAM,WAAW,MAAM,KAAK,gBAAgB,sBAAsB,SAAS,YAAY;AACvF,OAAK,8BACJ,UACA,2BAA2B,UAAU,oBAAoB,8BAA8B,CACvF;AACD,SAAO;CACP;;;;CAKD,MAAa,OAAOC,OAAgC;AACnD,SAAO,mBAAmB,WAAW,uBAAuB,MAAM,CAAC,CAAC;CACpE;;;;;;;;;CAUD,MAAc,0BAA0BC,UAAcC,iBAAyBC,mBAAgD;AAC9H,MAAI,KAAK,WAAW,SAAS,SAAS,EAAE;GAEvC,MAAM,WAAW,MAAM,KAAK,gBAAgB,gBAAgB,UAAU,gBAAgB;AACtF,UAAO,WAAW,UAAU,kBAAkB;EAC9C,OAAM;GAGN,MAAM,sBAAsB;GAC5B,MAAM,8BAA8B;GACpC,MAAM,oBAAoB,MAAM,KAAK,aAAa,KAAK,cAAc,oBAAoB;GAEzF,MAAM,uBAAuB,kBAAkB;AAC/C,QAAK,qBACJ,OAAM,IAAI,wBAAwB,kCAAkC;GAErE,MAAM,8BAA8B,OAAO,kBAAkB,wBAAwB,EAAE;GACvF,MAAM,oBAAoB,MAAM,KAAK,aAAa,KAAK,cAAc,qBAAqB;GAE1F,MAAM,sBAAsB,kBAAkB;GAC9C,MAAM,8BAA8B,OAAO,kBAAkB,wBAAwB,EAAE;AACvF,SAAM,uBAAuB,KAAK,WAAW,SAAS,oBAAoB,EACzE,OAAM,IAAI,wBAAwB,qDAAqD;GAGxF,MAAM,uBAAuB,MAAM,KAAK,gBAAgB,gBAAgB,qBAAqB,4BAA4B;GAEzH,MAAM,8BAA8B,WAAW,sBAAsB,cAAc,kBAAkB,kBAAkB,CAAC;GACxH,MAAM,uBAAuB,MAAM,KAAK,gBAAgB,gBAAgB,sBAAsB,6BAA6B;IAC1H,QAAQ;IACR,SAAS,OAAO,kBAAkB,gBAAgB;GAClD,EAAC;GAEF,MAAM,8BAA8B,WAAW,sBAAsB,cAAc,kBAAkB,kBAAkB,CAAC;GACxH,MAAM,uBAAuB,MAAM,KAAK,gBAAgB,gBAAgB,qBAAqB,6BAA6B;IACzH,QAAQ;IACR,SAAS,OAAO,kBAAkB,gBAAgB;GAClD,EAAC;AAEF,UAAO,WAAW,sBAAsB,kBAAkB;EAC1D;CACD;CAED,MAAc,8BAA8BT,MAAyD;EACpG,MAAM,eAAe,KAAK,WAAW,wBAAwB;EAG7D,MAAM,YAAY,MAAM,qBAAqB,sBAAsB;AACnE,QAAM,KAAK,yBAAyB,WAAW,MAAM,cAAc,iBAAiB,CAAC;AACrF,SAAO;CACP;CAED,MAAc,0BAA0BA,MAAyD;EAChG,MAAM,eAAe,KAAK,WAAW,wBAAwB;EAG7D,MAAM,qBAAqB,2BAA2B,cAAc,iBAAiB,CAAC;AACtF,OAAK,8BAA8B,MAAoC,oBAAoB,KAAK,WAAW,gBAAgB,CAAC;EAC5H,MAAM,gBAAgB,oCAAoC;GACzD,YAAY,KAAK;GACjB,eAAe,OAAO,mBAAmB,qBAAqB;GAC9D,kBAAkB,mBAAmB;EACrC,EAAC;AACF,QAAM,KAAK,gBAAgB,KAAK,kCAAkC,cAAc;AAChF,SAAO;CACP;CAED,MAAc,uCAAuCA,MAAyD;EAC7G,MAAM,0BAA0B,cAC/B,KAAK,WAAW,iBAAiB,CAAC,YAAY,KAAK,CAACU,MAAuB,EAAE,cAAc,UAAU,SAAS,CAC9G;EACD,MAAM,kBAAkB,MAAM,KAAK,aAAa,QAAQ,mBAAmB,KAAK,IAAI,GAAG;EACvF,MAAM,0BAA0B,gBAAgB,KAAK,CAAC,MAAM,EAAE,UAAU,wBAAwB,MAAM;AAEtG,OAAK,wBAAyB,OAAM,IAAI,wBAAwB;EAChE,MAAM,0BAA0B,OAAO,wBAAwB,iBAAiB,EAAE;EAClF,MAAM,mBAAmB,MAAM,KAAK,gBAAgB,gBAAgB,wBAAwB,OAAO,wBAAwB;EAC3H,MAAM,4BAA4B;GAAE,QAAQ;GAAkB,SAAS;EAAyB;EAChG,MAAM,UAAU,WAAW,kBAAkB,cAAc,wBAAwB,iBAAiB,CAAC;EACrG,MAAM,cAAc,WAAW,SAAS,mBAAmB,KAAK,mBAAmB,CAAC;AAEpF,OAAK,8BACJ,MACA,2BAA2B,2BAA2B,YAAY,EAClE,wBAAwB,MACxB;AACD,SAAO;CACP;CAED,AAAQ,8BAA8BC,kBAA8CC,KAA4BC,YAAiB;AAChI,mBAAiB,sBAAsB,mBAAmB,IAAI,IAAI;AAClE,mBAAiB,mBAAmB,IAAI,qBAAqB,UAAU;AACvE,MAAI,WACH,kBAAiB,cAAc;CAEhC;CAED,AAAQ,sBAAsBC,UAAoBF,KAA4B;AAC7E,WAAS,sBAAsB,IAAI;AACnC,WAAS,mBAAmB,IAAI,qBAAqB,UAAU;CAC/D;;;;CAKD,AAAQ,kBAAkBG,kBAAgD;AACzE,gBAAc,iBAAiB,UAAU;CACzC;CAED,MAAc,uBAAuBC,iBAAuD;EAC3F,MAAMC,sBACL,gBAAgB,KACf,CAAC,OACC,EAAE,SAAS,eAAe,oBAAoB,EAAE,SAAS,eAAe,cACzE,EAAE,eACF,KAAK,WAAW,SAAS,EAAE,YAAY,CACxC,IAAI;AAEN,MAAI,qBAAqB;GACxB,MAAM,KAAK,MAAM,KAAK,gBAAgB,gBACrC,cAAc,oBAAoB,YAAY,EAC9C,OAAO,oBAAoB,oBAAoB,EAAE,CACjD;AACD,UAAO,WAAW,IAAI,cAAc,oBAAoB,oBAAoB,CAAC;EAC7E,MACA,QAAO;CAER;;;;;CAMD,MAAc,6CACbf,WACAgB,cACAC,mBACAzB,UACAI,WACAsB,sBACAf,oBAC+B;EAC/B,IAAIgB,gCAAoD;EACxD,MAAM,sBAAsB,MAAM,KAAW,UAAU,sBAAsB,OAAO,uBAAuB;GAC1G,MAAM,sBAAsB,WAAW,cAAc,mBAAmB,iBAAiB;GACzF,MAAM,WAAW,MAAM,KAAK,gBAAgB,sBAAsB,SAAS,YAAY;GACvF,MAAM,qBAAqB,2BAA2B,UAAU,oBAAoB;GACpF,MAAM,2CAA2C,yBAAyB,mBAAmB;AAC7F,OAAI,qBAAqB,mBAAmB,YAAY;AACvD,oCAAgC;AAIhC,UAAM,KAAK,yBACV,WACA,sBACA,oBACA,UAAU,oBAAoB,sBAAsB,aAAa,OAAO,UAAU,oBAAoB,EAAE,GAAG,MAC3G,UACA,+BACA,0CACA,oBACA;GACD;AACD,4CAAyC,mBAAmB,mBAAmB;AAC/E,4CAAyC,gBAAgB,OAAO,mBAAmB,qBAAqB;AACxG,UAAO;EACP,EAAC;AAEF,MAAI,8BACH,QAAO;GAAE;GAA+B;EAAqB;IAE7D,OAAM,IAAI,wBAAwB,iCAAiC,SAAS;CAE7E;CAED,MAAc,yBACbvB,WACAwB,sBAOAC,oBACAC,2BACA9B,UACA+B,+BACAC,0CACAC,qBACC;EAED,MAAM,iBAAiB,oBAAoB,aAAa,UAAU,KAAK,UAAU,KAAK;AACtF,MAAI,gBAAgB;AACnB,QAAK,qBACJ,MAAK,mBACJ,wBAAuB,qBAAqB;KACtC;IACN,MAAM,OAAO,KAAK,kBAAkB,SAAS,GACxC,MAAM,KAAK,eAAe,wBAAwB,WAAW,UAAU,8BAA8B,GACtG;IACJ,MAAM,oBAAoB,KAAK,eAAe,KAAK,OAAO,UAAU;AACpE,2BAAuB,MAAM,KAAK,oCAAoC,mBAAmB,oBAAoB,0BAA0B;GACvI;AAEF,4CAAyC,uBAAuB,WAAW,qBAAqB,uBAAuB,qBAAqB,CAAC;EAC7I;CACD;CAED,MAAc,oCAAoCC,mBAA2BC,oBAAgCL,2BAA0C;AACtJ,MAAI;AACH,UAAO,MAAM,KAAK,uBAAuB,mBACxC;IACC,YAAY;IACZ,gBAAgB,wBAAwB;GACxC,GACD,oBACA,cAAc,0BAA0B,CACxC;EACD,SAAQ,GAAG;AAGX,WAAQ,MAAM,iCAAiC,EAAE;AACjD,UAAO,qBAAqB;EAC5B;CACD;CAED,MAAc,sCAAsCR,iBAA+BtB,UAA+BI,WAAuC;EACxJ,MAAM,qBAAqB,gBAAgB,KAAK,CAAC,MAAM,EAAE,SAAS,eAAe,UAAU,EAAE,SAAS,eAAe,SAAS,IAAI;AAElI,MAAI,sBAAsB,MAAM;GAC/B,MAAM,YAAY,EAAE,UAAU,IAAI,GAAG,UAAU,KAAK;AACpD,SAAM,IAAI,yBAAyB,iDAAiD,SAAS,WAAW,KAAK,yBAAyB,SAAS,CAAC;EAChJ;EAED,MAAM,oBAAoB,MAAM,KAAK,aAAa,QAAQ,yBAAyB,cAAc,mBAAmB,OAAO,CAAC,kBAAkB;EAC9I,MAAM,mBAAmB,kBAAkB,KAC1C,CAAC,QAAQ,GAAG,SAAS,qBAAqB,UAAU,GAAG,SAAS,qBAAqB,aAAa,mBAAmB,gBAAgB,GAAG,YACxI;AAGD,MAAI,oBAAoB,KACvB,OAAM,IAAI,wBAAwB;AAGnC,MAAI,iBAAiB,SAAS,qBAAqB,SAClD,QAAO,KAAK,0BAA0B,kBAAkB,oBAAoB,SAAS;IAErF,QAAO,KAAK,6CAA6C,kBAAkB,UAAU,oBAAoB,UAAU;CAEpH;CAED,MAAc,0BACbgC,kBACAC,oBACArC,UACkB;EAClB,IAAI;AAEJ,MAAI,iBAAiB,qBAAqB,MAAM;GAC/C,MAAM,gBAAgB,MAAM,KAAK,gBAAgB,gBAChD,UAAU,iBAAiB,YAAY,EACvC,OAAO,iBAAiB,mBAAmB,EAAE,CAC7C;AACD,eAAY,WAAW,eAAe,iBAAiB,kBAAkB;EACzE,WAAU,iBAAiB,iBAAiB;GAK5C,MAAM,eAAe,MAAM,KAAK,gBAAgB,oBAAoB,OAAO,iBAAiB,iBAAiB,EAAE,CAAC;AAChH,eAAY,WAAW,cAAc,iBAAiB,gBAAgB;EACtE,MACA,OAAM,IAAI,yBACR,oDAAoD,mBAAmB,IAAI,UAAU,CAAC,cAAc,KAAK,UAAU,SAAS,CAAC;AAIhI,SAAO,WAAW,WAAW,UAAU,mBAAmB,oBAAoB,CAAC;CAC/E;CAED,MAAc,6CACboC,kBACApC,UACAqC,oBACAjC,WACkB;EAClB,MAAM,kBAAkB,iBAAiB;AACzC,MAAI,mBAAmB,KACtB,OAAM,IAAI,yBACR,sDAAsD,iBAAiB,IAAI,UAAU,CAAC,cAAc,KAAK,UAAU,SAAS,CAAC;EAGhI,MAAM,sBAAsB,mBAAmB;AAC/C,MAAI,uBAAuB,KAC1B,OAAM,IAAI,yBACR,oDAAoD,mBAAmB,IAAI,UAAU,CAAC,cAAc,KAAK,UAAU,SAAS,CAAC;EAIhI,MAAM,EAAE,iBAAiB,GAAG,MAAM,KAAK,uBAAuB,4BAC7D,iBAAiB,OACjB,OAAO,iBAAiB,iBAAiB,EAAE,EAC3C,yBAAyB,iBAAiB,gBAAgB,EAC1D,gBACA;EAED,MAAM,KAAK,WAAW,iBAAiB,oBAAoB;AAE3D,MAAI,iBAAiB,aAAa;GAEjC,IAAI,gCAAgC,MAAM,KAAK,gBAAgB,sBAAsB,UAAU,iBAAiB,YAAY,CAAC;AAC7H,SAAM,KAAK,2BAA2B,WAAW,UAAU,oBAAoB,kBAAkB,+BAA+B,GAAG,CAAC,MACnI,QAAQ,eAAe,MAAM;AAC5B,YAAQ,IAAI,kDAAkD;GAC9D,EAAC,CACF;EACD;AACD,SAAO;CACP;;;;;;;;CASD,MAAM,yBAAyBJ,UAA0D;AACxF,MAAI,SAAS,2BAA2B;GAEvC,MAAM,UAAU,MAAM,KAAK,gBAAgB,mBAAmB,SAAS,YAAY;AAEnF,WACC,MAAM,KAAK,uBAAuB,yBACjC,QAAQ,QACR,gBAAgB,uBAAuB,SAAS,6BAA6B,EAC7E,mBAAmB,SAAS,0BAA0B,CACtD,EACA;EACF;AACD,SAAO;CACP;;;;;;CAOD,MAAM,yBAAyBsC,OAAkBC,QAA6BC,wBAA+D;AAC5I,OAAK,OAAO,YACX,OAAM,IAAI,OAAO,sBAAsB,KAAK,UAAU,OAAO,CAAC;AAG/D,MAAI,MAAM,WAAW;AACpB,OAAI,OAAO,oBACV,OAAM,IAAI,OAAO,iCAAiC,KAAK,UAAU,OAAO,CAAC;GAG1E,MAAM,aAAa,iBAAiB;GACpC,MAAM,kCAAkC,0BAA2B,MAAM,KAAK,gBAAgB,sBAAsB,OAAO,YAAY;GACvI,MAAM,sBAAsB,2BAA2B,iCAAiC,WAAW;AACnG,QAAK,sBAAsB,QAAoB,oBAAoB;AACnE,UAAO;EACP,MACA,QAAO;CAER;CAED,MAAM,qCACLC,mBACAC,WACAC,sBACAC,oBAC4E;EAC5E,MAAM,UAAU,qBAAqB;GACpC,YAAY;GACZ,gBAAgB,wBAAwB;GACxC,SAAS;EACT,EAAC;AACF,MAAI;GACH,MAAM,kBAAkB,MAAM,KAAK,gBAAgB,IAAI,kBAAkB,QAAQ;AAGjF,OAAI,mBAAmB,WAAW,EACjC,QAAO;GAER,MAAM,mBAAmB,KAAK,WAAW,SAAS,EAAE,gBAAgB,YAAY;AAGhF,OAAI,gBAAgB,eAAe,iBAClC,QAAO,KAAK,qCAAqC,sBAAsB,UAAU;IAEjF,QAAO,KAAK,qCAAqC,WAAW,sBAAsB,iBAAiB,kBAAkB;EAEtH,SAAQ,GAAG;AACX,OAAI,aAAa,eAAe;AAC/B,uBAAmB,KAAK,qBAAqB;AAC7C,WAAO;GACP,WAAU,aAAa,qBACvB,OAAM,IAAI,0BAA0B;IAEpC,OAAM;EAEP;CACD;CAED,MAAc,qCAAqCF,WAAmBC,sBAA8BE,iBAAkCC,eAAmB;EACxJ,MAAM,sBAAsB,6BAA6B,gBAAgB;EACzE,MAAM,kBAAkB,MAAM,KAAK,uBAAuB,kBAAkB,WAAW,qBAAqB,cAAc;AAC1H,SAAO,+BAA+B;GACrC,aAAa;GACb,iBAAiB,gBAAgB;GACjC,qBAAqB,gBAAgB,oBAAoB,UAAU;GACnE,kBAAkB,gBAAgB,oBAAoB,OAAO,gBAAgB,iBAAiB,UAAU,GAAG;GAC3G,iBAAiB,gBAAgB;EACjC,EAAC;CACF;CAED,MAAc,qCAAqCH,sBAA8BD,WAAmB;EACnG,MAAM,WAAW,KAAK,WAAW,WAAW,UAAU,KAAK;EAC3D,MAAM,uBAAuB,MAAM,KAAK,gBAAgB,sBAAsB,SAAS;AACvF,SAAO,qCAAqC;GAC3C,aAAa;GACb,iBAAiB,WAAW,qBAAqB,QAAQ,UAAU;GACnE;GACA,eAAe,OAAO,qBAAqB,QAAQ;EACnD,EAAC;CACF;;;;;;;;;;CAWD,MAAc,2BACbtC,WACAJ,UACA+C,YACAX,kBACAY,yBACAC,YACgB;AAChB,OAAK,KAAK,kBAAkB,SAAS,KAAK,KAAK,WAAW,UAAU,CAGnE;AAGD,OAAK,SAAS,uBAAuB,WAAW,gBAAgB,SAAS,YACxE,QAAO,KAAK,yBAAyB,WAAW,UAAU,yBAAyB,WAAW;KACxF;GAEN,MAAM,eAAe,2BAA2B,yBAAyB,WAAW;GACpF,IAAI,gBAAgB,8BAA8B;IACjD,iBAAiB,OAAO,aAAa,qBAAqB;IAC1D,oBAAoB,aAAa;IACjC,YAAY,WAAW;IACvB,kBAAkB,iBAAiB;GACnC,EAAC;AACF,SAAM,KAAK,gBAAgB,KAAK,4BAA4B,cAAc;EAC1E;CACD;;;;;;;CAQD,MAAM,gCAAgCC,cAAmCC,gBAAkD;AAC1H,OAAK,eAAe,KAAK,CAAC,MAAM,EAAE,uBAAuB,KAAK,CAC7D,QAAO,eAAe,OAAO;EAE9B,MAAM,YAAY,MAAM,qBAAqB,aAAa,MAAM;EAChE,MAAM,qBAAqB,eAAe,OAAO,CAAC,MAAM,EAAE,uBAAuB,KAAK;AACtF,MAAI,aAAa,WAAW;GAE3B,MAAM,YAAY,MAAM,KAAK,sCAAsC,aAAa,UAAU;GAC1F,MAAM,sBAAsB,MAAM,KAAK,qBAAqB,WAAW,cAAc,UAAU;AAC/F,SAAM,KAAK,+BAA+B,6BAA6B,oBAAoB,oBAAoB;EAC/G,MACA,SAAQ,KAAK,oCAAoC,mBAAmB,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,KAAK,CAAC;AAElG,OAAK,MAAM,iBAAiB,mBAC3B,OAAM,KAAK,OAAO,wBAAwB,aAAa,UAAU,cAAc,EAAE,aAAa,cAAc,CAAC;AAG9G,SAAO,MAAM,KAAK,aAAa,aAC9B,aACA,UAAU,eAAe,GAAG,EAC5B,eAAe,IAAI,CAAC,kBAAkB,aAAa,cAAc,CAAC,CAClE;CACD;CAED,AAAQ,yBAAyB/C,WAAsBJ,UAA+BoD,eAA6BH,YAAmC;AACrJ,OAAK,8BAA8B,UAAwC,2BAA2B,eAAe,WAAW,CAAC;EAEjI,MAAM,OAAO,cAAc,IAAI,QAAQ,UAAU,KAAK,UAAU,MAAM,GAAG,OAAO,SAAS,eAAe,QAAQ,SAAS,IAAI,KAAK,IAAI,GAAG,SAAS;EAClJ,MAAM,UAAU,KAAK,WAAW,mBAAmB;AACnD,UAAQ,IAAI,UAAU;AACtB,SAAO,KAAK,WACV,QAAQ,MAAM,WAAW,KAAK;GAC9B;GACA,MAAM,KAAK,UAAU,SAAS;GAC9B,aAAa,EAAE,0BAA0B,OAAQ;EACjD,EAAC,CACD,MACA,QAAQ,sBAAsB,CAAC,MAAM;AACpC,WAAQ,IAAI,iEAAiE,EAAE;EAC/E,EAAC,CACF;CACF;CAED,AAAQ,yBAAyBjD,UAAmC;AACnE,aAAW,SAAS,QAAQ,SAC3B,QAAO,SAAS;KACV;GACN,MAAM,UAAU,SAAS;AACzB,UAAO,cAAc,QAAQ;EAC7B;CACD;AACD;AAED,MAAM,YAAY,MAAM,WACvB,QAAO,eAAe,MAAM,WAAkB,UAAU;CACvD,OAAO,WAAY;EAClB,MAAMqD,MAA2B,CAAE;AACnC,OAAK,IAAI,OAAO,OAAO,oBAAoB,KAAK,CAC/C,KAAI,OAAO,KAAK;AAEjB,SAAO;CACP;CACD,cAAc;CACd,UAAU;AACV,EAAC;;;;AC1zBH,oBAAoB;IAEP,iBAAN,MAAqB;;;;;;;;CAQ3B,wBAA2BC,OAAkBC,UAA+BC,IAA+B;EAC1G,IAAIC,YAAiB,EACpB,OAAO,IAAI,QAAQ,MAAM,KAAK,MAAM,MACpC;AAED,OAAK,IAAI,OAAO,OAAO,KAAK,MAAM,OAAO,EAAE;GAC1C,IAAI,YAAY,MAAM,OAAO;GAC7B,IAAI,QAAQ,SAAS;AAErB,OAAI;AACH,cAAU,OAAO,aAAa,KAAK,WAAW,OAAO,GAAG;GACxD,SAAQ,GAAG;AACX,QAAI,UAAU,WAAW,KACxB,WAAU,UAAU,CAAE;AAGvB,cAAU,QAAQ,OAAO,KAAK,UAAU,EAAE;AAC1C,YAAQ,IAAI,yCAAyC,GAAG,MAAM,IAAI,GAAG,MAAM,KAAK,IAAI,QAAQ,KAAK,EAAE;GACnG,UAAS;AACT,QAAI,UAAU,WACb;SAAI,UAAU,MAEb,WAAU,qBAAqB,OAAO;SAC5B,UAAU,GAEpB,WAAU,uBAAuB,OAAO,UAAU;IAClD;GAEF;EACD;AAED,SAAO,KAAW,OAAO,KAAK,MAAM,aAAa,EAAE,OAAO,oBAAoB;AAC7E,OAAI,MAAM,aAAa,iBAAiB,SAAS,gBAAgB,aAAa;IAC7E,MAAM,aAAa,MAAM,aAAa,iBAAiB;IACvD,MAAM,qBAAqB,MAAM,qBAAqB,IAAI,QAAQ,cAAc,MAAM,KAAK,MAAM,aAAa,iBAAiB,SAAS;IACxI,IAAI,cAAc,MAAM,aAAa;AAErC,QAAI,YAAY,gBAAgB,YAAY,aAAa,SAAS,oBAAoB,KACrF,WAAU,mBAAmB;SACnB,SAAS,oBAAoB,KACvC,OAAM,IAAI,kBAAkB,wBAAwB,MAAM,KAAK,GAAG,gBAAgB;SACxE,YAAY,gBAAgB,YAAY,IAClD,QAAO,KAAW,SAAS,kBAAkB,CAAC,cAAc;AAC3D,YAAO,KAAK,wBAAwB,oBAAoB,SAA8B,UAAU,EAAE,GAAG;IACrG,EAAC,CAAC,KAAK,CAAC,wBAAwB;AAChC,eAAU,mBAAmB;IAC7B,EAAC;IAEF,QAAO,KAAK,wBAAwB,oBAAoB,SAAS,kBAAkB,GAAG,CAAC,KAAK,CAAC,uBAAuB;AACnH,eAAU,mBAAmB;IAC7B,EAAC;GAEH,MACA,WAAU,mBAAmB,SAAS;EAEvC,EAAC,CAAC,KAAK,MAAM;AACb,UAAO;EACP,EAAC;CACF;CAED,uBAA0BH,OAAkBI,UAAaF,IAAqD;AAC7G,MAAI,MAAM,aAAa,MAAM,KAC5B,OAAM,IAAI,kBAAkB,aAAa,MAAM,IAAI,GAAG,MAAM,KAAK;EAElE,IAAIG,YAAqC,CAAE;EAC3C,IAAI,IAAI;AAER,OAAK,IAAI,OAAO,OAAO,KAAK,MAAM,OAAO,EAAE;GAC1C,IAAI,YAAY,MAAM,OAAO;GAC7B,IAAI,QAAQ,EAAE;GAEd,IAAI;AAEJ,OAAI,UAAU,aAAa,UAAU,SAAS,EAAE,qBAAqB,QAAQ,KAC5E,kBAAiB,EAAE,qBAAqB;SAC9B,UAAU,cAAc,EAAE,eAAe,OAA4B,WAAW,KAAK,eAAe,UAAU,MAAM,MAAM,CAIpI,kBAAiB;SACP,UAAU,aAAa,UAAU,SAAS,EAAE,eAAe,QAAQ,MAAM;IACnF,MAAM,UAAU,EAAE,aAAa;AAC/B,qBAAiB,aAAa,KAAK,WAAW,OAAO,IAAI,QAAQ;GACjE,WAAU,UAAU,aAAa,EAAE,uBAAuB,SAAS,MAEnE,kBAAiB;IAEjB,kBAAiB,aAAa,KAAK,WAAW,OAAO,GAAG;AAEzD,aAAU,OAAO;EACjB;AAED,MAAI,MAAM,SAAS,KAAK,eAAe,UAAU,IAChD,WAAU,MAAM,kBAAkB,mBAAmB,OAAO,mBAAmB,EAAE,CAAC,CAAC;AAGpF,SAAO,KAAW,OAAO,KAAK,MAAM,aAAa,EAAE,OAAO,oBAAoB;AAC7E,OAAI,MAAM,aAAa,iBAAiB,SAAS,gBAAgB,aAAa;IAC7E,MAAM,aAAa,MAAM,aAAa,iBAAiB;IACvD,MAAM,qBAAqB,MAAM,qBAAqB,IAAI,QAAQ,cAAc,MAAM,KAAK,MAAM,aAAa,iBAAiB,SAAS;IACxI,IAAI,cAAc,MAAM,aAAa;AACrC,QAAI,YAAY,gBAAgB,YAAY,aAAa,EAAE,oBAAoB,KAC9E,WAAU,mBAAmB;SACnB,EAAE,oBAAoB,KAChC,OAAM,IAAI,kBAAkB,sBAAsB,MAAM,KAAK,GAAG,gBAAgB;SACtE,YAAY,gBAAgB,YAAY,IAClD,QAAO,KAAW,EAAE,kBAAkB,CAAC,cAAc;AACpD,YAAO,KAAK,uBAAuB,oBAAoB,WAAW,GAAG;IACrE,EAAC,CAAC,KAAK,CAAC,wBAAwB;AAChC,eAAU,mBAAmB;IAC7B,EAAC;IAEF,QAAO,KAAK,uBAAuB,oBAAoB,EAAE,kBAAkB,GAAG,CAAC,KAAK,CAAC,uBAAuB;AAC3G,eAAU,mBAAmB;IAC7B,EAAC;GAEH,MACA,WAAU,mBAAmB,EAAE;EAEhC,EAAC,CAAC,KAAK,MAAM;AACb,UAAO;EACP,EAAC;CACF;AACD;AAGM,SAAS,aACfC,WACAC,WACAC,OACAN,IACAO,KAAiB,OAAO,mBAAmB,eAAe,EACjC;AACzB,KAAI,cAAc,SAAS,cAAc,eACxC,QAAO;SACG,SAAS,KACnB,KAAI,UAAU,gBAAgB,YAAY,UACzC,QAAO;IAEP,OAAM,IAAI,kBAAkB,QAAQ,UAAU;SAErC,UAAU,WAAW;EAC/B,IAAI,QAAQ;AAEZ,MAAI,UAAU,SAAS,UAAU,OAAO;GACvC,MAAM,SAAS,cAAc,kBAAkB,UAAU,MAAM,MAAM,CAAC;AACtE,kBAAe,WAAW,WAAW,uBAAuB,OAAO,GAAG;EACtE;AAED,SAAO,mBAAmB,WAAW,cAAc,GAAG,EAAE,OAAO,IAAI,MAAM,WAAW,CAAC;CACrF,OAAM;EACN,MAAM,SAAS,kBAAkB,UAAU,MAAM,MAAM;AAEvD,aAAW,WAAW,SACrB,QAAO;IAEP,QAAO,mBAAmB,OAAO;CAElC;AACD;AAGM,SAAS,aAAaH,WAAmBC,WAAuBG,OAAiCR,IAAwB;AAC/H,KAAI,SAAS,KACZ,KAAI,UAAU,gBAAgB,YAAY,UACzC,QAAO;IAEP,OAAM,IAAI,kBAAkB,QAAQ,UAAU;SAErC,UAAU,gBAAgB,YAAY,OAAO,UAAU,GACjE,QAAO,eAAe,UAAU,KAAK;SAC3B,UAAU,WAAW;AAC/B,MAAI,MAAM,KACT,OAAM,IAAI,YAAY,6DAA6D,YAAY,iBAAiB;EAEjH,IAAI,iBAAiB,WAAW,IAAI,mBAAmB,MAAM,CAAC;AAE9D,MAAI,UAAU,SAAS,UAAU,MAChC,QAAO;SACG,UAAU,SAAS,UAAU,iBACvC,QAAO,iBAAiB,eAAe;IAEvC,QAAO,kBAAkB,UAAU,MAAM,uBAAuB,eAAe,CAAC;CAEjF,MACA,QAAO,kBAAkB,UAAU,MAAM,MAAM;AAEhD;;;;;;;AAQD,SAAS,kBAAkBS,MAAgCH,OAAiC;AAC3F,KAAI,SAAS,UAAU,SAAS,SAAS,KACxC,QAAO;SACG,SAAS,UAAU,QAC7B,QAAO,QAAQ,MAAM;SACX,SAAS,UAAU,KAC7B,QAAO,MAAM,SAAS,CAAC,UAAU;SACvB,SAAS,UAAU,iBAC7B,QAAO,eAAe,MAAM;IAE5B,QAAO;AAER;AAED,SAAS,kBAAkBG,MAAgCC,OAA6B;AACvF,KAAI,SAAS,UAAU,MACtB,QAAO,mBAAmB,MAAa;SAC7B,SAAS,UAAU,QAC7B,QAAO,UAAU;SACP,SAAS,UAAU,KAC7B,QAAO,IAAI,KAAK,SAAS,MAAM;SACrB,SAAS,UAAU,iBAC7B,QAAO,iBAAiB,mBAAmB,MAAM,CAAC;IAElD,QAAO;AAER;AAED,SAAS,eAAeC,cAAkC;AACzD,QAAO,SAAS,uBAAuB,aAAa,CAAC;AACrD;AAED,SAAS,iBAAiBC,YAAgC;AACzD,KAAI,WAAW,WAAW,EACzB,QAAO;CAGR,MAAM,SAAS,WAAW,WAAW;AACrC,QAAO,uBAAuB,OAAO;AACrC;AAED,SAAS,eAAeH,MAAsE;AAC7F,SAAQ,MAAR;AACC,OAAK,UAAU,OACd,QAAO;AAER,OAAK,UAAU,OACd,QAAO;AAER,OAAK,UAAU,MACd,QAAO,IAAI,WAAW;AAEvB,OAAK,UAAU,KACd,QAAO,IAAI,KAAK;AAEjB,OAAK,UAAU,QACd,QAAO;AAER,OAAK,UAAU,iBACd,QAAO;AAER,UACC,OAAM,IAAI,kBAAkB,EAAE,KAAK;CACpC;AACD;AAED,SAAS,eAAeA,MAAgCI,OAAyB;AAChF,SAAQ,MAAR;AACC,OAAK,UAAU,OACd,QAAO,UAAU;AAElB,OAAK,UAAU,OACd,QAAO,UAAU;AAElB,OAAK,UAAU,MACd,QAAQ,MAAqB,WAAW;AAEzC,OAAK,UAAU,KACd,QAAO,AAAC,MAAe,SAAS,KAAK;AAEtC,OAAK,UAAU,QACd,QAAO,UAAU;AAElB,OAAK,UAAU,iBACd,QAAO,UAAU;AAElB,UACC,OAAM,IAAI,kBAAkB,EAAE,KAAK;CACpC;AACD;;;;ICnTY,kCAAN,MAAiE;CACvE,MAAM,qBAAqBC,OAAkD;AAC5E,SAAO,MAAM;CACb;CAED,MAAM,MAA4BC,UAA4B;AAC7D,QAAM,IAAI,iBAAiB;CAC3B;CAED,MAAM,KAA2BC,UAAsBC,KAA6BC,OAAgD;AACnI,QAAM,IAAI,iBAAiB;CAC3B;CAED,MAAM,aAAmCC,SAAqBC,QAAmBC,YAA0C;AAC1H,QAAM,IAAI,iBAAiB;CAC3B;CAED,MAAM,UAAuCF,SAAqBG,QAAYC,OAAWC,OAAeC,SAAgC;AACvI,QAAM,IAAI,iBAAiB;CAC3B;CAED,MAAM,eAA8B;AACnC;CACA;CAED,MAAM,MAA4BL,QAAmBL,UAAaW,cAAkC;AACnG,QAAM,IAAI,iBAAiB;CAC3B;CAED,MAAM,cAAoCN,QAAmBO,WAAyC;AACrG,QAAM,IAAI,iBAAiB;CAC3B;CAED,MAAM,OAA6BZ,UAA4B;AAC9D,QAAM,IAAI,iBAAiB;CAC3B;CAED,MAAM,gCAAgCa,SAAiC;AACtE,SAAO;CACP;CAED,MAAM,gCAAgCA,SAAaC,SAA4B;AAC9E;CACA;CAED,MAAM,iBAAgC;AACrC;CACA;CAED,MAAM,sBAA8C;AACnD,SAAO;CACP;CAED,MAAM,cAAgC;AACrC,SAAO;CACP;AACD;;;;MC1DY,iBAAiB;MAEjB,iBAAiB;IAiBjB,gBAAN,MAAoB;CAC1B,AAAQ,iBAAwC;CAEhD,YAA6BC,WAAuCC,cAA4B;EA4BhG,KA5B6B;EA4B5B,KA5BmE;CAA8B;CAElG,MAAMC,SAAsB;AAC3B,OAAK,MAAM;AACX,OAAK,iBAAiB;GACrB,aAAa,KAAK,UAAU,iBAAiB,MAAM,KAAK,OAAO,EAAE,eAAe;GAChF,UAAU,KAAK,aAAa,KAAK;GACjC;EACA;CACD;CAED,AAAQ,QAAQ;AACf,MAAI,KAAK,kBAAkB,KAAM;EAEjC,MAAM,MAAM,KAAK,aAAa,KAAK;AACnC,MAAI,MAAM,KAAK,eAAe,WAAW,eACxC,MAAK,eAAe,SAAS;AAE9B,OAAK,eAAe,WAAW;CAC/B;CAED,OAAa;AACZ,MAAI,KAAK,gBAAgB;AACxB,QAAK,UAAU,mBAAmB,KAAK,eAAe,YAAY;AAClE,QAAK,iBAAiB;EACtB;CACD;AACD;;;;ICnBY,wBAAN,MAAoD;;CAE1D,AAAiB,WAAgD,IAAI;CACrE,AAAiB,QAAoC,IAAI;CACzD,AAAiB,eAAkD,IAAI;CACvE,AAAiB,wBAA+C,IAAI;CACpE,AAAQ,iBAAgC;CACxC,AAAQ,SAAoB;CAC5B,AAAQ,sBAAsB,IAAI;CAElC,KAAK,EAAE,QAAkC,EAAE;AAC1C,OAAK,SAAS;CACd;CAED,SAAS;AACR,OAAK,SAAS;AACd,OAAK,SAAS,OAAO;AACrB,OAAK,MAAM,OAAO;AAClB,OAAK,aAAa,OAAO;AACzB,OAAK,iBAAiB;AACtB,OAAK,oBAAoB,OAAO;CAChC;;;;CAKD,MAAM,IAA0BC,SAAqBC,QAAmBC,WAAkC;EAEzG,MAAM,OAAO,cAAc,QAAQ;EACnC,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,cAAY,gBAAgB,WAAW,UAAU;AACjD,UAAQ,UAAU,MAAlB;AACC,QAAKC,KAAO,QACX,QAAO,MAAO,KAAK,SAAS,IAAI,KAAK,EAAE,IAAI,UAAU,IAAsB,KAAK;AACjF,QAAKA,KAAO,YACX,QAAO,MAAO,KAAK,MAAM,IAAI,KAAK,EAAE,IAAI,cAAc,OAAO,CAAC,EAAE,SAAS,IAAI,UAAU,IAAsB,KAAK;AACnH,QAAKA,KAAO,YACX,QAAO,MAAO,KAAK,aAAa,IAAI,KAAK,EAAE,IAAI,cAAc,OAAO,CAAC,EAAE,SAAS,IAAI,UAAU,IAAsB,KAAK;AAC1H,WACC,OAAM,IAAI,iBAAiB;EAC5B;CACD;CAED,MAAM,eAAkBH,SAAqBC,QAAmBC,WAA8B;EAC7F,MAAM,OAAO,cAAc,QAAQ;EACnC,IAAIE;AACJ,cAAY,MAAM,qBAAqB,QAAQ;AAC/C,cAAY,gBAAgB,WAAW,UAAU;AACjD,UAAQ,UAAU,MAAlB;AACC,QAAKD,KAAO;AACX,SAAK,SAAS,IAAI,KAAK,EAAE,OAAO,UAAU;AAC1C;AACD,QAAKA,KAAO,aAAa;IACxB,MAAM,QAAQ,KAAK,MAAM,IAAI,KAAK,EAAE,IAAI,cAAc,OAAO,CAAC;AAC9D,QAAI,SAAS,MAAM;AAClB,WAAM,SAAS,OAAO,UAAU;AAChC,YAAO,MAAM,UAAU,UAAU;IACjC;AACD;GACA;AACD,QAAKA,KAAO;AACX,SAAK,aAAa,IAAI,KAAK,EAAE,IAAI,cAAc,OAAO,CAAC,EAAE,SAAS,OAAO,UAAU;AACnF;AACD,WACC,OAAM,IAAI,iBAAiB;EAC5B;CACD;CAED,AAAQ,iBAA0CH,SAAqBK,IAAQC,QAAW;AACzF,aAAW,KAAK,UAAU,cAAc,QAAQ,EAAE,MAAM,IAAI,MAAM,CAAC,IAAI,IAAI,OAAO;CAClF;CAED,MAAM,wBAAqDN,SAAqBO,QAAYL,WAAiC;EAC5H,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,cAAY,gBAAgB,WAAW,UAAU;EAEjD,MAAM,QAAQ,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AACjE,SAAO,SAAS,SAAS,sBAAsB,WAAW,MAAM,aAAa,KAAK,sBAAsB,MAAM,cAAc,UAAU;CACtI;CAED,MAAM,IAAIM,gBAA2C;EACpD,MAAM,SAAS,MAAM,eAAe;EACpC,MAAM,UAAU,OAAO;EACvB,MAAM,YAAY,MAAM,qBAAqB,QAAQ;EACrD,IAAI,EAAE,QAAQ,WAAW,GAAG,SAAS,eAAe,IAAI;AACxD,cAAY,gBAAgB,WAAW,UAAU;AACjD,UAAQ,UAAU,MAAlB;AACC,QAAKL,KAAO,SAAS;IACpB,MAAM,gBAAgB;AACtB,SAAK,iBAAiB,cAAc,OAAO,WAAW,cAAc;AACpE;GACA;AACD,QAAKA,KAAO,aAAa;IACxB,MAAM,oBAAoB;IAC1B,MAAM,qBAAqB;AAC3B,aAAS;AACT,UAAM,KAAK,eAAe,oBAAoB,QAAQ,WAAW,kBAAkB;AACnF;GACA;AACD,QAAKA,KAAO,aAAa;IACxB,MAAM,oBAAoB;IAC1B,MAAM,cAAc;AACpB,aAAS;AACT,UAAM,KAAK,eAAe,aAAa,QAAQ,WAAW,kBAAkB;AAC5E;GACA;AACD,WACC,OAAM,IAAI,iBAAiB;EAC5B;CACD;CAED,MAAc,eAAeM,SAAqCF,QAAYL,WAAeQ,QAA2B;EACvH,MAAM,QAAQ,KAAK,aAAa,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AACxE,MAAI,SAAS,MAAM;GAElB,MAAM,WAAW,EAChB,UAAU,IAAI,IAAI,CAAC,CAAC,WAAW,MAAO,CAAC,GACvC;AACD,cAAW,KAAK,cAAc,cAAc,QAAQ,EAAE,MAAM,IAAI,MAAM,CAAC,IAAI,QAAQ,SAAS;EAC5F,MAEA,OAAM,SAAS,IAAI,WAAW,OAAO;CAEtC;;CAGD,MAAc,eAAeC,SAAqCJ,QAAYL,WAAeU,QAA2B;EACvH,MAAM,QAAQ,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AACjE,MAAI,SAAS,MAAM;GAElB,MAAM,WAAW;IAChB,UAAU,CAAC,SAAU;IACrB,cAAc;IACd,cAAc;IACd,UAAU,IAAI,IAAI,CAAC,CAAC,WAAW,MAAO,CAAC;GACvC;AACD,cAAW,KAAK,OAAO,cAAc,QAAQ,EAAE,MAAM,IAAI,MAAM,CAAC,IAAI,QAAQ,SAAS;EACrF,OAAM;AAGN,SAAM,SAAS,IAAI,WAAW,OAAO;GACrC,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,OAAI,MAAM,KAAK,wBAAwB,SAAS,QAAQ,oBAAoB,WAAW,UAAU,CAAC,CACjG,MAAK,gBAAgB,MAAM,UAAU,UAAU;EAEhD;CACD;;CAGD,AAAQ,gBAAgBC,UAAqBX,WAAe;AAC3D,OAAK,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;GACzC,MAAM,eAAe,SAAS;AAC9B,OAAI,sBAAsB,cAAc,UAAU,EAAE;AACnD,aAAS,OAAO,GAAG,GAAG,UAAU;AAChC;GACA;AACD,OAAI,iBAAiB,UACpB;EAED;AACD,WAAS,KAAK,UAAU;CACxB;CAED,MAAM,iBAA8CF,SAAqBO,QAAYO,gBAAoBC,OAAeC,SAAgC;EACvJ,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,mBAAiB,gBAAgB,WAAW,eAAe;EAE3D,MAAM,YAAY,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AAErE,MAAI,aAAa,KAChB,QAAO,CAAE;EAGV,IAAI,QAAQ,UAAU;EACtB,IAAIC,MAAY,CAAE;AAClB,MAAI,SAAS;GACZ,IAAI;AACJ,QAAK,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,IAClC,KAAI,sBAAsB,gBAAgB,MAAM,GAAG,CAClD;AAGF,OAAI,KAAK,GAAG;IACX,IAAI,aAAa,IAAI,IAAI;AACzB,QAAI,aAAa,EAEhB,cAAa;AAEd,UAAM,MAAM,MAAM,YAAY,IAAI,EAAE;AACpC,QAAI,SAAS;GACb,MACA,OAAM,CAAE;EAET,OAAM;GACN,MAAM,IAAI,MAAM,UAAU,CAAC,OAAO,sBAAsB,IAAI,eAAe,CAAC;AAC5E,SAAM,MAAM,MAAM,GAAG,IAAI,MAAM;EAC/B;EACD,IAAIC,SAAc,CAAE;AACpB,OAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,IAC/B,QAAO,KAAK,MAAM,UAAU,SAAS,IAAI,IAAI,GAAG,CAAM,CAAC;AAExD,SAAO;CACP;CAED,MAAM,gBAA6ClB,SAAqBO,QAAYY,YAAqC;EACxH,MAAM,YAAY,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;EAErE,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,eAAa,WAAW,IAAI,CAAC,OAAO,gBAAgB,WAAW,GAAG,CAAC;AAEnE,MAAI,aAAa,KAChB,QAAO,CAAE;EAEV,IAAID,SAAc,CAAE;AACpB,OAAK,IAAI,IAAI,GAAG,IAAI,WAAW,QAAQ,IACtC,QAAO,KAAK,MAAM,UAAU,SAAS,IAAI,WAAW,GAAG,CAAM,CAAC;AAE/D,SAAO;CACP;CAED,MAAM,gBAA6ClB,SAAqBO,QAAsD;EAC7H,MAAM,YAAY,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AAErE,MAAI,aAAa,KAChB,QAAO;EAGR,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,SAAO;GACN,OAAO,oBAAoB,WAAW,UAAU,aAAa;GAC7D,OAAO,oBAAoB,WAAW,UAAU,aAAa;EAC7D;CACD;CAED,MAAM,qBAAkDP,SAAqBO,QAAYa,SAA4B;EACpH,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,YAAU,gBAAgB,WAAW,QAAQ;EAC7C,MAAM,YAAY,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AACrE,MAAI,aAAa,KAChB,OAAM,IAAI,MAAM;AAEjB,YAAU,eAAe;CACzB;CAED,MAAM,qBAAkDpB,SAAqBO,QAAYc,SAA4B;EACpH,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,YAAU,gBAAgB,WAAW,QAAQ;EAC7C,MAAM,YAAY,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AACrE,MAAI,aAAa,KAChB,OAAM,IAAI,MAAM;AAEjB,YAAU,eAAe;CACzB;;;;;;;;CASD,MAAM,mBAAgDrB,SAAqBO,QAAYe,OAAWC,OAA0B;EAC3H,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,UAAQ,gBAAgB,WAAW,MAAM;AACzC,UAAQ,gBAAgB,WAAW,MAAM;EAEzC,MAAM,YAAY,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AACrE,MAAI,aAAa,KAChB,YAAW,KAAK,OAAO,cAAc,QAAQ,EAAE,MAAM,IAAI,MAAM,CAAC,IAAI,QAAQ;GAC3E,UAAU,CAAE;GACZ,cAAc;GACd,cAAc;GACd,UAAU,IAAI;EACd,EAAC;KACI;AACN,aAAU,eAAe;AACzB,aAAU,eAAe;AACzB,aAAU,WAAW,CAAE;EACvB;CACD;CAED,MAAM,cAA2CvB,SAAqBO,QAAgC;EACrG,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,SACC,KAAK,MACH,IAAI,cAAc,QAAQ,CAAC,EAC1B,IAAI,OAAO,EACX,SAAS,IAAI,CAAC,cAAc;AAC7B,UAAO,oBAAoB,WAAW,UAAU;EAChD,EAAC,IAAI,CAAE;CAEV;CAED,MAAM,uBAAuBiB,SAAiC;AAC7D,SAAO,KAAK,oBAAoB,IAAI,QAAQ,IAAI;CAChD;CAED,MAAM,uBAAuBA,SAAaC,SAA4B;AACrE,OAAK,oBAAoB,IAAI,SAAS,QAAQ;CAC9C;CAED,eAA8B;AAC7B,SAAO,QAAQ,SAAS;CACxB;CAED,MAAM,oBAA6C;AAClD,SAAO,KAAK,iBAAiB;GAAE,MAAM;GAAY,MAAM,KAAK;EAAgB,IAAG,EAAE,MAAM,QAAS;CAChG;CAED,MAAM,kBAAkBC,OAA8B;AACrD,OAAK,iBAAiB;CACtB;CAED,MAAM,aAA0C1B,SAAqBO,QAA+B;EACnG,MAAM,YAAY,KAAK,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE,IAAI,OAAO;AAErE,MAAI,aAAa,KAChB,QAAO,CAAE;AAGV,SAAO,UAAU,SAAS,IAAI,CAAC,OAAO,MAAM,UAAU,SAAS,IAAI,GAAG,CAAM,CAAC;CAC7E;CAED,yBAAyBoB,kBAA2D;AACnF,SAAO,KAAK;CACZ;CAED,YAAgB;AACf,SAAO,cAAc,KAAK,QAAQ,+BAA+B;CACjE;CAED,MAAM,iBAAiBC,OAA0B;AAChD,OAAK,MAAM,WAAW,KAAK,SAAS,QAAQ,CAC3C,MAAK,MAAM,CAAC,IAAI,OAAO,IAAI,QAAQ,SAAS,CAC3C,KAAI,OAAO,gBAAgB,MAC1B,SAAQ,OAAO,GAAG;AAIrB,OAAK,MAAM,gBAAgB,KAAK,MAAM,QAAQ,CAC7C,MAAK,0BAA0B,cAAc,MAAM;AAEpD,OAAK,MAAM,gBAAgB,KAAK,aAAa,QAAQ,CACpD,MAAK,0BAA0B,cAAc,MAAM;AAEpD,OAAK,oBAAoB,OAAO,MAAM;CACtC;CAED,MAAM,gBAA6C5B,SAAqBO,QAA2B;AAClG,OAAK,MAAM,IAAI,QAAQ,KAAK,EAAE,OAAO,OAAO;CAC5C;CAED,AAAQ,0BAA0BsB,cAAqDC,OAAe;EAIrG,MAAMC,kBAA4B,CAAE;AACpC,OAAK,MAAM,CAAC,QAAQ,UAAU,IAAI,aAAa,SAAS,CACvD,MAAK,MAAM,CAAC,IAAI,QAAQ,IAAI,UAAU,SAAS,SAAS,CACvD,KAAI,QAAQ,gBAAgB,OAAO;AAClC,mBAAgB,KAAK,OAAO;AAC5B;EACA;AAGH,OAAK,MAAM,UAAU,gBACpB,cAAa,OAAO,OAAO;CAE5B;CAED,oBAAmC;AAClC,SAAO,QAAQ,SAAS;CACxB;;;;;;CAOD,mBAAmBC,QAA+B;AACjD,SAAO,QAAQ,SAAS;CACxB;;;;;CAMD,qBAAqBA,QAA+B;AACnD,SAAO,QAAQ,SAAS;CACxB;AACD;;;;IC9XY,kCAAN,MAA2F;CACjG,AAAQ,SAA6B;CAErC,YAA6BC,WAA6DC,wBAA8D;EAgKxJ,KAhK6B;EAgK5B,KAhKyF;CAAgE;CAE1J,IAAY,QAAsB;AACjC,MAAI,KAAK,UAAU,KAClB,OAAM,IAAI,iBAAiB;AAG5B,SAAO,KAAK;CACZ;CAED,MAAM,WAAWC,MAAkF;EAGlG,MAAM,EAAE,SAAS,cAAc,gBAAgB,GAAG,MAAM,KAAK,WAAW,KAAK;AAC7E,OAAK,SAAS;AACd,SAAO;GACN;GACA;EACA;CACD;CAED,MAAM,eAA8B;AACnC,OAAK,QAAQ,QAAQ;CACrB;CAED,MAAc,WACbA,MACoF;AACpF,MAAI,KAAK,SAAS,UACjB,KAAI;GACH,MAAMC,YAAU,MAAM,KAAK,wBAAwB;AACnD,OAAIA,aAAW,MAAM;IACpB,MAAM,iBAAiB,MAAM,UAAQ,KAAK,KAAK;AAC/C,WAAO;KACN;KACA,cAAc;KACd;IACA;GACD;EACD,SAAQ,GAAG;AAEX,WAAQ,MAAM,kDAAkD,EAAE;AAClE,QAAK,UAAU,EAAE;EACjB;EAGF,MAAM,UAAU,IAAI;AACpB,QAAM,QAAQ,KAAK,KAAK;AACxB,SAAO;GACN;GACA,cAAc;GACd,gBAAgB;EAChB;CACD;CAED,eAAqCC,SAAqBC,QAAmBC,IAAuB;AACnG,SAAO,KAAK,MAAM,eAAe,SAAS,QAAQ,GAAG;CACrD;CAED,IAA0BF,SAAqBC,QAAmBC,IAA2B;AAC5F,SAAO,KAAK,MAAM,IAAI,SAAS,QAAQ,GAAG;CAC1C;CAED,cAA2CF,SAAqBG,QAAgC;AAC/F,SAAO,KAAK,MAAM,cAAc,SAAS,OAAO;CAChD;CAED,uBAAuBC,SAAiC;AACvD,SAAO,KAAK,MAAM,uBAAuB,QAAQ;CACjD;CAED,MAAM,oBAA6C;AAClD,SAAO,KAAK,SAAS,KAAK,MAAM,mBAAmB,GAAG,EAAE,MAAM,gBAAiB;CAC/E;CAED,gBAA6CJ,SAAqBG,QAAmC;AACpG,SAAO,KAAK,MAAM,gBAAgB,SAAS,OAAO;CAClD;CAED,wBAAqDH,SAAqBG,QAAYD,IAA0B;AAC/G,SAAO,KAAK,MAAM,wBAAwB,SAAS,QAAQ,GAAG;CAC9D;CAED,iBAA8CF,SAAqBG,QAAYE,OAAWC,OAAeC,SAAgC;AACxI,SAAO,KAAK,MAAM,iBAAiB,SAAS,QAAQ,OAAO,OAAO,QAAQ;CAC1E;CAED,gBAA6CP,SAAqBQ,QAAgBC,YAAoC;AACrH,SAAO,KAAK,MAAM,gBAAgB,SAAS,QAAQ,WAAW;CAC9D;CAED,aAA0CT,SAAqBG,QAA+B;AAC7F,SAAO,KAAK,MAAM,aAAa,SAAS,OAAO;CAC/C;CAED,eAA8B;AAC7B,SAAO,KAAK,MAAM,cAAc;CAChC;CAED,IAAIO,gBAA2C;AAC9C,SAAO,KAAK,MAAM,IAAI,eAAe;CACrC;CAED,uBAAuBN,SAAaO,SAA4B;AAC/D,SAAO,KAAK,MAAM,uBAAuB,SAAS,QAAQ;CAC1D;CAED,kBAAkBC,OAA8B;AAC/C,SAAO,KAAK,MAAM,kBAAkB,MAAM;CAC1C;CAED,qBAAkDZ,SAAqBG,QAAYD,IAAuB;AACzG,SAAO,KAAK,MAAM,qBAAqB,SAAS,QAAQ,GAAG;CAC3D;CAED,mBAAgDF,SAAqBG,QAAYU,OAAWC,OAA0B;AACrH,SAAO,KAAK,MAAM,mBAAmB,SAAS,QAAQ,OAAO,MAAM;CACnE;CAED,qBAAkDd,SAAqBG,QAAYD,IAAuB;AACzG,SAAO,KAAK,MAAM,qBAAqB,SAAS,QAAQ,GAAG;CAC3D;CAED,yBAAyBa,kBAA2D;AACnF,SAAO,KAAK,MAAM,yBAAyB,iBAAiB;CAC5D;CAED,YAAgB;AACf,SAAO,KAAK,MAAM,WAAW;CAC7B;CAED,MAAM,iBAAiBC,OAA0B;AAChD,SAAO,KAAK,MAAM,iBAAiB,MAAM;CACzC;CAED,MAAM,gBAA6ChB,SAAqBG,QAA2B;AAClG,SAAO,KAAK,MAAM,gBAAgB,SAAS,OAAO;CAClD;CAED,oBAAmC;AAClC,SAAO,KAAK,MAAM,mBAAmB;CACrC;;;;;;CAOD,mBAAmBA,QAA2B;AAC7C,SAAO,KAAK,MAAM,mBAAmB,OAAO;CAC5C;;;;;CAMD,qBAAqBA,QAA2B;AAC/C,SAAO,KAAK,MAAM,qBAAqB,OAAO;CAC9C;AACD;;;;ACxLD,oBAAoB;IAIP,kBAAN,MAAkD;CACxD,YACkBc,YACAC,kBACAC,gBACAC,cAChB;EAiIF,KArIkB;EAqIjB,KApIiB;EAoIhB,KAnIgB;EAmIf,KAlIe;CACd;CAEJ,IACCC,SACAC,MACAC,QACiD;AACjD,SAAO,KAAK,sBAAsB,SAAS,WAAW,KAAK,MAAM,OAAO;CACxE;CAED,KACCF,SACAG,MACAD,QACkD;AAClD,SAAO,KAAK,sBAAsB,SAAS,WAAW,MAAM,MAAM,OAAO;CACzE;CAED,IACCF,SACAI,MACAF,QACiD;AACjD,SAAO,KAAK,sBAAsB,SAAS,WAAW,KAAK,MAAM,OAAO;CACxE;CAED,OACCF,SACAK,MACAH,QACoD;AACpD,SAAO,KAAK,sBAAsB,SAAS,WAAW,QAAQ,MAAM,OAAO;CAC3E;CAED,MAAc,sBACbI,SACAC,QACAC,eACAC,QACe;EACf,MAAM,mBAAmB,KAAK,oBAAoB,SAAS,OAAO;AAClE,MACC,iBAAiB,UACjB,QAAQ,cAAc,SACrB,MAAM,qBAAqB,iBAAiB,OAAO,EAAE,cACrD,KAAK,iBAAiB,iBAAiB,CAKxC,OAAM,IAAI,sBAAsB,oGAAoG,QAAQ,KAAK;EAGlJ,MAAM,eAAe,MAAM,KAAK,gBAAgB,iBAAiB;EAEjE,MAAM,QAAQ,QAAQ,QAAQ,IAAI,aAAa,CAAC,GAAG,QAAQ,KAAK,aAAa,CAAC;EAC9E,MAAM,UAAU;GAAE,GAAG,KAAK,iBAAiB,mBAAmB;GAAE,GAAG,QAAQ;GAAc,GAAG;EAAc;EAE1G,MAAM,kBAAkB,MAAM,KAAK,oBAAoB,kBAAkB,eAAe,SAAS,QAAQ,UAAU,KAAK;EAExH,MAAMC,OAA2B,MAAM,KAAK,WAAW,QAAQ,MAAM,QAAQ;GAC5E,aAAa,QAAQ;GACrB;GACA,cAAc,UAAU;GACxB,MAAM,mBAAmB;GACzB,oBAAoB,QAAQ;GAC5B,SAAS,QAAQ;EACjB,EAAC;AAEF,MAAI,iBAAiB,OACpB,QAAO,MAAM,KAAK,gBAAgB,iBAAiB,QAAQ,MAAgB,OAAO;CAEnF;CAED,AAAQ,oBAAoBJ,SAAqBC,QAAsC;AACtF,UAAQ,QAAR;AACC,QAAK,WAAW,IACf,QAAQ,QAAuB;AAChC,QAAK,WAAW,KACf,QAAQ,QAAwB;AACjC,QAAK,WAAW,IACf,QAAQ,QAAuB;AAChC,QAAK,WAAW,OACf,QAAQ,QAA0B;EACnC;CACD;CAED,MAAc,gBAAgBI,kBAAqD;EAElF,MAAM,cAAc,iBAAiB,QAAQ,iBAAiB;AAC9D,MAAI,eAAe,KAClB,OAAM,IAAI,iBAAiB;EAE5B,MAAM,QAAQ,MAAM,qBAAqB,YAAY;AACrD,SAAO,MAAM;CACb;CAED,MAAc,oBACbA,kBACAH,eACAF,SACAC,QACAK,QACyB;AACzB,MAAI,iBAAiB,QAAQ,MAAM;AAClC,OAAI,iBAAiB,SAAS,cAAc,iBAAiB,MAAM,cAAc,MAAM,CACtF,OAAM,IAAI,kBAAkB,wBAAwB,QAAQ,KAAK,GAAG,OAAO;GAG5E,MAAM,mBAAmB,MAAM,qBAAqB,iBAAiB,KAAK;AAC1E,OAAI,iBAAiB,aAAa,QAAQ,cAAc,KACvD,OAAM,IAAI,iBAAiB,sEAAsE;GAGlG,MAAM,kBAAkB,MAAM,KAAK,eAAe,uBAAuB,kBAAkB,eAAe,QAAQ,cAAc,KAAK;AACrI,UAAO,KAAK,UAAU,gBAAgB;EACtC,MACA,QAAO;CAER;CAED,MAAc,gBAAkCC,SAAqBC,MAAcL,QAAoD;EACtI,MAAM,oBAAoB,MAAM,qBAAqB,QAAQ;EAE7D,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,GAAG,MAAO,MAAM,cAAc,YAAY,EAAG;EAChF,MAAM,qBAAqB,MAAM,KAAK,cAAc,CAAC,yBAAyB,SAAS;AACvF,SAAO,KAAK,eAAe,wBAAwB,mBAAmB,UAAU,sBAAsB,QAAQ,cAAc,KAAK;CACjI;AACD;;;;IC5IY,aAAN,MAA6C;CACnD,AAAQ,OAAoB;CAC5B,AAAQ,cAA6B;CACrC,AAAQ;CAER,YAA6BM,UAAqCC,eAA8B;EA0MhG,KA1M6B;EA0M5B,KA1MiE;AACjE,OAAK,OAAO;CACZ;CASD,eAAeC,aAA4B;AAC1C,OAAK,cAAc;CACnB;CAED,iBAAgC;AAC/B,SAAO,KAAK;CACZ;CAED,QAAQC,MAAY;AACnB,MAAI,KAAK,eAAe,KACvB,OAAM,IAAI,iBAAiB;AAE5B,OAAK,OAAO;CACZ;CAED,mBAAmBC,mBAA2B;AAC7C,MAAI,KAAK,QAAQ,KAChB,OAAM,IAAI,iBAAiB;EAE5B,MAAM,sBAAsB,KAAK,KAAK;EACtC,MAAM,sBAAsB;GAC3B,SAAS,OAAO,oBAAoB,gBAAgB;GACpD,QAAQ,WAAW,mBAAmB,oBAAoB,WAAW;EACrE;AACD,OAAK,SAAS,uBAAuB,oBAAoB;AACzD,OAAK,+BAA+B,kBAAkB;CACtD;CAED,+BAA+BC,mBAA6B;AAC3D,MAAI,KAAK,QAAQ,KAChB,OAAM,IAAI,iBAAiB;EAE5B,MAAM,sBAAsB,KAAK,KAAK;EACtC,MAAM,8BAA8B,KAAK,kCAAkC,oBAAoB,OAAO,kBAAkB;AACxH,OAAK,SAAS,+BAA+B,4BAA4B;CACzE;CAED,kCAAkCC,aAAiBF,mBAAmC;AAQrF,SAAO,KAAK,cAAc,kBAAkB;GAC3C,MAAM;GACN,KAAK;GACL,SAAS;EACT,EAAC;CACF;CAED,MAAM,WAAWD,MAAY;AAC5B,MAAI,KAAK,QAAQ,KAChB,OAAM,IAAI,iBAAiB;AAE5B,OAAK,OAAO;AACZ,QAAM,KAAK,SAAS,wBAAwB,KAAK;CACjD;CAED,UAAuB;AACtB,SAAO,KAAK;CACZ;;;;CAKD,oBAA0B;AACzB,SAAO,KAAK,cACT,EACA,aAAa,KAAK,YACjB,IACD,CAAE;CACL;CAED,iBAAqB;AACpB,SAAO,KAAK,iBAAiB,CAAC,UAAU;CACxC;CAED,iBAAuB;EACtB,IAAI,SAAS,KAAK,iBAAiB,CAAC,YAAY,IAAI,CAAC,eAAe,WAAW,MAAM;AACrF,SAAO,KAAK,KAAK,iBAAiB,CAAC,UAAU,MAAM;AACnD,SAAO;CACP;CAED,yBAAuC;EAGtC,MAAM,sBAAsB,KAAK,SAAS,wBAAwB;AAClE,MAAI,uBAAuB,KAC1B,KAAI,KAAK,qBAAqB,CAC7B,OAAM,IAAI,qBAAqB;IAE/B,OAAM,IAAI,iBAAiB;AAG7B,SAAO;CACP;CAED,cAAcI,SAA8B;EAC3C,IAAI,aAAa,KAAK,iBAAiB,CAAC,YAAY,KAAK,CAACC,MAAuB,SAAS,EAAE,OAAO,QAAQ,CAAC;AAE5G,OAAK,WACJ,OAAM,IAAI,OAAO,wBAAwB,QAAQ;AAGlD,SAAO;CACP;CAED,SAASD,SAAsB;AAC9B,OAAK,KAAK,KACT,QAAO;IAEP,QAAO,YAAY,KAAK,KAAK,UAAU,SAAS,KAAK,KAAK,YAAY,KAAK,CAAC,MAAM,EAAE,UAAU,QAAQ;CAEvG;CAED,WAAWE,WAA0B;AACpC,MAAI,cAAc,UAAU,KAC3B,QAAO,KAAK,gBAAgB;KACtB;GACN,IAAI,aAAa,KAAK,iBAAiB,CAAC,YAAY,KAAK,CAAC,MAAM,EAAE,cAAc,UAAU;AAE1F,QAAK,WACJ,OAAM,IAAI,MAAM,8BAA8B,YAAY,eAAe,KAAK,iBAAiB,CAAC;AAGjG,UAAO,WAAW;EAClB;CACD;CAED,YAAYA,WAA4B;AACvC,SAAO,KAAK,iBAAiB,CAC3B,YAAY,OAAO,CAAC,MAAM,EAAE,cAAc,UAAU,CACpD,IAAI,CAAC,OAAO,GAAG,MAAM;CACvB;CAED,sBAA+B;AAC9B,SAAO,KAAK,QAAQ;CACpB;CAED,kBAA2B;AAE1B,SAAO,KAAK,SAAS,wBAAwB,IAAI;CACjD;CAED,kBAAwB;AACvB,SAAO,cAAc,KAAK,KAAK;CAC/B;CAED,gBAAgBC,QAA+B;AAC9C,OAAK,eAAe;AACpB,UAAQ,IAAI,0BAA0B,OAAO,aAAa;CAC1D;CAED,WAAoB;AACnB,SAAO,KAAK,aAAa;CACzB;CAED,QAAQ;AACP,OAAK,OAAO;AACZ,OAAK,cAAc;AACnB,OAAK,SAAS,OAAO;AACrB,OAAK,eAAe,4BAA4B,EAC/C,cAAc,MACd,EAAC;CACF;CAED,mBAAmBC,0BAAoD;EACtE,MAAM,8BAA8B,KAAK,SAAS,gCAAgC;AAClF,MAAI,+BAA+B,MAAM;AACxC,WAAQ,IAAI,0EAA0E;AACtF;EACA;EACD,IAAI;AACJ,MAAI;AACH,0BAAuB,WAAW,6BAA6B,yBAAyB,4BAA4B;EACpH,SAAQ,GAAG;AAGX,WAAQ,KAAK,uCAAuC,EAAE;AACtD;EACA;EACD,MAAM,kBAAkB;GACvB,QAAQ;GACR,SAAS,OAAO,yBAAyB,oBAAoB;EAC7D;AACD,UAAQ,KAAK,sCAAsC,yBAAyB,oBAAoB,EAAE;AAClG,OAAK,SAAS,uBAAuB,gBAAgB;CACrD;AACD;;;;IC3NY,gCAAN,MAA+D;CACrE,YAA6BC,WAA4B;EA0BzD,KA1B6B;CAA8B;CAC3D,MAAM,OAAO,GAAG,MAA6C;AAC5D,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAU,GAAG;EAAK,EAAC;CACjF;CACD,MAAM,QAAQ,GAAG,MAA8C;AAC9D,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAW,GAAG;EAAK,EAAC;CAClF;CACD,MAAM,SAAS,GAAG,MAA+C;AAChE,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAY,GAAG;EAAK,EAAC;CACnF;CACD,MAAM,IAAI,GAAG,MAA0C;AACtD,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAO,GAAG;EAAK,EAAC;CAC9E;CACD,MAAM,IAAI,GAAG,MAA0C;AACtD,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAO,GAAG;EAAK,EAAC;CAC9E;CACD,MAAM,IAAI,GAAG,MAA0C;AACtD,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAO,GAAG;EAAK,EAAC;CAC9E;CACD,MAAM,mBAAmB,GAAG,MAAyD;AACpF,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAsB,GAAG;EAAK,EAAC;CAC7F;CACD,MAAM,qBAAqB,GAAG,MAA2D;AACxF,SAAO,KAAK,UAAU,aAAa,OAAO;GAAC;GAAmB;GAAwB,GAAG;EAAK,EAAC;CAC/F;AACD;;;;IChBY,gBAAN,MAAoB;CAC1B,AAAQ,aAAqB;CAC7B,AAAQ,oBAA4B,KAAK,KAAK;CAE9C,YACkBC,YACAC,iBACAC,UACAC,qBAChB;EA2DF,KA/DkB;EA+DjB,KA9DiB;EA8DhB,KA7DgB;EA6Df,KA5De;CACd;;;;CAKJ,WAAWC,SAA4C;AACtD,MAAI;AACH,UAAO,KAAK,OAAO,WAAW,QAAQ;EACtC,UAAS;AACT,QAAK,aAAa,KAAK,aAAa,QAAQ,OAAO,CAAC,KAAK,UAAU,MAAM,UAAU,KAAK,EAAE;GAC1F,MAAM,MAAM,IAAI,OAAO,SAAS;AAEhC,OAAI,KAAK,aAAa,OAAQ,MAAM,KAAK,oBAAoB,KAAe;AAC3E,SAAK,oBAAoB;AACzB,SAAK,aAAa;AAClB,SAAK,cAAc;GACnB;EACD;CACD;CAED,eAA8B;AAE7B,OAAK,KAAK,WAAW,iBAAiB,KAAK,KAAK,WAAW,UAAU,CAAE,QAAO,QAAQ,SAAS;EAC/F,MAAM,eAAe,KAAK,WAAW,wBAAwB;EAC7D,MAAM,cAAc,kBAAkB;GACrC,gBAAgB,aAAa,aAAa,QAAQ,KAAK,OAAO,mBAAmB,GAAG,CAAC;GACrF,gBAAgB,aAAa,QAAQ,UAAU;EAC/C,EAAC;AACF,SAAO,KAAK,gBACV,IAAI,gBAAgB,YAAY,CAChC,MAAM,QAAQ,aAAa,KAAK,CAAC,CACjC,MACA,QAAQ,iBAAiB,CAAC,MAAM;AAC/B,WAAQ,IAAI,2BAA2B,EAAE;EACzC,EAAC,CACF,CACA,MACA,QAAQ,yBAAyB,CAAC,MAAM;AACvC,WAAQ,IAAI,2BAA2B,EAAE;EACzC,EAAC,CACF;CACF;;;;CAKD,MAAa,YAAYC,oBAAuD;AAC/E,MAAI,mBAAmB,eACtB,KAAI;GACH,MAAM,kBAAkB,KAAK,qBAAqB;GAClD,MAAM,eAAe,MAAM,gBAAgB,oBAAoB,OAAO,mBAAmB,kBAAkB,EAAE,CAAC;GAC9G,MAAM,UAAU,wBAAwB,cAAc,mBAAmB,eAAe;AACxF,UAAO,iBAAiB,QAAQ;EAChC,SAAQ,OAAO;AACf,WAAQ,IAAI,6BAA6B,MAAM;EAC/C;CAEF;AACD;;;;ACvED,oBAAoB;IAQP,wBAAN,MAA4B;CAGlC,AAAiB;CAEjB,AAAiB;CAEjB,YAA6BC,iBAAoDC,kBAAoCC,cAA4B;EA0QjJ,KA1Q6B;EA0Q5B,KA1QgF;AAChF,OAAK,YAAY,IAAI,qBAAqB;AAC1C,OAAK,aAAa,IAAI,qBAAqB;CAC3C;;;;;;CAOD,MAAM,kBAAkBC,iBAAkCC,cAAiD;EAC1G,MAAM,kBAAkB,YAAY;GACnC,MAAM,eAAe,4BAA4B;IAChD;IACA,OAAO,oBAAoB,EAC1B,mBAAmB,aACnB,EAAC;IACF,MAAM;GACN,EAAC;GACF,MAAM,EAAE,gBAAgB,GAAG,MAAM,KAAK,gBAAgB,KAAK,wBAAwB,aAAa;AAChG,UAAO;EACP;EACD,MAAM,MAAM,KAAK,kBAAkB,cAAc,gBAAgB;AACjE,SAAO,KAAK,WAAW,SAAS,KAAK,CAAE,GAAE,gBAAgB;CACzD;CAED,AAAQ,kBAAkBC,cAAsBF,iBAAkC;AACjF,SAAO,eAAe;CACtB;;;;;;CAOD,gBAAgBA,iBAAkCC,cAAwB;EACzE,MAAM,MAAM,KAAK,kBAAkB,cAAc,gBAAgB;AACjE,OAAK,WAAW,uBAAuB,IAAI;CAC3C;;;;;;;;;;CAWD,MAAM,kCACLD,iBACAG,sBACAC,iBACgC;AAChC,MAAI,QAAQ,qBAAqB,CAChC,OAAM,IAAI,iBAAiB;EAE5B,MAAM,iBAAiB,qBAAqB,GAAG;AAC/C,OAAK,qBAAqB,MAAM,CAAC,aAAa,SAAS,WAAW,eAAe,CAChF,OAAM,IAAI,iBAAiB;EAG5B,MAAM,YAAY,KAAK,aAAa,qBAAqB;EAEzD,MAAM,kBAAkB,aAAa,YAAY;GAChD,MAAM,cAAc,qBAAqB,IAAI,CAAC,EAAE,WAAW,KAAK,iBAAiB,EAAE,YAAY,UAAW,EAAC,CAAC;GAC5G,MAAM,eAAe,4BAA4B;IAChD;IACA,MAAM,mBAAmB;KACxB;KACA;KACA;IACA,EAAC;IACF,OAAO;GACP,EAAC;GACF,MAAM,EAAE,gBAAgB,GAAG,MAAM,KAAK,gBAAgB,KAAK,wBAAwB,cAAc,gBAAgB;AACjH,UAAO;EACP,EAAC;AAEF,SAAO,KAAK,UAAU,SACrB,WACA,qBAAqB,IAAI,CAAC,aAAa,SAAS,UAAU,EAC1D,gBACA;CACD;;;;;;;;CASD,MAAM,sBACLJ,iBACAK,qBACAD,iBACgC;EAChC,MAAM,YAAY,KAAK,aAAa,CAAC,mBAAoB,EAAC;EAC1D,MAAM,kBAAkB,YAAY;GACnC,MAAM,iBAAiB,oBAAoB;GAC3C,MAAM,aAAa,oBAAoB;GACvC,MAAM,cAAc,CAAC,iBAAiB,EAAE,WAAY,EAAC,AAAC;GACtD,MAAM,eAAe,4BAA4B;IAChD;IACA,MAAM,mBAAmB;KACxB;KACA;KACA;IACA,EAAC;IACF,OAAO;GACP,EAAC;GACF,MAAM,EAAE,gBAAgB,GAAG,MAAM,KAAK,gBAAgB,KAAK,wBAAwB,cAAc,gBAAgB;AACjH,UAAO;EACP;AACD,SAAO,KAAK,UAAU,SAAS,WAAW,CAAC,oBAAoB,SAAU,GAAE,gBAAgB;CAC3F;;;;;CAMD,oBAAoBC,qBAAoD;AACvE,OAAK,UAAU,gBAAgB,oBAAoB,UAAU;EAC7D,MAAM,YAAY,KAAK,aAAa,CAAC,mBAAoB,EAAC;AAC1D,OAAK,UAAU,uBAAuB,UAAU;CAChD;;;;;CAMD,iCAAiCC,sBAAuD;AACvF,OAAK,UAAU,SAAS,qBAAqB,IAAI,CAAC,aAAa,SAAS,UAAU,CAAC;EACnF,MAAM,YAAY,KAAK,aAAa,qBAAqB;AACzD,OAAK,UAAU,uBAAuB,UAAU;CAChD;;;;;CAMD,MAAM,wBAAwBC,WAA8C;EAC3E,MAAM,kBAAkB,YAAY;GACnC,MAAM,eAAe,4BAA4B;IAChD,iBAAiB;IACjB,MAAM,mBAAmB;KACxB;KACA,aAAa,CAAE;KACf,gBAAgB;IAChB,EAAC;IACF,OAAO;GACP,EAAC;GACF,MAAM,EAAE,gBAAgB,GAAG,MAAM,KAAK,gBAAgB,KAAK,wBAAwB,aAAa;AAChG,UAAO;EACP;AACD,SAAO,KAAK,UAAU,SAAS,WAAW,CAAE,GAAE,gBAAgB;CAC9D;;;;;CAMD,kBAAkBA,WAAqB;AACtC,OAAK,UAAU,uBAAuB,UAAU;CAChD;CAED,AAAQ,aAAaJ,sBAA8D;AAClF,MAAI,QAAQ,qBAAqB,CAChC,OAAM,IAAI,iBAAiB;EAE5B,MAAM,aAAa,IAAI;AACvB,OAAK,MAAM,uBAAuB,sBAAsB;AACvD,OAAI,QAAQ,oBAAoB,MAAM,CACrC,OAAM,IAAI,iBAAiB;AAE5B,QAAK,MAAM,QAAQ,oBAAoB,MACtC,YAAW,IAAI,KAAK,UAAU;EAE/B;AAED,MAAI,WAAW,QAAQ,EACtB,OAAM,IAAI,OAAO,uCAAuC,WAAW;AAEpE,SAAO,qBAAqB,GAAG,MAAM,GAAG;CACxC;;;;;;;CAQD,MAAa,kBAAkBK,sBAA4CC,yBAA+BC,SAAsC;EAC/I,MAAM,YAAY,MAAM,qBAAqB,QAAQ;AACrD,SAAO,OAAO,OACb,yBACA;GACC,iBAAiB,qBAAqB;GACtC,GAAG,UAAU;EACb,GACD,KAAK,iBAAiB,mBAAmB,CACzC;CACD;AACD;;;;;;AAOD,SAAS,2BAA2BF,sBAA4CT,cAAqC;AACpH,QAAO,qBAAqB,QAAQ,SAAS,GAAG,aAAa,KAAK;AAClE;IAEK,uBAAN,MAA2B;CAC1B,AAAiB,cAA6C,IAAI;CAClE,AAAiB,aAA4C,IAAI;CAEjE,YAA6BA,cAA4B;EA+CvD,KA/C2B;CAA8B;;;;;CAM3D,MAAa,SACZY,mBACAC,aACAC,QACgC;EAChC,MAAM,eAAe,oBAAoB,KAAK,WAAW,IAAI,kBAAkB,GAAG;AAClF,MAAI,gBAAgB,QAAQ,2BAA2B,cAAc,KAAK,aAAa,CACtF,QAAO;EAGR,MAAM,SAAS,YAAY,YAAY,IAAI,CAAC,OAAO,KAAK,YAAY,IAAI,GAAG,IAAI,KAAK,CAAC;EACrF,MAAM,kBAAkB,MAAM,OAAO;AACrC,MAAI,OAAO,UAAU,KAAK,mBAAmB,SAAS,2BAA2B,iBAAiB,KAAK,aAAa,EAAE;GACrH,MAAM,WAAW,MAAM,QAAQ;AAC/B,OAAI,qBAAqB,QAAQ,SAAS,cAAc,oBAAoB,QAC3E,MAAK,WAAW,IAAI,mBAAmB,SAAS;IAEhD,MAAK,MAAM,MAAM,YAChB,MAAK,YAAY,IAAI,IAAI,SAAS;AAGpC,UAAO;EACP,MACA,QAAO;CAER;CAED,AAAO,gBAAgBC,IAAc;AACpC,OAAK,SAAS,CAAC,EAAG,EAAC;CACnB;CAED,AAAO,uBAAuBA,IAAc;AAC3C,OAAK,WAAW,OAAO,GAAG;CAC1B;CAED,AAAO,SAASC,KAAiB;AAChC,OAAK,MAAM,MAAM,IAChB,MAAK,YAAY,OAAO,GAAG;CAE5B;AACD;;;;AC3RD,oBAAoB;MAEP,0CAA0C;IAS1C,iCAAN,MAAqC;CAC3C,AAAQ,gCAA2D,CAAE;CACrE,AAAiB;CACjB,AAAQ,kCAA4F;CAEpG,YACkBC,YACAC,iBAEjBC,oBAA4B,yCAC3B;EA2CF,KA/CkB;EA+CjB,KA9CiB;AAIjB,OAAK,gCAAgC,SAAS,mBAAmB,MAAM,KAAK,mBAAmB,CAAC;CAChG;;;;;;;CAQD,MAAM,0BAA0BC,qBAAgDC,WAAsB;AACrG,MAAI,KAAK,WAAW,UAAU,EAAE;GAC/B,MAAM,0BAA0B,MAAM,qBAAqB,sBAAsB;AACjF,OAAI,wBAAwB,OAAO,UAAU,IAAI;AAChD,SAAK,8BAA8B,KAAK,GAAG,oBAAoB;AAC/D,SAAK,+BAA+B;GACpC;EACD;CACD;CAED,MAAc,oBAAmC;EAChD,MAAM,sBAAsB,KAAK;AACjC,OAAK,gCAAgC,CAAE;AACvC,MAAI;AACH,OAAI,oBAAoB,SAAS,EAChC,OAAM,KAAK,6BAA6B,oBAAoB;EAE7D,SAAQ,GAAG;AACX,OAAI,aAAa,aAAa;AAC7B,SAAK,8BAA8B,KAAK,GAAG,oBAAoB;AAC/D,SAAK,+BAA+B;GACpC,OAAM;AACN,YAAQ,IAAI,oCAAoC,EAAE,MAAM,oBAAoB,OAAO;AACnF,UAAM;GACN;EACD;CACD;CAED,MAAM,6BAA6BD,qBAAgD;EAClF,MAAM,QAAQ,8BAA8B,EAAE,qBAAqB,oBAAqB,EAAC;AACzF,QAAM,KAAK,gBAAgB,KAAK,0BAA0B,MAAM;CAChE;AACD;;;;IC/CY,2BAAN,MAA2D;CACjE,YACkBE,sBACAC,YACAC,YACAC,cACAC,iBACAC,uBACAC,mBACAC,uBACAC,WACAC,0BAChB;EAwEF,KAlFkB;EAkFjB,KAjFiB;EAiFhB,KAhFgB;EAgFf,KA/Ee;EA+Ed,KA9Ec;EA8Eb,KA7Ea;EA6EZ,KA5EY;EA4EX,KA3EW;EA2EV,KA1EU;EA0ET,KAzES;CACd;CAEJ,wBAAwBC,OAA0B;AACjD,OAAK,qBAAqB,qBAAqB,MAAM;CACrD;CAED,MAAM,uBAAuBC,QAAwBC,SAAaC,SAA4B;AAC7F,QAAM,KAAK,qBAAqB,OAAO;AACvC,QAAM,CAAC,MAAM,KAAK,YAAY,EAAE,qBAAqB,OAAO;AAC5D,QAAM,KAAK,gBAAgB,uBAAuB,QAAQ,QAAQ;AAGlE,OAAK,QAAQ,KAAK,eAAe,EAAE;GAClC,MAAM,cAAc;IAAE;IAAS;IAAS;GAAQ;GAChD,MAAM,wBAAwB,MAAM,KAAK,uBAAuB;AAChE,SAAM,sBAAsB,uBAAuB,YAAY;AAC/D,QAAK,yBAAyB,CAAC,WAAY,EAAC;EAC5C;CACD;;;;CAKD,MAAM,0BAA0BC,SAAoC;AAClE,GAAC,MAAM,KAAK,YAAY,EAAE,8BAA8B,QAAQ;CACjE;CAED,QAAQC,eAAsB;AAC7B,OAAK,UAAU,cAAc;CAC7B;CAED,sBAAsBC,cAAqC;AAC1D,OAAK,qBAAqB,sBAAsB,aAAa;AAC7D,OAAK,eAAe,EAAE;GACrB,MAAM,OAAO,KAAK,WAAW,SAAS;AACtC,OAAI,aAAa,gBAAgB,QAAQ,KAAK,gBAAgB,YAAY,SACzE,MAAK,kBAAkB,qCAAqC,KAAK;IAEjE,MAAK,kBAAkB,OAAO;EAE/B;CACD;CAED,iBAAiBC,SAA+B;AAC/C,OAAK,gBAAgB,yBAAyB,QAAQ;CACtD;CAED,MAAc,qBAAqBC,MAAqC;EAEvE,MAAMC,kBAA6B,CAAE;EACrC,MAAM,OAAO,KAAK,WAAW,SAAS;AACtC,MAAI,QAAQ,KAAM;AAClB,OAAK,MAAM,UAAU,KACpB,KACC,OAAO,cAAc,cAAc,UACnC,oBAAoB,aAAa,OAAO,aAAa,OAAO,KAAK,IACjE,SAAS,KAAK,KAAK,OAAO,WAAW,CAErC,OAAM,KAAK,WAAW,WAAW,MAAM,KAAK,aAAa,KAAK,aAAa,KAAK,IAAI,CAAC;UAEpF,OAAO,cAAc,cAAc,UAAU,OAAO,cAAc,cAAc,WACjF,oBAAoB,iCAAiC,OAAO,aAAa,OAAO,KAAK,IACrF,SAAS,KAAK,UAAU,OAAO,OAAO,WAAW,CAEjD,OAAM,CAAC,MAAM,KAAK,uBAAuB,EAAE,yBAAyB;SAC1D,OAAO,cAAc,cAAc,UAAU,oBAAoB,uBAAuB,OAAO,aAAa,OAAO,KAAK,CAClI,iBAAgB,KAAK,CAAC,OAAO,gBAAgB,OAAO,UAAW,EAAC;AAGlE,QAAM,KAAK,kBAAkB,uBAAuB,gBAAgB;CACpE;AACD;;;;ICtGY,eAAN,MAAmB;CACzB,MAAM,2BAA4C;AACjD,SAAO,YAAY,iBAAiB,CAAC;CACrC;CAED,MAAM,SAA4B;EACjC,MAAM,SAAS;EACf,MAAM,SAAS,OAAO;AAEtB,MAAI,OACH,QAAO,OAAO,YAAY;IAE1B,QAAO,CAAE;CAEV;CAED,MAAM,OAAOC,MAA+B;EAC3C,MAAM,EAAE,QAAQ,GAAG,MAAM,OAAO;AAChC,SAAO,OAAO,KAAK;CACnB;AACD;;;;ACrBD,oBAAoB;IAkBP,qBAAN,MAAmD;CAEzD,AAAQ,SAAsC,IAAI,WAAW,YAAY;AACxE,SAAO,MAAM,UAAU;CACvB;CAED,MAAM,0BAA0BC,YAAoBC,MAAsC;AACzF,SAAO,0BAAkC,MAAM,KAAK,OAAO,UAAU,EAAE,YAAY,KAAK;CACxF;AACD;IAKY,uBAAN,MAAqD;CAC3D,YAA6BC,oBAAwC;EAOrE,KAP6B;CAA0C;CAEvE,MAAM,0BAA0BF,YAAoBC,MAAsC;EACzF,MAAM,OAAO,MAAM,KAAK,mBAAmB,8BAA8B,YAAY,KAAK;AAC1F,SAAO,qBAAqB,KAAK;CACjC;AACD;;;;AC5BD,oBAAoB;IA8BP,kBAAN,MAA6C;CACnD,YAA6BE,UAA0B;EA0CvD,KA1C6B;CAA4B;CAGzD,AAAQ,SAAoC,IAAI,WAAW,YAAY;AACtE,MAAI,KAAK,SACR,QAAO,KAAK;AAGb,SAAO,MAAM,YAAU;CACvB;CAED,MAAM,kBAAyC;AAC9C,SAAO,gBAAqB,MAAM,KAAK,OAAO,UAAU,EAAE,OAAO;CACjE;CAED,MAAM,YAAYC,WAAwD;AACzE,SAAO,YAAiB,MAAM,KAAK,OAAO,UAAU,EAAE,WAAW,OAAO;CACxE;CAED,MAAM,YAAYC,YAA6BC,YAA6C;AAC3F,SAAO,YAAiB,MAAM,KAAK,OAAO,UAAU,EAAE,YAAY,WAAW;CAC7E;AACD;IAKY,oBAAN,MAA+C;CACrD,YAA6BC,oBAAwC;EAcpE,KAd4B;CAA0C;CAEvE,kBAAyC;AACxC,SAAO,KAAK,mBAAmB,qBAAqB,OAAO,mBAAmB,6BAA6B,CAAC;CAC5G;CAED,YAAYH,WAAwD;AACnE,SAAO,KAAK,mBAAmB,iBAAiB,WAAW,OAAO,mBAAmB,6BAA6B,CAAC;CACnH;CAED,YAAYC,YAA6BC,YAA6C;AACrF,SAAO,KAAK,mBAAmB,iBAAiB,YAAY,WAAW;CACvE;AACD;;;;AC3EM,SAAS,gBAAgBE,SAAgC;CAC/D,MAAM,iBAAiB,kBAAkB,SAAS,EAAE;AACpD,QAAO;EACN,sBAAsB,eAAe;EACrC,iBAAiB,eAAe;EAChC,eAAe;GACd,iBAAiB,eAAe;GAChC,iBAAiB,eAAe;EAChC;CACD;AACD;AAEM,SAAS,gBAAgB,EAAE,sBAAsB,iBAAiB,eAA0B,EAAc;AAChH,QAAO,kBAAkB;EAAC;EAAsB;EAAiB,cAAc;EAAiB,cAAc;CAAgB,EAAC;AAC/H;;;;ICCY,WAAN,MAAe;CACrB,YAA6BC,aAA0B;EAwGvD,KAxG6B;CAA4B;CAEzD,MAAa,mBAAwC;AACpD,SAAO;GACN,aAAa,YAAY;GACzB,YAAY,oBAAoB;GAChC,cAAc,MAAM,KAAK,YAAY,iBAAiB;EACtD;CACD;CAED,MAAa,qBACZC,uBACAC,kBACAC,qBACAC,WACsB;EACtB,MAAM,eAAe,MAAM,KAAK,YAAY,uBAAuB,kBAAkB,qBAAqB,UAAU;AACpH,SAAO,gBAAgB,aAAa;CACpC;;;;CAKD,MAAM,YACLH,uBACAC,kBACAC,qBACAC,WACqB;EACrB,MAAM,kBAAkB,eAAe,sBAAsB,YAAY,iBAAiB,YAAY,oBAAoB,aAAa;EACvI,MAAM,qBAAqB,MAAM,KAAK,YAAY,YAAY,oBAAoB,eAAe;EACjG,MAAM,kBAAkB,mBAAmB;EAE3C,MAAM,MAAM,KAAK,YAChB,sBAAsB,WACtB,iBAAiB,WACjB,qBACA,iBACA,mBAAmB,cACnB,iBACA,sBAAsB,WACtB;EAED,MAAM,kBAAkB,WAAW,KAAK,UAAU;AAClD,SAAO;GACN,sBAAsB,sBAAsB;GAC5C,iBAAiB,iBAAiB;GAClC,eAAe;IACd;IACiB;GACjB;EACD;CACD;CAED,MAAa,mBAAmBC,kBAA8BC,eAAwD;EACrH,MAAM,UAAU,gBAAgB,iBAAiB;AACjD,SAAO;GAAE,sBAAsB,MAAM,KAAK,YAAY,SAAS,cAAc;GAAE,sBAAsB,QAAQ;EAAsB;CACnI;;;;CAKD,MAAM,YAAYC,SAAoBD,eAAgD;EACrF,MAAM,kBAAkB,QAAQ,cAAc;EAC9C,MAAM,kBAAkB,eAAe,QAAQ,sBAAsB,QAAQ,iBAAiB,cAAc,WAAW,WAAW;EAClI,MAAM,oBAAoB,MAAM,KAAK,YAAY,YAAY,cAAc,aAAa,YAAY,gBAAgB;EAEpH,MAAM,MAAM,KAAK,YAChB,QAAQ,sBACR,QAAQ,iBACR,uBAAuB,cAAc,EACrC,iBACA,mBACA,iBACA,sBAAsB,WACtB;AAED,SAAO,wBAAwB,KAAK,QAAQ,cAAc,gBAAgB;CAC1E;CAED,AAAQ,YACPE,yBACAC,oBACAN,qBACAO,iBACAC,mBACAC,iBACAC,uBACY;EACZ,MAAM,UAAU,OACf,yBACA,oBACA,oBAAoB,cACpB,sBAAsB,oBAAoB,eAAe,EACzD,iBACA,IAAI,WAAW,CAAC,OAAO,sBAAsB,AAAC,GAC9C;EAED,MAAM,mBAAmB,OAAO,gBAAgB,uBAAuB,gBAAgB,kBAAkB,kBAAkB;EAE3H,MAAM,WAAW,KAAK,SAAS,kBAAkB,uBAAuB,MAAM,EAAE,yBAAyB;AACzG,SAAO,gBAAgB,SAAS;CAChC;AACD;;;;ICpHY,kBAAN,MAAsB;CAC5B,YACkBC,UACAC,YACAC,cACAC,uBAChB;EAoLF,KAxLkB;EAwLjB,KAvLiB;EAuLhB,KAtLgB;EAsLf,KArLe;CACd;;;;;;;CAQJ,MAAM,gBAAgBC,SAAaC,kBAA0BC,iBAAiD;AAC7G,MAAI,mBAAmB,QAAQ,gBAAgB,UAAU,iBAExD,OAAM,IAAI,OACR,yCAAyC,gBAAgB,QAAQ,kCAAkC,iBAAiB,aAAa,QAAQ;EAG5I,MAAM,WAAW,mBAAoB,MAAM,KAAK,sBAAsB,QAAQ;AAE9E,MAAI,SAAS,YAAY,iBACxB,QAAO,SAAS;SACN,SAAS,UAAU,kBAAkB;AAI/C,SAAM,CAAC,MAAM,KAAK,uBAAuB,EAAE,gBAAgB,QAAQ;GAEnE,MAAM,oBAAoB,MAAM,KAAK,sBAAsB,QAAQ;AACnE,UAAO,KAAK,gBAAgB,SAAS,kBAAkB,kBAAkB;EACzE,OAAM;GAEN,MAAM,QAAQ,MAAM,KAAK,aAAa,KAAK,cAAc,QAAQ;GACjE,MAAM,EAAE,mBAAmB,GAAG,MAAM,KAAK,mBAAmB,OAAO,UAAU,iBAAiB;AAC9F,UAAO;EACP;CACD;CAED,MAAM,sBAAsBF,SAAoC;AAE/D,MAAI,SAAS,SAAS,KAAK,WAAW,gBAAgB,CAAC,CACtD,QAAO,KAAK,2BAA2B;AAExC,SAAO,KAAK,SAAS,mBAAmB,SAAS,MAAM,KAAK,iCAAiC,QAAQ,CAAC;CACtG;CAED,MAAM,oBAAoBC,kBAA2C;EAEpE,IAAI,sBAAsB,KAAK,2BAA2B;AAC1D,MAAI,oBAAoB,UAAU,kBAAkB;AACnD,SAAM,CAAC,MAAM,KAAK,uBAAuB,EAAE,gBAAgB,KAAK,WAAW,gBAAgB,CAAC;AAC5F,yBAAsB,KAAK,2BAA2B;EAEtD;AACD,SAAO,KAAK,gBAAgB,KAAK,WAAW,gBAAgB,EAAE,kBAAkB,oBAAoB;CACpG;CAED,4BAA0C;AACzC,SAAO,KAAK,WAAW,wBAAwB;CAC/C;CAED,MAAM,YAAYE,gBAAoBF,kBAAsD;EAC3F,IAAI,QAAQ,MAAM,KAAK,aAAa,KAAK,cAAc,eAAe;EACtE,IAAI,kBAAkB,MAAM,KAAK,sBAAsB,eAAe;AAEtE,MAAI,mBAAmB,gBAAgB,SAAS;AAC/C,YAAS,MAAM,CAAC,MAAM,KAAK,uBAAuB,EAAE,gBAAgB,eAAe,EAAE;AACrF,qBAAkB,MAAM,KAAK,sBAAsB,eAAe;EAClE;AACD,SAAO,MAAM,KAAK,gBAAgB,OAAO,kBAAkB,gBAAgB;CAC3E;CAED,MAAM,mBAAmBD,SAAoD;EAC5E,IAAI,QAAQ,MAAM,KAAK,aAAa,KAAK,cAAc,QAAQ;EAE/D,IAAI,kBAAkB,MAAM,KAAK,sBAAsB,QAAQ;AAC/D,MAAI,OAAO,MAAM,gBAAgB,KAAK,gBAAgB,SAAS;AAI9D,YAAS,MAAM,CAAC,MAAM,KAAK,uBAAuB,EAAE,gBAAgB,QAAQ,EAAE;AAC9E,qBAAkB,MAAM,KAAK,sBAAsB,QAAQ;AAC3D,OAAI,OAAO,MAAM,gBAAgB,KAAK,gBAAgB,QAErD,OAAM,IAAI,OAAO,kEAAkE,QAAQ;EAE5F;AACD,SAAO;GAAE,QAAQ,KAAK,0BAA0B,MAAM,aAAa,SAAS,gBAAgB,OAAO;GAAE,SAAS,OAAO,MAAM,gBAAgB;EAAE;CAC7I;CAED,MAAc,gBAAgBI,OAAcH,kBAA0BI,iBAA+B;EACpG,MAAM,iBAAiB,MAAM;EAC7B,IAAIC;EACJ,IAAIC;AACJ,MAAI,mBAAmB,gBAAgB,QACtC,OAAM,IAAI,OAAO,iEAAiE,eAAe;SACvF,qBAAqB,gBAAgB,SAAS;AACxD,iBAAc,gBAAgB;AAC9B,OAAI,OAAO,MAAM,gBAAgB,KAAK,gBAAgB,QACrD,WAAU,MAAM;KACV;IACN,MAAM,iBAAiB,cAAc,MAAM,gBAAgB,CAAC;IAE5D,MAAM,iBAAiB,MAAM,KAAK,aAAa,KAAK,iBAAiB,CAAC,gBAAgB,iBAAiB,OAAO,gBAAgB,QAAQ,CAAC,AAAC,EAAC;AACzI,cAAU,eAAe;GACzB;EACD,OAAM;GAEN,MAAM,EAAE,mBAAmB,kBAAkB,GAAG,MAAM,KAAK,mBAAmB,OAAO,iBAAiB,iBAAiB;AACvH,aAAU,iBAAiB;AAC3B,iBAAc;EACd;AACD,SAAO,KAAK,0BAA0B,SAAS,gBAAgB,YAAY;CAC3E;;;;;;CAOD,MAAc,iCAAiCP,SAAa;AAC3D,MAAI,SAAS,SAAS,KAAK,WAAW,gBAAgB,CAAC,CACtD,OAAM,IAAI,iBAAiB;EAE5B,MAAM,kBAAkB,KAAK,WAAW,cAAc,QAAQ;EAC9D,MAAM,uBAAuB,MAAM,KAAK,oBAAoB,OAAO,gBAAgB,cAAc,CAAC;AAClG,SAAO;GACN,SAAS,OAAO,gBAAgB,gBAAgB;GAChD,QAAQ,WAAW,sBAAsB,gBAAgB,WAAW;EACpE;CACD;CAED,MAAc,mBACbI,OACAC,iBACAG,kBACqE;EACrE,MAAM,iBAAiB,cAAc,MAAM,gBAAgB,CAAC;EAE5D,MAAM,UAAU,iBAAiB,OAAO,gBAAgB,QAAQ,CAAC;EACjE,MAAM,8BAA8B,gBAAgB,UAAU;EAE9D,MAAMC,aAAyB,MAAM,KAAK,aAAa,UAAU,iBAAiB,gBAAgB,SAAS,6BAA6B,KAAK;EAE7I,IAAI,cAAc,gBAAgB;EAClC,IAAI,eAAe,gBAAgB;EACnC,IAAIC,uBAAwC;AAE5C,OAAK,MAAM,aAAa,YAAY;GACnC,MAAM,UAAU,KAAK,sBAAsB,aAAa,UAAU,CAAC;AACnE,OAAI,UAAU,IAAI,YACjB;SACU,UAAU,MAAM,aAAa;AACvC,mBAAe,WAAW,cAAc,UAAU,aAAa;AAC/D,kBAAc;AACd,2BAAuB;AACvB,QAAI,eAAe,iBAClB;GAED,MACA,OAAM,IAAI,OAAO,qBAAqB,QAAQ,aAAa,YAAY;EAExE;AAED,MAAI,gBAAgB,qBAAqB,qBACxC,OAAM,IAAI,OAAO,yCAAyC,YAAY,MAAM,WAAW,OAAO,2BAA2B,eAAe;AAGzI,SAAO;GAAE,mBAAmB;GAAc,kBAAkB;EAAsB;CAClF;CAED,AAAQ,sBAAsBC,IAAgB;AAC7C,SAAO,OAAO,iBAAiB,GAAG,CAAC;CACnC;CAED,AAAQ,0BAA0BL,SAAyBN,SAAaY,UAAkB;AACzF,MAAI,WAAW,KACd,OAAM,IAAI,eAAe,uBAAuB,QAAQ;AAGzD,SAAO,eAAe,UAAU,QAA6B;CAC7D;AACD;;;;AC5GD,oBAAoB;IA2CP,oBAAN,MAAwB;;;;CAI9B;CACA,AAAiB;CACjB,AAAQ;CAER,YACkBC,cACAC,iBACAC,UACAC,iBACAC,eACAC,mBACAC,YACAC,cACAC,aACAC,uBACAC,wBAChB;EAozBF,KA/zBkB;EA+zBjB,KA9zBiB;EA8zBhB,KA7zBgB;EA6zBf,KA5zBe;EA4zBd,KA3zBc;EA2zBb,KA1zBa;EA0zBZ,KAzzBY;EAyzBX,KAxzBW;EAwzBV,KAvzBU;EAuzBT,KAtzBS;EAszBR,KArzBQ;AAEjB,OAAK,sBAAsB;GAC1B,OAAO;GACP,6BAA6B;GAC7B,iCAAiC,CAAE;GACnC,4BAA4B,CAAE;EAC9B;AACD,OAAK,kCAAkC,OAAa;AACpD,OAAK,2BAA2B,CAAE;CAClC;;;;;;;CAQD,MAAa,WAAWC,OAAkBC,eAAwB;EACjE,MAAM,SAAS,MAAM,KAAK,gBAAgB,IAAI,6BAA6B,KAAK;AAChF,MAAI,OAAO,wCAAwC,cAElD,MAAK,oBAAoB,QAAQ;AAElC,OAAK,2BAA2B,OAAO;AACvC,OAAK,gCAAgC,SAAS;CAC9C;;;;;CAMD,MAAM,qCAAqCC,MAA2B;AACrE,MAAI;AACH,OAAI;AACH,UAAM,KAAK,wBAAwB,KAAK;AACxC,UAAM,KAAK,0BAA0B,KAAK;GAC1C,UAAS;AAET,UAAM,KAAK,uBAAuB,KAAK,yBAAyB;GAChE;EACD,SAAQ,GAAG;AACX,OAAI,aAAa,YAEhB,SAAQ,IAAI,0DAA0D,EAAE;IAExE,OAAM;EAEP;CACD;;;;;;;;CASD,MAAM,wBAAwBA,MAAY;EACzC,MAAM,gBAAgB,MAAM,KAAK,aAAa,KAAK,sBAAsB,KAAK,UAAU,MAAM;AAC9F,MAAI,cAAc,gBAAgB,MAAM;GACvC,MAAM,sBAAsB,MAAM,KAAK,aAAa,QAAQ,oBAAoB,cAAc,aAAa,KAAK;GAChH,MAAM,qBAAqB,QAAQ,qBAAqB,CAAC,gBAAgB,YAAY,qBAAqB;GAC1G,IAAIC,mCAAuD;IAC1D,mBAAmB,IAAI,qBAAqB,uCAAuC;IACnF,mBAAmB,IAAI,qBAAqB,yCAAyC;IACrF,mBAAmB,IAAI,qBAAqB,0CAA0C;IACtF,mBAAmB,IAAI,qBAAqB,KAAK;GACjD,EACC,MAAM,CACN,OAAO,UAAU;GACnB,IAAI,gCAAgC,mBAAmB,IAAI,qBAAqB,SAAS,IAAI,CAAE;GAC/F,MAAM,8BAA8B,iCAAiC;AACrE,QAAK,sBAAsB;IAC1B,OAAO,KAAK,oBAAoB;IAChC,6BAA6B,8BAA8B,8BAA8B;IACzF,iCAAiC,8BAA8B,OAAO,mBAAmB,IAAI,qBAAqB,KAAK,IAAI,CAAE,EAAC;IAC9H,4BAA4B,mBAAmB,IAAI,qBAAqB,SAAS,IAAI,CAAE;GACvF;EACD;CACD;;;;;CAMD,MAAM,0BAA0BD,MAAY;AAC3C,QAAM,KAAK,gCAAgC;AAE3C,MAAI;AACH,OAAI,KAAK,oBAAoB,+BAA+B,KAAK,oBAAoB,OAAO;IAC3F,MAAM,uBAAuB,gBAAgB,sBAAsB,KAAK,oBAAoB,4BAA4B,qBAAqB;AAC7I,YAAQ,sBAAR;AACC,UAAK,qBAAqB;AACzB,cAAQ,IAAI,wEAAwE;AACpF;AACD,UAAK,qBAAqB;AAC1B,UAAK,qBAAqB;AACzB,YAAM,KAAK,qBAAqB,MAAM,KAAK,oBAAoB,OAAO,KAAK,oBAAoB,4BAA4B;AAC3H;AACD,UAAK,qBAAqB;AACzB,YAAM,KAAK,mBAAmB,MAAM,KAAK,oBAAoB,OAAO,KAAK,oBAAoB,4BAA4B;AACzH;IACD;AACD,SAAK,oBAAoB,8BAA8B;GACvD;EACD,UAAS;AACT,QAAK,oBAAoB,QAAQ;EACjC;EAGD,MAAM,cAAc,6BAA6B,EAAE,iBAAiB,CAAE,EAAE,EAAC;AACzE,OAAK,QAAQ,KAAK,oBAAoB,gCAAgC,EAAE;GACvE,MAAM,uBAAuB,MAAM,KAAK,8BAA8B,KAAK;AAC3E,OAAI,wBAAwB,KAC3B,aAAY,kBAAkB;AAE/B,QAAK,oBAAoB,kCAAkC,CAAE;EAC7D;EAED,IAAIE,iBAA4C,CAAE;AAClD,OAAK,QAAQ,KAAK,oBAAoB,2BAA2B,EAAE;GAClE,MAAM,EAAE,sBAAsB,mBAAmB,GAAG,MAAM,KAAK,wBAAwB,KAAK;AAC5F,oBAAiB;AACjB,OAAI,wBAAwB,KAC3B,aAAY,kBAAkB,YAAY,gBAAgB,OAAO,qBAAqB;AAEvF,QAAK,oBAAoB,6BAA6B,CAAE;EACxD;AACD,MAAI,YAAY,gBAAgB,UAAU,EACzC;AAED,QAAM,KAAK,gBAAgB,KAAK,yBAAyB,YAAY;AAErE,OAAK,QAAQ,eAAe,EAAE;GAC7B,MAAM,cAAc,MAAM,KAAK,aAAa;AAC5C,SAAM,KAAW,gBAAgB,CAAC,mBAAmB,YAAY,2BAA2B,eAAe,CAAC;EAC5G;CACD;;;;CAKD,MAAM,qBAAqBF,MAAYG,eAA0BC,aAA0B;AAC1F,MAAI,sBAAsB,cAAc,EAAE;AACzC,WAAQ,IAAI,oEAAoE;AAChF;EACA;EACD,MAAM,sBAAsB,KAAK,gBAAgB,2BAA2B;EAC5E,MAAM,uBAAuB,gBAAgB,wBAAwB,MAAM,UAAU,MAAM,CAAC;EAC5F,MAAM,uBAAuB,MAAM,KAAK,gBAAgB,sBAAsB,qBAAqB,MAAM;EACzG,MAAM,uBAAuB,MAAM,KAAK,gCAAgC,aAAa,MAAM,qBAAqB,sBAAsB,cAAc;AACpJ,SAAO,KAAK,gBAAgB,KAAK,8BAA8B,qBAAqB;CACpF;CAGD,MAAc,wBAAwBJ,MAGnC;EAEF,MAAM,sBAAsB,KAAK,gBAAgB,2BAA2B;AAC5E,MAAI,sBAAsB,oBAAoB,OAAO,EAAE;AAEtD,WAAQ,IAAI,kEAAkE;AAC9E,UAAO;IAAE,sBAAsB,CAAE;IAAE,mBAAmB,CAAE;GAAE;EAC1D;EAED,MAAM,kBAAkB,IAAI;EAC5B,IAAIK,oBAA+C,CAAE;AACrD,OAAK,MAAM,eAAe,KAAK,oBAAoB,4BAA4B;GAC9E,MAAM,EAAE,sBAAsB,uBAAuB,GAAG,MAAM,KAAK,+BAA+B,aAAa,qBAAqB,KAAK;AACzI,mBAAgB,KAAK,qBAAqB;AAC1C,uBAAoB,kBAAkB,OAAO,sBAAsB;EACnE;AAED,SAAO;GAAE,sBAAsB;GAAiB;EAAmB;CACnE;CAGD,MAAc,8BAA8BL,MAAY;EAGvD,MAAM,uBAAuB,KAAK,YAAY,KAAK,CAAC,MAAM,EAAE,cAAc,qBAAqB,uCAAuC;AACtI,MAAI,wBAAwB,MAAM;AACjC,WAAQ,IAAI,uCAAuC;AACnD;EACA;EAGD,MAAM,sBAAsB,KAAK,gBAAgB,2BAA2B;EAC5E,MAAM,uBAAuB,MAAM,KAAK,gBAAgB,sBAAsB,qBAAqB,MAAM;AACzG,MAAI,sBAAsB,oBAAoB,QAAQ,qBAAqB,OAAO,EAAE;AAEnF,WAAQ,IAAI,kEAAkE;AAC9E;EACA;EAED,MAAM,kBAAkB,IAAI;AAC5B,OAAK,MAAM,eAAe,KAAK,oBAAoB,iCAAiC;GACnF,MAAM,uBAAuB,MAAM,KAAK,yCAAyC,aAAa,qBAAqB,sBAAsB,KAAK;AAC9I,mBAAgB,KAAK,qBAAqB;EAC1C;AACD,SAAO;CACP;CAED,MAAc,gCACbI,aACAJ,MACAM,qBACAC,sBACAJ,eACuC;EACvC,MAAM,eAAe,KAAK,iBAAiB,YAAY;EACvD,MAAM,sBAAsB,KAAK;EACjC,MAAM,cAAc,oBAAoB;AACxC,UAAQ,KAAK,2CAA2C,aAAa,0BAA0B,YAAY,qBAAqB,EAAE;EAElI,MAAM,aAAa,MAAM,KAAK,aAAa,KAAK,cAAc,aAAa;EAC3E,MAAM,YAAY,MAAM,KAAK,aAAa,KAAK,cAAc,YAAY;EAEzE,MAAM,oBAAoB,MAAM,KAAK,kBAAkB,WAAW;EAClE,MAAM,eAAe,cAAc,kBAAkB,iBAAiB;EACtE,MAAM,YAAY,cAAc,aAAa,UAAU;EACvD,MAAM,cAAc,cAAc,aAAa,YAAY;EAC3D,MAAM,sCAAsC,MAAM,KAAK,2BACtD,WACA,aACA,kBAAkB,YAAY,SAC9B,cACA,cAAc,KAAK,SAAS,EAC5B,YACA;EAED,MAAM,mBAAmB,MAAM,KAAK,kBAAkB,UAAU;EAChE,MAAM,qBAAqB,MAAM,KAAK,iBAAiB,YAAY,sBAAsB,mBAAmB,kBAAkB,YAAY;EAC1I,MAAM,oBAAoB,MAAM,KAAK,oBAAoB,WAAW,qBAAqB,kBAAkB,eAAe,mBAAmB,KAAK;EAClJ,MAAM,2BAA2B,KAAK,cAAc,2BAA2B,iBAAiB,aAAa,kBAAkB,YAAY,OAAO;EAElJ,MAAM,oBAAoB,2BAA2B;GACpD,uBAAuB,cAAc,mBAAmB,4BAA4B,CAAC;GACrF,sBAAsB,OAAO,cAAc,mBAAmB,4BAA4B,CAAC,qBAAqB;GAChH,0BAA0B,mBAAmB,8BAA8B;GAC3E,iBAAiB,OAAO,kBAAkB,YAAY,QAAQ;GAC9D,OAAO,WAAW;GAClB,SAAS,YAAY,mBAAmB,QAAQ;GAChD,2BAA2B,CAAE;GAC7B,2BAA2B,CAC1B,gCAAgC;IAC/B,QAAQ,KAAK;IACb,iBAAiB,yBAAyB;IAC1C,gBAAgB,OAAO,yBAAyB,qBAAqB;GACrE,EAAC,AACF;EACD,EAAC;EAEF,MAAM,mBAAmB,+BAA+B;GACvD,iBAAiB,kBAAkB;GACnC,gCAAgC,kBAAkB;GAClD,cAAc,kBAAkB;GAChC,OAAO,UAAU;GACjB,8BAA8B,kBAAkB,kCAAkC;GAClF,qBAAqB,OAAO,iBAAiB,YAAY,QAAQ;GACjE,SAAS,kBAAkB;GAC3B,2BAA2B,kBAAkB,mCAAmC;GAChF,sBAAsB,OAAO,kBAAkB,mCAAmC,qBAAqB;GACvG,2BAA2B,kBAAkB,gCAAgC;GAC7E,8BAA8B;EAC9B,EAAC;AAEF,SAAO,kCAAkC;GAAE;GAAmB;GAAkB;EAAqC,EAAC;CACtH;CAED,MAAc,2BACbK,WACAC,aACAC,sBACAC,cACAC,YACAC,gBACkD;EAClD,MAAM,UAAU,KAAK,gBAAgB,sBAAsB,cAAc,WAAW,YAAY;EAChG,MAAMC,YAA+C,CAAE;EAEvD,MAAM,WAAW,MAAM,KAAK,aAAa,KAAK,iBAAiB,WAAW;EAC1E,MAAM,iBAAiB,MAAM,KAAK,aAAa,QAAQ,kBAAkB,SAAS,WAAW;AAE7F,OAAK,MAAM,iBAAiB,gBAAgB;AAC3C,OAAI,SAAS,cAAc,OAAO,eAAe,CAAE;GACnD,IAAI,MAAM,MAAM,KAAK,uBAAuB;GAC5C,MAAM,eAAe,MAAM,IAAI,kCAAkC,cAAc,MAAM;GACrF,MAAM,UAAU,KAAK,sBAAsB,cAAc,OAAO,aAAa;GAC7E,MAAM,mBAAmB,KAAK,cAAc,WAAW,SAAS,QAAQ;GACxE,MAAM,gBAAgB,sCAAsC;IAC3D,WAAW,cAAc;IACzB,6BAA6B;IAC7B,SAAS,OAAO,qBAAqB;GACrC,EAAC;AACF,aAAU,KAAK,cAAc;EAC7B;AAED,SAAO;CACP;CAED,AAAQ,sBAAsBC,aAAiBC,cAA4B;AAC1E,SAAO,KAAK,cAAc,kBAAkB;GAC3C,MAAM;GACN,KAAK,aAAa;GAClB,SAAS;EACT,EAAC;CACF;CAED,AAAQ,gBAAgBN,sBAA8BO,cAAsBT,WAAuBC,aAAyB;EAC3H,MAAM,cAAc,WAAW,KAAK,CAAC,CAAE,EAAC;EACxC,MAAM,kBAAkB,WAAW,KAAK,CAAC,oBAAqB,EAAC;EAC/D,MAAM,iBAAiB,WAAW,KAAK,CAAC,OAAO,wBAAwB,SAAS,AAAC,EAAC;EAClF,MAAM,aAAa,qBAAqB,aAAa;EAErD,MAAM,WAAW,OAAO,aAAa,WAAW,aAAa,iBAAiB,YAAY,eAAe;AACzG,SAAO,KAAK,cAAc,WAAW,SAAS;CAC9C;CAED,MAAc,+BACbL,aACAE,qBACAN,MAC4C;EAC5C,MAAM,gBAAgB,KAAK,iBAAiB,YAAY;AACxD,UAAQ,KAAK,2CAA2C,cAAc,0BAA0B,YAAY,qBAAqB,EAAE;EACnI,MAAM,cAAc,MAAM,KAAK,aAAa,KAAK,cAAc,cAAc;EAC7E,MAAM,kBAAkB,MAAM,KAAK,gBAAgB,sBAAsB,cAAc;EAEvF,MAAM,eAAe,MAAM,KAAK,kBAAkB,YAAY;EAC9D,MAAM,2BAA2B,KAAK,cAAc,2BAA2B,aAAa,aAAa,gBAAgB,OAAO;EAChI,MAAM,8BAA8B,KAAK,cAAc,2BAA2B,qBAAqB,aAAa,YAAY,OAAO;EACvI,MAAM,wBAAwB,MAAM,KAAK,yBAAyB,aAAa,aAAa,YAAY;EAExG,MAAM,4BAA4B,MAAM,KAAK,gCAAgC,aAAa,aAAa,YAAY;EAEnH,MAAM,uBAAuB,2BAA2B;GACvD,uBAAuB;GACvB,sBAAsB;GACtB,OAAO;GACP,iBAAiB,OAAO,aAAa,YAAY,QAAQ;GACzD,0BAA0B,yBAAyB;GACnD,SAAS,YAAY,aAAa,iBAAiB;GACnD;GACA,2BAA2B,CAC1B,gCAAgC;IAC/B,QAAQ,KAAK;IACb,iBAAiB,4BAA4B;IAC7C,gBAAgB,OAAO,oBAAoB,QAAQ;GACnD,EAAC,AACF;EACD,EAAC;AACF,SAAO;GACN;GACA;EACA;CACD;CAED,MAAc,yCACbI,aACAE,qBACAC,sBACAP,MACC;EACD,MAAM,gBAAgB,KAAK,iBAAiB,YAAY;AACxD,UAAQ,KAAK,2CAA2C,cAAc,0BAA0B,YAAY,qBAAqB,EAAE;EACnI,MAAM,cAAc,MAAM,KAAK,aAAa,KAAK,cAAc,cAAc;EAE7E,MAAM,UAAU,MAAM,KAAK,aAAa,QAAQ,oBAAoB,YAAY,QAAQ;EACxF,MAAM,YAAY,QAAQ,KAAK,CAAC,WAAW,OAAO,QAAQ,KAAK,IAAI;EACnE,MAAM,eAAe,QAAQ,OAAO,CAAC,WAAW,OAAO,QAAQ,KAAK,IAAI;EACxE,IAAI,kBAAkB,MAAM,KAAK,mBAAmB,eAAe,YAAY;EAC/E,MAAM,eAAe,MAAM,KAAK,kBAAkB,YAAY;EAC9D,MAAM,qBAAqB,MAAM,KAAK,iBAAiB,aAAa,iBAAiB,cAAc,qBAAqB;EAExH,MAAM,4BAA4B,IAAI;AAGtC,MAAI,WAAW;GACd,MAAM,8BAA8B,KAAK,cAAc,2BAA2B,qBAAqB,aAAa,YAAY,OAAO;AACvI,6BAA0B,KACzB,gCAAgC;IAC/B,QAAQ,KAAK;IACb,iBAAiB,4BAA4B;IAC7C,gBAAgB,OAAO,oBAAoB,QAAQ;GACnD,EAAC,CACF;EACD;AACD,OAAK,MAAM,UAAU,cAAc;GAClC,MAAMkB,qBAA4C,MAAM,KAAK,6BAA6B,OAAO,MAAM,aAAa,YAAY;GAChI,IAAI,wBAAwB,gCAAgC;IAC3D,QAAQ,OAAO;IACf,iBAAiB,mBAAmB;IACpC,gBAAgB,OAAO,mBAAmB,qBAAqB;GAC/D,EAAC;AACF,6BAA0B,KAAK,sBAAsB;EACrD;AAED,SAAO,2BAA2B;GACjC,uBAAuB,mBAAmB,8BAA8B,mBAAmB,4BAA4B,MAAM;GAC7H,sBAAsB,mBAAmB,8BACtC,OAAO,mBAAmB,4BAA4B,qBAAqB,GAC3E;GACH,OAAO;GACP,iBAAiB,OAAO,aAAa,YAAY,QAAQ;GACzD,0BAA0B,mBAAmB,8BAA8B;GAC3E,SAAS,YAAY,mBAAmB,QAAQ;GAChD,2BAA2B,CAAE;GACF;EAC3B,EAAC;CACF;CAED,MAAc,mBAAmBC,eAAuBC,aAA2C;AAClG,MAAI;AACH,UAAO,MAAM,KAAK,gBAAgB,sBAAsB,cAAc;EACtE,SAAQ,GAAG;GAEX,MAAM,wBAAwB,MAAM,KAAK,uBAAuB;GAChE,MAAM,aAAa,MAAM,sBAAsB,2BAA2B,eAAe,OAAO,YAAY,gBAAgB,CAAC;AAC7H,UAAO;IAAE,QAAQ;IAAY,SAAS,OAAO,YAAY,gBAAgB;GAAE;EAC3E;CACD;CAED,MAAc,oBACbC,WACAf,qBACAgB,kBACAnB,eACAoB,mBACAvB,MACkC;EAClC,MAAM,EAAE,6BAA6B,mCAAmC,cAAc,GAAG,KAAK,2BAC7F,eACA,kBACA,WACA,oBACA;EAED,MAAM,oBAAoB,MAAM,KAAK,iBAAiB,WAAW,qBAAqB,kBAAkB,kBAAkB,YAAY;EACtI,MAAM,kBAAkB,MAAM,KAAK,6BAA6B,MAAM,eAAe,iBAAiB;AAEtG,SAAO;GACN,mCAAmC,kBAAkB;GACrD,oCAAoC,cAAc,kBAAkB,4BAA4B;GAChG,SAAS,cAAc,YAAY,kBAAkB,QAAQ,CAAC;GAC9D,iCAAiC;GACjC;GACA;GACA;EACA;CACD;CAED,MAAc,6BAA6BA,MAAYwB,eAAuBF,kBAAuE;EACpJ,IAAIG,kBAA0C;AAC9C,MAAI,KAAK,MAAM,eAAe,MAAM;GACnC,MAAM,oBAAoB,MAAM,KAAK,mBAAmB;GACxD,MAAM,cAAc,MAAM,kBAAkB,kBAAkB,cAAc;GAC5E,MAAM,cAAc,kBAAkB,oBAAoB,aAAa,iBAAiB,YAAY;AACpG,qBAAkB,sBAAsB;IACvC,sBAAsB,YAAY;IAClC,qBAAqB,YAAY;IACjC,gBAAgB,OAAO,YAAY,eAAe;IAClD,6BAA6B,YAAY;GACzC,EAAC;EACF;AACD,SAAO;CACP;CAED,AAAQ,2BAA2BD,eAAuBF,kBAAsCD,WAAkBK,iBAA+B;EAChJ,MAAM,yBAAyB;GAC9B,QAAQ;GACR,SAAS;EACT;EACD,MAAM,8BAA8B,KAAK,cAAc,2BAA2B,wBAAwB,iBAAiB,YAAY,OAAO;EAC9I,MAAM,8BAA8B,KAAK,WAAW,kCAAkC,UAAU,KAAK,cAAc;EACnH,MAAM,oCAAoC,KAAK,cAAc,WAAW,6BAA6B,iBAAiB,YAAY,OAAO;EACzI,MAAM,eAAe,mBAAmB,cAAc;EACtD,MAAM,gCAAgC,KAAK,cAAc,2BAA2B,iBAAiB,aAAa,gBAAgB,OAAO;AACzI,SAAO;GAAE;GAA6B;GAAmC;GAAc;EAA+B;CACtH;CAED,MAAc,yBAAyBN,aAAoBO,mBAAiC;EAC3F,MAAMC,wBAAwD,CAAE;EAChE,MAAM,kBAAkB,MAAM,KAAK,aAAa,KAAK,kBAAkB,YAAY,UAAU;EAC7F,MAAM,qBAAqB,MAAM,KAAK,aAAa,QAAQ,4BAA4B,YAAY,YAAY;EAC/G,MAAM,8BAA8B,QAAQ,oBAAoB,CAAC,eAAe,WAAW,WAAW;EACtG,MAAM,cAAc,MAAM,KAAK,aAAa;AAC5C,OAAK,MAAM,CAAC,YAAY,gBAAgB,IAAI,6BAA6B;GACxE,MAAM,uBAAuB,gBAAgB,IAAI,CAAC,WAAW,OAAO,mBAAmB;GACvF,MAAM,wBAAwB,OAAOC,kBAA4B;IAChE,MAAM,qBAAqB,MAAM,YAAY,uBAAuB,mBAAmB,iBAAiB,eAAe,SAAS,WAAW,CAAC;AAC5I,0BAAsB,KAAK,mBAAmB;GAC9C;AACD,OAAI;AACH,UAAM,sBAAsB,qBAAqB;GACjD,SAAQ,GAAG;AAEX,QAAI,aAAa,yBAAyB;KACzC,MAAM,qBAAqB,EAAE,QAAQ,MAAM,KAAK;KAChD,MAAM,0BAA0B,qBAAqB,OAAO,CAAC,aAAa,mBAAmB,SAAS,QAAQ,CAAC;AAC/G,SAAI,wBAAwB,OAC3B,OAAM,sBAAsB,wBAAwB;IAErD,MACA,OAAM;GAEP;EACD;AACD,SAAO;CACP;CAED,MAAc,gCAAgCC,OAAcC,aAA+D;EAC1H,MAAM,UAAU,MAAM,KAAK,aAAa,QAAQ,oBAAoB,MAAM,QAAQ;EAClF,MAAM,eAAe,QAAQ,OAAO,CAAC,WAAW,OAAO,QAAQ,KAAK,WAAW,SAAS,EAAE,IAAI;AAC9F,SAAO,MAAM,KAAK,qCAAqC,MAAM,KAAK,cAAc,YAAY;CAC5F;CAED,MAAc,qCAAqCC,SAAaC,cAA6BF,aAA0D;EACtJ,MAAM,kBAAkB,IAAI;EAE5B,MAAM,iBAAiB,QAAQ,cAAc,CAAC,WAAW,WAAW,OAAO,cAAc,CAAC;EAC1F,MAAM,kBAAkB,IAAI;AAC5B,OAAK,MAAM,CAAC,QAAQ,QAAQ,IAAI,gBAAgB;GAC/C,MAAM,iBAAiB,MAAM,KAAK,aAAa,aAC9C,kBACA,QACA,QAAQ,IAAI,CAAC,WAAW,cAAc,OAAO,cAAc,CAAC,CAC5D;AACD,QAAK,MAAM,UAAU,SAAS;IAC7B,MAAM,yBAAyB,eAAe,KAAK,CAAC,QAAQ,SAAS,IAAI,KAAK,OAAO,cAAc,CAAC;IACpG,MAAM,oBAAoB,cAAc,wBAAwB,YAAY;IAC5E,MAAM,YAAY,KAAK,cAAc,iBAAiB;IACtD,MAAM,aAAa,KAAK,cAAc,iBAAiB;IAGvD,MAAMG,qBAAoC,CAAE;IAC5C,MAAM,mBAAmB,MAAM,KAAK,aAAa,qCAChD,KAAK,WAAW,gBAAgB,EAChC,WACA,mBACA,mBACA;AACD,QAAI,oBAAoB,QAAQ,cAAc,iBAAiB,OAAO,gCAAgC,EAAE;KACvG,MAAM,UAAU;KAChB,MAAM,gBAAgB,oBAAoB;MACzC,qBAAqB,QAAQ;MAC7B,yBAAyB,wBAAwB;MACjD,cAAc,QAAQ;MACtB,qBAAqB,QAAQ;MAC7B,kBAAkB,QAAQ;MAC1B,iBAAiB,QAAQ;KACzB,EAAC;KACF,MAAM,qBAAqB,yBAAyB;MACnD,uBAAuB,KAAK,cAAc,aAAa,YAAY,qBAAqB,YAAY,OAAO,CAAC;MAC5G,8BAA8B,OAAO,YAAY,QAAQ;MACzD,wBAAwB,KAAK,cAAc,WAAW,WAAW,WAAW;MAC5E,qBAAqB;KACrB,EAAC;AACF,qBAAgB,KAAK,mBAAmB;IACxC,MACA,iBAAgB,KAAK,OAAO;GAE7B;EACD;EACD,MAAM,wBAAwB,MAAM,KAAK,uBAAuB;AAChE,MAAI,gBAAgB,WAAW,GAAG;AACjC,QAAK,MAAM,UAAU,gBACpB,OAAM,sBAAsB,oBAAoB,OAAO,MAAM,QAAQ;GAEtE,MAAM,iBAAiB,aAAa,OAAO,CAAC,YAAY,gBAAgB,SAAS,OAAO,CAAC;AAEzF,UAAO,KAAK,qCAAqC,SAAS,gBAAgB,YAAY;EACtF,MACA,QAAO;CAER;;;;CAKD,AAAQ,iBAAiB9B,aAA0B;AAGlD,SAAO,cAAc,YAAY,IAAI;CACrC;CAED,MAAc,iBACb0B,OACAJ,iBACAS,SACAC,gBAC8B;EAC9B,MAAM,gCAAgC,KAAK,cAAc,2BAA2B,QAAQ,aAAa,gBAAgB,OAAO;EAChI,MAAM,8BAA8B,CAAC,MAAM,KAAK,uBAAuB,EAAE,gBAAgB,MAAM,GAC5F,KAAK,cAAc,2BAA2B,gBAAgB,QAAQ,YAAY,OAAO,GACzF;AAEH,SAAO;GACyB;GAC/B,SAAS,QAAQ;GACY;EAC7B;CACD;CAMD,MAAc,6BAA6BC,QAAYN,aAA2D;EACjH,MAAM,wBAAwB,MAAM,KAAK,uBAAuB;EAChE,MAAM,OAAO,MAAM,KAAK,aAAa,KAAK,aAAa,OAAO;EAC9D,MAAM,eAAe,MAAM,sBAAsB,2BAA2B,KAAK,UAAU,OAAO,OAAO,KAAK,UAAU,gBAAgB,CAAC;EACzI,MAAM,sBAAsB,KAAK,cAAc,WAAW,cAAc,YAAY,OAAO;AAC3F,SAAO;GAAE,KAAK;GAAqB,sBAAsB,OAAO,KAAK,UAAU,gBAAgB;EAAE;CACjG;CAED,MAAc,kBAAkBD,OAA2C;EAC1E,MAAM,mBAAmB,KAAK,cAAc,iBAAiB;EAC7D,MAAM,UAAU,MAAM,KAAK,sBAAsB,OAAO,iBAAiB;AACzE,SAAO;GACN,aAAa;IACZ,QAAQ;IACR,SAAS,OAAO,MAAM,gBAAgB,GAAG;GACzC;GACD,kBAAkB;EAClB;CACD;;;;CAKD,MAAc,sBAAsBQ,eAAsBC,sBAAsE;AAC/H,MAAI,cAAc,aAAa;GAC9B,MAAM,aAAa,MAAM,KAAK,SAAS,kBAAkB;AACzD,UAAO;IACN,WAAW;IACX,kBAAkB;IAClB,WAAW,WAAW,WAAW;IACjC,kBAAkB,KAAK,cAAc,cAAc,sBAAsB,WAAW,WAAW,WAAW;IAC1G,aAAa,KAAK,cAAc,sBAAsB,WAAW,aAAa,UAAU;IACxF,oBAAoB,KAAK,cAAc,gBAAgB,sBAAsB,WAAW,aAAa,WAAW;GAChH;EACD,MACA,QAAO;CAER;;;;;CAMD,uBAAuBC,qBAAyC;AAC/D,OAAK,sBAAsB;AAC3B,OAAK,gCAAgC,SAAS;CAC9C;CAED,MAAM,QAAQ;AACb,QAAM,KAAK,gCAAgC;AAC3C,OAAK,sBAAsB;GAC1B,OAAO;GACP,6BAA6B;GAC7B,iCAAiC,CAAE;GACnC,4BAA4B,CAAE;EAC9B;CACD;;;;;CAMD,MAAM,uBAAuBC,mBAA6C;AACzE,MAAI,kBAAkB,SAAS,EAAG;AAClC,UAAQ,IAAI,0CAA0C,kBAAkB;EACxE,MAAM,0BAA0B,MAAM,KAAK,aAAa,aACvD,uBACA,WAAW,kBAAkB,GAAG,EAChC,kBAAkB,IAAI,CAAC,OAAO,cAAc,GAAG,CAAC,CAChD;EACD,MAAM,kBAAkB,wBAAwB,IAAI,CAAC,WAAW,KAAK,6BAA6B,OAAO,CAAC;EAC1G,MAAM,kBAAkB,sBAAsB,EAC7C,gBACA,EAAC;AACF,SAAO,KAAK,gBAAgB,IAAI,mBAAmB,gBAAgB;CACnE;CAED,AAAQ,6BAA6BC,gBAAwD;EAC5F,MAAM,eAAe,KAAK,gBAAgB,2BAA2B;EACrE,MAAM,iBAAiB,KAAK,cAAc,2BAA2B,cAAc,gBAAgB,eAAe,SAAS,CAAC;AAC5H,SAAO,6BAA6B;GACnC,OAAO,cAAc,eAAe,IAAI;GACxC,YAAY,eAAe;GAC3B,iBAAiB,eAAe;GAChC,eAAe,OAAO,aAAa,QAAQ;EAC3C,EAAC;CACF;;;;;;;;;;;CAYD,MAAc,mBAAmB1C,MAAY2C,OAAeC,sBAAmC;EAC9F,MAAM,sBAAsB,KAAK;EACjC,MAAM,cAAc,oBAAoB;EACxC,MAAM,sBAAsB,KAAK,gBAAgB,2BAA2B;AAC5E,UAAQ,KAAK,2CAA2C,YAAY,0BAA0B,qBAAqB,qBAAqB,EAAE;AAE1I,MAAI,qBAAqB,mCAAmC,KAC3D,OAAM,IAAI,MAAM;EAEjB,MAAM,EAAE,SAAS,sBAAsB,6BAA6B,GAAG,qBAAqB;EAE5F,MAAM,UAAU,KAAK,sBAAsB,aAAa,oBAAoB;EAC5E,MAAM,qBAAqB,KAAK,cAAc,WAAW,SAAS,6BAA6B,KAAK;EAEpG,MAAMvB,YAAmB,MAAM,KAAK,aAAa,KAAK,cAAc,YAAY;EAGhF,MAAM,eAAe,cAAc,UAAU,MAAM;EACnD,MAAM,sBAAsB,qBAAqB;GAChD,YAAY;GACZ,gBAAgB,wBAAwB;GACxC,SAAS;EACT,EAAC;EACF,MAAM,uBAAuB,MAAM,KAAK,gBAAgB,IAAI,kBAAkB,oBAAoB;EAClG,MAAM,EAAE,WAAW,aAAa,GAAG;AACnC,MAAI,aAAa,KAChB,OAAM,IAAI,MAAM;AAEjB,MAAI,eAAe,KAClB,OAAM,IAAI,MAAM;EAEjB,MAAM,yBAAyB,KAAK,gBAAgB,OAAO,qBAAqB,EAAE,cAAc,WAAW,YAAY;AAEvH,OAAK,YAAY,oBAAoB,uBAAuB,CAC3D,OAAM,IAAI,MAAM;EAEjB,MAAM,mBAAmB,MAAM,KAAK,kBAAkB,UAAU;EAEhE,MAAM,EAAE,6BAA6B,mCAAmC,cAAc,+BAA+B,GAAG,KAAK,2BAC5H,OACA,kBACA,WACA,oBACA;EACD,MAAM,kBAAkB,MAAM,KAAK,6BAA6B,MAAM,OAAO,iBAAiB;EAE9F,MAAM,+BAA+B,MAAM,KAAK,4BAA4B,kBAAkB,sBAAsB,aAAa;EAEjI,MAAM,mBAAmB,+BAA+B;GACvD,qBAAqB,OAAO,iBAAiB,YAAY,QAAQ;GACjE,8BAA8B,8BAA8B;GAC5D,2BAA2B,4BAA4B;GACvD,OAAO;GACP,gCAAgC;GAChC,SAAS,cAAc,YAAY,iBAAiB,iBAAiB,CAAC;GACtE;GACA,sBAAsB,6BAA6B;GACnD;GACA,2BAA2B;GACV;EACjB,EAAC;AAEF,QAAM,KAAK,gBAAgB,KAAK,6BAA6B,iCAAiC,EAAE,iBAAkB,EAAC,CAAC;CACpH;CAED,MAAc,4BACbC,kBACAuB,iBACAlC,cACyB;EACzB,MAAMmC,eAAsC;GAC3C,SAAS,OAAO,gBAAgB,cAAc;GAC9C,QAAQ;IACP,WAAW,gBAAgB;IAC3B,aAAa,gBAAgB;IAC7B,WAAW;GACX;EACD;EAGD,MAAMC,YAAwB,KAAK,cAAc,eAAe,iBAAiB,YAAY,QAAQ,cAAc,iBAAiB,iBAAiB,CAAC;EAEtJ,MAAM,eAAe,MAAM,KAAK,uBAAuB,uBAAuB,iBAAiB,YAAY,QAAQ,cAAc;GAChI,SAAS,iBAAiB,YAAY;GACtC,QAAQ,UAAU;EAClB,EAAC;AAEF,SAAO,oBAAoB;GAC1B,qBAAqB;GACrB,yBAAyB,wBAAwB;GACjD,cAAc,aAAa;GAC3B,iBAAiB,aAAa;GAC9B,kBAAkB,aAAa,oBAAoB,OAAO,aAAa,iBAAiB,UAAU,GAAG;GACrG,qBAAqB,aAAa,oBAAoB,UAAU;EAChE,EAAC;CACF;AACD;;;;AAKD,SAAS,cAAcC,KAAa;AACnC,QAAO,kBAAkB,IAAI,KAAK;AAClC;AAED,SAAS,sBAAsB,GAAG,MAAgB;AACjD,QAAO,KAAK,KAAK,CAAC,SAAS,cAAc,IAAI,CAAC;AAC9C;AAED,SAAS,YAAYC,SAAqD;AACzE,QAAO,WAAW,OAAO,cAAc,QAAQ,GAAG;AAClD;;;;ICx8BY,WAAN,MAAe;CACrB,AAAQ,mBAAmD,IAAI;CAG/D,AAAQ,sBAA2C;CAEnD,AAAQ,8BAAgD;CAExD,uBAAuBC,iBAA+B;AACrD,MAAI,KAAK,uBAAuB,QAAQ,KAAK,oBAAoB,UAAU,gBAAgB,SAAS;AACnG,WAAQ,IAAI,0CAA0C;AACtD;EACA;AACD,OAAK,sBAAsB;CAC3B;CAED,yBAA8C;AAC7C,SAAO,KAAK;CACZ;CAED,+BAA+BC,6BAAwC;AACtE,OAAK,8BAA8B;CACnC;CAED,iCAAmD;AAClD,SAAO,KAAK;CACZ;;;;;;CAOD,mBAAmBC,SAAaC,WAA+D;AAC9F,SAAO,WAAW,KAAK,kBAAkB,SAAS,YAAY;AAC7D,UAAO,WAAW;EAClB,EAAC;CACF;CAED,QAAQ;AACP,OAAK,mBAAmB,IAAI;AAC5B,OAAK,sBAAsB;AAC3B,OAAK,8BAA8B;CACnC;;;;;;CAOD,MAAM,wBAAwBC,MAAY;EACzC,MAAM,6BAA6B,UAAU,KAAK,wBAAwB,CAAC,CAAC;EAC5E,MAAM,8BAA8B,OAAO,KAAK,UAAU,gBAAgB;AAC1E,MAAI,8BAA8B,2BAEjC,SAAQ,KAAK,wDAAwD,2BAA2B,MAAM,4BAA4B,EAAE;EAGrI,MAAM,0BAA0B,IAAI;AACpC,OAAK,MAAM,cAAc,KAAK,aAAa;GAC1C,MAAM,iBAAiB,KAAK,iBAAiB,IAAI,WAAW,MAAM;AAClE,OAAI,kBAAkB,QAAQ,OAAO,WAAW,gBAAgB,MAAM,MAAM,gBAAgB,QAC3F,OAAM,WAAW,yBAAyB,WAAW,OAAO,MAAM,eAAe;EAElF;AACD,OAAK,mBAAmB;CACxB;AACD;;;;ICrEY,wBAAN,MAAoD;CAC1D,uBAAuBC,aAA2B;AACjD,SAAO,cAAc,cAAc,IAAI,QAAQ,YAAY,CAAC;CAC5D;AACD;;;;ACmFD,oBAAoB;MAkEPC,UAA6B,CAAE;AAErC,eAAe,YAAYC,QAAoBC,aAA0B;AAC/E,SAAQ,UAAU;AAClB,SAAQ,eAAe;AACvB,SAAQ,WAAW,IAAI;AACvB,SAAQ,gBAAgB,IAAI;AAC5B,SAAQ,OAAO,IAAI,WAAW,QAAQ,UAAU,QAAQ;AACxD,SAAQ,eAAe,IAAI;CAC3B,MAAM,eAAe,IAAI;CAEzB,MAAM,gBAAgB,OAAO,kBAAkB;CAE/C,MAAM,oBAAoB,IAAI,kBAAkB,cAAc,oBAAoB;AAClF,SAAQ,iBAAiB,IAAI;AAC7B,SAAQ,MAAM,MAAM,wBAAwB,OAAO;CAEnD,MAAM,eAAe,IAAI,uBAAuB,wBAAwB;AAExE,SAAQ,aAAa,IAAI,WAAW,mBAAmB;AACvD,SAAQ,kBAAkB,IAAI,gBAAgB,QAAQ,YAAY,QAAQ,MAAM,QAAQ,gBAAgB,MAAM,QAAQ;AACtH,SAAQ,gBAAgB,IAAI,cAAc,QAAQ,MAAM,QAAQ,iBAAiB,QAAQ,MAAM,QAAQ;AACvG,SAAQ,kBAAkB,IAAI,sBAAsB,QAAQ,iBAAiB,QAAQ,MAAM;CAC3F,MAAM,mBAAmB,IAAI,iBAAiB,QAAQ,MAAM,QAAQ,YAAY,MAAM,QAAQ,QAAQ,QAAQ,gBAAgB,QAAQ;AAEtI,SAAQ,SAAS;AACjB,SAAQ,UAAU,aAAa,YAAY;EAC1C,MAAM,EAAE,eAAe,GAAG,MAAM,OAAO;AACvC,SAAO,IAAI,cAAc,QAAQ;CACjC,EAAC;CAEF,IAAI;AACJ,KAAI,2BAA2B,KAAK,eAAe,EAAE;AACpD,UAAQ,kBAAkB,IAAI,8BAA8B,QAAQ;AACpE,2BAAyB,YAAY;AACpC,UAAO,IAAI,eACV,QAAQ,iBACR,IAAI,qCAAqC,SACzC,cACA,IAAI,uBAAuB,4BAA4B,aACvD,IAAI;EAEL;CACD,MACA,0BAAyB,YAAY;AAEtC,SAAQ,YAAY,YAAY;EAC/B,MAAM,EAAE,WAAW,GAAG,MAAM,OAAO;AACnC,SAAO,IAAI,UAAU,IAAI,eAAe;CACxC;CAED,MAAM,4BAA4B,IAAI,gCAAgC,OAAOC,UAAiB;AAC7F,QAAM,OAAO,UAAU,MAAM;CAC7B,GAAE;AAEH,SAAQ,eAAe;CAEvB,MAAM,UAAU,IAAI,cAAc,IAAI,yBAAyB,SAAS,IAAI,2BAA2B;CAGvG,IAAIC,QAAuC;AAC3C,MAAK,eAAe,CACnB,SAAQ,IAAI,uBAAuB,kBAAkB;AAGtD,SAAQ,QAAQ,SAAS;AAEzB,SAAQ,sBAAsB,IAAI,aAAa,QAAQ;CACvD,MAAM,yBAAyB,IAAI,aAAa;AAEhD,SAAQ,kBAAkB,aAAa,YAAY;EAClD,MAAM,EAAE,uBAAuB,GAAG,MAAM,OAAO;AAC/C,SAAO,IAAI,sBAAsB,QAAQ,MAAM,QAAQ,qBAAqB,cAAc,MAAM;CAChG,EAAC;;CAGF,MAAM,2BAA2B,YAAY;EAC5C,MAAM,EAAE,gBAAgB,GAAG,MAAM,OAAO;AACxC,SAAO,MAAM;AAEZ,OAAI,2BAA2B,CAC9B,QAAO,IAAI,eAAe,QAAQ,qBAAqB,QAAQ,qBAAqB;KAC9E;IAEN,MAAM,eAAe,IAAI;AACzB,WAAO,IAAI,eACV,IAAI,aAAa,IAAI,uBAAuB,kBAAkB,gBAC9D,IAAI,aAAa,mBACjB;GAED;EACD;CACD;AACD,SAAQ,iBAAiB,YAAY;EACpC,MAAM,UAAU,MAAM,0BAA0B;AAChD,SAAO,SAAS;CAChB;AAED,SAAQ,UAAU,aAAa,YAAY;EAC1C,MAAM,EAAE,SAAS,GAAG,MAAM,OAAO;EACjC,MAAM,EAAE,aAAa,GAAG,MAAM,OAAO;EACrC,MAAM,aAAa,MAAM,QAAQ,MAAM;EACvC,MAAM,oBAAoB,MAAM,0BAA0B;AAC1D,SAAO,IAAI,QAAQ,kBAAkB,cAAc,oBAAoB,aAAa,QAAQ,OAAiC,CAAC,MAAM,OAAO;GAC1I,MAAMC,iBAAe,IAAI;AACzB,UAAO,IAAI,YAAY,MAAM,IAAI,cAAc,oBAAoB,mBAAmB,QAAQ,qBAAqBA,gBAAc;EACjI;CACD,EAAC;AAEF,KAAI,UAAU,IAAI,cAAc,CAC/B,SAAQ,cAAc,IAAI,kBAAkB,IAAI,iCAAiC;IAEjF,SAAQ,cAAc,IAAI;AAG3B,SAAQ,WAAW,IAAI,SAAS,QAAQ;AAExC,SAAQ,YAAY,IAAI,gBAAgB,QAAQ,UAAU,QAAQ,MAAM,QAAQ,qBAAqB,QAAQ;AAE7G,SAAQ,mBAAmB,IAAI,uBAAuB,QAAQ,KAAK,QAAQ,UAAU,QAAQ,WAAW,QAAQ,eAAe,QAAQ;AAEvI,SAAQ,SAAS,IAAI,aACpB,QAAQ,MACR,QAAQ,qBACR,QAAQ,YACR,QAAQ,iBACR,QAAQ,gBACR,IAAI,+BAA+B,QAAQ,MAAM,QAAQ,kBACzD,OACA,QAAQ,WACR,QAAQ;AAGT,SAAQ,cAAc,aAAa,YAAY;EAC9C,MAAM,EAAE,mBAAmB,GAAG,MAAM,OAAO;AAC3C,SAAO,IAAI,kBAAkB,QAAQ,MAAM,QAAQ,qBAAqB,QAAQ,OAAO,QAAQ;CAC/F,EAAC;AACF,SAAQ,QAAQ,aAAa,YAAY;EACxC,MAAM,EAAE,aAAa,GAAG,MAAM,OAAO;AACrC,SAAO,IAAI,YAAY,QAAQ,MAAM,QAAQ,QAAQ,QAAQ,iBAAiB,QAAQ,qBAAqB,QAAQ;CACnH,EAAC;AACF,SAAQ,WAAW,aAAa,YAAY;EAC3C,MAAM,EAAE,eAAe,GAAG,MAAM,OAAO;AACvC,SAAO,IAAI,cAAc,QAAQ;CACjC,EAAC;AACF,SAAQ,kBAAkB,aAAa,YAAY;EAClD,MAAM,EAAE,uBAAuB,GAAG,MAAM,OAAO;AAC/C,SAAO,IAAI,sBACV,QAAQ,MACR,MAAM,QAAQ,UAAU,EACxB,QAAQ,qBACR,QAAQ,iBACR,QAAQ,UACR,QAAQ,WACR,MAAM,QAAQ,iBAAiB,EAC/B,QAAQ,kBACR,QAAQ;CAET,EAAC;AACF,SAAQ,cAAc,IAAI,kBACzB,QAAQ,qBACR,QAAQ,WACR,QAAQ,UACR,QAAQ,iBACR,QAAQ,eACR,QAAQ,aACR,QAAQ,MACR,QAAQ,QACR,QAAQ,OACR,QAAQ,iBACR,QAAQ;CAGT,MAAMC,gBAA+B;EACpC,mBAAmBC,aAA0BC,WAAsBC,aAAyC;AAC3G,QAAK,QAAQ,IAAI,gBAAgB,YAAY,cAAc,eAAe,EAAE;AAE3E,YAAQ,IAAI,2BAA2B;AAEvC,gBAAY,QAAQ,WAAW,QAAQ,UAAU;GACjD;AAED,UAAO,cAAc,cAAc,mBAAmB,aAAa,WAAW,YAAY;EAC1F;EAED,eAAeC,QAAwC;AACtD,UAAO,cAAc,cAAc,eAAe,OAAO;EACzD;EAED,wBAAwBC,WAAoBC,YAAsCC,aAA2C;AAC5H,UAAO,cAAc,cAAc,wBAAwB,WAAW,YAAY,YAAY;EAC9F;CACD;CAED,IAAIC;AACJ,MAAK,WAAW,CACf,kBAAiB,IAAI,qBAAqB,IAAI,iCAAiC;IAE/E,kBAAiB,IAAI;AAGtB,SAAQ,yBAAyB,IAAI;CACrC,MAAM,EAAE,oBAAoB,GAAG,MAAM,OAAO;AAE5C,SAAQ,QAAQ,IAAI;EACnB,QAAQ;;;;EAIR,IAAI,aAAa,QAAQ;EACzB;EACA,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR;EACA,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,IAAI,mBAAmB,QAAQ;EAC/B;EACA;EACA,OAAOX,UAAiB;AACvB,SAAM,OAAO,UAAU,MAAM;EAC7B;EACD,QAAQ;;AAGT,SAAQ,SAAS,aAAa,YAAY;EACzC,MAAM,EAAE,cAAc,GAAG,MAAM,OAAO;EACtC,MAAM,UAAU,MAAM,QAAQ,SAAS;EACvC,MAAM,oBAAoB,CAAC,QAAQ,SAAS,gBAAiB;AAC7D,SAAO,IAAI,aAAa,QAAQ,MAAM,QAAQ,IAAI,QAAQ,OAAO,mBAAmB,aAAa,QAAQ;CACzG,EAAC;AACF,SAAQ,iBAAiB,aAAa,YAAY;EACjD,MAAM,EAAE,sBAAsB,GAAG,MAAM,OAAO;AAC9C,SAAO,IAAI,qBACV,QAAQ,MACR,MAAM,QAAQ,iBAAiB,EAC/B,MAAM,QAAQ,UAAU,EACxB,QAAQ,qBACR,QAAQ,iBACR,cAAc,0BACd,QAAQ,OACR,QAAQ,UACR,QAAQ,WACR,MAAM,QAAQ,aAAa;CAE5B,EAAC;AACF,SAAQ,WAAW,aAAa,YAAY;EAC3C,MAAM,EAAE,gBAAgB,GAAG,MAAM,OAAO;AACxC,SAAO,IAAI,eACV,QAAQ,MACR,MAAM,QAAQ,iBAAiB,EAC/B,MAAM,QAAQ,gBAAgB,EAC9B,MAAM,QAAQ,UAAU,EACxB,QAAQ,KACR,QAAQ,qBACR,QAAQ,iBACR,MAAM,QAAQ,SAAS,EACvB,QAAQ,QACR,cAAc,0BACd,QAAQ,WACR,QAAQ,UACR,QAAQ,WACR,MAAM,QAAQ,aAAa,EAC3B,QAAQ;CAET,EAAC;CACF,MAAM,SAAS,IAAI,OAAO,IAAI,iCAAiC,SAAS;AACxE,SAAQ,OAAO,aAAa,YAAY;EACvC,MAAM,EAAE,YAAY,GAAG,MAAM,OAAO;AACpC,SAAO,IAAI,WAAW,QAAQ,YAAY,mBAAmB,SAAS,QAAQ,QAAQ,gBAAgB,QAAQ,QAAQ,QAAQ;CAC9H,EAAC;AACF,SAAQ,OAAO,aAAa,YAAY;EACvC,MAAM,EAAE,YAAY,GAAG,MAAM,OAAO;AACpC,SAAO,IAAI,WACV,QAAQ,MACR,QAAQ,qBACR,QAAQ,QACR,QAAQ,iBACR,MAAM,QAAQ,MAAM,EACpB,SACA,QAAQ,OACR,QAAQ;CAET,EAAC;CACF,MAAM,mBAAmB,IAAI,+BAA+B;AAC5D,SAAQ,WAAW,aAAa,YAAY;EAC3C,MAAM,EAAE,gBAAgB,GAAG,MAAM,OAAO;AACxC,SAAO,IAAI,eACV,QAAQ,MACR,MAAM,QAAQ,iBAAiB,EAC/B,cAAc,MAAM,EACpB,wBACA,kBACA,cAAc,0BACd,QAAQ,gBACR,QAAQ,iBACR,QAAQ,QACR,cAAc;CAEf,EAAC;AAEF,SAAQ,cAAc,aAAa,YAAY;EAC9C,MAAM,EAAE,mBAAmB,GAAG,MAAM,OAAO;AAC3C,SAAO,IAAI,kBACV,QAAQ,MACR,MAAM,QAAQ,iBAAiB,EAC/B,QAAQ,iBACR;CAED,EAAC;CACF,MAAM,YAAY,IAAI,cAAc,cAAc,MAAM;AAExD,SAAQ,eAAe,aAAa,YAAY;EAC/C,MAAM,EAAE,uBAAuB,GAAG,MAAM,OAAO;AAC/C,SAAO,IAAI,sBAAsB,QAAQ,WAAW,QAAQ;CAC5D,EAAC;CAEF,MAAM,sBAAsB,IAAI,yBAC/B,cAAc,wBACd,QAAQ,MACR,QAAQ,MACR,QAAQ,qBACR,cAAc,iBACd,QAAQ,cACR,QAAQ,aACR,QAAQ,iBACR,OAAOA,UAAiB;AACvB,QAAM,OAAO,UAAU,MAAM;CAC7B,GACD,OAAOY,gBAA+B;EACrC,MAAM,UAAU,MAAM,QAAQ,SAAS;AACvC,UAAQ,kBAAkB,YAAY;AACtC,UAAQ,iBAAiB;CACzB;AAGF,SAAQ,iBAAiB,IAAI,eAC5B,qBACA,SAAS,IAAI,mCACb,QAAQ,MACR,QAAQ,qBACR,QAAQ,gBACR,CAAC,SAAS,IAAI,UAAU,oBAAoB,aAAa,GAAG,OAC5D,IAAI,cAAc,WAAW,eAC7B,cAAc;AAEf,SAAQ,MAAM,KAAK,QAAQ,eAAe;AAC1C,SAAQ,QAAQ;AAChB,SAAQ,YAAY,aAAa,YAAY;EAC5C,MAAM,EAAE,gBAAgB,GAAG,MAAM,OAAO;AACxC,SAAO,IAAI,eAAe,QAAQ,MAAM,MAAM,QAAQ,UAAU,EAAE,QAAQ,iBAAiB,QAAQ,QAAQ,QAAQ;CACnH,EAAC;AACF,SAAQ,gBAAgB,aAAa,YAAY;EAChD,MAAM,EAAE,eAAe,GAAG,MAAM,OAAO;AACvC,SAAO,IAAI,cAAc,IAAI,aAAa,QAAQ;CAClD,EAAC;AACF,SAAQ,mBAAmB,aAAa,YAAY;EACnD,MAAM,EAAE,kBAAkB,GAAG,MAAM,OAAO;EAC1C,MAAM,EAAE,uBAAuB,GAAG,MAAM,OAAO;EAC/C,MAAM,wBAAwB,IAAI,sBAAsB,QAAQ;AAChE,SAAO,IAAI,iBAAiB,uBAAuB,MAAM,QAAQ,gBAAgB,EAAE,MAAM,QAAQ,MAAM,EAAE,QAAQ,QAAQ,QAAQ;CACjI,EAAC;AACF;AAED,MAAM,2CAA2C;AAEjD,eAAe,YAAYd,QAAoBO,WAAsBQ,iBAAiD;CACrH,MAAM,UAAU,MAAM,QAAQ,SAAS;AACvC,KAAI;AACH,QAAM,QAAQ,KAAK;GAClB,MAAM,cAAc,QAAQ,KAAK,SAAS,CAAC;GAC3C;GACA;EACA,EAAC;CACF,SAAQ,GAAG;AACX,MAAI,aAAa,yBAAyB;AACzC,WAAQ,IAAI,iEAAiE;AAC7E,SAAM,MAAM,yCAAyC;AACrD,WAAQ,IAAI,6CAA6C;AACzD,UAAO,YAAY,QAAQ,WAAW,gBAAgB;EACtD,WAAU,aAAa,iBAAiB;AACxC,WAAQ,IAAI,yDAAyD;AACrE,SAAM,MAAM,yCAAyC;AACrD,WAAQ,IAAI,qCAAqC;AACjD,UAAO,YAAY,QAAQ,WAAW,gBAAgB;EACtD,OAAM;AAEN,UAAO,UAAU,EAAE;AACnB;EACA;CACD;AACD,KAAI,UAAU,gBAAgB,UAAU,eAEvC,SAAQ,oBAAoB;AAE7B;AAEM,eAAe,eAA8B;AACnD,OAAM,QAAQ,MAAM,cAAc;AAClC,OAAM,YAAY,QAAQ,SAAS,QAAQ,aAAa;AACxD;AAED,WAAW,SAAS,YAClB,CAAC,KAAsC,UAAU"}