{"version":3,"file":"SubscriptionDialogs-DAlWs68I.js","names":["acceptedPlans: AvailablePlanType[]","messageIdOrMessageFunction: TranslationKey","reason?: MaybeTranslation","userController: UserController"],"sources":["../../src/common/misc/SubscriptionDialogs.ts"],"sourcesContent":["import { assertNotNull, downcast, isEmpty, neverNull } from \"@tutao/tutanota-utils\"\nimport { Dialog } from \"../gui/base/Dialog\"\nimport type { TranslationKey, MaybeTranslation } from \"./LanguageViewModel\"\nimport { lang } from \"./LanguageViewModel\"\nimport type { ClickHandler } from \"../gui/base/GuiUtils\"\nimport { locator } from \"../api/main/CommonLocator\"\nimport type { UserController } from \"../api/main/UserController.js\"\nimport { BookingTypeRef } from \"../api/entities/sys/TypeRefs.js\"\nimport { GENERATED_MAX_ID } from \"../api/common/utils/EntityUtils.js\"\nimport { AvailablePlanType, Const, NewBusinessPlans, NewPaidPlans, NewPersonalPlans, PlanType } from \"../api/common/TutanotaConstants.js\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\n\n/**\n * Opens a dialog which states that the function is not available in the Free subscription and provides an option to upgrade.\n */\nexport async function showNotAvailableForFreeDialog(acceptedPlans: AvailablePlanType[] = NewPaidPlans) {\n\tconst wizard = await import(\"../subscription/UpgradeSubscriptionWizard\")\n\tconst customerInfo = await locator.logins.getUserController().loadCustomerInfo()\n\n\tconst businessPlanRequired =\n\t\tacceptedPlans.filter((plan) => NewBusinessPlans.includes(plan)).length === acceptedPlans.length &&\n\t\tNewPersonalPlans.includes(downcast(customerInfo.plan))\n\tconst msg = businessPlanRequired ? \"pricing.notSupportedByPersonalPlan_msg\" : \"newPaidPlanRequired_msg\"\n\n\tawait wizard.showUpgradeWizard(locator.logins, acceptedPlans, msg)\n}\n\nexport function createNotAvailableForFreeClickHandler(acceptedPlans: AvailablePlanType[], click: ClickHandler, available: () => boolean): ClickHandler {\n\treturn (e, dom) => {\n\t\tif (!available()) {\n\t\t\tshowNotAvailableForFreeDialog(acceptedPlans)\n\t\t} else {\n\t\t\tclick(e, dom)\n\t\t}\n\t}\n}\n\n/**\n * Returns whether a paid subscriptino is active and shows one of the showNotAvailableForFreeDialog or subscription cancelled dialogs if needed.\n */\nexport async function checkPaidSubscription(): Promise<boolean> {\n\tif (locator.logins.getUserController().isFreeAccount()) {\n\t\tshowNotAvailableForFreeDialog()\n\t\treturn false\n\t}\n\treturn true\n}\n\nexport async function showMoreStorageNeededOrderDialog(messageIdOrMessageFunction: TranslationKey): Promise<PlanType | void> {\n\tconst userController = locator.logins.getUserController()\n\tif (!userController.isGlobalAdmin()) {\n\t\treturn Dialog.message(\"insufficientStorageWarning_msg\")\n\t}\n\tconst confirmed = await Dialog.confirm(messageIdOrMessageFunction, \"upgrade_action\")\n\tif (confirmed) {\n\t\tif (userController.isFreeAccount()) {\n\t\t\tconst wizard = await import(\"../subscription/UpgradeSubscriptionWizard\")\n\t\t\treturn wizard.showUpgradeWizard(locator.logins)\n\t\t} else {\n\t\t\tconst usedStorage = Number(await locator.userManagementFacade.readUsedUserStorage(userController.user))\n\t\t\tconst { getAvailableMatchingPlans } = await import(\"../subscription/SubscriptionUtils.js\")\n\t\t\tconst plansWithMoreStorage = await getAvailableMatchingPlans(\n\t\t\t\tlocator.serviceExecutor,\n\t\t\t\t(config) => Number(config.storageGb) * Const.MEMORY_GB_FACTOR > usedStorage,\n\t\t\t)\n\t\t\tif (isEmpty(plansWithMoreStorage)) {\n\t\t\t\tawait Dialog.message(userController.isGlobalAdmin() ? \"insufficientStorageAdmin_msg\" : \"insufficientStorageUser_msg\")\n\t\t\t} else {\n\t\t\t\tawait showPlanUpgradeRequiredDialog(plansWithMoreStorage)\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @returns true if the needed plan has been ordered\n */\nexport async function showPlanUpgradeRequiredDialog(acceptedPlans: AvailablePlanType[], reason?: MaybeTranslation): Promise<boolean> {\n\tif (isEmpty(acceptedPlans)) {\n\t\tthrow new ProgrammingError(\"no plans specified\")\n\t}\n\tconst userController = locator.logins.getUserController()\n\tif (userController.isFreeAccount()) {\n\t\tshowNotAvailableForFreeDialog(acceptedPlans)\n\t\treturn false\n\t} else if (!userController.isGlobalAdmin()) {\n\t\tDialog.message(\"contactAdmin_msg\")\n\t\treturn false\n\t} else {\n\t\tif (reason == null) {\n\t\t\t// show generic reason if not supplied\n\t\t\tlet customerInfo = await userController.loadCustomerInfo()\n\t\t\tconst businessPlanRequired =\n\t\t\t\tacceptedPlans.filter((plan) => NewBusinessPlans.includes(plan)).length === acceptedPlans.length &&\n\t\t\t\t!NewBusinessPlans.includes(downcast(customerInfo.plan))\n\t\t\treason = businessPlanRequired ? \"pricing.notSupportedByPersonalPlan_msg\" : \"newPaidPlanRequired_msg\"\n\t\t}\n\t\tawait showSwitchPlanDialog(userController, acceptedPlans, reason)\n\t\treturn acceptedPlans.includes(downcast<AvailablePlanType>(await userController.getPlanType()))\n\t}\n}\n\nexport async function showUpgradeWizardOrSwitchSubscriptionDialog(userController: UserController): Promise<void> {\n\tif (userController.isFreeAccount()) {\n\t\tconst { showUpgradeWizard } = await import(\"../subscription/UpgradeSubscriptionWizard\")\n\t\tawait showUpgradeWizard(locator.logins)\n\t} else {\n\t\tawait showSwitchPlanDialog(userController, NewPaidPlans)\n\t}\n}\n\nasync function showSwitchPlanDialog(userController: UserController, acceptedPlans: AvailablePlanType[], reason?: MaybeTranslation): Promise<void> {\n\tlet customerInfo = await userController.loadCustomerInfo()\n\tconst bookings = await locator.entityClient.loadRange(BookingTypeRef, neverNull(customerInfo.bookings).items, GENERATED_MAX_ID, 1, true)\n\tconst { showSwitchDialog } = await import(\"../subscription/SwitchSubscriptionDialog\")\n\treturn showSwitchDialog(\n\t\tawait userController.loadCustomer(),\n\t\tcustomerInfo,\n\t\tawait userController.loadAccountingInfo(),\n\t\tassertNotNull(bookings[0]),\n\t\tacceptedPlans,\n\t\treason ?? null,\n\t)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeO,eAAe,8BAA8BA,gBAAqC,cAAc;CACtG,MAAM,SAAS,MAAM,OAAO;CAC5B,MAAM,eAAe,MAAM,QAAQ,OAAO,mBAAmB,CAAC,kBAAkB;CAEhF,MAAM,uBACL,cAAc,OAAO,CAAC,SAAS,iBAAiB,SAAS,KAAK,CAAC,CAAC,WAAW,cAAc,UACzF,iBAAiB,SAAS,SAAS,aAAa,KAAK,CAAC;CACvD,MAAM,MAAM,uBAAuB,2CAA2C;AAE9E,OAAM,OAAO,kBAAkB,QAAQ,QAAQ,eAAe,IAAI;AAClE;AAeM,eAAe,wBAA0C;AAC/D,KAAI,QAAQ,OAAO,mBAAmB,CAAC,eAAe,EAAE;AACvD,iCAA+B;AAC/B,SAAO;CACP;AACD,QAAO;AACP;AAEM,eAAe,iCAAiCC,4BAAsE;CAC5H,MAAM,iBAAiB,QAAQ,OAAO,mBAAmB;AACzD,MAAK,eAAe,eAAe,CAClC,QAAO,OAAO,QAAQ,iCAAiC;CAExD,MAAM,YAAY,MAAM,OAAO,QAAQ,4BAA4B,iBAAiB;AACpF,KAAI,UACH,KAAI,eAAe,eAAe,EAAE;EACnC,MAAM,SAAS,MAAM,OAAO;AAC5B,SAAO,OAAO,kBAAkB,QAAQ,OAAO;CAC/C,OAAM;EACN,MAAM,cAAc,OAAO,MAAM,QAAQ,qBAAqB,oBAAoB,eAAe,KAAK,CAAC;EACvG,MAAM,EAAE,2BAA2B,GAAG,MAAM,OAAO;EACnD,MAAM,uBAAuB,MAAM,0BAClC,QAAQ,iBACR,CAAC,WAAW,OAAO,OAAO,UAAU,GAAG,MAAM,mBAAmB,YAChE;AACD,MAAI,QAAQ,qBAAqB,CAChC,OAAM,OAAO,QAAQ,eAAe,eAAe,GAAG,iCAAiC,8BAA8B;IAErH,OAAM,8BAA8B,qBAAqB;CAE1D;AAEF;AAKM,eAAe,8BAA8BD,eAAoCE,QAA6C;AACpI,KAAI,QAAQ,cAAc,CACzB,OAAM,IAAI,iBAAiB;CAE5B,MAAM,iBAAiB,QAAQ,OAAO,mBAAmB;AACzD,KAAI,eAAe,eAAe,EAAE;AACnC,gCAA8B,cAAc;AAC5C,SAAO;CACP,YAAW,eAAe,eAAe,EAAE;AAC3C,SAAO,QAAQ,mBAAmB;AAClC,SAAO;CACP,OAAM;AACN,MAAI,UAAU,MAAM;GAEnB,IAAI,eAAe,MAAM,eAAe,kBAAkB;GAC1D,MAAM,uBACL,cAAc,OAAO,CAAC,SAAS,iBAAiB,SAAS,KAAK,CAAC,CAAC,WAAW,cAAc,WACxF,iBAAiB,SAAS,SAAS,aAAa,KAAK,CAAC;AACxD,YAAS,uBAAuB,2CAA2C;EAC3E;AACD,QAAM,qBAAqB,gBAAgB,eAAe,OAAO;AACjE,SAAO,cAAc,SAAS,SAA4B,MAAM,eAAe,aAAa,CAAC,CAAC;CAC9F;AACD;AAWD,eAAe,qBAAqBC,gBAAgCH,eAAoCE,QAA0C;CACjJ,IAAI,eAAe,MAAM,eAAe,kBAAkB;CAC1D,MAAM,WAAW,MAAM,QAAQ,aAAa,UAAU,gBAAgB,UAAU,aAAa,SAAS,CAAC,OAAO,kBAAkB,GAAG,KAAK;CACxI,MAAM,EAAE,kBAAkB,GAAG,MAAM,OAAO;AAC1C,QAAO,iBACN,MAAM,eAAe,cAAc,EACnC,cACA,MAAM,eAAe,oBAAoB,EACzC,cAAc,SAAS,GAAG,EAC1B,eACA,UAAU,KACV;AACD"}