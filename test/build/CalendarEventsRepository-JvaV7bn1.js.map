{"version":3,"file":"CalendarEventsRepository-JvaV7bn1.js","names":["calendarModel: CalendarModel","calendarFacade: CalendarFacade","zone: string","entityClient: EntityClient","eventController: EventController","contactModel: ContactModel","logins: LoginController","daysInMonths: Array<Date>","progressMonitor: IProgressMonitor","canceled: Stream<boolean>","calendarInfo: CalendarInfo | null","event: CalendarEvent","newMap: DaysToEvents","month: CalendarTimeRange","id: IdTuple","eventToRemove: CalendarEvent","updates: ReadonlyArray<EntityUpdateData>","eventOwnerGroupId: string","month: number","newEvent: CalendarEvent","baseYear: number | null","contact: Contact","userId: Id","forceReload: boolean","date: Date","selectedDate: Date","monthRangeForRecurrence: CalendarTimeRange"],"sources":["../../src/common/calendar/date/CalendarEventsRepository.ts"],"sourcesContent":["import Stream from \"mithril/stream\"\nimport stream from \"mithril/stream\"\nimport { CalendarInfo, CalendarModel } from \"../../../calendar-app/calendar/model/CalendarModel.js\"\nimport { IProgressMonitor } from \"../../api/common/utils/ProgressMonitor.js\"\nimport {\n\taddDaysForRecurringEvent,\n\tcalculateContactsAge,\n\tCalendarTimeRange,\n\tcreateRepeatRuleWithValues,\n\textractYearFromBirthday,\n\tgenerateUid,\n\tgetEventEnd,\n\tgetEventStart,\n\tgetMonthRange,\n\tisBirthdayEvent,\n\tisClientOnlyCalendar,\n} from \"./CalendarUtils.js\"\nimport { CalendarEvent, CalendarEventTypeRef, Contact, ContactTypeRef, createCalendarEvent } from \"../../api/entities/tutanota/TypeRefs.js\"\nimport { getListId, isSameId, listIdPart } from \"../../api/common/utils/EntityUtils.js\"\nimport { DateTime } from \"luxon\"\nimport { CalendarFacade } from \"../../api/worker/facades/lazy/CalendarFacade.js\"\nimport { EntityClient } from \"../../api/common/EntityClient.js\"\nimport { findAllAndRemove, incrementDate, isNotNull, stringToBase64 } from \"@tutao/tutanota-utils\"\nimport { CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID, OperationType, RepeatPeriod } from \"../../api/common/TutanotaConstants.js\"\nimport { NotAuthorizedError, NotFoundError } from \"../../api/common/error/RestError.js\"\nimport { EventController } from \"../../api/main/EventController.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../../api/common/utils/EntityUpdateUtils.js\"\nimport { generateLocalEventElementId, getAllDayDateUTC } from \"../../api/common/utils/CommonCalendarUtils.js\"\nimport { ContactModel } from \"../../contactsFunctionality/ContactModel.js\"\nimport { LoginController } from \"../../api/main/LoginController.js\"\nimport { isoDateToBirthday } from \"../../api/common/utils/BirthdayUtils.js\"\n\nconst LIMIT_PAST_EVENTS_YEARS = 100\n\nconst TAG = \"[CalendarEventRepository]\"\n\n/** Map from timestamp of beginnings of days to events that occur on those days. */\nexport type DaysToEvents = ReadonlyMap<number, ReadonlyArray<CalendarEvent>>\n\n/** Object holding the year of birth if available and the corresponding event */\nexport type BirthdayEventRegistry = {\n\tbaseYear: number | null\n\tevent: CalendarEvent\n}\n\n/**\n * Loads and keeps calendar events up to date.\n *\n * If you need to load calendar events there's a good chance you should just use this\n */\nexport class CalendarEventsRepository {\n\t/** timestamps of the beginning of months that we already loaded */\n\tprivate readonly loadedMonths = new Set<number>()\n\tprivate daysToEvents: Stream<DaysToEvents> = stream(new Map())\n\tprivate pendingLoadRequest: Promise<void> = Promise.resolve()\n\n\tprivate clientOnlyEvents: Map<number, BirthdayEventRegistry[]> = new Map()\n\n\tconstructor(\n\t\tprivate readonly calendarModel: CalendarModel,\n\t\tprivate readonly calendarFacade: CalendarFacade,\n\t\tprivate readonly zone: string,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly contactModel: ContactModel,\n\t\tprivate readonly logins: LoginController,\n\t) {\n\t\teventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId))\n\n\t\t// Detect when group infos has been reset and reset our data in turn.\n\t\t// There is probably another way, we could reduce and also compute symmetric difference.\n\t\t// This might fire right away but it should be harmless then.\n\t\tthis.calendarModel.getCalendarInfosStream().map((infos) => {\n\t\t\tif (infos.size === 0) {\n\t\t\t\tthis.loadedMonths.clear()\n\t\t\t\tthis.daysToEvents(new Map())\n\t\t\t}\n\t\t})\n\t}\n\n\tgetEventsForMonths(): Stream<DaysToEvents> {\n\t\treturn this.daysToEvents\n\t}\n\n\tgetBirthdayEvents(): Map<number, BirthdayEventRegistry[]> {\n\t\treturn this.clientOnlyEvents\n\t}\n\n\tasync canLoadBirthdaysCalendar(): Promise<boolean> {\n\t\treturn await this.logins.getUserController().isNewPaidPlan()\n\t}\n\n\tasync loadMonthsIfNeeded(daysInMonths: Array<Date>, progressMonitor: IProgressMonitor, canceled: Stream<boolean>): Promise<void> {\n\t\tconst promiseForThisLoadRequest = this.pendingLoadRequest.then(async () => {\n\t\t\tfor (const dayInMonth of daysInMonths) {\n\t\t\t\tif (canceled()) return\n\n\t\t\t\tconst monthRange = getMonthRange(dayInMonth, this.zone)\n\n\t\t\t\tif (!this.loadedMonths.has(monthRange.start)) {\n\t\t\t\t\tthis.loadedMonths.add(monthRange.start)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst calendarInfos = await this.calendarModel.getCalendarInfos()\n\t\t\t\t\t\tconst eventsMap = await this.calendarFacade.updateEventMap(monthRange, calendarInfos, this.daysToEvents(), this.zone)\n\t\t\t\t\t\tthis.replaceEvents(eventsMap)\n\t\t\t\t\t\tthis.addBirthdaysEventsIfNeeded(dayInMonth, monthRange)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis.loadedMonths.delete(monthRange.start)\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprogressMonitor.workDone(1)\n\t\t\t}\n\t\t})\n\t\tthis.pendingLoadRequest = promiseForThisLoadRequest\n\t\tawait promiseForThisLoadRequest\n\t}\n\n\tprivate async addOrUpdateEvent(calendarInfo: CalendarInfo | null, event: CalendarEvent) {\n\t\tif (calendarInfo == null) {\n\t\t\treturn\n\t\t}\n\t\tconst eventListId = getListId(event)\n\t\tif (isSameId(calendarInfo.groupRoot.shortEvents, eventListId)) {\n\t\t\t// to prevent unnecessary churn, we only add the event if we have the months it covers loaded.\n\t\t\tconst eventStartMonth = getMonthRange(getEventStart(event, this.zone), this.zone)\n\t\t\tconst eventEndMonth = getMonthRange(getEventEnd(event, this.zone), this.zone)\n\t\t\tif (this.loadedMonths.has(eventStartMonth.start)) await this.addDaysForEvent(event, eventStartMonth)\n\t\t\t// no short event covers more than two months, so this should cover everything.\n\t\t\tif (eventEndMonth.start != eventStartMonth.start && this.loadedMonths.has(eventEndMonth.start)) await this.addDaysForEvent(event, eventEndMonth)\n\t\t} else if (isSameId(calendarInfo.groupRoot.longEvents, eventListId)) {\n\t\t\tthis.removeExistingEvent(event)\n\n\t\t\tfor (const firstDayTimestamp of this.loadedMonths) {\n\t\t\t\tconst loadedMonth = getMonthRange(new Date(firstDayTimestamp), this.zone)\n\n\t\t\t\tif (event.repeatRule != null) {\n\t\t\t\t\tawait this.addDaysForRecurringEvent(event, loadedMonth)\n\t\t\t\t} else {\n\t\t\t\t\tawait this.addDaysForEvent(event, loadedMonth)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate replaceEvents(newMap: DaysToEvents): void {\n\t\t// We rely on typescript ReadonlyMap type because freezing\n\t\t// this map throws \"The object can not be cloned\" on iOS\n\t\t// when the source of newMap is updateEventMap\n\t\tthis.daysToEvents(newMap)\n\t}\n\n\tprivate cloneEvents(): Map<number, Array<CalendarEvent>> {\n\t\treturn new Map(Array.from(this.daysToEvents().entries()).map(([day, events]) => [day, events.slice()]))\n\t}\n\n\tprivate addDaysForRecurringEvent(event: CalendarEvent, month: CalendarTimeRange): void {\n\t\tif (!isClientOnlyCalendar(listIdPart(event._id)) && -DateTime.fromJSDate(event.startTime).diffNow(\"year\").years > LIMIT_PAST_EVENTS_YEARS) {\n\t\t\tconsole.log(\"repeating event is too far into the past\", event)\n\t\t\treturn\n\t\t}\n\n\t\tconst newMap = this.cloneEvents()\n\n\t\taddDaysForRecurringEvent(newMap, event, month, this.zone)\n\n\t\tthis.replaceEvents(newMap)\n\t}\n\n\tprivate removeDaysForEvent(id: IdTuple): void {\n\t\tconst newMap = this.cloneEvents()\n\n\t\tfor (const dayEvents of newMap.values()) {\n\t\t\tfindAllAndRemove(dayEvents, (e) => isSameId(e._id, id))\n\t\t}\n\n\t\tthis.replaceEvents(newMap)\n\t}\n\n\t/**\n\t * Removes {@param eventToRemove} from {@param events} using isSameEvent()\n\t */\n\tprivate removeExistingEvent(eventToRemove: CalendarEvent) {\n\t\tconst newMap = this.cloneEvents()\n\n\t\tfor (const dayEvents of newMap.values()) {\n\t\t\tfindAllAndRemove(dayEvents, (e) => isSameId(e._id, eventToRemove._id))\n\t\t}\n\n\t\tthis.replaceEvents(newMap)\n\t}\n\n\tprivate async addDaysForEvent(event: CalendarEvent, month: CalendarTimeRange) {\n\t\tconst { addDaysForEventInstance } = await import(\"./CalendarUtils.js\")\n\t\tconst newMap = this.cloneEvents()\n\t\taddDaysForEventInstance(newMap, event, month, this.zone)\n\t\tthis.replaceEvents(newMap)\n\t}\n\n\tprivate async entityEventsReceived(updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: string) {\n\t\tconst calendarInfos = await this.calendarModel.getCalendarInfos()\n\t\tfor (const update of updates) {\n\t\t\tif (isUpdateForTypeRef(CalendarEventTypeRef, update)) {\n\t\t\t\tif (update.operation === OperationType.CREATE || update.operation === OperationType.UPDATE) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst event = await this.entityClient.load(CalendarEventTypeRef, [update.instanceListId, update.instanceId])\n\t\t\t\t\t\tawait this.addOrUpdateEvent(calendarInfos.get(eventOwnerGroupId) ?? null, event)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\t\t\t\tconsole.log(TAG, e.name, \"updated event is not accessible anymore\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t} else if (update.operation === OperationType.DELETE) {\n\t\t\t\t\tthis.removeDaysForEvent([update.instanceListId, update.instanceId])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic pushClientOnlyEvent(month: number, newEvent: CalendarEvent, baseYear: number | null) {\n\t\tlet clientOnlyEventsOfThisMonth = this.clientOnlyEvents.get(month) ?? []\n\t\tclientOnlyEventsOfThisMonth.push({ baseYear, event: newEvent })\n\t\tthis.clientOnlyEvents.set(month, clientOnlyEventsOfThisMonth)\n\t}\n\n\tprivate createClientOnlyBirthdayEvent(contact: Contact, userId: Id) {\n\t\tconst encodedContactId = stringToBase64(contact._id.join(\"/\"))\n\t\tconst calendarId = `${userId}#${CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID}`\n\t\tconst uid = generateUid(calendarId, Date.now())\n\n\t\tconst eventTitle = this.calendarModel.getBirthdayEventTitle(contact.firstName)\n\n\t\tlet fullDateIso = contact.birthdayIso!\n\t\t// Set the year because we can have birthdays without year\n\t\tif (contact.birthdayIso?.startsWith(\"--\")) {\n\t\t\tfullDateIso = contact.birthdayIso.replace(\"-\", \"1970\")\n\t\t}\n\n\t\tconst birthday = new Date(fullDateIso!)\n\n\t\t// Set up start and end date base on UTC.\n\t\t// Also increments a copy of startDate by one day and set it as endDate\n\t\tconst startDate = getAllDayDateUTC(new Date(birthday))\n\t\tconst endDate = getAllDayDateUTC(incrementDate(new Date(startDate), 1))\n\n\t\tconst newEvent = createCalendarEvent({\n\t\t\tsequence: \"0\",\n\t\t\trecurrenceId: null,\n\t\t\thashedUid: null,\n\t\t\tsummary: eventTitle,\n\t\t\tstartTime: startDate,\n\t\t\tendTime: endDate,\n\t\t\tlocation: \"\",\n\t\t\tdescription: \"\", // The only visible part of the event will be the title\n\t\t\talarmInfos: [],\n\t\t\torganizer: null,\n\t\t\tattendees: [],\n\t\t\tinvitedConfidentially: null,\n\t\t\trepeatRule: createRepeatRuleWithValues(RepeatPeriod.ANNUALLY, 1),\n\t\t\tuid,\n\t\t})\n\n\t\tnewEvent._id = [calendarId, `${generateLocalEventElementId(newEvent.startTime.getTime(), contact._id.join(\"/\"))}#${encodedContactId}`]\n\t\tnewEvent._ownerGroup = calendarId\n\t\treturn newEvent\n\t}\n\n\tasync loadContactsBirthdays(forceReload: boolean = false) {\n\t\t// Do not reload birthdays\n\t\tif (this.clientOnlyEvents.size > 0 && !forceReload) {\n\t\t\treturn\n\t\t}\n\n\t\t// Always work with an empty map of birthdays\n\t\tthis.clientOnlyEvents.clear()\n\n\t\tconst listId = await this.contactModel.getContactListId()\n\t\tif (listId == null) return []\n\n\t\tconst contacts = await this.entityClient.loadAll(ContactTypeRef, listId)\n\t\tconst filteredContacts = contacts\n\t\t\t.filter((contact) => contact.birthdayIso)\n\t\t\t.sort((a, b) => {\n\t\t\t\tconst birthdayContactA = isoDateToBirthday(a.birthdayIso!)\n\t\t\t\tconst birthdayContactB = isoDateToBirthday(b.birthdayIso!)\n\t\t\t\treturn (\n\t\t\t\t\tnew Date(`${birthdayContactA.month}/${birthdayContactA.day}`).getTime() -\n\t\t\t\t\tnew Date(`${birthdayContactB.month}/${birthdayContactB.day}`).getTime()\n\t\t\t\t)\n\t\t\t})\n\n\t\tfor (const contact of filteredContacts) {\n\t\t\tconst newEvent = this.createClientOnlyBirthdayEvent(contact, this.logins.getUserController().userId)\n\t\t\tthis.pushClientOnlyEvent(newEvent.startTime.getMonth(), newEvent, extractYearFromBirthday(contact.birthdayIso))\n\t\t}\n\n\t\treturn filteredContacts\n\t}\n\n\trefreshBirthdayCalendar(date: Date) {\n\t\tconst month = getMonthRange(date, this.zone)\n\t\tthis.addBirthdaysEventsIfNeeded(date, month, true)\n\t}\n\n\taddBirthdaysEventsIfNeeded(selectedDate: Date, monthRangeForRecurrence: CalendarTimeRange, removeEventOccurrences = false) {\n\t\tconst clientOnlyEventsThisMonth = this.clientOnlyEvents.get(selectedDate.getMonth())\n\t\tconst birthdaysOfThisMonth = clientOnlyEventsThisMonth?.filter((birthdayEvent) => isBirthdayEvent(birthdayEvent.event.uid))\n\t\tif (birthdaysOfThisMonth) {\n\t\t\tfor (const calendarEvent of birthdaysOfThisMonth) {\n\t\t\t\tconst age = calculateContactsAge(calendarEvent.baseYear, selectedDate.getFullYear())\n\t\t\t\tconst ageString = age ? `(${this.calendarModel.getAgeString(age)})` : \"\"\n\n\t\t\t\tif (removeEventOccurrences) {\n\t\t\t\t\tthis.removeDaysForEvent(calendarEvent.event._id)\n\t\t\t\t}\n\t\t\t\tthis.addDaysForRecurringEvent(\n\t\t\t\t\t{\n\t\t\t\t\t\t...calendarEvent.event,\n\t\t\t\t\t\tsummary: `${calendarEvent.event.summary} ${ageString}`,\n\t\t\t\t\t},\n\t\t\t\t\tmonthRangeForRecurrence,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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"}