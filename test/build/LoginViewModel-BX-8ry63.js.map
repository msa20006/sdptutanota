{"version":3,"file":"LoginViewModel-BX-8ry63.js","names":["logins: LoginController","includeInvoiceNotPaidForAdmin: boolean","defaultStatus?: ApprovalStatus","error: Error","isExternalLogin: boolean","error: E","handler: (error: E) => void","string: string","vnode: Vnode<LoginFormAttrs>","e: SubmitEvent","e: KeyboardEvent","e: MouseEvent","vnode: Vnode<CredentialsSelectorAttrs>","buttons: Children","vnode: Vnode","sizes","loginController: LoginController","credentialsProvider: CredentialsProvider","secondFactorHandler: SecondFactorHandler","deviceConfig: DeviceConfig","domainConfig: DomainConfig","credentialRemovalHandler: CredentialRemovalHandler","pushServiceApp: NativePushServiceApp | null","appLock: AppLock","userId: string","encryptedCredentials: CredentialsInfo","credentialsInfo: CredentialsInfo","userId: Id","credentials: UnencryptedCredentials | null","credentials","error: Error"],"sources":["../../src/common/misc/LoginUtils.ts","../../src/common/login/LoginForm.ts","../../src/common/login/CredentialsSelector.ts","../../src/common/gui/BaseTopLevelView.ts","../../src/common/gui/base/DesktopBaseHeader.ts","../../src/common/gui/LoginScreenHeader.ts","../../src/common/login/LoginView.ts","../../src/common/login/LoginViewModel.ts"],"sourcesContent":["import type { LoginController } from \"../api/main/LoginController\"\nimport { Dialog } from \"../gui/base/Dialog\"\nimport { generatedIdToTimestamp } from \"../api/common/utils/EntityUtils\"\nimport type { MaybeTranslation } from \"./LanguageViewModel\"\nimport { lang } from \"./LanguageViewModel\"\nimport {\n\tAccessBlockedError,\n\tAccessDeactivatedError,\n\tAccessExpiredError,\n\tBadRequestError,\n\tConnectionError,\n\tNotAuthenticatedError,\n\tNotAuthorizedError,\n\tNotFoundError,\n\tTooManyRequestsError,\n} from \"../api/common/error/RestError\"\nimport { CancelledError } from \"../api/common/error/CancelledError\"\nimport {\n\tApprovalStatus,\n\tAvailablePlans,\n\tAvailablePlanType,\n\tgetCustomerApprovalStatus,\n\tKdfType,\n\tNewBusinessPlans,\n\tNewPaidPlans,\n\tNewPersonalPlans,\n\tSubscriptionType,\n} from \"../api/common/TutanotaConstants\"\nimport type { ResetAction } from \"../login/recover/RecoverLoginDialog\"\nimport { showProgressDialog } from \"../gui/dialogs/ProgressDialog\"\nimport { UserError } from \"../api/main/UserError\"\nimport { noOp, ofClass } from \"@tutao/tutanota-utils\"\nimport { showUserError } from \"./ErrorHandlerImpl\"\nimport type { SubscriptionParameters } from \"../subscription/UpgradeSubscriptionWizard\"\nimport { locator } from \"../api/main/CommonLocator\"\nimport { CredentialAuthenticationError } from \"../api/common/error/CredentialAuthenticationError\"\nimport type { Params } from \"mithril\"\nimport { LoginState } from \"../login/LoginViewModel.js\"\n\n/**\n * Shows warnings if the invoices are not paid or the registration is not approved yet.\n * @param logins The `LoginController` used to retrieve the current users customer information from.\n * @param includeInvoiceNotPaidForAdmin If true, also shows a warning for an admin if the invoice is not paid (use at login), if false does not show this warning (use when sending an email).\n * @param defaultStatus This status is used if the actual status on the customer is \"0\"\n * @returns True if the user may still send emails, false otherwise.\n */\nexport function checkApprovalStatus(logins: LoginController, includeInvoiceNotPaidForAdmin: boolean, defaultStatus?: ApprovalStatus): Promise<boolean> {\n\tif (!logins.getUserController().isInternalUser()) {\n\t\t// external users are not authorized to load the customer\n\t\treturn Promise.resolve(true)\n\t}\n\n\treturn logins\n\t\t.getUserController()\n\t\t.loadCustomer()\n\t\t.then((customer) => {\n\t\t\tconst approvalStatus = getCustomerApprovalStatus(customer)\n\t\t\tconst status = approvalStatus === ApprovalStatus.REGISTRATION_APPROVED && defaultStatus != null ? defaultStatus : approvalStatus\n\t\t\tif (\n\t\t\t\tstatus === ApprovalStatus.REGISTRATION_APPROVAL_NEEDED ||\n\t\t\t\tstatus === ApprovalStatus.DELAYED ||\n\t\t\t\tstatus === ApprovalStatus.REGISTRATION_APPROVAL_NEEDED_AND_INITIALLY_ACCESSED\n\t\t\t) {\n\t\t\t\treturn Dialog.message(\"waitingForApproval_msg\").then(() => false)\n\t\t\t} else if (status === ApprovalStatus.DELAYED_AND_INITIALLY_ACCESSED) {\n\t\t\t\tif (new Date().getTime() - generatedIdToTimestamp(customer._id) > 2 * 24 * 60 * 60 * 1000) {\n\t\t\t\t\treturn Dialog.message(\"requestApproval_msg\").then(() => true)\n\t\t\t\t} else {\n\t\t\t\t\treturn Dialog.message(\"waitingForApproval_msg\").then(() => false)\n\t\t\t\t}\n\t\t\t} else if (status === ApprovalStatus.INVOICE_NOT_PAID) {\n\t\t\t\tif (logins.getUserController().isGlobalAdmin()) {\n\t\t\t\t\tif (includeInvoiceNotPaidForAdmin) {\n\t\t\t\t\t\treturn Dialog.message(\"invoiceNotPaid_msg\")\n\t\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t\t// TODO: navigate to payment site in settings\n\t\t\t\t\t\t\t\t//m.route.set(\"/settings\")\n\t\t\t\t\t\t\t\t//tutao.locator.settingsViewModel.show(tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_ADMIN_PAYMENT);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.then(() => true)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst errorMessage = lang.makeTranslation(\"invoiceNotPaidUser_msg\", lang.get(\"invoiceNotPaidUser_msg\") + \" \" + lang.get(\"contactAdmin_msg\"))\n\n\t\t\t\t\treturn Dialog.message(errorMessage).then(() => false)\n\t\t\t\t}\n\t\t\t} else if (status === ApprovalStatus.SPAM_SENDER) {\n\t\t\t\tDialog.message(\"loginAbuseDetected_msg\") // do not logout to avoid that we try to reload with mail editor open\n\n\t\t\t\treturn false\n\t\t\t} else if (status === ApprovalStatus.PAID_SUBSCRIPTION_NEEDED) {\n\t\t\t\tconst message = lang.get(\"upgradeNeeded_msg\")\n\t\t\t\treturn Dialog.reminder(lang.get(\"upgradeReminderTitle_msg\"), message).then((confirmed) => {\n\t\t\t\t\tif (confirmed) {\n\t\t\t\t\t\timport(\"../subscription/UpgradeSubscriptionWizard\").then((m) => m.showUpgradeWizard(logins))\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn true\n\t\t\t}\n\t\t})\n}\n\nexport function getLoginErrorMessage(error: Error, isExternalLogin: boolean): MaybeTranslation {\n\tswitch (error.constructor) {\n\t\tcase BadRequestError:\n\t\tcase NotAuthenticatedError:\n\t\tcase AccessDeactivatedError:\n\t\t\treturn \"loginFailed_msg\"\n\n\t\tcase AccessBlockedError:\n\t\t\treturn \"loginFailedOften_msg\"\n\n\t\tcase AccessExpiredError:\n\t\t\treturn isExternalLogin ? \"expiredLink_msg\" : \"inactiveAccount_msg\"\n\n\t\tcase TooManyRequestsError:\n\t\t\treturn \"tooManyAttempts_msg\"\n\n\t\tcase CancelledError:\n\t\t\treturn \"emptyString_msg\"\n\n\t\tcase CredentialAuthenticationError:\n\t\t\treturn lang.getTranslation(\"couldNotUnlockCredentials_msg\", {\n\t\t\t\t\"{reason}\": error.message,\n\t\t\t})\n\n\t\tcase ConnectionError:\n\t\t\treturn \"connectionLostLong_msg\"\n\n\t\tdefault:\n\t\t\treturn \"emptyString_msg\"\n\t}\n}\n\n/**\n * Handle expected login errors\n * Any unexpected errors will be rethrown\n */\nexport function handleExpectedLoginError<E extends Error>(error: E, handler: (error: E) => void) {\n\tif (\n\t\terror instanceof BadRequestError ||\n\t\terror instanceof NotAuthenticatedError ||\n\t\terror instanceof AccessExpiredError ||\n\t\terror instanceof AccessBlockedError ||\n\t\terror instanceof AccessDeactivatedError ||\n\t\terror instanceof TooManyRequestsError ||\n\t\terror instanceof CancelledError ||\n\t\terror instanceof CredentialAuthenticationError ||\n\t\terror instanceof ConnectionError\n\t) {\n\t\thandler(error)\n\t} else {\n\t\tthrow error\n\t}\n}\n\nexport function getLoginErrorStateAndMessage(error: Error): { errorMessage: MaybeTranslation; state: LoginState } {\n\tlet errorMessage = getLoginErrorMessage(error, false)\n\tlet state\n\tif (error instanceof BadRequestError || error instanceof NotAuthenticatedError) {\n\t\tstate = LoginState.InvalidCredentials\n\t} else if (error instanceof AccessExpiredError) {\n\t\tstate = LoginState.AccessExpired\n\t} else {\n\t\tstate = LoginState.UnknownError\n\t}\n\thandleExpectedLoginError(error, noOp)\n\treturn {\n\t\terrorMessage,\n\t\tstate,\n\t}\n}\n\nexport async function showSignupDialog(urlParams: Params) {\n\tconst subscriptionParams = getSubscriptionParameters(urlParams)\n\tconst registrationDataId = getRegistrationDataIdFromParams(urlParams)\n\tconst referralCode = getReferralCodeFromParams(urlParams)\n\tconst availablePlans = getAvailablePlansFromSubscriptionParameters(subscriptionParams)\n\tawait showProgressDialog(\n\t\t\"loading_msg\",\n\t\tlocator.worker.initialized.then(async () => {\n\t\t\tconst { loadSignupWizard } = await import(\"../subscription/UpgradeSubscriptionWizard\")\n\t\t\tawait loadSignupWizard(subscriptionParams, registrationDataId, referralCode, availablePlans)\n\t\t}),\n\t).catch(\n\t\tofClass(UserError, async (e) => {\n\t\t\tconst m = await import(\"mithril\")\n\t\t\tawait showUserError(e)\n\t\t\t// redirects if there were invalid parameters, e.g. for referral codes and campaignIds\n\t\t\tm.route.set(\"/signup\")\n\t\t}),\n\t)\n}\n\nfunction getAvailablePlansFromSubscriptionParameters(params: SubscriptionParameters | null): AvailablePlanType[] {\n\t// Default to all available plans if the params do not have the needed information\n\tif (params == null || params.type == null) return AvailablePlans\n\n\ttry {\n\t\tconst type = stringToSubscriptionType(params.type)\n\t\tswitch (type) {\n\t\t\tcase SubscriptionType.Business:\n\t\t\t\treturn NewBusinessPlans\n\t\t\tcase SubscriptionType.Personal:\n\t\t\t\treturn NewPersonalPlans\n\t\t\tcase SubscriptionType.PaidPersonal:\n\t\t\t\treturn NewPaidPlans.filter((paidPlan) => NewPersonalPlans.includes(paidPlan))\n\t\t}\n\t} catch (e) {\n\t\t// If params.type is not a valid subscription type, return the default value\n\t\treturn AvailablePlans\n\t}\n}\n\nexport function stringToSubscriptionType(string: string): SubscriptionType {\n\tswitch (string.toLowerCase()) {\n\t\tcase \"business\":\n\t\t\treturn SubscriptionType.Business\n\t\tcase \"private\":\n\t\t\treturn SubscriptionType.Personal\n\t\tcase \"privatepaid\":\n\t\t\treturn SubscriptionType.PaidPersonal\n\t\tdefault:\n\t\t\tthrow new Error(`Failed to get subscription type: ${string}`)\n\t}\n}\n\nfunction getSubscriptionParameters(hashParams: Params): SubscriptionParameters | null {\n\tconst { subscription, type, interval } = hashParams\n\tconst isSubscriptionString = typeof subscription === \"string\"\n\tconst isTypeString = typeof type === \"string\"\n\tconst isIntervalString = typeof interval === \"string\"\n\n\tif (!isSubscriptionString && !isTypeString && !isIntervalString) return null\n\n\treturn {\n\t\tsubscription: isSubscriptionString ? subscription : null,\n\t\ttype: isTypeString ? type : null,\n\t\tinterval: isIntervalString ? interval : null,\n\t}\n}\n\nexport function getReferralCodeFromParams(urlParams: Params): string | null {\n\tif (typeof urlParams.ref === \"string\") {\n\t\treturn urlParams.ref\n\t}\n\treturn null\n}\n\nexport function getRegistrationDataIdFromParams(hashParams: Params): string | null {\n\tif (typeof hashParams.token === \"string\") {\n\t\treturn hashParams.token\n\t}\n\treturn null\n}\n\nasync function loadRedeemGiftCardWizard(urlHash: string): Promise<Dialog> {\n\tconst wizard = await import(\"../subscription/giftcards/RedeemGiftCardWizard\")\n\treturn wizard.loadRedeemGiftCardWizard(urlHash)\n}\n\nexport async function showGiftCardDialog(urlHash: string) {\n\tshowProgressDialog(\"loading_msg\", loadRedeemGiftCardWizard(urlHash))\n\t\t.then((dialog) => dialog.show())\n\t\t.catch((e) => {\n\t\t\tif (e instanceof NotAuthorizedError || e instanceof NotFoundError) {\n\t\t\t\tthrow new UserError(\"invalidGiftCard_msg\")\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t})\n\t\t.catch(ofClass(UserError, showUserError))\n}\n\nexport async function showRecoverDialog(mailAddress: string, resetAction: ResetAction) {\n\tconst dialog = await import(\"../login/recover/RecoverLoginDialog\")\n\tdialog.show(mailAddress, resetAction)\n}\n\nexport type ExternalUserKeyDeriver = {\n\tkdfType: KdfType\n\tsalt: Uint8Array\n}\n","import m, { Children, Component, Vnode } from \"mithril\"\nimport stream from \"mithril/stream\"\nimport Stream from \"mithril/stream\"\nimport { liveDataAttrs } from \"../gui/AriaUtils\"\nimport { lang, TranslationKey } from \"../misc/LanguageViewModel.js\"\nimport { Autocomplete, TextField, TextFieldType } from \"../gui/base/TextField.js\"\nimport { Checkbox } from \"../gui/base/Checkbox.js\"\nimport { client } from \"../misc/ClientDetector.js\"\nimport { isApp, isDesktop, isOfflineStorageAvailable } from \"../api/common/Env\"\nimport { LoginButton } from \"../gui/base/buttons/LoginButton.js\"\nimport { PasswordField } from \"../misc/passwords/PasswordField.js\"\nimport { Keys } from \"../api/common/TutanotaConstants\"\nimport { useKeyHandler } from \"../misc/KeyManager.js\"\n\nexport type LoginFormAttrs = {\n\tonSubmit: (username: string, password: string) => unknown\n\tmailAddress: Stream<string>\n\tpassword: Stream<string>\n\tsavePassword?: Stream<boolean>\n\thelpText?: Vnode<any> | string\n\tinvalidCredentials?: boolean\n\tshowRecoveryOption?: boolean\n\taccessExpired?: boolean\n}\n\nexport class LoginForm implements Component<LoginFormAttrs> {\n\tmailAddressTextField!: HTMLInputElement\n\tpasswordTextField!: HTMLInputElement\n\t// When iOS does auto-filling (always in WebView as of iOS 12.2 and in older Safari)\n\t// it only sends one input/change event for all fields so we didn't know if fields\n\t// were updated. So we kindly ask our fields to update themselves with real DOM values.\n\tautofillUpdateHandler!: Stream<void>\n\n\toncreate(vnode: Vnode<LoginFormAttrs>) {\n\t\tconst a = vnode.attrs\n\t\tthis.autofillUpdateHandler = stream.combine(() => {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tconst oldAddress = a.mailAddress()\n\t\t\t\tconst newAddress = this.mailAddressTextField.value\n\t\t\t\tconst oldPassword = a.password()\n\t\t\t\tconst newPassword = this.passwordTextField.value\n\t\t\t\t// only update values when they are different or we get stuck in an infinite loop\n\t\t\t\tif (oldAddress !== newAddress && newAddress != \"\") a.mailAddress(newAddress)\n\t\t\t\tif (oldPassword !== newPassword && newPassword != \"\") a.password(newPassword)\n\t\t\t})\n\t\t}, [a.mailAddress, a.password])\n\t}\n\n\tonremove(vnode: Vnode<LoginFormAttrs>) {\n\t\tvnode.attrs.password(\"\")\n\t\tthis.autofillUpdateHandler.end(true)\n\t\tthis.passwordTextField.value = \"\"\n\t}\n\n\tview(vnode: Vnode<LoginFormAttrs>): Children {\n\t\tconst a = vnode.attrs\n\t\tconst canSaveCredentials = client.localStorage()\n\t\tif (a.savePassword && (isApp() || isDesktop())) {\n\t\t\ta.savePassword(true)\n\t\t}\n\t\treturn m(\n\t\t\t\"form\",\n\t\t\t{\n\t\t\t\tonsubmit: (e: SubmitEvent) => {\n\t\t\t\t\t// do not post the form, the form is just here to enable browser auto-fill\n\t\t\t\t\te.preventDefault() // a.onSubmit(a.mailAddress(), a.password())\n\t\t\t\t},\n\t\t\t},\n\t\t\t[\n\t\t\t\tm(\n\t\t\t\t\t\"\",\n\t\t\t\t\tm(TextField, {\n\t\t\t\t\t\tlabel: \"mailAddress_label\" as TranslationKey,\n\t\t\t\t\t\tvalue: a.mailAddress(),\n\t\t\t\t\t\toninput: a.mailAddress,\n\t\t\t\t\t\ttype: TextFieldType.Email,\n\t\t\t\t\t\tautocompleteAs: Autocomplete.email,\n\t\t\t\t\t\tonDomInputCreated: (dom) => {\n\t\t\t\t\t\t\tthis.mailAddressTextField = dom\n\t\t\t\t\t\t\tif (!client.isMobileDevice()) {\n\t\t\t\t\t\t\t\tdom.focus() // have email address auto-focus so the user can immediately type their username (unless on mobile)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeyHandler: (key) => {\n\t\t\t\t\t\t\tif (key.key != null && key.key.toLowerCase() === Keys.RETURN.code) {\n\t\t\t\t\t\t\t\ta.onSubmit(a.mailAddress(), a.password())\n\t\t\t\t\t\t\t\t// this is so that when \"Return\" is pressed, the user is logged in\n\t\t\t\t\t\t\t\t// and the password reveal button is not triggered\n\t\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t\tm(\n\t\t\t\t\t\"\",\n\t\t\t\t\tm(PasswordField, {\n\t\t\t\t\t\tvalue: a.password(),\n\t\t\t\t\t\toninput: a.password,\n\t\t\t\t\t\tautocompleteAs: Autocomplete.currentPassword,\n\t\t\t\t\t\tonDomInputCreated: (dom) => (this.passwordTextField = dom),\n\t\t\t\t\t\tkeyHandler: (key) => {\n\t\t\t\t\t\t\tif (key.key != null && key.key.toLowerCase() === Keys.RETURN.code) {\n\t\t\t\t\t\t\t\ta.onSubmit(a.mailAddress(), a.password())\n\t\t\t\t\t\t\t\t// this is so that when \"Return\" is pressed, the user is logged in\n\t\t\t\t\t\t\t\t// and the password reveal button is not triggered\n\t\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t\ta.savePassword\n\t\t\t\t\t? isApp() || isDesktop()\n\t\t\t\t\t\t? m(\"small.block.content-fg\", lang.get(\"dataWillBeStored_msg\"))\n\t\t\t\t\t\t: m(\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tonkeydown: (e: KeyboardEvent) => {\n\t\t\t\t\t\t\t\t\t\tuseKeyHandler(e, (key) => {\n\t\t\t\t\t\t\t\t\t\t\tif (key.key != null && key.key.toLowerCase() === Keys.RETURN.code) {\n\t\t\t\t\t\t\t\t\t\t\t\ta.onSubmit(a.mailAddress(), a.password())\n\t\t\t\t\t\t\t\t\t\t\t\t// this is so that when \"Return\" is pressed, the user is logged in\n\t\t\t\t\t\t\t\t\t\t\t\t// and the password reveal button is not triggered\n\t\t\t\t\t\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tm(Checkbox, {\n\t\t\t\t\t\t\t\t\tlabel: () => lang.get(\"storePassword_action\"),\n\t\t\t\t\t\t\t\t\tchecked: a.savePassword(),\n\t\t\t\t\t\t\t\t\tonChecked: a.savePassword,\n\t\t\t\t\t\t\t\t\thelpLabel: canSaveCredentials\n\t\t\t\t\t\t\t\t\t\t? lang.makeTranslation(\n\t\t\t\t\t\t\t\t\t\t\t\t\"onlyPrivateComputer_msg\",\n\t\t\t\t\t\t\t\t\t\t\t\tlang.get(\"onlyPrivateComputer_msg\") +\n\t\t\t\t\t\t\t\t\t\t\t\t\t(isOfflineStorageAvailable() ? \"\\n\" + lang.get(\"dataWillBeStored_msg\") : \"\"),\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t: \"functionNotSupported_msg\",\n\t\t\t\t\t\t\t\t\tdisabled: !canSaveCredentials,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t  )\n\t\t\t\t\t: null,\n\t\t\t\tm(\n\t\t\t\t\t\".pt\",\n\t\t\t\t\tm(LoginButton, {\n\t\t\t\t\t\tlabel: isApp() || isDesktop() ? \"addAccount_action\" : \"login_action\",\n\t\t\t\t\t\tonclick: () => a.onSubmit(a.mailAddress(), a.password()),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t\tm(\n\t\t\t\t\t\"p.center.statusTextColor.mt-s\",\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\t// browser reset\n\t\t\t\t\t\t\tmarginBottom: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tm(\"small\", liveDataAttrs(), [\n\t\t\t\t\t\ta.helpText ? a.helpText : null,\n\t\t\t\t\t\t\" \",\n\t\t\t\t\t\ta.invalidCredentials && a.showRecoveryOption\n\t\t\t\t\t\t\t? m(\n\t\t\t\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\thref: \"/recover\",\n\t\t\t\t\t\t\t\t\t\tonclick: (e: MouseEvent) => {\n\t\t\t\t\t\t\t\t\t\t\tm.route.set(\"/recover\", {\n\t\t\t\t\t\t\t\t\t\t\t\tmailAddress: a.mailAddress(),\n\t\t\t\t\t\t\t\t\t\t\t\tresetAction: \"password\",\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlang.get(\"recoverAccountAccess_action\"),\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t: a.accessExpired && a.accessExpired\n\t\t\t\t\t\t\t? m(\n\t\t\t\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// We import the dialog directly rather than redirecting to /recover here in order to not pass the password in plaintext via the URL\n\t\t\t\t\t\t\t\t\t\thref: \"#\",\n\t\t\t\t\t\t\t\t\t\tonclick: (e: MouseEvent) => {\n\t\t\t\t\t\t\t\t\t\t\timport(\"./recover/TakeOverDeletedAddressDialog.js\").then(({ showTakeOverDialog }) =>\n\t\t\t\t\t\t\t\t\t\t\t\tshowTakeOverDialog(a.mailAddress(), a.password()),\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlang.get(\"help_label\"),\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t],\n\t\t)\n\t}\n}\n","import m, { Children, Component, Vnode } from \"mithril\"\nimport { Button, ButtonType } from \"../gui/base/Button.js\"\nimport { LoginButton } from \"../gui/base/buttons/LoginButton.js\"\nimport { CredentialsInfo } from \"../native/common/generatedipc/CredentialsInfo.js\"\nimport { lang } from \"../misc/LanguageViewModel.js\"\n\nexport type CredentialsSelectorAttrs = {\n\tcredentials: ReadonlyArray<CredentialsInfo>\n\tonCredentialsSelected: (arg0: CredentialsInfo) => unknown\n\t// will show the delete options if this is provided\n\tonCredentialsDeleted?: ((arg0: CredentialsInfo) => void) | null\n}\n\nexport class CredentialsSelector implements Component<CredentialsSelectorAttrs> {\n\tview(vnode: Vnode<CredentialsSelectorAttrs>): Children {\n\t\tconst a = vnode.attrs\n\t\treturn a.credentials.map((c) => {\n\t\t\tconst buttons: Children = []\n\t\t\tconst onCredentialsDeleted = a.onCredentialsDeleted\n\t\t\tbuttons.push(\n\t\t\t\tm(LoginButton, {\n\t\t\t\t\tlabel: lang.makeTranslation(\"login_label\", c.login),\n\t\t\t\t\tonclick: () => a.onCredentialsSelected(c),\n\t\t\t\t}),\n\t\t\t)\n\n\t\t\tif (onCredentialsDeleted) {\n\t\t\t\tbuttons.push(\n\t\t\t\t\tm(Button, {\n\t\t\t\t\t\tlabel: \"delete_action\",\n\t\t\t\t\t\tclick: () => onCredentialsDeleted(c),\n\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn m(\".flex-space-between.pt.child-grow.last-child-fixed\", buttons)\n\t\t})\n\t}\n}\n","import { Vnode } from \"mithril\"\nimport { TopLevelAttrs } from \"../../TopLevelView.js\"\n\n/**\n * Base (utility) class for top-level components. Will handle URL updates for you automatically and will only call {@link onNewUrl} when necessary.\n */\nexport abstract class BaseTopLevelView {\n\tprivate lastPath: string = \"\"\n\n\toninit({ attrs }: Vnode<TopLevelAttrs>) {\n\t\tthis.lastPath = attrs.requestedPath\n\t\tthis.onNewUrl(attrs.args, attrs.requestedPath)\n\t}\n\n\tonbeforeupdate({ attrs }: Vnode<TopLevelAttrs>) {\n\t\t// onupdate() is called on every re-render but we don't want to call onNewUrl all the time\n\t\tif (this.lastPath !== attrs.requestedPath) {\n\t\t\tthis.lastPath = attrs.requestedPath\n\t\t\tthis.onNewUrl(attrs.args, attrs.requestedPath)\n\t\t}\n\t}\n\n\tprotected abstract onNewUrl(args: Record<string, any>, requestedPath: string): void\n}\n","import m, { Children, ClassComponent, Vnode } from \"mithril\"\nimport { AriaLandmarks, landmarkAttrs } from \"../AriaUtils.js\"\nimport { px, size, size as sizes } from \"../size.js\"\nimport { theme } from \"../theme.js\"\n\n/**\n * Base layout for the header in desktop layout.\n */\nexport class DesktopBaseHeader implements ClassComponent {\n\tview(vnode: Vnode): Children {\n\t\treturn m(\".header-nav.flex.items-center.rel\", [this.renderLogo(), vnode.children])\n\t}\n\n\tprivate renderLogo() {\n\t\treturn m(\n\t\t\t\".logo-height\",\n\t\t\t{\n\t\t\t\t...landmarkAttrs(AriaLandmarks.Banner, \"Tuta logo\"),\n\t\t\t\tstyle: {\n\t\t\t\t\t\"margin-left\": px(sizes.drawer_menu_width + size.hpad + size.hpad_button),\n\t\t\t\t},\n\t\t\t},\n\t\t\tm.trust(theme.logo),\n\t\t)\n\t}\n}\n","import { pureComponent } from \"./base/PureComponent.js\"\nimport { styles } from \"./styles.js\"\nimport m from \"mithril\"\nimport { DesktopBaseHeader } from \"./base/DesktopBaseHeader.js\"\nimport { AriaLandmarks, landmarkAttrs } from \"./AriaUtils.js\"\nimport { theme } from \"./theme.js\"\n\n/** Small header-like view for the login screens. */\nexport const LoginScreenHeader = pureComponent(() =>\n\tstyles.isDesktopLayout()\n\t\t? m(DesktopBaseHeader)\n\t\t: m(\n\t\t\t\t\".mt-l.flex.justify-center.mb\",\n\t\t\t\tm(\n\t\t\t\t\t\".logo.logo-height.mt-safe-inset\",\n\t\t\t\t\t{\n\t\t\t\t\t\t...landmarkAttrs(AriaLandmarks.Banner, \"Tuta Mail logo\"),\n\t\t\t\t\t},\n\t\t\t\t\tm.trust(theme.logo),\n\t\t\t\t),\n\t\t  ),\n)\n","import m, { Children, Vnode } from \"mithril\"\nimport { client } from \"../misc/ClientDetector.js\"\nimport { assertMainOrNode, isApp, isDesktop } from \"../api/common/Env\"\nimport { lang, TranslationKey, MaybeTranslation } from \"../misc/LanguageViewModel.js\"\nimport { defer, DeferredObject, mapNullable } from \"@tutao/tutanota-utils\"\nimport { BootIcons } from \"../gui/base/icons/BootIcons\"\nimport { showProgressDialog } from \"../gui/dialogs/ProgressDialog\"\nimport { windowFacade } from \"../misc/WindowFacade.js\"\nimport { DeviceType } from \"../misc/ClientConstants.js\"\nimport { Button, ButtonType } from \"../gui/base/Button.js\"\nimport { AriaLandmarks, landmarkAttrs, liveDataAttrs } from \"../gui/AriaUtils\"\nimport { DisplayMode, LoginState, LoginViewModel } from \"./LoginViewModel.js\"\nimport { LoginForm } from \"./LoginForm.js\"\nimport { CredentialsSelector } from \"./CredentialsSelector.js\"\nimport { getWhitelabelCustomizations } from \"../misc/WhitelabelCustomizations.js\"\nimport { createAsyncDropdown, DropdownButtonAttrs } from \"../gui/base/Dropdown.js\"\nimport type { ClickHandler } from \"../gui/base/GuiUtils\"\nimport { IconButton } from \"../gui/base/IconButton.js\"\nimport { BaseTopLevelView } from \"../gui/BaseTopLevelView.js\"\nimport { TopLevelAttrs, TopLevelView } from \"../../TopLevelView.js\"\nimport { LoginScreenHeader } from \"../gui/LoginScreenHeader.js\"\nimport { styles } from \"../gui/styles.js\"\nimport { locator } from \"../api/main/CommonLocator.js\"\nimport { renderInfoLinks } from \"../gui/RenderLoginInfoLinks.js\"\nimport { showSnackBar } from \"../gui/base/SnackBar.js\"\n\nassertMainOrNode()\n\nexport interface LoginViewAttrs extends TopLevelAttrs {\n\t/** Default path to redirect to after the login. Can be overridden with query param `requestedPath`. */\n\ttargetPath: string\n\tmakeViewModel: () => LoginViewModel\n}\n\n/** create a string provider that changes periodically until promise is resolved */\nfunction makeDynamicLoggingInMessage(promise: Promise<unknown>): () => TranslationKey {\n\tconst messageArray: Array<TranslationKey> = [\n\t\t\"dynamicLoginDecryptingMails_msg\",\n\t\t\"dynamicLoginOrganizingCalendarEvents_msg\",\n\t\t\"dynamicLoginSortingContacts_msg\",\n\t\t\"dynamicLoginUpdatingOfflineDatabase_msg\",\n\t\t\"dynamicLoginCyclingToWork_msg\",\n\t\t\"dynamicLoginRestockingTutaFridge_msg\",\n\t\t\"dynamicLoginPreparingRocketLaunch_msg\",\n\t\t\"dynamicLoginSwitchingOnPrivacy_msg\",\n\t]\n\tlet currentMessage: TranslationKey = \"login_msg\"\n\tlet messageIndex: number = 0\n\tconst messageIntervalId = setInterval(() => {\n\t\tcurrentMessage = messageArray[messageIndex]\n\t\tmessageIndex = ++messageIndex % 8\n\t\tm.redraw()\n\t}, 4000 /** spinner spins every 2s */)\n\tpromise.finally(() => clearInterval(messageIntervalId))\n\treturn () => currentMessage\n}\n\nexport class LoginView extends BaseTopLevelView implements TopLevelView<LoginViewAttrs> {\n\tprivate readonly viewModel: LoginViewModel\n\tprivate readonly defaultRedirect: string\n\tprivate readonly initPromise: Promise<void>\n\n\tprivate moreExpanded: boolean\n\t// we save the login form because we need access to the password input field inside of it for when \"loginWith\" is set in the url,\n\t// in order to focus it\n\tprivate loginForm: DeferredObject<LoginForm>\n\tprivate selectedRedirect: string\n\tprivate bottomMargin = 0\n\n\tconstructor({ attrs }: Vnode<LoginViewAttrs>) {\n\t\tsuper()\n\t\tthis.defaultRedirect = attrs.targetPath\n\t\tthis.selectedRedirect = this.defaultRedirect\n\n\t\tthis.loginForm = defer()\n\t\tthis.moreExpanded = false\n\t\tthis.viewModel = attrs.makeViewModel()\n\t\tthis.initPromise = this.viewModel.init().then(m.redraw)\n\t}\n\n\tkeyboardListener = (keyboardSize: number) => {\n\t\tthis.bottomMargin = keyboardSize\n\t\tm.redraw()\n\t}\n\n\tview({ attrs }: Vnode<LoginViewAttrs>) {\n\t\treturn m(\n\t\t\t\"#login-view.main-view.flex.col.nav-bg\",\n\t\t\t{\n\t\t\t\toncreate: () => windowFacade.addKeyboardSizeListener(this.keyboardListener),\n\t\t\t\tonremove: () => windowFacade.removeKeyboardSizeListener(this.keyboardListener),\n\t\t\t\tstyle: {\n\t\t\t\t\tmarginBottom: this.bottomMargin + \"px\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[\n\t\t\t\tm(LoginScreenHeader),\n\t\t\t\tm(\n\t\t\t\t\t\".flex-grow.flex-center.scroll\",\n\t\t\t\t\tm(\n\t\t\t\t\t\t\".flex.col.flex-grow-shrink-auto.max-width-m.plr-l.\" + (styles.isSingleColumnLayout() ? \"pt\" : \"pt-l\"),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...landmarkAttrs(AriaLandmarks.Main, isApp() || isDesktop() ? lang.get(\"addAccount_action\") : lang.get(\"login_label\")),\n\t\t\t\t\t\t\toncreate: (vnode) => {\n\t\t\t\t\t\t\t\t;(vnode.dom as HTMLElement).focus()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tm(\n\t\t\t\t\t\t\t\t\".content-bg.border-radius-big.pb\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tclass: styles.isSingleColumnLayout() ? \"plr-l\" : \"plr-2l\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tthis._renderFormForDisplayMode(),\n\t\t\t\t\t\t\t\tthis.renderMoreOptions(),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tm(\".flex-grow\"),\n\t\t\t\t\t\t\t!(isApp() || isDesktop()) && this.viewModel.shouldShowAppButtons() ? this._renderAppButtons() : null,\n\t\t\t\t\t\t\trenderInfoLinks(),\n\t\t\t\t\t\t],\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t],\n\t\t)\n\t}\n\n\tprivate _renderFormForDisplayMode(): Children {\n\t\tswitch (this.viewModel.displayMode) {\n\t\t\tcase DisplayMode.DeleteCredentials:\n\t\t\tcase DisplayMode.Credentials:\n\t\t\t\treturn this._renderCredentialsSelector()\n\t\t\tcase DisplayMode.Form:\n\t\t\t\treturn this._renderLoginForm()\n\t\t}\n\t}\n\n\tprivate renderMoreOptions(): Children {\n\t\treturn m(\".flex-center.flex-column\", [\n\t\t\tthis._loginAnotherLinkVisible()\n\t\t\t\t? m(Button, {\n\t\t\t\t\t\tlabel: \"loginOtherAccount_action\",\n\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t\tclick: () => {\n\t\t\t\t\t\t\tthis.viewModel.showLoginForm()\n\t\t\t\t\t\t},\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t\tthis._deleteCredentialsLinkVisible()\n\t\t\t\t? m(Button, {\n\t\t\t\t\t\tlabel: this.viewModel.displayMode === DisplayMode.DeleteCredentials ? \"cancel_action\" : \"removeAccount_action\",\n\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t\tclick: () => this._switchDeleteCredentialsState(),\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t\tthis._knownCredentialsLinkVisible()\n\t\t\t\t? m(Button, {\n\t\t\t\t\t\tlabel: \"knownCredentials_label\",\n\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t\tclick: () => this.viewModel.showCredentials(),\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t\tthis._signupLinkVisible()\n\t\t\t\t? m(Button, {\n\t\t\t\t\t\tlabel: \"register_label\",\n\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t\tclick: () => m.route.set(\"/signup\"),\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t\tthis._switchThemeLinkVisible()\n\t\t\t\t? m(Button, {\n\t\t\t\t\t\tlabel: \"switchColorTheme_action\",\n\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t\t\tclick: this.themeSwitchListener(),\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t\tthis._recoverLoginVisible()\n\t\t\t\t? m(Button, {\n\t\t\t\t\t\tlabel: \"recoverAccountAccess_action\",\n\t\t\t\t\t\tclick: () => {\n\t\t\t\t\t\t\tm.route.set(\"/recover\")\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttype: ButtonType.Secondary,\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t])\n\t}\n\n\tthemeSwitchListener(): ClickHandler {\n\t\treturn createAsyncDropdown({\n\t\t\tlazyButtons: async () => {\n\t\t\t\tconst defaultButtons: ReadonlyArray<DropdownButtonAttrs> = [\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"systemThemePref_label\",\n\t\t\t\t\t\tclick: () => locator.themeController.setThemePreference(\"auto:light|dark\"),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"light_label\",\n\t\t\t\t\t\tclick: () => locator.themeController.setThemePreference(\"light\"),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"dark_label\",\n\t\t\t\t\t\tclick: () => locator.themeController.setThemePreference(\"dark\"),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: client.isCalendarApp() ? \"light_red_label\" : \"light_blue_label\",\n\t\t\t\t\t\tclick: () => locator.themeController.setThemePreference(\"light_secondary\"),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: client.isCalendarApp() ? \"dark_red_label\" : \"dark_blue_label\",\n\t\t\t\t\t\tclick: () => locator.themeController.setThemePreference(\"dark_secondary\"),\n\t\t\t\t\t},\n\t\t\t\t]\n\t\t\t\tconst customButtons = (await locator.themeController.getCustomThemes()).map((themeId) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tlabel: lang.makeTranslation(themeId, themeId),\n\t\t\t\t\t\tclick: () => locator.themeController.setThemePreference(themeId),\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn defaultButtons.concat(customButtons)\n\t\t\t},\n\t\t\twidth: 300,\n\t\t})\n\t}\n\n\t_signupLinkVisible(): boolean {\n\t\treturn this.viewModel.displayMode === DisplayMode.Form && this.viewModel.shouldShowSignup()\n\t}\n\n\t_loginAnotherLinkVisible(): boolean {\n\t\treturn this.viewModel.displayMode === DisplayMode.Credentials || this.viewModel.displayMode === DisplayMode.DeleteCredentials\n\t}\n\n\t_deleteCredentialsLinkVisible(): boolean {\n\t\treturn this.viewModel.displayMode === DisplayMode.Credentials || this.viewModel.displayMode === DisplayMode.DeleteCredentials\n\t}\n\n\t_knownCredentialsLinkVisible(): boolean {\n\t\treturn this.viewModel.displayMode === DisplayMode.Form && this.viewModel.getSavedCredentials().length > 0\n\t}\n\n\t_switchThemeLinkVisible(): boolean {\n\t\treturn locator.themeController.shouldAllowChangingTheme()\n\t}\n\n\t_recoverLoginVisible(): boolean {\n\t\treturn this.viewModel.shouldShowRecover()\n\t}\n\n\t_renderLoginForm(): Children {\n\t\treturn m(\".flex.col.pb\", [\n\t\t\tm(LoginForm, {\n\t\t\t\toncreate: (vnode) => {\n\t\t\t\t\tconst form = vnode as Vnode<unknown, LoginForm>\n\t\t\t\t\tthis.loginForm.resolve(form.state)\n\t\t\t\t},\n\t\t\t\tonremove: () => {\n\t\t\t\t\t// we need to re-resolve this promise sometimes and for that we\n\t\t\t\t\t// need a new promise. otherwise, callbacks that are registered after\n\t\t\t\t\t// this point never get called because they have been registered after\n\t\t\t\t\t// it was resolved the first time.\n\t\t\t\t\tthis.loginForm = defer()\n\t\t\t\t},\n\t\t\t\tonSubmit: () => this._loginWithProgressDialog(),\n\t\t\t\tmailAddress: this.viewModel.mailAddress,\n\t\t\t\tpassword: this.viewModel.password,\n\t\t\t\tsavePassword: this.viewModel.savePassword,\n\t\t\t\thelpText: lang.getTranslationText(this.viewModel.helpText),\n\t\t\t\tinvalidCredentials: this.viewModel.state === LoginState.InvalidCredentials,\n\t\t\t\tshowRecoveryOption: this._recoverLoginVisible(),\n\t\t\t\taccessExpired: this.viewModel.state === LoginState.AccessExpired,\n\t\t\t}),\n\t\t])\n\t}\n\n\tasync _loginWithProgressDialog() {\n\t\tconst loginPromise = this.viewModel.login()\n\t\tconst dynamicMessage = makeDynamicLoggingInMessage(loginPromise)\n\t\tawait showProgressDialog(dynamicMessage, loginPromise)\n\n\t\tif (this.viewModel.state === LoginState.LoggedIn) {\n\t\t\tm.route.set(this.selectedRedirect)\n\t\t}\n\t}\n\n\t_renderCredentialsSelector(): Children {\n\t\treturn m(\".flex.col.pb-l\", [\n\t\t\tm(\n\t\t\t\t\".small.center.statusTextColor\",\n\t\t\t\t{\n\t\t\t\t\t...liveDataAttrs(),\n\t\t\t\t\tclass: styles.isSingleColumnLayout() ? \"\" : \"pt-xs\",\n\t\t\t\t},\n\t\t\t\tlang.getTranslationText(this.viewModel.helpText),\n\t\t\t),\n\t\t\tm(CredentialsSelector, {\n\t\t\t\tcredentials: this.viewModel.getSavedCredentials(),\n\t\t\t\tonCredentialsSelected: async (c) => {\n\t\t\t\t\tawait this.viewModel.useCredentials(c)\n\t\t\t\t\tawait this._loginWithProgressDialog()\n\t\t\t\t},\n\t\t\t\tonCredentialsDeleted:\n\t\t\t\t\tthis.viewModel.displayMode === DisplayMode.DeleteCredentials\n\t\t\t\t\t\t? (credentials) => {\n\t\t\t\t\t\t\t\tthis.viewModel.deleteCredentials(credentials).then((result) => {\n\t\t\t\t\t\t\t\t\tif (result == \"networkError\") {\n\t\t\t\t\t\t\t\t\t\tshowSnackBar({\n\t\t\t\t\t\t\t\t\t\t\tmessage: \"deleteCredentialOffline_msg\",\n\t\t\t\t\t\t\t\t\t\t\tbutton: {\n\t\t\t\t\t\t\t\t\t\t\t\tlabel: \"ok_action\",\n\t\t\t\t\t\t\t\t\t\t\t\tclick: () => {},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tm.redraw()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: null,\n\t\t\t}),\n\t\t])\n\t}\n\n\t_renderAppButtons(): Children {\n\t\treturn m(\".flex-center.pt-l.ml-between-s\", [\n\t\t\tclient.isDesktopDevice() || client.device === DeviceType.ANDROID\n\t\t\t\t? m(IconButton, {\n\t\t\t\t\t\ttitle: \"appInfoAndroidImageAlt_alt\",\n\t\t\t\t\t\tclick: (e) => {\n\t\t\t\t\t\t\tthis._openUrl(\"https://play.google.com/store/apps/details?id=de.tutao.tutanota\")\n\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t},\n\t\t\t\t\t\ticon: BootIcons.Android,\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t\tclient.isDesktopDevice() || client.device === DeviceType.IPAD || client.device === DeviceType.IPHONE\n\t\t\t\t? m(IconButton, {\n\t\t\t\t\t\ttitle: \"appInfoIosImageAlt_alt\",\n\t\t\t\t\t\tclick: (e) => {\n\t\t\t\t\t\t\tthis._openUrl(\"https://itunes.apple.com/app/tutanota/id922429609?mt=8&uo=4&at=10lSfb\")\n\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t},\n\t\t\t\t\t\ticon: BootIcons.Apple,\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t\tclient.isDesktopDevice() || client.device === DeviceType.ANDROID\n\t\t\t\t? m(IconButton, {\n\t\t\t\t\t\ttitle: \"appInfoFDroidImageAlt_alt\",\n\t\t\t\t\t\tclick: (e) => {\n\t\t\t\t\t\t\tthis._openUrl(\"https://f-droid.org/packages/de.tutao.tutanota/\")\n\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t},\n\t\t\t\t\t\ticon: BootIcons.FDroid,\n\t\t\t\t  })\n\t\t\t\t: null,\n\t\t])\n\t}\n\n\tonNewUrl(args: Record<string, any>, requestedPath: string) {\n\t\tif (args.requestedPath) {\n\t\t\tthis.selectedRedirect = args.requestedPath\n\t\t} else if (args.action) {\n\t\t\t// Action needs be forwarded this way in order to be able to deal with cases where a user is not logged in and clicks\n\t\t\t// on the support link on our website (https://app.tuta.com?action=supportMail)\n\t\t\tthis.selectedRedirect = `/mail?action=${args.action}`\n\t\t} else {\n\t\t\tthis.selectedRedirect = this.defaultRedirect\n\t\t}\n\t\tthis.handleLoginArguments(args, requestedPath)\n\t}\n\n\tprivate async handleLoginArguments(args: Record<string, any>, requestedPath: string) {\n\t\tawait this.initPromise\n\t\t// since we wait for something async here the URL might have already changed and\n\t\t// we shouldn't handle any outdated URL changes.\n\t\tif (m.route.get() !== requestedPath) return\n\n\t\tconst autoLogin = args.noAutoLogin == null || args.noAutoLogin === false\n\n\t\tif (autoLogin) {\n\t\t\tif (args.userId) {\n\t\t\t\tawait this.viewModel.useUserId(args.userId)\n\t\t\t}\n\n\t\t\tif (this.viewModel.canLogin()) {\n\t\t\t\tthis._loginWithProgressDialog()\n\n\t\t\t\tm.redraw()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif (args.loginWith) {\n\t\t\tthis.viewModel.showLoginForm()\n\t\t}\n\n\t\t// We want to focus password field if login field is already filled in\n\t\tif (args.loginWith) {\n\t\t\tthis.loginForm.promise.then((loginForm: LoginForm) => {\n\t\t\t\tloginForm.mailAddressTextField.value = \"\"\n\t\t\t\tloginForm.passwordTextField.value = \"\"\n\t\t\t\tthis.viewModel.mailAddress(args.loginWith ?? \"\")\n\t\t\t\tthis.viewModel.password(\"\")\n\t\t\t\tloginForm.passwordTextField.focus()\n\t\t\t})\n\t\t}\n\n\t\tm.redraw()\n\t}\n\n\t_openUrl(url: string) {\n\t\twindow.open(url, \"_blank\")\n\t}\n\n\t_switchDeleteCredentialsState(): void {\n\t\tthis.viewModel.switchDeleteState()\n\t}\n}\n\nexport function getWhitelabelRegistrationDomains(): string[] {\n\treturn mapNullable(getWhitelabelCustomizations(window), (c) => c.registrationDomains) || []\n}\n","import { AccessExpiredError, BadRequestError, NotAuthenticatedError } from \"../api/common/error/RestError\"\nimport { lang, MaybeTranslation } from \"../misc/LanguageViewModel.js\"\nimport { SecondFactorHandler } from \"../misc/2fa/SecondFactorHandler.js\"\nimport { getLoginErrorMessage, handleExpectedLoginError } from \"../misc/LoginUtils.js\"\nimport type { LoginController } from \"../api/main/LoginController\"\nimport stream from \"mithril/stream\"\nimport Stream from \"mithril/stream\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError\"\nimport type { CredentialsProvider } from \"../misc/credentials/CredentialsProvider.js\"\nimport { CredentialAuthenticationError } from \"../api/common/error/CredentialAuthenticationError\"\nimport { first, noOp } from \"@tutao/tutanota-utils\"\nimport { KeyPermanentlyInvalidatedError } from \"../api/common/error/KeyPermanentlyInvalidatedError\"\nimport { assertMainOrNode } from \"../api/common/Env\"\nimport { SessionType } from \"../api/common/SessionType\"\nimport { DeviceStorageUnavailableError } from \"../api/common/error/DeviceStorageUnavailableError\"\nimport { DeviceConfig } from \"../misc/DeviceConfig.js\"\nimport { getWhitelabelRegistrationDomains } from \"./LoginView.js\"\nimport { CancelledError } from \"../api/common/error/CancelledError.js\"\nimport { CredentialRemovalHandler } from \"./CredentialRemovalHandler.js\"\nimport { NativePushServiceApp } from \"../native/main/NativePushServiceApp.js\"\nimport { CredentialsInfo } from \"../native/common/generatedipc/CredentialsInfo.js\"\nimport { credentialsToUnencrypted } from \"../misc/credentials/Credentials.js\"\nimport { UnencryptedCredentials } from \"../native/common/generatedipc/UnencryptedCredentials.js\"\nimport { AppLock } from \"./AppLock.js\"\nimport { isOfflineError } from \"../api/common/utils/ErrorUtils.js\"\n\nassertMainOrNode()\n\n/**\n * Defines what the view should currently render.\n */\nexport const enum DisplayMode {\n\t/* Display the stored credentials */\n\tCredentials = \"credentials\",\n\n\t/* Display login form (username, password) */\n\tForm = \"form\",\n\n\t/* Display the stored credentials and options to delete them */\n\tDeleteCredentials = \"deleteCredentials\",\n}\n\n/**\n * Reflects which state the current login process has.\n */\nexport const enum LoginState {\n\t/* Log in in process. */\n\tLoggingIn = \"LoggingIn\",\n\n\t/* Some unknown error occured during login. */\n\tUnknownError = \"UnknownError\",\n\n\t/* The credentials used for the last login attempt where invalid (e.g. bad password). */\n\tInvalidCredentials = \"InvalidCredentials\",\n\n\t/* The access token used for login has expired. */\n\tAccessExpired = \"AccessExpired\",\n\n\t/* Default state - the user is not logged in nor has login been attempted yet. */\n\tNotAuthenticated = \"NotAuthenticated\",\n\n\t/* The user has successfully logged in. */\n\tLoggedIn = \"LoggedIn\",\n}\n\n/**\n * Interface for the view model used on the login page. There is no real technical reason for extracting an interface for the view model\n * other than making it easier to document its methods and for some additional checks when mocking this.\n */\nexport interface ILoginViewModel {\n\treadonly state: LoginState\n\treadonly displayMode: DisplayMode\n\treadonly mailAddress: Stream<string>\n\treadonly password: Stream<string>\n\treadonly helpText: MaybeTranslation\n\treadonly savePassword: Stream<boolean>\n\n\t/**\n\t * Checks whether the viewmodel is in a state where it can attempt to login. This depends on the current displayMode as well as\n\t * what data (email, password, userId, ...) has been set.\n\t */\n\tcanLogin(): boolean\n\n\t/**\n\t * Will tell the viewmodel to use a certain userId. If there are any stored credentials for that user-id on the device, it will\n\t * load those, set them as potential credentials for login and switch to DisplayMode.Credentials. This is useful in order to prepare\n\t * the viewmodel for an automatic login without user interaction.\n\t * @param userId\n\t */\n\tuseUserId(userId: string): Promise<void>\n\n\t/**\n\t * Instructs the viewmodel to use the credentials passed for the next login attempt. Changes displayMode to DisplayMode.Credentials.\n\t * @param credentials\n\t */\n\tuseCredentials(credentials: CredentialsInfo): Promise<void>\n\n\t/**\n\t * Returns all credentials stored on the device.\n\t */\n\tgetSavedCredentials(): ReadonlyArray<CredentialsInfo>\n\n\t/**\n\t * Attempts to log in. How the login will be performed (using stored credentials/using email and password) depends on the current\n\t * DisplayMode.\n\t */\n\tlogin(): Promise<void>\n\n\t/**\n\t * Deletes stored credentials from the device.\n\t * @param credentials\n\t */\n\tdeleteCredentials(credentials: CredentialsInfo): Promise<\"networkError\" | null>\n\n\t/**\n\t * Changes the display mode to DisplayMode.Form.\n\t */\n\tshowLoginForm(): void\n\n\t/**\n\t * Changes the display mode to DisplayMode.Credentials.\n\t */\n\tshowCredentials(): void\n\n\t/**\n\t * Toggles between DisplayMode.Credentials and DisplayMode.DeleteCredentials.\n\t */\n\tswitchDeleteState(): void\n}\n\nexport class LoginViewModel implements ILoginViewModel {\n\treadonly mailAddress: Stream<string>\n\treadonly password: Stream<string>\n\tdisplayMode: DisplayMode\n\tstate: LoginState\n\thelpText: MaybeTranslation\n\treadonly savePassword: Stream<boolean>\n\tprivate savedInternalCredentials: ReadonlyArray<CredentialsInfo>\n\n\t// visibleForTesting\n\tautoLoginCredentials: CredentialsInfo | null\n\n\tconstructor(\n\t\tprivate readonly loginController: LoginController,\n\t\tprivate readonly credentialsProvider: CredentialsProvider,\n\t\tprivate readonly secondFactorHandler: SecondFactorHandler,\n\t\tprivate readonly deviceConfig: DeviceConfig,\n\t\tprivate readonly domainConfig: DomainConfig,\n\t\tprivate readonly credentialRemovalHandler: CredentialRemovalHandler,\n\t\tprivate readonly pushServiceApp: NativePushServiceApp | null,\n\t\tprivate readonly appLock: AppLock,\n\t) {\n\t\tthis.state = LoginState.NotAuthenticated\n\t\tthis.displayMode = DisplayMode.Form\n\t\tthis.helpText = \"emptyString_msg\"\n\t\tthis.mailAddress = stream(\"\")\n\t\tthis.password = stream(\"\")\n\t\tthis.autoLoginCredentials = null\n\t\tthis.savePassword = stream(false)\n\t\tthis.savedInternalCredentials = []\n\t}\n\n\t/**\n\t * This method should be called right after creation of the view model by whoever created the viewmodel. The view model will not be\n\t * fully functional before this method has been called!\n\t * @returns {Promise<void>}\n\t */\n\tasync init(): Promise<void> {\n\t\tawait this.updateCachedCredentials()\n\t}\n\n\tasync useUserId(userId: string): Promise<void> {\n\t\tthis.autoLoginCredentials = await this.credentialsProvider.getCredentialsInfoByUserId(userId)\n\n\t\tif (this.autoLoginCredentials) {\n\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t} else {\n\t\t\tthis.displayMode = DisplayMode.Form\n\t\t}\n\t}\n\n\tcanLogin(): boolean {\n\t\tif (this.displayMode === DisplayMode.Credentials) {\n\t\t\treturn this.autoLoginCredentials != null || this.savedInternalCredentials.length === 1\n\t\t} else if (this.displayMode === DisplayMode.Form) {\n\t\t\treturn Boolean(this.mailAddress() && this.password())\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tasync useCredentials(encryptedCredentials: CredentialsInfo): Promise<void> {\n\t\tconst credentialsInfo = await this.credentialsProvider.getCredentialsInfoByUserId(encryptedCredentials.userId)\n\n\t\tif (credentialsInfo) {\n\t\t\tthis.autoLoginCredentials = credentialsInfo\n\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t}\n\t}\n\n\tasync login() {\n\t\tif (this.state === LoginState.LoggingIn) return\n\t\tthis.state = LoginState.LoggingIn\n\n\t\tif (this.displayMode === DisplayMode.Credentials || this.displayMode === DisplayMode.DeleteCredentials) {\n\t\t\tawait this.autologin()\n\t\t} else if (this.displayMode === DisplayMode.Form) {\n\t\t\tawait this.formLogin()\n\t\t} else {\n\t\t\tthrow new ProgrammingError(`Cannot login with current display mode: ${this.displayMode}`)\n\t\t}\n\t}\n\n\tasync deleteCredentials(credentialsInfo: CredentialsInfo): Promise<\"networkError\" | null> {\n\t\tlet credentials\n\n\t\ttry {\n\t\t\t/**\n\t\t\t * We have to decrypt the credentials here (and hence deal with any potential errors), because :LoginController.deleteOldSession\n\t\t\t * expects the full credentials. The reason for this is that the accessToken contained within credentials has a double function:\n\t\t\t * 1. It is used as an actual access token to re-authenticate\n\t\t\t * 2. It is used as a session ID\n\t\t\t * Since we want to also delete the session from the server, we need the (decrypted) accessToken in its function as a session id.\n\t\t\t */\n\t\t\tcredentials = await this.unlockAppAndGetCredentials(credentialsInfo.userId)\n\t\t} catch (e) {\n\t\t\tif (e instanceof KeyPermanentlyInvalidatedError) {\n\t\t\t\tawait this.credentialsProvider.clearCredentials(e)\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof CancelledError) {\n\t\t\t\t// ignore, happens if we have app pin activated and the user\n\t\t\t\t// cancels the prompt or provides a wrong password.\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof CredentialAuthenticationError) {\n\t\t\t\tthis.helpText = getLoginErrorMessage(e, false)\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof DeviceStorageUnavailableError) {\n\t\t\t\t// We want to allow deleting credentials even if keychain fails\n\t\t\t\tawait this.credentialsProvider.deleteByUserId(credentialsInfo.userId)\n\t\t\t\tawait this.credentialRemovalHandler.onCredentialsRemoved(credentialsInfo)\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tif (credentials) {\n\t\t\tawait this.credentialsProvider.deleteByUserId(credentials.credentialInfo.userId)\n\t\t\tawait this.credentialRemovalHandler.onCredentialsRemoved(credentials.credentialInfo)\n\t\t\tawait this.updateCachedCredentials()\n\t\t\ttry {\n\t\t\t\tawait this.loginController.deleteOldSession(credentials, (await this.pushServiceApp?.loadPushIdentifierFromNative()) ?? null)\n\t\t\t} catch (e) {\n\t\t\t\tif (isOfflineError(e)) {\n\t\t\t\t\treturn \"networkError\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\t/** @throws CredentialAuthenticationError */\n\tprivate async unlockAppAndGetCredentials(userId: Id): Promise<UnencryptedCredentials | null> {\n\t\tawait this.appLock.enforce()\n\t\treturn await this.credentialsProvider.getDecryptedCredentialsByUserId(userId)\n\t}\n\n\tgetSavedCredentials(): ReadonlyArray<CredentialsInfo> {\n\t\treturn this.savedInternalCredentials\n\t}\n\n\tswitchDeleteState() {\n\t\tif (this.displayMode === DisplayMode.DeleteCredentials) {\n\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t} else if (this.displayMode === DisplayMode.Credentials) {\n\t\t\tthis.displayMode = DisplayMode.DeleteCredentials\n\t\t} else {\n\t\t\tthrow new ProgrammingError(\"invalid state\")\n\t\t}\n\t}\n\n\tshowLoginForm() {\n\t\tthis.displayMode = DisplayMode.Form\n\t\tthis.helpText = \"emptyString_msg\"\n\t}\n\n\tshowCredentials() {\n\t\tthis.displayMode = DisplayMode.Credentials\n\t\tthis.helpText = \"emptyString_msg\"\n\t}\n\n\tshouldShowRecover(): boolean {\n\t\treturn this.domainConfig.firstPartyDomain\n\t}\n\n\tshouldShowSignup(): boolean {\n\t\treturn this.domainConfig.firstPartyDomain || getWhitelabelRegistrationDomains().length > 0\n\t}\n\n\tshouldShowAppButtons(): boolean {\n\t\treturn this.domainConfig.firstPartyDomain\n\t}\n\n\tprivate async updateCachedCredentials() {\n\t\tthis.savedInternalCredentials = await this.credentialsProvider.getInternalCredentialsInfos()\n\t\tthis.autoLoginCredentials = null\n\n\t\tif (this.savedInternalCredentials.length > 0) {\n\t\t\tif (this.displayMode !== DisplayMode.DeleteCredentials) {\n\t\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t\t}\n\t\t} else {\n\t\t\tthis.displayMode = DisplayMode.Form\n\t\t}\n\t}\n\n\tprivate async autologin(): Promise<void> {\n\t\tlet credentials: UnencryptedCredentials | null = null\n\t\ttry {\n\t\t\tif (this.autoLoginCredentials == null) {\n\t\t\t\tconst allCredentials = await this.credentialsProvider.getInternalCredentialsInfos()\n\t\t\t\tthis.autoLoginCredentials = first(allCredentials)\n\t\t\t}\n\n\t\t\t// we don't want to auto-login on the legacy domain, there's a banner\n\t\t\t// there to move people to the new domain.\n\t\t\tif (this.autoLoginCredentials) {\n\t\t\t\tcredentials = await this.unlockAppAndGetCredentials(this.autoLoginCredentials.userId)\n\n\t\t\t\tif (credentials) {\n\t\t\t\t\tconst offlineTimeRange = this.deviceConfig.getOfflineTimeRangeDays(this.autoLoginCredentials.userId)\n\t\t\t\t\tconst result = await this.loginController.resumeSession(credentials, null, offlineTimeRange)\n\t\t\t\t\tif (result.type == \"success\") {\n\t\t\t\t\t\tawait this.onLogin()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\t\t\tthis.helpText = \"offlineLoginPremiumOnly_msg\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthenticatedError && this.autoLoginCredentials) {\n\t\t\t\tconst autoLoginCredentials = this.autoLoginCredentials\n\t\t\t\tawait this.credentialsProvider.deleteByUserId(autoLoginCredentials.userId)\n\t\t\t\tif (credentials) {\n\t\t\t\t\tawait this.credentialRemovalHandler.onCredentialsRemoved(credentials.credentialInfo)\n\t\t\t\t}\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\tawait this.onLoginFailed(e)\n\t\t\t} else if (e instanceof KeyPermanentlyInvalidatedError) {\n\t\t\t\tawait this.credentialsProvider.clearCredentials(e)\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\tthis.helpText = \"credentialsKeyInvalidated_msg\"\n\t\t\t} else if (e instanceof DeviceStorageUnavailableError) {\n\t\t\t\t// The app already shows a dialog with FAQ link so we don't have to explain\n\t\t\t\t// much here, just catching it to avoid unexpected error dialog\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\tthis.helpText = lang.makeTranslation(\"help_text\", \"Could not access secret storage\")\n\t\t\t} else {\n\t\t\t\tawait this.onLoginFailed(e)\n\t\t\t}\n\t\t}\n\n\t\tif (this.state === LoginState.AccessExpired || this.state === LoginState.InvalidCredentials) {\n\t\t\tthis.displayMode = DisplayMode.Form\n\t\t\tthis.mailAddress(this.autoLoginCredentials?.login ?? \"\")\n\t\t}\n\t}\n\n\tprivate async formLogin(): Promise<void> {\n\t\tconst mailAddress = this.mailAddress()\n\t\tconst password = this.password()\n\t\tconst savePassword = this.savePassword()\n\n\t\tif (mailAddress === \"\" || password === \"\") {\n\t\t\tthis.state = LoginState.InvalidCredentials\n\t\t\tthis.helpText = \"loginFailed_msg\"\n\t\t\treturn\n\t\t}\n\n\t\tthis.helpText = \"login_msg\"\n\n\t\ttry {\n\t\t\tconst sessionType = savePassword ? SessionType.Persistent : SessionType.Login\n\n\t\t\tconst { credentials, databaseKey } = await this.loginController.createSession(mailAddress, password, sessionType)\n\t\t\tawait this.onLogin()\n\t\t\t// enforce app lock always, even if we don't access stored credentials\n\t\t\tawait this.appLock.enforce()\n\n\t\t\t// we don't want to have multiple credentials that\n\t\t\t// * share the same userId with different mail addresses (may happen if a user chooses a different alias to log in than the one they saved)\n\t\t\t// * share the same mail address (may happen if mail aliases are moved between users)\n\t\t\tconst storedCredentialsToDelete = this.savedInternalCredentials.filter((c) => c.login === mailAddress || c.userId === credentials.userId)\n\n\t\t\tfor (const credentialToDelete of storedCredentialsToDelete) {\n\t\t\t\tconst credentials = await this.credentialsProvider.getDecryptedCredentialsByUserId(credentialToDelete.userId)\n\n\t\t\t\tif (credentials) {\n\t\t\t\t\tawait this.loginController.deleteOldSession(credentials)\n\t\t\t\t\t// we handled the deletion of the offlineDb in createSession already\n\t\t\t\t\tawait this.credentialsProvider.deleteByUserId(credentials.credentialInfo.userId, { deleteOfflineDb: false })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (savePassword) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.credentialsProvider.store(credentialsToUnencrypted(credentials, databaseKey))\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof KeyPermanentlyInvalidatedError) {\n\t\t\t\t\t\tawait this.credentialsProvider.clearCredentials(e)\n\t\t\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\t\t} else if (e instanceof DeviceStorageUnavailableError || e instanceof CancelledError) {\n\t\t\t\t\t\tconsole.warn(\"will proceed with ephemeral credentials because device storage is unavailable:\", e)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof DeviceStorageUnavailableError) {\n\t\t\t\tconsole.warn(\"cannot log in: failed to get credentials from device storage\", e)\n\t\t\t}\n\t\t\tawait this.onLoginFailed(e)\n\t\t} finally {\n\t\t\tawait this.secondFactorHandler.closeWaitingForSecondFactorDialog()\n\t\t}\n\t}\n\n\tprivate async onLogin(): Promise<void> {\n\t\tthis.helpText = \"emptyString_msg\"\n\t\tthis.state = LoginState.LoggedIn\n\t}\n\n\tprivate async onLoginFailed(error: Error): Promise<void> {\n\t\tthis.helpText = getLoginErrorMessage(error, false)\n\n\t\tif (error instanceof BadRequestError || error instanceof NotAuthenticatedError) {\n\t\t\tthis.state = LoginState.InvalidCredentials\n\t\t} else if (error instanceof AccessExpiredError) {\n\t\t\tthis.state = LoginState.AccessExpired\n\t\t} else {\n\t\t\tthis.state = LoginState.UnknownError\n\t\t}\n\n\t\thandleExpectedLoginError(error, noOp)\n\t}\n}\n"],"mappings":"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"}