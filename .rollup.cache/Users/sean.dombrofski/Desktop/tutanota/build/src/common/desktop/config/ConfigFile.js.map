{"version":3,"file":"ConfigFile.js","sourceRoot":"","sources":["../../../../../src/common/desktop/config/ConfigFile.ts"],"names":[],"mappings":"AACA,OAAO,IAAI,MAAM,WAAW,CAAA;AAE5B,MAAM,SAAS,GAA+B,EAAE,CAAA;AAIhD;;;;GAIG;AACH,MAAM,UAAU,aAAa,CAAC,CAAS,EAAE,CAAS,EAAE,EAAa;IAChE,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;IAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;QAChD,SAAS,CAAC,QAAQ,CAAC,GAAG,IAAI,UAAU,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAA;IACtD,CAAC;IAED,OAAO,SAAS,CAAC,QAAQ,CAAC,CAAA;AAC3B,CAAC;AAID,MAAM,OAAO,UAAU;IAMO;IAAmC;IAAmC;IAL3F,aAAa,CAAc;IAEnC;;QAEI;IACJ,YAA6B,QAAgB,EAAmB,QAAgB,EAAmB,EAAa;QAAnF,aAAQ,GAAR,QAAQ,CAAQ;QAAmB,aAAQ,GAAR,QAAQ,CAAQ;QAAmB,OAAE,GAAF,EAAE,CAAW;QAC/G,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,OAAO,EAAE,CAAA;IACvC,CAAC;IAED,cAAc,CAAC,UAAe;QAC7B,IAAI,CAAC;YACJ,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;QAC1D,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,EAAE,CAAC,CAAA;QACxC,CAAC;QAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;IACzB,CAAC;IAED,QAAQ;QACP,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa;aACrC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;aAC5D,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aAC1B,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;YACZ,gDAAgD;YAChD,OAAO,CAAC,KAAK,CAAC,wBAAwB,EAAE,CAAC,CAAC,CAAA;QAC3C,CAAC,CAAC,CAAA;QACH,OAAO,IAAI,CAAC,aAAa,CAAA;IAC1B,CAAC;IAED;;;;;;;;OAQG;IACH,SAAS,CAAC,GAAQ;QACjB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa;aACrC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;aACtE,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;aACxC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;aAC/D,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;YACZ,OAAO,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC,CAAC,CAAA;QAC1C,CAAC,CAAC,CAAA;QACH,OAAO,IAAI,CAAC,aAAa,CAAA;IAC1B,CAAC;CACD","sourcesContent":["import type * as FsModule from \"node:fs\"\nimport path from \"node:path\"\n\nconst instances: Record<string, ConfigFile> = {}\n\ntype FsExports = typeof FsModule\n\n/**\n * get an instance of ConfigFile pointing at a certain path\n * @param p {string} path to file the configFile should write to\n * @param fs the fs object returned by \"import fs from ''fs\"\n */\nexport function getConfigFile(p: string, f: string, fs: FsExports): ConfigFile {\n\tconst fullpath = path.join(p, f)\n\tif (!Object.keys(instances).includes(fullpath)) {\n\t\tinstances[fullpath] = new ConfigFile(p, fullpath, fs)\n\t}\n\n\treturn instances[fullpath]\n}\n\nexport type ConfigFileType = ConfigFile\n\nexport class ConfigFile {\n\tprivate accessPromise: Promise<any>\n\n\t/**\n\t * @param filePath path to the file the json objects should be stored in\n\t **/\n\tconstructor(private readonly filePath: string, private readonly fullpath: string, private readonly fs: FsExports) {\n\t\tthis.accessPromise = Promise.resolve()\n\t}\n\n\tensurePresence(defaultObj: any): Promise<void> {\n\t\ttry {\n\t\t\tthis.fs.accessSync(this.fullpath, this.fs.constants.F_OK)\n\t\t} catch (e) {\n\t\t\treturn this.writeJSON(defaultObj || {})\n\t\t}\n\n\t\treturn Promise.resolve()\n\t}\n\n\treadJSON(): Promise<any> {\n\t\tthis.accessPromise = this.accessPromise\n\t\t\t.then(() => this.fs.promises.readFile(this.fullpath, \"utf8\"))\n\t\t\t.then((t) => JSON.parse(t))\n\t\t\t.catch((e) => {\n\t\t\t\t// catch needed to make future reads/writes work\n\t\t\t\tconsole.error(\"failed to read config!\", e)\n\t\t\t})\n\t\treturn this.accessPromise\n\t}\n\n\t/**\n\t * asynchronously write an object to a file.\n\t * multiple writes are handled in a fifo manner to prevent race conditions that could\n\t * cause the file to contain invalid json\n\t * deliberately not using async to make sure the chain of writes doesn't branch.\n\t *\n\t * @param obj the object to serialize\n\t * @returns {Promise<void>} resolves when the object has been written\n\t */\n\twriteJSON(obj: any): Promise<void> {\n\t\tthis.accessPromise = this.accessPromise\n\t\t\t.then(() => this.fs.promises.mkdir(this.filePath, { recursive: true }))\n\t\t\t.then(() => JSON.stringify(obj, null, 2))\n\t\t\t.then((json) => this.fs.promises.writeFile(this.fullpath, json))\n\t\t\t.catch((e) => {\n\t\t\t\tconsole.error(\"failed to write conf:\", e)\n\t\t\t})\n\t\treturn this.accessPromise\n\t}\n}\n"]}