{"version":3,"file":"UserFacade.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/facades/UserFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { GroupType } from \"../../common/TutanotaConstants\"\nimport { Aes256Key, AesKey, decryptKey } from \"@tutao/tutanota-crypto\"\nimport { assertNotNull, KeyVersion } from \"@tutao/tutanota-utils\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { createWebsocketLeaderStatus, GroupMembership, User, UserGroupKeyDistribution, WebsocketLeaderStatus } from \"../../entities/sys/TypeRefs\"\nimport { LoginIncompleteError } from \"../../common/error/LoginIncompleteError\"\nimport { isSameId } from \"../../common/utils/EntityUtils.js\"\nimport { KeyCache } from \"./KeyCache.js\"\nimport { CryptoWrapper, VersionedKey } from \"../crypto/CryptoWrapper.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { checkKeyVersionConstraints, parseKeyVersion } from \"./KeyLoaderFacade.js\"\n\nexport interface AuthDataProvider {\n\t/**\n\t * @return The map which contains authentication data for the logged-in user.\n\t */\n\tcreateAuthHeaders(): Dict\n\n\tisFullyLoggedIn(): boolean\n}\n\n/** Holder for the user and session-related data on the worker side. */\nexport class UserFacade implements AuthDataProvider {\n\tprivate user: User | null = null\n\tprivate accessToken: string | null = null\n\tprivate leaderStatus!: WebsocketLeaderStatus\n\n\tconstructor(private readonly keyCache: KeyCache, private readonly cryptoWrapper: CryptoWrapper) {\n\t\tthis.reset()\n\t}\n\n\t// Login process is somehow multi-step, and we don't use a separate network stack for it. So we have to break up setters.\n\t// 1. We need to download user. For that we need to set access token already (to authenticate the request for the server as it is passed in headers).\n\t// 2. We need to get group keys. For that we need to unlock userGroupKey with userPassphraseKey\n\t// so this leads to this steps in UserFacade:\n\t// 1. Access token is set\n\t// 2. User is set\n\t// 3. UserGroupKey is unlocked\n\tsetAccessToken(accessToken: string | null) {\n\t\tthis.accessToken = accessToken\n\t}\n\n\tgetAccessToken(): string | null {\n\t\treturn this.accessToken\n\t}\n\n\tsetUser(user: User) {\n\t\tif (this.accessToken == null) {\n\t\t\tthrow new ProgrammingError(\"invalid state: no access token\")\n\t\t}\n\t\tthis.user = user\n\t}\n\n\tunlockUserGroupKey(userPassphraseKey: AesKey) {\n\t\tif (this.user == null) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: no user\")\n\t\t}\n\t\tconst userGroupMembership = this.user.userGroup\n\t\tconst currentUserGroupKey = {\n\t\t\tversion: parseKeyVersion(userGroupMembership.groupKeyVersion),\n\t\t\tobject: decryptKey(userPassphraseKey, userGroupMembership.symEncGKey),\n\t\t}\n\t\tthis.keyCache.setCurrentUserGroupKey(currentUserGroupKey)\n\t\tthis.setUserDistKey(currentUserGroupKey.version, userPassphraseKey)\n\t}\n\n\tsetUserDistKey(currentUserGroupKeyVersion: KeyVersion, userPassphraseKey: AesKey) {\n\t\tif (this.user == null) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: no user\")\n\t\t}\n\t\t// Why this magic + 1? Because we don't have access to the new version number when calling this function so we compute it from the current one\n\t\tconst newUserGroupKeyVersion = checkKeyVersionConstraints(currentUserGroupKeyVersion + 1)\n\t\tconst userGroupMembership = this.user.userGroup\n\t\tconst legacyUserDistKey = this.deriveLegacyUserDistKey(userGroupMembership.group, userPassphraseKey)\n\t\tconst userDistKey = this.deriveUserDistKey(userGroupMembership.group, newUserGroupKeyVersion, userPassphraseKey)\n\t\tthis.keyCache.setLegacyUserDistKey(legacyUserDistKey)\n\t\tthis.keyCache.setUserDistKey(userDistKey)\n\t}\n\n\t/**\n\t * Derives a distribution key from the password key to share the new user group key of the user to their other clients (apps, web etc)\n\t * This is a fallback function that gets called when the output key of `deriveUserDistKey` fails to decrypt the new user group key\n\t * @deprecated\n\t * @param userGroupId user group id of the logged in user\n\t * @param userPasswordKey current password key of the user\n\t */\n\tderiveLegacyUserDistKey(userGroupId: Id, userPasswordKey: AesKey): AesKey {\n\t\t// we prepare a key to encrypt potential user group key rotations with\n\t\t// when passwords are changed clients are logged-out of other sessions\n\t\t// this key is only needed by the logged-in clients, so it should be reliable enough to assume that userPassphraseKey is in sync\n\n\t\t// we bind this to userGroupId and the domain separator userGroupKeyDistributionKey from crypto package\n\t\t// the hkdf salt does not have to be secret but should be unique per user and carry some additional entropy which sha256 ensures\n\n\t\treturn this.cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: userGroupId,\n\t\t\tkey: userPasswordKey,\n\t\t\tcontext: \"userGroupKeyDistributionKey\",\n\t\t})\n\t}\n\n\t/**\n\t * Derives a distribution to share the new user group key of the user to their other clients (apps, web etc)\n\t * @param userGroupId user group id of the logged in user\n\t * @param newUserGroupKeyVersion the new user group key version\n\t * @param userPasswordKey current password key of the user\n\t */\n\tderiveUserDistKey(userGroupId: Id, newUserGroupKeyVersion: KeyVersion, userPasswordKey: AesKey): Aes256Key {\n\t\treturn this.cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: `userGroup: ${userGroupId}, newUserGroupKeyVersion: ${newUserGroupKeyVersion}`,\n\t\t\tkey: userPasswordKey,\n\t\t\t// Formerly,this was not bound to the user group key version.\n\t\t\tcontext: \"versionedUserGroupKeyDistributionKey\",\n\t\t})\n\t}\n\n\tasync updateUser(user: User) {\n\t\tif (this.user == null) {\n\t\t\tthrow new ProgrammingError(\"Update user is called without logging in. This function is not for you.\")\n\t\t}\n\t\tthis.user = user\n\t\tawait this.keyCache.removeOutdatedGroupKeys(user)\n\t}\n\n\tgetUser(): User | null {\n\t\treturn this.user\n\t}\n\n\t/**\n\t * @return The map which contains authentication data for the logged-in user.\n\t */\n\tcreateAuthHeaders(): Dict {\n\t\treturn this.accessToken\n\t\t\t? {\n\t\t\t\t\taccessToken: this.accessToken,\n\t\t\t  }\n\t\t\t: {}\n\t}\n\n\tgetUserGroupId(): Id {\n\t\treturn this.getLoggedInUser().userGroup.group\n\t}\n\n\tgetAllGroupIds(): Id[] {\n\t\tlet groups = this.getLoggedInUser().memberships.map((membership) => membership.group)\n\t\tgroups.push(this.getLoggedInUser().userGroup.group)\n\t\treturn groups\n\t}\n\n\tgetCurrentUserGroupKey(): VersionedKey {\n\t\t// the userGroupKey is always written after the login to this.currentUserGroupKey\n\t\t//if the user has only logged in offline this has not happened\n\t\tconst currentUserGroupKey = this.keyCache.getCurrentUserGroupKey()\n\t\tif (currentUserGroupKey == null) {\n\t\t\tif (this.isPartiallyLoggedIn()) {\n\t\t\t\tthrow new LoginIncompleteError(\"userGroupKey not available\")\n\t\t\t} else {\n\t\t\t\tthrow new ProgrammingError(\"Invalid state: userGroupKey is not available\")\n\t\t\t}\n\t\t}\n\t\treturn currentUserGroupKey\n\t}\n\n\tgetMembership(groupId: Id): GroupMembership {\n\t\tlet membership = this.getLoggedInUser().memberships.find((g: GroupMembership) => isSameId(g.group, groupId))\n\n\t\tif (!membership) {\n\t\t\tthrow new Error(`No group with groupId ${groupId} found!`)\n\t\t}\n\n\t\treturn membership\n\t}\n\n\thasGroup(groupId: Id): boolean {\n\t\tif (!this.user) {\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn groupId === this.user.userGroup.group || this.user.memberships.some((m) => m.group === groupId)\n\t\t}\n\t}\n\n\tgetGroupId(groupType: GroupType): Id {\n\t\tif (groupType === GroupType.User) {\n\t\t\treturn this.getUserGroupId()\n\t\t} else {\n\t\t\tlet membership = this.getLoggedInUser().memberships.find((m) => m.groupType === groupType)\n\n\t\t\tif (!membership) {\n\t\t\t\tthrow new Error(\"could not find groupType \" + groupType + \" for user \" + this.getLoggedInUser()._id)\n\t\t\t}\n\n\t\t\treturn membership.group\n\t\t}\n\t}\n\n\tgetGroupIds(groupType: GroupType): Id[] {\n\t\treturn this.getLoggedInUser()\n\t\t\t.memberships.filter((m) => m.groupType === groupType)\n\t\t\t.map((gm) => gm.group)\n\t}\n\n\tisPartiallyLoggedIn(): boolean {\n\t\treturn this.user != null\n\t}\n\n\tisFullyLoggedIn(): boolean {\n\t\t// We have userGroupKey, and we can decrypt any other key - we are good to go\n\t\treturn this.keyCache.getCurrentUserGroupKey() != null\n\t}\n\n\tgetLoggedInUser(): User {\n\t\treturn assertNotNull(this.user)\n\t}\n\n\tsetLeaderStatus(status: WebsocketLeaderStatus) {\n\t\tthis.leaderStatus = status\n\t\tconsole.log(\"New leader status set:\", status.leaderStatus)\n\t}\n\n\tisLeader(): boolean {\n\t\treturn this.leaderStatus.leaderStatus\n\t}\n\n\treset() {\n\t\tthis.user = null\n\t\tthis.accessToken = null\n\t\tthis.keyCache.reset()\n\t\tthis.leaderStatus = createWebsocketLeaderStatus({\n\t\t\tleaderStatus: false,\n\t\t})\n\t}\n\n\tupdateUserGroupKey(userGroupKeyDistribution: UserGroupKeyDistribution) {\n\t\tconst userDistKey = this.keyCache.getUserDistKey()\n\t\tif (userDistKey == null) {\n\t\t\tconsole.log(\"could not update userGroupKey because distribution key is not available\")\n\t\t\treturn\n\t\t}\n\t\tlet newUserGroupKeyBytes\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tnewUserGroupKeyBytes = decryptKey(userDistKey, userGroupKeyDistribution.distributionEncUserGroupKey)\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof CryptoError) {\n\t\t\t\t\t// this might be due to old encryption with the legacy derivation of the distribution key\n\t\t\t\t\t// try with the legacy one instead\n\t\t\t\t\tconst legacyUserDistKey = this.keyCache.getLegacyUserDistKey()\n\t\t\t\t\tif (legacyUserDistKey == null) {\n\t\t\t\t\t\tconsole.log(\"could not update userGroupKey because old legacy distribution key is not available\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tnewUserGroupKeyBytes = decryptKey(legacyUserDistKey, userGroupKeyDistribution.distributionEncUserGroupKey)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// this may happen during offline storage synchronisation when the event queue contains user group key rotation and a password change.\n\t\t\t// We can ignore this error as we already have the latest user group key after connecting the offline client\n\t\t\tconsole.log(`Could not decrypt userGroupKeyUpdate`, e)\n\t\t\treturn\n\t\t}\n\t\tconst newUserGroupKey = {\n\t\t\tobject: newUserGroupKeyBytes,\n\t\t\tversion: parseKeyVersion(userGroupKeyDistribution.userGroupKeyVersion),\n\t\t}\n\t\tconsole.log(`updating userGroupKey. new version: ${userGroupKeyDistribution.userGroupKeyVersion}`)\n\t\tthis.keyCache.setCurrentUserGroupKey(newUserGroupKey)\n\t}\n}\n"]}