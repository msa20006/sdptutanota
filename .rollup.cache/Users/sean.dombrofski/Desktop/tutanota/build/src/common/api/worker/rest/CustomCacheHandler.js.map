{"version":3,"file":"CustomCacheHandler.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/rest/CustomCacheHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { ListElementEntity } from \"../../common/EntityTypes.js\"\nimport { CalendarEvent, CalendarEventTypeRef, Mail } from \"../../entities/tutanota/TypeRefs.js\"\nimport { freezeMap, getTypeId, TypeRef } from \"@tutao/tutanota-utils\"\nimport { CUSTOM_MAX_ID, CUSTOM_MIN_ID, firstBiggerThanSecond, getElementId, LOAD_MULTIPLE_LIMIT } from \"../../common/utils/EntityUtils.js\"\nimport { resolveTypeReference } from \"../../common/EntityFunctions.js\"\nimport { CacheStorage, ExposedCacheStorage, Range } from \"./DefaultEntityRestCache.js\"\nimport { EntityRestClient } from \"./EntityRestClient.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { EntityUpdate } from \"../../entities/sys/TypeRefs\"\n\n/**\n * update when implementing custom cache handlers.\n * add new types to the union when implementing new\n * custom cache handlers.\n */\ntype CustomCacheHandledType = never | CalendarEvent | Mail\n\n/**\n * makes sure that any {ref<A>, handler<A>} pair passed to\n * the constructor uses the same A for both props and that they\n * are types for which we actually do custom handling.\n */\ntype CustomCacheHandlerMapping = CustomCacheHandledType extends infer A\n\t? A extends ListElementEntity\n\t\t? { ref: TypeRef<A>; handler: CustomCacheHandler<A> }\n\t\t: never\n\t: never\n\n/**\n * wrapper for a TypeRef -> CustomCacheHandler map that's needed because we can't\n * use TypeRefs directly as map keys due to object identity not matching.\n *\n * it is mostly read-only\n */\nexport class CustomCacheHandlerMap {\n\tprivate readonly handlers: ReadonlyMap<string, CustomCacheHandler<ListElementEntity>>\n\n\tconstructor(...args: ReadonlyArray<CustomCacheHandlerMapping>) {\n\t\tconst handlers: Map<string, CustomCacheHandler<ListElementEntity>> = new Map()\n\t\tfor (const { ref, handler } of args) {\n\t\t\tconst key = getTypeId(ref)\n\t\t\thandlers.set(key, handler)\n\t\t}\n\t\tthis.handlers = freezeMap(handlers)\n\t}\n\n\tget<T extends ListElementEntity>(typeRef: TypeRef<T>): CustomCacheHandler<T> | undefined {\n\t\tconst typeId = getTypeId(typeRef)\n\t\t// map is frozen after the constructor. constructor arg types are set up to uphold this invariant.\n\t\treturn this.handlers.get(typeId) as CustomCacheHandler<T> | undefined\n\t}\n}\n\n/**\n * Some types are not cached like other types, for example because their custom Ids are not sortable.\n * make sure to update CustomHandledType when implementing this for a new type.\n */\nexport interface CustomCacheHandler<T extends ListElementEntity> {\n\tloadRange?: (storage: ExposedCacheStorage, listId: Id, start: Id, count: number, reverse: boolean) => Promise<T[]>\n\n\tgetElementIdsInCacheRange?: (storage: ExposedCacheStorage, listId: Id, ids: Array<Id>) => Promise<Array<Id>>\n\n\tshouldLoadOnCreateEvent?: (event: EntityUpdate) => Promise<boolean>\n}\n\n/**\n * implements range loading in JS because the custom Ids of calendar events prevent us from doing\n * this effectively in the database.\n */\nexport class CustomCalendarEventCacheHandler implements CustomCacheHandler<CalendarEvent> {\n\tconstructor(private readonly entityRestClient: EntityRestClient) {}\n\n\tasync loadRange(storage: CacheStorage, listId: Id, start: Id, count: number, reverse: boolean): Promise<CalendarEvent[]> {\n\t\tconst range = await storage.getRangeForList(CalendarEventTypeRef, listId)\n\n\t\t//if offline db for this list is empty load from server\n\t\tlet rawList: Array<CalendarEvent> = []\n\t\tif (range == null) {\n\t\t\tlet chunk: Array<CalendarEvent> = []\n\t\t\tlet currentMin = CUSTOM_MIN_ID\n\t\t\twhile (true) {\n\t\t\t\tchunk = await this.entityRestClient.loadRange(CalendarEventTypeRef, listId, currentMin, LOAD_MULTIPLE_LIMIT, false)\n\t\t\t\trawList.push(...chunk)\n\t\t\t\tif (chunk.length < LOAD_MULTIPLE_LIMIT) break\n\t\t\t\tcurrentMin = getElementId(chunk[chunk.length - 1])\n\t\t\t}\n\t\t\tfor (const event of rawList) {\n\t\t\t\tawait storage.put(event)\n\t\t\t}\n\n\t\t\t// we have all events now\n\t\t\tawait storage.setNewRangeForList(CalendarEventTypeRef, listId, CUSTOM_MIN_ID, CUSTOM_MAX_ID)\n\t\t} else {\n\t\t\tthis.assertCorrectRange(range)\n\t\t\trawList = await storage.getWholeList(CalendarEventTypeRef, listId)\n\t\t\tconsole.log(`CalendarEvent list ${listId} has ${rawList.length} events`)\n\t\t}\n\t\tconst typeModel = await resolveTypeReference(CalendarEventTypeRef)\n\t\tconst sortedList = reverse\n\t\t\t? rawList\n\t\t\t\t\t.filter((calendarEvent) => firstBiggerThanSecond(start, getElementId(calendarEvent), typeModel))\n\t\t\t\t\t.sort((a, b) => (firstBiggerThanSecond(getElementId(b), getElementId(a), typeModel) ? 1 : -1))\n\t\t\t: rawList\n\t\t\t\t\t.filter((calendarEvent) => firstBiggerThanSecond(getElementId(calendarEvent), start, typeModel))\n\t\t\t\t\t.sort((a, b) => (firstBiggerThanSecond(getElementId(a), getElementId(b), typeModel) ? 1 : -1))\n\t\treturn sortedList.slice(0, count)\n\t}\n\n\tprivate assertCorrectRange(range: Range) {\n\t\tif (range.lower !== CUSTOM_MIN_ID || range.upper !== CUSTOM_MAX_ID) {\n\t\t\tthrow new ProgrammingError(`Invalid range for CalendarEvent: ${JSON.stringify(range)}`)\n\t\t}\n\t}\n\n\tasync getElementIdsInCacheRange(storage: CacheStorage, listId: Id, ids: Array<Id>): Promise<Array<Id>> {\n\t\tconst range = await storage.getRangeForList(CalendarEventTypeRef, listId)\n\t\tif (range) {\n\t\t\tthis.assertCorrectRange(range)\n\t\t\t// assume none of the given Ids are already cached to make sure they are loaded now\n\t\t\treturn ids\n\t\t} else {\n\t\t\treturn []\n\t\t}\n\t}\n}\n\nexport class CustomMailEventCacheHandler implements CustomCacheHandler<Mail> {\n\tasync shouldLoadOnCreateEvent(): Promise<boolean> {\n\t\t// New emails should be pre-cached.\n\t\t//  - we need them to display the folder contents\n\t\t//  - will very likely be loaded by indexer later\n\t\t//  - we might have the instance in offline cache already because of notification process\n\t\treturn true\n\t}\n}\n"]}