{"version":3,"file":"PasswordGenerator.js","sourceRoot":"","sources":["../../../../../src/common/misc/passwords/PasswordGenerator.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,sBAAsB,CAAA;AACvD,OAAO,EAAE,MAAM,EAAE,MAAM,uBAAuB,CAAA;AAG9C,gBAAgB,EAAE,CAAA;AAElB,qBAAqB;AACrB,+CAA+C;AAC/C,MAAM,CAAC,MAAM,eAAe,GAAW,CAAC,CAAA;AACxC,MAAM,CAAC,MAAM,UAAU,GAAW,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,CAAA;AAElE,MAAM,OAAO,iBAAiB;IACT;IAAsC;IAA1D,YAAoB,UAA4B,EAAU,UAAyB;QAA/D,eAAU,GAAV,UAAU,CAAkB;QAAU,eAAU,GAAV,UAAU,CAAe;IAAG,CAAC;IAEvF,KAAK,CAAC,wBAAwB;QAC7B,MAAM,SAAS,GAAG,IAAI,GAAG,EAAE,CAAA;QAE3B,OAAO,SAAS,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;YAC3B,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,4BAA4B,EAAE,CAAA;YACtD,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QACpB,CAAC;QAED,OAAO,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;IACvC,CAAC;IAED,KAAK,CAAC,4BAA4B;QACjC,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAA;QACrC,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,2BAA2B,CAAC,MAAM,CAAC,CAAC,CAAA;IACvE,CAAC;IAED,2HAA2H;IAC3H,yHAAyH;IACzH,oJAAoJ;IACpJ,0HAA0H;IAC1H,KAAK,CAAC,2BAA2B,CAAC,KAAa;QAC9C,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,8BAA8B,CAAC,CAAA;QACjD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAA;QAC9E,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,UAAU,GAAG,UAAU,CAAC,GAAG,KAAK,CAAC,CAAA;IACrD,CAAC;CACD","sourcesContent":["import { assertMainOrNode } from \"../../api/common/Env\"\nimport { assert } from \"@tutao/tutanota-utils\"\nimport { WorkerRandomizer } from \"../../api/worker/workerInterfaces.js\"\n\nassertMainOrNode()\n\n// exported for tests\n// size of dictionary is within the 2Byte range\nexport const NUMBER_OF_BYTES: number = 2\nexport const BYTE_RANGE: number = Math.pow(2, 8 * NUMBER_OF_BYTES)\n\nexport class PasswordGenerator {\n\tconstructor(private randomizer: WorkerRandomizer, private dictionary: Array<string>) {}\n\n\tasync generateRandomPassphrase(): Promise<string> {\n\t\tconst usedWords = new Set()\n\n\t\twhile (usedWords.size < 6) {\n\t\t\tconst word = await this.pickRandomWordFromDictionary()\n\t\t\tusedWords.add(word)\n\t\t}\n\n\t\treturn Array.from(usedWords).join(\" \")\n\t}\n\n\tasync pickRandomWordFromDictionary(): Promise<string> {\n\t\tconst length = this.dictionary.length\n\t\treturn this.dictionary[await this.generateRandomNumberInRange(length)]\n\t}\n\n\t// The Randomizer generates a number within range := {0, ..., BYTE_RANGE - 1} (1Byte -> {0, ..., 255} for BYTE_RANGE = 256)\n\t// To scale the number n to our desired range, we can divide n by the BYTE_RANGE, resulting in a number n with 0 <= n < 1\n\t// @param 'range' is the length of the dictionary. Multiplying the above number by the range will result in a number in range := {0, ..., range - 1}\n\t// This is necessary to keep the distribution of numbers even, as well as ensuring that we do not access any invalid Index\n\tasync generateRandomNumberInRange(range: number): Promise<number> {\n\t\tassert(range > 0, \"range must be greater than 0\")\n\t\tconst byteNumber = await this.randomizer.generateRandomNumber(NUMBER_OF_BYTES)\n\t\treturn Math.floor((byteNumber / BYTE_RANGE) * range)\n\t}\n}\n"]}