{"version":3,"file":"SseClient.js","sourceRoot":"","sources":["../../../../../src/common/desktop/sse/SseClient.ts"],"names":[],"mappings":"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","sourcesContent":["import http from \"node:http\"\nimport type { DesktopNetworkClient } from \"../net/DesktopNetworkClient\"\nimport { makeTaggedLogger } from \"../DesktopLog\"\nimport { Scheduler } from \"../../api/common/utils/Scheduler.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\nimport { reverse } from \"../../api/common/TutanotaConstants.js\"\n\nconst log = makeTaggedLogger(\"[SSE]\")\n\n/**\n * Provides computed delays for SSE (in ms)\n */\nexport interface SseDelay {\n\treconnectDelay(attempt: number): number\n\n\tinitialConnectionDelay(): number\n}\n\nexport interface SseEventHandler {\n\tonNewMessage: (message: string) => unknown\n\tonNotAuthenticated: () => unknown\n}\n\nexport interface SseConnectOptions {\n\turl: URL\n\theaders: Record<string, string | undefined>\n}\n\nexport enum ConnectionState {\n\t/** Not connecting or trying to connect. */\n\tdisconnected,\n\t/** Will try to reconnect after timeout. */\n\tdelayedReconnect,\n\t/** Started the connection. */\n\tconnecting,\n\t/** Received the response, connection is usable. */\n\tconnected,\n}\n\n/**\n *   +--------------+                              +-------------+\n *   | Disconnected |                              |  Connecting |\n *   +-------^------+ ----------connect-------->   +----+--------+\n *           |                                  | ^     |\n *           |        +-----------error---------+ |     |\n *           |        |                           |     response\n *       disconnect   |                           |     |\n *           |        v ----------timeout---------+     v\n * +---------+---------+                           +--------------+\n * | DelayedConnecting |<---------close------------+   Connected  |\n * +-------------------+          error            +--------------+\n */\ntype State =\n\t| { state: ConnectionState.disconnected }\n\t| { state: ConnectionState.connecting; options: SseConnectOptions; attempt: number; connection: http.ClientRequest }\n\t| { state: ConnectionState.delayedReconnect; options: SseConnectOptions; attempt: number; timeout: NodeJS.Timeout }\n\t| { state: ConnectionState.connected; options: SseConnectOptions; connection: http.ClientRequest; receivedHeartbeat: boolean }\n\n/**\n * Generic Server Sent Events client.\n * Does automatically reconnect.\n */\nexport class SseClient {\n\tprivate listener: SseEventHandler | null = null\n\tprivate _state: State = { state: ConnectionState.disconnected }\n\tprivate readTimeoutSec: number | null = null\n\tprivate heartBeatListenerHandle: NodeJS.Timeout | undefined = undefined\n\n\tprivate set state(newState: State) {\n\t\tconst stateName = reverse(ConnectionState)[newState.state]\n\t\tlog.debug(\"state:\", stateName)\n\t\tthis._state = newState\n\t}\n\n\tprivate get state(): State {\n\t\treturn this._state\n\t}\n\n\tconstructor(private readonly net: DesktopNetworkClient, private readonly delay: SseDelay, private readonly scheduler: Scheduler) {}\n\n\tasync connect(options: SseConnectOptions) {\n\t\tlog.debug(\"connect\")\n\t\tswitch (this.state.state) {\n\t\t\tcase ConnectionState.delayedReconnect:\n\t\t\t\tthis.scheduler.unscheduleTimeout(this.state.timeout)\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.connecting:\n\t\t\tcase ConnectionState.connected:\n\t\t\t\tawait this.disconnect()\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.disconnected:\n\t\t\t\tbreak\n\t\t\t// go on with connection\n\t\t}\n\t\tthis.doConnect(options)\n\t}\n\n\tprivate doConnect(options: SseConnectOptions) {\n\t\tlet attempt: number\n\t\tswitch (this.state.state) {\n\t\t\tcase ConnectionState.disconnected:\n\t\t\t\tattempt = 1\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.delayedReconnect:\n\t\t\t\tattempt = this.state.attempt\n\t\t\t\t// go on with connection\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.connecting:\n\t\t\tcase ConnectionState.connected:\n\t\t\t\tthrow new ProgrammingError(\"Invalid state: already connecting\")\n\t\t}\n\n\t\tconst { url, headers } = options\n\n\t\tconst connection = this.net.request(url, {\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\tConnection: \"Keep-Alive\",\n\t\t\t\t\"Keep-Alive\": \"header\",\n\t\t\t\tAccept: \"text/event-stream\",\n\t\t\t\t...headers,\n\t\t\t},\n\t\t\tmethod: \"GET\",\n\t\t})\n\t\tconnection\n\t\t\t.on(\"socket\", (s) => {\n\t\t\t\t// We add this listener purely as a workaround for some problem with net module.\n\t\t\t\t// The problem is that sometimes request gets stuck after handshake - does not process unless some event\n\t\t\t\t// handler is called (and it works more reliably with console.log()).\n\t\t\t\t// This makes the request magically unstuck, probably console.log does some I/O and/or socket things.\n\t\t\t\ts.on(\"lookup\", () => log.debug(\"lookup\"))\n\t\t\t})\n\t\t\t.on(\"response\", async (res) => {\n\t\t\t\tlog.debug(\"established SSE connection with code\", res.statusCode)\n\t\t\t\tthis.state = { state: ConnectionState.connected, connection, options, receivedHeartbeat: false }\n\t\t\t\tthis.resetHeartbeatListener()\n\n\t\t\t\tif (res.statusCode === 403 || res.statusCode === 401) {\n\t\t\t\t\tawait this.listener?.onNotAuthenticated()\n\t\t\t\t\tawait this.disconnect()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tres.setEncoding(\"utf8\")\n\t\t\t\tlet resData = \"\"\n\t\t\t\tres.on(\"data\", (d) => {\n\t\t\t\t\t// add new data to the buffer\n\t\t\t\t\tresData += d\n\t\t\t\t\tconst lines = resData.split(\"\\n\")\n\t\t\t\t\tresData = lines.pop() ?? \"\" // put the last line back into the buffer\n\n\t\t\t\t\tfor (const l of lines) {\n\t\t\t\t\t\tconst trimmedLine = l.trim()\n\t\t\t\t\t\tif (trimmedLine === \"\") {\n\t\t\t\t\t\t\tlog.debug(\"heartbeat\")\n\t\t\t\t\t\t\tthis.onHeartbeat()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.listener?.onNewMessage(trimmedLine)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t\t.on(\"close\", () => {\n\t\t\t\t\t\tlog.debug(\"response closed\")\n\t\t\t\t\t\t// This event is fired also when we close the connection manually. In this case we do not want to reconnect.\n\t\t\t\t\t\tif (this.state.state != ConnectionState.disconnected) this.delayedReconnect()\n\t\t\t\t\t})\n\t\t\t\t\t.on(\"error\", (e) => {\n\t\t\t\t\t\tlog.error(\"response error:\", e)\n\t\t\t\t\t\t// This event is fired also when we close the connection manually. In this case we do not want to reconnect.\n\t\t\t\t\t\tif (this.state.state != ConnectionState.disconnected) this.delayedReconnect()\n\t\t\t\t\t})\n\t\t\t})\n\t\t\t.on(\"information\", () => log.debug(\"information\"))\n\t\t\t.on(\"connect\", () => log.debug(\"connect:\"))\n\t\t\t.on(\"error\", (e) => {\n\t\t\t\tlog.error(\"error:\", e.message)\n\t\t\t\tif (this.state.state === ConnectionState.connecting) {\n\t\t\t\t\tthis.exponentialBackoffReconnect()\n\t\t\t\t}\n\t\t\t})\n\t\t\t.end()\n\t\tthis.state = { state: ConnectionState.connecting, connection, attempt, options }\n\t}\n\n\tasync disconnect() {\n\t\tconst state = this.state\n\t\tswitch (state.state) {\n\t\t\tcase ConnectionState.delayedReconnect:\n\t\t\t\tthis.scheduler.unscheduleTimeout(state.timeout)\n\t\t\t\tthis.state = { state: ConnectionState.disconnected }\n\t\t\t\tbreak\n\t\t\tcase ConnectionState.connected:\n\t\t\tcase ConnectionState.connecting:\n\t\t\t\treturn new Promise<void>((resolve) => {\n\t\t\t\t\tstate.connection.once(\"close\", () => {\n\t\t\t\t\t\tthis.state = { state: ConnectionState.disconnected }\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t})\n\t\t\t\t\tstate.connection.destroy()\n\t\t\t\t})\n\t\t}\n\t}\n\n\tsetEventListener(listener: SseEventHandler) {\n\t\tthis.listener = listener\n\t}\n\n\tsetReadTimeout(timeoutSeconds: number) {\n\t\tthis.readTimeoutSec = timeoutSeconds\n\t\tthis.resetHeartbeatListener()\n\t\tthis.onHeartbeat()\n\t}\n\n\tprivate exponentialBackoffReconnect() {\n\t\tif (this.state.state != ConnectionState.connecting) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: not connecting\")\n\t\t}\n\t\tlog.debug(\"Scheduling exponential reconnect\")\n\t\tconst timeout = this.scheduler.scheduleAfter(() => this.retryConnect(), this.delay.reconnectDelay(this.state.attempt))\n\t\tthis.state = { state: ConnectionState.delayedReconnect, attempt: this.state.attempt + 1, options: this.state.options, timeout }\n\t}\n\n\tprivate delayedReconnect() {\n\t\tif (this.state.state != ConnectionState.connected) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: not connected\")\n\t\t}\n\t\tlog.debug(\"Scheduling delayed reconnect\")\n\t\tconst timeout = this.scheduler.scheduleAfter(() => this.retryConnect(), this.delay.initialConnectionDelay())\n\t\tthis.state = { state: ConnectionState.delayedReconnect, attempt: 0, options: this.state.options, timeout }\n\t}\n\n\tprivate async retryConnect() {\n\t\tif (this.state.state !== ConnectionState.delayedReconnect) {\n\t\t\tthrow new ProgrammingError(\"Invalid state: not in delayed reconnect\")\n\t\t}\n\t\tthis.doConnect(this.state.options)\n\t}\n\n\tprivate onHeartbeat() {\n\t\tif (this.state.state === ConnectionState.connected) {\n\t\t\tthis.state = { ...this.state, receivedHeartbeat: true }\n\t\t}\n\t}\n\n\tprivate resetHeartbeatListener() {\n\t\t// It will check if the heartbeat was received periodically.\n\t\t// Theoretically we need to reset this every time we connect but\n\t\t// the server will send us the timeout right after the connection anyway.\n\t\tif (this.heartBeatListenerHandle != null) this.scheduler.unschedulePeriodic(this.heartBeatListenerHandle)\n\t\tthis.heartBeatListenerHandle = this.scheduler.schedulePeriodic(async () => {\n\t\t\tconst state = this.state\n\t\t\tif (state.state === ConnectionState.connected) {\n\t\t\t\tif (state.receivedHeartbeat) {\n\t\t\t\t\tthis.state = { ...state, receivedHeartbeat: false }\n\t\t\t\t} else {\n\t\t\t\t\tawait this.disconnect()\n\t\t\t\t\tthis.doConnect(state.options)\n\t\t\t\t}\n\t\t\t}\n\t\t}, Math.floor(this.readTimeoutSec! * 1.2 * 1000))\n\t}\n}\n"]}