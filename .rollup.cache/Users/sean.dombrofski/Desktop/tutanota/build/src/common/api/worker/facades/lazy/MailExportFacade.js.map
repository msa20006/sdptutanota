{"version":3,"file":"MailExportFacade.js","sourceRoot":"","sources":["../../../../../../../src/common/api/worker/facades/lazy/MailExportFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { File as TutanotaFile, Mail } from \"../../../entities/tutanota/TypeRefs\"\nimport { assertWorkerOrNode } from \"../../../common/Env\"\nimport { BulkMailLoader, MailWithMailDetails } from \"../../../../../mail-app/workerUtils/index/BulkMailLoader.js\"\nimport { convertToDataFile, DataFile } from \"../../../common/DataFile.js\"\nimport { ArchiveDataType } from \"../../../common/TutanotaConstants.js\"\nimport { BlobFacade } from \"./BlobFacade.js\"\nimport { CryptoFacade } from \"../../crypto/CryptoFacade.js\"\nimport { createReferencingInstance } from \"../../../common/utils/BlobUtils.js\"\nimport { MailExportTokenFacade } from \"./MailExportTokenFacade.js\"\nimport { assertNotNull, isNotNull } from \"@tutao/tutanota-utils\"\nimport { NotFoundError } from \"../../../common/error/RestError\"\nimport { elementIdPart } from \"../../../common/utils/EntityUtils\"\nimport { BlobAccessTokenFacade } from \"../BlobAccessTokenFacade\"\nimport { BlobServerUrl } from \"../../../entities/storage/TypeRefs\"\nimport { Group } from \"../../../entities/sys/TypeRefs\"\nimport { SuspensionBehavior } from \"../../rest/RestClient\"\n\nassertWorkerOrNode()\n\n/**\n * Denotes the header that will have the mail export token.\n */\nexport const MAIL_EXPORT_TOKEN_HEADER = \"mailExportToken\"\n\n/**\n * Wraps bulk loading of mails for mail export.\n *\n * Takes care of using mail export tokens.\n */\nexport class MailExportFacade {\n\tconstructor(\n\t\tprivate readonly mailExportTokenFacade: MailExportTokenFacade,\n\t\tprivate readonly bulkMailLoader: BulkMailLoader,\n\t\tprivate readonly blobFacade: BlobFacade,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly blobAccessTokenFacade: BlobAccessTokenFacade,\n\t) {}\n\n\t/**\n\t * Returns a list of servers that can be used to request data from.\n\t */\n\tasync getExportServers(group: Group): Promise<BlobServerUrl[]> {\n\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestWriteToken(ArchiveDataType.Attachments, group._id)\n\t\treturn blobServerAccessInfo.servers\n\t}\n\n\tasync loadFixedNumberOfMailsWithCache(mailListId: Id, startId: Id, baseUrl: string): Promise<Mail[]> {\n\t\treturn this.mailExportTokenFacade.loadWithToken((token) =>\n\t\t\tthis.bulkMailLoader.loadFixedNumberOfMailsWithCache(mailListId, startId, { baseUrl, ...this.options(token) }),\n\t\t)\n\t}\n\n\tasync loadMailDetails(mails: readonly Mail[]): Promise<MailWithMailDetails[]> {\n\t\treturn this.mailExportTokenFacade.loadWithToken((token) => this.bulkMailLoader.loadMailDetails(mails, this.options(token)))\n\t}\n\n\tasync loadAttachments(mails: readonly Mail[], baseUrl: string): Promise<TutanotaFile[]> {\n\t\treturn this.mailExportTokenFacade.loadWithToken((token) => this.bulkMailLoader.loadAttachments(mails, { baseUrl, ...this.options(token) }))\n\t}\n\n\tasync loadAttachmentData(mail: Mail, attachments: readonly TutanotaFile[]): Promise<DataFile[]> {\n\t\tconst attachmentsWithKeys = await this.cryptoFacade.enforceSessionKeyUpdateIfNeeded(mail, attachments)\n\n\t\tconst downloads = await this.mailExportTokenFacade.loadWithToken((token) => {\n\t\t\tconst referencingInstances = attachmentsWithKeys.map(createReferencingInstance)\n\t\t\treturn this.blobFacade.downloadAndDecryptBlobsOfMultipleInstances(ArchiveDataType.Attachments, referencingInstances, {\n\t\t\t\t...this.options(token),\n\t\t\t})\n\t\t})\n\n\t\tconst attachmentData = Array.from(downloads.entries()).map(([fileId, bytes]) => {\n\t\t\ttry {\n\t\t\t\tif (bytes == null) {\n\t\t\t\t\treturn null\n\t\t\t\t} else {\n\t\t\t\t\tconst attachment = assertNotNull(attachmentsWithKeys.find((attachment) => elementIdPart(attachment._id) === fileId))\n\t\t\t\t\treturn convertToDataFile(attachment, bytes)\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\treturn null\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn attachmentData.filter(isNotNull)\n\t}\n\n\tprivate options(token: string): { extraHeaders: Dict; suspensionBehavior: SuspensionBehavior.Throw } {\n\t\treturn {\n\t\t\textraHeaders: {\n\t\t\t\t[MAIL_EXPORT_TOKEN_HEADER]: token,\n\t\t\t},\n\t\t\tsuspensionBehavior: SuspensionBehavior.Throw,\n\t\t}\n\t}\n}\n"]}