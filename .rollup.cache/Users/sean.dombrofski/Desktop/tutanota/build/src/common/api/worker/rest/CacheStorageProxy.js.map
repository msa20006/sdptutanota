{"version":3,"file":"CacheStorageProxy.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/rest/CacheStorageProxy.ts"],"names":[],"mappings":"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","sourcesContent":["import { CacheStorage, LastUpdateTime, Range } from \"./DefaultEntityRestCache.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { ListElementEntity, SomeEntity } from \"../../common/EntityTypes\"\nimport { TypeRef } from \"@tutao/tutanota-utils\"\nimport { OfflineStorage, OfflineStorageInitArgs } from \"../offline/OfflineStorage.js\"\nimport { EphemeralCacheStorage, EphemeralStorageInitArgs } from \"./EphemeralCacheStorage\"\nimport { EntityRestClient } from \"./EntityRestClient.js\"\nimport { CustomCacheHandlerMap } from \"./CustomCacheHandler.js\"\n\nexport interface EphemeralStorageArgs extends EphemeralStorageInitArgs {\n\ttype: \"ephemeral\"\n}\n\nexport type OfflineStorageArgs = OfflineStorageInitArgs & {\n\ttype: \"offline\"\n}\n\ninterface CacheStorageInitReturn {\n\t/** If the created storage is an OfflineStorage */\n\tisPersistent: boolean\n\t/** If a OfflineStorage was created, whether or not the backing database was created fresh or already existed */\n\tisNewOfflineDb: boolean\n}\n\nexport interface CacheStorageLateInitializer {\n\tinitialize(args: OfflineStorageArgs | EphemeralStorageArgs): Promise<CacheStorageInitReturn>\n\n\tdeInitialize(): Promise<void>\n}\n\ntype SomeStorage = OfflineStorage | EphemeralCacheStorage\n\n/**\n * This is necessary so that we can release offline storage mode without having to rewrite the credentials handling system. Since it's possible that\n * a desktop user might not use a persistent session, and we won't know until they try to log in, we can only decide what kind of cache storage to use at login\n * This implementation allows us to avoid modifying too much of the worker public API. Once we make this obsolete, all we will have to do is\n * remove the initialize parameter from the LoginFacade, and tidy up the WorkerLocator init\n *\n * Create a proxy to a cache storage object.\n * It will be uninitialized, and unusable until {@method CacheStorageLateInitializer.initializeCacheStorage} has been called on the returned object\n * Once it is initialized, then it is safe to use\n * @param factory A factory function to get a CacheStorage implementation when initialize is called\n * @return {CacheStorageLateInitializer} The uninitialized proxy and a function to initialize it\n */\nexport class LateInitializedCacheStorageImpl implements CacheStorageLateInitializer, CacheStorage {\n\tprivate _inner: SomeStorage | null = null\n\n\tconstructor(private readonly sendError: (error: Error) => Promise<void>, private readonly offlineStorageProvider: () => Promise<null | OfflineStorage>) {}\n\n\tprivate get inner(): CacheStorage {\n\t\tif (this._inner == null) {\n\t\t\tthrow new ProgrammingError(\"Cache storage is not initialized\")\n\t\t}\n\n\t\treturn this._inner\n\t}\n\n\tasync initialize(args: OfflineStorageArgs | EphemeralStorageArgs): Promise<CacheStorageInitReturn> {\n\t\t// We might call this multiple times.\n\t\t// This happens when persistent credentials login fails and we need to start with new cache for new login.\n\t\tconst { storage, isPersistent, isNewOfflineDb } = await this.getStorage(args)\n\t\tthis._inner = storage\n\t\treturn {\n\t\t\tisPersistent,\n\t\t\tisNewOfflineDb,\n\t\t}\n\t}\n\n\tasync deInitialize(): Promise<void> {\n\t\tthis._inner?.deinit()\n\t}\n\n\tprivate async getStorage(\n\t\targs: OfflineStorageArgs | EphemeralStorageArgs,\n\t): Promise<{ storage: SomeStorage; isPersistent: boolean; isNewOfflineDb: boolean }> {\n\t\tif (args.type === \"offline\") {\n\t\t\ttry {\n\t\t\t\tconst storage = await this.offlineStorageProvider()\n\t\t\t\tif (storage != null) {\n\t\t\t\t\tconst isNewOfflineDb = await storage.init(args)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstorage,\n\t\t\t\t\t\tisPersistent: true,\n\t\t\t\t\t\tisNewOfflineDb,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Precaution in case something bad happens to offline database. We want users to still be able to log in.\n\t\t\t\tconsole.error(\"Error while initializing offline cache storage\", e)\n\t\t\t\tthis.sendError(e)\n\t\t\t}\n\t\t}\n\t\t// both \"else\" case and fallback for unavailable storage and error cases\n\t\tconst storage = new EphemeralCacheStorage()\n\t\tawait storage.init(args)\n\t\treturn {\n\t\t\tstorage,\n\t\t\tisPersistent: false,\n\t\t\tisNewOfflineDb: false,\n\t\t}\n\t}\n\n\tdeleteIfExists<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<void> {\n\t\treturn this.inner.deleteIfExists(typeRef, listId, id)\n\t}\n\n\tget<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<T | null> {\n\t\treturn this.inner.get(typeRef, listId, id)\n\t}\n\n\tgetIdsInRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<Id>> {\n\t\treturn this.inner.getIdsInRange(typeRef, listId)\n\t}\n\n\tgetLastBatchIdForGroup(groupId: Id): Promise<Id | null> {\n\t\treturn this.inner.getLastBatchIdForGroup(groupId)\n\t}\n\n\tasync getLastUpdateTime(): Promise<LastUpdateTime> {\n\t\treturn this._inner ? this.inner.getLastUpdateTime() : { type: \"uninitialized\" }\n\t}\n\n\tgetRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Range | null> {\n\t\treturn this.inner.getRangeForList(typeRef, listId)\n\t}\n\n\tisElementIdInCacheRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<boolean> {\n\t\treturn this.inner.isElementIdInCacheRange(typeRef, listId, id)\n\t}\n\n\tprovideFromRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, start: Id, count: number, reverse: boolean): Promise<T[]> {\n\t\treturn this.inner.provideFromRange(typeRef, listId, start, count, reverse)\n\t}\n\n\tprovideMultiple<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: string, elementIds: string[]): Promise<T[]> {\n\t\treturn this.inner.provideMultiple(typeRef, listId, elementIds)\n\t}\n\n\tgetWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<T>> {\n\t\treturn this.inner.getWholeList(typeRef, listId)\n\t}\n\n\tpurgeStorage(): Promise<void> {\n\t\treturn this.inner.purgeStorage()\n\t}\n\n\tput(originalEntity: SomeEntity): Promise<void> {\n\t\treturn this.inner.put(originalEntity)\n\t}\n\n\tputLastBatchIdForGroup(groupId: Id, batchId: Id): Promise<void> {\n\t\treturn this.inner.putLastBatchIdForGroup(groupId, batchId)\n\t}\n\n\tputLastUpdateTime(value: number): Promise<void> {\n\t\treturn this.inner.putLastUpdateTime(value)\n\t}\n\n\tsetLowerRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<void> {\n\t\treturn this.inner.setLowerRangeForList(typeRef, listId, id)\n\t}\n\n\tsetNewRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, lower: Id, upper: Id): Promise<void> {\n\t\treturn this.inner.setNewRangeForList(typeRef, listId, lower, upper)\n\t}\n\n\tsetUpperRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<void> {\n\t\treturn this.inner.setUpperRangeForList(typeRef, listId, id)\n\t}\n\n\tgetCustomCacheHandlerMap(entityRestClient: EntityRestClient): CustomCacheHandlerMap {\n\t\treturn this.inner.getCustomCacheHandlerMap(entityRestClient)\n\t}\n\n\tgetUserId(): Id {\n\t\treturn this.inner.getUserId()\n\t}\n\n\tasync deleteAllOwnedBy(owner: Id): Promise<void> {\n\t\treturn this.inner.deleteAllOwnedBy(owner)\n\t}\n\n\tasync deleteWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<void> {\n\t\treturn this.inner.deleteWholeList(typeRef, listId)\n\t}\n\n\tclearExcludedData(): Promise<void> {\n\t\treturn this.inner.clearExcludedData()\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" db when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId)\n\t * @param listId the mail list that we want to lock\n\t */\n\tlockRangesDbAccess(listId: Id): Promise<void> {\n\t\treturn this.inner.lockRangesDbAccess(listId)\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(listId)\"\n\t * @param listId the mail list that we want to unlock\n\t */\n\tunlockRangesDbAccess(listId: Id): Promise<void> {\n\t\treturn this.inner.unlockRangesDbAccess(listId)\n\t}\n}\n"]}