{"version":3,"file":"SleepDetector.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/utils/SleepDetector.ts"],"names":[],"mappings":"AAIA,uBAAuB;AACvB,uCAAuC;AACvC,MAAM,CAAC,MAAM,cAAc,GAAG,IAAI,CAAA;AAClC,oFAAoF;AACpF,MAAM,CAAC,MAAM,cAAc,GAAG,KAAK,CAAA;AAQnC;;;;;;;;GAQG;AACH,MAAM,OAAO,aAAa;IAGI;IAAuC;IAF5D,cAAc,GAA0B,IAAI,CAAA;IAEpD,YAA6B,SAAoB,EAAmB,YAA0B;QAAjE,cAAS,GAAT,SAAS,CAAW;QAAmB,iBAAY,GAAZ,YAAY,CAAc;IAAG,CAAC;IAElG,KAAK,CAAC,OAAc;QACnB,IAAI,CAAC,IAAI,EAAE,CAAA;QACX,IAAI,CAAC,cAAc,GAAG;YACrB,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,cAAc,CAAC;YAChF,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE;YACjC,OAAO;SACP,CAAA;IACF,CAAC;IAEO,KAAK;QACZ,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI;YAAE,OAAM;QAEvC,MAAM,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,CAAA;QACnC,IAAI,GAAG,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,GAAG,cAAc,EAAE,CAAC;YACzD,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAA;QAC9B,CAAC;QACD,IAAI,CAAC,cAAc,CAAC,QAAQ,GAAG,GAAG,CAAA;IACnC,CAAC;IAED,IAAI;QACH,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;YAClE,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;QAC3B,CAAC;IACF,CAAC;CACD","sourcesContent":["import { Thunk } from \"@tutao/tutanota-utils\"\nimport { Scheduler } from \"../../common/utils/Scheduler.js\"\nimport { DateProvider } from \"../../common/DateProvider.js\"\n\n// exported for testing\n/** How often do we check for sleep. */\nexport const CHECK_INTERVAL = 5000\n/** How much time should have passed for us to assume that the app was suspended. */\nexport const SLEEP_INTERVAL = 15000\n\ninterface ScheduledState {\n\tscheduledId: number\n\tlastTime: number\n\treadonly onSleep: Thunk\n}\n\n/**\n * Class for detecting suspension state of the app/device.\n * When the device is entering the sleep mode the browser would pause the page. For most of the app it looks like no time has passed at all but when there\n * are external factors e.g. websocket connection we might need to know whether it happens.\n *\n * We detect such situation by scheduling periodic timer and measuring the time in between.\n *\n * Currently is only capable of having one sleep action at a time.\n */\nexport class SleepDetector {\n\tprivate scheduledState: ScheduledState | null = null\n\n\tconstructor(private readonly scheduler: Scheduler, private readonly dateProvider: DateProvider) {}\n\n\tstart(onSleep: Thunk): void {\n\t\tthis.stop()\n\t\tthis.scheduledState = {\n\t\t\tscheduledId: this.scheduler.schedulePeriodic(() => this.check(), CHECK_INTERVAL),\n\t\t\tlastTime: this.dateProvider.now(),\n\t\t\tonSleep,\n\t\t}\n\t}\n\n\tprivate check() {\n\t\tif (this.scheduledState == null) return\n\n\t\tconst now = this.dateProvider.now()\n\t\tif (now - this.scheduledState.lastTime > SLEEP_INTERVAL) {\n\t\t\tthis.scheduledState.onSleep()\n\t\t}\n\t\tthis.scheduledState.lastTime = now\n\t}\n\n\tstop(): void {\n\t\tif (this.scheduledState) {\n\t\t\tthis.scheduler.unschedulePeriodic(this.scheduledState.scheduledId)\n\t\t\tthis.scheduledState = null\n\t\t}\n\t}\n}\n"]}