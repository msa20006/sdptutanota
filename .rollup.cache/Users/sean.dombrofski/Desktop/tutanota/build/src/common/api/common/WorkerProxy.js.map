{"version":3,"file":"WorkerProxy.js","sourceRoot":"","sources":["../../../../../src/common/api/common/WorkerProxy.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAA;AAChD,OAAO,EAAE,OAAO,EAAE,MAAM,kCAAkC,CAAA;AAC1D,OAAO,EAAE,gBAAgB,EAAE,MAAM,0BAA0B,CAAA;AAI3D;;;;;GAKG;AACH,MAAM,UAAU,YAAY,CAAI,aAAsC;IACrE,0DAA0D;IAC1D,MAAM,WAAW,GAAG,IAAI,KAAK,CAC5B,EAAE,EACF;QACC,GAAG,EAAE,CAAC,CAAS,EAAE,QAAgB,EAAE,EAAE;YACpC,OAAO,WAAW,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAA;QAC5C,CAAC;KACD,CACD,CAAA;IACD,OAAO,QAAQ,CAAI,WAAW,CAAC,CAAA;AAChC,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,WAAW,CAAwC,KAAQ;IAC1E,OAAO,CAAC,OAAqC,EAAE,EAAE;QAChD,MAAM,CAAC,MAAM,EAAE,EAAE,EAAE,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CAAA;QACvC,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAA;QAEpC,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;YAClB,MAAM,IAAI,gBAAgB,CAAC,0BAA0B,MAAM,IAAI,EAAE,gBAAgB,CAAC,CAAA;QACnF,CAAC;QAED,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,CAAA;IACnC,CAAC,CAAA;AACF,CAAC;AAUD;;;;GAIG;AACH,MAAM,UAAU,kBAAkB,CACjC,KAAQ;IAER,OAAO,KAAK,EAAE,OAAqC,EAAE,EAAE;QACtD,MAAM,CAAC,MAAM,EAAE,EAAE,EAAE,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CAAA;QACvC,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAA;QAEpC,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;YAClB,MAAM,IAAI,gBAAgB,CAAC,0BAA0B,MAAM,IAAI,EAAE,gBAAgB,CAAC,CAAA;QACnF,CAAC;QAED,MAAM,IAAI,GAAG,MAAM,IAAI,EAAE,CAAA;QACzB,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;YAClB,MAAM,IAAI,gBAAgB,CAAC,uBAAuB,MAAM,IAAI,EAAE,uBAAuB,CAAC,CAAA;QACvF,CAAC;QAED,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,CAAA;IACnC,CAAC,CAAA;AACF,CAAC;AAED;;GAEG;AACH,SAAS,WAAW,CAAC,aAAsC,EAAE,UAAkB;IAC9E,OAAO,IAAI,KAAK,CACf,EAAE,EACF;QACC,GAAG,EAAE,CAAC,CAAS,EAAE,QAAgB,EAAE,EAAE;YACpC,4HAA4H;YAC5H,0HAA0H;YAC1H,yHAAyH;YACzH,cAAc;YACd,IAAI,QAAQ,KAAK,MAAM,EAAE,CAAC;gBACzB,OAAO,SAAS,CAAA;YACjB,CAAC;iBAAM,CAAC;gBACP,OAAO,CAAC,GAAG,IAAW,EAAE,EAAE;oBACzB,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,QAAiB,EAAE,CAAC,UAAU,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAA;oBAC5E,OAAO,aAAa,CAAC,OAAO,CAAC,CAAA;gBAC9B,CAAC,CAAA;YACF,CAAC;QACF,CAAC;KACD,CACD,CAAA;AACF,CAAC","sourcesContent":["/**\n * @file Functions to automatically expose certain interfaces across the WorkerProtocol Queue.\n */\nimport { downcast } from \"@tutao/tutanota-utils\"\nimport { Request } from \"./threading/MessageDispatcher.js\"\nimport { ProgrammingError } from \"./error/ProgrammingError\"\n\ntype RequestSender<RequestTypes> = (arg0: Request<RequestTypes>) => Promise<any>\n\n/**\n * Generates proxy where each field will be treated as an interface with async methods. Each method will delegate to the\n * {@param requestSender}.\n * Attention! Make sure that the *only* fields on T are facades. Every facade method must return promise or Bad Things will happen.\n * You should specify T explicitly to avoid mistakes.\n */\nexport function exposeRemote<T>(requestSender: RequestSender<\"facade\">): T {\n\t// Outer proxy is just used to generate individual facades\n\tconst workerProxy = new Proxy(\n\t\t{},\n\t\t{\n\t\t\tget: (_: object, property: string) => {\n\t\t\t\treturn facadeProxy(requestSender, property)\n\t\t\t},\n\t\t},\n\t)\n\treturn downcast<T>(workerProxy)\n}\n\n/**\n * Generate a handler which will delegate to {@param impls}.\n * Attention! Make sure that the *only* fields on T are facades. Every facade method must return promise or Bad Things will happen.\n * You should specify T explicitly to avoid mistakes.\n */\nexport function exposeLocal<T extends object, IncomingRequestType>(impls: T): (message: Request<IncomingRequestType>) => Promise<any> {\n\treturn (message: Request<IncomingRequestType>) => {\n\t\tconst [facade, fn, args] = message.args\n\t\tconst impl = downcast(impls)[facade]\n\n\t\tif (impl == null) {\n\t\t\tthrow new ProgrammingError(`Facade is not exposed: ${facade}.${fn} (exposeLocal)`)\n\t\t}\n\n\t\treturn downcast(impl)[fn](...args)\n\t}\n}\n\nexport type FacadeImpls = {\n\t[facade: string]: any\n}\n\nexport type DelayedImpls<IMPLS extends FacadeImpls> = {\n\t[Property in keyof IMPLS]: () => Promise<IMPLS[Property]>\n}\n\n/**\n * Generate a handler which will delegate to {@param impls}.\n * Attention! Make sure that the *only* fields on T are functions that resolve to facades. Every facade method must return promise or Bad Things will happen.\n * You should specify T explicitly to avoid mistakes.\n */\nexport function exposeLocalDelayed<T extends DelayedImpls<FacadeImpls>, IncomingRequestType>(\n\timpls: T,\n): (message: Request<IncomingRequestType>) => Promise<any> {\n\treturn async (message: Request<IncomingRequestType>) => {\n\t\tconst [facade, fn, args] = message.args\n\t\tconst init = downcast(impls)[facade]\n\n\t\tif (init == null) {\n\t\t\tthrow new ProgrammingError(`Facade is not exposed: ${facade}.${fn} (exposeLocal)`)\n\t\t}\n\n\t\tconst impl = await init()\n\t\tif (impl == null) {\n\t\t\tthrow new ProgrammingError(`Facade is not lazy: ${facade}.${fn} (exposeLocalDelayed)`)\n\t\t}\n\n\t\treturn downcast(impl)[fn](...args)\n\t}\n}\n\n/**\n * Generates proxy which will generate methods which will simulate methods of the facade.\n */\nfunction facadeProxy(requestSender: RequestSender<\"facade\">, facadeName: string) {\n\treturn new Proxy(\n\t\t{},\n\t\t{\n\t\t\tget: (_: object, property: string) => {\n\t\t\t\t// We generate whatever property is asked from us and we assume it is a function. It is normally enforced by the type system\n\t\t\t\t// but runtime also tests for certain properties e.g. when returning a value from a promise it will try to test whether it\n\t\t\t\t// is \"promisable\". It is doing so by checking whether there's a \"then\" function. So we explicitly say we don't have such\n\t\t\t\t// a function.\n\t\t\t\tif (property === \"then\") {\n\t\t\t\t\treturn undefined\n\t\t\t\t} else {\n\t\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\t\tconst request = new Request(\"facade\" as const, [facadeName, property, args])\n\t\t\t\t\t\treturn requestSender(request)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t)\n}\n"]}