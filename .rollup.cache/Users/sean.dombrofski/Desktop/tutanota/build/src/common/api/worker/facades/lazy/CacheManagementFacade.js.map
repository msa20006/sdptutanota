{"version":3,"file":"CacheManagementFacade.js","sourceRoot":"","sources":["../../../../../../../src/common/api/worker/facades/lazy/CacheManagementFacade.ts"],"names":[],"mappings":"AAAA,OAAO,EAAS,YAAY,EAAQ,+BAA+B,EAAE,WAAW,EAAE,MAAM,mCAAmC,CAAA;AAE3H,OAAO,EAAE,kBAAkB,EAAE,MAAM,wBAAwB,CAAA;AAG3D,OAAO,EAAE,QAAQ,EAAE,MAAM,sCAAsC,CAAA;AAE/D,kBAAkB,EAAE,CAAA;AAEpB;;;GAGG;AACH,MAAM,OAAO,qBAAqB;IAEf;IACA;IACA;IAHlB,YACkB,UAAsB,EACtB,mBAAiC,EACjC,eAAuC;QAFvC,eAAU,GAAV,UAAU,CAAY;QACtB,wBAAmB,GAAnB,mBAAmB,CAAc;QACjC,oBAAe,GAAf,eAAe,CAAwB;IACtD,CAAC;IAEJ;;;OAGG;IACH,KAAK,CAAC,eAAe,CAAC,OAAW;QAChC,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAA;QAC7C,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,UAAU,EAAE,CAAA;QACpC,IAAI,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,EAAE,CAAC;YACzD,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAA;QACrC,CAAC;QACD,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,CAAA;IACvB,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,WAAW,CAAC,OAAW;QAC5B,MAAM,IAAI,CAAC,eAAe,CAAC,uBAAuB,CAAC,YAAY,EAAE,IAAI,EAAE,OAAO,CAAC,CAAA;QAC/E,OAAO,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,YAAY,EAAE,OAAO,CAAC,CAAA;IAClE,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,UAAU;QACf,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,eAAe,EAAE,CAAC,GAAG,CAAA;QAEpD,MAAM,IAAI,CAAC,eAAe,CAAC,uBAAuB,CAAC,WAAW,EAAE,IAAI,EAAE,MAAM,CAAC,CAAA;QAE7E,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;QACrE,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,CAAC,4BAA4B;QAEnE,OAAO,IAAI,CAAA;IACZ,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,uBAAuB;QAC5B,8FAA8F;QAC9F,8FAA8F;QAC9F,IAAI,CAAC;YACJ,6FAA6F;YAC7F,MAAM,wBAAwB,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,+BAA+B,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,CAAA;YACvI,IAAI,CAAC,UAAU,CAAC,kBAAkB,CAAC,wBAAwB,CAAC,CAAA;QAC7D,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,iFAAiF;YACjF,yEAAyE;YACzE,8FAA8F;YAC9F,OAAO,CAAC,GAAG,CAAC,iCAAiC,EAAE,CAAC,CAAC,CAAA;QAClD,CAAC;IACF,CAAC;CACD","sourcesContent":["import { Group, GroupTypeRef, User, UserGroupKeyDistributionTypeRef, UserTypeRef } from \"../../../entities/sys/TypeRefs.js\"\nimport { EntityClient } from \"../../../common/EntityClient.js\"\nimport { assertWorkerOrNode } from \"../../../common/Env.js\"\nimport { UserFacade } from \"../UserFacade.js\"\nimport { DefaultEntityRestCache } from \"../../rest/DefaultEntityRestCache.js\"\nimport { isSameId } from \"../../../common/utils/EntityUtils.js\"\n\nassertWorkerOrNode()\n\n/**\n * This facade is responsible for handling cases where we need to manually update an entity in the rest cache.\n * It is also suitable to manually ensure consistency between the rest cache and the key cache.\n */\nexport class CacheManagementFacade {\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly cachingEntityClient: EntityClient,\n\t\tprivate readonly entityRestCache: DefaultEntityRestCache,\n\t) {}\n\n\t/**\n\t * Refreshes group and user (because of the memberships) in the rest cache and updates the key cache if possible.\n\t * @param groupId\n\t */\n\tasync refreshKeyCache(groupId: Id): Promise<{ user: User; group: Group }> {\n\t\tconst group = await this.reloadGroup(groupId)\n\t\tconst user = await this.reloadUser()\n\t\tif (isSameId(groupId, this.userFacade.getUserGroupId())) {\n\t\t\tawait this.tryUpdatingUserGroupKey()\n\t\t}\n\t\treturn { user, group }\n\t}\n\n\t/**\n\t * Refreshes a group in the rest cache.\n\t * @param groupId\n\t */\n\tasync reloadGroup(groupId: Id): Promise<Group> {\n\t\tawait this.entityRestCache.deleteFromCacheIfExists(GroupTypeRef, null, groupId)\n\t\treturn await this.cachingEntityClient.load(GroupTypeRef, groupId)\n\t}\n\n\t/*\n\t * Deletes the logged-in user from the cache, and reloads and returns the new user object.\n\t * Is used to ensure we have the latest version, there can be times when the object becomes a little outdated, resulting in errors.\n\t * It also ensures that the key cache is updated.\n\t */\n\tasync reloadUser(): Promise<User> {\n\t\tconst userId = this.userFacade.getLoggedInUser()._id\n\n\t\tawait this.entityRestCache.deleteFromCacheIfExists(UserTypeRef, null, userId)\n\n\t\tconst user = await this.cachingEntityClient.load(UserTypeRef, userId)\n\t\tawait this.userFacade.updateUser(user) // updates the key cache too\n\n\t\treturn user\n\t}\n\n\t/**\n\t * Tries updating the user group key in the key cache by loading and decrypting the UserGroupKeyDistribution entity.\n\t */\n\tasync tryUpdatingUserGroupKey() {\n\t\t// this handles updates of the user group key which is also stored on the user as a membership\n\t\t// we might not have access to the password to decrypt it, though. therefore we handle it here\n\t\ttry {\n\t\t\t// Note that UserGroupKeyDistribution is never cached in the rest cache. no need to delete it\n\t\t\tconst userGroupKeyDistribution = await this.cachingEntityClient.load(UserGroupKeyDistributionTypeRef, this.userFacade.getUserGroupId())\n\t\t\tthis.userFacade.updateUserGroupKey(userGroupKeyDistribution)\n\t\t} catch (e) {\n\t\t\t// we do not want to fail here, as this update might be an outdated entity update\n\t\t\t// in case we only process updates after a longer period of being offline\n\t\t\t// in such case we should have set the correct user group key already during the regular login\n\t\t\tconsole.log(\"Could not update user group key\", e)\n\t\t}\n\t}\n}\n"]}