{"version":3,"file":"KeyLoaderFacade.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/facades/KeyLoaderFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { EntityClient } from \"../../common/EntityClient.js\"\nimport { AesKey, AsymmetricKeyPair, decryptKey, decryptKeyPair, EncryptedKeyPairs, isRsaOrRsaEccKeyPair } from \"@tutao/tutanota-crypto\"\nimport { Group, GroupKey, GroupKeyTypeRef, GroupTypeRef, KeyPair } from \"../../entities/sys/TypeRefs.js\"\nimport { isKeyVersion, KeyVersion, Versioned } from \"@tutao/tutanota-utils/dist/Utils.js\"\nimport { UserFacade } from \"./UserFacade.js\"\nimport { NotFoundError } from \"../../common/error/RestError.js\"\nimport { customIdToString, getElementId, isSameId, stringToCustomId } from \"../../common/utils/EntityUtils.js\"\nimport { KeyCache } from \"./KeyCache.js\"\nimport { assertNotNull, lazyAsync } from \"@tutao/tutanota-utils\"\nimport { CacheManagementFacade } from \"./lazy/CacheManagementFacade.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { VersionedKey } from \"../crypto/CryptoWrapper.js\"\n\n/**\n * Load symmetric and asymmetric keys and decrypt them.\n * Handle group key versioning.\n */\nexport class KeyLoaderFacade {\n\tconstructor(\n\t\tprivate readonly keyCache: KeyCache,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly cacheManagementFacade: lazyAsync<CacheManagementFacade>,\n\t) {}\n\n\t/**\n\t * Load the symmetric group key for the groupId with the provided requestedVersion.\n\t * @param groupId the id of the group\n\t * @param requestedVersion the requestedVersion of the key to be loaded\n\t * @param currentGroupKey needs to be set if the user is not a member of the group (e.g. an admin)\n\t */\n\tasync loadSymGroupKey(groupId: Id, requestedVersion: KeyVersion, currentGroupKey?: VersionedKey): Promise<AesKey> {\n\t\tif (currentGroupKey != null && currentGroupKey.version < requestedVersion) {\n\t\t\t// we might not have the membership for this group. so the caller needs to handle it by refreshing the cache\n\t\t\tthrow new Error(\n\t\t\t\t`Provided current group key is too old (${currentGroupKey.version}) to load the requested version ${requestedVersion} for group ${groupId}`,\n\t\t\t)\n\t\t}\n\t\tconst groupKey = currentGroupKey ?? (await this.getCurrentSymGroupKey(groupId))\n\n\t\tif (groupKey.version === requestedVersion) {\n\t\t\treturn groupKey.object\n\t\t} else if (groupKey.version < requestedVersion) {\n\t\t\t// the latest key is not cached, so we update the user and try again\n\t\t\t// this can still fail as we might be too slow with processing some update e.g. a GroupKeyUpdate\n\t\t\t// (we are member of a shared group rotated by someone else and the new membership is not yet on the user)\n\t\t\tawait (await this.cacheManagementFacade()).refreshKeyCache(groupId)\n\t\t\t// There is no point in re-trying with the outdated current group key\n\t\t\tconst refreshedGroupKey = await this.getCurrentSymGroupKey(groupId) // we pass the currentGroupKey to break the recursion\n\t\t\treturn this.loadSymGroupKey(groupId, requestedVersion, refreshedGroupKey)\n\t\t} else {\n\t\t\t// we load a former key as the cached one is newer: groupKey.requestedVersion > requestedVersion\n\t\t\tconst group = await this.entityClient.load(GroupTypeRef, groupId)\n\t\t\tconst { symmetricGroupKey } = await this.findFormerGroupKey(group, groupKey, requestedVersion)\n\t\t\treturn symmetricGroupKey\n\t\t}\n\t}\n\n\tasync getCurrentSymGroupKey(groupId: Id): Promise<VersionedKey> {\n\t\t// The current user group key should not be included in the map of current keys, because we only keep a copy in userFacade\n\t\tif (isSameId(groupId, this.userFacade.getUserGroupId())) {\n\t\t\treturn this.getCurrentSymUserGroupKey()\n\t\t}\n\t\treturn this.keyCache.getCurrentGroupKey(groupId, () => this.loadAndDecryptCurrentSymGroupKey(groupId))\n\t}\n\n\tasync loadSymUserGroupKey(requestedVersion: KeyVersion): Promise<AesKey> {\n\t\t// we provide the current user group key to break a possibly infinite recursion\n\t\tlet currentUserGroupKey = this.getCurrentSymUserGroupKey()\n\t\tif (currentUserGroupKey.version < requestedVersion) {\n\t\t\tawait (await this.cacheManagementFacade()).refreshKeyCache(this.userFacade.getUserGroupId())\n\t\t\tcurrentUserGroupKey = this.getCurrentSymUserGroupKey()\n\t\t\t// if the key is still outdated loadSymGroupKey will throw - we tried our best.\n\t\t}\n\t\treturn this.loadSymGroupKey(this.userFacade.getUserGroupId(), requestedVersion, currentUserGroupKey)\n\t}\n\n\tgetCurrentSymUserGroupKey(): VersionedKey {\n\t\treturn this.userFacade.getCurrentUserGroupKey()\n\t}\n\n\tasync loadKeypair(keyPairGroupId: Id, requestedVersion: KeyVersion): Promise<AsymmetricKeyPair> {\n\t\tlet group = await this.entityClient.load(GroupTypeRef, keyPairGroupId)\n\t\tlet currentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId)\n\n\t\tif (requestedVersion > currentGroupKey.version) {\n\t\t\tgroup = (await (await this.cacheManagementFacade()).refreshKeyCache(keyPairGroupId)).group\n\t\t\tcurrentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId)\n\t\t}\n\t\treturn await this.loadKeyPairImpl(group, requestedVersion, currentGroupKey)\n\t}\n\n\tasync loadCurrentKeyPair(groupId: Id): Promise<Versioned<AsymmetricKeyPair>> {\n\t\tlet group = await this.entityClient.load(GroupTypeRef, groupId)\n\n\t\tlet currentGroupKey = await this.getCurrentSymGroupKey(groupId)\n\t\tif (parseKeyVersion(group.groupKeyVersion) !== currentGroupKey.version) {\n\t\t\t// There is a race condition after rotating the group key were the group entity in the cache is not in sync with current key version in the key cache.\n\t\t\t// group.groupKeyVersion might be newer than currentGroupKey.version.\n\t\t\t// We reload group and user and refresh entity and key cache to synchronize both caches.\n\t\t\tgroup = (await (await this.cacheManagementFacade()).refreshKeyCache(groupId)).group\n\t\t\tcurrentGroupKey = await this.getCurrentSymGroupKey(groupId)\n\t\t\tif (parseKeyVersion(group.groupKeyVersion) !== currentGroupKey.version) {\n\t\t\t\t// we still do not have the proper state to get the current key pair\n\t\t\t\tthrow new Error(`inconsistent key version state in cache and key cache for group ${groupId}`)\n\t\t\t}\n\t\t}\n\t\treturn { object: this.validateAndDecryptKeyPair(group.currentKeys, groupId, currentGroupKey), version: parseKeyVersion(group.groupKeyVersion) }\n\t}\n\n\tprivate async loadKeyPairImpl(group: Group, requestedVersion: KeyVersion, currentGroupKey: VersionedKey) {\n\t\tconst keyPairGroupId = group._id\n\t\tlet keyPair: KeyPair | null\n\t\tlet symGroupKey: VersionedKey\n\t\tif (requestedVersion > currentGroupKey.version) {\n\t\t\tthrow new Error(`Not possible to get newer key version than is cached for group ${keyPairGroupId}`)\n\t\t} else if (requestedVersion === currentGroupKey.version) {\n\t\t\tsymGroupKey = currentGroupKey\n\t\t\tif (parseKeyVersion(group.groupKeyVersion) === currentGroupKey.version) {\n\t\t\t\tkeyPair = group.currentKeys\n\t\t\t} else {\n\t\t\t\t// we load by the version and thus can be sure that we are able to decrypt this key\n\t\t\t\tconst formerGroupKey = await this.loadFormerGroupKeyInstance(group, currentGroupKey.version)\n\t\t\t\tkeyPair = formerGroupKey.keyPair\n\t\t\t}\n\t\t} else {\n\t\t\t// load a former key pair: groupKeyVersion < groupKey.version\n\t\t\tconst { symmetricGroupKey, groupKeyInstance } = await this.findFormerGroupKey(group, currentGroupKey, requestedVersion)\n\t\t\tkeyPair = groupKeyInstance.keyPair\n\t\t\tsymGroupKey = { object: symmetricGroupKey, version: requestedVersion }\n\t\t}\n\t\treturn this.validateAndDecryptKeyPair(keyPair, keyPairGroupId, symGroupKey)\n\t}\n\n\tasync loadFormerGroupKeyInstance(group: Group, version: KeyVersion): Promise<GroupKey> {\n\t\tconst formerKeysList = assertNotNull(group.formerGroupKeys).list\n\t\treturn await this.entityClient.load(GroupKeyTypeRef, [formerKeysList, convertKeyVersionToCustomId(version)])\n\t}\n\n\t/**\n\t *\n\t * @param groupId MUST NOT be the user group id!\n\t * @private\n\t */\n\tprivate async loadAndDecryptCurrentSymGroupKey(groupId: Id) {\n\t\tif (isSameId(groupId, this.userFacade.getUserGroupId())) {\n\t\t\tthrow new ProgrammingError(\"Must not add the user group to the regular group key cache\")\n\t\t}\n\t\tconst groupMembership = this.userFacade.getMembership(groupId)\n\t\tconst requiredUserGroupKey = await this.loadSymUserGroupKey(parseKeyVersion(groupMembership.symKeyVersion))\n\t\treturn {\n\t\t\tversion: parseKeyVersion(groupMembership.groupKeyVersion),\n\t\t\tobject: decryptKey(requiredUserGroupKey, groupMembership.symEncGKey),\n\t\t}\n\t}\n\n\tprivate async findFormerGroupKey(\n\t\tgroup: Group,\n\t\tcurrentGroupKey: VersionedKey,\n\t\ttargetKeyVersion: KeyVersion,\n\t): Promise<{ symmetricGroupKey: AesKey; groupKeyInstance: GroupKey }> {\n\t\tconst formerKeysList = assertNotNull(group.formerGroupKeys).list\n\t\t// start id is not included in the result of the range request, so we need to start at current version.\n\t\tconst startId = convertKeyVersionToCustomId(currentGroupKey.version)\n\t\tconst amountOfKeysIncludingTarget = currentGroupKey.version - targetKeyVersion\n\n\t\tconst formerKeys: GroupKey[] = await this.entityClient.loadRange(GroupKeyTypeRef, formerKeysList, startId, amountOfKeysIncludingTarget, true)\n\n\t\tlet lastVersion = currentGroupKey.version\n\t\tlet lastGroupKey = currentGroupKey.object\n\t\tlet lastGroupKeyInstance: GroupKey | null = null\n\n\t\tfor (const formerKey of formerKeys) {\n\t\t\tconst version = this.decodeGroupKeyVersion(getElementId(formerKey))\n\t\t\tif (version + 1 > lastVersion) {\n\t\t\t\tcontinue\n\t\t\t} else if (version + 1 === lastVersion) {\n\t\t\t\tlastGroupKey = decryptKey(lastGroupKey, formerKey.ownerEncGKey)\n\t\t\t\tlastVersion = version\n\t\t\t\tlastGroupKeyInstance = formerKey\n\t\t\t\tif (lastVersion <= targetKeyVersion) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(`unexpected version ${version}; expected ${lastVersion}`)\n\t\t\t}\n\t\t}\n\n\t\tif (lastVersion !== targetKeyVersion || !lastGroupKeyInstance) {\n\t\t\tthrow new Error(`could not get version (last version is ${lastVersion} of ${formerKeys.length} key(s) loaded from list ${formerKeysList})`)\n\t\t}\n\n\t\treturn { symmetricGroupKey: lastGroupKey, groupKeyInstance: lastGroupKeyInstance }\n\t}\n\n\tprivate decodeGroupKeyVersion(id: Id): KeyVersion {\n\t\treturn parseKeyVersion(customIdToString(id))\n\t}\n\n\tprivate validateAndDecryptKeyPair(keyPair: KeyPair | null, groupId: Id, groupKey: VersionedKey) {\n\t\tif (keyPair == null) {\n\t\t\tthrow new NotFoundError(`no key pair on group ${groupId}`)\n\t\t}\n\t\t// this cast is acceptable as those are the constraints we have on KeyPair. we just cannot know which one we have statically\n\t\tconst decryptedKeyPair = decryptKeyPair(groupKey.object, keyPair as EncryptedKeyPairs)\n\t\tif (groupKey.version !== 0 && isRsaOrRsaEccKeyPair(decryptedKeyPair)) {\n\t\t\tthrow new CryptoError(\"received an rsa key pair in a version other than 0: \" + groupKey.version)\n\t\t}\n\t\treturn decryptedKeyPair\n\t}\n}\n\nfunction convertKeyVersionToCustomId(version: KeyVersion) {\n\treturn stringToCustomId(String(version))\n}\n\nexport function parseKeyVersion(version: NumberString): KeyVersion {\n\tconst versionAsNumber = Number(version)\n\treturn checkKeyVersionConstraints(versionAsNumber)\n}\n\nexport function checkKeyVersionConstraints(version: number): KeyVersion {\n\tif (!isKeyVersion(version)) {\n\t\tthrow new CryptoError(\"key version is not a non-negative integer\")\n\t}\n\treturn version\n}\n"]}