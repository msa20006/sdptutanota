{"version":3,"file":"ProgressTracker.js","sourceRoot":"","sources":["../../../../../src/common/api/main/ProgressTracker.ts"],"names":[],"mappings":"AAAA,OAAO,MAAM,MAAM,gBAAgB,CAAA;AAEnC,OAAO,EAAE,eAAe,EAAE,MAAM,iCAAiC,CAAA;AAIjE;;;;GAIG;AACH,MAAM,OAAO,eAAe;IAC3B,uCAAuC;IACvC,gBAAgB,CAAgB;IACf,QAAQ,CAAyC;IAC1D,SAAS,CAAmB;IAEpC;QACC,0DAA0D;QAC1D,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;QACjC,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAA;QACzB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAA;IACnB,CAAC;IAED;;;;;;OAMG;IACH,mBAAmB,CAAC,IAAY;QAC/B,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,EAAE,CAAA;QAC3B,MAAM,OAAO,GAAG,IAAI,eAAe,CAAC,IAAI,EAAE,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC,CAAA;QAE1F,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAA;QAE9B,OAAO,EAAE,CAAA;IACV,CAAC;IAED,+BAA+B;IAC/B,KAAK,CAAC,eAAe,CAAC,IAAY;QACjC,OAAO,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAA;IACtC,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,EAAqB,EAAE,MAAc;QAC7D,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAA;IACtC,CAAC;IAED,UAAU,CAAC,EAAqB;QAC/B,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,CAAA;IACrC,CAAC;IAEO,UAAU,CAAC,EAAqB,EAAE,UAAkB;QAC3D,SAAS;QACT,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,CAAA;QAC7C,iCAAiC;QACjC,IAAI,UAAU,IAAI,GAAG;YAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;IAChD,CAAC;IAED;;OAEG;IACH,SAAS;QACR,IAAI,KAAK,GAAG,CAAC,CAAA;QAEb,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC;YAC9C,KAAK,IAAI,OAAO,CAAC,SAAS,CAAA;QAC3B,CAAC;QAED,OAAO,KAAK,CAAA;IACb,CAAC;IAED;;OAEG;IACH,aAAa;QACZ,IAAI,KAAK,GAAG,CAAC,CAAA;QAEb,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC;YAC9C,KAAK,IAAI,OAAO,CAAC,aAAa,CAAA;QAC/B,CAAC;QAED,OAAO,KAAK,CAAA;IACb,CAAC;IAED;;OAEG;IACH,eAAe;QACd,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAA;QAClC,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,EAAE,CAAA;QAC1C,iDAAiD;QACjD,OAAO,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,aAAa,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;IACpE,CAAC;CACD","sourcesContent":["import stream from \"mithril/stream\"\nimport type { ProgressMonitorId } from \"../common/utils/ProgressMonitor\"\nimport { ProgressMonitor } from \"../common/utils/ProgressMonitor\"\n\nexport type ExposedProgressTracker = Pick<ProgressTracker, \"registerMonitor\" | \"workDoneForMonitor\">\n\n/**\n * The progress tracker controls the progress bar located in Header.js\n * You can register progress monitors with it and then make workDone calls on them\n * and then the total progress will be shown at the top of the window\n */\nexport class ProgressTracker {\n\t// Will stream a number between 0 and 1\n\tonProgressUpdate: stream<number>\n\tprivate readonly monitors: Map<ProgressMonitorId, ProgressMonitor>\n\tprivate idCounter: ProgressMonitorId\n\n\tconstructor() {\n\t\t// initially, there is no work, so we are done by default.\n\t\tthis.onProgressUpdate = stream(1)\n\t\tthis.monitors = new Map()\n\t\tthis.idCounter = 0\n\t}\n\n\t/**\n\t * Register a monitor with the tracker, so that it's progress can be displayed\n\t * Returns an ID as a handle, useful for making calls from the worker\n\t *\n\t * Make sure that monitor completes, so it can be unregistered.\n\t * @param work - total work to do\n\t */\n\tregisterMonitorSync(work: number): ProgressMonitorId {\n\t\tconst id = this.idCounter++\n\t\tconst monitor = new ProgressMonitor(work, (percentage) => this.onProgress(id, percentage))\n\n\t\tthis.monitors.set(id, monitor)\n\n\t\treturn id\n\t}\n\n\t/** async wrapper for remote */\n\tasync registerMonitor(work: number): Promise<ProgressMonitorId> {\n\t\treturn this.registerMonitorSync(work)\n\t}\n\n\tasync workDoneForMonitor(id: ProgressMonitorId, amount: number): Promise<void> {\n\t\tthis.getMonitor(id)?.workDone(amount)\n\t}\n\n\tgetMonitor(id: ProgressMonitorId): ProgressMonitor | null {\n\t\treturn this.monitors.get(id) ?? null\n\t}\n\n\tprivate onProgress(id: ProgressMonitorId, percentage: number) {\n\t\t// notify\n\t\tthis.onProgressUpdate(this.completedAmount())\n\t\t// we might be done with this one\n\t\tif (percentage >= 100) this.monitors.delete(id)\n\t}\n\n\t/**\n\t * Total work that will be done from all monitors\n\t */\n\ttotalWork(): number {\n\t\tlet total = 0\n\n\t\tfor (const monitor of this.monitors.values()) {\n\t\t\ttotal += monitor.totalWork\n\t\t}\n\n\t\treturn total\n\t}\n\n\t/**\n\t * Current absolute amount of completed work from all monitors\n\t */\n\tcompletedWork(): number {\n\t\tlet total = 0\n\n\t\tfor (const monitor of this.monitors.values()) {\n\t\t\ttotal += monitor.workCompleted\n\t\t}\n\n\t\treturn total\n\t}\n\n\t/**\n\t * Completed percentage of completed work as a number between 0 and 1\n\t */\n\tcompletedAmount(): number {\n\t\tconst totalWork = this.totalWork()\n\t\tconst completedWork = this.completedWork()\n\t\t// no work to do means you have done all the work\n\t\treturn totalWork !== 0 ? Math.min(1, completedWork / totalWork) : 1\n\t}\n}\n"]}