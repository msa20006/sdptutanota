{"version":3,"file":"NativeLineProtocol.js","sourceRoot":"","sources":["../../../../../src/common/native/common/NativeLineProtocol.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * this file contains the typescript implementation of the line protocol\n * for IPC used by the mobile apps that can't use the structured clone\n * algorithm.\n *\n * to prevent us from parsing the messages twice -- once as a dict to find\n * out the type and method, a second time to parse the arguments into\n * their actual types -- we use a line-based protocol. It supports\n * requests with arbitrary arguments, responses with a return value\n * and request errors with an attached error object and works as\n * follows:\n *\n * \tline\t\ttype\t\tcontent\t\t\t\tnote\n *  [1] \t\tall\t\t\t<type> \t\t\t\t\"request\", \"response\" or \"responseError\"\n *  [2]\t\t\tall\t\t\t<requestId>\t\t\ta string like \"main123\", responses and errors cite the original requestId\n *  [3]\t\t\trequest\t\t<method>\t\t\ta string method name to invoke\n *  [3]\t\t\tresponse\t<return>\t\t\tjson-encoded return value\n *  [3]\t\t\terror\t\t<error>\t\t\t\tjson-encoded error object\n *  [4]\t\t\trequest\t\t<arg0>\t\t\t\tjson-encoded first argument\n *  ...\n *  [n] \t\trequest\t\t<argx>\t\t\t\tjson-encoded last argument\n */\nimport { Message, Request, RequestError, Response } from \"../../api/common/threading/MessageDispatcher.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\nimport { base64ToUint8Array, uint8ArrayToBase64 } from \"@tutao/tutanota-utils\"\n\nexport type NativeMessage = Message<NativeRequestType>\nexport type JsMessage = Message<JsRequestType>\nexport type JsMessageHandler = (message: JsMessage) => unknown\n\n/**\n * serialize a native message to the line protocol used in the apps\n * @param message\n */\nexport function encodeNativeMessage(message: NativeMessage): string {\n\tlet encodedMessage: Array<string> = []\n\tencodedMessage.push(message.type)\n\tencodedMessage.push(message.id!)\n\tswitch (message.type) {\n\t\tcase \"request\":\n\t\t\tencodedMessage.push(message.requestType)\n\t\t\tif (message.args.length === 0) {\n\t\t\t\tencodedMessage.push(\"\")\n\t\t\t}\n\t\t\tfor (const arg of message.args) {\n\t\t\t\tencodedMessage.push(encodeValueForNative(arg))\n\t\t\t}\n\t\t\tbreak\n\t\tcase \"response\":\n\t\t\tencodedMessage.push(encodeValueForNative(message.value))\n\t\t\tbreak\n\t\tcase \"requestError\":\n\t\t\tencodedMessage.push(encodeValueForNative(message.error))\n\t\t\tbreak\n\t}\n\treturn encodedMessage.join(\"\\n\")\n}\n\nexport function encodeValueForNative(value: unknown): string {\n\treturn JSON.stringify(replaceBytesWithWrapper(value))\n}\n\nconst BYTES_MARKER = \"__bytes\"\n\nexport function replaceBytesWithWrapper(value: unknown): unknown {\n\tif (value == null) {\n\t\treturn null\n\t} else if (value instanceof Uint8Array) {\n\t\treturn { data: uint8ArrayToBase64(value), marker: BYTES_MARKER }\n\t} else if (Array.isArray(value)) {\n\t\treturn value.map(replaceBytesWithWrapper)\n\t} else if (typeof value === \"object\") {\n\t\tconst newObject: Record<string, any> = {}\n\t\tfor (const [key, field] of Object.entries(value)) {\n\t\t\tnewObject[key] = replaceBytesWithWrapper(field)\n\t\t}\n\t\treturn newObject\n\t} else {\n\t\treturn value\n\t}\n}\n\nexport function replaceWrapperByBytes(value: unknown): unknown {\n\tif (value == null) {\n\t\treturn null\n\t} else if (isByteWrapper(value)) {\n\t\treturn base64ToUint8Array(value.data)\n\t} else if (Array.isArray(value)) {\n\t\treturn value.map(replaceWrapperByBytes)\n\t} else if (typeof value === \"object\") {\n\t\tconst newObject: Record<string, any> = {}\n\t\tfor (const [key, field] of Object.entries(value)) {\n\t\t\tnewObject[key] = replaceWrapperByBytes(field)\n\t\t}\n\t\treturn newObject\n\t} else {\n\t\treturn value\n\t}\n}\n\nfunction isByteWrapper(value: unknown): value is { marker: typeof BYTES_MARKER; data: string } {\n\treturn (\n\t\tvalue != null &&\n\t\ttypeof value === \"object\" &&\n\t\t(value as Record<string, unknown>).marker === BYTES_MARKER &&\n\t\ttypeof (value as Record<string, unknown>).data === \"string\"\n\t)\n}\n\n/**\n * decode a string received over the native bridge in the apps into a native message object\n * @param encoded\n */\nexport function decodeNativeMessage(encoded: string): JsMessage {\n\tconst [type, messageId, ...rest] = encoded.split(\"\\n\")\n\tlet parsedMessage: Message<any>\n\tswitch (type) {\n\t\tcase \"request\": {\n\t\t\tconst [requestType, ...args] = rest\n\t\t\tparsedMessage = new Request(\n\t\t\t\trequestType,\n\t\t\t\targs.map((s) => decodeValueFromNative(s)),\n\t\t\t)\n\t\t\tparsedMessage.id = messageId\n\t\t\tbreak\n\t\t}\n\t\tcase \"response\": {\n\t\t\tconst [value] = rest\n\t\t\tparsedMessage = new Response(messageId, decodeValueFromNative(value))\n\t\t\tbreak\n\t\t}\n\t\tcase \"requestError\": {\n\t\t\tconst [error] = rest\n\t\t\tparsedMessage = new RequestError(messageId, decodeValueFromNative(error) as Error)\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t\t\tthrow new ProgrammingError(`unknown message type: ${type}`)\n\t}\n\treturn parsedMessage\n}\n\nexport function decodeValueFromNative(encoded: string): unknown {\n\treturn replaceWrapperByBytes(JSON.parse(encoded))\n}\n"]}