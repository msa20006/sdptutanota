{"version":3,"file":"CsvParser.js","sourceRoot":"","sources":["../../../../../src/common/misc/parsing/CsvParser.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Parser } from \"./ParserCombinator\"\nimport {\n\tcombineParsers,\n\tmakeCharacterParser,\n\tmakeEitherParser,\n\tmakeNotOneOfCharactersParser,\n\tmakeOneOrMoreParser,\n\tmakeSeparatedByParser,\n\tmakeZeroOrMoreParser,\n\tmapParser,\n\tParserError,\n\tStringIterator,\n} from \"./ParserCombinator\"\n\ntype ParsedCsv = {\n\trows: Array<Array<string>>\n}\ntype CsvParseOptions = {\n\tdelimiter: Delimiter\n}\ntype Delimiter = \",\" | \"|\" | \":\" | \";\"\nconst DEFAULT_CSV_PARSE_OPTIONS = {\n\tdelimiter: \",\",\n}\n\nexport function parseCsv(input: string, options?: Partial<CsvParseOptions>): ParsedCsv {\n\tconst { delimiter } = Object.assign({}, DEFAULT_CSV_PARSE_OPTIONS, options)\n\tconst lineDelimiterParser = makeOneOrMoreParser(makeCharacterParser(\"\\n\"))\n\tconst parser = makeSeparatedByParser(lineDelimiterParser, makeRowParser(delimiter))\n\tconst rows = parser(new StringIterator(input.replace(/\\r\\n/g, \"\\n\")))\n\treturn {\n\t\trows: rows,\n\t}\n}\n\nfunction makeRowParser(delimiter: Delimiter): Parser<Array<string>> {\n\treturn makeSeparatedByParser(makeCharacterParser(delimiter), makeColumnParser(delimiter))\n}\n\nfunction makeColumnParser(delimiter: Delimiter): Parser<string> {\n\treturn makeEitherParser(quotedColumnParser, makeUnquotedColumnParser(delimiter))\n}\n\nconst quotedColumnParser: Parser<string> = mapParser(\n\tcombineParsers(makeZeroOrMoreParser(makeCharacterParser(\" \")), parseQuotedColumn, makeZeroOrMoreParser(makeCharacterParser(\" \"))),\n\t(result) => result[1],\n)\n\n/**\n * Parse a column that is nonempty, doesn't contain any quotes, newlines, or delimiters\n * @param delimiter\n * @returns {Parser<*>}\n */\nfunction makeUnquotedColumnParser(delimiter: string): Parser<string> {\n\t// We don't use trim spaces parser because it won't remove trailing spaces in this case\n\treturn mapParser(makeZeroOrMoreParser(makeNotOneOfCharactersParser(['\"', \"\\n\", delimiter])), (arr) => arr.join(\"\"))\n}\n\n/**\n * Parse the inside of a double-quote quoted string, returning the string without the outer double-quotes\n * @param iterator\n */\nfunction parseQuotedColumn(iterator: StringIterator): string {\n\tconst initial = iterator.next()\n\n\tif (initial.done || initial.value !== '\"') {\n\t\tthrow new ParserError(\"expected quote\")\n\t}\n\n\tlet result = \"\"\n\n\twhile (true) {\n\t\tconst token = iterator.next()\n\n\t\tif (token.done) {\n\t\t\tthrow new ParserError(\"unexpected end of input\")\n\t\t}\n\n\t\tif (token.value === '\"') {\n\t\t\t// We will either be at an escaped quote, or at the end of the string\n\t\t\tif (iterator.peek() === '\"') {\n\t\t\t\t// It's escaped, append only a single quote to the result\n\t\t\t\titerator.next()\n\t\t\t\tresult += '\"'\n\t\t\t} else {\n\t\t\t\t// it's not escaped, so it's the final delimiter\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tresult += token.value\n\t\t}\n\t}\n\n\treturn result\n}\n"]}