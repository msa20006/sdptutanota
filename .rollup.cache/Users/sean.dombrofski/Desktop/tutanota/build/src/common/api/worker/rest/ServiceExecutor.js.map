{"version":3,"file":"ServiceExecutor.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/rest/ServiceExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpMethod, MediaType, resolveTypeReference } from \"../../common/EntityFunctions\"\nimport {\n\tDeleteService,\n\tExtraServiceParams,\n\tGetService,\n\tIServiceExecutor,\n\tMethodDefinition,\n\tParamTypeFromRef,\n\tPostService,\n\tPutService,\n\tReturnTypeFromRef,\n} from \"../../common/ServiceRequest.js\"\nimport { Entity } from \"../../common/EntityTypes\"\nimport { isSameTypeRef, lazy, TypeRef } from \"@tutao/tutanota-utils\"\nimport { RestClient } from \"./RestClient\"\nimport { InstanceMapper } from \"../crypto/InstanceMapper\"\nimport { CryptoFacade } from \"../crypto/CryptoFacade\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { AuthDataProvider } from \"../facades/UserFacade\"\nimport { LoginIncompleteError } from \"../../common/error/LoginIncompleteError.js\"\n\nassertWorkerOrNode()\n\ntype AnyService = GetService | PostService | PutService | DeleteService\n\nexport class ServiceExecutor implements IServiceExecutor {\n\tconstructor(\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly authDataProvider: AuthDataProvider,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly cryptoFacade: lazy<CryptoFacade>,\n\t) {}\n\n\tget<S extends GetService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"get\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"get\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.GET, data, params)\n\t}\n\n\tpost<S extends PostService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"post\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"post\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.POST, data, params)\n\t}\n\n\tput<S extends PutService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"put\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"put\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.PUT, data, params)\n\t}\n\n\tdelete<S extends DeleteService>(\n\t\tservice: S,\n\t\tdata: ParamTypeFromRef<S[\"delete\"][\"data\"]>,\n\t\tparams?: ExtraServiceParams,\n\t): Promise<ReturnTypeFromRef<S[\"delete\"][\"return\"]>> {\n\t\treturn this.executeServiceRequest(service, HttpMethod.DELETE, data, params)\n\t}\n\n\tprivate async executeServiceRequest(\n\t\tservice: AnyService,\n\t\tmethod: HttpMethod,\n\t\trequestEntity: Entity | null,\n\t\tparams: ExtraServiceParams | undefined,\n\t): Promise<any> {\n\t\tconst methodDefinition = this.getMethodDefinition(service, method)\n\t\tif (\n\t\t\tmethodDefinition.return &&\n\t\t\tparams?.sessionKey == null &&\n\t\t\t(await resolveTypeReference(methodDefinition.return)).encrypted &&\n\t\t\t!this.authDataProvider.isFullyLoggedIn()\n\t\t) {\n\t\t\t// Short-circuit before we do an actual request which we can't decrypt\n\t\t\t// If we have a session key passed it doesn't mean that it is for the return type but it is likely\n\t\t\t// so we allow the request.\n\t\t\tthrow new LoginIncompleteError(`Tried to make service request with encrypted return type but is not fully logged in yet, service: ${service.name}`)\n\t\t}\n\n\t\tconst modelVersion = await this.getModelVersion(methodDefinition)\n\n\t\tconst path = `/rest/${service.app.toLowerCase()}/${service.name.toLowerCase()}`\n\t\tconst headers = { ...this.authDataProvider.createAuthHeaders(), ...params?.extraHeaders, v: modelVersion }\n\n\t\tconst encryptedEntity = await this.encryptDataIfNeeded(methodDefinition, requestEntity, service, method, params ?? null)\n\n\t\tconst data: string | undefined = await this.restClient.request(path, method, {\n\t\t\tqueryParams: params?.queryParams,\n\t\t\theaders,\n\t\t\tresponseType: MediaType.Json,\n\t\t\tbody: encryptedEntity ?? undefined,\n\t\t\tsuspensionBehavior: params?.suspensionBehavior,\n\t\t\tbaseUrl: params?.baseUrl,\n\t\t})\n\n\t\tif (methodDefinition.return) {\n\t\t\treturn await this.decryptResponse(methodDefinition.return, data as string, params)\n\t\t}\n\t}\n\n\tprivate getMethodDefinition(service: AnyService, method: HttpMethod): MethodDefinition {\n\t\tswitch (method) {\n\t\t\tcase HttpMethod.GET:\n\t\t\t\treturn (service as GetService)[\"get\"]\n\t\t\tcase HttpMethod.POST:\n\t\t\t\treturn (service as PostService)[\"post\"]\n\t\t\tcase HttpMethod.PUT:\n\t\t\t\treturn (service as PutService)[\"put\"]\n\t\t\tcase HttpMethod.DELETE:\n\t\t\t\treturn (service as DeleteService)[\"delete\"]\n\t\t}\n\t}\n\n\tprivate async getModelVersion(methodDefinition: MethodDefinition): Promise<string> {\n\t\t// This is some kind of a hack because we don't generate data for the whole model anywhere (unfortunately).\n\t\tconst someTypeRef = methodDefinition.data ?? methodDefinition.return\n\t\tif (someTypeRef == null) {\n\t\t\tthrow new ProgrammingError(\"Need either data or return for the service method!\")\n\t\t}\n\t\tconst model = await resolveTypeReference(someTypeRef)\n\t\treturn model.version\n\t}\n\n\tprivate async encryptDataIfNeeded(\n\t\tmethodDefinition: MethodDefinition,\n\t\trequestEntity: Entity | null,\n\t\tservice: AnyService,\n\t\tmethod: HttpMethod,\n\t\tparams: ExtraServiceParams | null,\n\t): Promise<string | null> {\n\t\tif (methodDefinition.data != null) {\n\t\t\tif (requestEntity == null || !isSameTypeRef(methodDefinition.data, requestEntity._type)) {\n\t\t\t\tthrow new ProgrammingError(`Invalid service data! ${service.name} ${method}`)\n\t\t\t}\n\n\t\t\tconst requestTypeModel = await resolveTypeReference(methodDefinition.data)\n\t\t\tif (requestTypeModel.encrypted && params?.sessionKey == null) {\n\t\t\t\tthrow new ProgrammingError(\"Must provide a session key for an encrypted data transfer type!: \" + service)\n\t\t\t}\n\n\t\t\tconst encryptedEntity = await this.instanceMapper.encryptAndMapToLiteral(requestTypeModel, requestEntity, params?.sessionKey ?? null)\n\t\t\treturn JSON.stringify(encryptedEntity)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tprivate async decryptResponse<T extends Entity>(typeRef: TypeRef<T>, data: string, params: ExtraServiceParams | undefined): Promise<T> {\n\t\tconst responseTypeModel = await resolveTypeReference(typeRef)\n\t\t// Filter out __proto__ to avoid prototype pollution.\n\t\tconst instance = JSON.parse(data, (k, v) => (k === \"__proto__\" ? undefined : v))\n\t\tconst resolvedSessionKey = await this.cryptoFacade().resolveServiceSessionKey(instance)\n\t\treturn this.instanceMapper.decryptAndMapToInstance(responseTypeModel, instance, resolvedSessionKey ?? params?.sessionKey ?? null)\n\t}\n}\n"]}