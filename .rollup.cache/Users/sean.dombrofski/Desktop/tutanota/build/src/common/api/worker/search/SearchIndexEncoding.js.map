{"version":3,"file":"SearchIndexEncoding.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/search/SearchIndexEncoding.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwDG;AAEH;;;;;;;;GAQG;AACH,MAAM,UAAU,mBAAmB,CAAC,GAAe,EAAE,EAA8E;IAClI,IAAI,MAAM,GAAG,CAAC,CAAA;IACd,IAAI,UAAU,GAAG,CAAC,CAAA;IAElB,OAAO,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC;QAC5B,MAAM,KAAK,GAAG,iBAAiB,CAAC,GAAG,EAAE,MAAM,CAAC,CAAA;QAC5C,MAAM,KAAK,GAAG,MAAM,CAAA;QACpB,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,MAAM,CAAA;QACxC,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,CAAC,CAAA;IACvC,CAAC;IAED,OAAO,UAAU,CAAA;AAClB,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,uBAAuB,CAAC,GAAe,EAAE,MAA+B;IACvF,IAAI,aAAa,GAAG,CAAC,CAAA;IAErB,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC7C,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;QAC9B,GAAG,CAAC,UAAU,CAAC,KAAK,EAAE,GAAG,CAAC,CAAA;QAC1B,aAAa,IAAI,GAAG,GAAG,KAAK,CAAA;IAC7B,CAAC;IAED,OAAO,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,GAAG,aAAa,CAAC,CAAA;AACnD,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,kBAAkB,CAAC,MAAoB,EAAE,WAAwB;IAChF,MAAM,WAAW,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAA;IAChD,IAAI,MAAkB,CAAA;IACtB,IAAI,MAAM,CAAA;IAEV,IAAI,WAAW,EAAE,CAAC;QACjB,MAAM,GAAG,WAAW,CAAC,MAAM,CAAA;QAC3B,MAAM,GAAG,IAAI,UAAU,CAAC,WAAW,CAAC,MAAM,GAAG,WAAW,CAAC,CAAA;QACzD,kCAAkC;QAClC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAA;IACxB,CAAC;SAAM,CAAC;QACP,MAAM,GAAG,IAAI,UAAU,CAAC,WAAW,CAAC,CAAA;QACpC,MAAM,GAAG,CAAC,CAAA;IACX,CAAC;IAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACxC,MAAM,IAAI,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACvD,CAAC;IAED,OAAO,MAAM,CAAA;AACd,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,iBAAiB,CAAC,UAAsB,EAAE,MAAkB,EAAE,MAAc;IAC3F,wFAAwF;IACxF,MAAM,cAAc,GAAG,iBAAiB,CAAC,UAAU,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IAC3E,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,GAAG,cAAc,CAAC,CAAA;IAC/C,OAAO,cAAc,GAAG,UAAU,CAAC,MAAM,CAAA;AAC1C,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAa,EAAE,MAAkB,EAAE,MAAc;IAClF,0DAA0D;IAC1D,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;QACnB,MAAM,CAAC,MAAM,CAAC,GAAG,KAAK,CAAA;QACtB,OAAO,CAAC,CAAA;IACT,CAAC;SAAM,CAAC;QACP,uFAAuF;QACvF,8BAA8B;QAC9B,6CAA6C;QAC7C,MAAM,MAAM,GAAG,aAAa,CAAC,KAAK,CAAC,CAAA;QACnC,IAAI,cAAc,GAAG,KAAK,CAAA;QAC1B,uBAAuB;QACvB,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,GAAG,IAAI,CAAA;QAE9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACjC,MAAM,YAAY,GAAG,MAAM,GAAG,MAAM,GAAG,CAAC,CAAA;YAExC,sDAAsD;YACtD,IAAI,cAAc,GAAG,IAAI,EAAE,CAAC;gBAC3B,iDAAiD;gBACjD,MAAM,CAAC,YAAY,CAAC,GAAG,cAAc,GAAG,GAAG,CAAA;gBAC3C,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,GAAG,CAAC,CAAA;YAClD,CAAC;iBAAM,CAAC;gBACP,2BAA2B;gBAC3B,MAAM,CAAC,YAAY,CAAC,GAAG,cAAc,CAAA;YACtC,CAAC;QACF,CAAC;QAED,qBAAqB;QACrB,OAAO,MAAM,GAAG,CAAC,CAAA;IAClB,CAAC;AACF,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,iBAAiB,CAAC,MAAkB,EAAE,MAAc;IACnE,IAAI,WAAW,GAAG,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IACnD,IAAI,YAAY,GAAG,6BAA6B,CAAC,WAAW,CAAC,CAAA;IAC7D,OAAO,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,YAAY,EAAE,MAAM,GAAG,YAAY,GAAG,WAAW,CAAC,CAAA;AACnF,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,iBAAiB,CAAC,MAAkB,EAAE,MAAc;IACnE,uEAAuE;IACvE,eAAe;IACf,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAA;IAEvC,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;QACxB,kDAAkD;QAClD,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAA;QAC1C,IAAI,KAAK,GAAG,CAAC,CAAA;QAEb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE,CAAC;YACvC,2CAA2C;YAC3C,KAAK,GAAG,KAAK,GAAG,GAAG,CAAA;YACnB,KAAK,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAA;QAChC,CAAC;QAED,OAAO,KAAK,CAAA;IACb,CAAC;SAAM,CAAC;QACP,yBAAyB;QACzB,OAAO,MAAM,CAAC,MAAM,CAAC,CAAA;IACtB,CAAC;AACF,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,oBAAoB,CAAC,IAAkB;IACtD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE;QACjC,qEAAqE;QACrE,IAAI,cAAc,GAAG,6BAA6B,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;QAChE,OAAO,GAAG,GAAG,KAAK,CAAC,MAAM,GAAG,cAAc,CAAA;IAC3C,CAAC,EAAE,CAAC,CAAC,CAAA;AACN,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,6BAA6B,CAAC,KAAa;IAC1D,uCAAuC;IACvC,qEAAqE;IACrE,OAAO,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;AACpD,CAAC;AAED,MAAM,UAAU,8BAA8B,CAAC,OAAsB;IACpE,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,6BAA6B,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;AAC7E,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,MAAc;IAC3C,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;AAC5C,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,aAAa,CAAC,aAAyB,EAAE,SAAiB,CAAC;IAC1E,MAAM,OAAO,GAAa,EAAE,CAAA;IAE5B,OAAO,MAAM,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC;QACtC,MAAM,MAAM,GAAG,iBAAiB,CAAC,aAAa,EAAE,MAAM,CAAC,CAAA;QACvD,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QACpB,MAAM,IAAI,6BAA6B,CAAC,MAAM,CAAC,CAAA;IAChD,CAAC;IAED,OAAO,OAAO,CAAA;AACf,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,aAAa,CAAC,OAAiB,EAAE,MAAkB,EAAE,SAAiB,CAAC;IACtF,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;QAC9B,MAAM,IAAI,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACpD,CAAC;AACF,CAAC","sourcesContent":["/**\n * @fileoverview SearchIndexEncoding: binary encoding for certain search index columns\n *\n * <b>Purpose</b>\n *\n * We use it primarily because storing data in many tiny {@code Uint8Array}'s is very inefficient,\n * mostly GC wise. Not only many objects create GC pressure by themselves, but they also consume\n * much more memory because each element has a lot of pointers.\n * Besides that, this encoding can encode certain thing with very little space. E.g. let's say\n * you want to encode object like {@code {app: 1, type: 10234}}. You could convert it to JSON,\n * then convert to to binary and then save it. EcmaScript strings use 2 bytes per character.\n * That means that JSON \"{app:1,type:10234}\" (18 chars) would use 18*2=36 bytes.\n * With this binary encoding we would encode it as just two numbers, first one in one byte,\n * second one we would use three bytes (one for length of the number and two for the\n * actual number, more on format below) so in total 1+3=4 bytes.\n *\n * <b>Format</b>\n *\n * We encode two types of data: numbers and binary blocks.\n * For numbers we use the following encoding:\n * - If the number fits into 7 bits (smaller than 127), then the first byte represents the number\n * - If it doesn't fit, then the highest bit of the byte is set. The rest of the bits signify\n * the number of following bytes which encode the number.\n *\n * Example:\n * <pre>\n * number | bytes\n * ––––––––––––––––\n * 3      | [0000 0011]\n * 127    | [0111 1111]\n * 128    | [1000 0001] [1000 0000]\n * 10234  | [1000 0002] [0010 0111][1111 1010]\n * </pre>\n *\n * For binary blocks we use similar principle. First we encode length of the binary data\n * in the number format described above (as number of used bytes). After that we write binary data.\n * <pre>[length of first block][binary block] [length of second block] [binary block] ... [length of n block][binary block]</pre>\n *\n * Example:\n * <pre>\n * Storing 2 bytes [0xFF, 0xFF]\n *\n * length of binary data | data\n * -------------------------------------------------------------------\n * [0000 0010]             [0xFF, 0xFF]\n *\n * Storing 500 bytes [0xFF, 0xFF,.., 0xFF]\n *\n * length of length | length of binary data | data\n * -------------------------------------------------------------------\n * [1000 0010]       [0000 0001] [1111 0100] [0xFF, 0xFF,.., 0xFF]\n * </pre>\n *\n * <b>Interface</b>\n * In many functions we pass offset instead of passing a subarray. We do this to allocate less objects\n * ({@code Uint8Array}'s are quite expensive).\n */\n\n/**\n * Invoke {@param cb} for each binary block in a {@param row}.\n * Callback parameters:\n * block: found block (without length prefix, only actual data)\n * start: start of the total block, including prefix\n * end: end of the block (this index is not included in the data)\n * iteration: number of the current block.\n * @returns {number} Total number of found blocks\n */\nexport function iterateBinaryBlocks(row: Uint8Array, cb: (block: Uint8Array, start: number, end: number, iteration: number) => void): number {\n\tlet offset = 0\n\tlet iterations = 0\n\n\twhile (offset < row.length) {\n\t\tconst block = decodeBinaryBlock(row, offset)\n\t\tconst start = offset\n\t\toffset = block.byteOffset + block.length\n\t\tcb(block, start, offset, iterations++)\n\t}\n\n\treturn iterations\n}\n\n/**\n * Remove specified {@param ranges} from the {@param row}.\n * In each range start is included, end is excluded (like in {@link iterateBinaryBlocks}.\n * Ranges should be ordered in ascending order and non-overlapping.\n * It is intended to be used with {@link iterateBinaryBlocks}.\n * @returns {Uint8Array} row with ranges removes and length reduced\n */\nexport function removeBinaryBlockRanges(row: Uint8Array, ranges: Array<[number, number]>): Uint8Array {\n\tlet reducedLength = 0\n\n\tfor (let i = ranges.length - 1; i >= 0; i--) {\n\t\tconst [start, end] = ranges[i]\n\t\trow.copyWithin(start, end)\n\t\treducedLength += end - start\n\t}\n\n\treturn row.subarray(0, row.length - reducedLength)\n}\n\n/**\n * Encode all blocks from {@param source} and append into the {@param destination} (if present) or\n * into a new buffer.\n * @returns {Uint8Array} Resulting buffer\n */\nexport function appendBinaryBlocks(source: Uint8Array[], destination?: Uint8Array): Uint8Array {\n\tconst neededSpace = calculateNeededSpace(source)\n\tlet target: Uint8Array\n\tlet offset\n\n\tif (destination) {\n\t\toffset = destination.length\n\t\ttarget = new Uint8Array(destination.length + neededSpace)\n\t\t// Copy from destination to target\n\t\ttarget.set(destination)\n\t} else {\n\t\ttarget = new Uint8Array(neededSpace)\n\t\toffset = 0\n\t}\n\n\tfor (let i = 0; i < source.length; i++) {\n\t\toffset += encodeBinaryBlock(source[i], target, offset)\n\t}\n\n\treturn target\n}\n\n/**\n * Encode (length and data itself) and write {@param entityData} into {@param target} at specified {@param offset}.\n * target must have enough space to fit encoded data (incl. length prefix). {@see calculateNeededSpace}.\n * @returns {number} New offset after the written block\n */\nexport function encodeBinaryBlock(entityData: Uint8Array, target: Uint8Array, offset: number): number {\n\t// Encode length as number (either as one byte or as length of length and length itself)\n\tconst lengthOfPrefix = encodeNumberBlock(entityData.length, target, offset)\n\ttarget.set(entityData, offset + lengthOfPrefix)\n\treturn lengthOfPrefix + entityData.length\n}\n\n/**\n * Encode number either in compact format (single byte) or in multiple bytes (length of number &\n * number itself). Maximum number which fits is 2^127 (it's large).\n * Target should have enough space {@see calculateNeededSpaceForNumber}.\n * @param value the number to encode\n * @param target where to put encoded number\n * @param offset where to put encoded number\n * @returns {number} offset after the encoded number\n */\nexport function encodeNumberBlock(value: number, target: Uint8Array, offset: number): number {\n\t// If value is less than 127 (7 bits), just write it as is\n\tif (value <= 0x7f) {\n\t\ttarget[offset] = value\n\t\treturn 1\n\t} else {\n\t\t// If number doesn't fit into seven bits, then first write it's length into this 7 bits\n\t\t// and then the number itself.\n\t\t// How many bytes we need to store the number\n\t\tconst length = numberOfBytes(value)\n\t\tlet remainingValue = value\n\t\t// Set highest bit to 1\n\t\ttarget[offset] = length | 0x80\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst bytePosition = offset + length - i\n\n\t\t\t// If what's left doesn't fit into this byte, split it\n\t\t\tif (remainingValue > 0xff) {\n\t\t\t\t// like shifting right by 8 but without overflows\n\t\t\t\ttarget[bytePosition] = remainingValue % 256\n\t\t\t\tremainingValue = Math.floor(remainingValue / 256)\n\t\t\t} else {\n\t\t\t\t// if it does fit, write it\n\t\t\t\ttarget[bytePosition] = remainingValue\n\t\t\t}\n\t\t}\n\n\t\t// One bit for length\n\t\treturn length + 1\n\t}\n}\n\n/**\n * Read end decode binary block. Returned block shares buffer with {@param source}.\n * @param source Where to read data from\n * @param offset At which offset to read data from\n * @returns {Uint8Array} Decoded data (without length prefix)\n */\nexport function decodeBinaryBlock(source: Uint8Array, offset: number): Uint8Array {\n\tlet blockLength = decodeNumberBlock(source, offset)\n\tlet numberLength = calculateNeededSpaceForNumber(blockLength)\n\treturn source.subarray(offset + numberLength, offset + numberLength + blockLength)\n}\n\n/**\n * Read and decode number block. We don't return the length of the encoded number to\n * not allocate anything. Check {@code source[0]} or use\n * {@link calculateNeededSpaceForNumber}.\n * @param source Where to read number from\n * @param offset At which offset to read number\n * @returns {number} Decoded number\n */\nexport function decodeNumberBlock(source: Uint8Array, offset: number): number {\n\t// Check the first bit. If it's 1, it's a long number, if it's not it's\n\t// a short one.\n\tconst markerBit = source[offset] & 0x80\n\n\tif (markerBit === 0x80) {\n\t\t// Clear the first bit to get the length of number\n\t\tconst numberLength = source[offset] & 0x7f\n\t\tlet value = 0\n\n\t\tfor (let i = 0; i < numberLength; i++) {\n\t\t\t// Like shifting left but without overflows\n\t\t\tvalue = value * 256\n\t\t\tvalue += source[offset + i + 1]\n\t\t}\n\n\t\treturn value\n\t} else {\n\t\t// Just return the number\n\t\treturn source[offset]\n\t}\n}\n\n/**\n * Precalculate how much space do we need to write encoded blocks of {@param data}.\n * @returns {number} Number of bytes which we need to write encoded data.\n */\nexport function calculateNeededSpace(data: Uint8Array[]): number {\n\treturn data.reduce((acc, entry) => {\n\t\t// Prefix is just a length of data in bytes (in short or a long form)\n\t\tlet lengthOfPrefix = calculateNeededSpaceForNumber(entry.length)\n\t\treturn acc + entry.length + lengthOfPrefix\n\t}, 0)\n}\n\n/**\n * Find out how many bytes do we need to encode {@param value}\n */\nexport function calculateNeededSpaceForNumber(value: number): number {\n\t// If it's small, it fits into one byte\n\t// otherwise it's number of bytes to represent the number plus length\n\treturn value <= 0x7f ? 1 : numberOfBytes(value) + 1\n}\n\nexport function calculateNeededSpaceForNumbers(numbers: Array<number>): number {\n\treturn numbers.reduce((acc, n) => acc + calculateNeededSpaceForNumber(n), 0)\n}\n\n/**\n * Number of bytes needed to encode the number\n */\nexport function numberOfBytes(number: number): number {\n\treturn Math.ceil(Math.log2(number + 1) / 8)\n}\n\n/**\n * Read array of encoded numbers. Assumes that they're in the end of the {@param binaryNumbers}!\n * @param binaryNumbers Block with numbers encoded\n * @param offset At which offset to read numbers\n * @returns {Array<number>} Numbers which have been read\n */\nexport function decodeNumbers(binaryNumbers: Uint8Array, offset: number = 0): number[] {\n\tconst numbers: number[] = []\n\n\twhile (offset < binaryNumbers.length) {\n\t\tconst number = decodeNumberBlock(binaryNumbers, offset)\n\t\tnumbers.push(number)\n\t\toffset += calculateNeededSpaceForNumber(number)\n\t}\n\n\treturn numbers\n}\n\n/**\n * Encode array of numbers. Doesn't write how many numbers there are.\n * @param numbers Numbers to encode\n * @param target Where to write them\n * @param offset At which offset they should be written\n */\nexport function encodeNumbers(numbers: number[], target: Uint8Array, offset: number = 0): void {\n\tfor (const number of numbers) {\n\t\toffset += encodeNumberBlock(number, target, offset)\n\t}\n}\n"]}