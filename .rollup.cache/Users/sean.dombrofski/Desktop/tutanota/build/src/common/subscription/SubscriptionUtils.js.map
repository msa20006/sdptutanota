{"version":3,"file":"SubscriptionUtils.js","sourceRoot":"","sources":["../../../../src/common/subscription/SubscriptionUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TranslationKey } from \"../misc/LanguageViewModel\"\nimport {\n\tAccountType,\n\tAvailablePlanType,\n\tBookingItemFeatureType,\n\tgetClientType,\n\tgetPaymentMethodType,\n\tNewPaidPlans,\n\tPaymentMethodType,\n\tPlanType,\n\tPlanTypeToName,\n} from \"../api/common/TutanotaConstants\"\nimport type { AccountingInfo, Customer, CustomerInfo, PlanConfiguration } from \"../api/entities/sys/TypeRefs.js\"\nimport { Booking, createPaymentDataServiceGetData } from \"../api/entities/sys/TypeRefs.js\"\nimport { isEmpty, LazyLoaded } from \"@tutao/tutanota-utils\"\nimport { locator } from \"../api/main/CommonLocator\"\nimport { PaymentDataService } from \"../api/entities/sys/Services\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\nimport { IServiceExecutor } from \"../api/common/ServiceRequest.js\"\nimport { MobilePaymentSubscriptionOwnership } from \"../native/common/generatedipc/MobilePaymentSubscriptionOwnership.js\"\n\nexport const enum UpgradeType {\n\tSignup = \"Signup\",\n\t// during signup\n\tInitial = \"Initial\",\n\t// when logged into Free account\n\tSwitch = \"Switch\", // switching in paid account\n}\n\nexport function getCurrentCount(featureType: BookingItemFeatureType, booking: Booking | null): number {\n\tif (booking) {\n\t\tlet bookingItem = booking.items.find((item) => item.featureType === featureType)\n\t\treturn bookingItem ? Number(bookingItem.currentCount) : 0\n\t} else {\n\t\treturn 0\n\t}\n}\n\n/**\n * Returns the available storage capacity for the customer in GB\n */\nexport function getTotalStorageCapacityPerCustomer(customer: Customer, customerInfo: CustomerInfo, lastBooking: Booking | null): number {\n\tlet freeStorageCapacity = getIncludedStorageCapacityPerCustomer(customerInfo)\n\n\tif (customer.type === AccountType.PAID) {\n\t\treturn Math.max(freeStorageCapacity, getCurrentCount(BookingItemFeatureType.Storage, lastBooking))\n\t} else {\n\t\treturn freeStorageCapacity\n\t}\n}\n\nfunction getIncludedStorageCapacityPerCustomer(customerInfo: CustomerInfo): number {\n\treturn Math.max(Number(customerInfo.includedStorageCapacity), Number(customerInfo.promotionStorageCapacity))\n}\n\nexport function isWhitelabelActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn getCurrentCount(BookingItemFeatureType.Whitelabel, lastBooking) !== 0 || planConfig.whitelabel\n}\n\nexport function isSharingActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn getCurrentCount(BookingItemFeatureType.Sharing, lastBooking) !== 0 || planConfig.sharing\n}\n\nfunction isBusinessFeatureActive(lastBooking: Booking | null): boolean {\n\treturn getCurrentCount(BookingItemFeatureType.Business, lastBooking) !== 0\n}\n\nexport function isEventInvitesActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn isBusinessFeatureActive(lastBooking) || planConfig.eventInvites\n}\n\nexport function isAutoResponderActive(lastBooking: Booking | null, planConfig: PlanConfiguration): boolean {\n\treturn isBusinessFeatureActive(lastBooking) || planConfig.autoResponder\n}\n\nexport type PaymentErrorCode =\n\t| \"paypal.change\"\n\t| \"paypal.confirm_again\"\n\t| \"paypal.other_source\"\n\t| \"card.contact_bank\"\n\t| \"card.insufficient_funds\"\n\t| \"card.expired_card\"\n\t| \"card.change\"\n\t| \"card.3ds2_needed\"\n\t| \"card.3ds2_pending\"\n\t| \"card.3ds2_failed\"\n\t| \"card.cvv_invalid\"\n\t| \"card.number_invalid\"\n\t| \"card.date_invalid\"\n\nexport function getPreconditionFailedPaymentMsg(data: string | null): TranslationKey {\n\t// the type is mostly there to keep multiple locations that switch over these in sync\n\tswitch (data as PaymentErrorCode) {\n\t\tcase \"paypal.change\":\n\t\t\treturn \"payChangeError_msg\"\n\n\t\tcase \"paypal.confirm_again\":\n\t\t\treturn \"payPaypalConfirmAgainError_msg\"\n\n\t\tcase \"paypal.other_source\":\n\t\t\treturn \"payPaypalChangeSourceError_msg\"\n\n\t\tcase \"card.contact_bank\":\n\t\t\treturn \"payCardContactBankError_msg\"\n\n\t\tcase \"card.insufficient_funds\":\n\t\t\treturn \"payCardInsufficientFundsError_msg\"\n\n\t\tcase \"card.expired_card\":\n\t\t\treturn \"payCardExpiredError_msg\"\n\n\t\tcase \"card.change\":\n\t\t\treturn \"payChangeError_msg\"\n\n\t\tcase \"card.3ds2_needed\":\n\t\t\treturn \"creditCardPaymentErrorVerificationNeeded_msg\"\n\n\t\tcase \"card.3ds2_pending\":\n\t\t\treturn \"creditCardPendingVerification_msg\"\n\n\t\tcase \"card.3ds2_failed\":\n\t\t\treturn \"creditCardVerificationFailed_msg\"\n\n\t\tcase \"card.cvv_invalid\":\n\t\t\treturn \"creditCardCVVInvalid_msg\"\n\n\t\tcase \"card.number_invalid\":\n\t\t\treturn \"creditCardNumberInvalid_msg\"\n\n\t\tcase \"card.date_invalid\":\n\t\t\treturn \"creditCardExprationDateInvalid_msg\"\n\n\t\tdefault:\n\t\t\treturn \"payContactUsError_msg\"\n\t}\n}\n\nexport function getLazyLoadedPayPalUrl(): LazyLoaded<string> {\n\treturn new LazyLoaded(async () => {\n\t\tconst clientType = getClientType()\n\t\tconst result = await locator.serviceExecutor.get(\n\t\t\tPaymentDataService,\n\t\t\tcreatePaymentDataServiceGetData({\n\t\t\t\tclientType,\n\t\t\t}),\n\t\t)\n\t\treturn result.loginUrl\n\t})\n}\n\n/**\n * only to be invoked for PlanTypes where isNewPlan returns true\n */\nexport function toFeatureType(type: PlanType): BookingItemFeatureType {\n\tswitch (type) {\n\t\tcase PlanType.Revolutionary:\n\t\t\treturn BookingItemFeatureType.Revolutionary\n\t\tcase PlanType.Legend:\n\t\t\treturn BookingItemFeatureType.Legend\n\t\tcase PlanType.Essential:\n\t\t\treturn BookingItemFeatureType.Essential\n\t\tcase PlanType.Advanced:\n\t\t\treturn BookingItemFeatureType.Advanced\n\t\tcase PlanType.Unlimited:\n\t\t\treturn BookingItemFeatureType.Unlimited\n\t\tcase PlanType.Premium:\n\t\t\treturn BookingItemFeatureType.LegacyUsers\n\t\tdefault:\n\t\t\tthrow new Error(`can't convert ${type} to BookingItemFeatureType`)\n\t}\n}\n\n/**\n * Get plans that are available for purchase and that comply with the given criteria.\n * @param serviceExecutor\n * @param predicate\n */\nexport async function getAvailableMatchingPlans(\n\tserviceExecutor: IServiceExecutor,\n\tpredicate: (configuration: PlanConfiguration) => boolean,\n): Promise<Array<AvailablePlanType>> {\n\tconst { PriceAndConfigProvider } = await import(\"../subscription/PriceUtils.js\")\n\tconst priceAndConfigProvider = await PriceAndConfigProvider.getInitializedInstance(null, serviceExecutor, null)\n\treturn NewPaidPlans.filter((p) => {\n\t\tconst config = priceAndConfigProvider.getPlanPricesForPlan(p).planConfiguration\n\t\treturn predicate(config)\n\t})\n}\n\n/**\n * Filter for plans a customer can upgrade to that include a feature, assuming that the feature must be available on at least one plan.\n * @param predicate the criterion to select plans by\n * @param errorMessage the error message to throw in case no plan satisfies the criterion\n */\nasync function getAtLeastOneAvailableMatchingPlan(\n\tpredicate: (configuration: PlanConfiguration) => boolean,\n\terrorMessage: string,\n): Promise<Array<AvailablePlanType>> {\n\tconst plans = await getAvailableMatchingPlans(locator.serviceExecutor, predicate)\n\tif (isEmpty(plans)) {\n\t\tthrow new ProgrammingError(errorMessage)\n\t}\n\treturn plans\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Whitelabel feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithWhitelabel(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.whitelabel, \"no available plan with the Whitelabel feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Whitelabel feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithTemplates(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.templates, \"no available plan with the Templates feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Sharing feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithSharing(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.sharing, \"no available plan with the Sharing feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Event Invites feature.\n */\nexport async function getAvailablePlansWithEventInvites(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.eventInvites, \"no available plan with the Event Invites feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Auto-Responder feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithAutoResponder(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.autoResponder, \"no available plan with the Auto-Responder feature\")\n}\n\n/**\n * Get plans that a customer can upgrade to that include the Contact List feature.\n * @throws ProgrammingError if no plans include it.\n */\nexport async function getAvailablePlansWithContactList(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.contactList, \"no available plan with the Contact List feature\")\n}\n\nexport async function getAvailablePlansWithCalendarInvites(): Promise<Array<AvailablePlanType>> {\n\treturn getAtLeastOneAvailableMatchingPlan((config) => config.eventInvites, \"no available plan with the Calendar Invite feature\")\n}\n\n/** name of the plan/product how it is expected by iOS AppStore */\nexport function appStorePlanName(planType: PlanType): string {\n\treturn PlanTypeToName[planType].toLowerCase()\n}\n\n/** does current user has an active (non-expired) AppStore subscription? */\nexport function hasRunningAppStoreSubscription(accountingInfo: AccountingInfo): boolean {\n\treturn getPaymentMethodType(accountingInfo) === PaymentMethodType.AppStore && accountingInfo.appStoreSubscription != null\n}\n\n/** Check if the latest transaction using the current Store Account belongs to the user */\nexport async function queryAppStoreSubscriptionOwnership(userIdBytes: Uint8Array | null): Promise<MobilePaymentSubscriptionOwnership> {\n\treturn await locator.mobilePaymentsFacade.queryAppStoreSubscriptionOwnership(userIdBytes)\n}\n"]}