{"version":3,"file":"DefaultEntityRestCache.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/rest/DefaultEntityRestCache.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tCacheMode,\n\tEntityRestClient,\n\tEntityRestClientEraseOptions,\n\tEntityRestClientLoadOptions,\n\tEntityRestClientSetupOptions,\n\tEntityRestInterface,\n\tgetCacheModeBehavior,\n\tOwnerEncSessionKeyProvider,\n} from \"./EntityRestClient\"\nimport { resolveTypeReference } from \"../../common/EntityFunctions\"\nimport { OperationType } from \"../../common/TutanotaConstants\"\nimport { assertNotNull, difference, getFirstOrThrow, getTypeId, groupBy, isSameTypeRef, lastThrow, TypeRef } from \"@tutao/tutanota-utils\"\nimport {\n\tAuditLogEntryTypeRef,\n\tBucketPermissionTypeRef,\n\tEntityEventBatchTypeRef,\n\tEntityUpdate,\n\tGroupKeyTypeRef,\n\tKeyRotationTypeRef,\n\tPermissionTypeRef,\n\tRecoverCodeTypeRef,\n\tRejectedSenderTypeRef,\n\tSecondFactorTypeRef,\n\tSessionTypeRef,\n\tUser,\n\tUserGroupKeyDistributionTypeRef,\n\tUserGroupRootTypeRef,\n\tUserTypeRef,\n} from \"../../entities/sys/TypeRefs.js\"\nimport { ValueType } from \"../../common/EntityConstants.js\"\nimport { NotAuthorizedError, NotFoundError } from \"../../common/error/RestError\"\nimport { CalendarEventUidIndexTypeRef, MailDetailsBlobTypeRef, MailSetEntry, MailSetEntryTypeRef, MailTypeRef } from \"../../entities/tutanota/TypeRefs.js\"\nimport { CUSTOM_MAX_ID, CUSTOM_MIN_ID, firstBiggerThanSecond, GENERATED_MAX_ID, GENERATED_MIN_ID, getElementId } from \"../../common/utils/EntityUtils\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport type { ListElementEntity, SomeEntity, TypeModel } from \"../../common/EntityTypes\"\nimport { QueuedBatch } from \"../EventQueue.js\"\nimport { ENTITY_EVENT_BATCH_EXPIRE_MS } from \"../EventBusClient\"\nimport { CustomCacheHandlerMap } from \"./CustomCacheHandler.js\"\nimport { containsEventOfType, EntityUpdateData, getEventOfType } from \"../../common/utils/EntityUpdateUtils.js\"\nimport { isCustomIdType } from \"../offline/OfflineStorage.js\"\n\nassertWorkerOrNode()\n\n/**\n *\n * The minimum size of a range request when extending an existing range\n * Because we extend by making (potentially) many range requests until we reach the startId\n * We want to avoid that the requests are too small\n */\nexport const EXTEND_RANGE_MIN_CHUNK_SIZE = 40\nconst IGNORED_TYPES = [\n\tEntityEventBatchTypeRef,\n\tPermissionTypeRef,\n\tBucketPermissionTypeRef,\n\tSessionTypeRef,\n\tSecondFactorTypeRef,\n\tRecoverCodeTypeRef,\n\tRejectedSenderTypeRef,\n\t// when doing automatic calendar updates, we will miss uid index entity updates if we're using the cache.\n\t// this is mainly caused by some calendaring apps sending the same update multiple times in the same mail.\n\t// the earliest place where we could deduplicate would be in entityEventsReceived on the calendarModel.\n\tCalendarEventUidIndexTypeRef,\n\tKeyRotationTypeRef,\n\tUserGroupRootTypeRef,\n\tUserGroupKeyDistributionTypeRef,\n\tAuditLogEntryTypeRef, // Should not be part of cached data because there are errors inside entity event processing after rotating the admin group key\n] as const\n\n/**\n * List of types containing a customId that we want to explicitly enable caching for.\n * CustomId types are not cached by default because their id is using base64UrlEncoding while GeneratedUId types are using base64Ext encoding.\n * base64Url encoding results in a different sort order of elements that we have on the server, this is problematic for caching LET and their ranges.\n * When enabling caching for customId types we convert the id that we store in cache from base64Url to base64Ext so we have the same sort order. (see function\n * OfflineStorage.ensureBase64Ext). In theory, we can try to enable caching for all types but as of now we enable it for a limited amount of types because there\n * are other ways to cache customId types (see implementation of CustomCacheHandler)\n */\nconst CACHEABLE_CUSTOMID_TYPES = [MailSetEntryTypeRef, GroupKeyTypeRef] as const\n\nexport interface EntityRestCache extends EntityRestInterface {\n\t/**\n\t * Clear out the contents of the cache.\n\t */\n\tpurgeStorage(): Promise<void>\n\n\t/**\n\t * Get the batch id of the most recently processed batch for the given group.\n\t */\n\tgetLastEntityEventBatchForGroup(groupId: Id): Promise<Id | null>\n\n\t/**\n\t * Saved tha batch id of the most recently processed batch manually.\n\t *\n\t * Is needed when the cache is new but we want to make sure that the next time we will download from this moment, even if we don't receive any events.\n\t */\n\tsetLastEntityEventBatchForGroup(groupId: Id, batchId: Id): Promise<void>\n\n\t/**\n\t * Persist the last time client downloaded event batches. This is not the last *processed* item, merely when things were *downloaded*. We use it to\n\t * detect out-of-sync.\n\t */\n\trecordSyncTime(): Promise<void>\n\n\t/**\n\t * Fetch the time since last time we downloaded event batches.\n\t */\n\ttimeSinceLastSyncMs(): Promise<number | null>\n\n\t/**\n\t * Detect if out of sync based on stored \"lastUpdateTime\" and the current server time\n\t */\n\tisOutOfSync(): Promise<boolean>\n}\n\nexport type Range = { lower: Id; upper: Id }\n\nexport type LastUpdateTime = { type: \"recorded\"; time: number } | { type: \"never\" } | { type: \"uninitialized\" }\n\n/**\n * Part of the cache storage only with subset of CacheStorage functionality\n *\n * Separate from the rest of the cache as a narrow interface to not expose the whole storage for cases where we want to only get the cached part of the list to\n * display it even if we can't load the full page from the server or need some metadata.\n *\n * also exposes functions to repair an outdated cache in case we can't access the server without getting a new version of a cached entity\n * (mainly password changes)\n */\nexport interface ExposedCacheStorage {\n\tget<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<T | null>\n\n\t/**\n\t * Load range of entities. Does not include {@param start}.\n\t * If {@param reverse} is false then returns entities newer than {@param start} in ascending order sorted by\n\t * elementId.\n\t * If {@param reverse} is true then returns entities older than {@param start} in descending order sorted by\n\t * elementId.\n\t */\n\tprovideFromRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, start: Id, count: number, reverse: boolean): Promise<T[]>\n\n\t/**\n\t * Load a set of list element entities by id. Missing elements are not returned, no error is thrown.\n\t */\n\tprovideMultiple<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, elementIds: Id[]): Promise<Array<T>>\n\n\t/**\n\t * retrieve all list elements that are in the cache\n\t * @param typeRef\n\t * @param listId\n\t */\n\tgetWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<T>>\n\n\tgetLastUpdateTime(): Promise<LastUpdateTime>\n\n\tclearExcludedData(): Promise<void>\n\n\t/**\n\t * remove an ElementEntity from the cache by typeRef and Id.\n\t * the exposed interface is intentionally more narrow than the internal cacheStorage because\n\t * we must maintain the integrity of our list ranges.\n\t * */\n\tdeleteIfExists<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<void>\n\n\t/** delete all instances of the given type that share {@param listId}. also deletes the range of that list. */\n\tdeleteWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<void>\n}\n\nexport interface CacheStorage extends ExposedCacheStorage {\n\t/**\n\t * Get a given entity from the cache, expects that you have already checked for existence\n\t */\n\tget<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<T | null>\n\n\t/**\n\t * get a map with cache handlers for the customId types this storage implementation supports\n\t * customId types that don't have a custom handler don't get served from the cache\n\t */\n\tgetCustomCacheHandlerMap(entityRestClient: EntityRestClient): CustomCacheHandlerMap\n\n\tisElementIdInCacheRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<boolean>\n\n\tput(originalEntity: SomeEntity): Promise<void>\n\n\tgetRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Range | null>\n\n\tsetUpperRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<void>\n\n\tsetLowerRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, id: Id): Promise<void>\n\n\t/**\n\t * Creates a new list cache if there is none. Resets everything but elements.\n\t * @param typeRef\n\t * @param listId\n\t * @param lower\n\t * @param upper\n\t */\n\tsetNewRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, lower: Id, upper: Id): Promise<void>\n\n\tgetIdsInRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<Id>>\n\n\t/**\n\t * Persist the last processed batch for a given group id.\n\t */\n\tputLastBatchIdForGroup(groupId: Id, batchId: Id): Promise<void>\n\n\t/**\n\t * Retrieve the least processed batch id for a given group.\n\t */\n\tgetLastBatchIdForGroup(groupId: Id): Promise<Id | null>\n\n\tdeleteIfExists<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, id: Id): Promise<void>\n\n\tpurgeStorage(): Promise<void>\n\n\tputLastUpdateTime(value: number): Promise<void>\n\n\tgetUserId(): Id\n\n\tdeleteAllOwnedBy(owner: Id): Promise<void>\n\n\t/**\n\t * We want to lock the access to the \"ranges\" db when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId)\n\t * @param listId the mail list that we want to lock\n\t */\n\tlockRangesDbAccess(listId: Id): Promise<void>\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(listId)\"\n\t * @param listId the mail list that we want to unlock\n\t */\n\tunlockRangesDbAccess(listId: Id): Promise<void>\n}\n\n/**\n * This implementation provides a caching mechanism to the rest chain.\n * It forwards requests to the entity rest client.\n * The cache works as follows:\n * If a read from the target fails, the request fails.\n * If a read from the target is successful, the cache is written and the element returned.\n * For LETs the cache stores one range per list id. if a range is requested starting in the stored range or at the range ends the missing elements are loaded from the server.\n * Only ranges with elements with generated ids are stored in the cache. Custom id elements are only stored as single element currently. If needed this has to be extended for ranges.\n * Range requests starting outside the stored range are only allowed if the direction is away from the stored range. In this case we load from the range end to avoid gaps in the stored range.\n * Requests for creating or updating elements are always forwarded and not directly stored in the cache.\n * On EventBusClient notifications updated elements are stored in the cache if the element already exists in the cache.\n * On EventBusClient notifications new elements are only stored in the cache if they are LETs and in the stored range.\n * On EventBusClient notifications deleted elements are removed from the cache.\n *\n * Range handling:\n * |          <|>        c d e f g h i j k      <|>             |\n * MIN_ID  lowerRangeId     ids in range    upperRangeId    MAX_ID\n * lowerRangeId may be anything from MIN_ID to c, upperRangeId may be anything from k to MAX_ID\n */\nexport class DefaultEntityRestCache implements EntityRestCache {\n\tconstructor(private readonly entityRestClient: EntityRestClient, private readonly storage: CacheStorage) {}\n\n\tasync load<T extends SomeEntity>(typeRef: TypeRef<T>, id: PropertyType<T, \"_id\">, opts: EntityRestClientLoadOptions = {}): Promise<T> {\n\t\tconst useCache = await this.shouldUseCache(typeRef, opts)\n\t\tif (!useCache) {\n\t\t\treturn await this.entityRestClient.load(typeRef, id, opts)\n\t\t}\n\n\t\tconst { listId, elementId } = expandId(id)\n\t\tconst cachingBehavior = getCacheModeBehavior(opts.cacheMode)\n\t\tconst cachedEntity = cachingBehavior.readsFromCache ? await this.storage.get(typeRef, listId, elementId) : null\n\n\t\tif (cachedEntity == null) {\n\t\t\tconst entity = await this.entityRestClient.load(typeRef, id, opts)\n\t\t\tif (cachingBehavior.writesToCache) {\n\t\t\t\tawait this.storage.put(entity)\n\t\t\t}\n\t\t\treturn entity\n\t\t}\n\n\t\treturn cachedEntity\n\t}\n\n\tasync loadMultiple<T extends SomeEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id | null,\n\t\tids: Array<Id>,\n\t\townerEncSessionKeyProvider?: OwnerEncSessionKeyProvider,\n\t\topts: EntityRestClientLoadOptions = {},\n\t): Promise<Array<T>> {\n\t\tconst useCache = await this.shouldUseCache(typeRef, opts)\n\t\tif (!useCache) {\n\t\t\treturn await this.entityRestClient.loadMultiple(typeRef, listId, ids, ownerEncSessionKeyProvider, opts)\n\t\t}\n\t\treturn await this._loadMultiple(typeRef, listId, ids, ownerEncSessionKeyProvider, opts)\n\t}\n\n\tsetup<T extends SomeEntity>(listId: Id | null, instance: T, extraHeaders?: Dict, options?: EntityRestClientSetupOptions): Promise<Id> {\n\t\treturn this.entityRestClient.setup(listId, instance, extraHeaders, options)\n\t}\n\n\tsetupMultiple<T extends SomeEntity>(listId: Id | null, instances: Array<T>): Promise<Array<Id>> {\n\t\treturn this.entityRestClient.setupMultiple(listId, instances)\n\t}\n\n\tupdate<T extends SomeEntity>(instance: T): Promise<void> {\n\t\treturn this.entityRestClient.update(instance)\n\t}\n\n\terase<T extends SomeEntity>(instance: T, options?: EntityRestClientEraseOptions): Promise<void> {\n\t\treturn this.entityRestClient.erase(instance, options)\n\t}\n\n\tgetLastEntityEventBatchForGroup(groupId: Id): Promise<Id | null> {\n\t\treturn this.storage.getLastBatchIdForGroup(groupId)\n\t}\n\n\tsetLastEntityEventBatchForGroup(groupId: Id, batchId: Id): Promise<void> {\n\t\treturn this.storage.putLastBatchIdForGroup(groupId, batchId)\n\t}\n\n\tpurgeStorage(): Promise<void> {\n\t\tconsole.log(\"Purging the user's offline database\")\n\t\treturn this.storage.purgeStorage()\n\t}\n\n\tasync isOutOfSync(): Promise<boolean> {\n\t\tconst timeSinceLastSync = await this.timeSinceLastSyncMs()\n\t\treturn timeSinceLastSync != null && timeSinceLastSync > ENTITY_EVENT_BATCH_EXPIRE_MS\n\t}\n\n\tasync recordSyncTime(): Promise<void> {\n\t\tconst timestamp = this.getServerTimestampMs()\n\t\tawait this.storage.putLastUpdateTime(timestamp)\n\t}\n\n\tasync timeSinceLastSyncMs(): Promise<number | null> {\n\t\tconst lastUpdate = await this.storage.getLastUpdateTime()\n\t\tlet lastUpdateTime: number\n\t\tswitch (lastUpdate.type) {\n\t\t\tcase \"recorded\":\n\t\t\t\tlastUpdateTime = lastUpdate.time\n\t\t\t\tbreak\n\t\t\tcase \"never\":\n\t\t\t\treturn null\n\t\t\tcase \"uninitialized\":\n\t\t\t\tthrow new ProgrammingError(\"Offline storage is not initialized\")\n\t\t}\n\t\tconst now = this.getServerTimestampMs()\n\t\treturn now - lastUpdateTime\n\t}\n\n\tprivate getServerTimestampMs(): number {\n\t\treturn this.entityRestClient.getRestClient().getServerTimestampMs()\n\t}\n\n\t/**\n\t * Delete a cached entity. Sometimes this is necessary to do to ensure you always load the new version\n\t */\n\tdeleteFromCacheIfExists<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, elementId: Id): Promise<void> {\n\t\treturn this.storage.deleteIfExists(typeRef, listId, elementId)\n\t}\n\n\tprivate async _loadMultiple<T extends SomeEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id | null,\n\t\tids: Array<Id>,\n\t\townerEncSessionKeyProvider?: OwnerEncSessionKeyProvider,\n\t\topts: EntityRestClientLoadOptions = {},\n\t): Promise<Array<T>> {\n\t\tconst cachingBehavior = getCacheModeBehavior(opts.cacheMode)\n\t\tconst entitiesInCache: T[] = []\n\n\t\tlet idsToLoad: Id[]\n\t\tif (cachingBehavior.readsFromCache) {\n\t\t\tidsToLoad = []\n\t\t\tfor (const id of ids) {\n\t\t\t\tconst cachedEntity = await this.storage.get(typeRef, listId, id)\n\t\t\t\tif (cachedEntity != null) {\n\t\t\t\t\tentitiesInCache.push(cachedEntity)\n\t\t\t\t} else {\n\t\t\t\t\tidsToLoad.push(id)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tidsToLoad = ids\n\t\t}\n\n\t\tif (idsToLoad.length > 0) {\n\t\t\tconst entitiesFromServer = await this.entityRestClient.loadMultiple(typeRef, listId, idsToLoad, ownerEncSessionKeyProvider, opts)\n\t\t\tif (cachingBehavior.writesToCache) {\n\t\t\t\tfor (const entity of entitiesFromServer) {\n\t\t\t\t\tawait this.storage.put(entity)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn entitiesFromServer.concat(entitiesInCache)\n\t\t} else {\n\t\t\treturn entitiesInCache\n\t\t}\n\t}\n\n\tasync loadRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\topts: EntityRestClientLoadOptions = {},\n\t): Promise<T[]> {\n\t\tconst customHandler = this.storage.getCustomCacheHandlerMap(this.entityRestClient).get(typeRef)\n\t\tif (customHandler && customHandler.loadRange) {\n\t\t\treturn await customHandler.loadRange(this.storage, listId, start, count, reverse)\n\t\t}\n\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst useCache = (await this.shouldUseCache(typeRef, opts)) && isCachedRangeType(typeModel, typeRef)\n\n\t\tif (!useCache) {\n\t\t\treturn await this.entityRestClient.loadRange(typeRef, listId, start, count, reverse, opts)\n\t\t}\n\n\t\tconst behavior = getCacheModeBehavior(opts.cacheMode)\n\t\tif (!behavior.readsFromCache) {\n\t\t\tthrow new ProgrammingError(\"cannot write to cache without reading with range requests\")\n\t\t}\n\n\t\t// We lock access to the \"ranges\" db here in order to prevent race conditions when accessing the ranges database.\n\t\tawait this.storage.lockRangesDbAccess(listId)\n\n\t\ttry {\n\t\t\tconst range = await this.storage.getRangeForList(typeRef, listId)\n\n\t\t\tif (behavior.writesToCache) {\n\t\t\t\tif (range == null) {\n\t\t\t\t\tawait this.populateNewListWithRange(typeRef, listId, start, count, reverse, opts)\n\t\t\t\t} else if (isStartIdWithinRange(range, start, typeModel)) {\n\t\t\t\t\tawait this.extendFromWithinRange(typeRef, listId, start, count, reverse, opts)\n\t\t\t\t} else if (isRangeRequestAwayFromExistingRange(range, reverse, start, typeModel)) {\n\t\t\t\t\tawait this.extendAwayFromRange(typeRef, listId, start, count, reverse, opts)\n\t\t\t\t} else {\n\t\t\t\t\tawait this.extendTowardsRange(typeRef, listId, start, count, reverse, opts)\n\t\t\t\t}\n\t\t\t\treturn await this.storage.provideFromRange(typeRef, listId, start, count, reverse)\n\t\t\t} else {\n\t\t\t\tif (range && isStartIdWithinRange(range, start, typeModel)) {\n\t\t\t\t\tconst provided = await this.storage.provideFromRange(typeRef, listId, start, count, reverse)\n\t\t\t\t\tconst { newStart, newCount } = await this.recalculateRangeRequest(typeRef, listId, start, count, reverse)\n\t\t\t\t\tconst newElements = newCount > 0 ? await this.entityRestClient.loadRange(typeRef, listId, newStart, newCount, reverse) : []\n\t\t\t\t\treturn provided.concat(newElements)\n\t\t\t\t} else {\n\t\t\t\t\t// Since our starting ID is not in our range, we can't use the cache because we don't know exactly what\n\t\t\t\t\t// elements are missing.\n\t\t\t\t\t//\n\t\t\t\t\t// This can result in us re-retrieving elements we already have. Since we anyway must do a request,\n\t\t\t\t\t// this is fine.\n\t\t\t\t\treturn await this.entityRestClient.loadRange(typeRef, listId, start, count, reverse, opts)\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\t// We unlock access to the \"ranges\" db here. We lock it in order to prevent race conditions when accessing the \"ranges\" database.\n\t\t\tawait this.storage.unlockRangesDbAccess(listId)\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new list range, reading everything from the server that it can\n\t * range:         (none)\n\t * request:       *--------->\n\t * range becomes: |---------|\n\t * @private\n\t */\n\tprivate async populateNewListWithRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\topts: EntityRestClientLoadOptions,\n\t) {\n\t\t// Create a new range and load everything\n\t\tconst entities = await this.entityRestClient.loadRange(typeRef, listId, start, count, reverse, opts)\n\n\t\t// Initialize a new range for this list\n\t\tawait this.storage.setNewRangeForList(typeRef, listId, start, start)\n\n\t\t// The range bounds will be updated in here\n\t\tawait this.updateRangeInStorage(typeRef, listId, count, reverse, entities)\n\t}\n\n\t/**\n\t * Returns part of a request from the cache, and the remainder is loaded from the server\n\t * range:          |---------|\n\t * request:             *-------------->\n\t * range becomes: |--------------------|\n\t */\n\tprivate async extendFromWithinRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\topts: EntityRestClientLoadOptions,\n\t) {\n\t\tconst { newStart, newCount } = await this.recalculateRangeRequest(typeRef, listId, start, count, reverse)\n\t\tif (newCount > 0) {\n\t\t\t// We will be able to provide some entities from the cache, so we just want to load the remaining entities from the server\n\t\t\tconst entities = await this.entityRestClient.loadRange(typeRef, listId, newStart, newCount, reverse, opts)\n\t\t\tawait this.updateRangeInStorage(typeRef, listId, newCount, reverse, entities)\n\t\t}\n\t}\n\n\t/**\n\t * Start was outside the range, and we are loading away from the range\n\t * Keeps loading elements from the end of the range in the direction of the startId.\n\t * Returns once all available elements have been loaded or the requested number is in cache\n\t * range:          |---------|\n\t * request:                     *------->\n\t * range becomes:  |--------------------|\n\t */\n\tprivate async extendAwayFromRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\topts: EntityRestClientLoadOptions,\n\t) {\n\t\t// Start is outside the range, and we are loading away from the range, so we grow until we are able to provide enough\n\t\t// entities starting at startId\n\t\twhile (true) {\n\t\t\tconst range = assertNotNull(await this.storage.getRangeForList(typeRef, listId))\n\n\t\t\t// Which end of the range to start loading from\n\t\t\tconst loadStartId = reverse ? range.lower : range.upper\n\n\t\t\tconst requestCount = Math.max(count, EXTEND_RANGE_MIN_CHUNK_SIZE)\n\n\t\t\t// Load some entities\n\t\t\tconst entities = await this.entityRestClient.loadRange(typeRef, listId, loadStartId, requestCount, reverse, opts)\n\t\t\tawait this.updateRangeInStorage(typeRef, listId, requestCount, reverse, entities)\n\n\t\t\t// If we exhausted the entities from the server\n\t\t\tif (entities.length < requestCount) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Try to get enough entities from cache\n\t\t\tconst entitiesFromCache = await this.storage.provideFromRange(typeRef, listId, start, count, reverse)\n\n\t\t\t// If cache is now capable of providing the whole request\n\t\t\tif (entitiesFromCache.length === count) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Loads all elements from the startId in the direction of the range\n\t * Once complete, returns as many elements as it can from the original request\n\t * range:         |---------|\n\t * request:                     <------*\n\t * range becomes: |--------------------|\n\t * or\n\t * range:              |---------|\n\t * request:       <-------------------*\n\t * range becomes: |--------------------|\n\t */\n\tprivate async extendTowardsRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\topts: EntityRestClientLoadOptions,\n\t) {\n\t\twhile (true) {\n\t\t\tconst range = assertNotNull(await this.storage.getRangeForList(typeRef, listId))\n\n\t\t\tconst loadStartId = reverse ? range.upper : range.lower\n\n\t\t\tconst requestCount = Math.max(count, EXTEND_RANGE_MIN_CHUNK_SIZE)\n\n\t\t\tconst entities = await this.entityRestClient.loadRange(typeRef, listId, loadStartId, requestCount, !reverse, opts)\n\n\t\t\tawait this.updateRangeInStorage(typeRef, listId, requestCount, !reverse, entities)\n\n\t\t\t// The call to `updateRangeInStorage` will have set the range bounds to GENERATED_MIN_ID/GENERATED_MAX_ID\n\t\t\t// in the case that we have exhausted all elements from the server, so if that happens, we will also end up breaking here\n\t\t\tif (await this.storage.isElementIdInCacheRange(typeRef, listId, start)) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tawait this.extendFromWithinRange(typeRef, listId, start, count, reverse, opts)\n\t}\n\n\t/**\n\t * Given the parameters and result of a range request,\n\t * Inserts the result into storage, and updates the range bounds\n\t * based on number of entities requested and the actual amount that were received\n\t */\n\tprivate async updateRangeInStorage<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tcountRequested: number,\n\t\twasReverseRequest: boolean,\n\t\treceivedEntities: T[],\n\t) {\n\t\tconst isCustomId = isCustomIdType(await resolveTypeReference(typeRef))\n\t\tlet elementsToAdd = receivedEntities\n\t\tif (wasReverseRequest) {\n\t\t\t// Ensure that elements are cached in ascending (not reverse) order\n\t\t\telementsToAdd = receivedEntities.reverse()\n\t\t\tif (receivedEntities.length < countRequested) {\n\t\t\t\tconsole.log(\"finished loading, setting min id\")\n\t\t\t\tawait this.storage.setLowerRangeForList(typeRef, listId, isCustomId ? CUSTOM_MIN_ID : GENERATED_MIN_ID)\n\t\t\t} else {\n\t\t\t\t// After reversing the list the first element in the list is the lower range limit\n\t\t\t\tawait this.storage.setLowerRangeForList(typeRef, listId, getElementId(getFirstOrThrow(receivedEntities)))\n\t\t\t}\n\t\t} else {\n\t\t\t// Last element in the list is the upper range limit\n\t\t\tif (receivedEntities.length < countRequested) {\n\t\t\t\t// all elements have been loaded, so the upper range must be set to MAX_ID\n\t\t\t\tconsole.log(\"finished loading, setting max id\")\n\t\t\t\tawait this.storage.setUpperRangeForList(typeRef, listId, isCustomId ? CUSTOM_MAX_ID : GENERATED_MAX_ID)\n\t\t\t} else {\n\t\t\t\tawait this.storage.setUpperRangeForList(typeRef, listId, getElementId(lastThrow(receivedEntities)))\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all(elementsToAdd.map((element) => this.storage.put(element)))\n\t}\n\n\t/**\n\t * Calculates the new start value for the getElementRange request and the number of elements to read in\n\t * order to read no duplicate values.\n\t * @return returns the new start and count value. Important: count can be negative if everything is cached\n\t */\n\tprivate async recalculateRangeRequest<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t): Promise<{ newStart: string; newCount: number }> {\n\t\tlet allRangeList = await this.storage.getIdsInRange(typeRef, listId)\n\t\tlet elementsToRead = count\n\t\tlet startElementId = start\n\t\tconst range = await this.storage.getRangeForList(typeRef, listId)\n\t\tif (range == null) {\n\t\t\treturn { newStart: start, newCount: count }\n\t\t}\n\t\tconst { lower, upper } = range\n\t\tlet indexOfStart = allRangeList.indexOf(start)\n\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst isCustomId = isCustomIdType(typeModel)\n\t\tif (\n\t\t\t(!reverse && (isCustomId ? upper === CUSTOM_MAX_ID : upper === GENERATED_MAX_ID)) ||\n\t\t\t(reverse && (isCustomId ? lower === CUSTOM_MIN_ID : lower === GENERATED_MIN_ID))\n\t\t) {\n\t\t\t// we have already loaded the complete range in the desired direction, so we do not have to load from server\n\t\t\telementsToRead = 0\n\t\t} else if (allRangeList.length === 0) {\n\t\t\t// Element range is empty, so read all elements\n\t\t\telementsToRead = count\n\t\t} else if (indexOfStart !== -1) {\n\t\t\t// Start element is located in allRange read only elements that are not in allRange.\n\t\t\tif (reverse) {\n\t\t\t\telementsToRead = count - indexOfStart\n\t\t\t\tstartElementId = allRangeList[0] // use the lowest id in allRange as start element\n\t\t\t} else {\n\t\t\t\telementsToRead = count - (allRangeList.length - 1 - indexOfStart)\n\t\t\t\tstartElementId = allRangeList[allRangeList.length - 1] // use the  highest id in allRange as start element\n\t\t\t}\n\t\t} else if (lower === start || (firstBiggerThanSecond(start, lower, typeModel) && firstBiggerThanSecond(allRangeList[0], start, typeModel))) {\n\t\t\t// Start element is not in allRange but has been used has start element for a range request, eg. EntityRestInterface.GENERATED_MIN_ID, or start is between lower range id and lowest element in range\n\t\t\tif (!reverse) {\n\t\t\t\t// if not reverse read only elements that are not in allRange\n\t\t\t\tstartElementId = allRangeList[allRangeList.length - 1] // use the  highest id in allRange as start element\n\t\t\t\telementsToRead = count - allRangeList.length\n\t\t\t}\n\t\t\t// if reverse read all elements\n\t\t} else if (\n\t\t\tupper === start ||\n\t\t\t(firstBiggerThanSecond(start, allRangeList[allRangeList.length - 1], typeModel) && firstBiggerThanSecond(upper, start, typeModel))\n\t\t) {\n\t\t\t// Start element is not in allRange but has been used has start element for a range request, eg. EntityRestInterface.GENERATED_MAX_ID, or start is between upper range id and highest element in range\n\t\t\tif (reverse) {\n\t\t\t\t// if not reverse read only elements that are not in allRange\n\t\t\t\tstartElementId = allRangeList[0] // use the  highest id in allRange as start element\n\t\t\t\telementsToRead = count - allRangeList.length\n\t\t\t}\n\t\t\t// if not reverse read all elements\n\t\t}\n\t\treturn { newStart: startElementId, newCount: elementsToRead }\n\t}\n\n\t/**\n\t * Resolves when the entity is loaded from the server if necessary\n\t * @pre The last call of this function must be resolved. This is needed to avoid that e.g. while\n\t * loading a created instance from the server we receive an update of that instance and ignore it because the instance is not in the cache yet.\n\t *\n\t * @return Promise, which resolves to the array of valid events (if response is NotFound or NotAuthorized we filter it out)\n\t */\n\tasync entityEventsReceived(batch: QueuedBatch): Promise<Array<EntityUpdate>> {\n\t\tawait this.recordSyncTime()\n\n\t\t// we handle post multiple create operations separately to optimize the number of requests with getMultiple\n\t\tconst createUpdatesForLETs: EntityUpdate[] = []\n\t\tconst regularUpdates: EntityUpdate[] = [] // all updates not resulting from post multiple requests\n\t\tconst updatesArray = batch.events\n\t\tfor (const update of updatesArray) {\n\t\t\tconst typeRef = new TypeRef(update.application, update.type)\n\n\t\t\t// monitor application is ignored\n\t\t\tif (update.application === \"monitor\") continue\n\t\t\t// mailSetEntries are ignored because move operations are handled as a special event (and no post multiple is possible)\n\t\t\tif (\n\t\t\t\tupdate.operation === OperationType.CREATE &&\n\t\t\t\tgetUpdateInstanceId(update).instanceListId != null &&\n\t\t\t\t!isSameTypeRef(typeRef, MailTypeRef) &&\n\t\t\t\t!isSameTypeRef(typeRef, MailSetEntryTypeRef)\n\t\t\t) {\n\t\t\t\tcreateUpdatesForLETs.push(update)\n\t\t\t} else {\n\t\t\t\tregularUpdates.push(update)\n\t\t\t}\n\t\t}\n\n\t\tconst createUpdatesForLETsPerList = groupBy(createUpdatesForLETs, (update) => update.instanceListId)\n\n\t\tconst postMultipleEventUpdates: EntityUpdate[][] = []\n\t\t// we first handle potential post multiple updates in get multiple requests\n\t\tfor (let [instanceListId, updates] of createUpdatesForLETsPerList) {\n\t\t\tconst firstUpdate = updates[0]\n\t\t\tconst typeRef = new TypeRef<ListElementEntity>(firstUpdate.application, firstUpdate.type)\n\t\t\tconst ids = updates.map((update) => update.instanceId)\n\n\t\t\t// We only want to load the instances that are in cache range\n\t\t\tconst customHandler = this.storage.getCustomCacheHandlerMap(this.entityRestClient).get(typeRef)\n\t\t\tconst idsInCacheRange =\n\t\t\t\tcustomHandler && customHandler.getElementIdsInCacheRange\n\t\t\t\t\t? await customHandler.getElementIdsInCacheRange(this.storage, instanceListId, ids)\n\t\t\t\t\t: await this.getElementIdsInCacheRange(typeRef, instanceListId, ids)\n\n\t\t\tif (idsInCacheRange.length === 0) {\n\t\t\t\tpostMultipleEventUpdates.push(updates)\n\t\t\t} else {\n\t\t\t\tconst updatesNotInCacheRange =\n\t\t\t\t\tidsInCacheRange.length === updates.length ? [] : updates.filter((update) => !idsInCacheRange.includes(update.instanceId))\n\n\t\t\t\ttry {\n\t\t\t\t\t// loadMultiple is only called to cache the elements and check which ones return errors\n\t\t\t\t\tconst returnedInstances = await this._loadMultiple(typeRef, instanceListId, idsInCacheRange, undefined, { cacheMode: CacheMode.WriteOnly })\n\t\t\t\t\t//We do not want to pass updates that caused an error\n\t\t\t\t\tif (returnedInstances.length !== idsInCacheRange.length) {\n\t\t\t\t\t\tconst returnedIds = returnedInstances.map((instance) => getElementId(instance))\n\t\t\t\t\t\tpostMultipleEventUpdates.push(updates.filter((update) => returnedIds.includes(update.instanceId)).concat(updatesNotInCacheRange))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpostMultipleEventUpdates.push(updates)\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\t\t\t// return updates that are not in cache Range if NotAuthorizedError (for those updates that are in cache range)\n\t\t\t\t\t\tpostMultipleEventUpdates.push(updatesNotInCacheRange)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst otherEventUpdates: EntityUpdate[] = []\n\t\tfor (let update of regularUpdates) {\n\t\t\tconst { operation, type, application } = update\n\t\t\tconst { instanceListId, instanceId } = getUpdateInstanceId(update)\n\t\t\tconst typeRef = new TypeRef<SomeEntity>(application, type)\n\n\t\t\tswitch (operation) {\n\t\t\t\tcase OperationType.UPDATE: {\n\t\t\t\t\tconst handledUpdate = await this.processUpdateEvent(typeRef, update)\n\t\t\t\t\tif (handledUpdate) {\n\t\t\t\t\t\totherEventUpdates.push(handledUpdate)\n\t\t\t\t\t}\n\t\t\t\t\tbreak // do break instead of continue to avoid ide warnings\n\t\t\t\t}\n\t\t\t\tcase OperationType.DELETE: {\n\t\t\t\t\tif (\n\t\t\t\t\t\tisSameTypeRef(MailSetEntryTypeRef, typeRef) &&\n\t\t\t\t\t\tcontainsEventOfType(updatesArray as Readonly<EntityUpdateData[]>, OperationType.CREATE, instanceId)\n\t\t\t\t\t) {\n\t\t\t\t\t\t// move for mail is handled in create event.\n\t\t\t\t\t} else if (isSameTypeRef(MailTypeRef, typeRef)) {\n\t\t\t\t\t\t// delete mailDetails if they are available (as we don't send an event for this type)\n\t\t\t\t\t\tconst mail = await this.storage.get(MailTypeRef, instanceListId, instanceId)\n\t\t\t\t\t\tawait this.storage.deleteIfExists(typeRef, instanceListId, instanceId)\n\t\t\t\t\t\tif (mail?.mailDetails != null) {\n\t\t\t\t\t\t\tawait this.storage.deleteIfExists(MailDetailsBlobTypeRef, mail.mailDetails[0], mail.mailDetails[1])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this.storage.deleteIfExists(typeRef, instanceListId, instanceId)\n\t\t\t\t\t}\n\t\t\t\t\totherEventUpdates.push(update)\n\t\t\t\t\tbreak // do break instead of continue to avoid ide warnings\n\t\t\t\t}\n\t\t\t\tcase OperationType.CREATE: {\n\t\t\t\t\tconst handledUpdate = await this.processCreateEvent(typeRef, update, updatesArray)\n\t\t\t\t\tif (handledUpdate) {\n\t\t\t\t\t\totherEventUpdates.push(handledUpdate)\n\t\t\t\t\t}\n\t\t\t\t\tbreak // do break instead of continue to avoid ide warnings\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ProgrammingError(\"Unknown operation type: \" + operation)\n\t\t\t}\n\t\t}\n\t\t// the whole batch has been written successfully\n\t\tawait this.storage.putLastBatchIdForGroup(batch.groupId, batch.batchId)\n\t\t// merge the results\n\t\treturn otherEventUpdates.concat(postMultipleEventUpdates.flat())\n\t}\n\n\t/** Returns {null} when the update should be skipped. */\n\tprivate async processCreateEvent(typeRef: TypeRef<any>, update: EntityUpdate, batch: ReadonlyArray<EntityUpdate>): Promise<EntityUpdate | null> {\n\t\t// do not return undefined to avoid implicit returns\n\t\tconst { instanceId, instanceListId } = getUpdateInstanceId(update)\n\n\t\t// We put new instances into cache only when it's a new instance in the cached range which is only for the list instances.\n\t\tif (instanceListId != null) {\n\t\t\tconst deleteEvent = getEventOfType(batch, OperationType.DELETE, instanceId)\n\t\t\tconst mailSetEntry =\n\t\t\t\tdeleteEvent && isSameTypeRef(MailSetEntryTypeRef, typeRef)\n\t\t\t\t\t? await this.storage.get(MailSetEntryTypeRef, deleteEvent.instanceListId, instanceId)\n\t\t\t\t\t: null\n\t\t\t// avoid downloading new mailSetEntry in case of move event (DELETE + CREATE)\n\t\t\tif (deleteEvent != null && mailSetEntry != null) {\n\t\t\t\t// It is a move event for cached mailSetEntry\n\t\t\t\tawait this.storage.deleteIfExists(typeRef, deleteEvent.instanceListId, instanceId)\n\t\t\t\tawait this.updateListIdOfMailSetEntryAndUpdateCache(mailSetEntry, instanceListId, instanceId)\n\t\t\t\treturn update\n\t\t\t} else {\n\t\t\t\t// If there is a custom handler we follow its decision.\n\t\t\t\t// Otherwise, we do a range check to see if we need to keep the range up-to-date.\n\t\t\t\tconst shouldLoad =\n\t\t\t\t\t(await this.storage.getCustomCacheHandlerMap(this.entityRestClient).get(typeRef)?.shouldLoadOnCreateEvent?.(update)) ??\n\t\t\t\t\t(await this.storage.isElementIdInCacheRange(typeRef, instanceListId, instanceId))\n\t\t\t\tif (shouldLoad) {\n\t\t\t\t\t// No need to try to download something that's not there anymore\n\t\t\t\t\t// We do not consult custom handlers here because they are only needed for list elements.\n\t\t\t\t\tconsole.log(\"downloading create event for\", getTypeId(typeRef), instanceListId, instanceId)\n\t\t\t\t\treturn this.entityRestClient\n\t\t\t\t\t\t.load(typeRef, [instanceListId, instanceId])\n\t\t\t\t\t\t.then((entity) => this.storage.put(entity))\n\t\t\t\t\t\t.then(() => update)\n\t\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t\tif (isExpectedErrorForSynchronization(e)) {\n\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\treturn update\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn update\n\t\t}\n\t}\n\n\t/**\n\t * Updates the given mailSetEntry with the new list id and add it to the cache.\n\t */\n\tprivate async updateListIdOfMailSetEntryAndUpdateCache(mailSetEntry: MailSetEntry, newListId: Id, elementId: Id) {\n\t\t// In case of a move operation we have to replace the list id always, as the mailSetEntry is stored in another folder.\n\t\tmailSetEntry._id = [newListId, elementId]\n\t\tawait this.storage.put(mailSetEntry)\n\t}\n\n\t/** Returns {null} when the update should be skipped. */\n\tprivate async processUpdateEvent(typeRef: TypeRef<SomeEntity>, update: EntityUpdate): Promise<EntityUpdate | null> {\n\t\tconst { instanceId, instanceListId } = getUpdateInstanceId(update)\n\t\tconst cached = await this.storage.get(typeRef, instanceListId, instanceId)\n\t\t// No need to try to download something that's not there anymore\n\t\tif (cached != null) {\n\t\t\ttry {\n\t\t\t\t// in case this is an update for the user instance: if the password changed we'll be logged out at this point\n\t\t\t\t// if we don't catch the expected NotAuthenticated Error that results from trying to load anything with\n\t\t\t\t// the old user.\n\t\t\t\t// Letting the NotAuthenticatedError propagate to the main thread instead of trying to handle it ourselves\n\t\t\t\t// or throwing out the update drops us onto the login page and into the session recovery flow if the user\n\t\t\t\t// clicks their saved credentials again, but lets them still use offline login if they try to use the\n\t\t\t\t// outdated credentials while not connected to the internet.\n\t\t\t\tconst newEntity = await this.entityRestClient.load(typeRef, collapseId(instanceListId, instanceId))\n\t\t\t\tif (isSameTypeRef(typeRef, UserTypeRef)) {\n\t\t\t\t\tawait this.handleUpdatedUser(cached, newEntity)\n\t\t\t\t}\n\t\t\t\tawait this.storage.put(newEntity)\n\t\t\t\treturn update\n\t\t\t} catch (e) {\n\t\t\t\t// If the entity is not there anymore we should evict it from the cache and not keep the outdated/nonexisting instance around.\n\t\t\t\t// Even for list elements this should be safe as the instance is not there anymore and is definitely not in this version\n\t\t\t\tif (isExpectedErrorForSynchronization(e)) {\n\t\t\t\t\tconsole.log(`Instance not found when processing update for ${JSON.stringify(update)}, deleting from the cache.`)\n\t\t\t\t\tawait this.storage.deleteIfExists(typeRef, instanceListId, instanceId)\n\t\t\t\t\treturn null\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn update\n\t}\n\n\tprivate async handleUpdatedUser(cached: SomeEntity, newEntity: SomeEntity) {\n\t\t// When we are removed from a group we just get an update for our user\n\t\t// with no membership on it. We need to clean up all the entities that\n\t\t// belong to that group since we shouldn't be able to access them anymore\n\t\t// and we won't get any update or another chance to clean them up.\n\t\tconst oldUser = cached as User\n\t\tif (oldUser._id !== this.storage.getUserId()) {\n\t\t\treturn\n\t\t}\n\t\tconst newUser = newEntity as User\n\t\tconst removedShips = difference(oldUser.memberships, newUser.memberships, (l, r) => l._id === r._id)\n\t\tfor (const ship of removedShips) {\n\t\t\tconsole.log(\"Lost membership on \", ship._id, ship.groupType)\n\t\t\tawait this.storage.deleteAllOwnedBy(ship.group)\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @returns {Array<Id>} the ids that are in cache range and therefore should be cached\n\t */\n\tprivate async getElementIdsInCacheRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, ids: Id[]): Promise<Id[]> {\n\t\tconst ret: Id[] = []\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tif (await this.storage.isElementIdInCacheRange(typeRef, listId, ids[i])) {\n\t\t\t\tret.push(ids[i])\n\t\t\t}\n\t\t}\n\t\treturn ret\n\t}\n\n\t/**\n\t * Check if the given request should use the cache\n\t * @param typeRef typeref of the type\n\t * @param opts entity rest client options, if any\n\t * @return true if the cache can be used, false if a direct network request should be performed\n\t */\n\tprivate shouldUseCache(typeRef: TypeRef<any>, opts?: EntityRestClientLoadOptions): boolean {\n\t\t// some types won't be cached\n\t\tif (isIgnoredType(typeRef)) {\n\t\t\treturn false\n\t\t}\n\n\t\t// if a specific version is requested we have to load again and do not want to store it in the cache\n\t\treturn opts?.queryParams?.version == null\n\t}\n}\n\n/**\n * Returns whether the error is expected for the cases where our local state might not be up-to-date with the server yet. E.g. we might be processing an update\n * for the instance that was already deleted. Normally this would be optimized away but it might still happen due to timing.\n */\nfunction isExpectedErrorForSynchronization(e: Error): boolean {\n\treturn e instanceof NotFoundError || e instanceof NotAuthorizedError\n}\n\nexport function expandId(id: Id | IdTuple): { listId: Id | null; elementId: Id } {\n\tif (typeof id === \"string\") {\n\t\treturn {\n\t\t\tlistId: null,\n\t\t\telementId: id,\n\t\t}\n\t} else {\n\t\tconst [listId, elementId] = id\n\t\treturn {\n\t\t\tlistId,\n\t\t\telementId,\n\t\t}\n\t}\n}\n\nexport function collapseId(listId: Id | null, elementId: Id): Id | IdTuple {\n\tif (listId != null) {\n\t\treturn [listId, elementId]\n\t} else {\n\t\treturn elementId\n\t}\n}\n\nexport function getUpdateInstanceId(update: EntityUpdate): { instanceListId: Id | null; instanceId: Id } {\n\tlet instanceListId\n\tif (update.instanceListId === \"\") {\n\t\tinstanceListId = null\n\t} else {\n\t\tinstanceListId = update.instanceListId\n\t}\n\treturn { instanceListId, instanceId: update.instanceId }\n}\n\n/**\n * Check if a range request begins inside an existing range\n */\nfunction isStartIdWithinRange(range: Range, startId: Id, typeModel: TypeModel): boolean {\n\treturn !firstBiggerThanSecond(startId, range.upper, typeModel) && !firstBiggerThanSecond(range.lower, startId, typeModel)\n}\n\n/**\n * Check if a range request is going away from an existing range\n * Assumes that the range request doesn't start inside the range\n */\nfunction isRangeRequestAwayFromExistingRange(range: Range, reverse: boolean, start: string, typeModel: TypeModel) {\n\treturn reverse ? firstBiggerThanSecond(range.lower, start, typeModel) : firstBiggerThanSecond(start, range.upper, typeModel)\n}\n\n/**\n * some types are completely ignored by the cache and always served from a request.\n * Note:\n * isCachedRangeType(ref) ---> !isIgnoredType(ref) but\n * isIgnoredType(ref) -/-> !isCachedRangeType(ref) because of opted-in CustomId types.\n */\nfunction isIgnoredType(typeRef: TypeRef<unknown>): boolean {\n\treturn typeRef.app === \"monitor\" || IGNORED_TYPES.some((ref) => isSameTypeRef(typeRef, ref))\n}\n\n/**\n * Checks if for the given type, that contains a customId,  caching is enabled.\n */\nfunction isCachableCustomIdType(typeRef: TypeRef<unknown>): boolean {\n\treturn CACHEABLE_CUSTOMID_TYPES.some((ref) => isSameTypeRef(typeRef, ref))\n}\n\n/**\n * Ranges for customId types are normally not cached, but some are opted in.\n * Note:\n * isCachedRangeType(ref) ---> !isIgnoredType(ref) but\n * isIgnoredType(ref) -/-> !isCachedRangeType(ref)\n */\nfunction isCachedRangeType(typeModel: TypeModel, typeRef: TypeRef<unknown>): boolean {\n\treturn (!isIgnoredType(typeRef) && isGeneratedIdType(typeModel)) || isCachableCustomIdType(typeRef)\n}\n\nfunction isGeneratedIdType(typeModel: TypeModel): boolean {\n\treturn typeModel.values._id.type === ValueType.GeneratedId\n}\n"]}