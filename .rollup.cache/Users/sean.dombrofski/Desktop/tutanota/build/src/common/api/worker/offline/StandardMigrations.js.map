{"version":3,"file":"StandardMigrations.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/offline/StandardMigrations.ts"],"names":[],"mappings":"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","sourcesContent":["import { OfflineStorage } from \"./OfflineStorage.js\"\nimport { modelInfos } from \"../../common/EntityFunctions.js\"\nimport { typedKeys, TypeRef } from \"@tutao/tutanota-utils\"\nimport { ElementEntity, ListElementEntity, SomeEntity } from \"../../common/EntityTypes.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\n\nexport async function migrateAllListElements<T extends ListElementEntity>(typeRef: TypeRef<T>, storage: OfflineStorage, migrations: Array<Migration>) {\n\tlet entities = await storage.getRawListElementsOfType(typeRef)\n\n\tfor (const migration of migrations) {\n\t\t// @ts-ignore need better types for migrations\n\t\tentities = entities.map(migration)\n\t}\n\n\tfor (const entity of entities) {\n\t\tentity._type = typeRef as TypeRef<typeof entity>\n\t\tawait storage.put(entity)\n\t}\n}\n\nexport async function migrateAllElements<T extends ElementEntity>(typeRef: TypeRef<T>, storage: OfflineStorage, migrations: Array<Migration>) {\n\tlet entities = await storage.getRawElementsOfType(typeRef)\n\n\tfor (const migration of migrations) {\n\t\t// @ts-ignore need better types for migrations\n\t\tentities = entities.map(migration)\n\t}\n\n\tfor (const entity of entities) {\n\t\tentity._type = typeRef as TypeRef<typeof entity>\n\t\tawait storage.put(entity)\n\t}\n}\n\nexport type Migration = (entity: any) => SomeEntity\n\nexport function renameAttribute(oldName: string, newName: string): Migration {\n\treturn function (entity) {\n\t\tentity[newName] = entity[oldName]\n\t\tdelete entity[oldName]\n\t\treturn entity\n\t}\n}\n\nexport function addOwnerKeyVersion(): Migration {\n\treturn function (entity) {\n\t\tentity[\"_ownerKeyVersion\"] = entity[\"_ownerEncSessionKey\"] == null ? null : \"0\"\n\t\treturn entity\n\t}\n}\n\nexport function removeValue(valueName: string): Migration {\n\treturn function (entity) {\n\t\tdelete entity[valueName]\n\t\treturn entity\n\t}\n}\n\nexport function addValue(valueName: string, value: any): Migration {\n\treturn function (entity) {\n\t\tentity[valueName] = value\n\t\treturn entity\n\t}\n}\n\nexport function booleanToNumberValue(attribute: string): Migration {\n\treturn function (entity) {\n\t\t// same default value mapping as in the tutadb migration\n\t\tentity[attribute] = entity[attribute] ? \"1\" : \"0\"\n\t\treturn entity\n\t}\n}\n\nexport function changeCardinalityFromAnyToZeroOrOne(attribute: string): Migration {\n\treturn function (entity) {\n\t\tconst value = entity[attribute]\n\t\tif (!Array.isArray(value)) {\n\t\t\tthrow new ProgrammingError(\"Can only migrate from cardinality ANY.\")\n\t\t}\n\t\tconst length = value.length\n\t\tif (length === 0) {\n\t\t\tentity[attribute] = null\n\t\t} else if (length === 1) {\n\t\t\tentity[attribute] = value[0]\n\t\t} else {\n\t\t\tthrow new ProgrammingError(`not possible to migrate ANY to ZERO_OR_ONE with array length > 1. actual length: ${length}`)\n\t\t}\n\t\treturn entity\n\t}\n}\n\nexport async function clearDatabase(storage: OfflineStorage) {\n\tawait storage.purgeStorage()\n\tawait writeModelVersions(storage)\n}\n\nexport function deleteInstancesOfType<T extends SomeEntity>(storage: OfflineStorage, type: TypeRef<T>): Promise<void> {\n\treturn storage.deleteAllOfType(type)\n}\n\nasync function writeModelVersions(storage: OfflineStorage) {\n\tfor (const app of typedKeys(modelInfos)) {\n\t\tconst key = `${app}-version` as const\n\t\tlet version = modelInfos[app].version\n\t\tawait storage.setStoredModelVersion(app, version)\n\t}\n}\n"]}