{"version":3,"file":"SecretStorage.js","sourceRoot":"","sources":["../../../../../src/common/desktop/sse/SecretStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import * as PathModule from \"node:path\"\nimport * as FsModule from \"node:fs\"\nimport { DeviceStorageUnavailableError } from \"../../api/common/error/DeviceStorageUnavailableError.js\"\n\nexport function preselectGnomeLibsecret(electron: typeof Electron.CrossProcessExports) {\n\t// this is how chromium selects a backend:\n\t// https://chromium.googlesource.com/chromium/src/+/main/components/os_crypt/sync/key_storage_util_linux.cc\n\t// also for DE detection, which happens before:\n\t// https://chromium.googlesource.com/chromium/src/+/main/base/nix/xdg_util.cc\n\t// I'm 90% sure that it's the deprecated \"GNOME_DESKTOP_SESSION_ID\" env var that's set once you have logged into gnome\n\t// and back out that makes it suddenly work with i3 since chromium falls back to that if none of the more modern vars\n\t// contain something it recognizes.\n\t// if no explicit backend is given, we default to trying gnome-libsecret since that was what we required before.\n\tif (process.platform === \"linux\" && !process.argv.some((a) => a.startsWith(\"--password-store=\"))) {\n\t\telectron.app.commandLine.appendSwitch(\"password-store\", \"gnome-libsecret\")\n\t}\n}\n\nexport interface SecretStorage {\n\tgetPassword(service: string, account: string): Promise<string | null>\n\n\tsetPassword(service: string, account: string, password: string): Promise<void>\n}\n\n/**\n * Secret Storage impl using the electron 15+ SafeStorage API\n *\n * Note: the main thread will be blocked while the keychain is being unlocked,\n * potentially for as long as the user takes to enter a password.\n * We're asking for access before any windows are created, which should prevent\n * any weirdness arising from that.\n */\nexport class SafeStorageSecretStorage implements SecretStorage {\n\tprivate initialized = false\n\n\tconstructor(\n\t\tprivate readonly electron: typeof Electron.CrossProcessExports,\n\t\tprivate readonly fs: typeof FsModule,\n\t\tprivate readonly path: typeof PathModule,\n\t) {}\n\n\tasync getPassword(service: string, account: string): Promise<string | null> {\n\t\tawait this.assertAvailable()\n\t\tconst keyPath = this.getKeyPath(service, account)\n\t\ttry {\n\t\t\tconst encPwBuffer = await this.fs.promises.readFile(keyPath)\n\t\t\treturn this.electron.safeStorage.decryptString(encPwBuffer)\n\t\t} catch (e) {\n\t\t\tif (e.code === \"ENOENT\") {\n\t\t\t\t// the key wasn't created yet\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tasync setPassword(service: string, account: string, password: string): Promise<void> {\n\t\tawait this.assertAvailable()\n\t\tconst keyPath = this.getKeyPath(service, account)\n\t\tconst cypherBuffer = this.electron.safeStorage.encryptString(password)\n\t\treturn this.fs.promises.writeFile(keyPath, cypherBuffer)\n\t}\n\n\tprivate getKeyPath(service: string, account: string): string {\n\t\tconst fname = service.concat(\"-\", account)\n\t\tconst safeStoragePath = this.getSafeStoragePath()\n\t\treturn this.path.join(safeStoragePath, fname)\n\t}\n\n\t/**\n\t * this should always be a path inside the user's home directory (or equivalent)\n\t * @private\n\t */\n\tprivate getSafeStoragePath(): string {\n\t\treturn this.path.join(this.electron.app.getPath(\"userData\"), \"safe_storage\")\n\t}\n\n\t/**\n\t * ensures that the safe_storage directory exists and that we can use the\n\t * safeStorage API\n\t * @private\n\t */\n\tprivate async assertAvailable(): Promise<void> {\n\t\tawait this.electron.app.whenReady()\n\t\tawait this.fs.promises.mkdir(this.getSafeStoragePath(), { recursive: true })\n\n\t\tconst onLinux = process.platform === \"linux\"\n\t\tconst backend = onLinux ? this.electron.safeStorage.getSelectedStorageBackend() : null\n\n\t\tif (!this.initialized && backend === \"basic_text\") {\n\t\t\t// this will force isEncryptionAvailable to return true\n\t\t\tthis.electron.safeStorage.setUsePlainTextEncryption(true)\n\n\t\t\t// note that `basic_text` uses a hardcoded key which is insecure\n\t\t\tconsole.warn(\n\t\t\t\t`Detected safeStorage backend is insecure: ${backend}. Consider choosing a different one via command line args, or set up an app password to protect local data`,\n\t\t\t)\n\t\t}\n\n\t\tif (this.electron.safeStorage.isEncryptionAvailable()) {\n\t\t\tif (!this.initialized && onLinux) {\n\t\t\t\t// only linux has variable backends\n\t\t\t\tthis.initialized = true\n\t\t\t\tconsole.log(\"using safeStorage with backend\", backend)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tthrow new DeviceStorageUnavailableError(\"safeStorage API is not available\", null)\n\t}\n}\n"]}