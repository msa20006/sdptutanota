{"version":3,"file":"PostLoginUtils.js","sourceRoot":"","sources":["../../../../src/common/login/PostLoginUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { isIOSApp } from \"../api/common/Env.js\"\nimport { Const } from \"../api/common/TutanotaConstants.js\"\nimport { UserController } from \"../api/main/UserController.js\"\nimport { assertNotNull } from \"@tutao/tutanota-utils\"\nimport { UserManagementFacade } from \"../api/worker/facades/lazy/UserManagementFacade.js\"\nimport { CustomerFacade } from \"../api/worker/facades/lazy/CustomerFacade.js\"\n\n// the customer may have been reminded when they were a free account, so we can't use lastUpgradeReminder being null as a marker.\n// we use a date that's shortly before we started issuing reminders for legacy accounts and after we started only allowing new plans as upgrades.\n// anyone who is still legacy and was reminded before this date must have seen the last reminder when they were a free account.\n// if we end up wanting to repeat this down the line, update this to some later date.\nexport const reminderCutoffDate = new Date(\"2023-09-20T13:00:00.000Z\")\n\nexport async function shouldShowUpgradeReminder(userController: UserController, date: Date): Promise<boolean> {\n\t// * do not show to normal users, they can't upgrade their account\n\t// * do not show to new plans, they already switched\n\t// * do not show in ios app, they can't upgrade there.\n\tif (!userController.isGlobalAdmin() || (await userController.isNewPaidPlan()) || isIOSApp()) return false\n\n\tconst customerInfo = await userController.loadCustomerInfo()\n\tconst customerProperties = await userController.loadCustomerProperties()\n\n\tif (userController.isFreeAccount()) {\n\t\t// i'm any non-paying user - show repeatedly until upgraded, but only after INITIAL_UPGRADE_REMINDER_INTERVAL_MS\n\t\tconst isOldEnoughForInitialReminder =\n\t\t\tcustomerProperties.lastUpgradeReminder == null && date.getTime() - customerInfo.creationTime.getTime() > Const.INITIAL_UPGRADE_REMINDER_INTERVAL_MS\n\t\t// If we've shown the reminder before show it again every REPEATED_UPGRADE_REMINDER_INTERVAL_MS.\n\t\tconst wasRemindedLongAgo =\n\t\t\tcustomerProperties.lastUpgradeReminder != null &&\n\t\t\tdate.getTime() - customerProperties.lastUpgradeReminder.getTime() > Const.REPEATED_UPGRADE_REMINDER_INTERVAL_MS\n\t\treturn isOldEnoughForInitialReminder || wasRemindedLongAgo\n\t} else if (!(await userController.loadCustomer()).businessUse) {\n\t\t// i'm a private legacy paid account. show once.\n\t\t// we don't have to check account age - all legacy accounts are old enough by now.\n\t\treturn customerProperties.lastUpgradeReminder == null || customerProperties.lastUpgradeReminder.getTime() < reminderCutoffDate.getTime()\n\t} else {\n\t\t// i'm a business legacy paid account, so we don't show the reminder.\n\t\treturn false\n\t}\n}\n\nexport async function shouldShowStorageWarning(\n\tuserController: UserController,\n\tuserManagementFacade: UserManagementFacade,\n\tcustomerFacade: CustomerFacade,\n): Promise<boolean> {\n\tconst customerInfo = await userController.loadCustomerInfo()\n\t// New plans have per-user storage limits.\n\tif ((await userController.isNewPaidPlan()) || userController.isFreeAccount()) {\n\t\tconst usedStorage = await userManagementFacade.readUsedUserStorage(userController.user)\n\t\treturn isOverStorageLimit(usedStorage, Number(customerInfo.perUserStorageCapacity) * Const.MEMORY_GB_FACTOR)\n\t} else {\n\t\t// Legacy plans have per-account storage limits.\n\t\tif (!userController.isGlobalAdmin()) {\n\t\t\treturn false\n\t\t}\n\t\tconst customerId = assertNotNull(userController.user.customer)\n\t\tconst usedStorage = await customerFacade.readUsedCustomerStorage(customerId)\n\t\tif (Number(usedStorage) > Const.MEMORY_GB_FACTOR * Const.MEMORY_WARNING_FACTOR) {\n\t\t\tconst availableStorage = await customerFacade.readAvailableCustomerStorage(customerId)\n\t\t\treturn isOverStorageLimit(usedStorage, availableStorage)\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunction isOverStorageLimit(usedStorageInBytes: number, availableStorageInBytes: number) {\n\treturn usedStorageInBytes > availableStorageInBytes * Const.MEMORY_WARNING_FACTOR\n}\n"]}