{"version":3,"file":"DesktopNativeCryptoFacade.js","sourceRoot":"","sources":["../../../../src/common/desktop/DesktopNativeCryptoFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { base64ToBase64Url, base64ToUint8Array, stringToUtf8Uint8Array, uint8ArrayToBase64, utf8Uint8ArrayToString } from \"@tutao/tutanota-utils\"\nimport type { CryptoFunctions } from \"./CryptoFns.js\"\nimport type { TypeModel } from \"../api/common/EntityTypes.js\"\nimport type * as FsModule from \"node:fs\"\nimport { Aes256Key, Argon2IDExports, bitArrayToUint8Array, generateKeyFromPassphraseArgon2id, uint8ArrayToKey } from \"@tutao/tutanota-crypto\"\nimport { FileUri } from \"../native/common/FileApp.js\"\nimport path from \"node:path\"\nimport { NativeCryptoFacade } from \"../native/common/generatedipc/NativeCryptoFacade.js\"\nimport { EncryptedFileInfo } from \"../native/common/generatedipc/EncryptedFileInfo.js\"\nimport { RsaPrivateKey } from \"../native/common/generatedipc/RsaPrivateKey.js\"\nimport { RsaPublicKey } from \"../native/common/generatedipc/RsaPublicKey.js\"\nimport { nonClobberingFilename } from \"./PathUtils.js\"\nimport { TempFs } from \"./files/TempFs.js\"\nimport { KyberKeyPair } from \"../native/common/generatedipc/KyberKeyPair.js\"\nimport { KyberPublicKey } from \"../native/common/generatedipc/KyberPublicKey.js\"\nimport { KyberEncapsulation } from \"../native/common/generatedipc/KyberEncapsulation.js\"\nimport { KyberPrivateKey } from \"../native/common/generatedipc/KyberPrivateKey.js\"\n\ntype FsExports = typeof FsModule\n\nexport class DesktopNativeCryptoFacade implements NativeCryptoFacade {\n\tconstructor(\n\t\tprivate readonly fs: FsExports,\n\t\tprivate readonly cryptoFns: CryptoFunctions,\n\t\tprivate readonly tfs: TempFs,\n\t\tprivate readonly argon2: Promise<Argon2IDExports>,\n\t) {}\n\n\taesEncryptObject(encryptionKey: Aes256Key, object: number | string | boolean | ReadonlyArray<unknown> | object): string {\n\t\tconst serializedObject = JSON.stringify(object)\n\t\tconst encryptedBytes = this.cryptoFns.aesEncrypt(encryptionKey, stringToUtf8Uint8Array(serializedObject))\n\t\treturn uint8ArrayToBase64(encryptedBytes)\n\t}\n\n\taesDecryptObject(encryptionKey: Aes256Key, serializedObject: string): number | string | boolean | ReadonlyArray<unknown> | object {\n\t\tconst encryptedBytes = base64ToUint8Array(serializedObject)\n\t\tconst decryptedBytes = this.cryptoFns.aesDecrypt(encryptionKey, encryptedBytes, true)\n\t\tconst stringObject = utf8Uint8ArrayToString(decryptedBytes)\n\t\treturn JSON.parse(stringObject)\n\t}\n\n\tasync aesEncryptFile(key: Uint8Array, fileUri: string): Promise<EncryptedFileInfo> {\n\t\t// at the moment, this is randomized if the file to be encrypted\n\t\t// was created with FileFacade.writeDataFile.\n\t\t// to make it safe in all conditions, we should re-generate a random file name.\n\t\t// we're also not checking if the file to be encrypted is actually located in\n\t\t// the temp scratch space\n\t\tconst bytes = await this.fs.promises.readFile(fileUri)\n\t\tconst keyBits = this.cryptoFns.bytesToKey(key)\n\t\tconst encrypted = this.cryptoFns.aesEncrypt(keyBits, bytes)\n\t\tconst targetDir = await this.tfs.ensureEncryptedDir()\n\t\tconst writtenFileName = path.basename(fileUri)\n\t\tconst filePath = path.join(targetDir, writtenFileName)\n\t\tawait this.fs.promises.writeFile(filePath, encrypted)\n\t\treturn {\n\t\t\turi: filePath,\n\t\t\tunencryptedSize: bytes.length,\n\t\t}\n\t}\n\n\t/**\n\t * decrypts a file and returns the decrypted files path\n\t */\n\tasync aesDecryptFile(key: Uint8Array, encryptedFileUri: FileUri): Promise<FileUri> {\n\t\tconst targetDir = await this.tfs.ensureUnencrytpedDir()\n\t\tconst encData = await this.fs.promises.readFile(encryptedFileUri)\n\t\tconst bitKey = this.cryptoFns.bytesToKey(key)\n\t\tconst decData = this.cryptoFns.aesDecrypt(bitKey, encData, true)\n\n\t\tconst filesInDirectory = await this.fs.promises.readdir(targetDir)\n\t\t// since we're working purely in scratch space until putFileIntoDownloadsFolder\n\t\t// is called, we could re-generate a random name here.\n\t\tconst writtenFileName = path.basename(encryptedFileUri)\n\t\tconst newFilename = nonClobberingFilename(filesInDirectory, writtenFileName)\n\t\tconst decryptedFileUri = path.join(targetDir, newFilename)\n\t\tawait this.fs.promises.writeFile(decryptedFileUri, decData, {\n\t\t\tencoding: \"binary\",\n\t\t})\n\t\treturn decryptedFileUri\n\t}\n\n\tunauthenticatedAes256DecryptKey(encryptionKey: Aes256Key, keyToDecrypt: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.unauthenticatedAesDecrypt(encryptionKey, keyToDecrypt, false)\n\t}\n\n\taes256EncryptKey(encryptionKey: Aes256Key, keyToEncrypt: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.aesEncrypt(encryptionKey, keyToEncrypt, undefined, false)\n\t}\n\n\taesDecryptBytes(encryptionKey: Aes256Key, data: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.aesDecrypt(encryptionKey, data, true)\n\t}\n\n\taesEncryptBytes(encryptionKey: Aes256Key, data: Uint8Array): Uint8Array {\n\t\treturn this.cryptoFns.aesEncrypt(encryptionKey, data, undefined, true, true)\n\t}\n\n\tdecryptAndMapToInstance<T>(model: TypeModel, instance: Record<string, any>, piSessionKey: Uint8Array, piSessionKeyEncSessionKey: Uint8Array): Promise<T> {\n\t\tconst sk = this.cryptoFns.decryptKey(uint8ArrayToKey(piSessionKey), piSessionKeyEncSessionKey)\n\t\treturn this.cryptoFns.decryptAndMapToInstance(model, instance, sk)\n\t}\n\n\tgenerateId(byteLength: number): string {\n\t\treturn base64ToBase64Url(uint8ArrayToBase64(this.cryptoFns.randomBytes(byteLength)))\n\t}\n\n\tverifySignature(pem: string, data: Uint8Array, sig: Uint8Array): boolean {\n\t\treturn this.cryptoFns.verifySignature(pem, data, sig)\n\t}\n\n\tgenerateDeviceKey(): Aes256Key {\n\t\treturn this.cryptoFns.aes256RandomKey()\n\t}\n\n\trandomBytes(count: number): Uint8Array {\n\t\treturn this.cryptoFns.randomBytes(count)\n\t}\n\n\tasync rsaDecrypt(privateKey: RsaPrivateKey, data: Uint8Array): Promise<Uint8Array> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tasync rsaEncrypt(publicKey: RsaPublicKey, data: Uint8Array, seed: Uint8Array): Promise<Uint8Array> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tasync argon2idGeneratePassphraseKey(passphrase: string, salt: Uint8Array): Promise<Uint8Array> {\n\t\tconst hash = await generateKeyFromPassphraseArgon2id(await this.argon2, passphrase, salt)\n\t\treturn bitArrayToUint8Array(hash)\n\t}\n\n\tgenerateKyberKeypair(seed: Uint8Array): Promise<KyberKeyPair> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tkyberEncapsulate(publicKey: KyberPublicKey, seed: Uint8Array): Promise<KyberEncapsulation> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n\n\tkyberDecapsulate(privateKey: KyberPrivateKey, ciphertext: Uint8Array): Promise<Uint8Array> {\n\t\tthrow new Error(\"not implemented for this platform\")\n\t}\n}\n"]}