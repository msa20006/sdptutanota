{"version":3,"file":"NetAgent.js","sourceRoot":"","sources":["../../../../../src/common/desktop/net/NetAgent.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,KAAK,IAAI,WAAW,EAAE,MAAM,QAAQ,CAAA;AAQpD,yGAAyG;AACzG,MAAM,sBAAsB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAA;AACnD,oCAAoC;AACpC,MAAM,eAAe,GAAG,KAAM,CAAA;AAE9B,2EAA2E;AAC3E,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC;IACvB,WAAW,EAAE,CAAC;IACd,gBAAgB,EAAE,sBAAsB;IACxC,WAAW,EAAE,eAAe;IAC5B,cAAc,EAAE,eAAe;IAC/B,cAAc,EAAE,eAAe;IAC/B,iFAAiF;IACjF,gBAAgB,EAAE,IAAI;CACtB,CAAC,CAAA;AAEF,MAAM,CAAC,MAAM,WAAW,GAAc,KAAK,EAAE,MAAoB,EAAE,IAAwB,EAA2B,EAAE;IACvH,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,CAAC;QACxB,uDAAuD;QACvD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAA;IACrB,CAAC;IACD,OAAO,MAAM,WAAW,CAAC,MAAM,EAAE;QAChC,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC;QACf,UAAU,EAAE,KAAK;KACjB,CAAC,CAAA;AACH,CAAC,CAAA;AAED;;;GAGG;AACH,MAAM,UAAU,cAAc,CAAC,OAA2B;IACzD,MAAM,MAAM,GAAmD,EAAE,CAAA;IACjE,sEAAsE;IACtE,qDAAqD;IACrD,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAA;IAClD,OAAO,MAAM,CAAA;AACd,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,gBAAgB,CAAC,QAAqB;IACrD,OAAO,QAA6E,CAAA;AACrF,CAAC","sourcesContent":["import type { HeadersInit, RequestInit, Response } from \"undici\"\nimport { Agent, fetch as undiciFetch } from \"undici\"\n\nexport type UndiciResponse = Response\nexport type UndiciRequestInit = RequestInit\nexport type UndiciHeadersInit = HeadersInit\nexport type FetchResult = Awaited<ReturnType<FetchImpl>>\nexport type FetchImpl = (target: string | URL, init?: UndiciRequestInit) => Promise<UndiciResponse>\n\n/** How long the socket should stay open without any data sent over it. See IDLE_TIMEOUT_MS in tutadb. */\nconst SOCKET_IDLE_TIMEOUT_MS = 5 * 60 * 1000 + 1000\n/** Timeout between reading data. */\nconst READ_TIMEOUT_MS = 20_000\n\n// We do not enable HTTP2 yet because it is still experimental (and buggy).\nconst agent = new Agent({\n\tconnections: 3,\n\tkeepAliveTimeout: SOCKET_IDLE_TIMEOUT_MS,\n\tbodyTimeout: READ_TIMEOUT_MS,\n\theadersTimeout: READ_TIMEOUT_MS,\n\tconnectTimeout: READ_TIMEOUT_MS,\n\t// this is needed to address issues in some cases where IPv6 does not really work\n\tautoSelectFamily: true,\n})\n\nexport const customFetch: FetchImpl = async (target: string | URL, init?: UndiciRequestInit): Promise<UndiciResponse> => {\n\tif (init?.body != null) {\n\t\t// undici throws an error if this is not taken care of.\n\t\tinit.duplex = \"half\"\n\t}\n\treturn await undiciFetch(target, {\n\t\t...(init ?? {}),\n\t\tdispatcher: agent,\n\t})\n}\n\n/**\n * UndiciHeaderInit is slightly different from the Headers we handle in electron,\n * for example in the protocol interceptors.\n */\nexport function convertHeaders(headers: globalThis.Headers): UndiciHeadersInit {\n\tconst result: Record<string, string | ReadonlyArray<string>> = {}\n\t// false positive: Headers are not arrays and also not really iterable\n\t// eslint-disable-next-line unicorn/no-array-for-each\n\theaders.forEach((val, key) => (result[key] = val))\n\treturn result\n}\n\n/**\n * UndiciResponse.formData.get can return a File as defined in undici/types/file.d.ts (no .path or .webkitRelativePath)\n * the protocol handler expects it to return a file as defined at https://developer.mozilla.org/en-US/docs/Web/API/File\n * which contains .webkitRelativePath. we don't use formData, so we can ignore it.\n *\n * this fixes up the type of just those fields and should be relatively safe even if undici changes their response type.\n */\nexport function toGlobalResponse(response: FetchResult): globalThis.Response {\n\treturn response as typeof response & Pick<globalThis.Response, \"formData\" | \"clone\">\n}\n"]}