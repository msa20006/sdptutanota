{"version":3,"file":"OfflineStorage.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/offline/OfflineStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { ElementEntity, ListElementEntity, SomeEntity, TypeModel } from \"../../common/EntityTypes.js\"\nimport { CUSTOM_MIN_ID, firstBiggerThanSecond, GENERATED_MIN_ID, getElementId } from \"../../common/utils/EntityUtils.js\"\nimport { CacheStorage, expandId, ExposedCacheStorage, LastUpdateTime } from \"../rest/DefaultEntityRestCache.js\"\nimport * as cborg from \"cborg\"\nimport { EncodeOptions, Token, Type } from \"cborg\"\nimport {\n\tassert,\n\tassertNotNull,\n\tbase64ExtToBase64,\n\tbase64ToBase64Ext,\n\tbase64ToBase64Url,\n\tbase64UrlToBase64,\n\tgetTypeId,\n\tgroupByAndMapUniquely,\n\tmapNullable,\n\tsplitInChunks,\n\tTypeRef,\n} from \"@tutao/tutanota-utils\"\nimport { isDesktop, isOfflineStorageAvailable, isTest } from \"../../common/Env.js\"\nimport { modelInfos, resolveTypeReference } from \"../../common/EntityFunctions.js\"\nimport { DateProvider } from \"../../common/DateProvider.js\"\nimport { TokenOrNestedTokens } from \"cborg/interface\"\nimport { CalendarEventTypeRef, MailTypeRef } from \"../../entities/tutanota/TypeRefs.js\"\nimport { OfflineStorageMigrator } from \"./OfflineStorageMigrator.js\"\nimport { CustomCacheHandlerMap, CustomCalendarEventCacheHandler, CustomMailEventCacheHandler } from \"../rest/CustomCacheHandler.js\"\nimport { EntityRestClient } from \"../rest/EntityRestClient.js\"\nimport { InterWindowEventFacadeSendDispatcher } from \"../../../native/common/generatedipc/InterWindowEventFacadeSendDispatcher.js\"\nimport { SqlCipherFacade } from \"../../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { FormattedQuery, SqlValue, TaggedSqlValue, untagSqlObject } from \"./SqlValue.js\"\nimport { AssociationType, Cardinality, Type as TypeId, ValueType } from \"../../common/EntityConstants.js\"\nimport { OutOfSyncError } from \"../../common/error/OutOfSyncError.js\"\nimport { sql, SqlFragment } from \"./Sql.js\"\n\n/**\n * this is the value of SQLITE_MAX_VARIABLE_NUMBER in sqlite3.c\n * it may change if the sqlite version is updated.\n * */\nconst MAX_SAFE_SQL_VARS = 32766\n\nfunction dateEncoder(data: Date, typ: string, options: EncodeOptions): TokenOrNestedTokens | null {\n\tconst time = data.getTime()\n\treturn [\n\t\t// https://datatracker.ietf.org/doc/rfc8943/\n\t\tnew Token(Type.tag, 100),\n\t\tnew Token(time < 0 ? Type.negint : Type.uint, time),\n\t]\n}\n\nfunction dateDecoder(bytes: number): Date {\n\treturn new Date(bytes)\n}\n\nexport const customTypeEncoders: { [typeName: string]: typeof dateEncoder } = Object.freeze({\n\tDate: dateEncoder,\n})\n\ntype TypeDecoder = (_: any) => any\nexport const customTypeDecoders: Array<TypeDecoder> = (() => {\n\tconst tags: Array<TypeDecoder> = []\n\ttags[100] = dateDecoder\n\treturn tags\n})()\n\n/**\n * For each of these keys we track the current version in the database.\n * The keys are different model versions (because we need to migrate the data with certain model version changes) and \"offline\" key which is used to track\n * migrations that are needed for other reasons e.g. if DB structure changes or if we need to invalidate some tables.\n */\nexport type VersionMetadataBaseKey = keyof typeof modelInfos | \"offline\"\n\ntype VersionMetadataEntries = {\n\t// Yes this is cursed, give me a break\n\t[P in VersionMetadataBaseKey as `${P}-version`]: number\n}\n\nexport interface OfflineDbMeta extends VersionMetadataEntries {\n\tlastUpdateTime: number\n\ttimeRangeDays: number\n}\n\nconst TableDefinitions = Object.freeze({\n\t// plus ownerGroup added in a migration\n\tlist_entities:\n\t\t\"type TEXT NOT NULL, listId TEXT NOT NULL, elementId TEXT NOT NULL, ownerGroup TEXT, entity BLOB NOT NULL, PRIMARY KEY (type, listId, elementId)\",\n\t// plus ownerGroup added in a migration\n\telement_entities: \"type TEXT NOT NULL, elementId TEXT NOT NULL, ownerGroup TEXT, entity BLOB NOT NULL, PRIMARY KEY (type, elementId)\",\n\tranges: \"type TEXT NOT NULL, listId TEXT NOT NULL, lower TEXT NOT NULL, upper TEXT NOT NULL, PRIMARY KEY (type, listId)\",\n\tlastUpdateBatchIdPerGroupId: \"groupId TEXT NOT NULL, batchId TEXT NOT NULL, PRIMARY KEY (groupId)\",\n\tmetadata: \"key TEXT NOT NULL, value BLOB, PRIMARY KEY (key)\",\n\tblob_element_entities:\n\t\t\"type TEXT NOT NULL, listId TEXT NOT NULL, elementId TEXT NOT NULL, ownerGroup TEXT, entity BLOB NOT NULL, PRIMARY KEY (type, listId, elementId)\",\n} as const)\n\ntype Range = { lower: Id; upper: Id }\n\nexport interface OfflineStorageInitArgs {\n\tuserId: Id\n\tdatabaseKey: Uint8Array\n\ttimeRangeDays: number | null\n\tforceNewDatabase: boolean\n}\n\nexport class OfflineStorage implements CacheStorage, ExposedCacheStorage {\n\tprivate customCacheHandler: CustomCacheHandlerMap | null = null\n\tprivate userId: Id | null = null\n\tprivate timeRangeDays: number | null = null\n\n\tconstructor(\n\t\tprivate readonly sqlCipherFacade: SqlCipherFacade,\n\t\tprivate readonly interWindowEventSender: InterWindowEventFacadeSendDispatcher,\n\t\tprivate readonly dateProvider: DateProvider,\n\t\tprivate readonly migrator: OfflineStorageMigrator,\n\t\tprivate readonly cleaner: OfflineStorageCleaner,\n\t) {\n\t\tassert(isOfflineStorageAvailable() || isTest(), \"Offline storage is not available.\")\n\t}\n\n\t/**\n\t * @return {boolean} whether the database was newly created or not\n\t */\n\tasync init({ userId, databaseKey, timeRangeDays, forceNewDatabase }: OfflineStorageInitArgs): Promise<boolean> {\n\t\tthis.userId = userId\n\t\tthis.timeRangeDays = timeRangeDays\n\t\tif (forceNewDatabase) {\n\t\t\tif (isDesktop()) {\n\t\t\t\tawait this.interWindowEventSender.localUserDataInvalidated(userId)\n\t\t\t}\n\t\t\tawait this.sqlCipherFacade.deleteDb(userId)\n\t\t}\n\t\t// We open database here, and it is closed in the native side when the window is closed or the page is reloaded\n\t\tawait this.sqlCipherFacade.openDb(userId, databaseKey)\n\t\tawait this.createTables()\n\n\t\ttry {\n\t\t\tawait this.migrator.migrate(this, this.sqlCipherFacade)\n\t\t} catch (e) {\n\t\t\tif (e instanceof OutOfSyncError) {\n\t\t\t\tconsole.warn(\"Offline db is out of sync!\", e)\n\t\t\t\tawait this.recreateDbFile(userId, databaseKey)\n\t\t\t\tawait this.migrator.migrate(this, this.sqlCipherFacade)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t\t// if nothing is written here, it means it's a new database\n\t\treturn (await this.getLastUpdateTime()).type === \"never\"\n\t}\n\n\tprivate async recreateDbFile(userId: string, databaseKey: Uint8Array): Promise<void> {\n\t\tconsole.log(`recreating DB file for userId ${userId}`)\n\t\tawait this.sqlCipherFacade.closeDb()\n\t\tawait this.sqlCipherFacade.deleteDb(userId)\n\t\tawait this.sqlCipherFacade.openDb(userId, databaseKey)\n\t\tawait this.createTables()\n\t}\n\n\t/**\n\t * currently, we close DBs from the native side (mainly on things like reload and on android's onDestroy)\n\t */\n\tasync deinit() {\n\t\tthis.userId = null\n\t\tawait this.sqlCipherFacade.closeDb()\n\t}\n\n\tasync deleteIfExists(typeRef: TypeRef<SomeEntity>, listId: Id | null, elementId: Id): Promise<void> {\n\t\tconst type = getTypeId(typeRef)\n\t\tconst typeModel: TypeModel = await resolveTypeReference(typeRef)\n\t\tconst encodedElementId = ensureBase64Ext(typeModel, elementId)\n\t\tlet formattedQuery\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element:\n\t\t\t\tformattedQuery = sql`DELETE\n\t\t\t\t\t\t\t\t\t FROM element_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t   AND elementId = ${encodedElementId}`\n\t\t\t\tbreak\n\t\t\tcase TypeId.ListElement:\n\t\t\t\tformattedQuery = sql`DELETE\n\t\t\t\t\t\t\t\t\t FROM list_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t   AND listId = ${listId}\n\t\t\t\t\t\t\t\t\t   AND elementId = ${encodedElementId}`\n\t\t\t\tbreak\n\t\t\tcase TypeId.BlobElement:\n\t\t\t\tformattedQuery = sql`DELETE\n\t\t\t\t\t\t\t\t\t FROM blob_element_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t   AND listId = ${listId}\n\t\t\t\t\t\t\t\t\t   AND elementId = ${encodedElementId}`\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"must be a persistent type\")\n\t\t}\n\t\tawait this.sqlCipherFacade.run(formattedQuery.query, formattedQuery.params)\n\t}\n\n\tasync deleteAllOfType(typeRef: TypeRef<SomeEntity>): Promise<void> {\n\t\tconst type = getTypeId(typeRef)\n\t\tlet typeModel: TypeModel\n\t\ttypeModel = await resolveTypeReference(typeRef)\n\t\tlet formattedQuery\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element:\n\t\t\t\tformattedQuery = sql`DELETE\n\t\t\t\t\t\t\t\t\t FROM element_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}`\n\t\t\t\tbreak\n\t\t\tcase TypeId.ListElement:\n\t\t\t\tformattedQuery = sql`DELETE\n\t\t\t\t\t\t\t\t\t FROM list_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}`\n\t\t\t\tawait this.sqlCipherFacade.run(formattedQuery.query, formattedQuery.params)\n\t\t\t\tawait this.deleteAllRangesForType(type)\n\t\t\t\treturn\n\t\t\tcase TypeId.BlobElement:\n\t\t\t\tformattedQuery = sql`DELETE\n\t\t\t\t\t\t\t\t\t FROM blob_element_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}`\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"must be a persistent type\")\n\t\t}\n\t\tawait this.sqlCipherFacade.run(formattedQuery.query, formattedQuery.params)\n\t}\n\n\tprivate async deleteAllRangesForType(type: string): Promise<void> {\n\t\tconst { query, params } = sql`DELETE\n\t\t\t\t\t\t\t\t\t  FROM ranges\n\t\t\t\t\t\t\t\t\t  WHERE type = ${type}`\n\t\tawait this.sqlCipherFacade.run(query, params)\n\t}\n\n\tasync get<T extends SomeEntity>(typeRef: TypeRef<T>, listId: Id | null, elementId: Id): Promise<T | null> {\n\t\tconst type = getTypeId(typeRef)\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst encodedElementId = ensureBase64Ext(typeModel, elementId)\n\t\tlet formattedQuery\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element:\n\t\t\t\tformattedQuery = sql`SELECT entity\n\t\t\t\t\t\t\t\t\t from element_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t   AND elementId = ${encodedElementId}`\n\t\t\t\tbreak\n\t\t\tcase TypeId.ListElement:\n\t\t\t\tformattedQuery = sql`SELECT entity\n\t\t\t\t\t\t\t\t\t from list_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t   AND listId = ${listId}\n\t\t\t\t\t\t\t\t\t   AND elementId = ${encodedElementId}`\n\t\t\t\tbreak\n\t\t\tcase TypeId.BlobElement:\n\t\t\t\tformattedQuery = sql`SELECT entity\n\t\t\t\t\t\t\t\t\t from blob_element_entities\n\t\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t   AND listId = ${listId}\n\t\t\t\t\t\t\t\t\t   AND elementId = ${encodedElementId}`\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"must be a persistent type\")\n\t\t}\n\t\tconst result = await this.sqlCipherFacade.get(formattedQuery.query, formattedQuery.params)\n\t\treturn result?.entity ? await this.deserialize(typeRef, result.entity.value as Uint8Array) : null\n\t}\n\n\tasync provideMultiple<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, elementIds: Id[]): Promise<Array<T>> {\n\t\tif (elementIds.length === 0) return []\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst encodedElementIds = elementIds.map((elementId) => ensureBase64Ext(typeModel, elementId))\n\n\t\tconst type = getTypeId(typeRef)\n\t\tconst serializedList: ReadonlyArray<Record<string, TaggedSqlValue>> = await this.allChunked(\n\t\t\tMAX_SAFE_SQL_VARS - 2,\n\t\t\tencodedElementIds,\n\t\t\t(c) => sql`SELECT entity\n\t\t\t\t\t   FROM list_entities\n\t\t\t\t\t   WHERE type = ${type}\n\t\t\t\t\t\t AND listId = ${listId}\n\t\t\t\t\t\t AND elementId IN ${paramList(c)}`,\n\t\t)\n\t\treturn await this.deserializeList(\n\t\t\ttypeRef,\n\t\t\tserializedList.map((r) => r.entity.value as Uint8Array),\n\t\t)\n\t}\n\n\tasync getIdsInRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<Id>> {\n\t\tconst type = getTypeId(typeRef)\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst range = await this.getRange(typeRef, listId)\n\t\tif (range == null) {\n\t\t\tthrow new Error(`no range exists for ${type} and list ${listId}`)\n\t\t}\n\t\tconst { query, params } = sql`SELECT elementId\n\t\t\t\t\t\t\t\t\t  FROM list_entities\n\t\t\t\t\t\t\t\t\t  WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t\tAND listId = ${listId}\n\t\t\t\t\t\t\t\t\t\tAND (elementId = ${range.lower}\n\t\t\t\t\t\t\t\t\t\t  OR ${firstIdBigger(\"elementId\", range.lower)})\n\t\t\t\t\t\t\t\t\t\tAND NOT (${firstIdBigger(\"elementId\", range.upper)})`\n\t\tconst rows = await this.sqlCipherFacade.all(query, params)\n\t\treturn rows.map((row) => customIdToBase64Url(typeModel, row.elementId.value as string))\n\t}\n\n\t/** don't use this internally in this class, use OfflineStorage::getRange instead. OfflineStorage is\n\t * using converted custom IDs internally which is undone when using this to access the range.\n\t */\n\tasync getRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Range | null> {\n\t\tlet range = await this.getRange(typeRef, listId)\n\t\tif (range == null) return range\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\treturn {\n\t\t\tlower: customIdToBase64Url(typeModel, range.lower),\n\t\t\tupper: customIdToBase64Url(typeModel, range.upper),\n\t\t}\n\t}\n\n\tasync isElementIdInCacheRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, elementId: Id): Promise<boolean> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst encodedElementId = ensureBase64Ext(typeModel, elementId)\n\n\t\tconst range = await this.getRange(typeRef, listId)\n\t\treturn range != null && !firstBiggerThanSecond(encodedElementId, range.upper) && !firstBiggerThanSecond(range.lower, encodedElementId)\n\t}\n\n\tasync provideFromRange<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, start: Id, count: number, reverse: boolean): Promise<T[]> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst encodedStartId = ensureBase64Ext(typeModel, start)\n\t\tconst type = getTypeId(typeRef)\n\t\tlet formattedQuery\n\t\tif (reverse) {\n\t\t\tformattedQuery = sql`SELECT entity\n\t\t\t\t\t\t\t\t FROM list_entities\n\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t   AND listId = ${listId}\n\t\t\t\t\t\t\t\t   AND ${firstIdBigger(encodedStartId, \"elementId\")}\n\t\t\t\t\t\t\t\t ORDER BY LENGTH(elementId) DESC, elementId DESC LIMIT ${count}`\n\t\t} else {\n\t\t\tformattedQuery = sql`SELECT entity\n\t\t\t\t\t\t\t\t FROM list_entities\n\t\t\t\t\t\t\t\t WHERE type = ${type}\n\t\t\t\t\t\t\t\t   AND listId = ${listId}\n\t\t\t\t\t\t\t\t   AND ${firstIdBigger(\"elementId\", encodedStartId)}\n\t\t\t\t\t\t\t\t ORDER BY LENGTH(elementId) ASC, elementId ASC LIMIT ${count}`\n\t\t}\n\t\tconst { query, params } = formattedQuery\n\t\tconst serializedList: ReadonlyArray<Record<string, TaggedSqlValue>> = await this.sqlCipherFacade.all(query, params)\n\t\treturn await this.deserializeList(\n\t\t\ttypeRef,\n\t\t\tserializedList.map((r) => r.entity.value as Uint8Array),\n\t\t)\n\t}\n\n\tasync put(originalEntity: SomeEntity): Promise<void> {\n\t\tconst serializedEntity = this.serialize(originalEntity)\n\t\tconst { listId, elementId } = expandId(originalEntity._id)\n\t\tconst type = getTypeId(originalEntity._type)\n\t\tconst ownerGroup = originalEntity._ownerGroup\n\t\tconst typeModel = await resolveTypeReference(originalEntity._type)\n\t\tconst encodedElementId = ensureBase64Ext(typeModel, elementId)\n\t\tlet formattedQuery: FormattedQuery\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element:\n\t\t\t\tformattedQuery = sql`INSERT\n\t\t\t\tOR REPLACE INTO element_entities (type, elementId, ownerGroup, entity) VALUES (\n\t\t\t\t${type},\n\t\t\t\t${encodedElementId},\n\t\t\t\t${ownerGroup},\n\t\t\t\t${serializedEntity}\n\t\t\t\t)`\n\t\t\t\tbreak\n\t\t\tcase TypeId.ListElement:\n\t\t\t\tformattedQuery = sql`INSERT\n\t\t\t\tOR REPLACE INTO list_entities (type, listId, elementId, ownerGroup, entity) VALUES (\n\t\t\t\t${type},\n\t\t\t\t${listId},\n\t\t\t\t${encodedElementId},\n\t\t\t\t${ownerGroup},\n\t\t\t\t${serializedEntity}\n\t\t\t\t)`\n\t\t\t\tbreak\n\t\t\tcase TypeId.BlobElement:\n\t\t\t\tformattedQuery = sql`INSERT\n\t\t\t\tOR REPLACE INTO blob_element_entities (type, listId, elementId, ownerGroup, entity) VALUES (\n\t\t\t\t${type},\n\t\t\t\t${listId},\n\t\t\t\t${encodedElementId},\n\t\t\t\t${ownerGroup},\n\t\t\t\t${serializedEntity}\n\t\t\t\t)`\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"must be a persistent type\")\n\t\t}\n\t\tawait this.sqlCipherFacade.run(formattedQuery.query, formattedQuery.params)\n\t}\n\n\tasync setLowerRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, lowerId: Id): Promise<void> {\n\t\tlowerId = ensureBase64Ext(await resolveTypeReference(typeRef), lowerId)\n\t\tconst type = getTypeId(typeRef)\n\t\tconst { query, params } = sql`UPDATE ranges\n\t\t\t\t\t\t\t\t\t  SET lower = ${lowerId}\n\t\t\t\t\t\t\t\t\t  WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t\tAND listId = ${listId}`\n\t\tawait this.sqlCipherFacade.run(query, params)\n\t}\n\n\tasync setUpperRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, upperId: Id): Promise<void> {\n\t\tupperId = ensureBase64Ext(await resolveTypeReference(typeRef), upperId)\n\t\tconst type = getTypeId(typeRef)\n\t\tconst { query, params } = sql`UPDATE ranges\n\t\t\t\t\t\t\t\t\t  SET upper = ${upperId}\n\t\t\t\t\t\t\t\t\t  WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t\tAND listId = ${listId}`\n\t\tawait this.sqlCipherFacade.run(query, params)\n\t}\n\n\tasync setNewRangeForList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, lower: Id, upper: Id): Promise<void> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tlower = ensureBase64Ext(typeModel, lower)\n\t\tupper = ensureBase64Ext(typeModel, upper)\n\n\t\tconst type = getTypeId(typeRef)\n\t\tconst { query, params } = sql`INSERT\n\t\tOR REPLACE INTO ranges VALUES (\n\t\t${type},\n\t\t${listId},\n\t\t${lower},\n\t\t${upper}\n\t\t)`\n\t\treturn this.sqlCipherFacade.run(query, params)\n\t}\n\n\tasync getLastBatchIdForGroup(groupId: Id): Promise<Id | null> {\n\t\tconst { query, params } = sql`SELECT batchId\n\t\t\t\t\t\t\t\t\t  from lastUpdateBatchIdPerGroupId\n\t\t\t\t\t\t\t\t\t  WHERE groupId = ${groupId}`\n\t\tconst row = (await this.sqlCipherFacade.get(query, params)) as { batchId: TaggedSqlValue } | null\n\t\treturn (row?.batchId?.value ?? null) as Id | null\n\t}\n\n\tasync putLastBatchIdForGroup(groupId: Id, batchId: Id): Promise<void> {\n\t\tconst { query, params } = sql`INSERT\n\t\tOR REPLACE INTO lastUpdateBatchIdPerGroupId VALUES (\n\t\t${groupId},\n\t\t${batchId}\n\t\t)`\n\t\tawait this.sqlCipherFacade.run(query, params)\n\t}\n\n\tasync getLastUpdateTime(): Promise<LastUpdateTime> {\n\t\tconst time = await this.getMetadata(\"lastUpdateTime\")\n\t\treturn time ? { type: \"recorded\", time } : { type: \"never\" }\n\t}\n\n\tasync putLastUpdateTime(ms: number): Promise<void> {\n\t\tawait this.putMetadata(\"lastUpdateTime\", ms)\n\t}\n\n\tasync purgeStorage(): Promise<void> {\n\t\tfor (let name of Object.keys(TableDefinitions)) {\n\t\t\tawait this.sqlCipherFacade.run(\n\t\t\t\t`DELETE\n\t\t\t\t FROM ${name}`,\n\t\t\t\t[],\n\t\t\t)\n\t\t}\n\t}\n\n\tasync deleteRange(typeRef: TypeRef<unknown>, listId: string): Promise<void> {\n\t\tconst { query, params } = sql`DELETE\n\t\t\t\t\t\t\t\t\t  FROM ranges\n\t\t\t\t\t\t\t\t\t  WHERE type = ${getTypeId(typeRef)}\n\t\t\t\t\t\t\t\t\t\tAND listId = ${listId}`\n\t\tawait this.sqlCipherFacade.run(query, params)\n\t}\n\n\tasync getRawListElementsOfType(typeRef: TypeRef<ListElementEntity>): Promise<Array<ListElementEntity>> {\n\t\tconst { query, params } = sql`SELECT entity\n\t\t\t\t\t\t\t\t\t  from list_entities\n\t\t\t\t\t\t\t\t\t  WHERE type = ${getTypeId(typeRef)}`\n\t\tconst items = (await this.sqlCipherFacade.all(query, params)) ?? []\n\t\treturn items.map((item) => this.decodeCborEntity(item.entity.value as Uint8Array) as Record<string, unknown> & ListElementEntity)\n\t}\n\n\tasync getRawElementsOfType(typeRef: TypeRef<ElementEntity>): Promise<Array<ElementEntity>> {\n\t\tconst { query, params } = sql`SELECT entity\n\t\t\t\t\t\t\t\t\t  from element_entities\n\t\t\t\t\t\t\t\t\t  WHERE type = ${getTypeId(typeRef)}`\n\t\tconst items = (await this.sqlCipherFacade.all(query, params)) ?? []\n\t\treturn items.map((item) => this.decodeCborEntity(item.entity.value as Uint8Array) as Record<string, unknown> & ElementEntity)\n\t}\n\n\tasync getElementsOfType<T extends ElementEntity>(typeRef: TypeRef<T>): Promise<Array<T>> {\n\t\tconst { query, params } = sql`SELECT entity\n\t\t\t\t\t\t\t\t\t  from element_entities\n\t\t\t\t\t\t\t\t\t  WHERE type = ${getTypeId(typeRef)}`\n\t\tconst items = (await this.sqlCipherFacade.all(query, params)) ?? []\n\t\treturn await this.deserializeList(\n\t\t\ttypeRef,\n\t\t\titems.map((row) => row.entity.value as Uint8Array),\n\t\t)\n\t}\n\n\tasync getWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<Array<T>> {\n\t\tconst { query, params } = sql`SELECT entity\n\t\t\t\t\t\t\t\t\t  FROM list_entities\n\t\t\t\t\t\t\t\t\t  WHERE type = ${getTypeId(typeRef)}\n\t\t\t\t\t\t\t\t\t\tAND listId = ${listId}`\n\t\tconst items = (await this.sqlCipherFacade.all(query, params)) ?? []\n\t\treturn await this.deserializeList(\n\t\t\ttypeRef,\n\t\t\titems.map((row) => row.entity.value as Uint8Array),\n\t\t)\n\t}\n\n\tasync dumpMetadata(): Promise<Partial<OfflineDbMeta>> {\n\t\tconst query = \"SELECT * from metadata\"\n\t\tconst stored = (await this.sqlCipherFacade.all(query, [])).map((row) => [row.key.value as string, row.value.value as Uint8Array] as const)\n\t\treturn Object.fromEntries(stored.map(([key, value]) => [key, cborg.decode(value)])) as OfflineDbMeta\n\t}\n\n\tasync setStoredModelVersion(model: VersionMetadataBaseKey, version: number) {\n\t\treturn this.putMetadata(`${model}-version`, version)\n\t}\n\n\tgetCustomCacheHandlerMap(entityRestClient: EntityRestClient): CustomCacheHandlerMap {\n\t\tif (this.customCacheHandler == null) {\n\t\t\tthis.customCacheHandler = new CustomCacheHandlerMap(\n\t\t\t\t{\n\t\t\t\t\tref: CalendarEventTypeRef,\n\t\t\t\t\thandler: new CustomCalendarEventCacheHandler(entityRestClient),\n\t\t\t\t},\n\t\t\t\t{ ref: MailTypeRef, handler: new CustomMailEventCacheHandler() },\n\t\t\t)\n\t\t}\n\t\treturn this.customCacheHandler\n\t}\n\n\tgetUserId(): Id {\n\t\treturn assertNotNull(this.userId, \"No user id, not initialized?\")\n\t}\n\n\tasync deleteAllOwnedBy(owner: Id): Promise<void> {\n\t\t{\n\t\t\tconst { query, params } = sql`DELETE\n\t\t\t\t\t\t\t\t\t\t  FROM element_entities\n\t\t\t\t\t\t\t\t\t\t  WHERE ownerGroup = ${owner}`\n\t\t\tawait this.sqlCipherFacade.run(query, params)\n\t\t}\n\t\t{\n\t\t\t// first, check which list Ids contain entities owned by the lost group\n\t\t\tconst { query, params } = sql`SELECT listId, type\n\t\t\t\t\t\t\t\t\t\t  FROM list_entities\n\t\t\t\t\t\t\t\t\t\t  WHERE ownerGroup = ${owner}`\n\t\t\tconst rangeRows = await this.sqlCipherFacade.all(query, params)\n\t\t\tconst rows = rangeRows.map((row) => untagSqlObject(row) as { listId: string; type: string })\n\t\t\tconst listIdsByType: Map<string, Set<Id>> = groupByAndMapUniquely(\n\t\t\t\trows,\n\t\t\t\t(row) => row.type,\n\t\t\t\t(row) => row.listId,\n\t\t\t)\n\t\t\t// delete the ranges for those listIds\n\t\t\tfor (const [type, listIds] of listIdsByType.entries()) {\n\t\t\t\t// this particular query uses one other SQL var for the type.\n\t\t\t\tconst safeChunkSize = MAX_SAFE_SQL_VARS - 1\n\t\t\t\tconst listIdArr = Array.from(listIds)\n\t\t\t\tawait this.runChunked(\n\t\t\t\t\tsafeChunkSize,\n\t\t\t\t\tlistIdArr,\n\t\t\t\t\t(c) => sql`DELETE\n\t\t\t\t\t\t\t   FROM ranges\n\t\t\t\t\t\t\t   WHERE type = ${type}\n\t\t\t\t\t\t\t\t AND listId IN ${paramList(c)}`,\n\t\t\t\t)\n\t\t\t\tawait this.runChunked(\n\t\t\t\t\tsafeChunkSize,\n\t\t\t\t\tlistIdArr,\n\t\t\t\t\t(c) => sql`DELETE\n\t\t\t\t\t\t\t   FROM list_entities\n\t\t\t\t\t\t\t   WHERE type = ${type}\n\t\t\t\t\t\t\t\t AND listId IN ${paramList(c)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst { query, params } = sql`DELETE\n\t\t\t\t\t\t\t\t\t\t  FROM blob_element_entities\n\t\t\t\t\t\t\t\t\t\t  WHERE ownerGroup = ${owner}`\n\t\t\tawait this.sqlCipherFacade.run(query, params)\n\t\t}\n\t\t{\n\t\t\tconst { query, params } = sql`DELETE\n\t\t\t\t\t\t\t\t\t\t  FROM lastUpdateBatchIdPerGroupId\n\t\t\t\t\t\t\t\t\t\t  WHERE groupId = ${owner}`\n\t\t\tawait this.sqlCipherFacade.run(query, params)\n\t\t}\n\t}\n\n\tasync deleteWholeList<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id): Promise<void> {\n\t\tawait this.lockRangesDbAccess(listId)\n\t\tawait this.deleteRange(typeRef, listId)\n\t\tconst { query, params } = sql`DELETE\n\t\t\t\t\t\t\t\t\t  FROM list_entities\n\t\t\t\t\t\t\t\t\t  WHERE listId = ${listId}`\n\t\tawait this.sqlCipherFacade.run(query, params)\n\t\tawait this.unlockRangesDbAccess(listId)\n\t}\n\n\tprivate async putMetadata<K extends keyof OfflineDbMeta>(key: K, value: OfflineDbMeta[K]): Promise<void> {\n\t\tlet encodedValue\n\t\ttry {\n\t\t\tencodedValue = cborg.encode(value)\n\t\t} catch (e) {\n\t\t\tconsole.log(\"[OfflineStorage] failed to encode metadata for key\", key, \"with value\", value)\n\t\t\tthrow e\n\t\t}\n\t\tconst { query, params } = sql`INSERT\n\t\tOR REPLACE INTO metadata VALUES (\n\t\t${key},\n\t\t${encodedValue}\n\t\t)`\n\t\tawait this.sqlCipherFacade.run(query, params)\n\t}\n\n\tprivate async getMetadata<K extends keyof OfflineDbMeta>(key: K): Promise<OfflineDbMeta[K] | null> {\n\t\tconst { query, params } = sql`SELECT value\n\t\t\t\t\t\t\t\t\t  from metadata\n\t\t\t\t\t\t\t\t\t  WHERE key = ${key}`\n\t\tconst encoded = await this.sqlCipherFacade.get(query, params)\n\t\treturn encoded && cborg.decode(encoded.value.value as Uint8Array)\n\t}\n\n\t/**\n\t * Clear out unneeded data from the offline database (i.e. trash and spam lists, old data).\n\t * This will be called after login (CachePostLoginActions.ts) to ensure fast login time.\n\t * @param timeRangeDays: the maximum age of days that mails should be to be kept in the database. if null, will use a default value\n\t * @param userId id of the current user. default, last stored userId\n\t */\n\tasync clearExcludedData(timeRangeDays: number | null = this.timeRangeDays, userId: Id = this.getUserId()): Promise<void> {\n\t\tawait this.cleaner.cleanOfflineDb(this, timeRangeDays, userId, this.dateProvider.now())\n\t}\n\n\tprivate async createTables() {\n\t\tfor (let [name, definition] of Object.entries(TableDefinitions)) {\n\t\t\tawait this.sqlCipherFacade.run(\n\t\t\t\t`CREATE TABLE IF NOT EXISTS ${name}\n\t\t\t\t (\n\t\t\t\t\t ${definition}\n\t\t\t\t )`,\n\t\t\t\t[],\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate async getRange(typeRef: TypeRef<ElementEntity | ListElementEntity>, listId: Id): Promise<Range | null> {\n\t\tconst type = getTypeId(typeRef)\n\t\tconst { query, params } = sql`SELECT upper, lower\n\t\t\t\t\t\t\t\t\t  FROM ranges\n\t\t\t\t\t\t\t\t\t  WHERE type = ${type}\n\t\t\t\t\t\t\t\t\t\tAND listId = ${listId}`\n\t\tconst row = (await this.sqlCipherFacade.get(query, params)) ?? null\n\n\t\treturn mapNullable(row, untagSqlObject) as Range | null\n\t}\n\n\tasync deleteIn(typeRef: TypeRef<unknown>, listId: Id | null, elementIds: Id[]): Promise<void> {\n\t\tif (elementIds.length === 0) return\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst encodedElementIds = elementIds.map((elementIds) => ensureBase64Ext(typeModel, elementIds))\n\t\tswitch (typeModel.type) {\n\t\t\tcase TypeId.Element:\n\t\t\t\treturn await this.runChunked(\n\t\t\t\t\tMAX_SAFE_SQL_VARS - 1,\n\t\t\t\t\tencodedElementIds,\n\t\t\t\t\t(c) => sql`DELETE\n\t\t\t\t\t\t\t   FROM element_entities\n\t\t\t\t\t\t\t   WHERE type = ${getTypeId(typeRef)}\n\t\t\t\t\t\t\t\t AND elementId IN ${paramList(c)}`,\n\t\t\t\t)\n\t\t\tcase TypeId.ListElement:\n\t\t\t\treturn await this.runChunked(\n\t\t\t\t\tMAX_SAFE_SQL_VARS - 2,\n\t\t\t\t\tencodedElementIds,\n\t\t\t\t\t(c) => sql`DELETE\n\t\t\t\t\t\t\t   FROM list_entities\n\t\t\t\t\t\t\t   WHERE type = ${getTypeId(typeRef)}\n\t\t\t\t\t\t\t\t AND listId = ${listId}\n\t\t\t\t\t\t\t\t AND elementId IN ${paramList(c)}`,\n\t\t\t\t)\n\t\t\tcase TypeId.BlobElement:\n\t\t\t\treturn await this.runChunked(\n\t\t\t\t\tMAX_SAFE_SQL_VARS - 2,\n\t\t\t\t\tencodedElementIds,\n\t\t\t\t\t(c) => sql`DELETE\n\t\t\t\t\t\t\t   FROM blob_element_entities\n\t\t\t\t\t\t\t   WHERE type = ${getTypeId(typeRef)}\n\t\t\t\t\t\t\t\t AND listId = ${listId}\n\t\t\t\t\t\t\t\t AND elementId IN ${paramList(c)}`,\n\t\t\t\t)\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"must be a persistent type\")\n\t\t}\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" db when updating / reading the\n\t * offline available mail list / mailset ranges for each mail list (referenced using the listId).\n\t * @param listId the mail list or mail set entry list that we want to lock\n\t */\n\tasync lockRangesDbAccess(listId: Id) {\n\t\tawait this.sqlCipherFacade.lockRangesDbAccess(listId)\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(listId)\".\n\t * @param listId the mail list that we want to unlock\n\t */\n\tasync unlockRangesDbAccess(listId: Id) {\n\t\tawait this.sqlCipherFacade.unlockRangesDbAccess(listId)\n\t}\n\n\tasync updateRangeForListAndDeleteObsoleteData<T extends ListElementEntity>(typeRef: TypeRef<T>, listId: Id, rawCutoffId: Id): Promise<void> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\tconst isCustomId = isCustomIdType(typeModel)\n\t\tconst encodedCutoffId = ensureBase64Ext(typeModel, rawCutoffId)\n\n\t\tconst range = await this.getRange(typeRef, listId)\n\t\tif (range == null) {\n\t\t\treturn\n\t\t}\n\n\t\t// If the range for a given list is complete from the beginning (starts at GENERATED_MIN_ID), then we only want to actually modify the\n\t\t// saved range if we would be removing elements from the list, in order to not lose the information that the range is complete in storage.\n\t\t// So we have to check how old the oldest element in said range is. If it is newer than cutoffId, then we will not modify the range,\n\t\t// otherwise we will just modify it normally\n\t\tconst expectedMinId = isCustomId ? CUSTOM_MIN_ID : GENERATED_MIN_ID\n\t\tif (range.lower === expectedMinId) {\n\t\t\tconst entities = await this.provideFromRange(typeRef, listId, expectedMinId, 1, false)\n\t\t\tconst id = mapNullable(entities[0], getElementId)\n\t\t\tconst rangeWontBeModified = id == null || firstBiggerThanSecond(id, encodedCutoffId) || id === encodedCutoffId\n\t\t\tif (rangeWontBeModified) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif (firstBiggerThanSecond(encodedCutoffId, range.lower)) {\n\t\t\t// If the upper id of the range is below the cutoff, then the entire range will be deleted from the storage\n\t\t\t// so we just delete the range as well\n\t\t\t// Otherwise, we only want to modify\n\t\t\tif (firstBiggerThanSecond(encodedCutoffId, range.upper)) {\n\t\t\t\tawait this.deleteRange(typeRef, listId)\n\t\t\t} else {\n\t\t\t\tawait this.setLowerRangeForList(typeRef, listId, rawCutoffId)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate serialize(originalEntity: SomeEntity): Uint8Array {\n\t\ttry {\n\t\t\treturn cborg.encode(originalEntity, { typeEncoders: customTypeEncoders })\n\t\t} catch (e) {\n\t\t\tconsole.log(\"[OfflineStorage] failed to encode entity of type\", originalEntity._type, \"with id\", originalEntity._id)\n\t\t\tthrow e\n\t\t}\n\t}\n\n\t/**\n\t * Convert the type from CBOR representation to the runtime type\n\t */\n\tprivate async deserialize<T extends SomeEntity>(typeRef: TypeRef<T>, loaded: Uint8Array): Promise<T | null> {\n\t\tlet deserialized\n\t\ttry {\n\t\t\tdeserialized = this.decodeCborEntity(loaded)\n\t\t} catch (e) {\n\t\t\tconsole.log(e)\n\t\t\tconsole.log(`Error with CBOR decode. Trying to decode (of type: ${typeof loaded}): ${loaded}`)\n\t\t\treturn null\n\t\t}\n\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\treturn (await this.fixupTypeRefs(typeModel, deserialized)) as T\n\t}\n\n\tprivate decodeCborEntity(loaded: Uint8Array): Record<string, unknown> {\n\t\treturn cborg.decode(loaded, { tags: customTypeDecoders })\n\t}\n\n\tprivate async fixupTypeRefs(typeModel: TypeModel, deserialized: any): Promise<unknown> {\n\t\t// TypeRef cannot be deserialized back automatically. We could write a codec for it but we don't actually need to store it so we just \"patch\" it.\n\t\t// Some places rely on TypeRef being a class and not a plain object.\n\t\t// We also have to update all aggregates, recursively.\n\t\tdeserialized._type = new TypeRef(typeModel.app, typeModel.name)\n\t\tfor (const [associationName, associationModel] of Object.entries(typeModel.associations)) {\n\t\t\tif (associationModel.type === AssociationType.Aggregation) {\n\t\t\t\tconst aggregateTypeRef = new TypeRef(associationModel.dependency ?? typeModel.app, associationModel.refType)\n\t\t\t\tconst aggregateTypeModel = await resolveTypeReference(aggregateTypeRef)\n\t\t\t\tswitch (associationModel.cardinality) {\n\t\t\t\t\tcase Cardinality.One:\n\t\t\t\t\tcase Cardinality.ZeroOrOne: {\n\t\t\t\t\t\tconst aggregate = deserialized[associationName]\n\t\t\t\t\t\tif (aggregate) {\n\t\t\t\t\t\t\tawait this.fixupTypeRefs(aggregateTypeModel, aggregate)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase Cardinality.Any: {\n\t\t\t\t\t\tconst aggregateList = deserialized[associationName]\n\t\t\t\t\t\tfor (const aggregate of aggregateList) {\n\t\t\t\t\t\t\tawait this.fixupTypeRefs(aggregateTypeModel, aggregate)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn deserialized\n\t}\n\n\tprivate async deserializeList<T extends SomeEntity>(typeRef: TypeRef<T>, loaded: Array<Uint8Array>): Promise<Array<T>> {\n\t\t// manually reimplementing promiseMap to make sure we don't hit the scheduler since there's nothing actually async happening\n\t\tconst result: Array<T> = []\n\t\tfor (const entity of loaded) {\n\t\t\tconst deserialized = await this.deserialize(typeRef, entity)\n\t\t\tif (deserialized != null) {\n\t\t\t\tresult.push(deserialized)\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * convenience method to run a potentially too large query over several chunks.\n\t * chunkSize must be chosen such that the total number of SQL variables in the final query does not exceed MAX_SAFE_SQL_VARS\n\t * */\n\tprivate async runChunked(chunkSize: number, originalList: SqlValue[], formatter: (chunk: SqlValue[]) => FormattedQuery): Promise<void> {\n\t\tfor (const chunk of splitInChunks(chunkSize, originalList)) {\n\t\t\tconst formattedQuery = formatter(chunk)\n\t\t\tawait this.sqlCipherFacade.run(formattedQuery.query, formattedQuery.params)\n\t\t}\n\t}\n\n\t/**\n\t * convenience method to execute a potentially too large query over several chunks.\n\t * chunkSize must be chosen such that the total number of SQL variables in the final query does not exceed MAX_SAFE_SQL_VARS\n\t * */\n\tprivate async allChunked(\n\t\tchunkSize: number,\n\t\toriginalList: SqlValue[],\n\t\tformatter: (chunk: SqlValue[]) => FormattedQuery,\n\t): Promise<Array<Record<string, TaggedSqlValue>>> {\n\t\tconst result: Array<Record<string, TaggedSqlValue>> = []\n\t\tfor (const chunk of splitInChunks(chunkSize, originalList)) {\n\t\t\tconst formattedQuery = formatter(chunk)\n\t\t\tresult.push(...(await this.sqlCipherFacade.all(formattedQuery.query, formattedQuery.params)))\n\t\t}\n\t\treturn result\n\t}\n}\n\n/*\n * used to automatically create the right amount of SQL variables for selecting ids from a dynamic list.\n * must be used within sql`<query>` template string to inline the logic into the query.\n *\n * It is very important that params is kept to a size such that the total amount of SQL variables is\n * less than MAX_SAFE_SQL_VARS.\n */\nfunction paramList(params: SqlValue[]): SqlFragment {\n\tconst qs = params.map(() => \"?\").join(\",\")\n\treturn new SqlFragment(`(${qs})`, params)\n}\n\n/**\n * comparison to select ids that are bigger or smaller than a parameter id\n * must be used within sql`<query>` template string to inline the logic into the query.\n *\n * will always insert 3 constants and 3 SQL variables into the query.\n */\nfunction firstIdBigger(...args: [string, \"elementId\"] | [\"elementId\", string]): SqlFragment {\n\tlet [l, r]: [string, string] = args\n\tlet v\n\tif (l === \"elementId\") {\n\t\tv = r\n\t\tr = \"?\"\n\t} else {\n\t\tv = l\n\t\tl = \"?\"\n\t}\n\treturn new SqlFragment(`(CASE WHEN length(${l}) > length(${r}) THEN 1 WHEN length(${l}) < length(${r}) THEN 0 ELSE ${l} > ${r} END)`, [v, v, v])\n}\n\nexport function isCustomIdType(typeModel: TypeModel): boolean {\n\treturn typeModel.values._id.type === ValueType.CustomId\n}\n\n/**\n * We store customIds as base64ext in the db to make them sortable, but we get them as base64url from the server.\n */\nexport function ensureBase64Ext(typeModel: TypeModel, elementId: Id): Id {\n\tif (isCustomIdType(typeModel)) {\n\t\treturn base64ToBase64Ext(base64UrlToBase64(elementId))\n\t}\n\treturn elementId\n}\n\nexport function customIdToBase64Url(typeModel: TypeModel, elementId: Id): Id {\n\tif (isCustomIdType(typeModel)) {\n\t\treturn base64ToBase64Url(base64ExtToBase64(elementId))\n\t}\n\treturn elementId\n}\n\nexport interface OfflineStorageCleaner {\n\tcleanOfflineDb(offlineStorage: OfflineStorage, timeRangeDays: number | null, userId: Id, now: number): Promise<void>\n}\n"]}