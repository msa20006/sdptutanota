{"version":3,"file":"EntityRestClient.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/rest/EntityRestClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { RestClient, SuspensionBehavior } from \"./RestClient\"\nimport type { CryptoFacade } from \"../crypto/CryptoFacade\"\nimport { _verifyType, HttpMethod, MediaType, resolveTypeReference } from \"../../common/EntityFunctions\"\nimport { SessionKeyNotFoundError } from \"../../common/error/SessionKeyNotFoundError\"\nimport type { EntityUpdate } from \"../../entities/sys/TypeRefs.js\"\nimport { PushIdentifierTypeRef } from \"../../entities/sys/TypeRefs.js\"\nimport {\n\tConnectionError,\n\tInternalServerError,\n\tNotAuthenticatedError,\n\tNotAuthorizedError,\n\tNotFoundError,\n\tPayloadTooLargeError,\n} from \"../../common/error/RestError\"\nimport type { KeyVersion, lazy } from \"@tutao/tutanota-utils\"\nimport { isSameTypeRef, Mapper, ofClass, promiseMap, splitInChunks, TypeRef } from \"@tutao/tutanota-utils\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport type { ListElementEntity, SomeEntity, TypeModel } from \"../../common/EntityTypes\"\nimport { getElementId, LOAD_MULTIPLE_LIMIT, POST_MULTIPLE_LIMIT } from \"../../common/utils/EntityUtils\"\nimport { Type } from \"../../common/EntityConstants.js\"\nimport { SetupMultipleError } from \"../../common/error/SetupMultipleError\"\nimport { expandId } from \"./DefaultEntityRestCache.js\"\nimport { InstanceMapper } from \"../crypto/InstanceMapper\"\nimport { QueuedBatch } from \"../EventQueue.js\"\nimport { AuthDataProvider } from \"../facades/UserFacade\"\nimport { LoginIncompleteError } from \"../../common/error/LoginIncompleteError.js\"\nimport { BlobServerUrl } from \"../../entities/storage/TypeRefs.js\"\nimport { BlobAccessTokenFacade } from \"../facades/BlobAccessTokenFacade.js\"\nimport { AesKey } from \"@tutao/tutanota-crypto\"\nimport { isOfflineError } from \"../../common/utils/ErrorUtils.js\"\nimport { VersionedEncryptedKey, VersionedKey } from \"../crypto/CryptoWrapper.js\"\nimport { parseKeyVersion } from \"../facades/KeyLoaderFacade.js\"\n\nassertWorkerOrNode()\n\nexport function typeRefToPath(typeRef: TypeRef<any>): string {\n\treturn `/rest/${typeRef.app}/${typeRef.type.toLowerCase()}`\n}\n\nexport interface EntityRestClientSetupOptions {\n\tbaseUrl?: string\n\t/** Use this key to encrypt session key instead of trying to resolve the owner key based on the ownerGroup. */\n\townerKey?: VersionedKey\n}\n\nexport interface EntityRestClientUpdateOptions {\n\tbaseUrl?: string\n\t/** Use the key provided by this to decrypt the existing ownerEncSessionKey instead of trying to resolve the owner key based on the ownerGroup. */\n\townerKeyProvider?: OwnerKeyProvider\n}\n\nexport interface EntityRestClientEraseOptions {\n\textraHeaders?: Dict\n}\n\n/**\n * Determines how to handle caching behavior (i.e. reading/writing).\n *\n * Use {@link getCacheModeBehavior} to programmatically check the behavior of the cache mode.\n */\nexport const enum CacheMode {\n\t/** Prefer cached value if it's there, or fall back to network and write it to cache. */\n\tReadAndWrite,\n\n\t/**\n\t * Always retrieve from the network, but still save to cache.\n\t *\n\t * NOTE: This cannot be used with ranged requests.\n\t */\n\tWriteOnly,\n\n\t/** Prefer cached value, but in case of a cache miss, retrieve the value from network without writing it to cache. */\n\tReadOnly,\n}\n\n/**\n * Get the behavior of the cache mode for the options\n * @param cacheMode cache mode to check, or if `undefined`, check the default cache mode ({@link CacheMode.ReadAndWrite})\n */\nexport function getCacheModeBehavior(cacheMode: CacheMode | undefined): {\n\treadsFromCache: boolean\n\twritesToCache: boolean\n} {\n\tswitch (cacheMode ?? CacheMode.ReadAndWrite) {\n\t\tcase CacheMode.ReadAndWrite:\n\t\t\treturn { readsFromCache: true, writesToCache: true }\n\t\tcase CacheMode.WriteOnly:\n\t\t\treturn { readsFromCache: false, writesToCache: true }\n\t\tcase CacheMode.ReadOnly:\n\t\t\treturn { readsFromCache: true, writesToCache: false }\n\t}\n}\n\nexport interface EntityRestClientLoadOptions {\n\tqueryParams?: Dict\n\textraHeaders?: Dict\n\t/** Use the key provided by this to decrypt the existing ownerEncSessionKey instead of trying to resolve the owner key based on the ownerGroup. */\n\townerKeyProvider?: OwnerKeyProvider\n\t/** Defaults to {@link CacheMode.ReadAndWrite }*/\n\tcacheMode?: CacheMode\n\tbaseUrl?: string\n\tsuspensionBehavior?: SuspensionBehavior\n}\n\nexport interface OwnerEncSessionKeyProvider {\n\t(instanceElementId: Id): Promise<VersionedEncryptedKey>\n}\n\nexport interface OwnerKeyProvider {\n\t(ownerKeyVersion: KeyVersion): Promise<AesKey>\n}\n\n/**\n * The EntityRestInterface provides a convenient interface for invoking server side REST services.\n */\nexport interface EntityRestInterface {\n\t/**\n\t * Reads a single element from the server (or cache). Entities are decrypted before they are returned.\n\t * @param ownerKey Use this key to decrypt session key instead of trying to resolve the owner key based on the ownerGroup.\n\t */\n\tload<T extends SomeEntity>(typeRef: TypeRef<T>, id: PropertyType<T, \"_id\">, loadOptions?: EntityRestClientLoadOptions): Promise<T>\n\n\t/**\n\t * Reads a range of elements from the server (or cache). Entities are decrypted before they are returned.\n\t */\n\tloadRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\tloadOptions?: EntityRestClientLoadOptions,\n\t): Promise<T[]>\n\n\t/**\n\t * Reads multiple elements from the server (or cache). Entities are decrypted before they are returned.\n\t * @param ownerEncSessionKeyProvider use this to resolve the instances session key in case instance.ownerEncSessionKey is not defined (which might be undefined for MailDetails / Files)\n\t */\n\tloadMultiple<T extends SomeEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id | null,\n\t\telementIds: Array<Id>,\n\t\townerEncSessionKeyProvider?: OwnerEncSessionKeyProvider,\n\t\tloadOptions?: EntityRestClientLoadOptions,\n\t): Promise<Array<T>>\n\n\t/**\n\t * Creates a single element on the server. Entities are encrypted before they are sent.\n\t */\n\tsetup<T extends SomeEntity>(listId: Id | null, instance: T, extraHeaders?: Dict, options?: EntityRestClientSetupOptions): Promise<Id>\n\n\t/**\n\t * Creates multiple elements on the server. Entities are encrypted before they are sent.\n\t */\n\tsetupMultiple<T extends SomeEntity>(listId: Id | null, instances: ReadonlyArray<T>): Promise<Array<Id>>\n\n\t/**\n\t * Modifies a single element on the server. Entities are encrypted before they are sent.\n\t * @param instance\n\t * @param options\n\t */\n\tupdate<T extends SomeEntity>(instance: T, options?: EntityRestClientUpdateOptions): Promise<void>\n\n\t/**\n\t * Deletes a single element on the server.\n\t */\n\terase<T extends SomeEntity>(instance: T, options?: EntityRestClientEraseOptions): Promise<void>\n\n\t/**\n\t * Must be called when entity events are received.\n\t * @param batch The entity events that were received.\n\t * @return Similar to the events in the data parameter, but reduced by the events which are obsolete.\n\t */\n\tentityEventsReceived(batch: QueuedBatch): Promise<Array<EntityUpdate>>\n}\n\n/**\n * Retrieves the instances from the backend (db) and converts them to entities.\n *\n * Part of this process is\n * * the decryption for the returned instances (GET) and the encryption of all instances before they are sent (POST, PUT)\n * * the injection of aggregate instances for the returned instances (GET)\n * * caching for retrieved instances (GET)\n *\n */\nexport class EntityRestClient implements EntityRestInterface {\n\tget _crypto(): CryptoFacade {\n\t\treturn this.lazyCrypto()\n\t}\n\n\tconstructor(\n\t\tprivate readonly authDataProvider: AuthDataProvider,\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly lazyCrypto: lazy<CryptoFacade>,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly blobAccessTokenFacade: BlobAccessTokenFacade,\n\t) {}\n\n\tasync load<T extends SomeEntity>(typeRef: TypeRef<T>, id: PropertyType<T, \"_id\">, opts: EntityRestClientLoadOptions = {}): Promise<T> {\n\t\tconst { listId, elementId } = expandId(id)\n\t\tconst { path, queryParams, headers, typeModel } = await this._validateAndPrepareRestRequest(\n\t\t\ttypeRef,\n\t\t\tlistId,\n\t\t\telementId,\n\t\t\topts.queryParams,\n\t\t\topts.extraHeaders,\n\t\t\topts.ownerKeyProvider,\n\t\t)\n\t\tconst json = await this.restClient.request(path, HttpMethod.GET, {\n\t\t\tqueryParams,\n\t\t\theaders,\n\t\t\tresponseType: MediaType.Json,\n\t\t\tbaseUrl: opts.baseUrl,\n\t\t})\n\t\tconst entity = JSON.parse(json)\n\t\tconst migratedEntity = await this._crypto.applyMigrations(typeRef, entity)\n\t\tconst sessionKey = await this.resolveSessionKey(opts.ownerKeyProvider, migratedEntity, typeModel)\n\n\t\tconst instance = await this.instanceMapper.decryptAndMapToInstance<T>(typeModel, migratedEntity, sessionKey)\n\t\treturn this._crypto.applyMigrationsForInstance(instance)\n\t}\n\n\tprivate async resolveSessionKey(ownerKeyProvider: OwnerKeyProvider | undefined, migratedEntity: Record<string, any>, typeModel: TypeModel) {\n\t\ttry {\n\t\t\tif (ownerKeyProvider && migratedEntity._ownerEncSessionKey) {\n\t\t\t\tconst ownerKey = await ownerKeyProvider(parseKeyVersion(migratedEntity._ownerKeyVersion ?? 0))\n\t\t\t\treturn this._crypto.resolveSessionKeyWithOwnerKey(migratedEntity, ownerKey)\n\t\t\t} else {\n\t\t\t\treturn await this._crypto.resolveSessionKey(typeModel, migratedEntity)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof SessionKeyNotFoundError) {\n\t\t\t\tconsole.log(`could not resolve session key for instance of type ${typeModel.app}/${typeModel.name}`, e)\n\t\t\t\treturn null\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tasync loadRange<T extends ListElementEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id,\n\t\tstart: Id,\n\t\tcount: number,\n\t\treverse: boolean,\n\t\topts: EntityRestClientLoadOptions = {},\n\t): Promise<T[]> {\n\t\tconst rangeRequestParams = {\n\t\t\tstart: String(start),\n\t\t\tcount: String(count),\n\t\t\treverse: String(reverse),\n\t\t}\n\t\tconst { path, headers, typeModel, queryParams } = await this._validateAndPrepareRestRequest(\n\t\t\ttypeRef,\n\t\t\tlistId,\n\t\t\tnull,\n\t\t\tObject.assign(rangeRequestParams, opts.queryParams),\n\t\t\topts.extraHeaders,\n\t\t\topts.ownerKeyProvider,\n\t\t)\n\t\t// This should never happen if type checking is not bypassed with any\n\t\tif (typeModel.type !== Type.ListElement) throw new Error(\"only ListElement types are permitted\")\n\t\tconst json = await this.restClient.request(path, HttpMethod.GET, {\n\t\t\tqueryParams,\n\t\t\theaders,\n\t\t\tresponseType: MediaType.Json,\n\t\t\tbaseUrl: opts.baseUrl,\n\t\t\tsuspensionBehavior: opts.suspensionBehavior,\n\t\t})\n\t\treturn this._handleLoadMultipleResult(typeRef, JSON.parse(json))\n\t}\n\n\tasync loadMultiple<T extends SomeEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tlistId: Id | null,\n\t\telementIds: Array<Id>,\n\t\townerEncSessionKeyProvider?: OwnerEncSessionKeyProvider,\n\t\topts: EntityRestClientLoadOptions = {},\n\t): Promise<Array<T>> {\n\t\tconst { path, headers } = await this._validateAndPrepareRestRequest(typeRef, listId, null, opts.queryParams, opts.extraHeaders, opts.ownerKeyProvider)\n\t\tconst idChunks = splitInChunks(LOAD_MULTIPLE_LIMIT, elementIds)\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\n\t\tconst loadedChunks = await promiseMap(idChunks, async (idChunk) => {\n\t\t\tlet queryParams = {\n\t\t\t\tids: idChunk.join(\",\"),\n\t\t\t}\n\t\t\tlet json: string\n\t\t\tif (typeModel.type === Type.BlobElement) {\n\t\t\t\tjson = await this.loadMultipleBlobElements(listId, queryParams, headers, path, typeRef, opts.suspensionBehavior)\n\t\t\t} else {\n\t\t\t\tjson = await this.restClient.request(path, HttpMethod.GET, {\n\t\t\t\t\tqueryParams,\n\t\t\t\t\theaders,\n\t\t\t\t\tresponseType: MediaType.Json,\n\t\t\t\t\tbaseUrl: opts.baseUrl,\n\t\t\t\t\tsuspensionBehavior: opts.suspensionBehavior,\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn this._handleLoadMultipleResult(typeRef, JSON.parse(json), ownerEncSessionKeyProvider)\n\t\t})\n\t\treturn loadedChunks.flat()\n\t}\n\n\tprivate async loadMultipleBlobElements(\n\t\tarchiveId: Id | null,\n\t\tqueryParams: { ids: string },\n\t\theaders: Dict | undefined,\n\t\tpath: string,\n\t\ttypeRef: TypeRef<any>,\n\t\tsuspensionBehavior?: SuspensionBehavior,\n\t): Promise<string> {\n\t\tif (archiveId == null) {\n\t\t\tthrow new Error(\"archiveId must be set to load BlobElementTypes\")\n\t\t}\n\t\tconst doBlobRequest = async () => {\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestReadTokenArchive(archiveId)\n\t\t\tconst additionalRequestParams = Object.assign(\n\t\t\t\t{},\n\t\t\t\theaders, // prevent CORS request due to non standard header usage\n\t\t\t\tqueryParams,\n\t\t\t)\n\t\t\tconst allParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, additionalRequestParams, typeRef)\n\t\t\treturn tryServers(\n\t\t\t\tblobServerAccessInfo.servers,\n\t\t\t\tasync (serverUrl) =>\n\t\t\t\t\tthis.restClient.request(path, HttpMethod.GET, {\n\t\t\t\t\t\tqueryParams: allParams,\n\t\t\t\t\t\theaders: {}, // prevent CORS request due to non standard header usage\n\t\t\t\t\t\tresponseType: MediaType.Json,\n\t\t\t\t\t\tbaseUrl: serverUrl,\n\t\t\t\t\t\tnoCORS: true,\n\t\t\t\t\t\tsuspensionBehavior,\n\t\t\t\t\t}),\n\t\t\t\t`can't load instances from server `,\n\t\t\t)\n\t\t}\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictArchiveToken(archiveId)\n\n\t\treturn doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t}\n\n\tasync _handleLoadMultipleResult<T extends SomeEntity>(\n\t\ttypeRef: TypeRef<T>,\n\t\tloadedEntities: Array<any>,\n\t\townerEncSessionKeyProvider?: OwnerEncSessionKeyProvider,\n\t): Promise<Array<T>> {\n\t\tconst model = await resolveTypeReference(typeRef)\n\n\t\t// PushIdentifier was changed in the system model v43 to encrypt the name.\n\t\t// We check here to check the type only once per array and not for each element.\n\t\tif (isSameTypeRef(typeRef, PushIdentifierTypeRef)) {\n\t\t\tawait promiseMap(loadedEntities, (instance) => this._crypto.applyMigrations(typeRef, instance), {\n\t\t\t\tconcurrency: 5,\n\t\t\t})\n\t\t}\n\n\t\treturn promiseMap(\n\t\t\tloadedEntities,\n\t\t\t(instance) => {\n\t\t\t\treturn this._decryptMapAndMigrate(instance, model, ownerEncSessionKeyProvider)\n\t\t\t},\n\t\t\t{ concurrency: 5 },\n\t\t)\n\t}\n\n\tasync _decryptMapAndMigrate<T>(instance: any, model: TypeModel, ownerEncSessionKeyProvider?: OwnerEncSessionKeyProvider): Promise<T> {\n\t\tlet sessionKey: AesKey | null\n\t\tif (ownerEncSessionKeyProvider) {\n\t\t\tsessionKey = await this._crypto.decryptSessionKey(instance, await ownerEncSessionKeyProvider(getElementId(instance)))\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tsessionKey = await this._crypto.resolveSessionKey(model, instance)\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof SessionKeyNotFoundError) {\n\t\t\t\t\tconsole.log(\"could not resolve session key\", e, e.message, e.stack)\n\t\t\t\t\tsessionKey = null // will result in _errors being set on the instance\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst decryptedInstance = await this.instanceMapper.decryptAndMapToInstance<T>(model, instance, sessionKey)\n\t\treturn this._crypto.applyMigrationsForInstance<T>(decryptedInstance)\n\t}\n\n\tasync setup<T extends SomeEntity>(listId: Id | null, instance: T, extraHeaders?: Dict, options?: EntityRestClientSetupOptions): Promise<Id> {\n\t\tconst typeRef = instance._type\n\t\tconst { typeModel, path, headers, queryParams } = await this._validateAndPrepareRestRequest(\n\t\t\ttypeRef,\n\t\t\tlistId,\n\t\t\tnull,\n\t\t\tundefined,\n\t\t\textraHeaders,\n\t\t\toptions?.ownerKey,\n\t\t)\n\n\t\tif (typeModel.type === Type.ListElement) {\n\t\t\tif (!listId) throw new Error(\"List id must be defined for LETs\")\n\t\t} else {\n\t\t\tif (listId) throw new Error(\"List id must not be defined for ETs\")\n\t\t}\n\n\t\tconst sk = await this._crypto.setNewOwnerEncSessionKey(typeModel, instance, options?.ownerKey)\n\n\t\tconst encryptedEntity = await this.instanceMapper.encryptAndMapToLiteral(typeModel, instance, sk)\n\t\tconst persistencePostReturn = await this.restClient.request(path, HttpMethod.POST, {\n\t\t\tbaseUrl: options?.baseUrl,\n\t\t\tqueryParams,\n\t\t\theaders,\n\t\t\tbody: JSON.stringify(encryptedEntity),\n\t\t\tresponseType: MediaType.Json,\n\t\t})\n\t\treturn JSON.parse(persistencePostReturn).generatedId\n\t}\n\n\tasync setupMultiple<T extends SomeEntity>(listId: Id | null, instances: Array<T>): Promise<Array<Id>> {\n\t\tconst count = instances.length\n\n\t\tif (count < 1) {\n\t\t\treturn []\n\t\t}\n\n\t\tconst instanceChunks = splitInChunks(POST_MULTIPLE_LIMIT, instances)\n\t\tconst typeRef = instances[0]._type\n\t\tconst { typeModel, path, headers } = await this._validateAndPrepareRestRequest(typeRef, listId, null, undefined, undefined, undefined)\n\n\t\tif (typeModel.type === Type.ListElement) {\n\t\t\tif (!listId) throw new Error(\"List id must be defined for LETs\")\n\t\t} else {\n\t\t\tif (listId) throw new Error(\"List id must not be defined for ETs\")\n\t\t}\n\n\t\tconst errors: Error[] = []\n\t\tconst failedInstances: T[] = []\n\t\tconst idChunks: Array<Array<Id>> = await promiseMap(instanceChunks, async (instanceChunk) => {\n\t\t\ttry {\n\t\t\t\tconst encryptedEntities = await promiseMap(instanceChunk, async (e) => {\n\t\t\t\t\tconst sk = await this._crypto.setNewOwnerEncSessionKey(typeModel, e)\n\n\t\t\t\t\treturn this.instanceMapper.encryptAndMapToLiteral(typeModel, e, sk)\n\t\t\t\t})\n\t\t\t\t// informs the server that this is a POST_MULTIPLE request\n\t\t\t\tconst queryParams = {\n\t\t\t\t\tcount: String(instanceChunk.length),\n\t\t\t\t}\n\t\t\t\tconst persistencePostReturn = await this.restClient.request(path, HttpMethod.POST, {\n\t\t\t\t\tqueryParams,\n\t\t\t\t\theaders,\n\t\t\t\t\tbody: JSON.stringify(encryptedEntities),\n\t\t\t\t\tresponseType: MediaType.Json,\n\t\t\t\t})\n\t\t\t\treturn this.parseSetupMultiple(persistencePostReturn)\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof PayloadTooLargeError) {\n\t\t\t\t\t// If we try to post too many large instances then we get PayloadTooLarge\n\t\t\t\t\t// So we fall back to posting single instances\n\t\t\t\t\tconst returnedIds = await promiseMap(instanceChunk, (instance) => {\n\t\t\t\t\t\treturn this.setup(listId, instance).catch((e) => {\n\t\t\t\t\t\t\terrors.push(e)\n\t\t\t\t\t\t\tfailedInstances.push(instance)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\treturn returnedIds.filter(Boolean) as Id[]\n\t\t\t\t} else {\n\t\t\t\t\terrors.push(e)\n\t\t\t\t\tfailedInstances.push(...instanceChunk)\n\t\t\t\t\treturn [] as Id[]\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (errors.length) {\n\t\t\tif (errors.some(isOfflineError)) {\n\t\t\t\tthrow new ConnectionError(\"Setup multiple entities failed\")\n\t\t\t}\n\t\t\tthrow new SetupMultipleError<T>(\"Setup multiple entities failed\", errors, failedInstances)\n\t\t} else {\n\t\t\treturn idChunks.flat()\n\t\t}\n\t}\n\n\tasync update<T extends SomeEntity>(instance: T, options?: EntityRestClientUpdateOptions): Promise<void> {\n\t\tif (!instance._id) throw new Error(\"Id must be defined\")\n\t\tconst { listId, elementId } = expandId(instance._id)\n\t\tconst { path, queryParams, headers, typeModel } = await this._validateAndPrepareRestRequest(\n\t\t\tinstance._type,\n\t\t\tlistId,\n\t\t\telementId,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\toptions?.ownerKeyProvider,\n\t\t)\n\t\tconst sessionKey = await this.resolveSessionKey(options?.ownerKeyProvider, instance, typeModel)\n\t\tconst encryptedEntity = await this.instanceMapper.encryptAndMapToLiteral(typeModel, instance, sessionKey)\n\t\tawait this.restClient.request(path, HttpMethod.PUT, {\n\t\t\tbaseUrl: options?.baseUrl,\n\t\t\tqueryParams,\n\t\t\theaders,\n\t\t\tbody: JSON.stringify(encryptedEntity),\n\t\t\tresponseType: MediaType.Json,\n\t\t})\n\t}\n\n\tasync erase<T extends SomeEntity>(instance: T, options?: EntityRestClientEraseOptions): Promise<void> {\n\t\tconst { listId, elementId } = expandId(instance._id)\n\t\tconst { path, queryParams, headers } = await this._validateAndPrepareRestRequest(\n\t\t\tinstance._type,\n\t\t\tlistId,\n\t\t\telementId,\n\t\t\tundefined,\n\t\t\toptions?.extraHeaders,\n\t\t\tundefined,\n\t\t)\n\t\tawait this.restClient.request(path, HttpMethod.DELETE, {\n\t\t\tqueryParams,\n\t\t\theaders,\n\t\t})\n\t}\n\n\tasync _validateAndPrepareRestRequest(\n\t\ttypeRef: TypeRef<any>,\n\t\tlistId: Id | null,\n\t\telementId: Id | null,\n\t\tqueryParams: Dict | undefined,\n\t\textraHeaders: Dict | undefined,\n\t\townerKey: OwnerKeyProvider | VersionedKey | undefined,\n\t): Promise<{\n\t\tpath: string\n\t\tqueryParams: Dict | undefined\n\t\theaders: Dict | undefined\n\t\ttypeModel: TypeModel\n\t}> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\n\t\t_verifyType(typeModel)\n\n\t\tif (ownerKey == undefined && !this.authDataProvider.isFullyLoggedIn() && typeModel.encrypted) {\n\t\t\t// Short-circuit before we do an actual request which we can't decrypt\n\t\t\tthrow new LoginIncompleteError(`Trying to do a network request with encrypted entity but is not fully logged in yet, type: ${typeModel.name}`)\n\t\t}\n\n\t\tlet path = typeRefToPath(typeRef)\n\n\t\tif (listId) {\n\t\t\tpath += \"/\" + listId\n\t\t}\n\n\t\tif (elementId) {\n\t\t\tpath += \"/\" + elementId\n\t\t}\n\n\t\tconst headers = Object.assign({}, this.authDataProvider.createAuthHeaders(), extraHeaders)\n\n\t\tif (Object.keys(headers).length === 0) {\n\t\t\tthrow new NotAuthenticatedError(\"user must be authenticated for entity requests\")\n\t\t}\n\n\t\theaders.v = typeModel.version\n\t\treturn {\n\t\t\tpath,\n\t\t\tqueryParams,\n\t\t\theaders,\n\t\t\ttypeModel,\n\t\t}\n\t}\n\n\t/**\n\t * for the admin area (no cache available)\n\t */\n\tentityEventsReceived(batch: QueuedBatch): Promise<Array<EntityUpdate>> {\n\t\treturn Promise.resolve(batch.events)\n\t}\n\n\tgetRestClient(): RestClient {\n\t\treturn this.restClient\n\t}\n\n\tprivate parseSetupMultiple(result: any): Id[] {\n\t\ttry {\n\t\t\treturn JSON.parse(result).map((r: any) => r.generatedId)\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Invalid response: ${result}, ${e}`)\n\t\t}\n\t}\n}\n\n/**\n * Tries to run the mapper action against a list of servers. If the action resolves\n * successfully, the result is returned. In case of an ConnectionError and errors\n * that might occur only for a single blob server, the next server is tried.\n * Throws in all other cases.\n */\nexport async function tryServers<T>(servers: BlobServerUrl[], mapper: Mapper<string, T>, errorMsg: string): Promise<T> {\n\tlet index = 0\n\tlet error: Error | null = null\n\tfor (const server of servers) {\n\t\ttry {\n\t\t\treturn await mapper(server.url, index)\n\t\t} catch (e) {\n\t\t\t// InternalServerError is returned when accessing a corrupted archive, so we retry\n\t\t\tif (e instanceof ConnectionError || e instanceof InternalServerError || e instanceof NotFoundError) {\n\t\t\t\tconsole.log(`${errorMsg} ${server.url}`, e)\n\t\t\t\terror = e\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t\tindex++\n\t}\n\tthrow error\n}\n\n/**\n * Do a blob request and retry it in case of a NotAuthorizedError, performing some cleanup before retrying.\n *\n * This is useful for blob requests to handle expired tokens, which cah occur if the requests take a long time, the client gets suspended or paused by the OS.\n * @param doBlobRequest\n * @param doEvictTokenBeforeRetry\n */\nexport async function doBlobRequestWithRetry<T>(doBlobRequest: () => Promise<T>, doEvictTokenBeforeRetry: () => void): Promise<T> {\n\treturn doBlobRequest().catch(\n\t\t// in case one of the chunks could not be uploaded because of an invalid/expired token we upload all chunks again in order to guarantee that they are uploaded to the same archive.\n\t\t// we don't have to take care of already uploaded chunks, as they are unreferenced and will be cleaned up by the server automatically.\n\t\tofClass(NotAuthorizedError, (e) => {\n\t\t\tdoEvictTokenBeforeRetry()\n\t\t\treturn doBlobRequest()\n\t\t}),\n\t)\n}\n\nexport function getIds(\n\tinstance: any,\n\ttypeModel: TypeModel,\n): {\n\tlistId: string | null\n\tid: string\n} {\n\tif (!instance._id) throw new Error(\"Id must be defined\")\n\tlet listId = null\n\tlet id\n\n\tif (typeModel.type === Type.ListElement) {\n\t\tlistId = instance._id[0]\n\t\tid = instance._id[1]\n\t} else {\n\t\tid = instance._id\n\t}\n\n\treturn {\n\t\tlistId,\n\t\tid,\n\t}\n}\n"]}