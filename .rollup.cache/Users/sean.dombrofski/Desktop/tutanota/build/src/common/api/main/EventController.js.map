{"version":3,"file":"EventController.js","sourceRoot":"","sources":["../../../../../src/common/api/main/EventController.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,uBAAuB,CAAA;AAEhE,OAAO,MAAM,MAAM,gBAAgB,CAAA;AAEnC,OAAO,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAA;AAIhD,gBAAgB,EAAE,CAAA;AAIlB,MAAM,GAAG,GAAG,mBAAmB,CAAA;AAI/B,MAAM,OAAO,eAAe;IAIE;IAHrB,cAAc,GAAiC,MAAM,EAAE,CAAA;IACvD,eAAe,GAA8B,IAAI,GAAG,EAAE,CAAA;IAE9D,YAA6B,MAAuB;QAAvB,WAAM,GAAN,MAAM,CAAiB;IAAG,CAAC;IAExD,iBAAiB,CAAC,QAA8B;QAC/C,IAAI,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,iCAAiC,CAAC,CAAA;QACrD,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;QACnC,CAAC;IACF,CAAC;IAED,oBAAoB,CAAC,QAA8B;QAClD,MAAM,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;QACxD,IAAI,CAAC,UAAU,EAAE,CAAC;YACjB,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,2CAA2C,EAAE,QAAQ,CAAC,CAAA;QACzE,CAAC;IACF,CAAC;IAED,iBAAiB;QAChB,kCAAkC;QAClC,OAAO,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IACzC,CAAC;IAED,KAAK,CAAC,sBAAsB,CAAC,aAA0C,EAAE,iBAAqB;QAC7F,IAAI,aAAa,GAAG,OAAO,CAAC,OAAO,EAAE,CAAA;QAErC,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,EAAE,CAAC;YAClC,mGAAmG;YACnG,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,EAAE,CAAC,oBAAoB,CAAC,aAAgD,EAAE,iBAAiB,CAAC,CAAA;QAC1I,CAAC;QAED,OAAO,aAAa;aAClB,IAAI,CAAC,KAAK,IAAI,EAAE;YAChB,wDAAwD;YACxD,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;gBAC7C,IAAI,iBAAiB,GAA4B,QAAQ,CAAC,aAAa,CAAC,CAAA;gBACxE,MAAM,QAAQ,CAAC,iBAAiB,EAAE,iBAAiB,CAAC,CAAA;YACrD,CAAC;QACF,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,CAAA;IACb,CAAC;IAED,KAAK,CAAC,wBAAwB,CAAC,MAA4B;QAC1D,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;IAC5B,CAAC;CACD","sourcesContent":["import { downcast, identity, noOp } from \"@tutao/tutanota-utils\"\nimport type { LoginController } from \"./LoginController\"\nimport stream from \"mithril/stream\"\nimport Stream from \"mithril/stream\"\nimport { assertMainOrNode } from \"../common/Env\"\nimport { EntityUpdate, WebsocketCounterData } from \"../entities/sys/TypeRefs\"\nimport { EntityUpdateData } from \"../common/utils/EntityUpdateUtils.js\"\n\nassertMainOrNode()\n\nexport type ExposedEventController = Pick<EventController, \"onEntityUpdateReceived\" | \"onCountersUpdateReceived\">\n\nconst TAG = \"[EventController]\"\n\nexport type EntityEventsListener = (updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: Id) => Promise<unknown>\n\nexport class EventController {\n\tprivate countersStream: Stream<WebsocketCounterData> = stream()\n\tprivate entityListeners: Set<EntityEventsListener> = new Set()\n\n\tconstructor(private readonly logins: LoginController) {}\n\n\taddEntityListener(listener: EntityEventsListener) {\n\t\tif (this.entityListeners.has(listener)) {\n\t\t\tconsole.warn(TAG, \"Adding the same listener twice!\")\n\t\t} else {\n\t\t\tthis.entityListeners.add(listener)\n\t\t}\n\t}\n\n\tremoveEntityListener(listener: EntityEventsListener) {\n\t\tconst wasRemoved = this.entityListeners.delete(listener)\n\t\tif (!wasRemoved) {\n\t\t\tconsole.warn(TAG, \"Could not remove listener, possible leak?\", listener)\n\t\t}\n\t}\n\n\tgetCountersStream(): Stream<WebsocketCounterData> {\n\t\t// Create copy so it's never ended\n\t\treturn this.countersStream.map(identity)\n\t}\n\n\tasync onEntityUpdateReceived(entityUpdates: ReadonlyArray<EntityUpdate>, eventOwnerGroupId: Id): Promise<void> {\n\t\tlet loginsUpdates = Promise.resolve()\n\n\t\tif (this.logins.isUserLoggedIn()) {\n\t\t\t// the UserController must be notified first as other event receivers depend on it to be up-to-date\n\t\t\tloginsUpdates = this.logins.getUserController().entityEventsReceived(entityUpdates as ReadonlyArray<EntityUpdateData>, eventOwnerGroupId)\n\t\t}\n\n\t\treturn loginsUpdates\n\t\t\t.then(async () => {\n\t\t\t\t// sequentially to prevent parallel loading of instances\n\t\t\t\tfor (const listener of this.entityListeners) {\n\t\t\t\t\tlet entityUpdatesData: Array<EntityUpdateData> = downcast(entityUpdates)\n\t\t\t\t\tawait listener(entityUpdatesData, eventOwnerGroupId)\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(noOp)\n\t}\n\n\tasync onCountersUpdateReceived(update: WebsocketCounterData): Promise<void> {\n\t\tthis.countersStream(update)\n\t}\n}\n"]}