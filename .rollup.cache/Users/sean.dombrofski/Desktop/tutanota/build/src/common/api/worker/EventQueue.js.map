{"version":3,"file":"EventQueue.js","sourceRoot":"","sources":["../../../../../src/common/api/worker/EventQueue.ts"],"names":[],"mappings":"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","sourcesContent":["import { OperationType } from \"../common/TutanotaConstants.js\"\nimport { findAllAndRemove } from \"@tutao/tutanota-utils\"\nimport { ConnectionError, ServiceUnavailableError } from \"../common/error/RestError.js\"\nimport type { EntityUpdate } from \"../entities/sys/TypeRefs.js\"\nimport { ProgrammingError } from \"../common/error/ProgrammingError.js\"\nimport { ProgressMonitorDelegate } from \"./ProgressMonitorDelegate.js\"\n\nexport type QueuedBatch = {\n\tevents: EntityUpdate[]\n\tgroupId: Id\n\tbatchId: Id\n}\n\nexport const enum EntityModificationType {\n\tCREATE = \"CREATE\",\n\tUPDATE = \"UPDATE\",\n\tDELETE = \"DELETE\",\n}\n\ntype QueueAction = (nextElement: QueuedBatch) => Promise<void>\n\n/**\n * Checks which modification is applied in the given batch for the entity id.\n * @param batch entity updates of the batch.\n * @private visibleForTests\n */\nexport function batchMod(batchId: Id, batch: ReadonlyArray<EntityUpdate>, entityUpdate: EntityUpdate): EntityModificationType {\n\tfor (const batchEvent of batch) {\n\t\tif (\n\t\t\tentityUpdate.instanceId === batchEvent.instanceId &&\n\t\t\tentityUpdate.instanceListId === batchEvent.instanceListId &&\n\t\t\tentityUpdate.application === batchEvent.application &&\n\t\t\tentityUpdate.type === batchEvent.type\n\t\t) {\n\t\t\tswitch (batchEvent.operation) {\n\t\t\t\tcase OperationType.CREATE:\n\t\t\t\t\treturn EntityModificationType.CREATE\n\n\t\t\t\tcase OperationType.UPDATE:\n\t\t\t\t\treturn EntityModificationType.UPDATE\n\n\t\t\t\tcase OperationType.DELETE:\n\t\t\t\t\treturn EntityModificationType.DELETE\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ProgrammingError(`Unknown operation: ${batchEvent.operation}`)\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow new ProgrammingError(\n\t\t`Batch does not have events for ${entityUpdate.application}/${entityUpdate.type} ${lastOperationKey(entityUpdate)}, batchId: ${batchId}`,\n\t)\n}\n\n// A key for _lastOperationForEntity.\n// At runtime just an element id or listId/elementId.\n// Adding brand for type safety.\ntype LastOperationKey = string & { __brand: \"lastOpeKey\" }\n\nfunction lastOperationKey(update: EntityUpdate): LastOperationKey {\n\tconst typeIdentifier = `${update.application}/${update.type}`\n\tif (update.instanceListId) {\n\t\treturn `${typeIdentifier}/${update.instanceListId}/${update.instanceId}` as LastOperationKey\n\t} else {\n\t\treturn `${typeIdentifier}/${update.instanceId}` as LastOperationKey\n\t}\n}\n\nexport class EventQueue {\n\t/** Batches to process. Oldest first. */\n\tprivate readonly eventQueue: Array<QueuedBatch>\n\t// the last processed operation for a given entity id\n\tprivate readonly lastOperationForEntity: Map<LastOperationKey, QueuedBatch>\n\tprivate processingBatch: QueuedBatch | null\n\tprivate paused: boolean\n\tprivate progressMonitor: ProgressMonitorDelegate | null\n\n\t/**\n\t * @param tag identifier to make for better log messages\n\t * @param optimizationEnabled whether the queue should try to optimize events and remove unnecessary ones with the knowledge of newer ones\n\t * @param queueAction which is executed for each batch. Must *never* throw.\n\t */\n\tconstructor(private readonly tag: string, private readonly optimizationEnabled: boolean, private readonly queueAction: QueueAction) {\n\t\tthis.eventQueue = []\n\t\tthis.lastOperationForEntity = new Map()\n\t\tthis.processingBatch = null\n\t\tthis.paused = false\n\t\tthis.progressMonitor = null\n\t}\n\n\taddBatches(batches: ReadonlyArray<QueuedBatch>) {\n\t\tfor (const batch of batches) {\n\t\t\tthis.add(batch.batchId, batch.groupId, batch.events)\n\t\t}\n\t}\n\n\tsetProgressMonitor(progressMonitor: ProgressMonitorDelegate) {\n\t\tthis.progressMonitor?.completed() // make sure any old monitor does not have pending work\n\t\tthis.progressMonitor = progressMonitor\n\t}\n\n\t/**\n\t * @return whether the batch was added (not optimized away)\n\t */\n\tadd(batchId: Id, groupId: Id, newEvents: ReadonlyArray<EntityUpdate>): boolean {\n\t\tconst newBatch: QueuedBatch = {\n\t\t\tevents: [],\n\t\t\tgroupId,\n\t\t\tbatchId,\n\t\t}\n\n\t\tif (!this.optimizationEnabled) {\n\t\t\tnewBatch.events.push(...newEvents)\n\t\t} else {\n\t\t\tthis.optimizingAddEvents(newBatch, batchId, groupId, newEvents)\n\t\t}\n\n\t\tif (newBatch.events.length !== 0) {\n\t\t\tthis.eventQueue.push(newBatch)\n\n\t\t\tfor (const update of newBatch.events) {\n\t\t\t\tthis.lastOperationForEntity.set(lastOperationKey(update), newBatch)\n\t\t\t}\n\t\t}\n\n\t\t// ensures that events are processed when not paused\n\t\tthis.start()\n\t\treturn newBatch.events.length > 0\n\t}\n\n\tprivate optimizingAddEvents(newBatch: QueuedBatch, batchId: Id, groupId: Id, newEvents: ReadonlyArray<EntityUpdate>): void {\n\t\tfor (const newEvent of newEvents) {\n\t\t\tconst lastOpKey = lastOperationKey(newEvent)\n\t\t\tconst lastBatchForEntity = this.lastOperationForEntity.get(lastOpKey)\n\t\t\tif (\n\t\t\t\tlastBatchForEntity == null ||\n\t\t\t\t(this.processingBatch != null && this.processingBatch === lastBatchForEntity) ||\n\t\t\t\tgroupId !== lastBatchForEntity.groupId\n\t\t\t) {\n\t\t\t\t// If there's no current operation, there's nothing to merge, just add\n\t\t\t\t// If current operation is already being processed, don't modify it, we cannot merge anymore and should just append.\n\t\t\t\tnewBatch.events.push(newEvent)\n\t\t\t} else {\n\t\t\t\tconst newEntityModification = batchMod(batchId, newEvents, newEvent)\n\t\t\t\tconst lastEntityModification = batchMod(lastBatchForEntity.batchId, lastBatchForEntity.events, newEvent)\n\n\t\t\t\tif (newEntityModification === EntityModificationType.UPDATE) {\n\t\t\t\t\tswitch (lastEntityModification) {\n\t\t\t\t\t\tcase EntityModificationType.CREATE:\n\t\t\t\t\t\t\t// Skip create because the create was not processed yet and we will download the updated version already\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase EntityModificationType.UPDATE:\n\t\t\t\t\t\t\t// Skip update because the previous update was not processed yet and we will download the updated version already\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase EntityModificationType.DELETE:\n\t\t\t\t\t\t\tthrow new ProgrammingError(\n\t\t\t\t\t\t\t\t`UPDATE not allowed after DELETE. Last batch: ${lastBatchForEntity.batchId}, new batch: ${batchId}, ${newEvent.type} ${lastOpKey}`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t} else if (newEntityModification === EntityModificationType.DELETE) {\n\t\t\t\t\t// delete all other events because they don't matter if the entity is already gone\n\t\t\t\t\tthis.removeEventsForInstance(lastOpKey)\n\t\t\t\t\t// set last operation early to make sure that it's not some empty batch that is the last operation, otherwise batchMod will fail.\n\t\t\t\t\t// this shouldn't happen (because delete + create for the same entity in the same batch is not really a thing) and is a bit hacky,\n\t\t\t\t\t// but it works?\n\t\t\t\t\tthis.lastOperationForEntity.set(lastOpKey, newBatch)\n\t\t\t\t\t// add delete event\n\t\t\t\t\tnewBatch.events.push(newEvent)\n\t\t\t\t} else if (newEntityModification === EntityModificationType.CREATE) {\n\t\t\t\t\tif (lastEntityModification === EntityModificationType.DELETE || lastEntityModification === EntityModificationType.CREATE) {\n\t\t\t\t\t\t// It is likely custom id instance which got re-created\n\t\t\t\t\t\tnewBatch.events.push(newEvent)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new ProgrammingError(\n\t\t\t\t\t\t\t`Impossible modification combination ${lastEntityModification} ${newEntityModification} ${JSON.stringify(newEvent)}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new ProgrammingError(\n\t\t\t\t\t\t`Impossible modification combination ${lastEntityModification} ${newEntityModification} ${JSON.stringify(newEvent)}`,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate removeEventsForInstance(operationKey: LastOperationKey, startIndex: number = 0): void {\n\t\t// We keep empty batches because we expect certain number of batches to be processed and it's easier to just keep them.\n\t\tfor (let i = startIndex; i < this.eventQueue.length; i++) {\n\t\t\tconst batchInThePast = this.eventQueue[i]\n\t\t\tif (this.processingBatch === batchInThePast) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// this will remove all events for the element id from the batch\n\t\t\t// we keep delete events because they don't hurt generally and we also want things to be timely deleted\n\t\t\tfindAllAndRemove(batchInThePast.events, (event) => event.operation !== OperationType.DELETE && lastOperationKey(event) === operationKey)\n\t\t}\n\t}\n\n\tstart() {\n\t\tif (this.processingBatch) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.processNext()\n\t}\n\n\tqueueSize(): number {\n\t\treturn this.eventQueue.length\n\t}\n\n\tprivate processNext() {\n\t\tif (this.paused) {\n\t\t\treturn\n\t\t}\n\n\t\tconst next = this.eventQueue[0]\n\n\t\tif (next) {\n\t\t\tthis.processingBatch = next\n\n\t\t\tthis.queueAction(next)\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis.eventQueue.shift()\n\t\t\t\t\tthis.progressMonitor?.workDone(1)\n\t\t\t\t\tthis.processingBatch = null\n\n\t\t\t\t\t// When we are done with the batch, we don't want to merge with it anymore\n\t\t\t\t\tfor (const event of next.events) {\n\t\t\t\t\t\tconst concatenatedId = lastOperationKey(event)\n\t\t\t\t\t\tif (this.lastOperationForEntity.get(concatenatedId) === next) {\n\t\t\t\t\t\t\tthis.lastOperationForEntity.delete(concatenatedId)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.processNext()\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tconsole.log(\"EventQueue\", this.tag, this.optimizationEnabled, \"error\", next, e)\n\t\t\t\t\t// processing continues if the event bus receives a new event\n\t\t\t\t\tthis.processingBatch = null\n\n\t\t\t\t\tif (!(e instanceof ServiceUnavailableError || e instanceof ConnectionError)) {\n\t\t\t\t\t\tconsole.error(\"Uncaught EventQueue error!\", e, next)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis.eventQueue.splice(0)\n\n\t\tthis.processingBatch = null\n\n\t\tfor (const k of this.lastOperationForEntity.keys()) {\n\t\t\tthis.lastOperationForEntity.delete(k)\n\t\t}\n\t}\n\n\tpause() {\n\t\tthis.paused = true\n\t}\n\n\tresume() {\n\t\tthis.paused = false\n\t\tthis.start()\n\t}\n\n\t/** @private visibleForTesting */\n\tget __processingBatch(): QueuedBatch | null {\n\t\treturn this.processingBatch\n\t}\n}\n"]}