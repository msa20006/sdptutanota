{"version":3,"file":"MailExportTokenFacade.js","sourceRoot":"","sources":["../../../../../../../src/common/api/worker/facades/lazy/MailExportTokenFacade.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,oCAAoC,CAAA;AACvE,OAAO,EAAE,sBAAsB,EAAE,MAAM,wCAAwC,CAAA;AAI/E,MAAM,GAAG,GAAG,yBAAyB,CAAA;AAQrC;;;;GAIG;AACH,MAAM,OAAO,qBAAqB;IAMJ;IAL7B,oDAAoD;IAC5C,yBAAyB,GAAoC,IAAI,CAAA;IACzE,uCAAuC;IAC/B,kBAAkB,GAA2B,IAAI,CAAA;IAEzD,YAA6B,eAAiC;QAAjC,oBAAe,GAAf,eAAe,CAAkB;IAAG,CAAC;IAElE;;;;OAIG;IACH,KAAK,CAAC,aAAa,CAAI,OAAsC;QAC5D,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,IAAI,CAAC,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC,CAAA;QACvE,IAAI,CAAC;YACJ,OAAO,MAAM,OAAO,CAAC,KAAK,CAAC,CAAA;QAC5B,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,0BAA0B;YAC1B,IAAI,CAAC,YAAY,kBAAkB,EAAE,CAAC;gBACrC,IAAI,QAAQ,CAAA;gBACZ,IAAI,IAAI,CAAC,kBAAkB,KAAK,KAAK,EAAE,CAAC;oBACvC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,iDAAiD,CAAC,CAAA;oBACnE,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,EAAE,CAAA;gBACxC,CAAC;qBAAM,CAAC;oBACP,wDAAwD;oBACxD,QAAQ,GAAG,IAAI,CAAC,kBAAkB,IAAI,CAAC,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC,CAAA;gBACrE,CAAC;gBAED,OAAO,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAA;YAC/B,CAAC;iBAAM,CAAC;gBACP,MAAM,CAAC,CAAA;YACR,CAAC;QACF,CAAC;IACF,CAAC;IAED;;;;;;;OAOG;IACK,eAAe;QACtB,IAAI,IAAI,CAAC,yBAAyB,EAAE,CAAC;YACpC,OAAO,IAAI,CAAC,yBAAyB,CAAA;QACtC,CAAC;QAED,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAA;QAC9B,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,sBAAsB,EAAE,IAAI,EAAE,EAAE,kBAAkB,kCAA0B,EAAE,CAAC,CAAC,IAAI,CAC9I,CAAC,MAAM,EAAE,EAAE;YACV,IAAI,CAAC,kBAAkB,GAAG,MAAM,CAAC,eAAkC,CAAA;YACnE,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAA;YACrC,OAAO,IAAI,CAAC,kBAAkB,CAAA;QAC/B,CAAC,EACD,CAAC,KAAK,EAAE,EAAE;YACT,8EAA8E;YAC9E,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAA;YACrC,MAAM,KAAK,CAAA;QACZ,CAAC,CACD,CAAA;QACD,OAAO,IAAI,CAAC,yBAAyB,CAAA;IACtC,CAAC;IAED,qBAAqB;IACrB,sBAAsB,CAAC,KAAa;QACnC,IAAI,CAAC,kBAAkB,GAAG,KAAwB,CAAA;QAClD,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAA;IACtC,CAAC;IAED,qBAAqB;IACrB,sBAAsB;QACrB,OAAO,IAAI,CAAC,kBAAkB,CAAA;IAC/B,CAAC;CACD","sourcesContent":["import { AccessExpiredError } from \"../../../common/error/RestError.js\"\nimport { MailExportTokenService } from \"../../../entities/tutanota/Services.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { SuspensionBehavior } from \"../../rest/RestClient\"\n\nconst TAG = \"[MailExportTokenFacade]\"\n\n/**\n * Denotes an export token. This is internally just a string, but we want the TypeScript compiler to enforce strong\n * typing.\n */\ntype MailExportToken = string & { _exportToken: undefined }\n\n/**\n * Takes care of requested and invalidating export tokens as needed.\n *\n * Export token should be passed with network requests to avoid server penalties.\n */\nexport class MailExportTokenFacade {\n\t// This will only be set if a request is in progress\n\tprivate currentExportTokenRequest: Promise<MailExportToken> | null = null\n\t// Set when we have a known valid token\n\tprivate currentExportToken: MailExportToken | null = null\n\n\tconstructor(private readonly serviceExecutor: IServiceExecutor) {}\n\n\t/**\n\t * Runs {@param request}.\n\t *\n\t * If {@link AccessExpiredError} is thrown, deletes the cached token and re-runs it again.\n\t */\n\tasync loadWithToken<T>(request: (token: string) => Promise<T>): Promise<T> {\n\t\tconst token = this.currentExportToken ?? (await this.requestNewToken())\n\t\ttry {\n\t\t\treturn await request(token)\n\t\t} catch (e) {\n\t\t\t// We only allow one retry\n\t\t\tif (e instanceof AccessExpiredError) {\n\t\t\t\tlet newToken\n\t\t\t\tif (this.currentExportToken === token) {\n\t\t\t\t\tconsole.log(TAG, `token expired for exporting and will be renewed`)\n\t\t\t\t\tnewToken = await this.requestNewToken()\n\t\t\t\t} else {\n\t\t\t\t\t// Already a request going on... wait for that to finish\n\t\t\t\t\tnewToken = this.currentExportToken ?? (await this.requestNewToken())\n\t\t\t\t}\n\n\t\t\t\treturn await request(newToken)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Request a new token and write it to {@link currentExportToken}.\n\t *\n\t * This token will be valid for the mail group and current user for a short amount of time, after which you will get\n\t * an {@link AccessExpiredError} when using the token (or {@link NotAuthorizedError} if the user lost access to the group in the\n\t * meantime).\n\t * @throws TooManyRequestsError the user cannot request any more tokens right now\n\t */\n\tprivate requestNewToken(): Promise<MailExportToken> {\n\t\tif (this.currentExportTokenRequest) {\n\t\t\treturn this.currentExportTokenRequest\n\t\t}\n\n\t\tthis.currentExportToken = null\n\t\tthis.currentExportTokenRequest = this.serviceExecutor.post(MailExportTokenService, null, { suspensionBehavior: SuspensionBehavior.Throw }).then(\n\t\t\t(result) => {\n\t\t\t\tthis.currentExportToken = result.mailExportToken as MailExportToken\n\t\t\t\tthis.currentExportTokenRequest = null\n\t\t\t\treturn this.currentExportToken\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\t// Re-initialize in case MailExportTokenService won't fail on a future request\n\t\t\t\tthis.currentExportTokenRequest = null\n\t\t\t\tthrow error\n\t\t\t},\n\t\t)\n\t\treturn this.currentExportTokenRequest\n\t}\n\n\t// @VisibleForTesting\n\t_setCurrentExportToken(token: string) {\n\t\tthis.currentExportToken = token as MailExportToken\n\t\tthis.currentExportTokenRequest = null\n\t}\n\n\t// @VisibleForTesting\n\t_getCurrentExportToken(): string | null {\n\t\treturn this.currentExportToken\n\t}\n}\n"]}