{"version":3,"file":"SecondFactorUtils.js","sourceRoot":"","sources":["../../../../../src/common/misc/2fa/SecondFactorUtils.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,MAAM,uCAAuC,CAAA;AAE7D;;GAEG;AACH,MAAM,UAAU,eAAe,CAAC,KAAa,EAAE,oBAA0C;IACxF,4HAA4H;IAC5H,IAAI,KAAK,KAAK,KAAK,CAAC,cAAc,EAAE,CAAC;QACpC,OAAO,qBAAqB,CAAC,oBAAoB,CAAC,sBAAsB,EAAE,CAAC,WAAW,CAAC,CAAA;IACxF,CAAC;SAAM,IAAI,KAAK,KAAK,KAAK,CAAC,qBAAqB,EAAE,CAAC;QAClD,OAAO,qBAAqB,CAAC,oBAAoB,CAAC,sBAAsB,EAAE,CAAC,iBAAiB,CAAC,CAAA;IAC9F,CAAC;IAED,yCAAyC;IACzC,4JAA4J;IAC5J,2JAA2J;IAC3J,qDAAqD;IACrD,MAAM,KAAK,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;IACpF,MAAM,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAA;IACvB,4CAA4C;IAC5C,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAA;IACrB,wFAAwF;IACxF,MAAM,YAAY,GAAG,oBAAoB,CAAC,0BAA0B,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAA;IAC5F,OAAO,qBAAqB,CAAC,YAAY,CAAC,WAAW,CAAC,CAAA;AACvD,CAAC;AAED,SAAS,qBAAqB,CAAC,WAAmB;IACjD,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,WAAW,CAAC,CAAA;IAChC,GAAG,CAAC,QAAQ,GAAG,EAAE,CAAA;IACjB,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAA;AACtB,CAAC","sourcesContent":["import { DomainConfigProvider } from \"../../api/common/DomainConfigProvider.js\"\nimport { Const } from \"../../api/common/TutanotaConstants.js\"\n\n/**\n * Given appId (from the U2fKey), figure out which url should the user use for the login with that appId.\n */\nexport function appIdToLoginUrl(appId: string, domainConfigProvider: DomainConfigProvider): string {\n\t// Webauthn keys for our domains are special case because local, test and prod keys are registered for the same superdomain.\n\tif (appId === Const.WEBAUTHN_RP_ID) {\n\t\treturn webauthnUrlToLoginUrl(domainConfigProvider.getCurrentDomainConfig().webauthnUrl)\n\t} else if (appId === Const.LEGACY_WEBAUTHN_RP_ID) {\n\t\treturn webauthnUrlToLoginUrl(domainConfigProvider.getCurrentDomainConfig().legacyWebauthnUrl)\n\t}\n\n\t// If we get here, there are two options:\n\t//  * legacy (pre-Webauthn) U2F keys use the URL of a json file as appId. in that case, we use the hostname of that URL to figure out where to authenticate.\n\t//  * newer ones use some domain (no protocol, no port) for a whitelabel domain. we use the whitelabel domain if the key is registered through a whitelabel\n\t//       login. it might have a port on local builds.\n\tconst parts = (appId.endsWith(\".json\") ? new URL(appId).hostname : appId).split(\":\")\n\tconst domain = parts[0]\n\t// This might be undefined, but that's okay.\n\tconst port = parts[1]\n\t// If we use webauthn, we can assume https because no browser allows webauthn over http.\n\tconst domainConfig = domainConfigProvider.getDomainConfigForHostname(domain, \"https:\", port)\n\treturn webauthnUrlToLoginUrl(domainConfig.webauthnUrl)\n}\n\nfunction webauthnUrlToLoginUrl(webauthnUrl: string): string {\n\tconst url = new URL(webauthnUrl)\n\turl.pathname = \"\"\n\treturn url.toString()\n}\n"]}