{"version":3,"file":"ErrorHandler.js","sourceRoot":"","sources":["../../../../src/common/misc/ErrorHandler.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,OAAO,EAAE,oBAAoB,EAAE,MAAM,EAAE,MAAM,mBAAmB,CAAA;AAChE,OAAO,EAAE,KAAK,EAAE,MAAM,uBAAuB,CAAA;AAE7C,oBAAoB,EAAE,CAAA;AAEtB,8GAA8G;AAC9G,SAAS,wBAAwB,CAAI,EAAU,EAAE,EAAoB;IACpE,IAAI,OAAO,GAAG,CAAC,CAAA;IACf,OAAO,KAAK,IAAI,EAAE;QACjB,MAAM,WAAW,GAAG,OAAO,CAAA;QAC3B,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACpB,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAA;QAEjD,kCAAkC;QAClC,8BAA8B;QAC9B,4BAA4B;QAC5B,SAAS;QACT,iBAAiB;QACjB,gBAAgB;QAChB,sBAAsB;QACtB,oIAAoI;QAEpI,IAAI,WAAW,KAAK,CAAC,IAAI,gBAAgB,GAAG,EAAE,EAAE,CAAC;YAChD,MAAM,eAAe,GAAG,WAAW,GAAG,EAAE,CAAA;YACxC,MAAM,gBAAgB,GAAG,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;YACrD,MAAM,KAAK,CAAC,gBAAgB,CAAC,CAAA;QAC9B,CAAC;QAED,OAAO,EAAE,EAAE,CAAA;IACZ,CAAC,CAAA;AACF,CAAC;AAED;;;KAGK;AACL,MAAM,kBAAkB,GAAG,wBAAwB,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC,CAAA;AAE/F,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,CAAQ;IACjD,IAAI,MAAM,EAAE,EAAE,CAAC;QACd,MAAM,CAAC,CAAA;IACR,CAAC;IAED,IAAI,CAAC;QACJ,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAA;QAChC,MAAM,EAAE,uBAAuB,EAAE,GAAG,MAAM,kBAAkB,EAAE,CAAA;QAC9D,MAAM,uBAAuB,CAAC,CAAC,CAAC,CAAA;IACjC,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,OAAO,CAAC,KAAK,CAAC,sEAAsE,EAAE,CAAC,CAAC,CAAA;IACzF,CAAC;AACF,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,gCAAgC;IACrD,IAAI,CAAC;QACJ,MAAM,EAAE,gCAAgC,EAAE,GAAG,MAAM,kBAAkB,EAAE,CAAA;QACvE,gCAAgC,EAAE,CAAA;IACnC,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,OAAO,CAAC,KAAK,CAAC,mCAAmC,EAAE,CAAC,CAAC,CAAA;IACtD,CAAC;AACF,CAAC","sourcesContent":["/**\n * @file Handler for all the uncaught errors.\n * ErrorHandler is decoupled from ErrorHandlerImpl to reduce boot bundle size.\n */\nimport { assertMainOrNodeBoot, isTest } from \"../api/common/Env\"\nimport { delay } from \"@tutao/tutanota-utils\"\n\nassertMainOrNodeBoot()\n\n/** Produced async function which will not try to run more often than @param ms. Does not cache the result. */\nfunction produceThrottledFunction<R>(ms: number, fn: () => Promise<R>): () => Promise<R> {\n\tlet lastTry = 0\n\treturn async () => {\n\t\tconst previousTry = lastTry\n\t\tlastTry = Date.now()\n\t\tconst sincePreviousTry = Date.now() - previousTry\n\n\t\t// |---|----|--------------|-----|\n\t\t//   1001  1003           1011\n\t\t//    a     b              c\n\t\t// ms: 10\n\t\t// a: previousTry\n\t\t// b: Date.now()\n\t\t// c: previousTry + ms\n\t\t// If the last call was at 1001 and we are now calling fn again at 1003 then we want to wait until 1011 which would be (a + ms) - b.\n\n\t\tif (previousTry !== 0 && sincePreviousTry < ms) {\n\t\t\tconst waitShouldEndAt = previousTry + ms\n\t\t\tconst timeUntilWaitEnd = waitShouldEndAt - Date.now()\n\t\t\tawait delay(timeUntilWaitEnd)\n\t\t}\n\n\t\treturn fn()\n\t}\n}\n\n/**\n * Throttled error handler. We have issues with error loops when reloading the page in Firefox and this gives browser a break of event\n * loop to be able to reload the page properly.\n * */\nconst importErrorHandler = produceThrottledFunction(200, () => import(\"./ErrorHandlerImpl.js\"))\n\nexport async function handleUncaughtError(e: Error) {\n\tif (isTest()) {\n\t\tthrow e\n\t}\n\n\ttry {\n\t\tconsole.log(\"error\", e, e.stack)\n\t\tconst { handleUncaughtErrorImpl } = await importErrorHandler()\n\t\tawait handleUncaughtErrorImpl(e)\n\t} catch (e) {\n\t\tconsole.error(\"Encountered error when trying to handle errors with ErrorHandlerImpl\", e)\n\t}\n}\n\nexport async function disableErrorHandlingDuringLogout() {\n\ttry {\n\t\tconst { disableErrorHandlingDuringLogout } = await importErrorHandler()\n\t\tdisableErrorHandlingDuringLogout()\n\t} catch (e) {\n\t\tconsole.error(\"Could not import ErrorHandlerImpl\", e)\n\t}\n}\n"]}