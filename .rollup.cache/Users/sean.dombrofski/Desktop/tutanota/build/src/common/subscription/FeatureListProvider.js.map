{"version":3,"file":"FeatureListProvider.js","sourceRoot":"","sources":["../../../../src/common/subscription/FeatureListProvider.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,cAAc,EAAY,QAAQ,EAAE,cAAc,EAAE,MAAM,oCAAoC,CAAA;AACvG,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAA;AAC5D,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAA;AAE/C,IAAI,YAAY,GAA+B,IAAI,CAAA;AAEnD,MAAM,qBAAqB,GAAqB,CAAC,sBAAsB,CAAC,CAAA;AAExE,MAAM,OAAO,mBAAmB;IAGM;IAF7B,WAAW,GAAwB,IAAI,CAAA;IAE/C,YAAqC,YAA0B;QAA1B,iBAAY,GAAZ,YAAY,CAAc;IAAG,CAAC;IAE3D,KAAK,CAAC,IAAI;QACjB,IAAI,WAAW,KAAK,OAAO,KAAK;YAAE,OAAM;QACxC,MAAM,eAAe,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc,+BAA+B,CAAA;QAC1F,IAAI,CAAC;YACJ,MAAM,WAAW,GAAG,MAAM,KAAK,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAA;YACtE,IAAI,QAAQ,EAAE,EAAE,CAAC;gBAChB,IAAI,CAAC,2BAA2B,CAAC,WAAW,CAAC,CAAA;YAC9C,CAAC;YACD,IAAI,CAAC,aAAa,CAAC,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,WAAW,CAAC,aAAa,CAAC,UAAU,EAAE,GAAG,WAAW,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAA;YAC/H,IAAI,CAAC,aAAa,CAAC,CAAC,GAAG,WAAW,CAAC,SAAS,CAAC,UAAU,EAAE,GAAG,WAAW,CAAC,QAAQ,CAAC,UAAU,EAAE,GAAG,WAAW,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAA;YAClI,IAAI,CAAC,WAAW,GAAG,WAAW,CAAA;QAC/B,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,OAAO,CAAC,IAAI,CAAC,sCAAsC,eAAe,EAAE,EAAE,CAAC,CAAC,CAAA;QACzE,CAAC;IACF,CAAC;IAEO,aAAa,CAAC,UAA6B;QAClD,MAAM,aAAa,GAAG,IAAI,GAAG,EAA2B,CAAA;QACxD,KAAK,MAAM,QAAQ,IAAI,UAAU,EAAE,CAAC;YACnC,MAAM,KAAK,GAAG,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;YAC/C,MAAM,gBAAgB,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAA;YACjD,IAAI,KAAK,IAAI,IAAI,IAAI,gBAAgB,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;gBACnD,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,gBAAgB,EAAE,CAAC,CAAA;YAC7D,CAAC;QACF,CAAC;QACD,KAAK,MAAM,QAAQ,IAAI,UAAU,EAAE,CAAC;YACnC,QAAQ,CAAC,YAAY,GAAG,UAAU,CAAC,aAAa,EAAE,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE;gBACtE,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,CAAA;YAClB,CAAC,CAAC,CAAA;QACH,CAAC;IACF,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,sBAAsB,CAAC,YAA0B;QAC7D,IAAI,YAAY,IAAI,IAAI,EAAE,CAAC;YAC1B,YAAY,GAAG,IAAI,mBAAmB,CAAC,YAAY,CAAC,CAAA;YACpD,MAAM,YAAY,CAAC,IAAI,EAAE,CAAA;QAC1B,CAAC;QACD,OAAO,YAAY,CAAA;IACpB,CAAC;IAED,cAAc,CAAC,kBAA4B;QAC1C,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,EAAE,CAAC;YAC9B,OAAO,EAAE,QAAQ,EAAE,iBAAiB,EAAE,UAAU,EAAE,EAAE,EAAE,CAAA;QACvD,CAAC;aAAM,CAAC;YACP,OAAO,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,kBAAkB,CAAC,CAAC,CAAA;QAC5D,CAAC;IACF,CAAC;IAED,kBAAkB;QACjB,OAAO,IAAI,CAAC,WAAW,IAAI,IAAI,CAAA;IAChC,CAAC;IAED;;;;OAIG;IACK,2BAA2B,CAAC,WAAgB;QACnD,KAAK,MAAM,IAAI,IAAI,cAAc,EAAE,CAAC;YACnC,MAAM,QAAQ,GAAsC,WAAW,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAA;YACrF,KAAK,MAAM,QAAQ,IAAI,QAAQ,CAAC,UAAU,EAAE,CAAC;gBAC5C,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE;oBACzD,OAAO,CAAC,qBAAqB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;gBAC7C,CAAC,CAAC,CAAA;YACH,CAAC;QACF,CAAC;IACF,CAAC;CACD;AAyDD;;GAEG;AACH,MAAM,UAAU,wBAAwB,CAAC,QAAkB;IAC1D,QAAQ,QAAQ,EAAE,CAAC;QAClB,KAAK,QAAQ,CAAC,eAAe;YAC5B,OAAO,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAA;QAClD,KAAK,QAAQ,CAAC,aAAa;YAC1B,OAAO,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAA;QAChD;YACC,OAAO,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAA;IAC3C,CAAC;AACF,CAAC","sourcesContent":["import Stream from \"mithril/stream\"\nimport { PlanPrices } from \"../api/entities/sys/TypeRefs\"\nimport { TranslationKey } from \"../misc/LanguageViewModel\"\nimport { PaymentInterval } from \"./PriceUtils.js\"\nimport { AvailablePlans, PlanName, PlanType, PlanTypeToName } from \"../api/common/TutanotaConstants.js\"\nimport { downcast, getFromMap } from \"@tutao/tutanota-utils\"\nimport { isIOSApp } from \"../api/common/Env.js\"\n\nlet dataProvider: FeatureListProvider | null = null\n\nconst IOS_EXCLUDED_FEATURES: TranslationKey[] = [\"pricing.family_label\"]\n\nexport class FeatureListProvider {\n\tprivate featureList: FeatureLists | null = null\n\n\tprivate constructor(private readonly domainConfig: DomainConfig) {}\n\n\tprivate async init(): Promise<void> {\n\t\tif (\"undefined\" === typeof fetch) return\n\t\tconst listResourceUrl = `${this.domainConfig.websiteBaseUrl}/resources/data/features.json`\n\t\ttry {\n\t\t\tconst featureList = await fetch(listResourceUrl).then((r) => r.json())\n\t\t\tif (isIOSApp()) {\n\t\t\t\tthis.stripUnsupportedIosFeatures(featureList)\n\t\t\t}\n\t\t\tthis.countFeatures([...featureList.Free.categories, ...featureList.Revolutionary.categories, ...featureList.Legend.categories])\n\t\t\tthis.countFeatures([...featureList.Essential.categories, ...featureList.Advanced.categories, ...featureList.Unlimited.categories])\n\t\t\tthis.featureList = featureList\n\t\t} catch (e) {\n\t\t\tconsole.warn(`failed to fetch feature list from  ${listResourceUrl}`, e)\n\t\t}\n\t}\n\n\tprivate countFeatures(categories: FeatureCategory[]): void {\n\t\tconst featureCounts = new Map<string, { max: number }>()\n\t\tfor (const category of categories) {\n\t\t\tconst count = featureCounts.get(category.title)\n\t\t\tconst numberOfFeatures = category.features.length\n\t\t\tif (count == null || numberOfFeatures > count.max) {\n\t\t\t\tfeatureCounts.set(category.title, { max: numberOfFeatures })\n\t\t\t}\n\t\t}\n\t\tfor (const category of categories) {\n\t\t\tcategory.featureCount = getFromMap(featureCounts, category.title, () => {\n\t\t\t\treturn { max: 0 }\n\t\t\t})\n\t\t}\n\t}\n\n\tstatic async getInitializedInstance(domainConfig: DomainConfig): Promise<FeatureListProvider> {\n\t\tif (dataProvider == null) {\n\t\t\tdataProvider = new FeatureListProvider(domainConfig)\n\t\t\tawait dataProvider.init()\n\t\t}\n\t\treturn dataProvider\n\t}\n\n\tgetFeatureList(targetSubscription: PlanType): FeatureLists[PlanName] {\n\t\tif (this.featureList == null) {\n\t\t\treturn { subtitle: \"emptyString_msg\", categories: [] }\n\t\t} else {\n\t\t\treturn this.featureList[PlanTypeToName[targetSubscription]]\n\t\t}\n\t}\n\n\tfeatureLoadingDone(): boolean {\n\t\treturn this.featureList != null\n\t}\n\n\t/**\n\t * Remove features from the feature list that are unsupported for iOS and shouldn't be displayed to iOS users.\n\t * @param featureList feature list obtained from the server\n\t * @private\n\t */\n\tprivate stripUnsupportedIosFeatures(featureList: any) {\n\t\tfor (const plan of AvailablePlans) {\n\t\t\tconst features: { categories: FeatureCategory[] } = featureList[PlanTypeToName[plan]]\n\t\t\tfor (const category of features.categories) {\n\t\t\t\tcategory.features = category.features.filter(({ text }) => {\n\t\t\t\t\treturn !IOS_EXCLUDED_FEATURES.includes(text)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * tutanota-3 has a typeRef for plan prices, while the web site defines the type with only\n * some of the properties of the model type. using this method to maintain symmetry.\n */\nexport type WebsitePlanPrices = Pick<PlanPrices, \"additionalUserPriceMonthly\" | \"firstYearDiscount\" | \"monthlyPrice\" | \"monthlyReferencePrice\">\n\nexport type SelectedSubscriptionOptions = {\n\tbusinessUse: Stream<boolean>\n\tpaymentInterval: Stream<PaymentInterval>\n}\n\n/**\n * since some translations contain slots that will be populated with\n * dynamic content (depending on options & locale),\n * we have to provide functions to produce it. these\n * are used to select the correct one.\n **/\nexport type ReplacementKey = \"customDomains\" | \"mailAddressAliases\" | \"storage\" | \"label\"\n\n/**\n * A category of features to be shown\n * title: translation key for the title\n * features: List of features in this category\n * omit: whether this can be omitted from the compact feature list,\n */\nexport type FeatureCategory = {\n\ttitle: TranslationKey\n\tfeatures: Array<FeatureListItem>\n\tfeatureCount: { max: number }\n}\n\n/**\n * one item in the list that's shown below a subscription box,\n * text: translation key for the label,\n * toolTip: translation key for the tooltip that will be shown on hover,\n * omit: whether this can be omitted from the compact feature list,\n * antiFeature: some list items are denoting the lack of a feature and are\n *   rendered with an different icon.\n * replacements: a key to select the correct content to replace the slots in the translation\n */\nexport type FeatureListItem = {\n\ttext: TranslationKey\n\ttoolTip?: TranslationKey\n\tomit: boolean\n\tantiFeature?: boolean\n\treplacements?: ReplacementKey\n\theart?: boolean\n}\n\n/**\n * subtitle: the short text shown below the subscription name in the buy box\n * features: flat, ordered list of features for this subscription type\n */\ntype FeatureLists = { [K in PlanName]: { subtitle: string; categories: Array<FeatureCategory> } }\n\n/**\n * @returns the name to show to the user for the current subscription (PremiumBusiness -> Premium etc.)\n */\nexport function getDisplayNameOfPlanType(planType: PlanType): string {\n\tswitch (planType) {\n\t\tcase PlanType.PremiumBusiness:\n\t\t\treturn downcast(PlanTypeToName[PlanType.Premium])\n\t\tcase PlanType.TeamsBusiness:\n\t\t\treturn downcast(PlanTypeToName[PlanType.Teams])\n\t\tdefault:\n\t\t\treturn downcast(PlanTypeToName[planType])\n\t}\n}\n\nexport type SubscriptionPlanPrices = Record<PlanType, PlanPrices>\n\nexport const enum UpgradePriceType {\n\tPlanReferencePrice = \"0\",\n\tPlanActualPrice = \"1\",\n\tPlanNextYearsPrice = \"2\",\n\tAdditionalUserPrice = \"3\",\n\tContactFormPrice_UNUSED = \"4\",\n}\n"]}