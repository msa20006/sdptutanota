{"version":3,"file":"DesktopKeyStoreFacade.js","sourceRoot":"","sources":["../../../../src/common/desktop/DesktopKeyStoreFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SecretStorage } from \"./sse/SecretStorage\"\nimport { DesktopNativeCryptoFacade } from \"./DesktopNativeCryptoFacade\"\nimport { log } from \"./DesktopLog\"\nimport { getFromMap } from \"@tutao/tutanota-utils\"\nimport { Aes256Key, base64ToKey, keyToBase64 } from \"@tutao/tutanota-crypto\"\nimport { DeviceStorageUnavailableError } from \"../api/common/error/DeviceStorageUnavailableError.js\"\nimport { CancelledError } from \"../api/common/error/CancelledError\"\n\ninterface NativeKeySpec {\n\t/**\n\t * This is supposed to be internet service but this is what is usually presented to the user (at least mac os does this).\n\t * One would thing that this would group all the things but in reality permissions are set per-account anyway.\n\t */\n\treadonly serviceName: string\n\t/** This is supposed to be account name but this is usually not shown. */\n\treadonly accountName: string\n\t/** Whether we want to cache the key in memory */\n\treadonly cached: boolean\n}\n\nexport const DeviceKeySpec: NativeKeySpec = Object.freeze({\n\tserviceName: \"tutanota-vault\",\n\taccountName: \"tuta\",\n\tcached: true,\n})\n\nexport const CredentialsKeySpec: NativeKeySpec = Object.freeze({\n\tserviceName: \"tutanota-credentials\",\n\taccountName: \"tutanota-credentials\",\n\t// Credentials key should not be cached, we should ask it every time we operate on credentials (there's already intermediate in web to avoid asking\n\t// too many times)\n\tcached: false,\n})\n\n/** Interface for accessing/generating/caching keys. */\nexport class DesktopKeyStoreFacade {\n\tprivate readonly resolvedKeys: Map<NativeKeySpec, Promise<Aes256Key>> = new Map()\n\n\tconstructor(private readonly secretStorage: SecretStorage, private readonly crypto: DesktopNativeCryptoFacade) {}\n\n\t/**\n\t * get the key used to encrypt alarms and settings\n\t */\n\tasync getDeviceKey(): Promise<Aes256Key> {\n\t\t// Device key can be cached\n\t\treturn this.resolveKey(DeviceKeySpec)\n\t}\n\n\t/**\n\t * get the key used to encrypt saved credentials\n\t */\n\tasync getKeyChainKey(): Promise<Aes256Key> {\n\t\treturn this.resolveKey(CredentialsKeySpec)\n\t}\n\n\tprivate resolveKey(spec: NativeKeySpec): Promise<Aes256Key> {\n\t\t// Asking for the same key in parallel easily breaks gnome-keyring so we cache the promise.\n\t\tconst entry = getFromMap(this.resolvedKeys, spec, () => this.fetchOrGenerateKey(spec))\n\n\t\tif (spec.cached) {\n\t\t\t// We only want to cache *successful* promises, otherwise we have no chance to retry.\n\t\t\treturn entry.catch((e) => {\n\t\t\t\tthis.resolvedKeys.delete(spec)\n\t\t\t\tthrow e\n\t\t\t})\n\t\t} else {\n\t\t\t// If we don't want to cache the key we remove it in any case.\n\t\t\treturn entry.finally(() => {\n\t\t\t\tthis.resolvedKeys.delete(spec)\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate async fetchOrGenerateKey(spec: NativeKeySpec): Promise<Aes256Key> {\n\t\tlog.debug(\"resolving key...\", spec.serviceName)\n\t\ttry {\n\t\t\treturn (await this.fetchKey(spec)) ?? (await this.generateAndStoreKey(spec))\n\t\t} catch (e) {\n\t\t\tlog.warn(\"Failed to resolve/generate key: \", spec.serviceName, e)\n\t\t\tif (e instanceof CancelledError) {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t\tthrow new DeviceStorageUnavailableError(\"failed to resolve/generate key\", e)\n\t\t}\n\t}\n\n\tprivate async fetchKey(spec: NativeKeySpec): Promise<Aes256Key | null> {\n\t\tconst base64 = await this.secretStorage.getPassword(spec.serviceName, spec.accountName)\n\n\t\tif (base64 == null) {\n\t\t\treturn null\n\t\t}\n\t\treturn base64ToKey(base64)\n\t}\n\n\tprivate async generateAndStoreKey(spec: NativeKeySpec): Promise<Aes256Key> {\n\t\tlog.warn(`key ${spec.serviceName} not found, generating a new one`)\n\n\t\tconst key: Aes256Key = this.crypto.generateDeviceKey()\n\n\t\tconst base64 = keyToBase64(key)\n\n\t\tawait this.secretStorage.setPassword(spec.serviceName, spec.accountName, base64)\n\t\treturn key\n\t}\n}\n"]}