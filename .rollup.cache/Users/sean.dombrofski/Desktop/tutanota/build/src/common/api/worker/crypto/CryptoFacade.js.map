{"version":3,"file":"CryptoFacade.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/crypto/CryptoFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tassertNotNull,\n\tbase64ToUint8Array,\n\tdowncast,\n\tisSameTypeRef,\n\tisSameTypeRefByAttr,\n\tlazy,\n\tneverNull,\n\tofClass,\n\tpromiseMap,\n\tstringToUtf8Uint8Array,\n\tTypeRef,\n\tuint8ArrayToBase64,\n\tVersioned,\n} from \"@tutao/tutanota-utils\"\nimport {\n\tAccountType,\n\tasCryptoProtoocolVersion,\n\tassertEnumValue,\n\tBucketPermissionType,\n\tCryptoProtocolVersion,\n\tEncryptionAuthStatus,\n\tGroupType,\n\tPermissionType,\n\tPublicKeyIdentifierType,\n\tSYSTEM_GROUP_MAIL_ADDRESS,\n} from \"../../common/TutanotaConstants\"\nimport { HttpMethod, resolveTypeReference } from \"../../common/EntityFunctions\"\nimport type { BucketKey, BucketPermission, GroupMembership, InstanceSessionKey, Permission } from \"../../entities/sys/TypeRefs.js\"\nimport {\n\tBucketKeyTypeRef,\n\tBucketPermissionTypeRef,\n\tcreateInstanceSessionKey,\n\tcreateUpdatePermissionKeyData,\n\tGroupInfoTypeRef,\n\tGroupTypeRef,\n\tPermissionTypeRef,\n\tPushIdentifierTypeRef,\n} from \"../../entities/sys/TypeRefs.js\"\nimport {\n\tContact,\n\tContactTypeRef,\n\tcreateEncryptTutanotaPropertiesData,\n\tcreateInternalRecipientKeyData,\n\tcreateSymEncInternalRecipientKeyData,\n\tFile,\n\tFileTypeRef,\n\tInternalRecipientKeyData,\n\tMail,\n\tMailTypeRef,\n\tSymEncInternalRecipientKeyData,\n\tTutanotaPropertiesTypeRef,\n} from \"../../entities/tutanota/TypeRefs.js\"\nimport { typeRefToPath } from \"../rest/EntityRestClient\"\nimport { LockedError, NotFoundError, PayloadTooLargeError, TooManyRequestsError } from \"../../common/error/RestError\"\nimport { SessionKeyNotFoundError } from \"../../common/error/SessionKeyNotFoundError\"\nimport { birthdayToIsoDate, oldBirthdayToBirthday } from \"../../common/utils/BirthdayUtils\"\nimport type { Entity, Instance, SomeEntity, TypeModel } from \"../../common/EntityTypes\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport type { EntityClient } from \"../../common/EntityClient\"\nimport { RestClient } from \"../rest/RestClient\"\nimport {\n\tAes256Key,\n\taes256RandomKey,\n\taesEncrypt,\n\tAesKey,\n\tbitArrayToUint8Array,\n\tdecryptKey,\n\tEccPublicKey,\n\tencryptKey,\n\tisPqKeyPairs,\n\tsha256Hash,\n} from \"@tutao/tutanota-crypto\"\nimport { RecipientNotResolvedError } from \"../../common/error/RecipientNotResolvedError\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { EncryptTutanotaPropertiesService } from \"../../entities/tutanota/Services\"\nimport { UpdatePermissionKeyService } from \"../../entities/sys/Services\"\nimport { UserFacade } from \"../facades/UserFacade\"\nimport { elementIdPart, getElementId, getListId } from \"../../common/utils/EntityUtils.js\"\nimport { InstanceMapper } from \"./InstanceMapper.js\"\nimport { OwnerEncSessionKeysUpdateQueue } from \"./OwnerEncSessionKeysUpdateQueue.js\"\nimport { DefaultEntityRestCache } from \"../rest/DefaultEntityRestCache.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { KeyLoaderFacade, parseKeyVersion } from \"../facades/KeyLoaderFacade.js\"\nimport { encryptKeyWithVersionedKey, VersionedEncryptedKey, VersionedKey } from \"./CryptoWrapper.js\"\nimport { AsymmetricCryptoFacade } from \"./AsymmetricCryptoFacade.js\"\nimport { PublicKeyProvider, PublicKeys } from \"../facades/PublicKeyProvider.js\"\nimport { KeyVersion } from \"@tutao/tutanota-utils/dist/Utils.js\"\nimport { KeyRotationFacade } from \"../facades/KeyRotationFacade.js\"\n\nassertWorkerOrNode()\n\n// Unmapped encrypted owner group instance\ntype UnmappedOwnerGroupInstance = {\n\t_ownerEncSessionKey: string\n\t_ownerKeyVersion: NumberString\n\t_ownerGroup: Id\n}\n\ntype ResolvedSessionKeys = {\n\tresolvedSessionKeyForInstance: AesKey\n\tinstanceSessionKeys: Array<InstanceSessionKey>\n}\n\nexport class CryptoFacade {\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly ownerEncSessionKeysUpdateQueue: OwnerEncSessionKeysUpdateQueue,\n\t\tprivate readonly cache: DefaultEntityRestCache | null,\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t\tprivate readonly asymmetricCryptoFacade: AsymmetricCryptoFacade,\n\t\tprivate readonly publicKeyProvider: PublicKeyProvider,\n\t\tprivate readonly keyRotationFacade: lazy<KeyRotationFacade>,\n\t) {}\n\n\tasync applyMigrationsForInstance<T>(decryptedInstance: T): Promise<T> {\n\t\tconst instanceType = downcast<Entity>(decryptedInstance)._type\n\n\t\tif (isSameTypeRef(instanceType, ContactTypeRef)) {\n\t\t\tconst contact = downcast<Contact>(decryptedInstance)\n\n\t\t\ttry {\n\t\t\t\tif (!contact.birthdayIso && contact.oldBirthdayAggregate) {\n\t\t\t\t\tcontact.birthdayIso = birthdayToIsoDate(contact.oldBirthdayAggregate)\n\t\t\t\t\tcontact.oldBirthdayAggregate = null\n\t\t\t\t\tcontact.oldBirthdayDate = null\n\t\t\t\t\tawait this.entityClient.update(contact)\n\t\t\t\t} else if (!contact.birthdayIso && contact.oldBirthdayDate) {\n\t\t\t\t\tcontact.birthdayIso = birthdayToIsoDate(oldBirthdayToBirthday(contact.oldBirthdayDate))\n\t\t\t\t\tcontact.oldBirthdayDate = null\n\t\t\t\t\tawait this.entityClient.update(contact)\n\t\t\t\t} else if (contact.birthdayIso && (contact.oldBirthdayAggregate || contact.oldBirthdayDate)) {\n\t\t\t\t\tcontact.oldBirthdayAggregate = null\n\t\t\t\t\tcontact.oldBirthdayDate = null\n\t\t\t\t\tawait this.entityClient.update(contact)\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (!(e instanceof LockedError)) {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn decryptedInstance\n\t}\n\n\tasync resolveSessionKeyForInstance(instance: SomeEntity): Promise<AesKey | null> {\n\t\tconst typeModel = await resolveTypeReference(instance._type)\n\t\treturn this.resolveSessionKey(typeModel, instance)\n\t}\n\n\t/** Helper for the rare cases when we needed it on the client side. */\n\tasync resolveSessionKeyForInstanceBinary(instance: SomeEntity): Promise<Uint8Array | null> {\n\t\tconst key = await this.resolveSessionKeyForInstance(instance)\n\t\treturn key == null ? null : bitArrayToUint8Array(key)\n\t}\n\n\t/** Resolve a session key an {@param instance} using an already known {@param ownerKey}. */\n\tresolveSessionKeyWithOwnerKey(instance: Record<string, any>, ownerKey: AesKey): AesKey {\n\t\tlet key: Uint8Array | string = instance._ownerEncSessionKey\n\t\tif (typeof key === \"string\") {\n\t\t\tkey = base64ToUint8Array(key)\n\t\t}\n\n\t\treturn decryptKey(ownerKey, key)\n\t}\n\n\tasync decryptSessionKey(instance: Record<string, any>, ownerEncSessionKey: VersionedEncryptedKey): Promise<AesKey> {\n\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(instance._ownerGroup, ownerEncSessionKey.encryptingKeyVersion)\n\t\treturn decryptKey(gk, ownerEncSessionKey.key)\n\t}\n\n\t/**\n\t * Returns the session key for the provided type/instance:\n\t * * null, if the instance is unencrypted\n\t * * the decrypted _ownerEncSessionKey, if it is available\n\t * * the public decrypted session key, otherwise\n\t *\n\t * @param typeModel the type model of the instance\n\t * @param instance The unencrypted (client-side) instance or encrypted (server-side) object literal\n\t */\n\tasync resolveSessionKey(typeModel: TypeModel, instance: Record<string, any>): Promise<AesKey | null> {\n\t\ttry {\n\t\t\tif (!typeModel.encrypted) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tif (instance.bucketKey) {\n\t\t\t\t// if we have a bucket key, then we need to cache the session keys stored in the bucket key for details, files, etc.\n\t\t\t\t// we need to do this BEFORE we check the owner enc session key\n\t\t\t\tconst bucketKey = await this.convertBucketKeyToInstanceIfNecessary(instance.bucketKey)\n\t\t\t\tconst resolvedSessionKeys = await this.resolveWithBucketKey(bucketKey, instance, typeModel)\n\t\t\t\treturn resolvedSessionKeys.resolvedSessionKeyForInstance\n\t\t\t} else if (instance._ownerEncSessionKey && this.userFacade.isFullyLoggedIn() && this.userFacade.hasGroup(instance._ownerGroup)) {\n\t\t\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(instance._ownerGroup, parseKeyVersion(instance._ownerKeyVersion ?? \"0\"))\n\t\t\t\treturn this.resolveSessionKeyWithOwnerKey(instance, gk)\n\t\t\t} else if (instance.ownerEncSessionKey) {\n\t\t\t\t// Likely a DataTransferType, so this is a service.\n\t\t\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(\n\t\t\t\t\tthis.userFacade.getGroupId(GroupType.Mail),\n\t\t\t\t\tparseKeyVersion(instance.ownerKeyVersion ?? \"0\"),\n\t\t\t\t)\n\t\t\t\treturn this.resolveSessionKeyWithOwnerKey(instance, gk)\n\t\t\t} else {\n\t\t\t\t// See PermissionType jsdoc for more info on permissions\n\t\t\t\tconst permissions = await this.entityClient.loadAll(PermissionTypeRef, instance._permissions)\n\t\t\t\treturn (await this.trySymmetricPermission(permissions)) ?? (await this.resolveWithPublicOrExternalPermission(permissions, instance, typeModel))\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof CryptoError) {\n\t\t\t\tconsole.log(\"failed to resolve session key\", e)\n\t\t\t\tthrow new SessionKeyNotFoundError(\"Crypto error while resolving session key for instance \" + instance._id)\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Takes a freshly JSON-parsed, unmapped object and apply migrations as necessary\n\t * @param typeRef\n\t * @param data\n\t * @return the unmapped and still encrypted instance\n\t */\n\tasync applyMigrations<T extends SomeEntity>(typeRef: TypeRef<T>, data: Record<string, any>): Promise<Record<string, any>> {\n\t\tif (isSameTypeRef(typeRef, GroupInfoTypeRef) && data._ownerGroup == null) {\n\t\t\treturn this.applyCustomerGroupOwnershipToGroupInfo(data)\n\t\t} else if (isSameTypeRef(typeRef, TutanotaPropertiesTypeRef) && data._ownerEncSessionKey == null) {\n\t\t\treturn this.encryptTutanotaProperties(data)\n\t\t} else if (isSameTypeRef(typeRef, PushIdentifierTypeRef) && data._ownerEncSessionKey == null) {\n\t\t\treturn this.addSessionKeyToPushIdentifier(data)\n\t\t} else {\n\t\t\treturn data\n\t\t}\n\t}\n\n\t/**\n\t * In case the given bucketKey is a literal the literal will be converted to an instance and return. In case the BucketKey is already an instance the\n\t * instance is returned.\n\t * @param bucketKeyInstanceOrLiteral The bucket key as literal or instance\n\t */\n\tasync convertBucketKeyToInstanceIfNecessary(bucketKeyInstanceOrLiteral: Record<string, any>): Promise<BucketKey> {\n\t\tif (this.isLiteralInstance(bucketKeyInstanceOrLiteral)) {\n\t\t\t// decryptAndMapToInstance is misleading here (it's not going to be decrypted), but we want to map the BucketKey aggregate and its session key from\n\t\t\t// a literal to an instance to have the encrypted keys in binary format and not as base 64. There is actually no decryption ongoing, just\n\t\t\t// mapToInstance.\n\t\t\tconst bucketKeyTypeModel = await resolveTypeReference(BucketKeyTypeRef)\n\t\t\treturn (await this.instanceMapper.decryptAndMapToInstance(bucketKeyTypeModel, bucketKeyInstanceOrLiteral, null)) as BucketKey\n\t\t} else {\n\t\t\t// bucket key was already decoded\n\t\t\treturn bucketKeyInstanceOrLiteral as BucketKey\n\t\t}\n\t}\n\n\tpublic async resolveWithBucketKey(bucketKey: BucketKey, instance: Record<string, any>, typeModel: TypeModel): Promise<ResolvedSessionKeys> {\n\t\tconst instanceElementId = this.getElementIdFromInstance(instance)\n\t\tlet decryptedBucketKey: AesKey\n\t\tlet unencryptedSenderAuthStatus: EncryptionAuthStatus | null = null\n\t\tlet pqMessageSenderKey: EccPublicKey | null = null\n\t\tif (bucketKey.keyGroup && bucketKey.pubEncBucketKey) {\n\t\t\t// bucket key is encrypted with public key for internal recipient\n\t\t\tconst { decryptedAesKey, senderIdentityPubKey } = await this.asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(\n\t\t\t\tbucketKey.keyGroup,\n\t\t\t\tparseKeyVersion(bucketKey.recipientKeyVersion),\n\t\t\t\tasCryptoProtoocolVersion(bucketKey.protocolVersion),\n\t\t\t\tbucketKey.pubEncBucketKey,\n\t\t\t)\n\t\t\tdecryptedBucketKey = decryptedAesKey\n\t\t\tpqMessageSenderKey = senderIdentityPubKey\n\t\t} else if (bucketKey.groupEncBucketKey) {\n\t\t\t// received as secure external recipient or reply from secure external sender\n\t\t\tlet keyGroup\n\t\t\tconst groupKeyVersion = parseKeyVersion(bucketKey.recipientKeyVersion)\n\t\t\tif (bucketKey.keyGroup) {\n\t\t\t\t// 1. Uses when receiving confidential replies from external users.\n\t\t\t\t// 2. legacy code path for old external clients that used to encrypt bucket keys with user group keys.\n\t\t\t\tkeyGroup = bucketKey.keyGroup\n\t\t\t} else {\n\t\t\t\t// by default, we try to decrypt the bucket key with the ownerGroupKey (e.g. secure external recipient)\n\t\t\t\tkeyGroup = neverNull(instance._ownerGroup)\n\t\t\t}\n\n\t\t\tdecryptedBucketKey = await this.resolveWithGroupReference(keyGroup, groupKeyVersion, bucketKey.groupEncBucketKey)\n\t\t\tunencryptedSenderAuthStatus = EncryptionAuthStatus.AES_NO_AUTHENTICATION\n\t\t} else {\n\t\t\tthrow new SessionKeyNotFoundError(`encrypted bucket key not set on instance ${typeModel.name}`)\n\t\t}\n\t\tconst resolvedSessionKeys = await this.collectAllInstanceSessionKeysAndAuthenticate(\n\t\t\tbucketKey,\n\t\t\tdecryptedBucketKey,\n\t\t\tinstanceElementId,\n\t\t\tinstance,\n\t\t\ttypeModel,\n\t\t\tunencryptedSenderAuthStatus,\n\t\t\tpqMessageSenderKey,\n\t\t)\n\n\t\tawait this.ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(resolvedSessionKeys.instanceSessionKeys, typeModel)\n\n\t\t// for symmetrically encrypted instances _ownerEncSessionKey is sent from the server.\n\t\t// in this case it is not yet and we need to set it because the rest of the app expects it.\n\t\tconst groupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(instance._ownerGroup) // get current key for encrypting\n\t\tthis.setOwnerEncSessionKeyUnmapped(\n\t\t\tinstance as UnmappedOwnerGroupInstance,\n\t\t\tencryptKeyWithVersionedKey(groupKey, resolvedSessionKeys.resolvedSessionKeyForInstance),\n\t\t)\n\t\treturn resolvedSessionKeys\n\t}\n\n\t/**\n\t * Calculates the SHA-256 checksum of a string value as UTF-8 bytes and returns it as a base64-encoded string\n\t */\n\tpublic async sha256(value: string): Promise<string> {\n\t\treturn uint8ArrayToBase64(sha256Hash(stringToUtf8Uint8Array(value)))\n\t}\n\n\t/**\n\t * Decrypts the given encrypted bucket key with the group key of the given group. In case the current user is not\n\t * member of the key group the function tries to resolve the group key using the adminEncGroupKey.\n\t * This is necessary for resolving the BucketKey when receiving a reply from an external Mailbox.\n\t * @param keyGroup The group that holds the encryption key.\n\t * @param groupKeyVersion the version of the key from the keyGroup\n\t * @param groupEncBucketKey The group key encrypted bucket key.\n\t */\n\tprivate async resolveWithGroupReference(keyGroup: Id, groupKeyVersion: KeyVersion, groupEncBucketKey: Uint8Array): Promise<AesKey> {\n\t\tif (this.userFacade.hasGroup(keyGroup)) {\n\t\t\t// the logged-in user (most likely external) is a member of that group. Then we have the group key from the memberships\n\t\t\tconst groupKey = await this.keyLoaderFacade.loadSymGroupKey(keyGroup, groupKeyVersion)\n\t\t\treturn decryptKey(groupKey, groupEncBucketKey)\n\t\t} else {\n\t\t\t// internal user receiving a mail from secure external:\n\t\t\t// internal user group key -> external user group key -> external mail group key -> bucket key\n\t\t\tconst externalMailGroupId = keyGroup\n\t\t\tconst externalMailGroupKeyVersion = groupKeyVersion\n\t\t\tconst externalMailGroup = await this.entityClient.load(GroupTypeRef, externalMailGroupId)\n\n\t\t\tconst externalUserGroupdId = externalMailGroup.admin\n\t\t\tif (!externalUserGroupdId) {\n\t\t\t\tthrow new SessionKeyNotFoundError(\"no admin group on key group: \" + externalMailGroupId)\n\t\t\t}\n\t\t\tconst externalUserGroupKeyVersion = parseKeyVersion(externalMailGroup.adminGroupKeyVersion ?? \"0\")\n\t\t\tconst externalUserGroup = await this.entityClient.load(GroupTypeRef, externalUserGroupdId)\n\n\t\t\tconst internalUserGroupId = externalUserGroup.admin\n\t\t\tconst internalUserGroupKeyVersion = parseKeyVersion(externalUserGroup.adminGroupKeyVersion ?? \"0\")\n\t\t\tif (!(internalUserGroupId && this.userFacade.hasGroup(internalUserGroupId))) {\n\t\t\t\tthrow new SessionKeyNotFoundError(\"no admin group or no membership of admin group: \" + internalUserGroupId)\n\t\t\t}\n\n\t\t\tconst internalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(internalUserGroupId, internalUserGroupKeyVersion)\n\n\t\t\tconst currentExternalUserGroupKey = decryptKey(internalUserGroupKey, assertNotNull(externalUserGroup.adminGroupEncGKey))\n\t\t\tconst externalUserGroupKey = await this.keyLoaderFacade.loadSymGroupKey(externalUserGroupdId, externalUserGroupKeyVersion, {\n\t\t\t\tobject: currentExternalUserGroupKey,\n\t\t\t\tversion: parseKeyVersion(externalUserGroup.groupKeyVersion),\n\t\t\t})\n\n\t\t\tconst currentExternalMailGroupKey = decryptKey(externalUserGroupKey, assertNotNull(externalMailGroup.adminGroupEncGKey))\n\t\t\tconst externalMailGroupKey = await this.keyLoaderFacade.loadSymGroupKey(externalMailGroupId, externalMailGroupKeyVersion, {\n\t\t\t\tobject: currentExternalMailGroupKey,\n\t\t\t\tversion: parseKeyVersion(externalMailGroup.groupKeyVersion),\n\t\t\t})\n\n\t\t\treturn decryptKey(externalMailGroupKey, groupEncBucketKey)\n\t\t}\n\t}\n\n\tprivate async addSessionKeyToPushIdentifier(data: Record<string, any>): Promise<Record<string, any>> {\n\t\tconst userGroupKey = this.userFacade.getCurrentUserGroupKey()\n\n\t\t// set sessionKey for allowing encryption when old instance (< v43) is updated\n\t\tconst typeModel = await resolveTypeReference(PushIdentifierTypeRef)\n\t\tawait this.updateOwnerEncSessionKey(typeModel, data, userGroupKey, aes256RandomKey())\n\t\treturn data\n\t}\n\n\tprivate async encryptTutanotaProperties(data: Record<string, any>): Promise<Record<string, any>> {\n\t\tconst userGroupKey = this.userFacade.getCurrentUserGroupKey()\n\n\t\t// EncryptTutanotaPropertiesService could be removed and replaced with a Migration that writes the key\n\t\tconst groupEncSessionKey = encryptKeyWithVersionedKey(userGroupKey, aes256RandomKey())\n\t\tthis.setOwnerEncSessionKeyUnmapped(data as UnmappedOwnerGroupInstance, groupEncSessionKey, this.userFacade.getUserGroupId())\n\t\tconst migrationData = createEncryptTutanotaPropertiesData({\n\t\t\tproperties: data._id,\n\t\t\tsymKeyVersion: String(groupEncSessionKey.encryptingKeyVersion),\n\t\t\tsymEncSessionKey: groupEncSessionKey.key,\n\t\t})\n\t\tawait this.serviceExecutor.post(EncryptTutanotaPropertiesService, migrationData)\n\t\treturn data\n\t}\n\n\tprivate async applyCustomerGroupOwnershipToGroupInfo(data: Record<string, any>): Promise<Record<string, any>> {\n\t\tconst customerGroupMembership = assertNotNull(\n\t\t\tthis.userFacade.getLoggedInUser().memberships.find((g: GroupMembership) => g.groupType === GroupType.Customer),\n\t\t)\n\t\tconst listPermissions = await this.entityClient.loadAll(PermissionTypeRef, data._id[0])\n\t\tconst customerGroupPermission = listPermissions.find((p) => p.group === customerGroupMembership.group)\n\n\t\tif (!customerGroupPermission) throw new SessionKeyNotFoundError(\"Permission not found, could not apply OwnerGroup migration\")\n\t\tconst customerGroupKeyVersion = parseKeyVersion(customerGroupPermission.symKeyVersion ?? \"0\")\n\t\tconst customerGroupKey = await this.keyLoaderFacade.loadSymGroupKey(customerGroupMembership.group, customerGroupKeyVersion)\n\t\tconst versionedCustomerGroupKey = { object: customerGroupKey, version: customerGroupKeyVersion }\n\t\tconst listKey = decryptKey(customerGroupKey, assertNotNull(customerGroupPermission.symEncSessionKey))\n\t\tconst groupInfoSk = decryptKey(listKey, base64ToUint8Array(data._listEncSessionKey))\n\n\t\tthis.setOwnerEncSessionKeyUnmapped(\n\t\t\tdata as UnmappedOwnerGroupInstance,\n\t\t\tencryptKeyWithVersionedKey(versionedCustomerGroupKey, groupInfoSk),\n\t\t\tcustomerGroupMembership.group,\n\t\t)\n\t\treturn data\n\t}\n\n\tprivate setOwnerEncSessionKeyUnmapped(unmappedInstance: UnmappedOwnerGroupInstance, key: VersionedEncryptedKey, ownerGroup?: Id) {\n\t\tunmappedInstance._ownerEncSessionKey = uint8ArrayToBase64(key.key)\n\t\tunmappedInstance._ownerKeyVersion = key.encryptingKeyVersion.toString()\n\t\tif (ownerGroup) {\n\t\t\tunmappedInstance._ownerGroup = ownerGroup\n\t\t}\n\t}\n\n\tprivate setOwnerEncSessionKey(instance: Instance, key: VersionedEncryptedKey) {\n\t\tinstance._ownerEncSessionKey = key.key\n\t\tinstance._ownerKeyVersion = key.encryptingKeyVersion.toString()\n\t}\n\n\t/**\n\t * @return Whether the {@param elementOrLiteral} is a unmapped type, as used in JSON for transport or if it's a runtime representation of a type.\n\t */\n\tprivate isLiteralInstance(elementOrLiteral: Record<string, any>): boolean {\n\t\treturn typeof elementOrLiteral._type === \"undefined\"\n\t}\n\n\tprivate async trySymmetricPermission(listPermissions: Permission[]): Promise<AesKey | null> {\n\t\tconst symmetricPermission: Permission | null =\n\t\t\tlistPermissions.find(\n\t\t\t\t(p) =>\n\t\t\t\t\t(p.type === PermissionType.Public_Symmetric || p.type === PermissionType.Symmetric) &&\n\t\t\t\t\tp._ownerGroup &&\n\t\t\t\t\tthis.userFacade.hasGroup(p._ownerGroup),\n\t\t\t) ?? null\n\n\t\tif (symmetricPermission) {\n\t\t\tconst gk = await this.keyLoaderFacade.loadSymGroupKey(\n\t\t\t\tassertNotNull(symmetricPermission._ownerGroup),\n\t\t\t\tparseKeyVersion(symmetricPermission._ownerKeyVersion ?? \"0\"),\n\t\t\t)\n\t\t\treturn decryptKey(gk, assertNotNull(symmetricPermission._ownerEncSessionKey))\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Resolves the session key for the provided instance and collects all other instances'\n\t * session keys in order to update them.\n\t */\n\tprivate async collectAllInstanceSessionKeysAndAuthenticate(\n\t\tbucketKey: BucketKey,\n\t\tdecBucketKey: number[],\n\t\tinstanceElementId: string,\n\t\tinstance: Record<string, any>,\n\t\ttypeModel: TypeModel,\n\t\tencryptionAuthStatus: EncryptionAuthStatus | null,\n\t\tpqMessageSenderKey: EccPublicKey | null,\n\t): Promise<ResolvedSessionKeys> {\n\t\tlet resolvedSessionKeyForInstance: AesKey | undefined = undefined\n\t\tconst instanceSessionKeys = await promiseMap(bucketKey.bucketEncSessionKeys, async (instanceSessionKey) => {\n\t\t\tconst decryptedSessionKey = decryptKey(decBucketKey, instanceSessionKey.symEncSessionKey)\n\t\t\tconst groupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(instance._ownerGroup)\n\t\t\tconst ownerEncSessionKey = encryptKeyWithVersionedKey(groupKey, decryptedSessionKey)\n\t\t\tconst instanceSessionKeyWithOwnerEncSessionKey = createInstanceSessionKey(instanceSessionKey)\n\t\t\tif (instanceElementId == instanceSessionKey.instanceId) {\n\t\t\t\tresolvedSessionKeyForInstance = decryptedSessionKey\n\t\t\t\t// we can only authenticate once we have the session key\n\t\t\t\t// because we need to check if the confidential flag is set, which is encrypted still\n\t\t\t\t// we need to do it here at the latest because we must write the flag when updating the session key on the instance\n\t\t\t\tawait this.authenticateMainInstance(\n\t\t\t\t\ttypeModel,\n\t\t\t\t\tencryptionAuthStatus,\n\t\t\t\t\tpqMessageSenderKey,\n\t\t\t\t\tbucketKey.protocolVersion === CryptoProtocolVersion.TUTA_CRYPT ? parseKeyVersion(bucketKey.senderKeyVersion ?? \"0\") : null,\n\t\t\t\t\tinstance,\n\t\t\t\t\tresolvedSessionKeyForInstance,\n\t\t\t\t\tinstanceSessionKeyWithOwnerEncSessionKey,\n\t\t\t\t\tdecryptedSessionKey,\n\t\t\t\t\tbucketKey.keyGroup,\n\t\t\t\t)\n\t\t\t}\n\t\t\tinstanceSessionKeyWithOwnerEncSessionKey.symEncSessionKey = ownerEncSessionKey.key\n\t\t\tinstanceSessionKeyWithOwnerEncSessionKey.symKeyVersion = String(ownerEncSessionKey.encryptingKeyVersion)\n\t\t\treturn instanceSessionKeyWithOwnerEncSessionKey\n\t\t})\n\n\t\tif (resolvedSessionKeyForInstance) {\n\t\t\treturn { resolvedSessionKeyForInstance, instanceSessionKeys }\n\t\t} else {\n\t\t\tthrow new SessionKeyNotFoundError(\"no session key for instance \" + instance._id)\n\t\t}\n\t}\n\n\tprivate async authenticateMainInstance(\n\t\ttypeModel: TypeModel,\n\t\tencryptionAuthStatus: EncryptionAuthStatus | null,\n\t\tpqMessageSenderKey: Uint8Array | null,\n\t\tpqMessageSenderKeyVersion: KeyVersion | null,\n\t\tinstance: Record<string, any>,\n\t\tresolvedSessionKeyForInstance: number[],\n\t\tinstanceSessionKeyWithOwnerEncSessionKey: InstanceSessionKey,\n\t\tdecryptedSessionKey: number[],\n\t\tkeyGroup: Id | null,\n\t) {\n\t\t// we only authenticate mail instances\n\t\tconst isMailInstance = isSameTypeRefByAttr(MailTypeRef, typeModel.app, typeModel.name)\n\t\tif (isMailInstance) {\n\t\t\tif (!encryptionAuthStatus) {\n\t\t\t\tif (!pqMessageSenderKey) {\n\t\t\t\t\t// This message was encrypted with RSA. We check if TutaCrypt could have been used instead.\n\t\t\t\t\tconst recipientGroup = assertNotNull(\n\t\t\t\t\t\tkeyGroup,\n\t\t\t\t\t\t\"trying to authenticate an asymmetrically encrypted message, but we can't determine the recipient's group ID\",\n\t\t\t\t\t)\n\t\t\t\t\tconst currentKeyPair = await this.keyLoaderFacade.loadCurrentKeyPair(recipientGroup)\n\t\t\t\t\tencryptionAuthStatus = EncryptionAuthStatus.RSA_NO_AUTHENTICATION\n\t\t\t\t\tif (isPqKeyPairs(currentKeyPair.object)) {\n\t\t\t\t\t\tconst keyRotationFacade = this.keyRotationFacade()\n\t\t\t\t\t\tconst rotatedGroups = await keyRotationFacade.getGroupIdsThatPerformedKeyRotations()\n\t\t\t\t\t\tif (!rotatedGroups.includes(recipientGroup)) {\n\t\t\t\t\t\t\tencryptionAuthStatus = EncryptionAuthStatus.RSA_DESPITE_TUTACRYPT\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst mail = this.isLiteralInstance(instance)\n\t\t\t\t\t\t? ((await this.instanceMapper.decryptAndMapToInstance(typeModel, instance, resolvedSessionKeyForInstance)) as Mail)\n\t\t\t\t\t\t: (instance as Mail)\n\t\t\t\t\tconst senderMailAddress = mail.confidential ? mail.sender.address : SYSTEM_GROUP_MAIL_ADDRESS\n\t\t\t\t\tencryptionAuthStatus = await this.tryAuthenticateSenderOfMainInstance(\n\t\t\t\t\t\tsenderMailAddress,\n\t\t\t\t\t\tpqMessageSenderKey,\n\t\t\t\t\t\t// must not be null if this is a TutaCrypt message with a pqMessageSenderKey\n\t\t\t\t\t\tassertNotNull(pqMessageSenderKeyVersion),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t\tinstanceSessionKeyWithOwnerEncSessionKey.encryptionAuthStatus = aesEncrypt(decryptedSessionKey, stringToUtf8Uint8Array(encryptionAuthStatus))\n\t\t}\n\t}\n\n\tprivate async tryAuthenticateSenderOfMainInstance(senderMailAddress: string, pqMessageSenderKey: Uint8Array, pqMessageSenderKeyVersion: KeyVersion) {\n\t\ttry {\n\t\t\treturn await this.asymmetricCryptoFacade.authenticateSender(\n\t\t\t\t{\n\t\t\t\t\tidentifier: senderMailAddress,\n\t\t\t\t\tidentifierType: PublicKeyIdentifierType.MAIL_ADDRESS,\n\t\t\t\t},\n\t\t\t\tpqMessageSenderKey,\n\t\t\t\tpqMessageSenderKeyVersion,\n\t\t\t)\n\t\t} catch (e) {\n\t\t\t// we do not want to fail mail decryption here, e.g. in case an alias was removed we would get a permanent NotFoundError.\n\t\t\t// in those cases we will just show a warning banner but still want to display the mail\n\t\t\tconsole.error(\"Could not authenticate sender\", e)\n\t\t\treturn EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED\n\t\t}\n\t}\n\n\tprivate async resolveWithPublicOrExternalPermission(listPermissions: Permission[], instance: Record<string, any>, typeModel: TypeModel): Promise<AesKey> {\n\t\tconst pubOrExtPermission = listPermissions.find((p) => p.type === PermissionType.Public || p.type === PermissionType.External) ?? null\n\n\t\tif (pubOrExtPermission == null) {\n\t\t\tconst typeName = `${typeModel.app}/${typeModel.name}`\n\t\t\tthrow new SessionKeyNotFoundError(`could not find permission for instance of type ${typeName} with id ${this.getElementIdFromInstance(instance)}`)\n\t\t}\n\n\t\tconst bucketPermissions = await this.entityClient.loadAll(BucketPermissionTypeRef, assertNotNull(pubOrExtPermission.bucket).bucketPermissions)\n\t\tconst bucketPermission = bucketPermissions.find(\n\t\t\t(bp) => (bp.type === BucketPermissionType.Public || bp.type === BucketPermissionType.External) && pubOrExtPermission._ownerGroup === bp._ownerGroup,\n\t\t)\n\n\t\t// find the bucket permission with the same group as the permission and public type\n\t\tif (bucketPermission == null) {\n\t\t\tthrow new SessionKeyNotFoundError(\"no corresponding bucket permission found\")\n\t\t}\n\n\t\tif (bucketPermission.type === BucketPermissionType.External) {\n\t\t\treturn this.decryptWithExternalBucket(bucketPermission, pubOrExtPermission, instance)\n\t\t} else {\n\t\t\treturn this.decryptWithPublicBucketWithoutAuthentication(bucketPermission, instance, pubOrExtPermission, typeModel)\n\t\t}\n\t}\n\n\tprivate async decryptWithExternalBucket(\n\t\tbucketPermission: BucketPermission,\n\t\tpubOrExtPermission: Permission,\n\t\tinstance: Record<string, any>,\n\t): Promise<AesKey> {\n\t\tlet bucketKey\n\n\t\tif (bucketPermission.ownerEncBucketKey != null) {\n\t\t\tconst ownerGroupKey = await this.keyLoaderFacade.loadSymGroupKey(\n\t\t\t\tneverNull(bucketPermission._ownerGroup),\n\t\t\t\tparseKeyVersion(bucketPermission.ownerKeyVersion ?? \"0\"),\n\t\t\t)\n\t\t\tbucketKey = decryptKey(ownerGroupKey, bucketPermission.ownerEncBucketKey)\n\t\t} else if (bucketPermission.symEncBucketKey) {\n\t\t\t// legacy case: for very old email sent to external user we used symEncBucketKey on the bucket permission.\n\t\t\t// The bucket key is encrypted with the user group key of the external user.\n\t\t\t// We maintain this code as we still have some old BucketKeys in some external mailboxes.\n\t\t\t// Can be removed if we finished mail details migration or when we do cleanup of external mailboxes.\n\t\t\tconst userGroupKey = await this.keyLoaderFacade.loadSymUserGroupKey(parseKeyVersion(bucketPermission.symKeyVersion ?? \"0\"))\n\t\t\tbucketKey = decryptKey(userGroupKey, bucketPermission.symEncBucketKey)\n\t\t} else {\n\t\t\tthrow new SessionKeyNotFoundError(\n\t\t\t\t`BucketEncSessionKey is not defined for Permission ${pubOrExtPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`,\n\t\t\t)\n\t\t}\n\n\t\treturn decryptKey(bucketKey, neverNull(pubOrExtPermission.bucketEncSessionKey))\n\t}\n\n\tprivate async decryptWithPublicBucketWithoutAuthentication(\n\t\tbucketPermission: BucketPermission,\n\t\tinstance: Record<string, any>,\n\t\tpubOrExtPermission: Permission,\n\t\ttypeModel: TypeModel,\n\t): Promise<AesKey> {\n\t\tconst pubEncBucketKey = bucketPermission.pubEncBucketKey\n\t\tif (pubEncBucketKey == null) {\n\t\t\tthrow new SessionKeyNotFoundError(\n\t\t\t\t`PubEncBucketKey is not defined for BucketPermission ${bucketPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`,\n\t\t\t)\n\t\t}\n\t\tconst bucketEncSessionKey = pubOrExtPermission.bucketEncSessionKey\n\t\tif (bucketEncSessionKey == null) {\n\t\t\tthrow new SessionKeyNotFoundError(\n\t\t\t\t`BucketEncSessionKey is not defined for Permission ${pubOrExtPermission._id.toString()} (Instance: ${JSON.stringify(instance)})`,\n\t\t\t)\n\t\t}\n\n\t\tconst { decryptedAesKey } = await this.asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(\n\t\t\tbucketPermission.group,\n\t\t\tparseKeyVersion(bucketPermission.pubKeyVersion ?? \"0\"),\n\t\t\tasCryptoProtoocolVersion(bucketPermission.protocolVersion),\n\t\t\tpubEncBucketKey,\n\t\t)\n\n\t\tconst sk = decryptKey(decryptedAesKey, bucketEncSessionKey)\n\n\t\tif (bucketPermission._ownerGroup) {\n\t\t\t// is not defined for some old AccountingInfos\n\t\t\tlet bucketPermissionOwnerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(neverNull(bucketPermission._ownerGroup)) // get current key for encrypting\n\t\t\tawait this.updateWithSymPermissionKey(typeModel, instance, pubOrExtPermission, bucketPermission, bucketPermissionOwnerGroupKey, sk).catch(\n\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\tconsole.log(\"w> could not find instance to update permission\")\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t\treturn sk\n\t}\n\n\t/**\n\t * Returns the session key for the provided service response:\n\t * * null, if the instance is unencrypted\n\t * * the decrypted _ownerPublicEncSessionKey, if it is available\n\t * @param instance The unencrypted (client-side) or encrypted (server-side) instance\n\t *\n\t */\n\tasync resolveServiceSessionKey(instance: Record<string, any>): Promise<Aes256Key | null> {\n\t\tif (instance._ownerPublicEncSessionKey) {\n\t\t\t// we assume the server uses the current key pair of the recipient\n\t\t\tconst keypair = await this.keyLoaderFacade.loadCurrentKeyPair(instance._ownerGroup)\n\t\t\t// we do not authenticate as we could remove data transfer type encryption altogether and only rely on tls\n\t\t\treturn (\n\t\t\t\tawait this.asymmetricCryptoFacade.decryptSymKeyWithKeyPair(\n\t\t\t\t\tkeypair.object,\n\t\t\t\t\tassertEnumValue(CryptoProtocolVersion, instance._publicCryptoProtocolVersion),\n\t\t\t\t\tbase64ToUint8Array(instance._ownerPublicEncSessionKey),\n\t\t\t\t)\n\t\t\t).decryptedAesKey\n\t\t}\n\t\treturn null\n\t}\n\n\t/**\n\t * Creates a new _ownerEncSessionKey and assigns it to the provided entity\n\t * the entity must already have an _ownerGroup\n\t * @returns the generated key\n\t */\n\tasync setNewOwnerEncSessionKey(model: TypeModel, entity: Record<string, any>, keyToEncryptSessionKey?: VersionedKey): Promise<AesKey | null> {\n\t\tif (!entity._ownerGroup) {\n\t\t\tthrow new Error(`no owner group set  ${JSON.stringify(entity)}`)\n\t\t}\n\n\t\tif (model.encrypted) {\n\t\t\tif (entity._ownerEncSessionKey) {\n\t\t\t\tthrow new Error(`ownerEncSessionKey already set ${JSON.stringify(entity)}`)\n\t\t\t}\n\n\t\t\tconst sessionKey = aes256RandomKey()\n\t\t\tconst effectiveKeyToEncryptSessionKey = keyToEncryptSessionKey ?? (await this.keyLoaderFacade.getCurrentSymGroupKey(entity._ownerGroup))\n\t\t\tconst encryptedSessionKey = encryptKeyWithVersionedKey(effectiveKeyToEncryptSessionKey, sessionKey)\n\t\t\tthis.setOwnerEncSessionKey(entity as Instance, encryptedSessionKey)\n\t\t\treturn sessionKey\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync encryptBucketKeyForInternalRecipient(\n\t\tsenderUserGroupId: Id,\n\t\tbucketKey: AesKey,\n\t\trecipientMailAddress: string,\n\t\tnotFoundRecipients: Array<string>,\n\t): Promise<InternalRecipientKeyData | SymEncInternalRecipientKeyData | null> {\n\t\ttry {\n\t\t\tconst pubKeys = await this.publicKeyProvider.loadCurrentPubKey({\n\t\t\t\tidentifier: recipientMailAddress,\n\t\t\t\tidentifierType: PublicKeyIdentifierType.MAIL_ADDRESS,\n\t\t\t})\n\t\t\t// We do not create any key data in case there is one not found recipient, but we want to\n\t\t\t// collect ALL not found recipients when iterating a recipient list.\n\t\t\tif (notFoundRecipients.length !== 0) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tconst isExternalSender = this.userFacade.getUser()?.accountType === AccountType.EXTERNAL\n\t\t\t// we only encrypt symmetric as external sender if the recipient supports tuta-crypt.\n\t\t\t// Clients need to support symmetric decryption from external users. We can always encrypt symmetricly when old clients are deactivated that don't support tuta-crypt.\n\t\t\tif (pubKeys.object.pubKyberKey && isExternalSender) {\n\t\t\t\treturn this.createSymEncInternalRecipientKeyData(recipientMailAddress, bucketKey)\n\t\t\t} else {\n\t\t\t\treturn this.createPubEncInternalRecipientKeyData(bucketKey, recipientMailAddress, pubKeys, senderUserGroupId)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\tnotFoundRecipients.push(recipientMailAddress)\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof TooManyRequestsError) {\n\t\t\t\tthrow new RecipientNotResolvedError(\"\")\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async createPubEncInternalRecipientKeyData(\n\t\tbucketKey: AesKey,\n\t\trecipientMailAddress: string,\n\t\trecipientPublicKeys: Versioned<PublicKeys>,\n\t\tsenderGroupId: Id,\n\t) {\n\t\tconst pubEncBucketKey = await this.asymmetricCryptoFacade.asymEncryptSymKey(bucketKey, recipientPublicKeys, senderGroupId)\n\t\treturn createInternalRecipientKeyData({\n\t\t\tmailAddress: recipientMailAddress,\n\t\t\tpubEncBucketKey: pubEncBucketKey.pubEncSymKeyBytes,\n\t\t\trecipientKeyVersion: pubEncBucketKey.recipientKeyVersion.toString(),\n\t\t\tsenderKeyVersion: pubEncBucketKey.senderKeyVersion != null ? pubEncBucketKey.senderKeyVersion.toString() : null,\n\t\t\tprotocolVersion: pubEncBucketKey.cryptoProtocolVersion,\n\t\t})\n\t}\n\n\tprivate async createSymEncInternalRecipientKeyData(recipientMailAddress: string, bucketKey: AesKey) {\n\t\tconst keyGroup = this.userFacade.getGroupId(GroupType.Mail)\n\t\tconst externalMailGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(keyGroup)\n\t\treturn createSymEncInternalRecipientKeyData({\n\t\t\tmailAddress: recipientMailAddress,\n\t\t\tsymEncBucketKey: encryptKey(externalMailGroupKey.object, bucketKey),\n\t\t\tkeyGroup,\n\t\t\tsymKeyVersion: String(externalMailGroupKey.version),\n\t\t})\n\t}\n\n\t/**\n\t * Updates the given public permission with the given symmetric key for faster access if the client is the leader and otherwise does nothing.\n\t * @param typeModel The type model of the instance\n\t * @param instance The unencrypted (client-side) or encrypted (server-side) instance\n\t * @param permission The permission.\n\t * @param bucketPermission The bucket permission.\n\t * @param permissionOwnerGroupKey The symmetric group key for the owner group on the permission.\n\t * @param sessionKey The symmetric session key.\n\t */\n\tprivate async updateWithSymPermissionKey(\n\t\ttypeModel: TypeModel,\n\t\tinstance: Record<string, any>,\n\t\tpermission: Permission,\n\t\tbucketPermission: BucketPermission,\n\t\tpermissionOwnerGroupKey: VersionedKey,\n\t\tsessionKey: AesKey,\n\t): Promise<void> {\n\t\tif (!this.isLiteralInstance(instance) || !this.userFacade.isLeader()) {\n\t\t\t// do not update the session key in case of an unencrypted (client-side) instance\n\t\t\t// or in case we are not the leader client\n\t\t\treturn\n\t\t}\n\n\t\tif (!instance._ownerEncSessionKey && permission._ownerGroup === instance._ownerGroup) {\n\t\t\treturn this.updateOwnerEncSessionKey(typeModel, instance, permissionOwnerGroupKey, sessionKey)\n\t\t} else {\n\t\t\t// instances shared via permissions (e.g. body)\n\t\t\tconst encryptedKey = encryptKeyWithVersionedKey(permissionOwnerGroupKey, sessionKey)\n\t\t\tlet updateService = createUpdatePermissionKeyData({\n\t\t\t\townerKeyVersion: String(encryptedKey.encryptingKeyVersion),\n\t\t\t\townerEncSessionKey: encryptedKey.key,\n\t\t\t\tpermission: permission._id,\n\t\t\t\tbucketPermission: bucketPermission._id,\n\t\t\t})\n\t\t\tawait this.serviceExecutor.post(UpdatePermissionKeyService, updateService)\n\t\t}\n\t}\n\n\t/**\n\t * Resolves the ownerEncSessionKey of a mail. This might be needed if it wasn't updated yet\n\t * by the OwnerEncSessionKeysUpdateQueue but the file is already downloaded.\n\t * @param mainInstance the instance that has the bucketKey\n\t * @param childInstances the files that belong to the mainInstance\n\t */\n\tasync enforceSessionKeyUpdateIfNeeded(mainInstance: Record<string, any>, childInstances: readonly File[]): Promise<File[]> {\n\t\tif (!childInstances.some((f) => f._ownerEncSessionKey == null)) {\n\t\t\treturn childInstances.slice()\n\t\t}\n\t\tconst typeModel = await resolveTypeReference(mainInstance._type)\n\t\tconst outOfSyncInstances = childInstances.filter((f) => f._ownerEncSessionKey == null)\n\t\tif (mainInstance.bucketKey) {\n\t\t\t// invoke updateSessionKeys service in case a bucket key is still available\n\t\t\tconst bucketKey = await this.convertBucketKeyToInstanceIfNecessary(mainInstance.bucketKey)\n\t\t\tconst resolvedSessionKeys = await this.resolveWithBucketKey(bucketKey, mainInstance, typeModel)\n\t\t\tawait this.ownerEncSessionKeysUpdateQueue.postUpdateSessionKeysService(resolvedSessionKeys.instanceSessionKeys)\n\t\t} else {\n\t\t\tconsole.warn(\"files are out of sync refreshing\", outOfSyncInstances.map((f) => f._id).join(\", \"))\n\t\t}\n\t\tfor (const childInstance of outOfSyncInstances) {\n\t\t\tawait this.cache?.deleteFromCacheIfExists(FileTypeRef, getListId(childInstance), getElementId(childInstance))\n\t\t}\n\t\t// we have a caching entity client, so this re-inserts the deleted instances\n\t\treturn await this.entityClient.loadMultiple(\n\t\t\tFileTypeRef,\n\t\t\tgetListId(childInstances[0]),\n\t\t\tchildInstances.map((childInstance) => getElementId(childInstance)),\n\t\t)\n\t}\n\n\tprivate updateOwnerEncSessionKey(typeModel: TypeModel, instance: Record<string, any>, ownerGroupKey: VersionedKey, sessionKey: AesKey): Promise<void> {\n\t\tthis.setOwnerEncSessionKeyUnmapped(instance as UnmappedOwnerGroupInstance, encryptKeyWithVersionedKey(ownerGroupKey, sessionKey))\n\t\t// we have to call the rest client directly because instance is still the encrypted server-side version\n\t\tconst path = typeRefToPath(new TypeRef(typeModel.app, typeModel.name)) + \"/\" + (instance._id instanceof Array ? instance._id.join(\"/\") : instance._id)\n\t\tconst headers = this.userFacade.createAuthHeaders()\n\t\theaders.v = typeModel.version\n\t\treturn this.restClient\n\t\t\t.request(path, HttpMethod.PUT, {\n\t\t\t\theaders,\n\t\t\t\tbody: JSON.stringify(instance),\n\t\t\t\tqueryParams: { updateOwnerEncSessionKey: \"true\" },\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(PayloadTooLargeError, (e) => {\n\t\t\t\t\tconsole.log(\"Could not update owner enc session key - PayloadTooLargeError\", e)\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\tprivate getElementIdFromInstance(instance: Record<string, any>): Id {\n\t\tif (typeof instance._id === \"string\") {\n\t\t\treturn instance._id\n\t\t} else {\n\t\t\tconst idTuple = instance._id as IdTuple\n\t\t\treturn elementIdPart(idTuple)\n\t\t}\n\t}\n}\n\nif (!(\"toJSON\" in Error.prototype)) {\n\tObject.defineProperty(Error.prototype as any, \"toJSON\", {\n\t\tvalue: function () {\n\t\t\tconst alt: Record<string, any> = {}\n\t\t\tfor (let key of Object.getOwnPropertyNames(this)) {\n\t\t\t\talt[key] = this[key]\n\t\t\t}\n\t\t\treturn alt\n\t\t},\n\t\tconfigurable: true,\n\t\twritable: true,\n\t})\n}\n"]}