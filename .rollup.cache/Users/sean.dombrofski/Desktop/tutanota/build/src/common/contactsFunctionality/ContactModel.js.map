{"version":3,"file":"ContactModel.js","sourceRoot":"","sources":["../../../../src/common/contactsFunctionality/ContactModel.ts"],"names":[],"mappings":"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","sourcesContent":["import { assertMainOrNode } from \"../api/common/Env.js\"\nimport { Group, GroupInfo, GroupInfoTypeRef, GroupMembership, GroupTypeRef } from \"../api/entities/sys/TypeRefs.js\"\nimport {\n\tContact,\n\tContactList,\n\tContactListGroupRoot,\n\tContactListGroupRootTypeRef,\n\tContactListTypeRef,\n\tContactTypeRef,\n} from \"../api/entities/tutanota/TypeRefs.js\"\nimport { getFirstOrThrow, isNotNull, LazyLoaded, ofClass, promiseMap } from \"@tutao/tutanota-utils\"\nimport Stream from \"mithril/stream\"\nimport stream from \"mithril/stream\"\nimport { EntityClient, loadMultipleFromLists } from \"../api/common/EntityClient.js\"\nimport { LoginController } from \"../api/main/LoginController.js\"\nimport { EntityEventsListener, EventController } from \"../api/main/EventController.js\"\nimport { LoginIncompleteError } from \"../api/common/error/LoginIncompleteError.js\"\nimport { cleanMailAddress } from \"../api/common/utils/CommonCalendarUtils.js\"\nimport { DbError } from \"../api/common/error/DbError.js\"\nimport { compareOldestFirst, getEtId } from \"../api/common/utils/EntityUtils.js\"\nimport { NotAuthorizedError, NotFoundError } from \"../api/common/error/RestError.js\"\nimport { ShareCapability } from \"../api/common/TutanotaConstants.js\"\nimport { EntityUpdateData } from \"../api/common/utils/EntityUpdateUtils.js\"\nimport type { SearchResult } from \"../api/worker/search/SearchTypes.js\"\n\nassertMainOrNode()\n\nexport type ContactListInfo = {\n\tname: string\n\tgroupInfo: GroupInfo\n\tgroup: Group\n\tgroupRoot: ContactListGroupRoot\n\tisOwner: boolean\n\tcanEdit: boolean\n}\n\nexport class ContactModel {\n\tprivate contactListId: LazyLoaded<Id | null>\n\tprivate contactListInfo: Stream<ReadonlyArray<ContactListInfo>> = stream()\n\n\tconstructor(\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly loginController: LoginController,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly contactSearch: (query: string, field: string, minSuggestionCount: number, maxResults?: number) => Promise<SearchResult>,\n\t) {\n\t\tthis.contactListId = lazyContactListId(loginController, this.entityClient)\n\t\tthis.eventController.addEntityListener(this.entityEventsReceived)\n\t}\n\n\tasync getLoadedContactListInfos(): Promise<ReadonlyArray<ContactListInfo>> {\n\t\t// prevent re-loading them when we already have them\n\t\t// this is not perfect and might still start loads in parallel\n\t\tif (this.contactListInfo() === undefined) {\n\t\t\tawait this.loadContactLists()\n\t\t}\n\t\treturn this.contactListInfo()\n\t}\n\n\t/** might be empty if not loaded yet */\n\tgetOwnContactListInfos(): Stream<ReadonlyArray<ContactListInfo>> {\n\t\treturn this.contactListInfo.map((contactListInfos) => contactListInfos.filter((info) => info.isOwner))\n\t}\n\n\t/** might be empty if not loaded yet */\n\tgetSharedContactListInfos(): Stream<ReadonlyArray<ContactListInfo>> {\n\t\treturn this.contactListInfo.map((contactListInfos) => contactListInfos.filter((info) => !info.isOwner))\n\t}\n\n\t/** Id of the contact list. Is null for external users. */\n\tgetContactListId(): Promise<Id | null> {\n\t\treturn this.contactListId.getAsync()\n\t}\n\n\t/**\n\t * Provides the first contact (starting with oldest contact) that contains the given email address. Uses the index search if available, otherwise loads all contacts.\n\t */\n\tasync searchForContact(mailAddress: string): Promise<Contact | null> {\n\t\t//searching for contacts depends on searchFacade._db to be initialized. If the user has not logged in online the respective promise will never resolve.\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contacts as online login is not completed\")\n\t\t}\n\t\tconst cleanedMailAddress = cleanMailAddress(mailAddress)\n\t\tlet result\n\t\ttry {\n\t\t\tresult = await this.contactSearch('\"' + cleanedMailAddress + '\"', \"mailAddress\", 0)\n\t\t} catch (e) {\n\t\t\t// If IndexedDB is not supported or isn't working for some reason we load contacts from the server and\n\t\t\t// search manually.\n\t\t\tif (e instanceof DbError) {\n\t\t\t\tconst listId = await this.getContactListId()\n\t\t\t\tif (listId) {\n\t\t\t\t\tconst contacts = await this.entityClient.loadAll(ContactTypeRef, listId)\n\t\t\t\t\treturn contacts.find((contact) => contact.mailAddresses.some((a) => cleanMailAddress(a.address) === cleanedMailAddress)) ?? null\n\t\t\t\t} else {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t\t// the result is sorted from newest to oldest, but we want to return the oldest first like before\n\t\tresult.results.sort(compareOldestFirst)\n\n\t\tfor (const contactId of result.results) {\n\t\t\ttry {\n\t\t\t\tconst contact = await this.entityClient.load(ContactTypeRef, contactId)\n\t\t\t\tif (contact.mailAddresses.some((a) => cleanMailAddress(a.address) === cleanedMailAddress)) {\n\t\t\t\t\treturn contact\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\t/**\n\t * @pre locator.search.indexState().indexingSupported\n\t */\n\tasync searchForContacts(query: string, field: string, minSuggestionCount: number): Promise<Contact[]> {\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contacts as online login is not completed\")\n\t\t}\n\t\tconst result = await this.contactSearch(query, field, minSuggestionCount)\n\t\treturn await loadMultipleFromLists(ContactTypeRef, this.entityClient, result.results)\n\t}\n\n\tasync searchForContactLists(query: string): Promise<ContactListInfo[]> {\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contact lists as online login is not completed\")\n\t\t}\n\n\t\tconst contactLists = await this.getLoadedContactListInfos()\n\n\t\treturn contactLists.filter((contactList) => contactList.name.toLowerCase().includes(query))\n\t}\n\n\tasync loadContactFromId(contactId: IdTuple) {\n\t\tif (!this.loginController.isFullyLoggedIn()) {\n\t\t\tthrow new LoginIncompleteError(\"cannot search for contact lists as online login is not completed\")\n\t\t}\n\n\t\treturn await this.entityClient.load(ContactTypeRef, contactId)\n\t}\n\n\tasync getContactGroupId(): Promise<Id> {\n\t\treturn getFirstOrThrow(this.loginController.getUserController().getContactGroupMemberships()).group\n\t}\n\n\tprivate async loadContactLists() {\n\t\tconst userController = this.loginController.getUserController()\n\t\tconst contactListMemberships = userController.getContactListMemberships()\n\t\tconst contactListInfo = (\n\t\t\tawait promiseMap(\n\t\t\t\tawait promiseMap(contactListMemberships, (rlm: GroupMembership) => this.entityClient.load(GroupInfoTypeRef, rlm.groupInfo)),\n\t\t\t\t// need to catch both NotFoundError and NotAuthorizedError, as we might still have a membership for a short time\n\t\t\t\t// when the group root is already deleted, or we deleted our membership\n\t\t\t\t(groupInfo) =>\n\t\t\t\t\tthis.getContactListInfo(groupInfo)\n\t\t\t\t\t\t.catch(ofClass(NotFoundError, () => null))\n\t\t\t\t\t\t.catch(ofClass(NotAuthorizedError, () => null)),\n\t\t\t)\n\t\t).filter(isNotNull)\n\n\t\tthis.contactListInfo(contactListInfo)\n\t}\n\n\tprivate async getContactListInfo(groupInfo: GroupInfo): Promise<ContactListInfo> {\n\t\tconst group = await this.entityClient.load(GroupTypeRef, groupInfo.group)\n\t\tconst groupRoot = await this.entityClient.load(ContactListGroupRootTypeRef, groupInfo.group)\n\t\tconst userController = this.loginController.getUserController()\n\t\tconst { getSharedGroupName } = await import(\"../sharing/GroupUtils.js\")\n\t\tconst { hasCapabilityOnGroup, isSharedGroupOwner } = await import(\"../sharing/GroupUtils.js\")\n\n\t\treturn {\n\t\t\tname: getSharedGroupName(groupInfo, userController, true),\n\t\t\tgroup,\n\t\t\tgroupInfo,\n\t\t\tgroupRoot,\n\t\t\tisOwner: isSharedGroupOwner(group, getEtId(userController.user)),\n\t\t\tcanEdit: hasCapabilityOnGroup(userController.user, group, ShareCapability.Write),\n\t\t}\n\t}\n\n\tprivate readonly entityEventsReceived: EntityEventsListener = async (updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: Id): Promise<void> => {\n\t\tfor (const update of updates) {\n\t\t\tif (this.loginController.getUserController().isUpdateForLoggedInUserInstance(update, eventOwnerGroupId)) {\n\t\t\t\tawait this.loadContactLists()\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function lazyContactListId(logins: LoginController, entityClient: EntityClient): LazyLoaded<Id | null> {\n\treturn new LazyLoaded(() => {\n\t\treturn entityClient\n\t\t\t.loadRoot(ContactListTypeRef, logins.getUserController().user.userGroup.group)\n\t\t\t.then((contactList: ContactList) => {\n\t\t\t\treturn contactList.contacts\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, (e) => {\n\t\t\t\t\tif (!logins.getUserController().isInternalUser()) {\n\t\t\t\t\t\treturn null // external users have no contact list.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t)\n\t})\n}\n"]}