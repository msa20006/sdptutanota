{"version":3,"file":"OfflineDbRefCounter.js","sourceRoot":"","sources":["../../../../../src/common/desktop/db/OfflineDbRefCounter.ts"],"names":[],"mappings":"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","sourcesContent":["import { defer, DeferredObject, delay } from \"@tutao/tutanota-utils\"\nimport { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { log } from \"../DesktopLog.js\"\nimport { OfflineDbFactory } from \"./PerWindowSqlCipherFacade.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\n\nconst TAG = \"[OfflineDbRefCounter]\"\nconst MAX_WAIT_FOR_DB_CLOSE_MS = 1000\n\ninterface CacheEntry {\n\treadonly db: Promise<SqlCipherFacade>\n\t/** Reference counting for db in case multiple windows open it. */\n\tcounter: number\n\t/**\n\t * We want to lock the access to the \"ranges\" table when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId).\n\t * We store locks with their corresponding listId in this Map.\n\t */\n\tlistIdLocks: Map<string, DeferredObject<void>>\n}\n\n/**\n * mainly for reference counting sqlcipher database connections coming from different windows.\n * keeps one opened database for each userId, independent of the number of windows logged\n * into that account (as long as it's bigger than 0)\n */\nexport class OfflineDbRefCounter {\n\t/**\n\t * a map from userId to an instance of an offlineDb for that user and the number of references currently held to it.\n\t * @private\n\t */\n\tprivate readonly cache: Map<Id, CacheEntry> = new Map()\n\n\tconstructor(private readonly offlineDbFactory: OfflineDbFactory) {}\n\n\tasync getOrCreateDb(userId: Id, dbKey: Uint8Array): Promise<SqlCipherFacade> {\n\t\tlet entry: CacheEntry | undefined = this.cache.get(userId)\n\t\tif (entry) {\n\t\t\tentry.counter += 1\n\t\t\treturn await entry.db\n\t\t} else {\n\t\t\tconst db = this.offlineDbFactory.create(userId, dbKey)\n\t\t\tentry = { db, counter: 1, listIdLocks: new Map() }\n\t\t\tthis.cache.set(userId, entry)\n\t\t\treturn await entry.db\n\t\t}\n\n\t\t// not returning from here makes for better stack traces.\n\t}\n\n\t/*\n\t * de-reference the offline db belonging to the userId.\n\t * will release the db connection if this is the last reference.\n\t *\n\t * must only be called directly from PerWindowSqlCipherFacade or from within this class.\n\t *\n\t **/\n\tasync disposeDb(userId: Id) {\n\t\tlet entry = this.cache.get(userId)\n\t\tif (entry == null) {\n\t\t\treturn\n\t\t}\n\t\tentry.counter -= 1\n\n\t\tif (entry.counter === 0) {\n\t\t\tthis.cache.delete(userId)\n\t\t\tconst db = await entry.db\n\t\t\tawait db.closeDb()\n\t\t\tconsole.log(TAG, \"closed db for\", userId)\n\t\t} else {\n\t\t\tconsole.log(TAG, \"dispose done, still ref'd\")\n\t\t}\n\t}\n\n\t/**\n\t * deletes the offline DB file from the disk, making a best-effort attempt to let all\n\t * windows close the connection before removing it.\n\t *\n\t * should be used when:\n\t * * the offline DB is out of sync\n\t * * the credentials are deleted from the app\n\t * * the user logs in with a userId that is already stored in the app (internal and external users)\n\t * * there was an error during session creation that could cause us to have a new database but no new credentials.\n\t *\n\t * the database is not necessarily open or in the cache; it may be deleted directly from the login screen.\n\t */\n\tasync deleteDb(userId: string): Promise<void> {\n\t\tlog.debug(TAG, `Deleting db for user ${userId}`)\n\t\tawait this.disposeDb(userId)\n\t\tconst waitUntilMax = Date.now() + MAX_WAIT_FOR_DB_CLOSE_MS\n\t\twhile (this.cache.has(userId) && Date.now() < waitUntilMax) {\n\t\t\tlog.debug(`waiting for other windows to close db before deleting it for user ${userId}`)\n\t\t\tawait delay(100)\n\t\t}\n\t\tthis.cache.delete(userId)\n\t\tawait this.offlineDbFactory.delete(userId)\n\t\tlog.debug(TAG, `Deleted db for user ${userId}`)\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" table when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId).\n\t * @param userId the user the mail list that we're locking belongs to\n\t * @param listId the mail list that we want to lock\n\t */\n\tasync lockRangesDbAccess(userId: Id, listId: Id): Promise<void> {\n\t\tconst entry = this.cache.get(userId)\n\t\tif (entry == null) {\n\t\t\t// should not happen because why would we lock a table that we do not hold a ref for.\n\t\t\t// the caller will probably run into a offlineDbClosedError very soon.\n\t\t\tthrow new ProgrammingError(\"tried to lock a db that's not open.\")\n\t\t}\n\t\tif (entry.listIdLocks.get(listId)) {\n\t\t\tawait entry.listIdLocks.get(listId)?.promise\n\t\t\tentry.listIdLocks.set(listId, defer())\n\t\t} else {\n\t\t\tentry.listIdLocks.set(listId, defer())\n\t\t}\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(userId, listId)\".\n\t * @param userId the user the mail list that we're locking belongs to\n\t * @param listId the mail list that we want to unlock\n\t */\n\tasync unlockRangesDbAccess(userId: Id, listId: Id): Promise<void> {\n\t\tconst entry = this.cache.get(userId)\n\t\tif (entry == null) {\n\t\t\t// should not happen because why would we lock a table that we do not hold a ref for.\n\t\t\t// the caller will probably run into a offlineDbClosedError very soon.\n\t\t\tthrow new ProgrammingError(\"tried to unlock a db that's not open.\")\n\t\t}\n\t\tentry.listIdLocks.get(listId)?.resolve()\n\t\tentry.listIdLocks.delete(listId)\n\t}\n}\n"]}