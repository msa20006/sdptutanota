{"version":3,"file":"SimplifiedCreditCardInputModel.js","sourceRoot":"","sources":["../../../../src/common/subscription/SimplifiedCreditCardInputModel.ts"],"names":[],"mappings":"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","sourcesContent":["import { createCreditCard, CreditCard } from \"../api/entities/sys/TypeRefs.js\"\nimport { LanguageViewModel, TranslationKey } from \"../misc/LanguageViewModel.js\"\nimport { CCViewModel } from \"./SimplifiedCreditCardInput.js\"\nimport { isValidCreditCardNumber } from \"../misc/FormatValidator.js\"\nimport { typedValues } from \"@tutao/tutanota-utils\"\n\n// we're using string values to make it easy to iterate all card types\nexport enum CardType {\n\tAmex = \"Amex\",\n\tVisa = \"Visa\",\n\tMastercard = \"Mastercard\",\n\tMaestro = \"Maestro\",\n\tDiscover = \"Discover\",\n\tOther = \"Other\",\n}\n\n/**\n * Tries to find the credit card issuer by credit card number.\n * Therefore, it is checked whether the typed in number is in a known range.\n * Input MUST be sanitized to only contain numerical digits\n * @param cc the credit card number typed in by the user\n */\nexport function getCardTypeRange(cc: string): CardType {\n\tfor (let cardType of typedValues(CardType)) {\n\t\tif (cardType === CardType.Other) continue\n\t\tfor (let range of CardPrefixRanges[cardType]) {\n\t\t\tconst lowestRange = range[0].padEnd(8, \"0\")\n\t\t\tconst highestRange = range[1].padEnd(8, \"9\")\n\t\t\tconst lowestCC = cc.slice(0, 8).padEnd(8, \"0\")\n\t\t\tconst highestCC = cc.slice(0, 8).padEnd(8, \"9\")\n\t\t\tif (lowestRange <= lowestCC && highestCC <= highestRange) {\n\t\t\t\treturn cardType\n\t\t\t}\n\t\t}\n\t}\n\treturn CardType.Other\n}\n\ntype CardSpec = { cvvLength: number | null; cvvName: string; name: string | null }\n\n// we can't have enums with\nconst CardSpecs = Object.freeze({\n\t[CardType.Visa]: { cvvLength: 3, cvvName: \"CVV\", name: \"Visa\" },\n\t[CardType.Mastercard]: { cvvLength: 3, cvvName: \"CVC\", name: \"Mastercard\" },\n\t[CardType.Maestro]: { cvvLength: 3, cvvName: \"CVV\", name: \"Maestro\" },\n\t[CardType.Amex]: { cvvLength: 4, cvvName: \"CSC\", name: \"American Express\" },\n\t[CardType.Discover]: { cvvLength: 3, cvvName: \"CVD\", name: \"Discover\" },\n\t[CardType.Other]: { cvvLength: null, cvvName: \"CVV\", name: null },\n})\n\n// https://en.wikipedia.org/wiki/Payment_card_number\nconst CardPrefixRanges: Record<CardType, NumberString[][]> = Object.freeze({\n\t[CardType.Visa]: [[\"4\", \"4\"]],\n\t[CardType.Mastercard]: [\n\t\t[\"51\", \"55\"],\n\t\t[\"2221\", \"2720\"],\n\t],\n\t[CardType.Maestro]: [\n\t\t[\"6759\", \"6759\"],\n\t\t[\"676770\", \"676770\"],\n\t\t[\"676774\", \"676774\"],\n\t\t[\"5018\", \"5018\"],\n\t\t[\"5020\", \"5020\"],\n\t\t[\"5038\", \"5038\"],\n\t\t[\"5893\", \"5893\"],\n\t\t[\"6304\", \"6304\"],\n\t\t[\"6759\", \"6759\"],\n\t\t[\"6761\", \"6763\"],\n\t],\n\t[CardType.Amex]: [\n\t\t[\"34\", \"34\"],\n\t\t[\"37\", \"37\"],\n\t],\n\t[CardType.Discover]: [\n\t\t[\"6011\", \"6011\"],\n\t\t[\"644\", \"649\"],\n\t\t[\"65\", \"65\"],\n\t\t[\"622126\", \"622925\"],\n\t],\n\t[CardType.Other]: [[]],\n})\ntype StringInputCorrecter = (value: string, oldValue?: string) => string\n\nconst allDigits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nconst definiteMonthDigits = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nconst secondMonthDigits = [\"0\", \"1\", \"2\"]\nconst separator = \"/\"\nconst niceSeparator = ` ${separator} `\n\n/**\n * completely strip all whitespace from a string\n * @param s the string to clean up\n */\nfunction stripWhitespace(s: string): string {\n\treturn s.replace(/\\s/g, \"\")\n}\n\nfunction stripNonDigits(s: string): string {\n\treturn s.replace(/\\D/g, \"\")\n}\n\n/**\n * true if s contains characters and all of them are digits.\n */\nexport function isDigitString(s: string) {\n\tif (s.length === 0) return false\n\tconst matches = s.match(/\\d/g)\n\treturn matches != null && matches.length === s.length\n}\n\n/**\n * take a function that corrects whitespace on input that does not contain whitespace\n * and return one that does the same on input that contains arbitrary whitespace.\n * @param fn a function that does not deal with whitespace-containing or empty input\n */\nfunction normalizeInput(fn: StringInputCorrecter): StringInputCorrecter {\n\treturn (v: string, ov: string = \"\") => {\n\t\tv = stripWhitespace(v)\n\t\tif (v === \"\") return v\n\t\tov = stripWhitespace(ov)\n\t\treturn fn(v, ov)\n\t}\n}\n\n/*\n * take digits from the start of rest and add them to the end of ret until a non-digit is encountered.\n * discards rest from first non-digit.\n *\n * returns modified rest and ret\n */\nfunction nomDigitsUntilLength(rest: string, ret: string, length: number): { rest: string; ret: string } {\n\twhile (rest.length > 0 && ret.length < length) {\n\t\tconst next = rest[0]\n\t\trest = rest.slice(1)\n\t\tif (allDigits.includes(next)) {\n\t\t\tret += next\n\t\t} else {\n\t\t\trest = \"\"\n\t\t\tbreak\n\t\t}\n\t}\n\treturn { rest, ret }\n}\n\n/**\n * take a date input string and a previous value to render a version that's non-ambiguous\n * and conforms to a valid prefix of the \"MM / YY\" or \"MM / YYYY\" format in the 2000-2099 date range.\n * - should work with pre-emptively adding/removing the backslash\n * - should reformat pasted input\n * - ignores invalid input characters and any leftover input.\n *\n * EXAMPLES: new, old -> output (for more, look at the CreditCardViewModelTest.ts):\n * \"1\" -> \"1\" \t\t\t\tambiguous, we can't complete this\n * \"00\", \"0\" -> \"0\"     \tinvalid input character\n * \"3\", \"\" -> \"03 / \"       this must be march, there are no months starting with 3\n * \"13\", \"1\" -> \"01 / 3\"    13 as a month is invalid, the 1 must have been january and 3 part of the year\n * \"01 /\", \"01 / 2\" -> \"01\" pre-emptively remove backslash if the user backspaces across it\n * \"0126\", \"\" -> \"01 / 26\"  if the input is valid, we still add the separator even when pasting.\n *\n * @param value the new value of the (potentially partial) expiration date\n * @param oldDate the previous value, needed for some special backspace handling.\n */\nexport const inferExpirationDate = normalizeInput(inferNormalizedExpirationDate)\n\n/**\n *\n * @param value non-empty string without whitespace specifying a (potentially partial) date as a sequence of 0 to 6 digits.\n * @param oldDate previous value\n */\nfunction inferNormalizedExpirationDate(value: string, oldDate: string): string {\n\tif (oldDate.startsWith(value) && value.endsWith(separator)) {\n\t\t// probably used backspace. in this case, we need to remove the separator\n\t\t// in a special way to be consistent.\n\t\treturn value.slice(0, -1)\n\t}\n\tif (!allDigits.includes(value[0])) return \"\"\n\tlet rest = value\n\tlet ret = \"\"\n\tif (definiteMonthDigits.includes(rest[0])) {\n\t\t// we already know what month this must be (typed without leading zero)\n\t\tret = \"0\" + rest[0]\n\t\trest = rest.slice(1)\n\t} else {\n\t\t// we don't know yet if we have 01, 02, ..., 09 or 10, 11, 12\n\t\tif (rest[0] === \"0\") {\n\t\t\tret = \"0\"\n\t\t\trest = rest.slice(1)\n\t\t\tif (rest[0] === \"0\") {\n\t\t\t\t// started with \"00\"\n\t\t\t\treturn \"0\"\n\t\t\t} else if (allDigits.includes(rest[0])) {\n\t\t\t\t// started with \"0x\" x being a digit\n\t\t\t\tret = \"0\" + rest[0]\n\t\t\t\trest = rest.slice(1)\n\t\t\t} else {\n\t\t\t\t// started with 0x x not being a non-zero digit.\n\t\t\t\treturn \"0\"\n\t\t\t}\n\t\t} else if (value.length > 1) {\n\t\t\t/* input started with 1 */\n\t\t\trest = rest.slice(1)\n\t\t\tif (secondMonthDigits.includes(rest[0])) {\n\t\t\t\tret = \"1\" + rest[0]\n\t\t\t\trest = rest.slice(1)\n\t\t\t} else if (allDigits.includes(rest[0])) {\n\t\t\t\t// any digit other than 0,1,2 after \"1\" must mean january\n\t\t\t\tret = \"01\"\n\t\t\t\t// not removing a slash or input that's part of the year here.\n\t\t\t} else if (rest[0] === separator) {\n\t\t\t\tret = \"01\"\n\t\t\t\t// not stripping separator here, we do that later anyway\n\t\t\t} else {\n\t\t\t\t// 1x... -> x is invalid in this position\n\t\t\t\treturn \"1\"\n\t\t\t}\n\t\t} else {\n\t\t\t/* input was exactly \"1\" */\n\t\t\treturn \"1\"\n\t\t}\n\t}\n\n\tlet hadSlash = false\n\twhile (rest.startsWith(separator)) {\n\t\thadSlash = true\n\t\trest = rest.slice(1)\n\t}\n\n\tif ((ret.length === 2 && rest.length > 0) || hadSlash || value.length > oldDate.length) {\n\t\t// if there is more input or the user added a slash at the end of the month or the month just got finished,\n\t\t// we need a slash\n\t\tret += separator\n\t}\n\n\t// we have a month + slash + potentially first year digit\n\t// rest contains only the part of the input that is relevant to the year\n\t;({ rest, ret } = nomDigitsUntilLength(rest, ret, \"xx/xx\".length))\n\n\tif (!ret.endsWith(\"/20\")) {\n\t\t// we only consider years in the 2000-2099 range valid, which\n\t\t// means we can assume two-digit year and return.\n\t\treturn ret.replace(separator, niceSeparator)\n\t}\n\n\t;({ ret } = nomDigitsUntilLength(rest, ret, \"xx/xxxx\".length))\n\n\treturn ret.replace(separator, niceSeparator)\n}\n\n/**\n * take a sequence of digits and other characters, strip non-digits and group the rest into space-separated groups.\n * @param value non-empty string without whitespace specifying a (potentially partial) credit card number\n * @param groups most credit card number digits are grouped in groups of 4, but there are exceptions\n */\nfunction groupCreditCardNumber(value: string, groups: number[] = [4, 4, 4, 4, 4]): string {\n\tvalue = stripNonDigits(value)\n\tvalue = value.slice(0, 20)\n\tlet ret = value.slice(0, groups[0])\n\tvalue = value.slice(groups[0])\n\tfor (let i = 1; i < groups.length && value.length > 0; i++) {\n\t\tret += \" \"\n\t\tret += value.slice(0, groups[i])\n\t\tvalue = value.slice(groups[i])\n\t}\n\treturn ret\n}\n\n/*\n * extract a numeric month and year from an expiration date in the form \"M... / Y...\"\n * if the format is invalid (wrong separator, month not 1 - 12, invalid numbers, year not in 2000 - 2099 range) return null.\n * otherwise, return object containing the year and month properties.\n */\nexport function getExpirationMonthAndYear(expirationDate: string): { year: number; month: number } | null {\n\tif (expirationDate.length < \"xx / xx\".length || !expirationDate.includes(\" / \")) {\n\t\treturn null\n\t}\n\tconst [monthString, yearString] = expirationDate.split(\" / \").map((p) => p.trim())\n\tif (!isDigitString(monthString) || !isDigitString(yearString)) {\n\t\treturn null\n\t}\n\tconst monthNumber = Number(monthString)\n\tif (monthNumber < 1 || monthNumber > 12) {\n\t\treturn null\n\t}\n\tconst yearNumber = Number(yearString)\n\tif (yearString.length === 4 && yearString.startsWith(\"20\")) {\n\t\treturn {\n\t\t\tyear: Math.floor(yearNumber) - 2000,\n\t\t\tmonth: Math.floor(monthNumber),\n\t\t}\n\t} else if (yearString.length === 2) {\n\t\treturn {\n\t\t\tyear: Math.floor(yearNumber),\n\t\t\tmonth: Math.floor(monthNumber),\n\t\t}\n\t} else {\n\t\treturn null\n\t}\n}\n\nexport class SimplifiedCreditCardViewModel implements CCViewModel {\n\tprivate _cardHolderName: string = \"\"\n\tprivate _creditCardNumber: string = \"\"\n\tprivate _cvv: string = \"\"\n\tprivate _expirationDate: string = \"\"\n\n\tprivate creditCardType: CardType = CardType.Other\n\n\tconstructor(private readonly lang: LanguageViewModel) {}\n\n\tget expirationDate(): string {\n\t\treturn this._expirationDate\n\t}\n\n\tset expirationDate(value: string) {\n\t\tthis._expirationDate = inferExpirationDate(value, this._expirationDate)\n\t}\n\n\tget cvv(): string {\n\t\treturn this._cvv\n\t}\n\n\tset cvv(value: string) {\n\t\tconst correctedCvv = stripWhitespace(stripNonDigits(value))\n\t\tthis._cvv = correctedCvv.slice(0, 4)\n\t}\n\n\tget creditCardNumber(): string {\n\t\treturn this._creditCardNumber\n\t}\n\n\tset creditCardNumber(value: string) {\n\t\tlet cleanedNumber = stripNonDigits(stripWhitespace(value))\n\t\tthis.creditCardType = getCardTypeRange(cleanedNumber)\n\t\tthis._creditCardNumber =\n\t\t\tthis.creditCardType === CardType.Amex ? groupCreditCardNumber(cleanedNumber, [4, 6, 5, 5]) : groupCreditCardNumber(cleanedNumber)\n\t}\n\n\tget cardHolderName(): string {\n\t\treturn this._cardHolderName\n\t}\n\n\tset cardHolderName(value: string) {\n\t\t// no-op for now.\n\t}\n\n\tvalidateCreditCardPaymentData(): TranslationKey | null {\n\t\tconst cc = this.getCreditCardData()\n\t\tconst invalidNumber = this.validateCreditCardNumber(cc.number)\n\t\tif (invalidNumber) {\n\t\t\treturn invalidNumber\n\t\t}\n\t\tconst invalidCVV = this.validateCVV(cc.cvv)\n\t\tif (invalidCVV) {\n\t\t\treturn invalidCVV\n\t\t}\n\t\tconst invalidExpirationDate = this.getExpirationDateErrorHint()\n\t\tif (invalidExpirationDate) {\n\t\t\treturn invalidExpirationDate\n\t\t}\n\t\treturn null\n\t}\n\n\tvalidateCreditCardNumber(number: string): TranslationKey | null {\n\t\tif (number === \"\") {\n\t\t\treturn \"creditCardNumberFormat_msg\"\n\t\t} else if (!isValidCreditCardNumber(number)) {\n\t\t\treturn \"creditCardNumberInvalid_msg\"\n\t\t}\n\t\treturn null\n\t}\n\n\tvalidateCVV(cvv: string): TranslationKey | null {\n\t\tif (cvv.length < 3 || cvv.length > 4) {\n\t\t\treturn \"creditCardCVVFormat_label\"\n\t\t}\n\t\treturn null\n\t}\n\n\tgetCreditCardNumberHint(): string | null {\n\t\tconst spec = CardSpecs[this.creditCardType]\n\t\tif (this.creditCardType === CardType.Other) {\n\t\t\treturn null\n\t\t}\n\t\treturn spec.name\n\t}\n\n\tgetCreditCardNumberErrorHint(): string | null {\n\t\treturn this.validateCreditCardNumber(this._creditCardNumber) ? this.lang.get(\"creditCardNumberInvalid_msg\") : null\n\t}\n\n\t/**\n\t * return a translation string detailing what's wrong with the\n\t * contents of the expiration date field, if any.\n\t */\n\tgetExpirationDateErrorHint(): TranslationKey | null {\n\t\tconst expiration = getExpirationMonthAndYear(this._expirationDate)\n\t\tif (expiration == null) {\n\t\t\treturn \"creditCardExprationDateInvalid_msg\"\n\t\t}\n\t\tconst today = new Date()\n\t\tconst currentYear = today.getFullYear() - 2000\n\t\tconst currentMonth = today.getMonth() + 1\n\t\tconst { year, month } = expiration\n\t\tif (year > currentYear || (year === currentYear && month >= currentMonth)) {\n\t\t\treturn null\n\t\t}\n\t\treturn \"creditCardExpired_msg\"\n\t}\n\n\tgetCvvHint(): string | null {\n\t\tif (this.creditCardType === CardType.Other) {\n\t\t\treturn null\n\t\t} else {\n\t\t\tconst spec = CardSpecs[this.creditCardType]\n\t\t\treturn this.lang.get(\"creditCardCvvHint_msg\", { \"{currentDigits}\": this.cvv.length, \"{totalDigits}\": spec.cvvLength })\n\t\t}\n\t}\n\n\tgetCvvErrorHint(): string | null {\n\t\tconst spec = CardSpecs[this.creditCardType]\n\t\treturn this.validateCVV(this.cvv) ? this.lang.get(\"creditCardSpecificCVVInvalid_msg\", { \"{securityCode}\": spec.cvvName }) : null\n\t}\n\n\tgetCvvLabel(): string {\n\t\tif (this.creditCardType === CardType.Other) {\n\t\t\treturn this.lang.get(\"creditCardCvvLabelLong_label\", { \"{cvvName}\": CardSpecs[CardType.Other].cvvName })\n\t\t} else {\n\t\t\tconst spec = CardSpecs[this.creditCardType]\n\t\t\treturn this.lang.get(\"creditCardCvvLabelLong_label\", { \"{cvvName}\": spec.cvvName })\n\t\t}\n\t}\n\n\tgetCreditCardData(): CreditCard {\n\t\tconst expiration = getExpirationMonthAndYear(this._expirationDate)\n\t\tlet cc = createCreditCard({\n\t\t\tnumber: stripWhitespace(this._creditCardNumber),\n\t\t\tcardHolderName: this._cardHolderName,\n\t\t\tcvv: this._cvv,\n\t\t\texpirationMonth: expiration ? String(expiration.month) : \"\",\n\t\t\texpirationYear: expiration ? String(expiration.year) : \"\",\n\t\t})\n\t\treturn cc\n\t}\n\n\tsetCreditCardData(data: CreditCard | null): void {\n\t\tif (data) {\n\t\t\tthis.creditCardNumber = data.number\n\t\t\tthis.cvv = data.cvv\n\n\t\t\tif (data.expirationMonth && data.expirationYear) {\n\t\t\t\tthis.expirationDate = data.expirationMonth + \" / \" + data.expirationYear\n\t\t\t}\n\t\t} else {\n\t\t\tthis._creditCardNumber = \"\"\n\t\t\tthis._cvv = \"\"\n\t\t\tthis._expirationDate = \"\"\n\t\t}\n\t}\n}\n"]}