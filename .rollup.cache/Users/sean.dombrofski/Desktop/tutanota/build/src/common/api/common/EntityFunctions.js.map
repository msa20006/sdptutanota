{"version":3,"file":"EntityFunctions.js","sourceRoot":"","sources":["../../../../../src/common/api/common/EntityFunctions.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,sBAAsB,CAAA;AAG3C,OAAO,EAAE,UAAU,IAAI,cAAc,EAAE,MAAM,gCAAgC,CAAA;AAC7E,OAAO,EAAE,UAAU,IAAI,aAAa,EAAE,MAAM,+BAA+B,CAAA;AAC3E,OAAO,EAAE,UAAU,IAAI,kBAAkB,EAAE,MAAM,oCAAoC,CAAA;AACrF,OAAO,EAAE,UAAU,IAAI,iBAAiB,EAAE,MAAM,mCAAmC,CAAA;AACnF,OAAO,EAAE,UAAU,IAAI,oBAAoB,EAAE,MAAM,sCAAsC,CAAA;AACzF,OAAO,EAAE,UAAU,IAAI,gBAAgB,EAAE,MAAM,kCAAkC,CAAA;AACjF,OAAO,EAAE,UAAU,IAAI,iBAAiB,EAAE,MAAM,mCAAmC,CAAA;AACnF,OAAO,EAAE,UAAU,IAAI,eAAe,EAAE,MAAM,iCAAiC,CAAA;AAC/E,OAAO,YAAY,MAAM,8BAA8B,CAAA;AACvD,OAAO,aAAa,MAAM,+BAA+B,CAAA;AACzD,OAAO,iBAAiB,MAAM,mCAAmC,CAAA;AACjE,OAAO,gBAAgB,MAAM,kCAAkC,CAAA;AAC/D,OAAO,mBAAmB,MAAM,qCAAqC,CAAA;AACrE,OAAO,eAAe,MAAM,iCAAiC,CAAA;AAC7D,OAAO,gBAAgB,MAAM,kCAAkC,CAAA;AAC/D,OAAO,cAAc,MAAM,gCAAgC,CAAA;AAe3D;;;;GAIG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC;IACvC,IAAI,EAAE,cAAc;IACpB,GAAG,EAAE,aAAa;IAClB,QAAQ,EAAE,kBAAkB;IAC5B,OAAO,EAAE,iBAAiB;IAC1B,UAAU,EAAE,oBAAoB;IAChC,MAAM,EAAE,gBAAgB;IACxB,OAAO,EAAE,iBAAiB;IAC1B,KAAK,EAAE,eAAe;CACb,CAAC,CAAA;AAEX,MAAM,CAAC,MAAM,UAAU,GAAG;IACzB,IAAI,EAAE,aAAa;IACnB,GAAG,EAAE,YAAY;IACjB,QAAQ,EAAE,iBAAiB;IAC3B,OAAO,EAAE,gBAAgB;IACzB,UAAU,EAAE,mBAAmB;IAC/B,MAAM,EAAE,eAAe;IACvB,OAAO,EAAE,gBAAgB;IACzB,KAAK,EAAE,cAAc;CACZ,CAAA;AAGV;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,oBAAoB,CAAC,OAAqB;IAC/D,aAAa;IACb,MAAM,QAAQ,GAAG,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;IAExC,MAAM,SAAS,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;IACxC,IAAI,SAAS,IAAI,IAAI,EAAE,CAAC;QACvB,MAAM,IAAI,KAAK,CAAC,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAA;IACnE,CAAC;SAAM,CAAC;QACP,OAAO,SAAS,CAAA;IACjB,CAAC;AACF,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,SAAoB;IAC/C,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,OAAO,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,WAAW,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,WAAW,EAAE,CAAC;QACnH,MAAM,IAAI,KAAK,CAAC,sEAAsE,GAAG,SAAS,CAAC,IAAI,CAAC,CAAA;IACzG,CAAC;AACF,CAAC","sourcesContent":["import { Type } from \"./EntityConstants.js\"\nimport { TypeRef } from \"@tutao/tutanota-utils\"\nimport type { TypeModel } from \"./EntityTypes\"\nimport { typeModels as baseTypeModels } from \"../entities/base/TypeModels.js\"\nimport { typeModels as sysTypeModels } from \"../entities/sys/TypeModels.js\"\nimport { typeModels as tutanotaTypeModels } from \"../entities/tutanota/TypeModels.js\"\nimport { typeModels as monitorTypeModels } from \"../entities/monitor/TypeModels.js\"\nimport { typeModels as accountingTypeModels } from \"../entities/accounting/TypeModels.js\"\nimport { typeModels as gossipTypeModels } from \"../entities/gossip/TypeModels.js\"\nimport { typeModels as storageTypeModels } from \"../entities/storage/TypeModels.js\"\nimport { typeModels as usageTypeModels } from \"../entities/usage/TypeModels.js\"\nimport sysModelInfo from \"../entities/sys/ModelInfo.js\"\nimport baseModelInfo from \"../entities/base/ModelInfo.js\"\nimport tutanotaModelInfo from \"../entities/tutanota/ModelInfo.js\"\nimport monitorModelInfo from \"../entities/monitor/ModelInfo.js\"\nimport accountingModelInfo from \"../entities/accounting/ModelInfo.js\"\nimport gossipModelInfo from \"../entities/gossip/ModelInfo.js\"\nimport storageModelInfo from \"../entities/storage/ModelInfo.js\"\nimport usageModelInfo from \"../entities/usage/ModelInfo.js\"\n\nexport const enum HttpMethod {\n\tGET = \"GET\",\n\tPOST = \"POST\",\n\tPUT = \"PUT\",\n\tDELETE = \"DELETE\",\n}\n\nexport const enum MediaType {\n\tJson = \"application/json\",\n\tBinary = \"application/octet-stream\",\n\tText = \"text/plain\",\n}\n\n/**\n * Model maps are needed for static analysis and dead-code elimination.\n * We access most types through the TypeRef but also sometimes we include them completely dynamically (e.g. encryption of aggregates).\n * This means that we need to tell our bundler which ones do exist so that they are included.\n */\nexport const typeModels = Object.freeze({\n\tbase: baseTypeModels,\n\tsys: sysTypeModels,\n\ttutanota: tutanotaTypeModels,\n\tmonitor: monitorTypeModels,\n\taccounting: accountingTypeModels,\n\tgossip: gossipTypeModels,\n\tstorage: storageTypeModels,\n\tusage: usageTypeModels,\n} as const)\n\nexport const modelInfos = {\n\tbase: baseModelInfo,\n\tsys: sysModelInfo,\n\ttutanota: tutanotaModelInfo,\n\tmonitor: monitorModelInfo,\n\taccounting: accountingModelInfo,\n\tgossip: gossipModelInfo,\n\tstorage: storageModelInfo,\n\tusage: usageModelInfo,\n} as const\nexport type ModelInfos = typeof modelInfos\n\n/**\n * Convert a {@link TypeRef} to a {@link TypeModel} that it refers to.\n *\n * This function is async so that we can possibly load typeModels on demand instead of bundling them with the JS files.\n *\n * @param typeRef the typeRef for which we will return the typeModel.\n */\nexport async function resolveTypeReference(typeRef: TypeRef<any>): Promise<TypeModel> {\n\t// @ts-ignore\n\tconst modelMap = typeModels[typeRef.app]\n\n\tconst typeModel = modelMap[typeRef.type]\n\tif (typeModel == null) {\n\t\tthrow new Error(\"Cannot find TypeRef: \" + JSON.stringify(typeRef))\n\t} else {\n\t\treturn typeModel\n\t}\n}\n\nexport function _verifyType(typeModel: TypeModel) {\n\tif (typeModel.type !== Type.Element && typeModel.type !== Type.ListElement && typeModel.type !== Type.BlobElement) {\n\t\tthrow new Error(\"only Element, ListElement and BlobElement types are permitted, was: \" + typeModel.type)\n\t}\n}\n"]}