{"version":3,"file":"ImportExportUtils.js","sourceRoot":"","sources":["../../../../../src/common/calendar/import/ImportExportUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CalendarEvent, CalendarGroupRoot } from \"../../api/entities/tutanota/TypeRefs.js\"\nimport type { AlarmInfoTemplate } from \"../../api/worker/facades/lazy/CalendarFacade.js\"\nimport { assignEventId, CalendarEventValidity, checkEventValidity, getTimeZone } from \"../date/CalendarUtils.js\"\nimport { ParsedCalendarData, ParsedEvent } from \"./CalendarImporter.js\"\nimport { freezeMap, getFromMap, groupBy, insertIntoSortedArray } from \"@tutao/tutanota-utils\"\nimport { generateEventElementId } from \"../../api/common/utils/CommonCalendarUtils.js\"\nimport { createDateWrapper } from \"../../api/entities/sys/TypeRefs.js\"\nimport { parseCalendarEvents, parseICalendar } from \"../../../calendar-app/calendar/export/CalendarParser.js\"\nimport { lang, type TranslationKey } from \"../../misc/LanguageViewModel.js\"\nimport { assertValidURL } from \"@tutao/tutanota-utils/dist/Utils.js\"\n\nexport enum EventImportRejectionReason {\n\tPre1970,\n\tInversed,\n\tInvalidDate,\n\tDuplicate,\n}\n\nexport type EventWrapper = {\n\tevent: CalendarEvent\n\talarms: ReadonlyArray<AlarmInfoTemplate>\n}\n\n/** check if the event should be skipped because it's invalid or already imported. if not, add it to the map. */\nfunction shouldBeSkipped(event: CalendarEvent, instanceIdentifierToEventMap: Map<string, CalendarEvent>): EventImportRejectionReason | null {\n\tif (!event.uid) {\n\t\t// should not happen because calendar parser will generate uids if they do not exist\n\t\tthrow new Error(\"Uid is not set for imported event\")\n\t}\n\n\tswitch (checkEventValidity(event)) {\n\t\tcase CalendarEventValidity.InvalidContainsInvalidDate:\n\t\t\treturn EventImportRejectionReason.InvalidDate\n\t\tcase CalendarEventValidity.InvalidEndBeforeStart:\n\t\t\treturn EventImportRejectionReason.Inversed\n\t\tcase CalendarEventValidity.InvalidPre1970:\n\t\t\treturn EventImportRejectionReason.Pre1970\n\t}\n\tconst instanceIdentifier = makeInstanceIdentifier(event)\n\tif (!instanceIdentifierToEventMap.has(instanceIdentifier)) {\n\t\tinstanceIdentifierToEventMap.set(instanceIdentifier, event)\n\t\treturn null\n\t} else {\n\t\treturn EventImportRejectionReason.Duplicate\n\t}\n}\n\n/** we try to enforce that each calendar only contains each uid once, but we need to take into consideration\n * that altered instances have the same uid as their progenitor.*/\nfunction makeInstanceIdentifier(event: CalendarEvent): string {\n\treturn `${event.uid}-${event.recurrenceId?.getTime() ?? \"progenitor\"}`\n}\n\nexport type RejectedEvents = Map<EventImportRejectionReason, Array<CalendarEvent>>\n\n/** sort the parsed events into the ones we want to create and the ones we want to reject (stating a rejection reason)\n * will assign event id according to the calendarGroupRoot and the long/short event status */\nexport function sortOutParsedEvents(\n\tparsedEvents: ParsedEvent[],\n\texistingEvents: Array<CalendarEvent>,\n\tcalendarGroupRoot: CalendarGroupRoot,\n\tzone: string,\n): {\n\trejectedEvents: RejectedEvents\n\teventsForCreation: Array<EventWrapper>\n} {\n\tconst instanceIdentifierToEventMap = new Map()\n\tfor (const existingEvent of existingEvents) {\n\t\tif (existingEvent.uid == null) continue\n\t\tinstanceIdentifierToEventMap.set(makeInstanceIdentifier(existingEvent), existingEvent)\n\t}\n\n\tconst rejectedEvents: RejectedEvents = new Map()\n\tconst eventsForCreation: Array<{ event: CalendarEvent; alarms: Array<AlarmInfoTemplate> }> = []\n\tfor (const [_, flatParsedEvents] of groupBy(parsedEvents, (e) => e.event.uid)) {\n\t\tlet progenitor: { event: CalendarEvent; alarms: Array<AlarmInfoTemplate> } | null = null\n\t\tlet alteredInstances: Array<{ event: CalendarEvent; alarms: Array<AlarmInfoTemplate> }> = []\n\n\t\tfor (const { event, alarms } of flatParsedEvents) {\n\t\t\tif (flatParsedEvents.length > 1)\n\t\t\t\tconsole.warn(\"[ImportExportUtils] Found events with same uid: flatParsedEvents with more than one entry\", { flatParsedEvents })\n\t\t\tconst rejectionReason = shouldBeSkipped(event, instanceIdentifierToEventMap)\n\t\t\tif (rejectionReason != null) {\n\t\t\t\tgetFromMap(rejectedEvents, rejectionReason, () => []).push(event)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// hashedUid will be set later in calendarFacade to avoid importing the hash function here\n\t\t\tconst repeatRule = event.repeatRule\n\t\t\tevent._ownerGroup = calendarGroupRoot._id\n\n\t\t\tif (repeatRule != null && repeatRule.timeZone === \"\") {\n\t\t\t\trepeatRule.timeZone = getTimeZone()\n\t\t\t}\n\n\t\t\tfor (let alarmInfo of alarms) {\n\t\t\t\talarmInfo.alarmIdentifier = generateEventElementId(Date.now())\n\t\t\t}\n\n\t\t\tassignEventId(event, zone, calendarGroupRoot)\n\t\t\tif (event.recurrenceId == null) {\n\t\t\t\t// the progenitor must be null here since we would have\n\t\t\t\t// rejected the second uid-progenitor event in shouldBeSkipped.\n\t\t\t\tprogenitor = { event, alarms }\n\t\t\t} else {\n\t\t\t\tif (progenitor?.event.repeatRule != null) {\n\t\t\t\t\tinsertIntoSortedArray(\n\t\t\t\t\t\tcreateDateWrapper({ date: event.recurrenceId }),\n\t\t\t\t\t\tprogenitor.event.repeatRule.excludedDates,\n\t\t\t\t\t\t(left, right) => left.date.getTime() - right.date.getTime(),\n\t\t\t\t\t\t() => true,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\talteredInstances.push({ event, alarms })\n\t\t\t}\n\t\t}\n\t\tif (progenitor != null) eventsForCreation.push(progenitor)\n\t\teventsForCreation.push(...alteredInstances)\n\t}\n\n\treturn { rejectedEvents, eventsForCreation }\n}\n\n/** importer internals exported for testing */\nexport function parseCalendarStringData(value: string, zone: string): ParsedCalendarData {\n\tconst tree = parseICalendar(value)\n\treturn parseCalendarEvents(tree, zone)\n}\n\nexport function isIcal(iCalStr: string): boolean {\n\treturn iCalStr.trimStart().split(/\\r?\\n/, 1)[0] === \"BEGIN:VCALENDAR\"\n}\n\nexport function getExternalCalendarName(iCalStr: string): string {\n\tlet calName = iCalStr.match(/X-WR-CALNAME:(.*)\\r?\\n/)\n\tconst name = calName ? calName[1] : iCalStr.match(/PRODID:-\\/\\/(.*)\\/\\//)?.[1]!\n\treturn name ?? lang.get(\"noTitle_label\")\n}\n\nexport const enum SyncStatus {\n\tFailed = \"Failed\",\n\tSuccess = \"Success\",\n}\n\nexport function checkURLString(url: string): TranslationKey | URL {\n\tconst assertResult = assertValidURL(url)\n\tif (!assertResult) return \"invalidURL_msg\"\n\tif (!hasValidProtocol(assertResult, [\"https:\"])) return \"invalidURLProtocol_msg\"\n\treturn assertResult\n}\n\nexport function hasValidProtocol(url: URL, validProtocols: string[]) {\n\treturn validProtocols.includes(url.protocol)\n}\n\nexport const enum ByRule {\n\tBYMINUTE,\n\tBYHOUR,\n\tBYDAY,\n\tBYMONTHDAY,\n\tBYYEARDAY,\n\tBYWEEKNO,\n\tBYMONTH,\n\tBYSETPOS,\n\tWKST,\n}\n\nexport const BYRULE_MAP = freezeMap(\n\tnew Map([\n\t\t[\"BYMINUTE\", ByRule.BYMINUTE],\n\t\t[\"BYHOUR\", ByRule.BYHOUR],\n\t\t[\"BYDAY\", ByRule.BYDAY],\n\t\t[\"BYMONTHDAY\", ByRule.BYMONTHDAY],\n\t\t[\"BYYEARDAY\", ByRule.BYYEARDAY],\n\t\t[\"BYWEEKNO\", ByRule.BYWEEKNO],\n\t\t[\"BYMONTH\", ByRule.BYMONTH],\n\t\t[\"BYSETPOS\", ByRule.BYSETPOS],\n\t\t[\"WKST\", ByRule.WKST],\n\t]),\n)\n"]}