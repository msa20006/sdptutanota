{"version":3,"file":"ProtocolProxy.js","sourceRoot":"","sources":["../../../../../src/common/desktop/net/ProtocolProxy.ts"],"names":[],"mappings":"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","sourcesContent":["import path from \"node:path\"\nimport fs from \"node:fs\"\nimport { log } from \"../DesktopLog.js\"\nimport { Session } from \"electron\"\nimport { errorToObj } from \"../../api/common/threading/MessageDispatcher.js\"\nimport { lazyMemoized } from \"@tutao/tutanota-utils\"\nimport { getMimeTypeForFile } from \"../files/DesktopFileFacade.js\"\nimport { convertHeaders, customFetch, FetchImpl, toGlobalResponse, UndiciRequestInit } from \"./NetAgent\"\n\nconst TAG = \"[ProtocolProxy]\"\n\nexport const ASSET_PROTOCOL = \"asset\"\n\n/**\n * intercept & proxy https, http and asset requests on a session\n * @param session the webContents session we want to intercept requests on\n * @param assetDir the base directory of allowable scripts, images and other resources that the app may load.\n */\nexport function handleProtocols(session: Session, assetDir: string): void {\n\tdoHandleProtocols(session, assetDir, customFetch, path, fs)\n}\n\n/**\n *  exported for testing\n */\nexport function doHandleProtocols(session: Session, assetDir: string, fetchImpl: FetchImpl, pathModule: typeof path, fsModule: typeof fs): void {\n\tif (!interceptProtocol(\"http\", session, fetchImpl)) throw new Error(\"could not intercept http protocol\")\n\tif (!interceptProtocol(\"https\", session, fetchImpl)) throw new Error(\"could not intercept https protocol\")\n\tif (!handleAssetProtocol(session, assetDir, pathModule, fsModule)) throw new Error(\"could not register asset protocol\")\n}\n\n/**\n * intercept and proxy all requests for a protocol coming from a session. OPTIONS requests will be\n * answered immediately without actually calling the server.\n * @param session the session to intercept requests for\n * @param protocol http and https use different modules, so we need to intercept them separately.\n * @param fetchImpl an implementation of the fetch API (Request) => Promise<Response>\n */\nfunction interceptProtocol(protocol: string, session: Session, fetchImpl: FetchImpl): boolean {\n\tif (session.protocol.isProtocolHandled(protocol)) return true\n\tsession.protocol.handle(protocol, async (request: GlobalRequest): Promise<Response> => {\n\t\tconst { method, url, headers: globalHeaders } = request\n\t\tconst startTime: number = Date.now()\n\t\tif (!url.startsWith(protocol)) {\n\t\t\treturn new Response(null, { status: 400 })\n\t\t} else if (method == \"OPTIONS\") {\n\t\t\t// this actually doesn't seem to be called when the actual request is intercepted,\n\t\t\t// but we'll handle it anyway.\n\t\t\tlog.debug(TAG, \"intercepted options request, returning canned response\")\n\t\t\treturn optionsResponse()\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tconst options: UndiciRequestInit = { method, keepalive: true }\n\t\t\t\tconst body = await request.arrayBuffer()\n\t\t\t\tif (body.byteLength > 0) {\n\t\t\t\t\tglobalHeaders.set(\"Content-Length\", String(body.byteLength))\n\t\t\t\t\toptions.body = body\n\t\t\t\t\toptions.duplex = \"half\"\n\t\t\t\t}\n\t\t\t\toptions.headers = convertHeaders(globalHeaders)\n\t\t\t\tconst response = await fetchImpl(url, options)\n\t\t\t\treturn toGlobalResponse(response)\n\t\t\t} catch (e) {\n\t\t\t\tconst parsedUrl = new URL(url)\n\t\t\t\tconst noQueryUrl = `${parsedUrl.protocol}//${parsedUrl.host}${parsedUrl.pathname}`\n\t\t\t\tlog.debug(TAG, `error for ${method} ${noQueryUrl}:`)\n\t\t\t\tlog.debug(TAG, e)\n\t\t\t\tlog.debug(TAG, JSON.stringify(errorToObj(e)))\n\t\t\t\tlog.debug(TAG, `failed after ${Date.now() - startTime}ms`)\n\t\t\t\treturn Response.error()\n\t\t\t}\n\t\t}\n\t})\n\treturn session.protocol.isProtocolHandled(protocol)\n}\n\n/**\n * assign a custom handler the asset protocol scheme on the session if it has not been done yet.\n * the handler will handle all relative requests for resources and ensures that only\n */\nfunction handleAssetProtocol(session: Session, assetDir: string, pathModule: typeof path, fsModule: typeof fs): boolean {\n\tif (session.protocol.isProtocolHandled(ASSET_PROTOCOL)) return true\n\tsession.protocol.handle(ASSET_PROTOCOL, async (request: Request): Promise<Response> => {\n\t\tconst fail = (msg: string) => {\n\t\t\tlog.debug(TAG, msg)\n\t\t\treturn new Response(null, { status: 404 })\n\t\t}\n\t\t// in node, new URL will normalize the path and remove /.. and /. elements.\n\t\t// this doesn't work in browsers, so the startsWith check below should stay just to be sure\n\t\tconst url = new URL(request.url)\n\t\tif (url.protocol.slice(0, -1) !== ASSET_PROTOCOL) {\n\t\t\treturn fail(`passed non-asset url to asset handler: ${url}`)\n\t\t} else if (url.hostname !== \"app\" || !url.pathname.startsWith(\"/\")) {\n\t\t\treturn fail(`Invalid asset:// URL: ${request.url}`)\n\t\t} else {\n\t\t\tconst filePath = pathModule.resolve(assetDir, url.pathname.substring(1))\n\t\t\tif (!filePath.startsWith(assetDir)) {\n\t\t\t\treturn fail(`Invalid asset URL ${request.url} w/ pathname ${url.pathname} got resolved to ${filePath})`)\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\treturn fileFetch(filePath, fsModule)\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn fail(`failed to read asset at ${request.url}: ${e.message}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\treturn session.protocol.isProtocolHandled(ASSET_PROTOCOL)\n}\n\nconst optionsResponse = lazyMemoized<Response>(() => {\n\tconst headers = new Headers()\n\theaders.set(\"Access-Control-Allow-Origin\", \"*\")\n\theaders.set(\"Access-Control-Allow-Methods\", \"POST, GET, PUT, DELETE\")\n\theaders.set(\"Access-Control-Allow-Headers\", \"*\")\n\treturn new Response(null, {\n\t\tstatus: 200,\n\t\theaders,\n\t})\n})\n\n/**\n * fetch for file:// is not implemented in node 20, so we're getting it by hand.\n * you can test support with (note that electron's node might be a different version)\n *   $ node -e \"fetch('file://egal.txt')\"\n */\nexport async function fileFetch(filePath: string, fsModule: typeof fs): Promise<Response> {\n\tconst content = await fsModule.promises.readFile(filePath)\n\tconst headers = new Headers({\n\t\t\"Content-Length\": String(content.byteLength),\n\t\t\"Content-Type\": await getMimeTypeForFile(filePath),\n\t})\n\treturn new Response(content, { status: 200, headers })\n}\n"]}