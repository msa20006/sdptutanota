{"version":3,"file":"DateParser.js","sourceRoot":"","sources":["../../../../src/common/misc/DateParser.ts"],"names":[],"mappings":"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","sourcesContent":["import { DateTime } from \"luxon\"\nimport type { Birthday } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { createBirthday } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\n\n/**\n * parses the following formats:\n *\n * zh-hant    2017/6/23\n * hu         2017. 06. 23.\n * lt-lt      2017-06-23\n *\n * en        6/23/2017\n * fil-ph    6/23/2017\n * no        6/23/2017\n\n * sq        23.6.2017\n * hr        23. 06. 2017.\n * nl        23-6-2017\n * de        23.6.2017\n * el        23/6/2017\n * fr        23/06/2017\n * it        23/6/2017\n * pl        23.06.2017\n * pt-pt     23/06/2017\n * pt-br     23/06/2017\n * ro        23.06.2017\n * ru        23.06.2017\n * es        23/6/2017\n * tr        23.06.2017\n * fi        23.6.2017\n * mk        23.6.2017\n * sr        23.6.2017.\n * cs-cz     23. 6. 2017\n * da-dk     23/6/2017\n * et-ee     23.6.2017\n * id        23/6/2017\n * bg-bg     23.06.2017 Ð³.\n\n * @param dateString\n * @returns The timestamp from the given date string\n */\nconst referenceDate = new Date(2017, 5, 23)\n\nexport function parseDate(dateString: string, referenceDateRenderer: (refdate: Date) => string): Date {\n\tconst referenceParts = _cleanupAndSplit(referenceDateRenderer(referenceDate))\n\n\t// for finding day month and year position of locale date format  in cleanAndSplit array\n\tconst dayPos = referenceParts.findIndex((e) => e === 23)\n\tconst monthPos = referenceParts.findIndex((e) => e === 6)\n\tconst yearPos = referenceParts.findIndex((e) => e === 2017)\n\n\tconst parts = _cleanupAndSplit(dateString)\n\n\tlet day, month, year\n\n\tif (parts.length === 3) {\n\t\t// default dd-mm-yyyy or dd/mm/yyyy or dd.mm.yyyy\n\t\tday = parts[dayPos]\n\t\tmonth = parts[monthPos]\n\t\tyear = parts[yearPos]\n\t} else if (parts.length === 2) {\n\t\t// if only two numbers are provided then we interpret that as a day and a month\n\t\t// year pos *should* only ever be 0 or 2 (at the front or the back)\n\t\tif (yearPos === 0) {\n\t\t\tday = parts[dayPos - 1]\n\t\t\tmonth = parts[monthPos - 1]\n\t\t} else {\n\t\t\t// yearPos === 2\n\t\t\tday = parts[dayPos]\n\t\t\tmonth = parts[monthPos]\n\t\t}\n\n\t\tyear = new Date().getFullYear()\n\t} else {\n\t\t// invalid parts length\n\t\tthrow new ProgrammingError(`could not parse dateString '${dateString}' with reference date ${referenceParts}`)\n\t}\n\n\t// if 1 or 2 digit year, then make it be in the 2000\n\tif (year < 1000) {\n\t\tyear += 2000\n\t}\n\n\tif (month < 1 || month > 12) {\n\t\tthrow new Error(`Invalid value ${month} for month in ${dateString}`)\n\t}\n\n\t// maybe do better day clamping based on the month\n\tif (day < 1 || day > _getNumDaysInMonth(month, year)) {\n\t\tthrow new Error(`Invalid value ${day} for day in ${dateString}`)\n\t}\n\n\tconst date = new Date(year, month - 1, day)\n\n\tif (isNaN(date.getTime())) {\n\t\tthrow new Error(`Couldn't parse date string ${dateString}`)\n\t}\n\n\treturn date\n}\n\n/**\n * Get the number of days in a month in a given year\n * @param month as a number between 1 and 12\n * @param year\n * @return the number of days in the month\n * @private\n */\nexport function _getNumDaysInMonth(month: number, year: number): number {\n\tconst { daysInMonth } = DateTime.fromObject({\n\t\tmonth,\n\t\tyear,\n\t})\n\n\tif (!daysInMonth) {\n\t\tthrow new ProgrammingError(`could not get daysInMonth for month-year ${month}-${year}`)\n\t}\n\n\treturn daysInMonth\n}\n\n/**\n * Parses a birthday string containing either day and month or day and month and year. The year may be 4 or 2 digits. If it is 2 digits and after the current year, 1900 + x is used, 2000 + x otherwise.\n * @return A birthday object containing the data form the given text or null if the text could not be parsed.\n */\nexport function parseBirthday(text: string, referenceDateRenderer: (refdate: Date) => string): Birthday | null {\n\ttry {\n\t\tconst referenceParts = _cleanupAndSplit(referenceDateRenderer(referenceDate))\n\n\t\t//for finding day month and year position of locale date format  in cleanAndSplit array\n\t\tlet dayPos = referenceParts.findIndex((e) => e === 23)\n\t\tlet monthPos = referenceParts.findIndex((e) => e === 6)\n\t\tlet yearPos = referenceParts.findIndex((e) => e === 2017)\n\n\t\tlet birthdayValues = _cleanupAndSplit(text)\n\n\t\tlet day, month, year\n\n\t\tif (String(birthdayValues[dayPos]).length < 3 && String(birthdayValues[monthPos]).length < 3) {\n\t\t\tif (birthdayValues[dayPos] < 32) {\n\t\t\t\tday = String(birthdayValues[dayPos])\n\t\t\t} else {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\tif (birthdayValues[monthPos] < 13) {\n\t\t\t\tmonth = String(birthdayValues[monthPos])\n\t\t\t} else {\n\t\t\t\treturn null\n\t\t\t}\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\n\t\tif (birthdayValues[yearPos]) {\n\t\t\tif (String(birthdayValues[yearPos]).length === 4) {\n\t\t\t\tyear = String(birthdayValues[yearPos])\n\t\t\t} else if (String(birthdayValues[yearPos]).length === 2) {\n\t\t\t\tif (birthdayValues[yearPos] > Number(String(new Date().getFullYear()).substring(2))) {\n\t\t\t\t\tyear = \"19\" + String(birthdayValues[yearPos])\n\t\t\t\t} else {\n\t\t\t\t\tyear = \"20\" + String(birthdayValues[yearPos])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null\n\t\t\t}\n\t\t} else {\n\t\t\tyear = null\n\t\t}\n\t\treturn createBirthday({ day, month, year })\n\t} catch (e) {\n\t\treturn null\n\t}\n}\n\nexport function _cleanupAndSplit(dateString: string): number[] {\n\t// Clean up any characters that can't be dealt with\n\tdateString = dateString.replace(/[^ 0-9./-]/g, \"\")\n\treturn dateString\n\t\t.split(/[./-]/g)\n\t\t.slice(0, 3) // keep at most three date parts even if the string contains more than two separators (e.g., extra '.' at the end)\n\t\t.map((part) => parseInt(part))\n}\n"]}