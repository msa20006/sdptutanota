{"version":3,"file":"AsymmetricCryptoFacade.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/crypto/AsymmetricCryptoFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { assertWorkerOrNode } from \"../../common/Env\"\nimport {\n\tAesKey,\n\tAsymmetricKeyPair,\n\tAsymmetricPublicKey,\n\tbitArrayToUint8Array,\n\tEccKeyPair,\n\tEccPublicKey,\n\thexToRsaPublicKey,\n\tisPqKeyPairs,\n\tisPqPublicKey,\n\tisRsaEccKeyPair,\n\tisRsaOrRsaEccKeyPair,\n\tisRsaPublicKey,\n\tKeyPairType,\n\tPQPublicKeys,\n\tRsaPrivateKey,\n\tuint8ArrayToBitArray,\n} from \"@tutao/tutanota-crypto\"\nimport type { RsaImplementation } from \"./RsaImplementation\"\nimport { PQFacade } from \"../facades/PQFacade.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { asCryptoProtoocolVersion, CryptoProtocolVersion, EncryptionAuthStatus } from \"../../common/TutanotaConstants.js\"\nimport { arrayEquals, assertNotNull, uint8ArrayToHex, Versioned } from \"@tutao/tutanota-utils\"\nimport { KeyLoaderFacade, parseKeyVersion } from \"../facades/KeyLoaderFacade.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { createPublicKeyPutIn, PubEncKeyData } from \"../../entities/sys/TypeRefs.js\"\nimport { CryptoWrapper } from \"./CryptoWrapper.js\"\nimport { PublicKeyService } from \"../../entities/sys/Services.js\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest.js\"\nimport { PublicKeyIdentifier, PublicKeyProvider, PublicKeys } from \"../facades/PublicKeyProvider.js\"\nimport { KeyVersion } from \"@tutao/tutanota-utils/dist/Utils.js\"\n\nassertWorkerOrNode()\n\nexport type DecapsulatedAesKey = {\n\tdecryptedAesKey: AesKey\n\tsenderIdentityPubKey: EccPublicKey | null // for authentication: null for rsa only\n}\n\nexport type PubEncSymKey = {\n\tpubEncSymKeyBytes: Uint8Array\n\tcryptoProtocolVersion: CryptoProtocolVersion\n\tsenderKeyVersion: KeyVersion | null\n\trecipientKeyVersion: KeyVersion\n}\n\n/**\n * This class is responsible for asymmetric encryption and decryption.\n * It tries to hide the complexity behind handling different asymmetric protocol versions such as RSA and TutaCrypt.\n */\nexport class AsymmetricCryptoFacade {\n\tconstructor(\n\t\tprivate readonly rsa: RsaImplementation,\n\t\tprivate readonly pqFacade: PQFacade,\n\t\tprivate readonly keyLoaderFacade: KeyLoaderFacade,\n\t\tprivate readonly cryptoWrapper: CryptoWrapper,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly publicKeyProvider: PublicKeyProvider,\n\t) {}\n\n\t/**\n\t * Verifies whether the key that the public key service returns is the same as the one used for encryption.\n\t * When we have key verification we should stop verifying against the PublicKeyService but against the verified key.\n\t *\n\t * @param identifier the identifier to load the public key to verify that it matches the one used in the protocol run.\n\t * @param senderIdentityPubKey the senderIdentityPubKey that was used to encrypt/authenticate the data.\n\t * @param senderKeyVersion the version of the senderIdentityPubKey.\n\t */\n\tasync authenticateSender(identifier: PublicKeyIdentifier, senderIdentityPubKey: Uint8Array, senderKeyVersion: KeyVersion): Promise<EncryptionAuthStatus> {\n\t\tconst publicKeys = await this.publicKeyProvider.loadVersionedPubKey(identifier, senderKeyVersion)\n\t\treturn publicKeys.pubEccKey != null && arrayEquals(publicKeys.pubEccKey, senderIdentityPubKey)\n\t\t\t? EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED\n\t\t\t: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED\n\t}\n\n\t/**\n\t * Decrypts the pubEncSymKey with the recipientKeyPair and authenticates it if the protocol supports authentication.\n\t * If the protocol does not support authentication this method will only decrypt.\n\t * @param recipientKeyPair the recipientKeyPair. Must match the cryptoProtocolVersion and must be of the required recipientKeyVersion.\n\t * @param pubEncKeyData the encrypted symKey with the metadata (versions, group identifier etc.) for decryption and authentication.\n\t * @param senderIdentifier the identifier for the sender's key group\n\t * @throws CryptoError in case the authentication fails.\n\t */\n\tasync decryptSymKeyWithKeyPairAndAuthenticate(\n\t\trecipientKeyPair: AsymmetricKeyPair,\n\t\tpubEncKeyData: PubEncKeyData,\n\t\tsenderIdentifier: PublicKeyIdentifier,\n\t): Promise<DecapsulatedAesKey> {\n\t\tconst cryptoProtocolVersion = asCryptoProtoocolVersion(pubEncKeyData.protocolVersion)\n\t\tconst decapsulatedAesKey = await this.decryptSymKeyWithKeyPair(recipientKeyPair, cryptoProtocolVersion, pubEncKeyData.pubEncSymKey)\n\t\tif (cryptoProtocolVersion === CryptoProtocolVersion.TUTA_CRYPT) {\n\t\t\tconst encryptionAuthStatus = await this.authenticateSender(\n\t\t\t\tsenderIdentifier,\n\t\t\t\tassertNotNull(decapsulatedAesKey.senderIdentityPubKey),\n\t\t\t\tparseKeyVersion(assertNotNull(pubEncKeyData.senderKeyVersion)),\n\t\t\t)\n\t\t\tif (encryptionAuthStatus !== EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED) {\n\t\t\t\tthrow new CryptoError(\"the provided public key could not be authenticated\")\n\t\t\t}\n\t\t}\n\t\treturn decapsulatedAesKey\n\t}\n\n\t/**\n\t * Decrypts the pubEncSymKey with the recipientKeyPair.\n\t * @param pubEncSymKey the asymmetrically encrypted session key\n\t * @param cryptoProtocolVersion asymmetric protocol to decrypt pubEncSymKey (RSA or TutaCrypt)\n\t * @param recipientKeyPair the recipientKeyPair. Must match the cryptoProtocolVersion.\n\t */\n\tasync decryptSymKeyWithKeyPair(\n\t\trecipientKeyPair: AsymmetricKeyPair,\n\t\tcryptoProtocolVersion: CryptoProtocolVersion,\n\t\tpubEncSymKey: Uint8Array,\n\t): Promise<DecapsulatedAesKey> {\n\t\tswitch (cryptoProtocolVersion) {\n\t\t\tcase CryptoProtocolVersion.RSA: {\n\t\t\t\tif (!isRsaOrRsaEccKeyPair(recipientKeyPair)) {\n\t\t\t\t\tthrow new CryptoError(\"wrong key type. expected rsa. got \" + recipientKeyPair.keyPairType)\n\t\t\t\t}\n\t\t\t\tconst privateKey: RsaPrivateKey = recipientKeyPair.privateKey\n\t\t\t\tconst decryptedSymKey = await this.rsa.decrypt(privateKey, pubEncSymKey)\n\t\t\t\treturn {\n\t\t\t\t\tdecryptedAesKey: uint8ArrayToBitArray(decryptedSymKey),\n\t\t\t\t\tsenderIdentityPubKey: null,\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CryptoProtocolVersion.TUTA_CRYPT: {\n\t\t\t\tif (!isPqKeyPairs(recipientKeyPair)) {\n\t\t\t\t\tthrow new CryptoError(\"wrong key type. expected TutaCrypt. got \" + recipientKeyPair.keyPairType)\n\t\t\t\t}\n\t\t\t\tconst { decryptedSymKeyBytes, senderIdentityPubKey } = await this.pqFacade.decapsulateEncoded(pubEncSymKey, recipientKeyPair)\n\t\t\t\treturn {\n\t\t\t\t\tdecryptedAesKey: uint8ArrayToBitArray(decryptedSymKeyBytes),\n\t\t\t\t\tsenderIdentityPubKey,\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new CryptoError(\"invalid cryptoProtocolVersion: \" + cryptoProtocolVersion)\n\t\t}\n\t}\n\n\t/**\n\t * Loads the recipient key pair in the required version and decrypts the pubEncSymKey with it.\n\t */\n\tasync loadKeyPairAndDecryptSymKey(\n\t\trecipientKeyPairGroupId: Id,\n\t\trecipientKeyVersion: KeyVersion,\n\t\tcryptoProtocolVersion: CryptoProtocolVersion,\n\t\tpubEncSymKey: Uint8Array,\n\t): Promise<DecapsulatedAesKey> {\n\t\tconst keyPair: AsymmetricKeyPair = await this.keyLoaderFacade.loadKeypair(recipientKeyPairGroupId, recipientKeyVersion)\n\t\treturn await this.decryptSymKeyWithKeyPair(keyPair, cryptoProtocolVersion, pubEncSymKey)\n\t}\n\n\t/**\n\t * Encrypts the symKey asymmetrically with the provided public keys.\n\t * @param symKey the symmetric key  to be encrypted\n\t * @param recipientPublicKeys the public key(s) of the recipient in the current version\n\t * @param senderGroupId the group id of the sender. will only be used in case we also need the sender's key pair, e.g. with TutaCrypt.\n\t */\n\tasync asymEncryptSymKey(symKey: AesKey, recipientPublicKeys: Versioned<PublicKeys>, senderGroupId: Id): Promise<PubEncSymKey> {\n\t\tconst recipientPublicKey = this.extractRecipientPublicKey(recipientPublicKeys.object)\n\t\tconst keyPairType = recipientPublicKey.keyPairType\n\n\t\tif (isPqPublicKey(recipientPublicKey)) {\n\t\t\tconst senderKeyPair = await this.keyLoaderFacade.loadCurrentKeyPair(senderGroupId)\n\t\t\tconst senderEccKeyPair = await this.getOrMakeSenderIdentityKeyPair(senderKeyPair.object, senderGroupId)\n\t\t\treturn this.tutaCryptEncryptSymKeyImpl({ object: recipientPublicKey, version: recipientPublicKeys.version }, symKey, {\n\t\t\t\tobject: senderEccKeyPair,\n\t\t\t\tversion: senderKeyPair.version,\n\t\t\t})\n\t\t} else if (isRsaPublicKey(recipientPublicKey)) {\n\t\t\tconst pubEncSymKeyBytes = await this.rsa.encrypt(recipientPublicKey, bitArrayToUint8Array(symKey))\n\t\t\treturn {\n\t\t\t\tpubEncSymKeyBytes,\n\t\t\t\tcryptoProtocolVersion: CryptoProtocolVersion.RSA,\n\t\t\t\tsenderKeyVersion: null,\n\t\t\t\trecipientKeyVersion: recipientPublicKeys.version,\n\t\t\t}\n\t\t}\n\t\tthrow new CryptoError(\"unknown public key type: \" + keyPairType)\n\t}\n\n\t/**\n\t * Encrypts the symKey asymmetrically with the provided public keys using the TutaCrypt protocol.\n\t * @param symKey the key to be encrypted\n\t * @param recipientPublicKeys MUST be a pq key pair\n\t * @param senderEccKeyPair the sender's key pair (needed for authentication)\n\t * @throws ProgrammingError if the recipientPublicKeys are not suitable for TutaCrypt\n\t */\n\tasync tutaCryptEncryptSymKey(symKey: AesKey, recipientPublicKeys: Versioned<PublicKeys>, senderEccKeyPair: Versioned<EccKeyPair>): Promise<PubEncSymKey> {\n\t\tconst recipientPublicKey = this.extractRecipientPublicKey(recipientPublicKeys.object)\n\t\tif (!isPqPublicKey(recipientPublicKey)) {\n\t\t\tthrow new ProgrammingError(\"the recipient does not have pq key pairs\")\n\t\t}\n\t\treturn this.tutaCryptEncryptSymKeyImpl(\n\t\t\t{\n\t\t\t\tobject: recipientPublicKey,\n\t\t\t\tversion: recipientPublicKeys.version,\n\t\t\t},\n\t\t\tsymKey,\n\t\t\tsenderEccKeyPair,\n\t\t)\n\t}\n\n\tprivate async tutaCryptEncryptSymKeyImpl(\n\t\trecipientPublicKey: Versioned<PQPublicKeys>,\n\t\tsymKey: AesKey,\n\t\tsenderEccKeyPair: Versioned<EccKeyPair>,\n\t): Promise<PubEncSymKey> {\n\t\tconst ephemeralKeyPair = this.cryptoWrapper.generateEccKeyPair()\n\t\tconst pubEncSymKeyBytes = await this.pqFacade.encapsulateAndEncode(\n\t\t\tsenderEccKeyPair.object,\n\t\t\tephemeralKeyPair,\n\t\t\trecipientPublicKey.object,\n\t\t\tbitArrayToUint8Array(symKey),\n\t\t)\n\t\tconst senderKeyVersion = senderEccKeyPair.version\n\t\treturn { pubEncSymKeyBytes, cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT, senderKeyVersion, recipientKeyVersion: recipientPublicKey.version }\n\t}\n\n\tprivate extractRecipientPublicKey(publicKeys: PublicKeys): AsymmetricPublicKey {\n\t\tif (publicKeys.pubRsaKey) {\n\t\t\t// we ignore ecc keys as this is only used for the recipient keys\n\t\t\treturn hexToRsaPublicKey(uint8ArrayToHex(publicKeys.pubRsaKey))\n\t\t} else if (publicKeys.pubKyberKey && publicKeys.pubEccKey) {\n\t\t\tconst eccPublicKey = publicKeys.pubEccKey\n\t\t\tconst kyberPublicKey = this.cryptoWrapper.bytesToKyberPublicKey(publicKeys.pubKyberKey)\n\t\t\treturn {\n\t\t\t\tkeyPairType: KeyPairType.TUTA_CRYPT,\n\t\t\t\teccPublicKey,\n\t\t\t\tkyberPublicKey,\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Inconsistent Keypair\")\n\t\t}\n\t}\n\n\t/**\n\t * Returns the SenderIdentityKeyPair that is either already on the KeyPair that is being passed in,\n\t * or creates a new one and writes it to the respective Group.\n\t * @param senderKeyPair\n\t * @param keyGroupId Id for the Group that Public Key Service might write a new IdentityKeyPair for.\n\t * \t\t\t\t\t\tThis is necessary as a User might send an E-Mail from a shared mailbox,\n\t * \t\t\t\t\t\tfor which the KeyPair should be created.\n\t */\n\tprivate async getOrMakeSenderIdentityKeyPair(senderKeyPair: AsymmetricKeyPair, keyGroupId: Id): Promise<EccKeyPair> {\n\t\tconst algo = senderKeyPair.keyPairType\n\t\tif (isPqKeyPairs(senderKeyPair)) {\n\t\t\treturn senderKeyPair.eccKeyPair\n\t\t} else if (isRsaEccKeyPair(senderKeyPair)) {\n\t\t\treturn { publicKey: senderKeyPair.publicEccKey, privateKey: senderKeyPair.privateEccKey }\n\t\t} else if (isRsaOrRsaEccKeyPair(senderKeyPair)) {\n\t\t\t// there is no ecc key pair yet, so we have to genrate and upload one\n\t\t\tconst symGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(keyGroupId)\n\t\t\tconst newIdentityKeyPair = this.cryptoWrapper.generateEccKeyPair()\n\t\t\tconst symEncPrivEccKey = this.cryptoWrapper.encryptEccKey(symGroupKey.object, newIdentityKeyPair.privateKey)\n\t\t\tconst data = createPublicKeyPutIn({ pubEccKey: newIdentityKeyPair.publicKey, symEncPrivEccKey, keyGroup: keyGroupId })\n\t\t\tawait this.serviceExecutor.put(PublicKeyService, data)\n\t\t\treturn newIdentityKeyPair\n\t\t} else {\n\t\t\tthrow new CryptoError(\"unknown key pair type: \" + algo)\n\t\t}\n\t}\n}\n"]}