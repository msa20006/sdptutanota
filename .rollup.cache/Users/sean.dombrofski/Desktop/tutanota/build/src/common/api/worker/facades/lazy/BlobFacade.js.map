{"version":3,"file":"BlobFacade.js","sourceRoot":"","sources":["../../../../../../../src/common/api/worker/facades/lazy/BlobFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { addParamsToUrl, isSuspensionResponse, RestClient, SuspensionBehavior } from \"../../rest/RestClient.js\"\nimport { CryptoFacade } from \"../../crypto/CryptoFacade.js\"\nimport {\n\tassertNonNull,\n\tbase64ToBase64Ext,\n\tclear,\n\tconcat,\n\tgetFirstOrThrow,\n\tgroupBy,\n\tisEmpty,\n\tmapMap,\n\tneverNull,\n\tpromiseMap,\n\tsplitUint8ArrayInChunks,\n\tuint8ArrayToBase64,\n\tuint8ArrayToString,\n} from \"@tutao/tutanota-utils\"\nimport { ArchiveDataType, MAX_BLOB_SIZE_BYTES } from \"../../../common/TutanotaConstants.js\"\n\nimport { HttpMethod, MediaType, resolveTypeReference } from \"../../../common/EntityFunctions.js\"\nimport { assertWorkerOrNode, isApp, isDesktop } from \"../../../common/Env.js\"\nimport type { SuspensionHandler } from \"../../SuspensionHandler.js\"\nimport { BlobService } from \"../../../entities/storage/Services.js\"\nimport { aesDecrypt, AesKey, sha256Hash } from \"@tutao/tutanota-crypto\"\nimport type { FileUri, NativeFileApp } from \"../../../../native/common/FileApp.js\"\nimport type { AesApp } from \"../../../../native/worker/AesApp.js\"\nimport { InstanceMapper } from \"../../crypto/InstanceMapper.js\"\nimport { Blob, BlobReferenceTokenWrapper, createBlobReferenceTokenWrapper } from \"../../../entities/sys/TypeRefs.js\"\nimport { FileReference } from \"../../../common/utils/FileUtils.js\"\nimport { handleRestError } from \"../../../common/error/RestError.js\"\nimport { ProgrammingError } from \"../../../common/error/ProgrammingError.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { BlobGetInTypeRef, BlobPostOut, BlobPostOutTypeRef, BlobServerAccessInfo, createBlobGetIn, createBlobId } from \"../../../entities/storage/TypeRefs.js\"\nimport { AuthDataProvider } from \"../UserFacade.js\"\nimport { doBlobRequestWithRetry, tryServers } from \"../../rest/EntityRestClient.js\"\nimport { BlobAccessTokenFacade } from \"../BlobAccessTokenFacade.js\"\nimport { DefaultEntityRestCache } from \"../../rest/DefaultEntityRestCache.js\"\nimport { SomeEntity } from \"../../../common/EntityTypes.js\"\nimport { encryptBytes } from \"../../crypto/CryptoWrapper.js\"\nimport { BlobReferencingInstance } from \"../../../common/utils/BlobUtils.js\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\n\nassertWorkerOrNode()\nexport const BLOB_SERVICE_REST_PATH = `/rest/${BlobService.app}/${BlobService.name.toLowerCase()}`\nexport const TAG = \"BlobFacade\"\n\nexport interface BlobLoadOptions {\n\textraHeaders?: Dict\n\tsuspensionBehavior?: SuspensionBehavior\n\t/** override origin for the request */\n\tbaseUrl?: string\n}\n\n/**\n * The BlobFacade uploads and downloads blobs to/from the blob store.\n *\n * It requests tokens from the BlobAccessTokenService and download and uploads the blobs to/from the BlobService.\n *\n * In case of upload it is necessary to make a request to the BlobReferenceService or use the referenceTokens returned by the BlobService PUT in some other service call.\n * Otherwise, the blobs will automatically be deleted after some time. It is not allowed to reference blobs manually in some instance.\n */\nexport class BlobFacade {\n\tconstructor(\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly suspensionHandler: SuspensionHandler,\n\t\tprivate readonly fileApp: NativeFileApp,\n\t\tprivate readonly aesApp: AesApp,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly blobAccessTokenFacade: BlobAccessTokenFacade,\n\t) {}\n\n\t/**\n\t * Encrypts and uploads binary data to the blob store. The binary data is split into multiple blobs in case it\n\t * is too big.\n\t *\n\t * @returns blobReferenceToken that must be used to reference a blobs from an instance. Only to be used once.\n\t */\n\tasync encryptAndUpload(archiveDataType: ArchiveDataType, blobData: Uint8Array, ownerGroupId: Id, sessionKey: AesKey): Promise<BlobReferenceTokenWrapper[]> {\n\t\tconst chunks = splitUint8ArrayInChunks(MAX_BLOB_SIZE_BYTES, blobData)\n\t\tconst doBlobRequest = async () => {\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroupId)\n\t\t\treturn promiseMap(chunks, async (chunk) => await this.encryptAndUploadChunk(chunk, blobServerAccessInfo, sessionKey))\n\t\t}\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictWriteToken(archiveDataType, ownerGroupId)\n\n\t\treturn doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t}\n\n\t/**\n\t * Encrypts and uploads binary data stored as a file to the blob store. The binary data is split into multiple blobs in case it\n\t * is too big.\n\t *\n\t * @returns blobReferenceToken that must be used to reference a blobs from an instance. Only to be used once.\n\t */\n\tasync encryptAndUploadNative(\n\t\tarchiveDataType: ArchiveDataType,\n\t\tfileUri: FileUri,\n\t\townerGroupId: Id,\n\t\tsessionKey: AesKey,\n\t): Promise<BlobReferenceTokenWrapper[]> {\n\t\tif (!isApp() && !isDesktop()) {\n\t\t\tthrow new ProgrammingError(\"Environment is not app or Desktop!\")\n\t\t}\n\t\tconst chunkUris = await this.fileApp.splitFile(fileUri, MAX_BLOB_SIZE_BYTES)\n\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictWriteToken(archiveDataType, ownerGroupId)\n\t\tconst doBlobRequest = async () => {\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroupId)\n\t\t\treturn promiseMap(chunkUris, async (chunkUri) => {\n\t\t\t\treturn this.encryptAndUploadNativeChunk(chunkUri, blobServerAccessInfo, sessionKey)\n\t\t\t})\n\t\t}\n\t\treturn doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t}\n\n\t/**\n\t * Downloads multiple blobs, decrypts and joins them to unencrypted binary data.\n\t *\n\t * @param archiveDataType\n\t * @param referencingInstance that directly references the blobs\n\t * @returns Uint8Array unencrypted binary data\n\t */\n\tasync downloadAndDecrypt(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstance: BlobReferencingInstance,\n\t\tblobLoadOptions: BlobLoadOptions = {},\n\t): Promise<Uint8Array> {\n\t\tconst sessionKey = await this.resolveSessionKey(referencingInstance.entity)\n\t\t// Currently assumes that all the blobs of the instance are in the same archive.\n\t\t// If this changes we need to group by archive and do request for each archive and then concatenate all the chunks.\n\t\tconst doBlobRequest = async () => {\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, blobLoadOptions)\n\t\t\treturn this.downloadAndDecryptMultipleBlobsOfArchive(referencingInstance.blobs, blobServerAccessInfo, sessionKey, blobLoadOptions)\n\t\t}\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictReadBlobsToken(referencingInstance)\n\n\t\tconst blobChunks = await doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t\treturn this.concatenateBlobChunks(referencingInstance, blobChunks)\n\t}\n\n\tprivate concatenateBlobChunks(referencingInstance: BlobReferencingInstance, blobChunks: Map<Id, Uint8Array>) {\n\t\tconst resultSize = Array.from(blobChunks.values()).reduce((sum, blob) => blob.length + sum, 0)\n\t\tconst resultBuffer = new Uint8Array(resultSize)\n\t\tlet offset = 0\n\t\tfor (const blob of referencingInstance.blobs) {\n\t\t\tconst data = blobChunks.get(blob.blobId)\n\t\t\tassertNonNull(data, `Server did not return blob for id : ${blob.blobId}`)\n\t\t\tresultBuffer.set(data, offset)\n\t\t\toffset += data.length\n\t\t}\n\t\treturn resultBuffer\n\t}\n\n\t/**\n\t * Downloads blobs of all {@param referencingInstances}, decrypts them and joins them to unencrypted binaries.\n\t * If some blobs are not found the result will contain {@code null}.\n\t * @returns Map from instance id to the decrypted and concatenated contents of the referenced blobs\n\t */\n\tasync downloadAndDecryptBlobsOfMultipleInstances(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstances: BlobReferencingInstance[],\n\t\tblobLoadOptions: BlobLoadOptions = {},\n\t): Promise<Map<Id, Uint8Array | null>> {\n\t\t// If a mail has multiple attachments, we cannot assume they are all on the same archive.\n\t\t// But all blobs of a single attachment should be in the same archive\n\t\tconst instancesByArchive = groupBy(referencingInstances, (instance) => getFirstOrThrow(instance.blobs).archiveId)\n\n\t\t// instance id to data\n\t\tconst result: Map<Id, Uint8Array | null> = new Map()\n\n\t\tfor (const [_, instances] of instancesByArchive.entries()) {\n\t\t\t// request a token for all instances of the archive\n\t\t\t// download all blobs from all instances for this archive\n\t\t\tconst allBlobs = instances.flatMap((instance) => instance.blobs)\n\t\t\tconst doBlobRequest = async () => {\n\t\t\t\tconst accessInfo = await this.blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, instances, blobLoadOptions)\n\t\t\t\treturn this.downloadBlobsOfOneArchive(allBlobs, accessInfo, blobLoadOptions)\n\t\t\t}\n\t\t\tconst doEvictToken = () => {\n\t\t\t\tfor (const instance of instances) {\n\t\t\t\t\tthis.blobAccessTokenFacade.evictReadBlobsToken(instance)\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst encryptedBlobsOfAllInstances = await doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\t\t\t// sort blobs by the instance\n\t\t\tfor (const instance of instances) {\n\t\t\t\tconst decryptedData = await this.decryptInstanceData(instance, encryptedBlobsOfAllInstances)\n\t\t\t\t// return Map of instance id -> blob data\n\t\t\t\tresult.set(instance.elementId, decryptedData)\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\tprivate async decryptInstanceData(instance: BlobReferencingInstance, blobs: Map<Id, Uint8Array>): Promise<Uint8Array | null> {\n\t\t// get the key of the instance\n\t\tconst sessionKey = await this.resolveSessionKey(instance.entity)\n\t\t// decrypt blobs of the instance and concatenate them\n\t\tconst decryptedChunks: Uint8Array[] = []\n\t\tfor (const blob of instance.blobs) {\n\t\t\tconst encryptedChunk = blobs.get(blob.blobId)\n\t\t\tif (encryptedChunk == null) {\n\t\t\t\tconsole.log(TAG, `Did not find blob of the instance. blobId: ${blob.blobId}, instance: ${instance}`)\n\t\t\t\treturn null\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tdecryptedChunks.push(aesDecrypt(sessionKey, encryptedChunk))\n\t\t\t} catch (e) {\n\t\t\t\t// If decrypting one chunk of an instance fails it doesn't make sense to return any data for\n\t\t\t\t// that instance\n\t\t\t\tif (e instanceof CryptoError) {\n\t\t\t\t\tconsole.log(TAG, `Could not decrypt blob of the instance. blobId: ${blob.blobId}, instance: ${instance}`, e)\n\t\t\t\t\treturn null\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn concat(...decryptedChunks)\n\t}\n\n\t/**\n\t * Downloads multiple blobs, decrypts and joins them to unencrypted binary data which will be stored as a file on the\n\t * device.\n\t *\n\t * @param archiveDataType\n\t * @param referencingInstance that directly references the blobs\n\t * @param fileName is written to the returned FileReference\n\t * @param mimeType is written to the returned FileReference\n\t * @returns FileReference to the unencrypted binary data\n\t */\n\tasync downloadAndDecryptNative(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstance: BlobReferencingInstance,\n\t\tfileName: string,\n\t\tmimeType: string,\n\t): Promise<FileReference> {\n\t\tif (!isApp() && !isDesktop()) {\n\t\t\tthrow new ProgrammingError(\"Environment is not app or Desktop!\")\n\t\t}\n\t\tconst sessionKey = await this.resolveSessionKey(referencingInstance.entity)\n\t\tconst decryptedChunkFileUris: FileUri[] = []\n\t\tconst doBlobRequest = async () => {\n\t\t\tclear(decryptedChunkFileUris) // ensure that the decrypted file uris are emtpy in case we retry because of NotAuthorized error\n\t\t\tconst blobServerAccessInfo = await this.blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, {})\n\t\t\treturn promiseMap(referencingInstance.blobs, async (blob) => {\n\t\t\t\tdecryptedChunkFileUris.push(await this.downloadAndDecryptChunkNative(blob, blobServerAccessInfo, sessionKey))\n\t\t\t}).catch(async (e: Error) => {\n\t\t\t\t// cleanup every temporary file in the native part in case an error occured when downloading chun\n\t\t\t\tfor (const decryptedChunkFileUri of decryptedChunkFileUris) {\n\t\t\t\t\tawait this.fileApp.deleteFile(decryptedChunkFileUri)\n\t\t\t\t}\n\t\t\t\tthrow e\n\t\t\t})\n\t\t}\n\t\tconst doEvictToken = () => this.blobAccessTokenFacade.evictReadBlobsToken(referencingInstance)\n\n\t\tawait doBlobRequestWithRetry(doBlobRequest, doEvictToken)\n\n\t\t// now decryptedChunkFileUris has the correct order of downloaded blobs, and we need to tell native to join them\n\t\t// check if output already exists and return cached?\n\t\ttry {\n\t\t\tconst decryptedFileUri = await this.fileApp.joinFiles(fileName, decryptedChunkFileUris)\n\t\t\tconst size = await this.fileApp.getSize(decryptedFileUri)\n\t\t\treturn {\n\t\t\t\t_type: \"FileReference\",\n\t\t\t\tname: fileName,\n\t\t\t\tmimeType,\n\t\t\t\tsize,\n\t\t\t\tlocation: decryptedFileUri,\n\t\t\t}\n\t\t} finally {\n\t\t\tfor (const tmpBlobFile of decryptedChunkFileUris) {\n\t\t\t\tawait this.fileApp.deleteFile(tmpBlobFile)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async resolveSessionKey(entity: SomeEntity): Promise<AesKey> {\n\t\treturn neverNull(await this.cryptoFacade.resolveSessionKeyForInstance(entity))\n\t}\n\n\tprivate async encryptAndUploadChunk(chunk: Uint8Array, blobServerAccessInfo: BlobServerAccessInfo, sessionKey: AesKey): Promise<BlobReferenceTokenWrapper> {\n\t\tconst encryptedData = encryptBytes(sessionKey, chunk)\n\t\tconst blobHash = uint8ArrayToBase64(sha256Hash(encryptedData).slice(0, 6))\n\t\tconst queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, { blobHash }, BlobGetInTypeRef)\n\n\t\treturn tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\tconst response = await this.restClient.request(BLOB_SERVICE_REST_PATH, HttpMethod.POST, {\n\t\t\t\t\tqueryParams: queryParams,\n\t\t\t\t\tbody: encryptedData,\n\t\t\t\t\tresponseType: MediaType.Json,\n\t\t\t\t\tbaseUrl: serverUrl,\n\t\t\t\t})\n\t\t\t\treturn await this.parseBlobPostOutResponse(response)\n\t\t\t},\n\t\t\t`can't upload to server`,\n\t\t)\n\t}\n\n\tprivate async encryptAndUploadNativeChunk(\n\t\tfileUri: FileUri,\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tsessionKey: AesKey,\n\t): Promise<BlobReferenceTokenWrapper> {\n\t\tconst encryptedFileInfo = await this.aesApp.aesEncryptFile(sessionKey, fileUri)\n\t\tconst encryptedChunkUri = encryptedFileInfo.uri\n\t\tconst blobHash = await this.fileApp.hashFile(encryptedChunkUri)\n\n\t\treturn tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\treturn await this.uploadNative(encryptedChunkUri, blobServerAccessInfo, serverUrl, blobHash)\n\t\t\t},\n\t\t\t`can't upload to server from native`,\n\t\t)\n\t}\n\n\tprivate async uploadNative(\n\t\tlocation: string,\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tserverUrl: string,\n\t\tblobHash: string,\n\t): Promise<BlobReferenceTokenWrapper> {\n\t\tif (this.suspensionHandler.isSuspended()) {\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.uploadNative(location, blobServerAccessInfo, serverUrl, blobHash))\n\t\t}\n\t\tconst queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, { blobHash }, BlobGetInTypeRef)\n\t\tconst serviceUrl = new URL(BLOB_SERVICE_REST_PATH, serverUrl)\n\t\tconst fullUrl = addParamsToUrl(serviceUrl, queryParams)\n\t\tconst { suspensionTime, responseBody, statusCode, errorId, precondition } = await this.fileApp.upload(location, fullUrl.toString(), HttpMethod.POST, {}) // blobReferenceToken in the response body\n\n\t\tif (statusCode === 201 && responseBody != null) {\n\t\t\treturn this.parseBlobPostOutResponse(uint8ArrayToString(\"utf-8\", responseBody))\n\t\t} else if (responseBody == null) {\n\t\t\tthrow new Error(\"no response body\")\n\t\t} else if (isSuspensionResponse(statusCode, suspensionTime)) {\n\t\t\tthis.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), serviceUrl)\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.uploadNative(location, blobServerAccessInfo, serverUrl, blobHash))\n\t\t} else {\n\t\t\tthrow handleRestError(statusCode, ` | ${HttpMethod.POST} ${fullUrl.toString()} failed to natively upload blob`, errorId, precondition)\n\t\t}\n\t}\n\n\tprivate async parseBlobPostOutResponse(jsonData: string): Promise<BlobReferenceTokenWrapper> {\n\t\tconst responseTypeModel = await resolveTypeReference(BlobPostOutTypeRef)\n\t\tconst instance = JSON.parse(jsonData)\n\t\tconst { blobReferenceToken } = await this.instanceMapper.decryptAndMapToInstance<BlobPostOut>(responseTypeModel, instance, null)\n\t\t// is null in case of post multiple to the BlobService, currently only supported in the rust-sdk\n\t\t// post single always has a valid blobRefernceToken with cardinality one.\n\t\tif (blobReferenceToken == null) {\n\t\t\tthrow new ProgrammingError(\"empty blobReferenceToken not allowed for post single blob\")\n\t\t}\n\t\treturn createBlobReferenceTokenWrapper({ blobReferenceToken })\n\t}\n\n\tprivate async downloadAndDecryptMultipleBlobsOfArchive(\n\t\tblobs: readonly Blob[],\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tsessionKey: AesKey,\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<Map<Id, Uint8Array>> {\n\t\tconst mapWithEncryptedBlobs = await this.downloadBlobsOfOneArchive(blobs, blobServerAccessInfo, blobLoadOptions)\n\t\treturn mapMap(mapWithEncryptedBlobs, (blob) => aesDecrypt(sessionKey, blob))\n\t}\n\n\t/**\n\t * Download blobs of a single archive in a single request\n\t * @return map from blob id to the data\n\t */\n\tprivate async downloadBlobsOfOneArchive(\n\t\tblobs: readonly Blob[],\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<Map<Id, Uint8Array>> {\n\t\tif (isEmpty(blobs)) {\n\t\t\tthrow new ProgrammingError(\"Blobs are empty\")\n\t\t}\n\t\tconst archiveId = getFirstOrThrow(blobs).archiveId\n\t\tif (blobs.some((blob) => blob.archiveId !== archiveId)) {\n\t\t\tthrow new ProgrammingError(\"Must only request blobs of the same archive together\")\n\t\t}\n\t\tconst getData = createBlobGetIn({\n\t\t\tarchiveId,\n\t\t\tblobId: null,\n\t\t\tblobIds: blobs.map(({ blobId }) => createBlobId({ blobId: blobId })),\n\t\t})\n\t\tconst BlobGetInTypeModel = await resolveTypeReference(BlobGetInTypeRef)\n\t\tconst literalGetData = await this.instanceMapper.encryptAndMapToLiteral(BlobGetInTypeModel, getData, null)\n\t\tconst body = JSON.stringify(literalGetData)\n\t\tconst queryParams = await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, {}, BlobGetInTypeRef)\n\t\tconst concatBinaryData = await tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\treturn await this.restClient.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, {\n\t\t\t\t\tqueryParams: queryParams,\n\t\t\t\t\tbody,\n\t\t\t\t\tresponseType: MediaType.Binary,\n\t\t\t\t\tbaseUrl: serverUrl,\n\t\t\t\t\tnoCORS: true,\n\t\t\t\t\theaders: blobLoadOptions.extraHeaders,\n\t\t\t\t\tsuspensionBehavior: blobLoadOptions.suspensionBehavior,\n\t\t\t\t})\n\t\t\t},\n\t\t\t`can't download from server `,\n\t\t)\n\t\treturn parseMultipleBlobsResponse(concatBinaryData)\n\t}\n\n\tprivate async downloadAndDecryptChunkNative(blob: Blob, blobServerAccessInfo: BlobServerAccessInfo, sessionKey: AesKey): Promise<FileUri> {\n\t\tconst { archiveId, blobId } = blob\n\t\tconst getData = createBlobGetIn({\n\t\t\tarchiveId,\n\t\t\tblobId,\n\t\t\tblobIds: [],\n\t\t})\n\t\tconst BlobGetInTypeModel = await resolveTypeReference(BlobGetInTypeRef)\n\t\tconst literalGetData = await this.instanceMapper.encryptAndMapToLiteral(BlobGetInTypeModel, getData, null)\n\t\tconst _body = JSON.stringify(literalGetData)\n\n\t\tconst blobFilename = blobId + \".blob\"\n\n\t\treturn tryServers(\n\t\t\tblobServerAccessInfo.servers,\n\t\t\tasync (serverUrl) => {\n\t\t\t\treturn await this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, blobFilename, { _body })\n\t\t\t},\n\t\t\t`can't download native from server `,\n\t\t)\n\t}\n\n\t/**\n\t * @return the uri of the decrypted blob\n\t */\n\tprivate async downloadNative(\n\t\tserverUrl: string,\n\t\tblobServerAccessInfo: BlobServerAccessInfo,\n\t\tsessionKey: AesKey,\n\t\tfileName: string,\n\t\tadditionalParams: Dict,\n\t): Promise<FileUri> {\n\t\tif (this.suspensionHandler.isSuspended()) {\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, fileName, additionalParams))\n\t\t}\n\t\tconst serviceUrl = new URL(BLOB_SERVICE_REST_PATH, serverUrl)\n\t\tconst url = addParamsToUrl(serviceUrl, await this.blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, additionalParams, BlobGetInTypeRef))\n\t\tconst { statusCode, encryptedFileUri, suspensionTime, errorId, precondition } = await this.fileApp.download(url.toString(), fileName, {})\n\t\tif (statusCode == 200 && encryptedFileUri != null) {\n\t\t\tconst decryptedFileUrl = await this.aesApp.aesDecryptFile(sessionKey, encryptedFileUri)\n\t\t\ttry {\n\t\t\t\tawait this.fileApp.deleteFile(encryptedFileUri)\n\t\t\t} catch {\n\t\t\t\tconsole.log(\"Failed to delete encrypted file\", encryptedFileUri)\n\t\t\t}\n\t\t\treturn decryptedFileUrl\n\t\t} else if (isSuspensionResponse(statusCode, suspensionTime)) {\n\t\t\tthis.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), serviceUrl)\n\t\t\treturn this.suspensionHandler.deferRequest(() => this.downloadNative(serverUrl, blobServerAccessInfo, sessionKey, fileName, additionalParams))\n\t\t} else {\n\t\t\tthrow handleRestError(statusCode, ` | ${HttpMethod.GET} failed to natively download attachment`, errorId, precondition)\n\t\t}\n\t}\n}\n\n/**\n * Deserializes a list of BlobWrappers that are in the following binary format\n * element [ #blobs ] [ blobId ] [ blobHash ] [blobSize] [blob]     [ . . . ]    [ blobNId ] [ blobNHash ] [blobNSize] [blobN]\n * bytes     4          9          6           4          blobSize                  9          6            4           blobSize\n *\n * @return a map from blobId to the binary data\n */\nexport function parseMultipleBlobsResponse(concatBinaryData: Uint8Array): Map<Id, Uint8Array> {\n\tconst dataView = new DataView(concatBinaryData.buffer)\n\tconst result = new Map<Id, Uint8Array>()\n\tconst blobCount = dataView.getInt32(0)\n\tif (blobCount === 0) {\n\t\treturn result\n\t}\n\tif (blobCount < 0) {\n\t\tthrow new Error(`Invalid blob count: ${blobCount}`)\n\t}\n\tlet offset = 4\n\twhile (offset < concatBinaryData.length) {\n\t\tconst blobIdBytes = concatBinaryData.slice(offset, offset + 9)\n\t\tconst blobId = base64ToBase64Ext(uint8ArrayToBase64(blobIdBytes))\n\n\t\tconst blobSize = dataView.getInt32(offset + 15)\n\t\tconst dataStartOffset = offset + 19\n\t\tif (blobSize < 0 || dataStartOffset + blobSize > concatBinaryData.length) {\n\t\t\tthrow new Error(`Invalid blob size: ${blobSize}. Remaining length: ${concatBinaryData.length - dataStartOffset}`)\n\t\t}\n\t\tconst contents = concatBinaryData.slice(dataStartOffset, dataStartOffset + blobSize)\n\t\tresult.set(blobId, contents)\n\t\toffset = dataStartOffset + blobSize\n\t}\n\tif (blobCount !== result.size) {\n\t\tthrow new Error(`Parsed wrong number of blobs: ${blobCount}. Expected: ${result.size}`)\n\t}\n\treturn result\n}\n"]}