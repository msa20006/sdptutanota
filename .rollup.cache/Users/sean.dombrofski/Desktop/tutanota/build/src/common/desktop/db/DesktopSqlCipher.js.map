{"version":3,"file":"DesktopSqlCipher.js","sourceRoot":"","sources":["../../../../../src/common/desktop/db/DesktopSqlCipher.ts"],"names":[],"mappings":"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","sourcesContent":["import { Database, default as Sqlite } from \"better-sqlite3\"\nimport { mapNullable, uint8ArrayToHex } from \"@tutao/tutanota-utils\"\nimport { CryptoError } from \"@tutao/tutanota-crypto/error.js\"\nimport { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { OfflineDbClosedError } from \"../../api/common/error/OfflineDbClosedError.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\nimport { TaggedSqlValue, tagSqlObject, untagSqlValue } from \"../../api/worker/offline/SqlValue.js\"\nimport { Mode } from \"../../api/common/Env.js\"\n\nexport class DesktopSqlCipher implements SqlCipherFacade {\n\tprivate _db: Database | null = null\n\tprivate get db(): Database {\n\t\tif (this._db == null) {\n\t\t\tthrow new OfflineDbClosedError()\n\t\t}\n\t\treturn this._db\n\t}\n\n\t/**\n\t * @param nativeBindingPath the path to the sqlite native module\n\t * @param dbPath the path to the database file to use\n\t * @param integrityCheck whether to check the integrity of the db file during initialization\n\t */\n\tconstructor(private readonly nativeBindingPath: string, private readonly dbPath: string, private readonly integrityCheck: boolean) {\n\t\tprocess.on(\"exit\", () => this._db?.close())\n\t}\n\n\tasync openDb(userId: string, dbKey: Uint8Array): Promise<void> {\n\t\tthis._db = new Sqlite(this.dbPath, {\n\t\t\t// Remove ts-ignore once proper definition of Options exists, see https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/59049#\n\t\t\t// @ts-ignore missing type\n\t\t\tnativeBinding: this.nativeBindingPath,\n\t\t\t// verbose: (message, args) => console.log(\"DB\", message, args),\n\t\t})\n\t\ttry {\n\t\t\tthis.initSqlcipher({ databaseKey: dbKey, enableMemorySecurity: true, integrityCheck: this.integrityCheck })\n\t\t} catch (e) {\n\t\t\t// If we can't initialize the database we don't want to be stuck in a state where we hold the file lock, we need to retry the whole process again\n\t\t\tthis.db.close()\n\t\t\tthis._db = null\n\t\t\tthrow e // \"file is not a database\" is most likely wrong database key\n\t\t}\n\t}\n\n\tasync closeDb(): Promise<void> {\n\t\ttry {\n\t\t\t// We are performing defragmentation (incremental_vacuum) the database before closing.\n\t\t\t// But if it fails for some reason we don't want ot get stuck with non-closed database that we cannot delete so we close it and rethrow.\n\t\t\tthis.db.pragma(\"incremental_vacuum\")\n\t\t} finally {\n\t\t\tthis.db.close()\n\t\t\tthis._db = null\n\t\t}\n\t}\n\n\t/**\n\t * not implemented because we delete the DB directly from the per-window facade\n\t */\n\tdeleteDb(userId: string): Promise<void> {\n\t\tthrow new ProgrammingError(\"Not implemented\")\n\t}\n\n\t/**\n\t * Initialise sqlcipher with a database key, configuration:\n\t * - Sqlcipher always uses aes-256 for encryption.\n\t * - Sqlcipher always creates per page hmac for integrity with sha512.\n\t * - Sqlcipher generates a database salt value randomly and stores in the first 16 bytes of the database.\n\t * - We pass the database key directly to sqlcipher rather than using a password and therefore do not configure key derivation.\n\t * - we assume that adding entropy to entropy pool of the crypto provide (cipher_add_random) \"is not necessary [...], since [openssl] does (re-)seed itself automatically using trusted system entropy sources\", https://www.openssl.org/docs/man1.1.1/man3/RAND_add.html\n\t * @param databaseKey\n\t * @param enableMemorySecurity if true the the memory security option (that was default until 4.5, https://www.zetetic.net/blog/2021/10/28/sqlcipher-4.5.0-release/) to wipe memory allocated by SQLite internally, including the page cache is enabled.\n\t * @param integrityCheck: if true the hmac stored with each page of the database is verified to detect modification.\n\t * @throws if an error is detected during the integrity check\n\t */\n\tprivate initSqlcipher({\n\t\tdatabaseKey,\n\t\tenableMemorySecurity,\n\t\tintegrityCheck,\n\t}: {\n\t\tdatabaseKey: Uint8Array\n\t\tenableMemorySecurity: boolean\n\t\t// integrity check breaks tests\n\t\tintegrityCheck: boolean\n\t}) {\n\t\tif (env.mode === Mode.Test) {\n\t\t\tthis.db.pragma(\"cipher_log_source = NONE\")\n\t\t}\n\t\tif (enableMemorySecurity) {\n\t\t\tthis.db.pragma(\"cipher_memory_security = ON\")\n\t\t}\n\n\t\tconst key = `x'${uint8ArrayToHex(databaseKey)}'`\n\t\tthis.db.pragma(`KEY = \"${key}\"`)\n\n\t\t// We are using the auto_vacuum=incremental mode to allow for a faster vacuum execution\n\t\t// After changing the auto_vacuum mode we need to run \"vacuum\" once\n\t\t// auto_vacuum mode: 0 (NONE) | 1 (FULL) | 2 (INCREMENTAL)\n\t\tif (this.db.pragma(\"auto_vacuum\", { simple: true }) != 2) {\n\t\t\tthis.db.pragma(\"auto_vacuum = incremental\")\n\t\t\tthis.db.pragma(\"vacuum\")\n\t\t}\n\n\t\tif (integrityCheck) {\n\t\t\tthis.checkIntegrity()\n\t\t}\n\t}\n\n\t/**\n\t * Execute a query\n\t */\n\tasync run(query: string, params: TaggedSqlValue[]): Promise<void> {\n\t\tthis.db.prepare(query).run(params.map(untagSqlValue))\n\t}\n\n\t/**\n\t * Execute a query\n\t * @returns a single object or undefined if the query returns nothing\n\t */\n\tasync get(query: string, params: TaggedSqlValue[]): Promise<Record<string, TaggedSqlValue> | null> {\n\t\tconst result = this.db.prepare(query).get(params.map(untagSqlValue)) ?? null\n\t\treturn mapNullable(result, tagSqlObject)\n\t}\n\n\t/**\n\t * Execute a query\n\t * @returns a list of objects or an empty list if the query returns nothing\n\t */\n\tasync all(query: string, params: TaggedSqlValue[]): Promise<Array<Record<string, TaggedSqlValue>>> {\n\t\tconst result = this.db.prepare(query).all(params.map(untagSqlValue))\n\t\treturn result.map(tagSqlObject)\n\t}\n\n\t/**\n\t * not implemented because we lock the \"ranges\" DB directly from the per-window facade\n\t * we return Promise.resolve() in order to allow testing of the \"clearExcludedData\" function\n\t */\n\tlockRangesDbAccess(userId: Id): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n\n\t/**\n\t * not implemented because we unlock the \"ranges\" DB directly from the per-window facade\n\t * we return Promise.resolve() in order to allow testing of the \"clearExcludedData\" function\n\t */\n\tunlockRangesDbAccess(userId: Id): Promise<void> {\n\t\treturn Promise.resolve()\n\t}\n\n\tprivate checkIntegrity() {\n\t\t/**\n\t\t * Throws a CryptoError if MAC verification fails\n\t\t */\n\t\tconst errors: [] = this.db.pragma(\"cipher_integrity_check\")\n\t\tif (errors.length > 0) {\n\t\t\tthrow new CryptoError(`Integrity check failed with result : ${JSON.stringify(errors)}`)\n\t\t}\n\t}\n}\n"]}