{"version":3,"file":"PageContextLoginListener.js","sourceRoot":"","sources":["../../../../../src/common/api/main/PageContextLoginListener.ts"],"names":[],"mappings":"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","sourcesContent":["import { SecondFactorHandler } from \"../../misc/2fa/SecondFactorHandler.js\"\nimport { arrayEquals, assertNotNull, defer, DeferredObject } from \"@tutao/tutanota-utils\"\nimport { Challenge } from \"../entities/sys/TypeRefs.js\"\nimport { CacheInfo, LoginListener } from \"../worker/facades/LoginFacade.js\"\nimport { SessionType } from \"../common/SessionType.js\"\nimport { CredentialsProvider } from \"../../misc/credentials/CredentialsProvider.js\"\nimport { Credentials } from \"../../misc/credentials/Credentials.js\"\nimport { PersistedCredentials } from \"../../native/common/generatedipc/PersistedCredentials.js\"\n\nexport const enum LoginFailReason {\n\tSessionExpired,\n\tError,\n}\n\n/** Listener for the login events from the worker side. */\nexport class PageContextLoginListener implements LoginListener {\n\tprivate loginPromise: DeferredObject<void> = defer()\n\tprivate fullLoginFailed: boolean = false\n\n\tconstructor(private readonly secondFactorHandler: SecondFactorHandler, private readonly credentialsProvider: CredentialsProvider) {}\n\n\t/** e.g. after temp logout */\n\treset() {\n\t\tthis.loginPromise = defer()\n\t\tthis.fullLoginFailed = false\n\t}\n\n\twaitForFullLogin(): Promise<void> {\n\t\treturn this.loginPromise.promise\n\t}\n\n\t/**\n\t * Full login reached: any network requests can be made\n\t */\n\tasync onFullLoginSuccess(_sessionType: SessionType, _cacheInfo: CacheInfo, credentials: Credentials): Promise<void> {\n\t\tthis.fullLoginFailed = false\n\n\t\t// Update the credentials after the full login.\n\t\t// It is needed because we added encryptedPassphraseKey to credentials which is only\n\t\t// available after the full login which happens async.\n\n\t\t// First fetch encrypted credentials for the user to figure out if the credentials are stored but are also missing\n\t\t// a passphrase key, and then update if so.\n\n\t\tconst persistedCredentials = (await this.credentialsProvider.getAllInternalCredentials()).find((a) => a.credentialInfo.userId === credentials.userId)\n\t\tif (persistedCredentials != null && this.isPassphraseKeyUpdatedNeeded(persistedCredentials, credentials)) {\n\t\t\tawait this.credentialsProvider.replacePassword(\n\t\t\t\tpersistedCredentials.credentialInfo,\n\t\t\t\tassertNotNull(credentials.encryptedPassword),\n\t\t\t\tassertNotNull(credentials.encryptedPassphraseKey),\n\t\t\t)\n\t\t}\n\n\t\tthis.loginPromise.resolve()\n\t}\n\n\t/**\n\t * It is possible that a KDF migration was executed by a different client. This would change the passphrase key, so we need to check if we have to update the stored one.\n\t * @private\n\t */\n\tprivate isPassphraseKeyUpdatedNeeded(persistedCredentials: PersistedCredentials, credentials: Credentials) {\n\t\tconst persistedEncryptedPassphraseKey = persistedCredentials.encryptedPassphraseKey\n\t\tconst credentialsEncryptedPassphraseKey = credentials.encryptedPassphraseKey\n\t\tif (persistedCredentials.encryptedPassword != credentials.encryptedPassword) {\n\t\t\t// we only want to update the encrypted passwordKey if we changed the kdf function.\n\t\t\t// In this case we have the same endryptedPassword but a different password key.\n\t\t\treturn false\n\t\t}\n\t\tif (persistedEncryptedPassphraseKey != null && credentialsEncryptedPassphraseKey != null) {\n\t\t\treturn !arrayEquals(persistedEncryptedPassphraseKey, credentialsEncryptedPassphraseKey)\n\t\t} else if (persistedEncryptedPassphraseKey == null && credentialsEncryptedPassphraseKey == null) {\n\t\t\t// both are null so nothing has changed.\n\t\t\treturn false\n\t\t} else {\n\t\t\t// one is null and the other is not\n\t\t\treturn true\n\t\t}\n\t}\n\n\t/**\n\t * call when the login fails for invalid session or other reasons\n\t */\n\tasync onLoginFailure(reason: LoginFailReason): Promise<void> {\n\t\tthis.fullLoginFailed = true\n\t\tif (reason === LoginFailReason.SessionExpired) {\n\t\t\tconst { reloginForExpiredSession } = await import(\"../../misc/ErrorHandlerImpl.js\")\n\t\t\tawait reloginForExpiredSession()\n\t\t}\n\t}\n\n\t/**\n\t * call when retrying full login\n\t */\n\tonRetryLogin(): void {\n\t\tthis.fullLoginFailed = false\n\t}\n\n\t/**\n\t * Shows a dialog with possibility to use second factor and with a message that the login can be approved from another client.\n\t */\n\tonSecondFactorChallenge(sessionId: IdTuple, challenges: ReadonlyArray<Challenge>, mailAddress: string | null): Promise<void> {\n\t\treturn this.secondFactorHandler.showSecondFactorAuthenticationDialog(sessionId, challenges, mailAddress)\n\t}\n\n\t/**\n\t * true if the last full login attempt failed\n\t * may revert to false when retrying.\n\t */\n\tgetFullLoginFailed(): boolean {\n\t\treturn this.fullLoginFailed\n\t}\n}\n"]}