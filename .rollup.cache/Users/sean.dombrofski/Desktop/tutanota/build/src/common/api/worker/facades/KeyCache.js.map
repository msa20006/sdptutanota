{"version":3,"file":"KeyCache.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/facades/KeyCache.ts"],"names":[],"mappings":"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","sourcesContent":["import { getFromMap, neverNull } from \"@tutao/tutanota-utils\"\nimport { User } from \"../../entities/sys/TypeRefs.js\"\nimport { VersionedKey } from \"../crypto/CryptoWrapper.js\"\nimport { Aes256Key } from \"@tutao/tutanota-crypto\"\nimport { checkKeyVersionConstraints, parseKeyVersion } from \"./KeyLoaderFacade.js\"\n\n/**\n * A cache for decrypted current keys of each group. Encrypted keys are stored on membership.symEncGKey.\n * */\nexport class KeyCache {\n\tprivate currentGroupKeys: Map<Id, Promise<VersionedKey>> = new Map<Id, Promise<VersionedKey>>()\n\t// the user group key is password encrypted and stored on a special membership\n\t// also it is used to decrypt the rest of the keys therefore it requires some special handling\n\tprivate currentUserGroupKey: VersionedKey | null = null\n\t// the new user group key will be re-encrypted with this key to distribute the rotated user group key without asking for the password\n\tprivate userDistKey: Aes256Key | null = null\n\n\tprivate legacyUserDistKey: Aes256Key | null = null\n\n\tsetCurrentUserGroupKey(newUserGroupKey: VersionedKey) {\n\t\tif (this.currentUserGroupKey != null && this.currentUserGroupKey.version > newUserGroupKey.version) {\n\t\t\tconsole.log(\"Tried to set an outdated user group key\")\n\t\t\treturn\n\t\t}\n\t\t// we need to make sure that the versions returned from the server are non-negative integers, because we rely on that in key verification\n\t\tcheckKeyVersionConstraints(newUserGroupKey.version)\n\t\tthis.currentUserGroupKey = newUserGroupKey\n\t}\n\n\tgetCurrentUserGroupKey(): VersionedKey | null {\n\t\treturn this.currentUserGroupKey\n\t}\n\n\tsetUserDistKey(userDistKey: Aes256Key) {\n\t\tthis.userDistKey = userDistKey\n\t}\n\n\tsetLegacyUserDistKey(legacyUserDistKey: Aes256Key) {\n\t\tthis.legacyUserDistKey = legacyUserDistKey\n\t}\n\n\tgetUserDistKey(): Aes256Key | null {\n\t\treturn this.userDistKey\n\t}\n\n\tgetLegacyUserDistKey(): Aes256Key | null {\n\t\treturn this.legacyUserDistKey\n\t}\n\n\t/**\n\t *\n\t * @param groupId MUST NOT be the user group id\n\t * @param keyLoader a function to load and decrypt the group key if it is not cached\n\t */\n\tgetCurrentGroupKey(groupId: Id, keyLoader: () => Promise<VersionedKey>): Promise<VersionedKey> {\n\t\treturn getFromMap(this.currentGroupKeys, groupId, async () => {\n\t\t\tconst loadedKey = await keyLoader()\n\t\t\t// we need to make sure that the versions returned from the server are non-negative integers, because we rely on that in key verification\n\t\t\tcheckKeyVersionConstraints(loadedKey.version)\n\t\t\treturn loadedKey\n\t\t})\n\t}\n\n\treset() {\n\t\tthis.currentGroupKeys = new Map<Id, Promise<VersionedKey>>()\n\t\tthis.currentUserGroupKey = null\n\t\tthis.userDistKey = null\n\t}\n\n\t/**\n\t * Clears keys from the cache which are outdated or where we do no longer hava a membership.\n\t * An outdated user membership is ignored and should be processed by the UserGroupKeyDistribution update.\n\t * @param user updated user with up-to-date memberships\n\t */\n\tasync removeOutdatedGroupKeys(user: User) {\n\t\tconst currentUserGroupKeyVersion = neverNull(this.getCurrentUserGroupKey()).version\n\t\tconst receivedUserGroupKeyVersion = parseKeyVersion(user.userGroup.groupKeyVersion)\n\t\tif (receivedUserGroupKeyVersion > currentUserGroupKeyVersion) {\n\t\t\t//we just ignore this as the same batch MUST have a UserGroupKeyDistribution entity event update\n\t\t\tconsole.log(`Received user update with new user group key version: ${currentUserGroupKeyVersion} -> ${receivedUserGroupKeyVersion}`)\n\t\t}\n\n\t\tconst newCurrentGroupKeyCache = new Map<Id, Promise<VersionedKey>>()\n\t\tfor (const membership of user.memberships) {\n\t\t\tconst cachedGroupKey = this.currentGroupKeys.get(membership.group)\n\t\t\tif (cachedGroupKey != null && parseKeyVersion(membership.groupKeyVersion) === (await cachedGroupKey).version) {\n\t\t\t\tawait getFromMap(newCurrentGroupKeyCache, membership.group, () => cachedGroupKey)\n\t\t\t}\n\t\t}\n\t\tthis.currentGroupKeys = newCurrentGroupKeyCache\n\t}\n}\n"]}