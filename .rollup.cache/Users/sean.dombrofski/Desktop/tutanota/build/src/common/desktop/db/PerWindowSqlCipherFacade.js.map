{"version":3,"file":"PerWindowSqlCipherFacade.js","sourceRoot":"","sources":["../../../../../src/common/desktop/db/PerWindowSqlCipherFacade.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,gBAAgB,EAAE,MAAM,4CAA4C,CAAA;AAC7E,OAAO,EAAE,GAAG,EAAE,MAAM,kBAAkB,CAAA;AACtC,OAAO,EAAE,oBAAoB,EAAE,MAAM,gDAAgD,CAAA;AAGrF,MAAM,GAAG,GAAG,4BAA4B,CAAA;AAQxC;;;;;;;;;MASM;AACN,MAAM,OAAO,wBAAwB;IAYP;IAX7B;;;SAGK;IACG,KAAK,GAKF,IAAI,CAAA;IAEf,YAA6B,UAA+B;QAA/B,eAAU,GAAV,UAAU,CAAqB;IAAG,CAAC;IAEhE,KAAK,CAAC,MAAM,CAAC,MAAc,EAAE,KAAiB;QAC7C,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,aAAa,EAAE,MAAM,CAAC,CAAA;QACrC,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,EAAE,CAAC;YACxB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,MAAM,EAAE,CAAC;gBACjC,MAAM,IAAI,gBAAgB,CAAC,oCAAoC,IAAI,CAAC,KAAK,CAAC,MAAM,+BAA+B,MAAM,GAAG,CAAC,CAAA;YAC1H,CAAC;iBAAM,CAAC;gBACP,OAAO,CAAC,IAAI,CAAC,wCAAwC,MAAM,GAAG,CAAC,CAAA;gBAC/D,OAAM;YACP,CAAC;QACF,CAAC;QACD,IAAI,CAAC,KAAK,GAAG;YACZ,MAAM;YACN,EAAE,EAAE,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,MAAM,EAAE,KAAK,CAAC;YAChD,KAAK,EAAE,IAAI,GAAG,EAAE;SAChB,CAAA;IACF,CAAC;IAED,KAAK,CAAC,OAAO;QACZ,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,cAAc,EAAE,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;QAClD,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI;YAAE,OAAM;QAE9B,6DAA6D;QAC7D,yCAAyC;QACzC,+DAA+D;QAC/D,iEAAiE;QACjE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAA;QACpC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;QACjB,uFAAuF;QACvF,KAAK,MAAM,UAAU,IAAI,KAAK,EAAE,CAAC;YAChC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,oCAAoC,EAAE,UAAU,CAAC,CAAA;YAClE,MAAM,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAA;QAC/D,CAAC;QACD,IAAI,CAAC;YACJ,MAAM,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAA;QACxC,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,+EAA+E;YAC/E,GAAG,CAAC,KAAK,CAAC,yCAAyC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAA;QAChE,CAAC;IACF,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,MAAc;QAC5B,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA;IACvC,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,KAAa,EAAE,MAAqC;QAC7D,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;IAC5C,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,KAAa,EAAE,MAAqC;QAC7D,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;IAC5C,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,KAAa,EAAE,MAAqC;QAC7D,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;IAC5C,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,kBAAkB,CAAC,MAAU;QAClC,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI;YAAE,OAAM;QAC9B,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAA;QACpC,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;YACvB,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,8BAA8B,CAAC,CAAA;YAChD,OAAM;QACP,CAAC;QACD;;;;WAIG;QACH,MAAM,IAAI,CAAC,UAAU,CAAC,kBAAkB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;QACxD,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;QACjB,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,EAAE,CAAC;YACxB,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,6DAA6D,CAAC,CAAA;YAC/E,MAAM,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;YAC1D,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;QACrB,CAAC;IACF,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,oBAAoB,CAAC,MAAU;QACpC,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI;YAAE,OAAM;QAC9B,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAA;QACpC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;YACxB,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,8CAA8C,CAAC,CAAA;YAChE,OAAM;QACP,CAAC;QACD,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;QACpB,MAAM,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAC3D,CAAC;IAEO,KAAK,CAAC,EAAE;QACf,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,EAAE,CAAC;YACxB,MAAM,IAAI,oBAAoB,EAAE,CAAA;QACjC,CAAC;QACD,OAAO,MAAM,IAAI,CAAC,KAAK,CAAC,EAAE,CAAA;IAC3B,CAAC;CACD","sourcesContent":["import { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { TaggedSqlValue } from \"../../api/worker/offline/SqlValue.js\"\nimport { ProgrammingError } from \"../../api/common/error/ProgrammingError.js\"\nimport { log } from \"../DesktopLog.js\"\nimport { OfflineDbClosedError } from \"../../api/common/error/OfflineDbClosedError.js\"\nimport { OfflineDbRefCounter } from \"./OfflineDbRefCounter.js\"\n\nconst TAG = \"[PerWindowSqlCipherFacade]\"\n\nexport interface OfflineDbFactory {\n\tcreate(userid: string, key: Uint8Array, retry?: boolean): Promise<SqlCipherFacade>\n\n\tdelete(userId: string): Promise<void>\n}\n\n/** class that holds the offlinedb reference for a single window. does not get recreated after logout.\n *\n * this works closely with the OfflineDbReferenceCounter to make sure that there's only one database connection\n * open for a given userId / database file.\n *\n * to ensure database integrity, there's also the locking of list ranges, which must be released before\n * dereferencing the database connection.\n * since the reference counter currently has no way of associating locks or references with windows,\n * this association is tracked in this class.\n *  */\nexport class PerWindowSqlCipherFacade implements SqlCipherFacade {\n\t/**\n\t * information about our db reference: which user it belongs to, the db itself, the currently held locks.\n\t * if this is not present, we hold no locks, are not waiting on locks and hold no db reference.\n\t * */\n\tprivate state: {\n\t\tuserId: string\n\t\tdb: Promise<SqlCipherFacade>\n\t\t/** the list of listIdRange locks that this window currently holds or is trying to acquire */\n\t\tlocks: Set<string>\n\t} | null = null\n\n\tconstructor(private readonly refCounter: OfflineDbRefCounter) {}\n\n\tasync openDb(userId: string, dbKey: Uint8Array): Promise<void> {\n\t\tlog.debug(TAG, \"open db for\", userId)\n\t\tif (this.state != null) {\n\t\t\tif (this.state.userId != userId) {\n\t\t\t\tthrow new ProgrammingError(`Already opened database for user ${this.state.userId} when trying to open db for ${userId}!`)\n\t\t\t} else {\n\t\t\t\tconsole.warn(`trying to open already opened db for ${userId}!`)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tthis.state = {\n\t\t\tuserId,\n\t\t\tdb: this.refCounter.getOrCreateDb(userId, dbKey),\n\t\t\tlocks: new Set(),\n\t\t}\n\t}\n\n\tasync closeDb(): Promise<void> {\n\t\tlog.debug(TAG, \"close db for\", this.state?.userId)\n\t\tif (this.state == null) return\n\n\t\t// if this method is called, we certainly don't want anything\n\t\t// to do anymore with this db connection.\n\t\t// so set the state to null before actually calling disposeDb()\n\t\t// otherwise, an error might prevent us from resetting the state.\n\t\tconst { userId, locks } = this.state\n\t\tthis.state = null\n\t\t// we can just unlock the locks now because there will not be coming any writes anymore\n\t\tfor (const lockedList of locks) {\n\t\t\tconsole.log(TAG, \"unlocking list before dereffing db\", lockedList)\n\t\t\tawait this.refCounter.unlockRangesDbAccess(userId, lockedList)\n\t\t}\n\t\ttry {\n\t\t\tawait this.refCounter.disposeDb(userId)\n\t\t} catch (e) {\n\t\t\t// we may or may not have released our reference, we'll just hope for the best.\n\t\t\tlog.debug(`failed to dispose offline Db for user ${userId}`, e)\n\t\t}\n\t}\n\n\tasync deleteDb(userId: string): Promise<void> {\n\t\tawait this.refCounter.deleteDb(userId)\n\t}\n\n\tasync get(query: string, params: ReadonlyArray<TaggedSqlValue>): Promise<Record<string, TaggedSqlValue> | null> {\n\t\treturn (await this.db()).get(query, params)\n\t}\n\n\tasync all(query: string, params: ReadonlyArray<TaggedSqlValue>): Promise<ReadonlyArray<Record<string, TaggedSqlValue>>> {\n\t\treturn (await this.db()).all(query, params)\n\t}\n\n\tasync run(query: string, params: ReadonlyArray<TaggedSqlValue>): Promise<void> {\n\t\treturn (await this.db()).run(query, params)\n\t}\n\n\t/**\n\t * We want to lock the access to the \"ranges\" db when updating / reading the\n\t * offline available mail list ranges for each mail list (referenced using the listId)\n\t * @param listId the mail list that we want to lock\n\t */\n\tasync lockRangesDbAccess(listId: Id): Promise<void> {\n\t\tif (this.state == null) return\n\t\tconst { userId, locks } = this.state\n\t\tif (locks.has(listId)) {\n\t\t\tconsole.log(TAG, \"tried to acquire lock twice!\")\n\t\t\treturn\n\t\t}\n\t\t/*\n\t\t * it's possible that we're waiting for a lock and then the window gets closed or reloads due to logout,\n\t\t * causing us to release our DB ref.\n\t\t * if the lock is then released by whoever holds it, we would acquire it but never release it.\n\t\t */\n\t\tawait this.refCounter.lockRangesDbAccess(userId, listId)\n\t\tlocks.add(listId)\n\t\tif (this.state == null) {\n\t\t\tconsole.log(TAG, \"ref was released while we were waiting for lock, unlocking.\")\n\t\t\tawait this.refCounter.unlockRangesDbAccess(userId, listId)\n\t\t\tlocks.delete(listId)\n\t\t}\n\t}\n\n\t/**\n\t * This is the counterpart to the function \"lockRangesDbAccess(listId)\"\n\t * @param listId the mail list that we want to unlock\n\t */\n\tasync unlockRangesDbAccess(listId: Id): Promise<void> {\n\t\tif (this.state == null) return\n\t\tconst { userId, locks } = this.state\n\t\tif (!locks.has(listId)) {\n\t\t\tconsole.log(TAG, \"tried to release lock that was not acquired!\")\n\t\t\treturn\n\t\t}\n\t\tlocks.delete(listId)\n\t\tawait this.refCounter.unlockRangesDbAccess(userId, listId)\n\t}\n\n\tprivate async db(): Promise<SqlCipherFacade> {\n\t\tif (this.state == null) {\n\t\t\tthrow new OfflineDbClosedError()\n\t\t}\n\t\treturn await this.state.db\n\t}\n}\n"]}