{"version":3,"file":"PriceUtils.js","sourceRoot":"","sources":["../../../../src/common/subscription/PriceUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { BookingItemFeatureType, Const, PaymentMethodType, PlanType, PlanTypeToName } from \"../api/common/TutanotaConstants\"\nimport { assertTranslation, lang, TranslationKey } from \"../misc/LanguageViewModel\"\nimport { assertNotNull, downcast, neverNull } from \"@tutao/tutanota-utils\"\nimport type { AccountingInfo, PlanPrices, PriceData, PriceItemData } from \"../api/entities/sys/TypeRefs.js\"\nimport { createUpgradePriceServiceData, UpgradePriceServiceReturn } from \"../api/entities/sys/TypeRefs.js\"\nimport { UpgradePriceType, WebsitePlanPrices } from \"./FeatureListProvider\"\nimport { UpgradePriceService } from \"../api/entities/sys/Services\"\nimport { IServiceExecutor } from \"../api/common/ServiceRequest\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\nimport { UserError } from \"../api/main/UserError.js\"\nimport { isIOSApp } from \"../api/common/Env\"\nimport { MobilePlanPrice } from \"../native/common/generatedipc/MobilePlanPrice\"\nimport { locator } from \"../api/main/CommonLocator.js\"\nimport { isReferenceDateWithinCyberMondayCampaign } from \"../misc/CyberMondayUtils.js\"\n\nexport const enum PaymentInterval {\n\tMonthly = 1,\n\tYearly = 12,\n}\n\nexport const enum PriceType {\n\tMonthlyPerMonth,\n\tYearlyPerMonth,\n\tYearlyPerYear,\n}\n\nexport function asPaymentInterval(paymentInterval: string | number): PaymentInterval {\n\tif (typeof paymentInterval === \"string\") {\n\t\tpaymentInterval = Number(paymentInterval)\n\t}\n\tswitch (paymentInterval) {\n\t\t// additional cast to make this robust against changes to the PaymentInterval enum.\n\t\tcase Number(PaymentInterval.Monthly):\n\t\t\treturn PaymentInterval.Monthly\n\t\tcase Number(PaymentInterval.Yearly):\n\t\t\treturn PaymentInterval.Yearly\n\t\tdefault:\n\t\t\tthrow new ProgrammingError(`invalid payment interval: ${paymentInterval}`)\n\t}\n}\n\nexport function getPaymentMethodName(paymentMethod: PaymentMethodType): string {\n\tif (paymentMethod === PaymentMethodType.Invoice) {\n\t\treturn lang.get(\"paymentMethodOnAccount_label\")\n\t} else if (paymentMethod === PaymentMethodType.CreditCard) {\n\t\treturn lang.get(\"paymentMethodCreditCard_label\")\n\t} else if (paymentMethod === PaymentMethodType.Sepa) {\n\t\treturn \"SEPA\"\n\t} else if (paymentMethod === PaymentMethodType.Paypal) {\n\t\treturn \"PayPal\"\n\t} else if (paymentMethod === PaymentMethodType.AccountBalance) {\n\t\treturn lang.get(\"paymentMethodAccountBalance_label\")\n\t} else if (paymentMethod === PaymentMethodType.AppStore) {\n\t\treturn \"App Store\"\n\t} else {\n\t\treturn \"<\" + lang.get(\"comboBoxSelectionNone_msg\") + \">\"\n\t}\n}\n\nexport function getPaymentMethodInfoText(accountingInfo: AccountingInfo): string {\n\tif (accountingInfo.paymentMethodInfo) {\n\t\treturn accountingInfo.paymentMethod === PaymentMethodType.CreditCard\n\t\t\t? lang.get(\"endsWith_label\") + \" \" + neverNull(accountingInfo.paymentMethodInfo)\n\t\t\t: neverNull(accountingInfo.paymentMethodInfo)\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nexport function formatPriceDataWithInfo(priceData: PriceData): string {\n\treturn formatPriceWithInfo(formatPrice(Number(priceData.price), true), asPaymentInterval(priceData.paymentInterval), priceData.taxIncluded)\n}\n\n// Used on website, keep it in sync\nexport function formatPrice(value: number, includeCurrency: boolean): string {\n\t// round to two digits first because small deviations may exist at far away decimal places\n\tvalue = Math.round(value * 100) / 100\n\n\tif (includeCurrency) {\n\t\treturn value % 1 !== 0 ? lang.formats.priceWithCurrency.format(value) : lang.formats.priceWithCurrencyWithoutFractionDigits.format(value)\n\t} else {\n\t\treturn value % 1 !== 0 ? lang.formats.priceWithoutCurrency.format(value) : lang.formats.priceWithoutCurrencyWithoutFractionDigits.format(value)\n\t}\n}\n\n/**\n * Formats the monthly price of the subscription (even for yearly subscriptions).\n */\nexport function formatMonthlyPrice(subscriptionPrice: number, paymentInterval: PaymentInterval): string {\n\tconst monthlyPrice = paymentInterval === PaymentInterval.Yearly ? subscriptionPrice / Number(PaymentInterval.Yearly) : subscriptionPrice\n\treturn formatPrice(monthlyPrice, true)\n}\n\n/**\n * Formats the yearly price for the full year (not monthly).\n */\nexport function formatPriceWithInfo(formattedPrice: string, paymentInterval: PaymentInterval, taxIncluded: boolean): string {\n\tconst netOrGross = taxIncluded ? lang.get(\"gross_label\") : lang.get(\"net_label\")\n\tconst yearlyOrMonthly = paymentInterval === PaymentInterval.Yearly ? lang.get(\"pricing.perYear_label\") : lang.get(\"pricing.perMonth_label\")\n\treturn `${formattedPrice} ${yearlyOrMonthly} (${netOrGross})`\n}\n\n/**\n * Provides the price item from the given priceData for the given featureType. Returns null if no such item is available.\n */\nexport function getPriceItem(priceData: PriceData | null, featureType: NumberString): PriceItemData | null {\n\treturn priceData?.items.find((item) => item.featureType === featureType) ?? null\n}\n\nexport function getCountFromPriceData(priceData: PriceData | null, featureType: BookingItemFeatureType): number {\n\tconst priceItem = getPriceItem(priceData, featureType)\n\treturn priceItem ? Number(priceItem.count) : 0\n}\n\n/**\n * Returns the price for the feature type from the price data if available. otherwise 0.\n * @return The price\n */\nexport function getPriceFromPriceData(priceData: PriceData | null, featureType: NumberString): number {\n\tlet item = getPriceItem(priceData, featureType)\n\n\tif (item) {\n\t\treturn Number(item.price)\n\t} else {\n\t\treturn 0\n\t}\n}\n\n// Contains the price of a subscription as both formatted and unformatted strings\nexport type SubscriptionPrice = {\n\t// The locale formatted price of a description in the local currency on iOS and in Euro elsewhere\n\tdisplayPrice: string\n\t// The raw price in the local currency on iOS and in Euro elsewhere as a float\n\trawPrice: string\n}\n\nexport class PriceAndConfigProvider {\n\tprivate upgradePriceData: UpgradePriceServiceReturn | null = null\n\tprivate planPrices: Array<PlanPrices> | null = null\n\tprivate isReferralCodeSignup: boolean = false\n\tprivate mobilePrices: Map<string, MobilePlanPrice> | null = null\n\n\tprivate constructor() {}\n\n\tprivate async init(registrationDataId: string | null, serviceExecutor: IServiceExecutor, referralCode: string | null): Promise<void> {\n\t\tconst data = createUpgradePriceServiceData({\n\t\t\tdate: Const.CURRENT_DATE,\n\t\t\tcampaign: registrationDataId,\n\t\t\treferralCode: referralCode,\n\t\t})\n\t\tthis.upgradePriceData = await serviceExecutor.get(UpgradePriceService, data)\n\t\tif (isIOSApp()) {\n\t\t\tthis.mobilePrices = new Map()\n\n\t\t\tconst allPrices = await locator.mobilePaymentsFacade.getPlanPrices()\n\t\t\tfor (const plan of allPrices) {\n\t\t\t\tthis.mobilePrices.set(plan.name, plan)\n\t\t\t}\n\t\t}\n\t\tthis.isReferralCodeSignup = referralCode != null\n\t\tthis.planPrices = this.upgradePriceData.plans\n\t}\n\n\tstatic async getInitializedInstance(\n\t\tregistrationDataId: string | null,\n\t\tserviceExecutor: IServiceExecutor,\n\t\treferralCode: string | null,\n\t): Promise<PriceAndConfigProvider> {\n\t\t// There should be only one method to request a discount either referralCode or a promotion\n\t\tif (referralCode != null && registrationDataId != null) {\n\t\t\tthrow new UserError(\"referralSignupCampaignError_msg\")\n\t\t}\n\n\t\tconst priceDataProvider = new PriceAndConfigProvider()\n\t\tawait priceDataProvider.init(registrationDataId, serviceExecutor, referralCode)\n\t\treturn priceDataProvider\n\t}\n\n\tgetSubscriptionPrice(paymentInterval: PaymentInterval, subscription: PlanType, type: UpgradePriceType): number {\n\t\treturn paymentInterval === PaymentInterval.Yearly\n\t\t\t? this.getYearlySubscriptionPrice(subscription, type)\n\t\t\t: this.getMonthlySubscriptionPrice(subscription, type)\n\t}\n\n\t/**\n\t * Returns the subscription price with the currency formatting on iOS and as a plain period seperated number on other platforms\n\t */\n\tgetSubscriptionPriceWithCurrency(paymentInterval: PaymentInterval, subscription: PlanType, type: UpgradePriceType): SubscriptionPrice {\n\t\tconst price = this.getSubscriptionPrice(paymentInterval, subscription, type)\n\t\tconst rawPrice = price.toString()\n\n\t\tif (isIOSApp()) {\n\t\t\treturn this.getAppStorePaymentsSubscriptionPrice(subscription, paymentInterval, rawPrice, type)\n\t\t} else {\n\t\t\tconst price = this.getSubscriptionPrice(paymentInterval, subscription, type)\n\t\t\treturn { displayPrice: formatPrice(price, true), rawPrice: price.toString() }\n\t\t}\n\t}\n\n\tprivate getAppStorePaymentsSubscriptionPrice(subscription: PlanType, paymentInterval: PaymentInterval, rawPrice: string, type: UpgradePriceType) {\n\t\tconst planName = PlanTypeToName[subscription]\n\t\tconst applePrices = this.getMobilePrices().get(planName.toLowerCase())\n\n\t\tif (!applePrices) {\n\t\t\tthrow new Error(`no such iOS plan ${planName}`)\n\t\t}\n\n\t\tconst isCyberMonday = isReferenceDateWithinCyberMondayCampaign(Const.CURRENT_DATE ?? new Date())\n\n\t\tswitch (paymentInterval) {\n\t\t\tcase PaymentInterval.Monthly:\n\t\t\t\treturn { displayPrice: applePrices.displayMonthlyPerMonth, rawPrice: applePrices.rawMonthlyPerMonth }\n\t\t\tcase PaymentInterval.Yearly:\n\t\t\t\treturn { displayPrice: applePrices.displayYearlyPerYear, rawPrice: applePrices.rawYearlyPerYear }\n\t\t}\n\t}\n\n\tgetRawPricingData(): UpgradePriceServiceReturn {\n\t\treturn assertNotNull(this.upgradePriceData)\n\t}\n\n\tprivate getYearlySubscriptionPrice(subscription: PlanType, upgrade: UpgradePriceType): number {\n\t\tconst prices = this.getPlanPricesForPlan(subscription)\n\t\tconst monthlyPrice = getPriceForUpgradeType(upgrade, prices)\n\t\tconst discount = upgrade === UpgradePriceType.PlanActualPrice ? Number(prices.firstYearDiscount) : 0\n\t\treturn monthlyPrice * 10 - discount\n\t}\n\n\tprivate getMonthlySubscriptionPrice(subscription: PlanType, upgrade: UpgradePriceType): number {\n\t\tconst prices = this.getPlanPricesForPlan(subscription)\n\t\treturn getPriceForUpgradeType(upgrade, prices)\n\t}\n\n\tgetMobilePrices(): Map<string, MobilePlanPrice> {\n\t\treturn assertNotNull(this.mobilePrices)\n\t}\n\n\tgetPlanPricesForPlan(subscription: PlanType): PlanPrices {\n\t\tconst planPrices = assertNotNull(this.planPrices, \"called getPlanPricesForPlan before init\")\n\t\treturn assertNotNull(\n\t\t\tplanPrices.find((prices) => PlanTypeToName[subscription] === prices.planName),\n\t\t\t\"plan type not found\",\n\t\t)\n\t}\n\n\tgetPriceInfoMessage(): TranslationKey | null {\n\t\tconst rawData = this.getRawPricingData()\n\t\tconst bonusMonthMessage = getReasonForBonusMonths(Number(rawData.bonusMonthsForYearlyPlan), this.isReferralCodeSignup)\n\t\tif (bonusMonthMessage) {\n\t\t\treturn bonusMonthMessage\n\t\t} else if (rawData.messageTextId) {\n\t\t\t// text id that is specified by a promotion.\n\t\t\treturn assertTranslation(rawData.messageTextId)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n}\n\nfunction getPriceForUpgradeType(upgrade: UpgradePriceType, prices: WebsitePlanPrices): number {\n\tswitch (upgrade) {\n\t\tcase UpgradePriceType.PlanReferencePrice:\n\t\t\treturn Number(prices.monthlyReferencePrice)\n\t\tcase UpgradePriceType.PlanActualPrice:\n\t\tcase UpgradePriceType.PlanNextYearsPrice:\n\t\t\treturn Number(prices.monthlyPrice)\n\t\tcase UpgradePriceType.AdditionalUserPrice:\n\t\t\treturn Number(prices.additionalUserPriceMonthly)\n\t\tcase UpgradePriceType.ContactFormPrice_UNUSED:\n\t\t\tthrow new ProgrammingError(\"invalid price type\")\n\t}\n}\n\nfunction descendingSubscriptionOrder(): Array<PlanType> {\n\treturn [PlanType.Unlimited, PlanType.Advanced, PlanType.Legend, PlanType.Essential, PlanType.Revolutionary]\n}\n\n/**\n * Returns true if the targetSubscription plan is considered to be a lower (~ cheaper) subscription plan\n * Is based on the order of business and non-business subscriptions as defined in descendingSubscriptionOrder\n */\nexport function isSubscriptionDowngrade(targetSubscription: PlanType, currentSubscription: PlanType): boolean {\n\tconst order = descendingSubscriptionOrder()\n\tif (Object.values(PlanType).includes(downcast(currentSubscription))) {\n\t\treturn order.indexOf(targetSubscription) > order.indexOf(downcast(currentSubscription))\n\t} else {\n\t\treturn false\n\t}\n}\n\n/**\n * Helper function to determine the reason for bonus months that have be provided by the UpgradePriceService\n * @param bonusMonths The amount of bonus month\n * @param isReferralCodeSignup Indication if a referral code has been used to query the bonus months.\n */\nfunction getReasonForBonusMonths(bonusMonths: number, isReferralCodeSignup: boolean): TranslationKey | null {\n\tif (bonusMonths == 12) {\n\t\treturn \"chooseYearlyForOffer_msg\"\n\t} else if (bonusMonths == 1) {\n\t\treturn \"referralSignup_msg\"\n\t} else if (bonusMonths == 0 && isReferralCodeSignup) {\n\t\treturn \"referralSignupInvalid_msg\"\n\t} else {\n\t\treturn null\n\t}\n}\n"]}