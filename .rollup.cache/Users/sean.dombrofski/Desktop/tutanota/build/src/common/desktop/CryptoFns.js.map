{"version":3,"file":"CryptoFns.js","sourceRoot":"","sources":["../../../../src/common/desktop/CryptoFns.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,OAAO,MAAM,MAAM,aAAa,CAAA;AAChC,OAAO,EAAE,cAAc,EAAE,MAAM,qCAAqC,CAAA;AAGpE,OAAO,EAEN,eAAe,EACf,UAAU,EACV,UAAU,EAEV,WAAW,EAEX,UAAU,EACV,MAAM,EACN,eAAe,EACf,yBAAyB,GACzB,MAAM,wBAAwB,CAAA;AAE/B,oDAAoD;AACpD,qDAAqD;AACrD,+EAA+E;AAC/E,8DAA8D;AAC9D,MAAM,IAAI,GAAG,GAAG,EAAE;IACjB,MAAM,OAAO,GAAG,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;IACvC,MAAM;SACJ,UAAU,CAAC;QACX;YACC,MAAM,EAAE,QAAQ;YAChB,OAAO,EAAE,GAAG,GAAG,CAAC;YAChB,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC;SACzB;KACD,CAAC;SACD,IAAI,EAAE,CAAA;AACT,CAAC,CAAA;AAED,IAAI,EAAE,CAAA;AAwBN,MAAM,MAAM,GAAG,IAAI,cAAc,EAAE,CAAA;AACnC,MAAM,CAAC,MAAM,SAAS,GAAoB;IACzC,UAAU,CAAC,GAAW,EAAE,KAAiB,EAAE,EAAe,EAAE,UAAoB,EAAE,MAAgB;QACjG,OAAO,UAAU,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,UAAU,EAAE,MAAM,CAAC,CAAA;IACtD,CAAC;IAED,UAAU,CAAC,GAAc,EAAE,cAA0B,EAAE,UAAmB;QACzE,OAAO,UAAU,CAAC,GAAG,EAAE,cAAc,EAAE,UAAU,CAAC,CAAA;IACnD,CAAC;IAED,yBAAyB,CAAC,GAAc,EAAE,cAA0B,EAAE,UAAmB;QACxF,OAAO,yBAAyB,CAAC,GAAG,EAAE,cAAc,EAAE,UAAU,CAAC,CAAA;IAClE,CAAC;IAED,UAAU,CAAC,aAAqB,EAAE,GAAe;QAChD,OAAO,UAAU,CAAC,aAAa,EAAE,GAAG,CAAC,CAAA;IACtC,CAAC;IAED,UAAU,CAAC,KAAiB;QAC3B,OAAO,eAAe,CAAC,KAAK,CAAC,CAAA;IAC9B,CAAC;IAED,WAAW,CAAC,MAAc;QACzB,OAAO,WAAW,CAAC,MAAM,CAAC,CAAA;IAC3B,CAAC;IAED;;OAEG;IACH,eAAe,CAAC,GAAW,EAAE,IAAgB,EAAE,SAAqB;QACnE,OAAO,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,EAAE,GAAG,EAAE,SAAS,CAAC,CAAA;IACrD,CAAC;IAED,WAAW,CAAC,UAAkB;QAC7B,IAAI,CAAC;YACJ,8CAA8C;YAC9C,OAAO,MAAM,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAA;QAC7C,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,IAAI,EAAE,CAAA;YACN,OAAO,MAAM,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAA;QAC7C,CAAC;IACF,CAAC;IAED,eAAe;QACd,OAAO,eAAe,EAAE,CAAA;IACzB,CAAC;IAED,uBAAuB,CAAI,KAAgB,EAAE,QAA6B,EAAE,EAAiB;QAC5F,OAAO,MAAM,CAAC,uBAAuB,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAA;IAC3D,CAAC;CACD,CAAA","sourcesContent":["/**\n * This is a wrapper for commonly used crypto functions, easier to inject/swap implementations and test.\n */\nimport crypto from \"node:crypto\"\nimport { InstanceMapper } from \"../api/worker/crypto/InstanceMapper\"\nimport type { TypeModel } from \"../api/common/EntityTypes\"\nimport type { Base64 } from \"@tutao/tutanota-utils\"\nimport {\n\tAes256Key,\n\taes256RandomKey,\n\taesDecrypt,\n\taesEncrypt,\n\tAesKey,\n\tbase64ToKey,\n\tBitArray,\n\tdecryptKey,\n\trandom,\n\tuint8ArrayToKey,\n\tunauthenticatedAesDecrypt,\n} from \"@tutao/tutanota-crypto\"\n\n// the prng throws if it doesn't have enough entropy\n// it may be called very early, so we need to seed it\n// we do it here because it's the first place in the dep. chain that knows it's\n// in node but the last one that knows the prng implementation\nconst seed = () => {\n\tconst entropy = crypto.randomBytes(128)\n\trandom\n\t\t.addEntropy([\n\t\t\t{\n\t\t\t\tsource: \"random\",\n\t\t\t\tentropy: 128 * 8,\n\t\t\t\tdata: Array.from(entropy),\n\t\t\t},\n\t\t])\n\t\t.then()\n}\n\nseed()\n\nexport interface CryptoFunctions {\n\taesEncrypt(key: AesKey, bytes: Uint8Array, iv?: Uint8Array, usePadding?: boolean, useMac?: boolean): Uint8Array\n\n\taesDecrypt(key: AesKey, encryptedBytes: Uint8Array, usePadding: boolean): Uint8Array\n\n\tunauthenticatedAesDecrypt(key: Aes256Key, encryptedBytes: Uint8Array, usePadding: boolean): Uint8Array\n\n\tdecryptKey(encryptionKey: AesKey, key: Uint8Array): AesKey\n\n\tbytesToKey(bytes: Uint8Array): BitArray\n\n\tbase64ToKey(base64: Base64): BitArray\n\n\tverifySignature(pubKeyPem: string, data: Uint8Array, signature: Uint8Array): boolean\n\n\trandomBytes(nbrOfBytes: number): Uint8Array\n\n\taes256RandomKey(): Aes256Key\n\n\tdecryptAndMapToInstance<T>(model: TypeModel, instance: Record<string, any>, sk: AesKey | null): Promise<T>\n}\n\nconst mapper = new InstanceMapper()\nexport const cryptoFns: CryptoFunctions = {\n\taesEncrypt(key: AesKey, bytes: Uint8Array, iv?: Uint8Array, usePadding?: boolean, useMac?: boolean): Uint8Array {\n\t\treturn aesEncrypt(key, bytes, iv, usePadding, useMac)\n\t},\n\n\taesDecrypt(key: Aes256Key, encryptedBytes: Uint8Array, usePadding: boolean): Uint8Array {\n\t\treturn aesDecrypt(key, encryptedBytes, usePadding)\n\t},\n\n\tunauthenticatedAesDecrypt(key: Aes256Key, encryptedBytes: Uint8Array, usePadding: boolean): Uint8Array {\n\t\treturn unauthenticatedAesDecrypt(key, encryptedBytes, usePadding)\n\t},\n\n\tdecryptKey(encryptionKey: AesKey, key: Uint8Array): AesKey {\n\t\treturn decryptKey(encryptionKey, key)\n\t},\n\n\tbytesToKey(bytes: Uint8Array): BitArray {\n\t\treturn uint8ArrayToKey(bytes)\n\t},\n\n\tbase64ToKey(base64: Base64): BitArray {\n\t\treturn base64ToKey(base64)\n\t},\n\n\t/**\n\t * verify a signature of some data with a given PEM-encoded spki public key\n\t */\n\tverifySignature(pem: string, data: Uint8Array, signature: Uint8Array): boolean {\n\t\treturn crypto.verify(\"SHA512\", data, pem, signature)\n\t},\n\n\trandomBytes(nbrOfBytes: number): Uint8Array {\n\t\ttry {\n\t\t\t// may fail if the entropy pools are exhausted\n\t\t\treturn random.generateRandomData(nbrOfBytes)\n\t\t} catch (e) {\n\t\t\tseed()\n\t\t\treturn random.generateRandomData(nbrOfBytes)\n\t\t}\n\t},\n\n\taes256RandomKey(): Aes256Key {\n\t\treturn aes256RandomKey()\n\t},\n\n\tdecryptAndMapToInstance<T>(model: TypeModel, instance: Record<string, any>, sk: AesKey | null): Promise<T> {\n\t\treturn mapper.decryptAndMapToInstance(model, instance, sk)\n\t},\n}\n"]}