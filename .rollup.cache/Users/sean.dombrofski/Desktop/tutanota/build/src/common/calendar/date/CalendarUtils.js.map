{"version":3,"file":"CalendarUtils.js","sourceRoot":"","sources":["../../../../../src/common/calendar/date/CalendarUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tassert,\n\tclone,\n\tdecodeBase64,\n\tdeepEqual,\n\tdowncast,\n\tfilterInt,\n\tfindAllAndRemove,\n\tgetFirstOrThrow,\n\tgetFromMap,\n\tgetStartOfDay,\n\tincrementDate,\n\tinsertIntoSortedArray,\n\tisNotNull,\n\tisSameDayOfDate,\n\tisValidDate,\n\tneverNull,\n\tTIMESTAMP_ZERO_YEAR,\n} from \"@tutao/tutanota-utils\"\nimport {\n\tCLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID,\n\tCLIENT_ONLY_CALENDARS,\n\tEndType,\n\tEventTextTimeOption,\n\tgetWeekStart,\n\tRepeatPeriod,\n\tTimeFormat,\n\tWeekStart,\n} from \"../../api/common/TutanotaConstants\"\nimport { DateTime, DurationLikeObject, FixedOffsetZone, IANAZone } from \"luxon\"\nimport {\n\tCalendarEvent,\n\tCalendarEventTypeRef,\n\tCalendarGroupRoot,\n\tCalendarRepeatRule,\n\tcreateCalendarRepeatRule,\n\tGroupSettings,\n\tUserSettingsGroupRoot,\n} from \"../../api/entities/tutanota/TypeRefs.js\"\nimport { CalendarEventTimes, DAYS_SHIFTED_MS, generateEventElementId, isAllDayEvent, isAllDayEventByTimes } from \"../../api/common/utils/CommonCalendarUtils\"\nimport { createDateWrapper, DateWrapper, GroupInfo, RepeatRule, User } from \"../../api/entities/sys/TypeRefs.js\"\nimport { isSameId } from \"../../api/common/utils/EntityUtils\"\nimport type { Time } from \"./Time.js\"\nimport { CalendarInfo } from \"../../../calendar-app/calendar/model/CalendarModel\"\nimport { DateProvider } from \"../../api/common/DateProvider\"\nimport { EntityClient } from \"../../api/common/EntityClient.js\"\nimport { CalendarEventUidIndexEntry } from \"../../api/worker/facades/lazy/CalendarFacade.js\"\nimport { ParserError } from \"../../misc/parsing/ParserCombinator.js\"\nimport { LoginController } from \"../../api/main/LoginController.js\"\nimport { BirthdayEventRegistry } from \"./CalendarEventsRepository.js\"\n\nexport type CalendarTimeRange = {\n\tstart: number\n\tend: number\n}\n\nexport function eventStartsBefore(currentDate: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventStart(event, zone).getTime() < currentDate.getTime()\n}\n\nexport function eventEndsBefore(date: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventEnd(event, zone).getTime() < date.getTime()\n}\n\nexport function eventStartsAfter(date: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventStart(event, zone).getTime() > date.getTime()\n}\n\nexport function eventEndsAfterDay(currentDate: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventEnd(event, zone).getTime() > getStartOfNextDayWithZone(currentDate, zone).getTime()\n}\n\nexport function eventEndsAfterOrOn(currentDate: Date, zone: string, event: CalendarEvent): boolean {\n\treturn getEventEnd(event, zone).getTime() >= getStartOfNextDayWithZone(currentDate, zone).getTime()\n}\n\nexport function generateUid(groupId: Id, timestamp: number): string {\n\treturn `${groupId}${timestamp}@tuta.com`\n}\n\nexport function isBirthdayEvent(uid?: string | null) {\n\treturn uid?.includes(CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID) ?? false\n}\n\n/** get the timestamps of the start date and end date of the month the given date is in. */\nexport function getMonthRange(date: Date, zone: string): CalendarTimeRange {\n\tconst startDateTime = DateTime.fromJSDate(date, {\n\t\tzone,\n\t}).set({\n\t\tday: 1,\n\t\thour: 0,\n\t\tminute: 0,\n\t\tsecond: 0,\n\t\tmillisecond: 0,\n\t})\n\tconst start = startDateTime.toJSDate().getTime()\n\tconst end = startDateTime\n\t\t.plus({\n\t\t\tmonth: 1,\n\t\t})\n\t\t.toJSDate()\n\t\t.getTime()\n\treturn {\n\t\tstart,\n\t\tend,\n\t}\n}\n\nexport function getDayRange(date: Date, zone: string): CalendarTimeRange {\n\tconst startDateTime = DateTime.fromJSDate(date, {\n\t\tzone,\n\t}).set({\n\t\thour: 0,\n\t\tminute: 0,\n\t\tsecond: 0,\n\t\tmillisecond: 0,\n\t})\n\tconst start = startDateTime.toJSDate().getTime()\n\tconst end = startDateTime\n\t\t.plus({\n\t\t\tday: 1,\n\t\t})\n\t\t.toJSDate()\n\t\t.getTime()\n\treturn {\n\t\tstart,\n\t\tend,\n\t}\n}\n\n/**\n * @param date a date object representing a calendar date (like 1st of May 2023 15:15) in {@param zone}\n * @param zone the time zone to calculate which calendar date {@param date} represents.\n * @returns a date object representing the beginning of the given day in local time, like 1st of May 2023 00:00)\n */\nexport function getStartOfDayWithZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }).toJSDate()\n}\n\n/** @param date a date object representing some time on some calendar date (like 1st of May 2023) in {@param zone}\n * @param zone the time zone for which to calculate the calendar date that {@param date} represents\n * @returns a date object representing the start of the next calendar date (2nd of May 2023 00:00) in {@param zone} */\nexport function getStartOfNextDayWithZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }).plus({ day: 1 }).toJSDate()\n}\n\nexport function getEndOfDayWithZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).set({ hour: 23, minute: 59, second: 59, millisecond: 0 }).toJSDate()\n}\n\nexport function calculateAlarmTime(date: Date, interval: AlarmInterval, ianaTimeZone?: string): Date {\n\tconst diff = alarmIntervalToLuxonDurationLikeObject(interval)\n\n\treturn DateTime.fromJSDate(date, {\n\t\tzone: ianaTimeZone,\n\t})\n\t\t.minus(diff)\n\t\t.toJSDate()\n}\n\n/** takes a date which encodes the day in UTC and produces a date that encodes the same date but in local time zone. All times must be 0. */\nexport function getAllDayDateForTimezone(utcDate: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(utcDate, { zone: \"utc\" })\n\t\t.setZone(zone, { keepLocalTime: true })\n\t\t.set({ hour: 0, minute: 0, second: 0, millisecond: 0 })\n\t\t.toJSDate()\n}\n\nexport function incrementByRepeatPeriod(date: Date, repeatPeriod: RepeatPeriod, interval: number, ianaTimeZone: string): Date {\n\tswitch (repeatPeriod) {\n\t\tcase RepeatPeriod.DAILY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tdays: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tcase RepeatPeriod.WEEKLY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tweeks: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tcase RepeatPeriod.MONTHLY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tmonths: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tcase RepeatPeriod.ANNUALLY:\n\t\t\treturn DateTime.fromJSDate(date, {\n\t\t\t\tzone: ianaTimeZone,\n\t\t\t})\n\t\t\t\t.plus({\n\t\t\t\t\tyears: interval,\n\t\t\t\t})\n\t\t\t\t.toJSDate()\n\n\t\tdefault:\n\t\t\tthrow new Error(\"Unknown repeat period\")\n\t}\n}\n\nexport function getValidTimeZone(zone: string, fallback?: string): string {\n\tif (IANAZone.isValidZone(zone)) {\n\t\treturn zone\n\t} else {\n\t\tif (fallback && IANAZone.isValidZone(fallback)) {\n\t\t\tconsole.warn(`Time zone ${zone} is not valid, falling back to ${fallback}`)\n\t\t\treturn fallback\n\t\t} else {\n\t\t\tconst actualFallback = FixedOffsetZone.instance(new Date().getTimezoneOffset()).name\n\t\t\tconsole.warn(`Fallback time zone ${zone} is not valid, falling back to ${actualFallback}`)\n\t\t\treturn actualFallback\n\t\t}\n\t}\n}\n\nexport function getTimeZone(): string {\n\treturn DateTime.local().zoneName\n}\n\nexport class DefaultDateProvider implements DateProvider {\n\tnow(): number {\n\t\treturn Date.now()\n\t}\n\n\ttimeZone(): string {\n\t\treturn getTimeZone()\n\t}\n}\n\nexport function createRepeatRuleWithValues(frequency: RepeatPeriod, interval: number, timeZone: string = getTimeZone()): CalendarRepeatRule {\n\treturn createCalendarRepeatRule({\n\t\ttimeZone: timeZone,\n\t\tfrequency: frequency,\n\t\tinterval: String(interval),\n\t\tendValue: null,\n\t\tendType: \"0\",\n\t\texcludedDates: [],\n\t\tadvancedRules: [],\n\t})\n}\n\n/**\n * difference in whole 24-hour-intervals between two dates, not anticommutative.\n * Result is positive or 0 if b > a, result is negative or 0 otherwise\n */\nexport function getDiffIn24hIntervals(a: Date, b: Date, zone?: string): number {\n\treturn Math.floor(DateTime.fromJSDate(b, { zone }).diff(DateTime.fromJSDate(a, { zone }), \"day\").days)\n}\n\n/**\n * difference in whole 60 minute intervals between two dates\n * result is 0 if the diff is less than 60 minutes, otherwise\n * positive if b is after a, otherwise negative.\n *\n * not anticommutative.\n */\nexport function getDiffIn60mIntervals(a: Date, b: Date): number {\n\treturn Math.floor(DateTime.fromJSDate(b).diff(DateTime.fromJSDate(a), \"hours\").hours)\n}\n\nexport function getStartOfWeek(date: Date, firstDayOfWeekFromOffset: number): Date {\n\tlet firstDay\n\n\tif (firstDayOfWeekFromOffset > date.getDay()) {\n\t\tfirstDay = date.getDay() + 7 - firstDayOfWeekFromOffset\n\t} else {\n\t\tfirstDay = date.getDay() - firstDayOfWeekFromOffset\n\t}\n\n\treturn incrementDate(getStartOfDay(date), -firstDay)\n}\n\nexport function getRangeOfDays(startDay: Date, numDays: number): Array<Date> {\n\tlet calculationDate = startDay\n\tconst days: Date[] = []\n\n\tfor (let i = 0; i < numDays; i++) {\n\t\tdays.push(calculationDate)\n\t\tcalculationDate = incrementDate(new Date(calculationDate), 1)\n\t}\n\n\treturn days\n}\n\n/** Start of the week offset relative to Sunday (forward). */\nexport function getStartOfTheWeekOffset(weekStart: WeekStart): number {\n\tswitch (weekStart) {\n\t\tcase WeekStart.SUNDAY:\n\t\t\treturn 0\n\n\t\tcase WeekStart.SATURDAY:\n\t\t\treturn 6\n\n\t\tcase WeekStart.MONDAY:\n\t\tdefault:\n\t\t\treturn 1\n\t}\n}\n\n/** {@see getStartOfTheWeekOffset} */\nexport function getStartOfTheWeekOffsetForUser(userSettingsGroupRoot: UserSettingsGroupRoot): number {\n\treturn getStartOfTheWeekOffset(getWeekStart(userSettingsGroupRoot))\n}\n\nexport function getTimeFormatForUser(userSettingsGroupRoot: UserSettingsGroupRoot): TimeFormat {\n\t// it's saved as a string, but is a const enum.\n\treturn userSettingsGroupRoot.timeFormat as TimeFormat\n}\n\nexport function getWeekNumber(startOfTheWeek: Date): number {\n\t// Currently it doesn't support US-based week numbering system with partial weeks.\n\treturn DateTime.fromJSDate(startOfTheWeek).weekNumber\n}\n\nexport function getEventEnd(event: CalendarEventTimes, timeZone: string): Date {\n\tif (isAllDayEvent(event)) {\n\t\treturn getAllDayDateForTimezone(event.endTime, timeZone)\n\t} else {\n\t\treturn event.endTime\n\t}\n}\n\nexport function getEventStart({ startTime, endTime }: CalendarEventTimes, timeZone: string): Date {\n\treturn getEventStartByTimes(startTime, endTime, timeZone)\n}\n\nexport function getEventStartByTimes(startTime: Date, endTime: Date, timeZone: string): Date {\n\tif (isAllDayEventByTimes(startTime, endTime)) {\n\t\treturn getAllDayDateForTimezone(startTime, timeZone)\n\t} else {\n\t\treturn startTime\n\t}\n}\n\n/** @param date encodes some calendar date in {@param zone} (like the 1st of May 2023)\n * @returns {Date} encodes the same calendar date in UTC */\nexport function getAllDayDateUTCFromZone(date: Date, zone: string): Date {\n\treturn DateTime.fromJSDate(date, { zone }).setZone(\"utc\", { keepLocalTime: true }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }).toJSDate()\n}\n\nexport function isLongEvent(event: CalendarEvent, zone: string): boolean {\n\t// long events are longer than the event ID randomization range. we need to distinguish them\n\t// to be able to still load and display the ones overlapping the query range even though their\n\t// id might not be contained in the query timerange +- randomization range.\n\t// this also applies to events that repeat.\n\treturn event.repeatRule != null || getEventEnd(event, zone).getTime() - getEventStart(event, zone).getTime() > DAYS_SHIFTED_MS\n}\n\n/** create an event id depending on the calendar it is in and on its length */\nexport function assignEventId(event: CalendarEvent, zone: string, groupRoot: CalendarGroupRoot): void {\n\tconst listId = isLongEvent(event, zone) ? groupRoot.longEvents : groupRoot.shortEvents\n\tevent._id = [listId, generateEventElementId(event.startTime.getTime())]\n}\n\n/** predicate that tells us if two CalendarEvent objects refer to the same instance or different ones.*/\nexport function isSameEventInstance(left: Pick<CalendarEvent, \"_id\" | \"startTime\">, right: Pick<CalendarEvent, \"_id\" | \"startTime\">): boolean {\n\t// in addition to the id we compare the start time equality to be able to distinguish repeating events. They have the same id but different start time.\n\t// altered events with recurrenceId never have the same Id as another event instance, but might start at the same time.\n\treturn isSameId(left._id, right._id) && left.startTime.getTime() === right.startTime.getTime()\n}\n\nexport function hasAlarmsForTheUser(user: User, event: CalendarEvent): boolean {\n\tconst useAlarmList = neverNull(user.alarmInfoList).alarms\n\treturn event.alarmInfos.some(([listId]) => isSameId(listId, useAlarmList))\n}\n\nexport function eventComparator(l: CalendarEvent, r: CalendarEvent): number {\n\treturn l.startTime.getTime() - r.startTime.getTime()\n}\n\nfunction assertDateIsValid(date: Date) {\n\tif (!isValidDate(date)) {\n\t\tthrow new Error(\"Date is invalid!\")\n\t}\n}\n\n/**\n * we don't want to deal with some calendar event edge cases,\n * like pre-1970 events that would have negative timestamps.\n * during import, we can also get faulty events that are\n * impossible to create through the interface.\n */\nexport const enum CalendarEventValidity {\n\tInvalidContainsInvalidDate,\n\tInvalidEndBeforeStart,\n\tInvalidPre1970,\n\tValid,\n}\n\n/**\n * check if a given event should be allowed to be created in a tutanota calendar.\n * @param event\n * @returns Enum describing the reason to reject the event, if any.\n */\nexport function checkEventValidity(event: CalendarEvent): CalendarEventValidity {\n\tif (!isValidDate(event.startTime) || !isValidDate(event.endTime)) {\n\t\treturn CalendarEventValidity.InvalidContainsInvalidDate\n\t} else if (event.endTime.getTime() <= event.startTime.getTime()) {\n\t\treturn CalendarEventValidity.InvalidEndBeforeStart\n\t} else if (event.startTime.getTime() < TIMESTAMP_ZERO_YEAR) {\n\t\treturn CalendarEventValidity.InvalidPre1970\n\t}\n\treturn CalendarEventValidity.Valid\n}\n\nconst MAX_EVENT_ITERATIONS = 10000\n\n/**\n * add the days the given {@param event} is happening on during the given {@param range} to {@param daysToEvents}.\n *\n * ignores repeat rules.\n * @param zone\n */\nexport function addDaysForEventInstance(daysToEvents: Map<number, Array<CalendarEvent>>, event: CalendarEvent, range: CalendarTimeRange, zone: string) {\n\tconst { start: rangeStart, end: rangeEnd } = range\n\tconst clippedRange = clipRanges(getEventStart(event, zone).getTime(), getEventEnd(event, zone).getTime(), rangeStart, rangeEnd)\n\t// the event and range do not intersect\n\tif (clippedRange == null) return\n\tconst { start: eventStartInRange, end: eventEndInRange } = clippedRange\n\tlet calculationDate = getStartOfDayWithZone(new Date(eventStartInRange), zone)\n\tlet calculationTime = calculationDate.getTime()\n\tlet iterations = 0\n\n\twhile (calculationTime < rangeEnd) {\n\t\tassertDateIsValid(calculationDate)\n\t\tassert(iterations <= MAX_EVENT_ITERATIONS, \"Run into the infinite loop, addDaysForEvent\")\n\t\tif (calculationTime < eventEndInRange) {\n\t\t\tconst eventsForCalculationDate = getFromMap(daysToEvents, calculationTime, () => [])\n\t\t\tinsertIntoSortedArray(event, eventsForCalculationDate, eventComparator, isSameEventInstance)\n\t\t} else {\n\t\t\t// If the duration of the original event instance was reduced, we also have to delete the remaining days of the previous event instance.\n\t\t\tconst removed = findAllAndRemove(\n\t\t\t\tgetFromMap(daysToEvents, calculationTime, () => []),\n\t\t\t\t(e) => isSameEventInstance(e, event),\n\t\t\t)\n\t\t\tif (!removed) {\n\t\t\t\t// no further days this event instance occurred on\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tcalculationDate = incrementByRepeatPeriod(calculationDate, RepeatPeriod.DAILY, 1, zone)\n\t\tcalculationTime = calculationDate.getTime()\n\t\titerations++\n\t}\n}\n\n/** add the days a repeating {@param event} occurs on during {@param range} to {@param daysToEvents} by calling addDaysForEventInstance() for each of its\n * non-excluded instances.\n * @param timeZone\n */\nexport function addDaysForRecurringEvent(\n\tdaysToEvents: Map<number, Array<CalendarEvent>>,\n\tevent: CalendarEvent,\n\trange: CalendarTimeRange,\n\ttimeZone: string = getTimeZone(),\n) {\n\tconst repeatRule = event.repeatRule\n\n\tif (repeatRule == null) {\n\t\tthrow new Error(\"Invalid argument: event doesn't have a repeatRule\" + JSON.stringify(event))\n\t}\n\tconst allDay = isAllDayEvent(event)\n\tconst exclusions = allDay\n\t\t? repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateForTimezone(date, timeZone) }))\n\t\t: repeatRule.excludedDates\n\n\tfor (const { startTime, endTime } of generateEventOccurrences(event, timeZone)) {\n\t\tif (startTime.getTime() > range.end) break\n\t\tif (endTime.getTime() < range.start) continue\n\t\tif (isExcludedDate(startTime, exclusions)) {\n\t\t\tconst eventsOnExcludedDay = daysToEvents.get(getStartOfDayWithZone(startTime, timeZone).getTime())\n\t\t\tif (!eventsOnExcludedDay) continue\n\t\t} else {\n\t\t\tconst eventClone = clone(event)\n\t\t\tif (allDay) {\n\t\t\t\teventClone.startTime = getAllDayDateUTCFromZone(startTime, timeZone)\n\t\t\t\teventClone.endTime = getAllDayDateUTCFromZone(endTime, timeZone)\n\t\t\t} else {\n\t\t\t\teventClone.startTime = new Date(startTime)\n\t\t\t\teventClone.endTime = new Date(endTime)\n\t\t\t}\n\t\t\taddDaysForEventInstance(daysToEvents, eventClone, range, timeZone)\n\t\t}\n\t}\n}\n\n/**\n * get all instances of all series in a list of event series progenitors that intersect with the given range.\n * will return a sorted array of instances (by start time), interleaving the series if necessary.\n *\n */\nexport function generateCalendarInstancesInRange(\n\tprogenitors: ReadonlyArray<CalendarEvent>,\n\trange: CalendarTimeRange,\n\tmax: number = Infinity,\n\ttimeZone: string = getTimeZone(),\n): Array<CalendarEvent> {\n\tconst ret: Array<CalendarEvent> = []\n\n\tconst getNextCandidate = (\n\t\tpreviousCandidate: CalendarEvent,\n\t\tgenerator: Generator<{\n\t\t\tstartTime: Date\n\t\t\tendTime: Date\n\t\t}>,\n\t\texcludedDates: Array<DateWrapper>,\n\t) => {\n\t\tconst allDay = isAllDayEvent(previousCandidate)\n\t\tconst exclusions = allDay ? excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateForTimezone(date, timeZone) })) : excludedDates\n\t\tlet current\n\n\t\t// not using for-of because that automatically closes the generator\n\t\t// when breaking or returning, and we want to suspend and resume iteration.\n\t\twhile (ret.length < max) {\n\t\t\tcurrent = generator.next()\n\n\t\t\tif (current.done) break\n\n\t\t\tlet { startTime, endTime } = current.value\n\t\t\tif (startTime.getTime() > range.end) break\n\t\t\t// using \"<=\" because an all-day-event that lasts n days spans n+1 days,\n\t\t\t// ending at midnight utc on the day after. So they seem to intersect\n\t\t\t// the range if it starts on the day after the event ends.\n\t\t\tif (endTime.getTime() <= range.start) continue\n\n\t\t\tif (!isExcludedDate(startTime, exclusions)) {\n\t\t\t\tconst nextCandidate = clone(previousCandidate)\n\t\t\t\tif (allDay) {\n\t\t\t\t\tnextCandidate.startTime = getAllDayDateUTCFromZone(startTime, timeZone)\n\t\t\t\t\tnextCandidate.endTime = getAllDayDateUTCFromZone(endTime, timeZone)\n\t\t\t\t} else {\n\t\t\t\t\tnextCandidate.startTime = new Date(startTime)\n\t\t\t\t\tnextCandidate.endTime = new Date(endTime)\n\t\t\t\t}\n\t\t\t\treturn nextCandidate\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\t// we need to have one candidate for each series and then check which one gets added first.\n\t// if we added one, we advance the generator that generated it to the next candidate and repeat.\n\tconst generators: Array<{\n\t\tgenerator: Generator<{ startTime: Date; endTime: Date }>\n\t\texcludedDates: Array<DateWrapper>\n\t\tnextCandidate: CalendarEvent\n\t}> = progenitors\n\t\t.map((p) => {\n\t\t\tconst generator = generateEventOccurrences(p, timeZone)\n\t\t\tconst excludedDates = p.repeatRule?.excludedDates ?? []\n\t\t\tconst nextCandidate = getNextCandidate(p, generator, excludedDates)\n\t\t\tif (nextCandidate == null) return null\n\t\t\treturn {\n\t\t\t\texcludedDates,\n\t\t\t\tgenerator,\n\t\t\t\tnextCandidate,\n\t\t\t}\n\t\t})\n\t\t.filter(isNotNull)\n\n\twhile (generators.length > 0) {\n\t\t// performance: put the smallest nextCandidate in front. we only change the first item in each iteration, so this should be quick to re-sort.\n\t\t// still O(n²) in the best case >:(\n\t\t// we might improve runtime here by re-inserting the new nextCandidate into the list manually using a linear or binary search instead of invoking\n\t\t// sort.\n\t\t// we can then also maintain an index to the first still-open generator instead of splicing out the first generator when it stops yielding instances.\n\t\tgenerators.sort((a, b) => (a.nextCandidate?.startTime.getTime() ?? 0) - (b.nextCandidate?.startTime.getTime() ?? 0))\n\t\tconst first = getFirstOrThrow(generators)\n\t\tconst newNext = getNextCandidate(first.nextCandidate, first.generator, first.excludedDates)\n\n\t\tret.push(first.nextCandidate)\n\n\t\tif (newNext == null) {\n\t\t\tgenerators.splice(0, 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tfirst.nextCandidate = newNext\n\t}\n\treturn ret\n}\n\n/**\n * Returns the end date of a repeating rule that can be used to display in the ui.\n *\n * The actual end date that is stored on the repeat rule is always one day behind the displayed end date:\n * * for all-day events:\n *   - displayed end date: 2023-05-18\n *   - last occurrence can be: 2023-05-18\n *   - exported end date: 2023-05-18\n *   - actual timestamp on the entity: Midnight UTC 2023-05-19 (start of day)\n * * normal events behave the same except:\n *   - actual timestamp on the entity is Midnight local timezone 2023-05-19 (start of day)\n * @returns {Date}\n */\nexport function getRepeatEndTimeForDisplay(repeatRule: RepeatRule, isAllDay: boolean, timeZone: string): Date {\n\tif (repeatRule.endType !== EndType.UntilDate) {\n\t\tthrow new Error(\"Event has no repeat rule end type is not UntilDate: \" + JSON.stringify(repeatRule))\n\t}\n\n\tconst rawEndDate = new Date(filterInt(repeatRule.endValue ?? \"0\"))\n\tconst localDate = isAllDay ? getAllDayDateForTimezone(rawEndDate, timeZone) : rawEndDate\n\t// Shown date is one day behind the actual end (but it is still excluded)\n\treturn incrementByRepeatPeriod(localDate, RepeatPeriod.DAILY, -1, timeZone)\n}\n\n/**\n * generates all event occurrences in chronological order, including the progenitor.\n * terminates once the end condition of the repeat rule is hit.\n * @param event the event to iterate occurrences on.\n * @param timeZone\n */\nfunction* generateEventOccurrences(event: CalendarEvent, timeZone: string): Generator<{ startTime: Date; endTime: Date }> {\n\tconst { repeatRule } = event\n\n\tif (repeatRule == null) {\n\t\tyield event\n\t\treturn\n\t}\n\n\tconst frequency: RepeatPeriod = downcast(repeatRule.frequency)\n\tconst interval = Number(repeatRule.interval)\n\tlet eventStartTime = getEventStart(event, timeZone)\n\tlet eventEndTime = getEventEnd(event, timeZone)\n\t// Loop by the frequency step\n\tlet repeatEndTime: Date | null = null\n\tlet endOccurrences: number | null = null\n\tconst allDay = isAllDayEvent(event)\n\t// For all-day events we should rely on the local time zone or at least we must use the same zone as in getAllDayDateUTCFromZone\n\t// below. If they are not in sync, then daylight saving shifts may cause us to extract wrong UTC date (day in repeat rule zone and in\n\t// local zone may be different).\n\tconst repeatTimeZone = allDay ? timeZone : getValidTimeZone(repeatRule.timeZone)\n\n\tif (repeatRule.endType === EndType.Count) {\n\t\tendOccurrences = Number(repeatRule.endValue)\n\t} else if (repeatRule.endType === EndType.UntilDate) {\n\t\t// See CalendarEventDialog for an explanation why it's needed\n\t\tif (allDay) {\n\t\t\trepeatEndTime = getAllDayDateForTimezone(new Date(Number(repeatRule.endValue)), timeZone)\n\t\t} else {\n\t\t\trepeatEndTime = new Date(Number(repeatRule.endValue))\n\t\t}\n\t}\n\n\tlet calcStartTime = eventStartTime\n\tconst calcDuration = allDay ? getDiffIn24hIntervals(eventStartTime, eventEndTime, timeZone) : eventEndTime.getTime() - eventStartTime.getTime()\n\tlet calcEndTime = eventEndTime\n\tlet iteration = 1\n\n\twhile ((endOccurrences == null || iteration <= endOccurrences) && (repeatEndTime == null || calcStartTime.getTime() < repeatEndTime.getTime())) {\n\t\tassertDateIsValid(calcStartTime)\n\t\tassertDateIsValid(calcEndTime)\n\t\tyield { startTime: calcStartTime, endTime: calcEndTime }\n\n\t\tcalcStartTime = incrementByRepeatPeriod(eventStartTime, frequency, interval * iteration, repeatTimeZone)\n\t\tcalcEndTime = allDay\n\t\t\t? incrementByRepeatPeriod(calcStartTime, RepeatPeriod.DAILY, calcDuration, repeatTimeZone)\n\t\t\t: DateTime.fromJSDate(calcStartTime).plus(calcDuration).toJSDate()\n\t\titeration++\n\t}\n}\n\n/**\n * return true if an event has more than one visible occurrence according to its repeat rule and excluded dates\n *\n * will compare exclusion time stamps with the exact date-time value of the occurrences startTime\n *\n * @param event the calendar event to check. to get correct results, this must be the progenitor.\n */\nexport function calendarEventHasMoreThanOneOccurrencesLeft({ progenitor, alteredInstances }: CalendarEventUidIndexEntry): boolean {\n\tif (progenitor == null) {\n\t\t// this may happen if we accept multiple invites to altered instances without ever getting the progenitor.\n\t\treturn alteredInstances.length > 1\n\t}\n\tconst { repeatRule } = progenitor\n\tif (repeatRule == null) {\n\t\treturn false\n\t}\n\n\tconst { endType, endValue, excludedDates } = repeatRule\n\tif (endType === EndType.Never) {\n\t\t// there are infinite occurrences\n\t\treturn true\n\t} else if (endType === EndType.Count && Number(endValue ?? \"0\") + alteredInstances.length > excludedDates.length + 1) {\n\t\t// if there are not enough exclusions to delete all but one occurrence, we can return true\n\t\treturn true\n\t} else if (alteredInstances.length > 1) {\n\t\treturn true\n\t} else {\n\t\t// we need to count occurrences and match them up against altered instances & exclusions.\n\t\tconst excludedTimestamps = excludedDates.map(({ date }) => date.getTime())\n\t\tlet i = 0\n\t\t// in our model, we have an extra exclusion for each altered instance. this code\n\t\t// assumes that this invariant is upheld here and does not match each recurrenceId\n\t\t// against an exclusion, but only tallies them up.\n\t\tlet occurrencesFound = alteredInstances.length\n\t\tfor (const { startTime } of generateEventOccurrences(progenitor, getTimeZone())) {\n\t\t\tconst startTimestamp = startTime.getTime()\n\t\t\twhile (i < excludedTimestamps.length && startTimestamp > excludedTimestamps[i]) {\n\t\t\t\t// exclusions are sorted\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\tif (startTimestamp !== excludedTimestamps[i]) {\n\t\t\t\t// we found the place in the array where the startTimestamp would\n\t\t\t\t// be if it were in the array\n\t\t\t\toccurrencesFound += 1\n\t\t\t\tif (occurrencesFound > 1) return true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n}\n\n/**\n * find out if a given date is in a list of excluded dates\n * @param currentDate the date to check\n * @param excludedDates a sorted list of excluded dates, earliest to latest\n */\nfunction isExcludedDate(currentDate: Date, excludedDates: ReadonlyArray<DateWrapper> = []): boolean {\n\treturn excludedDates.some((dw) => dw.date.getTime() === currentDate.getTime())\n}\n\nexport type AlarmOccurrence = {\n\talarmTime: Date\n\toccurrenceNumber: number\n\teventTime: Date\n}\n\nexport function findNextAlarmOccurrence(\n\tnow: Date,\n\ttimeZone: string,\n\teventStart: Date,\n\teventEnd: Date,\n\tfrequency: RepeatPeriod,\n\tinterval: number,\n\tendType: EndType,\n\tendValue: number,\n\texclusions: Array<Date>,\n\talarmTrigger: AlarmInterval,\n\tlocalTimeZone: string,\n): AlarmOccurrence | null {\n\tlet occurrenceNumber = 0\n\tconst isAllDayEvent = isAllDayEventByTimes(eventStart, eventEnd)\n\tconst calcEventStart = isAllDayEvent ? getAllDayDateForTimezone(eventStart, localTimeZone) : eventStart\n\tassertDateIsValid(calcEventStart)\n\tconst endDate = endType === EndType.UntilDate ? (isAllDayEvent ? getAllDayDateForTimezone(new Date(endValue), localTimeZone) : new Date(endValue)) : null\n\n\twhile (endType !== EndType.Count || occurrenceNumber < endValue) {\n\t\tconst occurrenceDate = incrementByRepeatPeriod(calcEventStart, frequency, interval * occurrenceNumber, isAllDayEvent ? localTimeZone : timeZone)\n\t\tif (endDate && occurrenceDate.getTime() >= endDate.getTime()) {\n\t\t\treturn null\n\t\t}\n\n\t\tif (!exclusions.some((d) => d.getTime() === occurrenceDate.getTime())) {\n\t\t\tconst alarmTime = calculateAlarmTime(occurrenceDate, alarmTrigger, localTimeZone)\n\n\t\t\tif (alarmTime >= now) {\n\t\t\t\treturn {\n\t\t\t\t\talarmTime,\n\t\t\t\t\toccurrenceNumber: occurrenceNumber,\n\t\t\t\t\teventTime: occurrenceDate,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toccurrenceNumber++\n\t}\n\treturn null\n}\n\n/** */\nexport type CalendarDay = {\n\tdate: Date\n\tyear: number\n\tmonth: number\n\tday: number\n\t/** days that are technically not part of the current month, but are shown to fill the grid. */\n\tisPaddingDay: boolean\n}\n\nexport type CalendarMonth = {\n\tweekdays: ReadonlyArray<string>\n\tweeks: ReadonlyArray<ReadonlyArray<CalendarDay>>\n\t/** the 1st of the month, might not be the first date in {@link weeks} because of the padding days. */\n\tbeginningOfMonth: Date\n}\n\n/**\n *\n * https://www.kanzaki.com/docs/ical/sequence.html\n * The \"Organizer\" includes this property in an iCalendar object that it sends to an\n * \"Attendee\" to specify the current version of the calendar component.\n *\n * The \"Attendee\" includes this property in an iCalendar object that it sends to the \"Organizer\"\n * to specify the version of the calendar component that the \"Attendee\" is referring to.\n *\n * @param sequence\n */\nexport function incrementSequence(sequence: string): string {\n\tconst current = filterInt(sequence) || 0\n\t// Only the organizer should increase sequence numbers\n\treturn String(current + 1)\n}\n\nexport function findFirstPrivateCalendar(calendarInfo: ReadonlyMap<Id, CalendarInfo>): CalendarInfo | null {\n\tfor (const calendar of calendarInfo.values()) {\n\t\tif (calendar.userIsOwner && !calendar.isExternal) return calendar\n\t}\n\treturn null\n}\n\n/**\n * Prepare calendar event description to be shown to the user.\n *\n * It is needed to fix special format of links from Outlook which otherwise disappear during sanitizing.\n * They look like this:\n * ```\n * text<https://example.com>\n * ```\n *\n * @param description description to clean up\n * @param sanitizer optional sanitizer to apply after preparing the description\n */\nexport function prepareCalendarDescription(description: string, sanitizer: (s: string) => string): string {\n\tconst prepared = description.replace(/<(http|https):\\/\\/[A-z0-9$-_.+!*‘(),/?]+>/gi, (possiblyLink) => {\n\t\ttry {\n\t\t\tconst withoutBrackets = possiblyLink.slice(1, -1)\n\t\t\tconst url = new URL(withoutBrackets)\n\t\t\treturn `<a href=\"${url.toString()}\">${withoutBrackets}</a>`\n\t\t} catch (e) {\n\t\t\treturn possiblyLink\n\t\t}\n\t})\n\n\treturn sanitizer(prepared)\n}\n\nexport const DEFAULT_HOUR_OF_DAY = 6\n\n/** Get CSS class for the date element. */\nexport function getDateIndicator(day: Date, selectedDate: Date | null): string {\n\tif (isSameDayOfDate(day, selectedDate)) {\n\t\treturn \".accent-bg.circle\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\n/**\n * Determine what format the time of an event should be rendered in given a surrounding time period\n */\nexport function getTimeTextFormatForLongEvent(ev: CalendarEvent, startDay: Date, endDay: Date, zone: string): EventTextTimeOption | null {\n\tconst startsBefore = eventStartsBefore(startDay, zone, ev)\n\tconst endsAfter = eventEndsAfterOrOn(endDay, zone, ev)\n\n\tif ((startsBefore && endsAfter) || isAllDayEvent(ev)) {\n\t\treturn null\n\t} else if (startsBefore && !endsAfter) {\n\t\treturn EventTextTimeOption.END_TIME\n\t} else if (!startsBefore && endsAfter) {\n\t\treturn EventTextTimeOption.START_TIME\n\t} else {\n\t\treturn EventTextTimeOption.START_END_TIME\n\t}\n}\n\n/**\n * Creates a new date with the year, month and day from the Date and the hours and minutes from the Time\n * @param date\n * @param time\n */\nexport function combineDateWithTime(date: Date, time: Time): Date {\n\tconst newDate = new Date(date)\n\tnewDate.setHours(time.hour)\n\tnewDate.setMinutes(time.minute)\n\treturn newDate\n}\n\n/**\n * Check if an event occurs during some time period of days, either partially or entirely\n * Expects that firstDayOfWeek is before lastDayOfWeek, and that event starts before it ends, otherwise result is invalid\n */\nexport function isEventBetweenDays(event: CalendarEvent, firstDay: Date, lastDay: Date, zone: string): boolean {\n\tconst endOfDay = DateTime.fromJSDate(lastDay, { zone }).endOf(\"day\").toJSDate()\n\treturn !(eventEndsBefore(firstDay, zone, event) || eventStartsAfter(endOfDay, zone, event))\n}\n\nexport function getFirstDayOfMonth(d: Date): Date {\n\tconst date = new Date(d)\n\tdate.setDate(1)\n\treturn date\n}\n\n/**\n * get the \"primary\" event of a series - the one that contains the repeat rule and is not a repeated or a rescheduled instance.\n * @param calendarEvent\n * @param entityClient\n */\nexport async function resolveCalendarEventProgenitor(calendarEvent: CalendarEvent, entityClient: EntityClient): Promise<CalendarEvent> {\n\treturn calendarEvent.repeatRule ? await entityClient.load(CalendarEventTypeRef, calendarEvent._id) : calendarEvent\n}\n\n/** clip the range start-end to the range given by min-max. if the result would have length 0, null is returned. */\nexport function clipRanges(start: number, end: number, min: number, max: number): CalendarTimeRange | null {\n\tconst res = {\n\t\tstart: Math.max(start, min),\n\t\tend: Math.min(end, max),\n\t}\n\treturn res.start < res.end ? res : null\n}\n\nexport enum AlarmIntervalUnit {\n\tMINUTE = \"M\",\n\tHOUR = \"H\",\n\tDAY = \"D\",\n\tWEEK = \"W\",\n}\n\nexport const StandardAlarmInterval = Object.freeze({\n\tZERO_MINUTES: { value: 0, unit: AlarmIntervalUnit.MINUTE },\n\tFIVE_MINUTES: { value: 5, unit: AlarmIntervalUnit.MINUTE },\n\tTEN_MINUTES: { value: 10, unit: AlarmIntervalUnit.MINUTE },\n\tTHIRTY_MINUTES: { value: 30, unit: AlarmIntervalUnit.MINUTE },\n\tONE_HOUR: { value: 1, unit: AlarmIntervalUnit.HOUR },\n\tONE_DAY: { value: 1, unit: AlarmIntervalUnit.DAY },\n\tTWO_DAYS: { value: 2, unit: AlarmIntervalUnit.DAY },\n\tTHREE_DAYS: { value: 3, unit: AlarmIntervalUnit.DAY },\n\tONE_WEEK: { value: 1, unit: AlarmIntervalUnit.WEEK },\n} as const satisfies Record<string, AlarmInterval>)\n\n/**\n * Runtime representation of an alarm interval/alarm trigger.\n * Unlike iCal we only support one unit and alarms in the past\n * (represented here as non-negative numbers).\n */\nexport type AlarmInterval = Readonly<{\n\tunit: AlarmIntervalUnit\n\tvalue: number\n}>\n\nexport function alarmIntervalToLuxonDurationLikeObject(alarmInterval: AlarmInterval): DurationLikeObject {\n\tswitch (alarmInterval.unit) {\n\t\tcase AlarmIntervalUnit.MINUTE:\n\t\t\treturn { minutes: alarmInterval.value }\n\t\tcase AlarmIntervalUnit.HOUR:\n\t\t\treturn { hours: alarmInterval.value }\n\t\tcase AlarmIntervalUnit.DAY:\n\t\t\treturn { days: alarmInterval.value }\n\t\tcase AlarmIntervalUnit.WEEK:\n\t\t\treturn { weeks: alarmInterval.value }\n\t}\n}\n\n/**\n * compare two lists of dates that are sorted from earliest to latest. return true if they are equivalent.\n */\nexport function areExcludedDatesEqual(e1: ReadonlyArray<DateWrapper>, e2: ReadonlyArray<DateWrapper>): boolean {\n\tif (e1.length !== e2.length) return false\n\treturn e1.every(({ date }, i) => e2[i].date.getTime() === date.getTime())\n}\n\nexport function areRepeatRulesEqual(r1: CalendarRepeatRule | null, r2: CalendarRepeatRule | null): boolean {\n\treturn (\n\t\tr1 === r2 ||\n\t\t(r1?.endType === r2?.endType &&\n\t\t\tr1?.endValue === r2?.endValue &&\n\t\t\tr1?.frequency === r2?.frequency &&\n\t\t\tr1?.interval === r2?.interval &&\n\t\t\t/** r1?.timeZone === r2?.timeZone && we're ignoring time zone because it's not an observable change. */\n\t\t\tareExcludedDatesEqual(r1?.excludedDates ?? [], r2?.excludedDates ?? []) &&\n\t\t\tdeepEqual(r1?.advancedRules, r2?.advancedRules))\n\t)\n}\n\n/**\n * Converts db representation of alarm to a runtime one.\n */\nexport function parseAlarmInterval(serialized: string): AlarmInterval {\n\tconst matched = serialized.match(/^(\\d+)([MHDW])$/)\n\tif (matched) {\n\t\tconst [_, digits, unit] = matched\n\t\tconst value = filterInt(digits)\n\t\tif (isNaN(value)) {\n\t\t\tthrow new ParserError(`Invalid value: ${value}`)\n\t\t} else {\n\t\t\treturn { value, unit: unit as AlarmIntervalUnit }\n\t\t}\n\t} else {\n\t\tthrow new ParserError(`Invalid alarm interval: ${serialized}`)\n\t}\n}\n\nexport enum CalendarType {\n\tNORMAL,\n\tURL, // External calendar\n\tCLIENT_ONLY,\n}\n\nexport function isClientOnlyCalendar(calendarId: Id) {\n\tconst clientOnlyId = calendarId.match(/#(.*)/)?.[1]!\n\treturn CLIENT_ONLY_CALENDARS.has(clientOnlyId)\n}\n\nexport function isClientOnlyCalendarType(calendarType: CalendarType) {\n\treturn calendarType === CalendarType.CLIENT_ONLY\n}\n\nexport function isNormalCalendarType(calendarType: CalendarType) {\n\treturn calendarType === CalendarType.NORMAL\n}\n\nexport function isExternalCalendarType(calendarType: CalendarType) {\n\treturn calendarType === CalendarType.URL\n}\n\nexport function hasSourceUrl(groupSettings: GroupSettings | null | undefined) {\n\treturn isNotNull(groupSettings?.sourceUrl) && groupSettings?.sourceUrl !== \"\"\n}\n\nexport function getCalendarType(groupSettings: GroupSettings | null, groupInfo: GroupInfo): CalendarType {\n\tif (hasSourceUrl(groupSettings)) return CalendarType.URL\n\tif (isClientOnlyCalendar(groupSettings ? groupSettings._id : groupInfo.group)) return CalendarType.CLIENT_ONLY\n\treturn CalendarType.NORMAL\n}\n\nexport function extractYearFromBirthday(birthday: string | null): number | null {\n\tif (!birthday) {\n\t\treturn null\n\t}\n\n\tconst dateParts = birthday.split(\"-\")\n\tconst partsLength = dateParts.length\n\n\t// A valid ISO date should contain 3 parts:\n\t// YYYY-mm-dd => [yyyy, mm, dd]\n\tif (partsLength !== 3) {\n\t\treturn null\n\t}\n\n\treturn Number.parseInt(dateParts[0])\n}\n\nexport async function retrieveClientOnlyEventsForUser(logins: LoginController, events: IdTuple[], localEvents: Map<number, BirthdayEventRegistry[]>) {\n\tif (!(await logins.getUserController().isNewPaidPlan())) {\n\t\treturn []\n\t}\n\n\tconst clientOnlyEvents = events.filter(([calendarId, _]) => isClientOnlyCalendar(calendarId)).flatMap((event) => event.join(\"/\"))\n\tconst retrievedEvents: CalendarEvent[] = []\n\n\tfor (const event of Array.from(localEvents.values()).flat()) {\n\t\tif (clientOnlyEvents.includes(event.event._id.join(\"/\"))) {\n\t\t\tretrievedEvents.push(event.event)\n\t\t}\n\t}\n\n\treturn retrievedEvents\n}\n\nexport function calculateContactsAge(birthYear: number | null, currentYear: number): number | null {\n\tif (!birthYear) {\n\t\treturn null\n\t}\n\n\treturn currentYear - birthYear\n}\n\nexport function extractContactIdFromEvent(id: string | null | undefined): string | null {\n\tif (id == null) {\n\t\treturn null\n\t}\n\n\treturn decodeBase64(\"utf-8\", id)\n}\n"]}