{"version":3,"file":"WebauthnClient.js","sourceRoot":"","sources":["../../../../../../src/common/misc/2fa/webauthn/WebauthnClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { decode } from \"cborg\"\nimport { assert, downcast, getFirstOrThrow, partitionAsync, stringToUtf8Uint8Array } from \"@tutao/tutanota-utils\"\nimport type { U2fChallenge, U2fRegisteredDevice, WebauthnResponseData } from \"../../../api/entities/sys/TypeRefs.js\"\nimport { createU2fRegisteredDevice, createWebauthnResponseData, U2fKey } from \"../../../api/entities/sys/TypeRefs.js\"\nimport { WebAuthnFacade } from \"../../../native/common/generatedipc/WebAuthnFacade.js\"\nimport { WebauthnKeyDescriptor } from \"../../../native/common/generatedipc/WebauthnKeyDescriptor.js\"\nimport { getApiBaseUrl } from \"../../../api/common/Env.js\"\nimport { Const } from \"../../../api/common/TutanotaConstants.js\"\nimport { DomainConfigProvider } from \"../../../api/common/DomainConfigProvider.js\"\n\n/** Web authentication entry point for the rest of the app. */\nexport class WebauthnClient {\n\tconstructor(private readonly webauthn: WebAuthnFacade, private readonly domainConfigProvider: DomainConfigProvider, private readonly isApp: boolean) {}\n\n\tisSupported(): Promise<boolean> {\n\t\treturn this.webauthn.isSupported()\n\t}\n\n\t/** Whether it's possible to attempt a challenge. It might not be possible if there are not keys for this domain. */\n\tasync canAttemptChallenge(challenge: U2fChallenge): Promise<{ canAttempt: Array<U2fKey>; cannotAttempt: Array<U2fKey> }> {\n\t\t// Whitelabel keys can ge registered other (whitelabel) domains.\n\t\t// If it's a new Webauthn key it will match rpId, otherwise it will match legacy appId.\n\n\t\t// Partition in keys that might work and which certainly cannot work.\n\t\tconst [canAttempt, cannotAttempt] = await partitionAsync(\n\t\t\tchallenge.keys,\n\t\t\tasync (k) => (await this.webauthn.canAttemptChallengeForRpId(k.appId)) || (await this.webauthn.canAttemptChallengeForU2FAppId(k.appId)),\n\t\t)\n\t\treturn { canAttempt, cannotAttempt }\n\t}\n\n\tasync register(userId: Id, displayName: string): Promise<U2fRegisteredDevice> {\n\t\tconst challenge = this.getChallenge()\n\t\t// this must be at most 64 bytes because the authenticators are allowed to truncate it\n\t\t// https://www.w3.org/TR/webauthn-2/#user-handle\n\t\tconst name = `userId=\"${userId}\"`\n\t\tconst registrationResult = await this.webauthn.register({ challenge, userId, name, displayName, domain: this.selectRegistrationUrl() })\n\t\tconst attestationObject = this.parseAttestationObject(registrationResult.attestationObject)\n\t\tconst publicKey = this.parsePublicKey(downcast(attestationObject).authData)\n\n\t\treturn createU2fRegisteredDevice({\n\t\t\tkeyHandle: new Uint8Array(registrationResult.rawId),\n\t\t\t// For Webauthn keys we save rpId into appId. They do not conflict: one of them is json URL, another is domain.\n\t\t\tappId: registrationResult.rpId,\n\t\t\tpublicKey: this.serializePublicKey(publicKey),\n\t\t\tcompromised: false,\n\t\t\tcounter: \"-1\",\n\t\t})\n\t}\n\n\tprivate selectRegistrationUrl() {\n\t\tconst domainConfig = this.domainConfigProvider.getCurrentDomainConfig()\n\t\treturn this.getWebauthnUrl(domainConfig, \"new\")\n\t}\n\n\t/**\n\t * Attempt to complete Webauthn challenge (the local part, signing of the data).\n\t * U2fChallenge might have multiple keys for different domains and this method takes care of picking the one we can attempt to solve.\n\t * @return responseData to send to the server and base api url which should be contacted in order to finish the challenge\n\t * @throws CancelledError\n\t * @throws WebauthnError\n\t */\n\tasync authenticate(challenge: U2fChallenge): Promise<{ responseData: WebauthnResponseData; apiBaseUrl: string }> {\n\t\tconst allowedKeys: WebauthnKeyDescriptor[] = challenge.keys.map((key) => {\n\t\t\treturn {\n\t\t\t\tid: key.keyHandle,\n\t\t\t}\n\t\t})\n\n\t\tconst authenticationUrl = this.selectAuthenticationUrl(challenge)\n\t\tconst signResult = await this.webauthn.sign({\n\t\t\tchallenge: challenge.challenge,\n\t\t\tkeys: allowedKeys,\n\t\t\tdomain: authenticationUrl,\n\t\t})\n\n\t\tconst responseData = createWebauthnResponseData({\n\t\t\tkeyHandle: new Uint8Array(signResult.rawId),\n\t\t\tclientData: new Uint8Array(signResult.clientDataJSON),\n\t\t\tsignature: new Uint8Array(signResult.signature),\n\t\t\tauthenticatorData: new Uint8Array(signResult.authenticatorData),\n\t\t})\n\t\t// take https://app.tuta.com/webauthn and convert it to apis://app.tuta.com\n\t\tconst authUrlObject = new URL(authenticationUrl)\n\t\tconst domainConfig = this.domainConfigProvider.getDomainConfigForHostname(authUrlObject.hostname, authUrlObject.protocol, authUrlObject.port)\n\t\tconst apiUrl = getApiBaseUrl(domainConfig)\n\n\t\treturn { responseData, apiBaseUrl: apiUrl }\n\t}\n\n\tabortCurrentOperation(): Promise<void> {\n\t\treturn this.webauthn.abortCurrentOperation()\n\t}\n\n\tprivate selectAuthenticationUrl(challenge: U2fChallenge): string {\n\t\t// We need to figure our for which page we need to open authentication based on the keys that user has added because users can register keys for our\n\t\t// domains as well as for whitelabel domains.\n\n\t\tconst domainConfig = this.domainConfigProvider.getCurrentDomainConfig()\n\t\tif (challenge.keys.some((k) => k.appId === Const.WEBAUTHN_RP_ID)) {\n\t\t\t// This function is not needed for the webapp! We can safely assume that our clientWebRoot is a new domain.\n\t\t\treturn this.getWebauthnUrl(domainConfig, \"new\")\n\t\t} else if (challenge.keys.some((k) => k.appId === Const.LEGACY_WEBAUTHN_RP_ID)) {\n\t\t\t// If there's a Webauthn key for our old domain we need to open the webapp on the old domain.\n\t\t\treturn this.getWebauthnUrl(domainConfig, \"legacy\")\n\t\t} else {\n\t\t\t// If it isn't there, look for any Webauthn key. Legacy U2F key ids ends with json subpath.\n\t\t\tconst webauthnKey = challenge.keys.find((k) => !this.isLegacyU2fKey(k))\n\t\t\tif (webauthnKey) {\n\t\t\t\tconst domainConfigForHostname = this.domainConfigProvider.getDomainConfigForHostname(webauthnKey.appId, \"https:\")\n\t\t\t\treturn this.getWebauthnUrl(domainConfigForHostname, \"new\")\n\t\t\t} else if (challenge.keys.some((k) => k.appId === Const.U2F_LEGACY_APPID)) {\n\t\t\t\t// There are only legacy U2F keys but there is one for our domain, take it\n\t\t\t\treturn this.getWebauthnUrl(domainConfig, \"legacy\")\n\t\t\t} else {\n\t\t\t\t// Nothing else worked, select legacy U2F key for whitelabel domain\n\t\t\t\tconst keyToUse = getFirstOrThrow(challenge.keys)\n\t\t\t\tconst keyUrl = new URL(keyToUse.appId)\n\t\t\t\tconst domainConfigForHostname = this.domainConfigProvider.getDomainConfigForHostname(keyUrl.hostname, keyUrl.protocol, keyUrl.port)\n\t\t\t\treturn this.getWebauthnUrl(domainConfigForHostname, \"new\")\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getWebauthnUrl(domainConfig: DomainConfig, type: \"legacy\" | \"new\") {\n\t\tif (type === \"legacy\") {\n\t\t\treturn this.isApp ? domainConfig.legacyWebauthnMobileUrl : domainConfig.legacyWebauthnUrl\n\t\t} else {\n\t\t\treturn this.isApp ? domainConfig.webauthnMobileUrl : domainConfig.webauthnUrl\n\t\t}\n\t}\n\n\tprivate isLegacyU2fKey(key: U2fKey): boolean {\n\t\treturn key.appId.endsWith(Const.U2f_APPID_SUFFIX)\n\t}\n\n\tprivate getChallenge(): Uint8Array {\n\t\t// Should be replaced with our own entropy generator in the future.\n\t\tconst random = new Uint8Array(32)\n\t\tcrypto.getRandomValues(random)\n\t\treturn random\n\t}\n\n\tprivate parseAttestationObject(raw: ArrayBuffer): unknown {\n\t\treturn decode(new Uint8Array(raw))\n\t}\n\n\tprivate parsePublicKey(authData: Uint8Array): Map<number, number | Uint8Array> {\n\t\t// get the length of the credential ID\n\t\tconst dataView = new DataView(new ArrayBuffer(2))\n\t\tconst idLenBytes = authData.slice(53, 55)\n\t\tfor (const [index, value] of idLenBytes.entries()) {\n\t\t\tdataView.setUint8(index, value)\n\t\t}\n\t\tconst credentialIdLength = dataView.getUint16(0)\n\t\t// get the public key object\n\t\tconst publicKeyBytes = authData.slice(55 + credentialIdLength)\n\t\t// the publicKeyBytes are encoded again as CBOR\n\t\t// We have to use maps here because keys are numeric and cborg only allows them in maps\n\t\treturn decode(new Uint8Array(publicKeyBytes.buffer), {\n\t\t\tuseMaps: true,\n\t\t})\n\t}\n\n\tprivate serializePublicKey(publicKey: Map<number, number | Uint8Array>): Uint8Array {\n\t\tconst encoded = new Uint8Array(65)\n\t\tencoded[0] = 0x04\n\t\tconst x = publicKey.get(-2)\n\t\tconst y = publicKey.get(-3)\n\n\t\tif (!(x instanceof Uint8Array) || !(y instanceof Uint8Array)) {\n\t\t\tthrow new Error(\"Public key is in unknown format\")\n\t\t}\n\n\t\tencoded.set(x, 1)\n\t\tencoded.set(y, 33)\n\t\treturn encoded\n\t}\n}\n\n/** authenticators are allowed to truncate strings to this length */\nconst WEBAUTHN_STRING_MAX_BYTE_LENGTH = 64\n\n/**\n * some authenticators truncate this and others refuse to be registered\n * at all if this validation does not pass.\n *\n * Note: technically, we'd also be supposed to encode text direction and a language\n * code into the display name.\n */\nexport function validateWebauthnDisplayName(displayName: string): boolean {\n\treturn WEBAUTHN_STRING_MAX_BYTE_LENGTH - stringToUtf8Uint8Array(displayName).byteLength >= 0\n}\n"]}