{"version":3,"file":"LoginViewModel.js","sourceRoot":"","sources":["../../../../src/common/login/LoginViewModel.ts"],"names":[],"mappings":"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","sourcesContent":["import { AccessExpiredError, BadRequestError, NotAuthenticatedError } from \"../api/common/error/RestError\"\nimport { lang, MaybeTranslation } from \"../misc/LanguageViewModel.js\"\nimport { SecondFactorHandler } from \"../misc/2fa/SecondFactorHandler.js\"\nimport { getLoginErrorMessage, handleExpectedLoginError } from \"../misc/LoginUtils.js\"\nimport type { LoginController } from \"../api/main/LoginController\"\nimport stream from \"mithril/stream\"\nimport Stream from \"mithril/stream\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError\"\nimport type { CredentialsProvider } from \"../misc/credentials/CredentialsProvider.js\"\nimport { CredentialAuthenticationError } from \"../api/common/error/CredentialAuthenticationError\"\nimport { first, noOp } from \"@tutao/tutanota-utils\"\nimport { KeyPermanentlyInvalidatedError } from \"../api/common/error/KeyPermanentlyInvalidatedError\"\nimport { assertMainOrNode } from \"../api/common/Env\"\nimport { SessionType } from \"../api/common/SessionType\"\nimport { DeviceStorageUnavailableError } from \"../api/common/error/DeviceStorageUnavailableError\"\nimport { DeviceConfig } from \"../misc/DeviceConfig.js\"\nimport { getWhitelabelRegistrationDomains } from \"./LoginView.js\"\nimport { CancelledError } from \"../api/common/error/CancelledError.js\"\nimport { CredentialRemovalHandler } from \"./CredentialRemovalHandler.js\"\nimport { NativePushServiceApp } from \"../native/main/NativePushServiceApp.js\"\nimport { CredentialsInfo } from \"../native/common/generatedipc/CredentialsInfo.js\"\nimport { credentialsToUnencrypted } from \"../misc/credentials/Credentials.js\"\nimport { UnencryptedCredentials } from \"../native/common/generatedipc/UnencryptedCredentials.js\"\nimport { AppLock } from \"./AppLock.js\"\nimport { isOfflineError } from \"../api/common/utils/ErrorUtils.js\"\n\nassertMainOrNode()\n\n/**\n * Defines what the view should currently render.\n */\nexport const enum DisplayMode {\n\t/* Display the stored credentials */\n\tCredentials = \"credentials\",\n\n\t/* Display login form (username, password) */\n\tForm = \"form\",\n\n\t/* Display the stored credentials and options to delete them */\n\tDeleteCredentials = \"deleteCredentials\",\n}\n\n/**\n * Reflects which state the current login process has.\n */\nexport const enum LoginState {\n\t/* Log in in process. */\n\tLoggingIn = \"LoggingIn\",\n\n\t/* Some unknown error occured during login. */\n\tUnknownError = \"UnknownError\",\n\n\t/* The credentials used for the last login attempt where invalid (e.g. bad password). */\n\tInvalidCredentials = \"InvalidCredentials\",\n\n\t/* The access token used for login has expired. */\n\tAccessExpired = \"AccessExpired\",\n\n\t/* Default state - the user is not logged in nor has login been attempted yet. */\n\tNotAuthenticated = \"NotAuthenticated\",\n\n\t/* The user has successfully logged in. */\n\tLoggedIn = \"LoggedIn\",\n}\n\n/**\n * Interface for the view model used on the login page. There is no real technical reason for extracting an interface for the view model\n * other than making it easier to document its methods and for some additional checks when mocking this.\n */\nexport interface ILoginViewModel {\n\treadonly state: LoginState\n\treadonly displayMode: DisplayMode\n\treadonly mailAddress: Stream<string>\n\treadonly password: Stream<string>\n\treadonly helpText: MaybeTranslation\n\treadonly savePassword: Stream<boolean>\n\n\t/**\n\t * Checks whether the viewmodel is in a state where it can attempt to login. This depends on the current displayMode as well as\n\t * what data (email, password, userId, ...) has been set.\n\t */\n\tcanLogin(): boolean\n\n\t/**\n\t * Will tell the viewmodel to use a certain userId. If there are any stored credentials for that user-id on the device, it will\n\t * load those, set them as potential credentials for login and switch to DisplayMode.Credentials. This is useful in order to prepare\n\t * the viewmodel for an automatic login without user interaction.\n\t * @param userId\n\t */\n\tuseUserId(userId: string): Promise<void>\n\n\t/**\n\t * Instructs the viewmodel to use the credentials passed for the next login attempt. Changes displayMode to DisplayMode.Credentials.\n\t * @param credentials\n\t */\n\tuseCredentials(credentials: CredentialsInfo): Promise<void>\n\n\t/**\n\t * Returns all credentials stored on the device.\n\t */\n\tgetSavedCredentials(): ReadonlyArray<CredentialsInfo>\n\n\t/**\n\t * Attempts to log in. How the login will be performed (using stored credentials/using email and password) depends on the current\n\t * DisplayMode.\n\t */\n\tlogin(): Promise<void>\n\n\t/**\n\t * Deletes stored credentials from the device.\n\t * @param credentials\n\t */\n\tdeleteCredentials(credentials: CredentialsInfo): Promise<\"networkError\" | null>\n\n\t/**\n\t * Changes the display mode to DisplayMode.Form.\n\t */\n\tshowLoginForm(): void\n\n\t/**\n\t * Changes the display mode to DisplayMode.Credentials.\n\t */\n\tshowCredentials(): void\n\n\t/**\n\t * Toggles between DisplayMode.Credentials and DisplayMode.DeleteCredentials.\n\t */\n\tswitchDeleteState(): void\n}\n\nexport class LoginViewModel implements ILoginViewModel {\n\treadonly mailAddress: Stream<string>\n\treadonly password: Stream<string>\n\tdisplayMode: DisplayMode\n\tstate: LoginState\n\thelpText: MaybeTranslation\n\treadonly savePassword: Stream<boolean>\n\tprivate savedInternalCredentials: ReadonlyArray<CredentialsInfo>\n\n\t// visibleForTesting\n\tautoLoginCredentials: CredentialsInfo | null\n\n\tconstructor(\n\t\tprivate readonly loginController: LoginController,\n\t\tprivate readonly credentialsProvider: CredentialsProvider,\n\t\tprivate readonly secondFactorHandler: SecondFactorHandler,\n\t\tprivate readonly deviceConfig: DeviceConfig,\n\t\tprivate readonly domainConfig: DomainConfig,\n\t\tprivate readonly credentialRemovalHandler: CredentialRemovalHandler,\n\t\tprivate readonly pushServiceApp: NativePushServiceApp | null,\n\t\tprivate readonly appLock: AppLock,\n\t) {\n\t\tthis.state = LoginState.NotAuthenticated\n\t\tthis.displayMode = DisplayMode.Form\n\t\tthis.helpText = \"emptyString_msg\"\n\t\tthis.mailAddress = stream(\"\")\n\t\tthis.password = stream(\"\")\n\t\tthis.autoLoginCredentials = null\n\t\tthis.savePassword = stream(false)\n\t\tthis.savedInternalCredentials = []\n\t}\n\n\t/**\n\t * This method should be called right after creation of the view model by whoever created the viewmodel. The view model will not be\n\t * fully functional before this method has been called!\n\t * @returns {Promise<void>}\n\t */\n\tasync init(): Promise<void> {\n\t\tawait this.updateCachedCredentials()\n\t}\n\n\tasync useUserId(userId: string): Promise<void> {\n\t\tthis.autoLoginCredentials = await this.credentialsProvider.getCredentialsInfoByUserId(userId)\n\n\t\tif (this.autoLoginCredentials) {\n\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t} else {\n\t\t\tthis.displayMode = DisplayMode.Form\n\t\t}\n\t}\n\n\tcanLogin(): boolean {\n\t\tif (this.displayMode === DisplayMode.Credentials) {\n\t\t\treturn this.autoLoginCredentials != null || this.savedInternalCredentials.length === 1\n\t\t} else if (this.displayMode === DisplayMode.Form) {\n\t\t\treturn Boolean(this.mailAddress() && this.password())\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tasync useCredentials(encryptedCredentials: CredentialsInfo): Promise<void> {\n\t\tconst credentialsInfo = await this.credentialsProvider.getCredentialsInfoByUserId(encryptedCredentials.userId)\n\n\t\tif (credentialsInfo) {\n\t\t\tthis.autoLoginCredentials = credentialsInfo\n\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t}\n\t}\n\n\tasync login() {\n\t\tif (this.state === LoginState.LoggingIn) return\n\t\tthis.state = LoginState.LoggingIn\n\n\t\tif (this.displayMode === DisplayMode.Credentials || this.displayMode === DisplayMode.DeleteCredentials) {\n\t\t\tawait this.autologin()\n\t\t} else if (this.displayMode === DisplayMode.Form) {\n\t\t\tawait this.formLogin()\n\t\t} else {\n\t\t\tthrow new ProgrammingError(`Cannot login with current display mode: ${this.displayMode}`)\n\t\t}\n\t}\n\n\tasync deleteCredentials(credentialsInfo: CredentialsInfo): Promise<\"networkError\" | null> {\n\t\tlet credentials\n\n\t\ttry {\n\t\t\t/**\n\t\t\t * We have to decrypt the credentials here (and hence deal with any potential errors), because :LoginController.deleteOldSession\n\t\t\t * expects the full credentials. The reason for this is that the accessToken contained within credentials has a double function:\n\t\t\t * 1. It is used as an actual access token to re-authenticate\n\t\t\t * 2. It is used as a session ID\n\t\t\t * Since we want to also delete the session from the server, we need the (decrypted) accessToken in its function as a session id.\n\t\t\t */\n\t\t\tcredentials = await this.unlockAppAndGetCredentials(credentialsInfo.userId)\n\t\t} catch (e) {\n\t\t\tif (e instanceof KeyPermanentlyInvalidatedError) {\n\t\t\t\tawait this.credentialsProvider.clearCredentials(e)\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof CancelledError) {\n\t\t\t\t// ignore, happens if we have app pin activated and the user\n\t\t\t\t// cancels the prompt or provides a wrong password.\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof CredentialAuthenticationError) {\n\t\t\t\tthis.helpText = getLoginErrorMessage(e, false)\n\t\t\t\treturn null\n\t\t\t} else if (e instanceof DeviceStorageUnavailableError) {\n\t\t\t\t// We want to allow deleting credentials even if keychain fails\n\t\t\t\tawait this.credentialsProvider.deleteByUserId(credentialsInfo.userId)\n\t\t\t\tawait this.credentialRemovalHandler.onCredentialsRemoved(credentialsInfo)\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tif (credentials) {\n\t\t\tawait this.credentialsProvider.deleteByUserId(credentials.credentialInfo.userId)\n\t\t\tawait this.credentialRemovalHandler.onCredentialsRemoved(credentials.credentialInfo)\n\t\t\tawait this.updateCachedCredentials()\n\t\t\ttry {\n\t\t\t\tawait this.loginController.deleteOldSession(credentials, (await this.pushServiceApp?.loadPushIdentifierFromNative()) ?? null)\n\t\t\t} catch (e) {\n\t\t\t\tif (isOfflineError(e)) {\n\t\t\t\t\treturn \"networkError\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\t/** @throws CredentialAuthenticationError */\n\tprivate async unlockAppAndGetCredentials(userId: Id): Promise<UnencryptedCredentials | null> {\n\t\tawait this.appLock.enforce()\n\t\treturn await this.credentialsProvider.getDecryptedCredentialsByUserId(userId)\n\t}\n\n\tgetSavedCredentials(): ReadonlyArray<CredentialsInfo> {\n\t\treturn this.savedInternalCredentials\n\t}\n\n\tswitchDeleteState() {\n\t\tif (this.displayMode === DisplayMode.DeleteCredentials) {\n\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t} else if (this.displayMode === DisplayMode.Credentials) {\n\t\t\tthis.displayMode = DisplayMode.DeleteCredentials\n\t\t} else {\n\t\t\tthrow new ProgrammingError(\"invalid state\")\n\t\t}\n\t}\n\n\tshowLoginForm() {\n\t\tthis.displayMode = DisplayMode.Form\n\t\tthis.helpText = \"emptyString_msg\"\n\t}\n\n\tshowCredentials() {\n\t\tthis.displayMode = DisplayMode.Credentials\n\t\tthis.helpText = \"emptyString_msg\"\n\t}\n\n\tshouldShowRecover(): boolean {\n\t\treturn this.domainConfig.firstPartyDomain\n\t}\n\n\tshouldShowSignup(): boolean {\n\t\treturn this.domainConfig.firstPartyDomain || getWhitelabelRegistrationDomains().length > 0\n\t}\n\n\tshouldShowAppButtons(): boolean {\n\t\treturn this.domainConfig.firstPartyDomain\n\t}\n\n\tprivate async updateCachedCredentials() {\n\t\tthis.savedInternalCredentials = await this.credentialsProvider.getInternalCredentialsInfos()\n\t\tthis.autoLoginCredentials = null\n\n\t\tif (this.savedInternalCredentials.length > 0) {\n\t\t\tif (this.displayMode !== DisplayMode.DeleteCredentials) {\n\t\t\t\tthis.displayMode = DisplayMode.Credentials\n\t\t\t}\n\t\t} else {\n\t\t\tthis.displayMode = DisplayMode.Form\n\t\t}\n\t}\n\n\tprivate async autologin(): Promise<void> {\n\t\tlet credentials: UnencryptedCredentials | null = null\n\t\ttry {\n\t\t\tif (this.autoLoginCredentials == null) {\n\t\t\t\tconst allCredentials = await this.credentialsProvider.getInternalCredentialsInfos()\n\t\t\t\tthis.autoLoginCredentials = first(allCredentials)\n\t\t\t}\n\n\t\t\t// we don't want to auto-login on the legacy domain, there's a banner\n\t\t\t// there to move people to the new domain.\n\t\t\tif (this.autoLoginCredentials) {\n\t\t\t\tcredentials = await this.unlockAppAndGetCredentials(this.autoLoginCredentials.userId)\n\n\t\t\t\tif (credentials) {\n\t\t\t\t\tconst offlineTimeRange = this.deviceConfig.getOfflineTimeRangeDays(this.autoLoginCredentials.userId)\n\t\t\t\t\tconst result = await this.loginController.resumeSession(credentials, null, offlineTimeRange)\n\t\t\t\t\tif (result.type == \"success\") {\n\t\t\t\t\t\tawait this.onLogin()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\t\t\tthis.helpText = \"offlineLoginPremiumOnly_msg\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthenticatedError && this.autoLoginCredentials) {\n\t\t\t\tconst autoLoginCredentials = this.autoLoginCredentials\n\t\t\t\tawait this.credentialsProvider.deleteByUserId(autoLoginCredentials.userId)\n\t\t\t\tif (credentials) {\n\t\t\t\t\tawait this.credentialRemovalHandler.onCredentialsRemoved(credentials.credentialInfo)\n\t\t\t\t}\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\tawait this.onLoginFailed(e)\n\t\t\t} else if (e instanceof KeyPermanentlyInvalidatedError) {\n\t\t\t\tawait this.credentialsProvider.clearCredentials(e)\n\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\tthis.helpText = \"credentialsKeyInvalidated_msg\"\n\t\t\t} else if (e instanceof DeviceStorageUnavailableError) {\n\t\t\t\t// The app already shows a dialog with FAQ link so we don't have to explain\n\t\t\t\t// much here, just catching it to avoid unexpected error dialog\n\t\t\t\tthis.state = LoginState.NotAuthenticated\n\t\t\t\tthis.helpText = lang.makeTranslation(\"help_text\", \"Could not access secret storage\")\n\t\t\t} else {\n\t\t\t\tawait this.onLoginFailed(e)\n\t\t\t}\n\t\t}\n\n\t\tif (this.state === LoginState.AccessExpired || this.state === LoginState.InvalidCredentials) {\n\t\t\tthis.displayMode = DisplayMode.Form\n\t\t\tthis.mailAddress(this.autoLoginCredentials?.login ?? \"\")\n\t\t}\n\t}\n\n\tprivate async formLogin(): Promise<void> {\n\t\tconst mailAddress = this.mailAddress()\n\t\tconst password = this.password()\n\t\tconst savePassword = this.savePassword()\n\n\t\tif (mailAddress === \"\" || password === \"\") {\n\t\t\tthis.state = LoginState.InvalidCredentials\n\t\t\tthis.helpText = \"loginFailed_msg\"\n\t\t\treturn\n\t\t}\n\n\t\tthis.helpText = \"login_msg\"\n\n\t\ttry {\n\t\t\tconst sessionType = savePassword ? SessionType.Persistent : SessionType.Login\n\n\t\t\tconst { credentials, databaseKey } = await this.loginController.createSession(mailAddress, password, sessionType)\n\t\t\tawait this.onLogin()\n\t\t\t// enforce app lock always, even if we don't access stored credentials\n\t\t\tawait this.appLock.enforce()\n\n\t\t\t// we don't want to have multiple credentials that\n\t\t\t// * share the same userId with different mail addresses (may happen if a user chooses a different alias to log in than the one they saved)\n\t\t\t// * share the same mail address (may happen if mail aliases are moved between users)\n\t\t\tconst storedCredentialsToDelete = this.savedInternalCredentials.filter((c) => c.login === mailAddress || c.userId === credentials.userId)\n\n\t\t\tfor (const credentialToDelete of storedCredentialsToDelete) {\n\t\t\t\tconst credentials = await this.credentialsProvider.getDecryptedCredentialsByUserId(credentialToDelete.userId)\n\n\t\t\t\tif (credentials) {\n\t\t\t\t\tawait this.loginController.deleteOldSession(credentials)\n\t\t\t\t\t// we handled the deletion of the offlineDb in createSession already\n\t\t\t\t\tawait this.credentialsProvider.deleteByUserId(credentials.credentialInfo.userId, { deleteOfflineDb: false })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (savePassword) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.credentialsProvider.store(credentialsToUnencrypted(credentials, databaseKey))\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof KeyPermanentlyInvalidatedError) {\n\t\t\t\t\t\tawait this.credentialsProvider.clearCredentials(e)\n\t\t\t\t\t\tawait this.updateCachedCredentials()\n\t\t\t\t\t} else if (e instanceof DeviceStorageUnavailableError || e instanceof CancelledError) {\n\t\t\t\t\t\tconsole.warn(\"will proceed with ephemeral credentials because device storage is unavailable:\", e)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof DeviceStorageUnavailableError) {\n\t\t\t\tconsole.warn(\"cannot log in: failed to get credentials from device storage\", e)\n\t\t\t}\n\t\t\tawait this.onLoginFailed(e)\n\t\t} finally {\n\t\t\tawait this.secondFactorHandler.closeWaitingForSecondFactorDialog()\n\t\t}\n\t}\n\n\tprivate async onLogin(): Promise<void> {\n\t\tthis.helpText = \"emptyString_msg\"\n\t\tthis.state = LoginState.LoggedIn\n\t}\n\n\tprivate async onLoginFailed(error: Error): Promise<void> {\n\t\tthis.helpText = getLoginErrorMessage(error, false)\n\n\t\tif (error instanceof BadRequestError || error instanceof NotAuthenticatedError) {\n\t\t\tthis.state = LoginState.InvalidCredentials\n\t\t} else if (error instanceof AccessExpiredError) {\n\t\t\tthis.state = LoginState.AccessExpired\n\t\t} else {\n\t\t\tthis.state = LoginState.UnknownError\n\t\t}\n\n\t\thandleExpectedLoginError(error, noOp)\n\t}\n}\n"]}