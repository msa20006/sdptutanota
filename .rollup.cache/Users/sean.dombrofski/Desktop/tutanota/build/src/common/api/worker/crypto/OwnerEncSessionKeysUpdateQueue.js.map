{"version":3,"file":"OwnerEncSessionKeysUpdateQueue.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/crypto/OwnerEncSessionKeysUpdateQueue.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAA;AAChD,OAAO,EAAE,6BAA6B,EAAE,qBAAqB,EAAsB,MAAM,gCAAgC,CAAA;AACzH,OAAO,EAAE,WAAW,EAAE,MAAM,8BAA8B,CAAA;AAC1D,OAAO,EAAE,kBAAkB,EAAE,MAAM,kBAAkB,CAAA;AAErD,OAAO,EAAE,wBAAwB,EAAE,MAAM,6BAA6B,CAAA;AAGtE,OAAO,EAAE,oBAAoB,EAAE,MAAM,iCAAiC,CAAA;AAEtE,kBAAkB,EAAE,CAAA;AAEpB,MAAM,CAAC,MAAM,uCAAuC,GAAG,EAAE,CAAA;AAEzD;;;;;;GAMG;AACH,MAAM,OAAO,8BAA8B;IAMxB;IACA;IANV,6BAA6B,GAA8B,EAAE,CAAA;IACpD,6BAA6B,CAAqB;IAC3D,+BAA+B,GAA6D,IAAI,CAAA;IAExG,YACkB,UAAsB,EACtB,eAAiC;IAClD,4CAA4C;IAC5C,oBAA4B,uCAAuC;QAHlD,eAAU,GAAV,UAAU,CAAY;QACtB,oBAAe,GAAf,eAAe,CAAkB;QAIlD,IAAI,CAAC,6BAA6B,GAAG,QAAQ,CAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAA;IACjG,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,yBAAyB,CAAC,mBAA8C,EAAE,SAAoB;QACnG,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,EAAE,CAAC;YAChC,MAAM,uBAAuB,GAAG,MAAM,oBAAoB,CAAC,qBAAqB,CAAC,CAAA;YACjF,IAAI,uBAAuB,CAAC,EAAE,KAAK,SAAS,CAAC,EAAE,EAAE,CAAC;gBACjD,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,GAAG,mBAAmB,CAAC,CAAA;gBAC/D,IAAI,CAAC,6BAA6B,EAAE,CAAA;YACrC,CAAC;QACF,CAAC;IACF,CAAC;IAEO,KAAK,CAAC,iBAAiB;QAC9B,MAAM,mBAAmB,GAAG,IAAI,CAAC,6BAA6B,CAAA;QAC9D,IAAI,CAAC,6BAA6B,GAAG,EAAE,CAAA;QACvC,IAAI,CAAC;YACJ,IAAI,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACpC,MAAM,IAAI,CAAC,4BAA4B,CAAC,mBAAmB,CAAC,CAAA;YAC7D,CAAC;QACF,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,IAAI,CAAC,YAAY,WAAW,EAAE,CAAC;gBAC9B,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,GAAG,mBAAmB,CAAC,CAAA;gBAC/D,IAAI,CAAC,6BAA6B,EAAE,CAAA;YACrC,CAAC;iBAAM,CAAC;gBACP,OAAO,CAAC,GAAG,CAAC,kCAAkC,EAAE,CAAC,CAAC,IAAI,EAAE,mBAAmB,CAAC,MAAM,CAAC,CAAA;gBACnF,MAAM,CAAC,CAAA;YACR,CAAC;QACF,CAAC;IACF,CAAC;IAED,KAAK,CAAC,4BAA4B,CAAC,mBAA8C;QAChF,MAAM,KAAK,GAAG,6BAA6B,CAAC,EAAE,mBAAmB,EAAE,mBAAmB,EAAE,CAAC,CAAA;QACzF,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,wBAAwB,EAAE,KAAK,CAAC,CAAA;IACjE,CAAC;CACD","sourcesContent":["import { debounce } from \"@tutao/tutanota-utils\"\nimport { createUpdateSessionKeysPostIn, GroupKeyUpdateTypeRef, InstanceSessionKey } from \"../../entities/sys/TypeRefs.js\"\nimport { LockedError } from \"../../common/error/RestError\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { UpdateSessionKeysService } from \"../../entities/sys/Services\"\nimport { UserFacade } from \"../facades/UserFacade\"\nimport { TypeModel } from \"../../common/EntityTypes.js\"\nimport { resolveTypeReference } from \"../../common/EntityFunctions.js\"\n\nassertWorkerOrNode()\n\nexport const UPDATE_SESSION_KEYS_SERVICE_DEBOUNCE_MS = 50\n\n/**\n * This queue collects updates for ownerEncSessionKeys and debounces the update request to the UpdateSessionKeysService,\n * in order to update as many instances in one request as possible.\n *\n * In case of LockedErrors it will retry. In case of other errors it will discard the update.\n * (The next time the instance session key is resolved using the bucket key a new update attempt will be made for those instances.)\n */\nexport class OwnerEncSessionKeysUpdateQueue {\n\tprivate updateInstanceSessionKeyQueue: Array<InstanceSessionKey> = []\n\tprivate readonly invokeUpdateSessionKeyService: () => Promise<void>\n\tprivate senderAuthStatusForMailInstance: { authenticated: boolean; instanceElementId: Id } | null = null\n\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\t// allow passing the timeout for testability\n\t\tdebounceTimeoutMs: number = UPDATE_SESSION_KEYS_SERVICE_DEBOUNCE_MS,\n\t) {\n\t\tthis.invokeUpdateSessionKeyService = debounce(debounceTimeoutMs, () => this.sendUpdateRequest())\n\t}\n\n\t/**\n\t * Add the ownerEncSessionKey updates to the queue and debounce the update request.\n\t *\n\t * @param instanceSessionKeys all instanceSessionKeys from one bucketKey containing the ownerEncSessionKey as symEncSessionKey\n\t * @param typeModel of the main instance that we are updating session keys for\n\t */\n\tasync updateInstanceSessionKeys(instanceSessionKeys: Array<InstanceSessionKey>, typeModel: TypeModel) {\n\t\tif (this.userFacade.isLeader()) {\n\t\t\tconst groupKeyUpdateTypeModel = await resolveTypeReference(GroupKeyUpdateTypeRef)\n\t\t\tif (groupKeyUpdateTypeModel.id !== typeModel.id) {\n\t\t\t\tthis.updateInstanceSessionKeyQueue.push(...instanceSessionKeys)\n\t\t\t\tthis.invokeUpdateSessionKeyService()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendUpdateRequest(): Promise<void> {\n\t\tconst instanceSessionKeys = this.updateInstanceSessionKeyQueue\n\t\tthis.updateInstanceSessionKeyQueue = []\n\t\ttry {\n\t\t\tif (instanceSessionKeys.length > 0) {\n\t\t\t\tawait this.postUpdateSessionKeysService(instanceSessionKeys)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof LockedError) {\n\t\t\t\tthis.updateInstanceSessionKeyQueue.push(...instanceSessionKeys)\n\t\t\t\tthis.invokeUpdateSessionKeyService()\n\t\t\t} else {\n\t\t\t\tconsole.log(\"error during session key update:\", e.name, instanceSessionKeys.length)\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tasync postUpdateSessionKeysService(instanceSessionKeys: Array<InstanceSessionKey>) {\n\t\tconst input = createUpdateSessionKeysPostIn({ ownerEncSessionKeys: instanceSessionKeys })\n\t\tawait this.serviceExecutor.post(UpdateSessionKeysService, input)\n\t}\n}\n"]}