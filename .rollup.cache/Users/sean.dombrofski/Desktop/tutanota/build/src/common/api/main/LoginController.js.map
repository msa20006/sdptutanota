{"version":3,"file":"LoginController.js","sourceRoot":"","sources":["../../../../../src/common/api/main/LoginController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DeferredObject, lazy, lazyAsync } from \"@tutao/tutanota-utils\"\nimport { assertNotNull, defer } from \"@tutao/tutanota-utils\"\nimport { assertMainOrNodeBoot } from \"../common/Env\"\nimport type { UserController, UserControllerInitData } from \"./UserController\"\nimport { getWhitelabelCustomizations } from \"../../misc/WhitelabelCustomizations.js\"\nimport { NotFoundError } from \"../common/error/RestError\"\nimport { client } from \"../../misc/ClientDetector\"\nimport type { LoginFacade, NewSessionData } from \"../worker/facades/LoginFacade\"\nimport { ResumeSessionErrorReason } from \"../worker/facades/LoginFacade\"\nimport type { Credentials } from \"../../misc/credentials/Credentials\"\nimport { FeatureType, KdfType } from \"../common/TutanotaConstants\"\nimport { SessionType } from \"../common/SessionType\"\nimport { ExternalUserKeyDeriver } from \"../../misc/LoginUtils.js\"\nimport { UnencryptedCredentials } from \"../../native/common/generatedipc/UnencryptedCredentials.js\"\nimport { PageContextLoginListener } from \"./PageContextLoginListener.js\"\nimport { CacheMode } from \"../worker/rest/EntityRestClient.js\"\n\nassertMainOrNodeBoot()\n\nexport interface PostLoginAction {\n\t/** Partial login is achieved with getting the user, can happen offline. The login will wait for the returned promise. */\n\tonPartialLoginSuccess(loggedInEvent: LoggedInEvent): Promise<void>\n\n\t/** Full login is achieved with getting group keys. Can do service calls from this point on. */\n\tonFullLoginSuccess(loggedInEvent: LoggedInEvent): Promise<void>\n}\n\nexport type LoggedInEvent = {\n\treadonly sessionType: SessionType\n\treadonly userId: Id\n}\n\nexport type ResumeSessionResult = { type: \"success\" } | { type: \"error\"; reason: ResumeSessionErrorReason }\n\nexport class LoginController {\n\tprivate userController: UserController | null = null\n\t// they are FeatureType but we might not be aware of newer values for it, so it is not just FeatureType\n\tprivate customizations: NumberString[] | null = null\n\tprivate partialLogin: DeferredObject<void> = defer()\n\tprivate _isWhitelabel: boolean = !!getWhitelabelCustomizations(window)\n\tprivate postLoginActions: Array<lazy<Promise<PostLoginAction>>> = []\n\tprivate fullyLoggedIn: boolean = false\n\tprivate atLeastPartiallyLoggedIn: boolean = false\n\n\tconstructor(\n\t\tprivate readonly loginFacade: LoginFacade,\n\t\tprivate readonly loginListener: lazyAsync<PageContextLoginListener>,\n\t\tprivate readonly resetAppState: () => Promise<unknown>,\n\t) {}\n\n\tinit() {\n\t\tthis.waitForFullLogin().then(async () => {\n\t\t\tthis.fullyLoggedIn = true\n\t\t\tawait this.waitForPartialLogin()\n\t\t\tfor (const lazyAction of this.postLoginActions) {\n\t\t\t\tconst action = await lazyAction()\n\t\t\t\tawait action.onFullLoginSuccess({\n\t\t\t\t\tsessionType: this.getUserController().sessionType,\n\t\t\t\t\tuserId: this.getUserController().userId,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * create a new session and set up stored credentials and offline database, if applicable.\n\t * @param username the mail address being used to log in\n\t * @param password the password given to log in\n\t * @param sessionType whether to store the credentials in local storage\n\t * @param databaseKey if given, will use this key for the offline database. if not, will force a new database to be created and generate a key.\n\t */\n\tasync createSession(username: string, password: string, sessionType: SessionType, databaseKey: Uint8Array | null = null): Promise<NewSessionData> {\n\t\tconst newSessionData = await this.loginFacade.createSession(username, password, client.getIdentifier(), sessionType, databaseKey)\n\t\tconst { user, credentials, sessionId, userGroupInfo } = newSessionData\n\t\tawait this.onPartialLoginSuccess(\n\t\t\t{\n\t\t\t\tuser,\n\t\t\t\tuserGroupInfo,\n\t\t\t\tsessionId,\n\t\t\t\taccessToken: credentials.accessToken,\n\t\t\t\tsessionType,\n\t\t\t\tloginUsername: username,\n\t\t\t},\n\t\t\tsessionType,\n\t\t)\n\t\treturn newSessionData\n\t}\n\n\taddPostLoginAction(handler: lazy<Promise<PostLoginAction>>) {\n\t\tthis.postLoginActions.push(handler)\n\t}\n\n\tasync onPartialLoginSuccess(initData: UserControllerInitData, sessionType: SessionType): Promise<void> {\n\t\tconst { initUserController } = await import(\"./UserController\")\n\t\tthis.userController = await initUserController(initData)\n\n\t\tawait this.loadCustomizations()\n\t\tawait this._determineIfWhitelabel()\n\n\t\tfor (const lazyHandler of this.postLoginActions) {\n\t\t\tconst handler = await lazyHandler()\n\t\t\tawait handler.onPartialLoginSuccess({\n\t\t\t\tsessionType,\n\t\t\t\tuserId: initData.user._id,\n\t\t\t})\n\t\t}\n\t\tthis.atLeastPartiallyLoggedIn = true\n\t\tthis.partialLogin.resolve()\n\t}\n\n\tasync createExternalSession(\n\t\tuserId: Id,\n\t\tpassword: string,\n\t\tsalt: Uint8Array,\n\t\tkdfType: KdfType,\n\t\tclientIdentifier: string,\n\t\tsessionType: SessionType,\n\t): Promise<Credentials> {\n\t\tconst persistentSession = sessionType === SessionType.Persistent\n\t\tconst { user, credentials, sessionId, userGroupInfo } = await this.loginFacade.createExternalSession(\n\t\t\tuserId,\n\t\t\tpassword,\n\t\t\tsalt,\n\t\t\tkdfType,\n\t\t\tclientIdentifier,\n\t\t\tpersistentSession,\n\t\t)\n\t\tawait this.onPartialLoginSuccess(\n\t\t\t{\n\t\t\t\tuser,\n\t\t\t\taccessToken: credentials.accessToken,\n\t\t\t\tsessionType,\n\t\t\t\tsessionId,\n\t\t\t\tuserGroupInfo,\n\t\t\t\tloginUsername: userId,\n\t\t\t},\n\t\t\tSessionType.Login,\n\t\t)\n\t\treturn credentials\n\t}\n\n\t/**\n\t * Resume an existing session using stored credentials, may or may not unlock a persistent local database\n\t * @param unencryptedCredentials The stored credentials and optional database key for the offline db\n\t * @param externalUserKeyDeriver The KDF type and salt to resume a session\n\t * @param offlineTimeRangeDays the user configured time range for their offline storage, used to initialize the offline db\n\t */\n\tasync resumeSession(\n\t\tunencryptedCredentials: UnencryptedCredentials,\n\t\texternalUserKeyDeriver?: ExternalUserKeyDeriver | null,\n\t\tofflineTimeRangeDays?: number | null,\n\t): Promise<ResumeSessionResult> {\n\t\tconst { unencryptedToCredentials } = await import(\"../../misc/credentials/Credentials.js\")\n\t\tconst credentials = unencryptedToCredentials(unencryptedCredentials)\n\t\tconst resumeResult = await this.loginFacade.resumeSession(\n\t\t\tcredentials,\n\t\t\texternalUserKeyDeriver ?? null,\n\t\t\tunencryptedCredentials.databaseKey ?? null,\n\t\t\tofflineTimeRangeDays ?? null,\n\t\t)\n\t\tif (resumeResult.type === \"error\") {\n\t\t\treturn resumeResult\n\t\t} else {\n\t\t\tconst { user, userGroupInfo, sessionId } = resumeResult.data\n\t\t\ttry {\n\t\t\t\tawait this.onPartialLoginSuccess(\n\t\t\t\t\t{\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\taccessToken: credentials.accessToken,\n\t\t\t\t\t\tuserGroupInfo,\n\t\t\t\t\t\tsessionId,\n\t\t\t\t\t\tsessionType: SessionType.Persistent,\n\t\t\t\t\t\tloginUsername: credentials.login,\n\t\t\t\t\t},\n\t\t\t\t\tSessionType.Persistent,\n\t\t\t\t)\n\t\t\t} catch (e) {\n\t\t\t\t// Some parts of initialization can fail and we should reset the state, both on this side and the worker\n\t\t\t\t// side, otherwise login cannot be attempted again\n\t\t\t\tconsole.log(\"Error finishing login, logging out now!\", e)\n\t\t\t\tawait this.logout(false)\n\t\t\t\tthrow e\n\t\t\t}\n\n\t\t\treturn { type: \"success\" }\n\t\t}\n\t}\n\n\tisUserLoggedIn(): boolean {\n\t\treturn this.userController != null\n\t}\n\n\tisFullyLoggedIn(): boolean {\n\t\treturn this.fullyLoggedIn\n\t}\n\n\tisAtLeastPartiallyLoggedIn(): boolean {\n\t\treturn this.atLeastPartiallyLoggedIn\n\t}\n\n\twaitForPartialLogin(): Promise<void> {\n\t\treturn this.partialLogin.promise\n\t}\n\n\tasync waitForFullLogin(): Promise<void> {\n\t\t// Full login event might be received before we finish userLogin on the client side because they are done in parallel.\n\t\t// So we make sure to wait for userLogin first.\n\t\tawait this.waitForPartialLogin()\n\t\tconst loginListener = await this.loginListener()\n\t\treturn loginListener.waitForFullLogin()\n\t}\n\n\tisInternalUserLoggedIn(): boolean {\n\t\treturn this.isUserLoggedIn() && this.getUserController().isInternalUser()\n\t}\n\n\tisGlobalAdminUserLoggedIn(): boolean {\n\t\treturn this.isUserLoggedIn() && this.getUserController().isGlobalAdmin()\n\t}\n\n\tgetUserController(): UserController {\n\t\treturn assertNotNull(this.userController) // only to be used after login (when user is defined)\n\t}\n\n\tisEnabled(feature: FeatureType): boolean {\n\t\treturn this.customizations != null ? this.customizations.indexOf(feature) !== -1 : false\n\t}\n\n\tasync loadCustomizations(cacheMode: CacheMode = CacheMode.ReadAndWrite): Promise<void> {\n\t\tif (this.getUserController().isInternalUser()) {\n\t\t\tconst customer = await this.getUserController().loadCustomer(cacheMode)\n\t\t\tthis.customizations = customer.customizations.map((f) => f.feature)\n\t\t}\n\t}\n\n\t/**\n\t * Reset login state, delete session, if not {@link SessionType.Persistent}.\n\t * @param sync whether to try and close the session before the window is closed\n\t */\n\tasync logout(sync: boolean): Promise<void> {\n\t\t// make all parts of LoginController usable for another login\n\t\tif (this.userController) {\n\t\t\tawait this.userController.deleteSession(sync)\n\t\t} else {\n\t\t\tconsole.log(\"No session to delete\")\n\t\t}\n\t\t// Using this over LoginFacade.resetSession() to reset all app state that might have been already bound to\n\t\t// a user on the worker side.\n\t\tawait this.resetAppState()\n\t\tthis.userController = null\n\t\tthis.partialLogin = defer()\n\t\tthis.fullyLoggedIn = false\n\t\tconst loginListener = await this.loginListener()\n\t\tloginListener.reset()\n\t\tthis.init()\n\t}\n\n\tasync _determineIfWhitelabel(): Promise<void> {\n\t\tthis._isWhitelabel = await this.getUserController().isWhitelabelAccount()\n\t}\n\n\tisWhitelabel(): boolean {\n\t\treturn this._isWhitelabel\n\t}\n\n\t/**\n\t * Deletes the session on the server.\n\t * @param credentials\n\t * @param pushIdentifier identifier associated with this device, if any, to delete PushIdentifier on the server\n\t */\n\tasync deleteOldSession(credentials: UnencryptedCredentials, pushIdentifier: string | null = null): Promise<void> {\n\t\ttry {\n\t\t\tawait this.loginFacade.deleteSession(credentials.accessToken, pushIdentifier)\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\tconsole.log(\"session already deleted\")\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tasync retryAsyncLogin() {\n\t\tconst loginListener = await this.loginListener()\n\t\tloginListener.onRetryLogin()\n\t\tawait this.loginFacade.retryAsyncLogin()\n\t}\n}\n"]}