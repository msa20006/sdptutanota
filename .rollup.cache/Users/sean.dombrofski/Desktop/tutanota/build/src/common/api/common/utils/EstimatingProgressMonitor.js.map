{"version":3,"file":"EstimatingProgressMonitor.js","sourceRoot":"","sources":["../../../../../../src/common/api/common/utils/EstimatingProgressMonitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IProgressMonitor, ProgressListener } from \"./ProgressMonitor\"\nimport { first, last } from \"@tutao/tutanota-utils\"\n\nconst DEFAULT_RATE_PER_SECOND = 0.5\nconst DEFAULT_PROGRESS_ESTIMATION_REFRESH_MS: number = 1000\nconst MINIMUM_HISTORY_LENGTH_FOR_ESTIMATION = 3\nconst RATE_PER_SECOND_MAXIMUM_SCALING_RATIO: number = 0.75\n\nconst WORK_MAX_PERCENTAGE = 100\nconst WORK_COMPLETED_MIN = 0\n\n/**\n * Class to calculate percentage of total work and report it back.\n * Call {@code workDone() or @code totalWorkDone} for each work step and\n * {@code completed()} when you are done.\n * EstimatingProgressMonitor works the same as the {@link ProgressMonitor}, but\n * additionally **estimates** progress internally on the go.\n */\nexport class EstimatingProgressMonitor implements IProgressMonitor {\n\tworkCompleted: number\n\tratePerSecondHistory: Array<Readonly<[number, number]>> = Array.of([Date.now(), DEFAULT_RATE_PER_SECOND]) // entries: timestamp, rate per second\n\ttotalWork: number\n\tprogressEstimation: TimeoutID\n\n\tconstructor(totalWork: number, private readonly updater: ProgressListener) {\n\t\tthis.workCompleted = WORK_COMPLETED_MIN\n\t\tthis.totalWork = totalWork\n\t}\n\n\tpublic updateTotalWork(value: number) {\n\t\tthis.totalWork = value\n\t}\n\n\tpublic continueEstimation() {\n\t\tclearInterval(this.progressEstimation)\n\t\tthis.progressEstimation = setInterval(() => {\n\t\t\tif (this.ratePerSecondHistory.length < MINIMUM_HISTORY_LENGTH_FOR_ESTIMATION) {\n\t\t\t\tthis.workEstimate(DEFAULT_RATE_PER_SECOND)\n\t\t\t} else {\n\t\t\t\tconst previousRateEntry = this.ratePerSecondHistory[this.ratePerSecondHistory.length - 2]\n\t\t\t\tconst previousRateEntryTimestamp = first(previousRateEntry)!\n\n\t\t\t\tconst lastRateEntry = last(this.ratePerSecondHistory)!\n\t\t\t\tconst lastRateEntryTimestamp = first(lastRateEntry)!\n\t\t\t\tconst lastRatePerSecond = last(lastRateEntry)!\n\n\t\t\t\tlet lastDurationBetweenRatePerSecondUpdatesMs = lastRateEntryTimestamp - previousRateEntryTimestamp\n\t\t\t\tlet currentDurationMs = Date.now() - lastRateEntryTimestamp\n\t\t\t\tlet ratePerSecondScalingRatio: number = Math.min(\n\t\t\t\t\tRATE_PER_SECOND_MAXIMUM_SCALING_RATIO,\n\t\t\t\t\tlastDurationBetweenRatePerSecondUpdatesMs / currentDurationMs,\n\t\t\t\t)\n\n\t\t\t\tlet newRatePerSecondEstimate = lastRatePerSecond * ratePerSecondScalingRatio\n\t\t\t\tlet workDoneEstimation = Math.max(DEFAULT_RATE_PER_SECOND, newRatePerSecondEstimate)\n\n\t\t\t\t// only update estimation if we did not exceed the actual totalWork yet\n\t\t\t\tif (this.workCompleted + workDoneEstimation < this.totalWork) {\n\t\t\t\t\tthis.workEstimate(workDoneEstimation)\n\t\t\t\t}\n\t\t\t}\n\t\t}, DEFAULT_PROGRESS_ESTIMATION_REFRESH_MS)\n\t}\n\n\tpublic pauseEstimation() {\n\t\tclearInterval(this.progressEstimation)\n\t\tthis.ratePerSecondHistory = Array.of([Date.now(), DEFAULT_RATE_PER_SECOND])\n\t}\n\n\tprivate updateRatePerSecond(newWorkAmount: number) {\n\t\tlet lastRateEntry = last(this.ratePerSecondHistory)!\n\t\tlet lastTimestamp = first(lastRateEntry)!\n\t\tlet now = Date.now()\n\t\tlet durationSinceLastRateEntrySeconds = (now - lastTimestamp) / 1000\n\t\tlet ratePerSecond = newWorkAmount / durationSinceLastRateEntrySeconds\n\t\tlet newRateEntry: Readonly<[number, number]> = [now, ratePerSecond]\n\t\tthis.ratePerSecondHistory.push(newRateEntry)\n\t}\n\n\tprivate workEstimate(estimate: number) {\n\t\tthis.workCompleted += estimate\n\t\tthis.updater(this.percentage())\n\t}\n\n\tpublic workDone(amount: number) {\n\t\tthis.updateRatePerSecond(amount)\n\t\tthis.workCompleted += amount\n\t\tthis.updater(this.percentage())\n\t}\n\n\tpublic totalWorkDone(totalAmount: number) {\n\t\tlet workDifference = totalAmount - this.workCompleted\n\t\tthis.updateRatePerSecond(workDifference)\n\t\tthis.workCompleted = totalAmount\n\t\tthis.updater(this.percentage())\n\t}\n\n\tpublic percentage(): number {\n\t\tconst result = (WORK_MAX_PERCENTAGE * this.workCompleted) / this.totalWork\n\t\treturn Math.min(WORK_MAX_PERCENTAGE, result)\n\t}\n\n\tpublic completed() {\n\t\tthis.workCompleted = this.totalWork\n\t\tthis.updater(WORK_MAX_PERCENTAGE)\n\t}\n}\n"]}