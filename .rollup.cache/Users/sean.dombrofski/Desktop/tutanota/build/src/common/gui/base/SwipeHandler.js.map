{"version":3,"file":"SwipeHandler.js","sourceRoot":"","sources":["../../../../../src/common/gui/base/SwipeHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { size } from \"../size\"\n\nexport const enum DirectionLock {\n\tHorizontal,\n\tVertical,\n}\n\nexport interface Coordinate2D {\n\tx: number\n\ty: number\n}\n\n/* Tool to detect swipe gestures on certain elements. */\nexport class SwipeHandler {\n\t/** uses clientX/clientY thus relative to view port */\n\tstartPos: Coordinate2D\n\ttouchArea: HTMLElement\n\tanimating: Promise<unknown>\n\tisAnimating: boolean = false\n\tdirectionLock: DirectionLock | null\n\n\tconstructor(touchArea: HTMLElement) {\n\t\tthis.startPos = {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t}\n\t\tthis.touchArea = touchArea\n\t\tthis.animating = Promise.resolve()\n\t\tthis.directionLock = null\n\t}\n\n\tattach() {\n\t\tthis.touchArea.addEventListener(\"touchstart\", this.onTouchStart, { passive: true })\n\t\t// does invoke prevent default\n\t\tthis.touchArea.addEventListener(\"touchmove\", this.onTouchMove, { passive: false })\n\t\tthis.touchArea.addEventListener(\"touchend\", this.onTouchEnd, { passive: true })\n\t}\n\n\tdetach() {\n\t\tthis.touchArea.removeEventListener(\"touchstart\", this.onTouchStart)\n\t\tthis.touchArea.removeEventListener(\"touchmove\", this.onTouchMove)\n\t\tthis.touchArea.removeEventListener(\"touchend\", this.onTouchEnd)\n\t}\n\n\tprivate readonly onTouchStart = (e: TouchEvent) => {\n\t\tthis.startPos = {\n\t\t\tx: e.touches[0].clientX,\n\t\t\ty: e.touches[0].clientY,\n\t\t}\n\t}\n\n\tprivate readonly onTouchMove = (e: TouchEvent) => {\n\t\tlet { x, y } = this.getDelta(e)\n\n\t\t// If we're either locked horizontally OR if we're not locked vertically but would like to lock horizontally, then lock horizontally\n\t\tif (\n\t\t\tthis.directionLock === DirectionLock.Horizontal ||\n\t\t\t(this.directionLock !== DirectionLock.Vertical && Math.abs(x) > Math.abs(y) && Math.abs(x) > 14)\n\t\t) {\n\t\t\tthis.directionLock = DirectionLock.Horizontal\n\t\t\t// Do not scroll the list\n\t\t\te.preventDefault()\n\n\t\t\tif (!this.isAnimating) {\n\t\t\t\tthis.onHorizontalDrag(x, y)\n\t\t\t} // If we don't have a vertical lock yet but we would like to have it, lock vertically\n\t\t} else if (this.directionLock !== DirectionLock.Vertical && Math.abs(y) > Math.abs(x) && Math.abs(y) > size.list_row_height) {\n\t\t\tthis.directionLock = DirectionLock.Vertical\n\n\t\t\tif (!this.isAnimating) {\n\t\t\t\t// Reset the row\n\t\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\t\tif (!this.isAnimating) {\n\t\t\t\t\t\tthis.reset({\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly onTouchEnd = (e: TouchEvent) => {\n\t\tthis.gestureEnd(e)\n\t}\n\n\tprivate gestureEnd(e: TouchEvent) {\n\t\tconst delta = this.getDelta(e)\n\n\t\tif (!this.isAnimating && this.directionLock === DirectionLock.Horizontal) {\n\t\t\t// Gesture is completed\n\t\t\tthis.animating = this.onHorizontalGestureCompleted(delta)\n\t\t\tthis.isAnimating = true\n\t\t} else if (!this.isAnimating) {\n\t\t\t// Gesture is not completed, reset row\n\t\t\tthis.animating = this.reset(delta)\n\t\t\tthis.isAnimating = true\n\t\t}\n\n\t\tthis.animating.then(() => (this.isAnimating = false))\n\t\tthis.directionLock = null\n\t}\n\n\tonHorizontalDrag(xDelta: number, yDelta: number) {\n\t\t// noOp\n\t}\n\n\tonHorizontalGestureCompleted(delta: { x: number; y: number }): Promise<unknown> {\n\t\t// noOp\n\t\treturn Promise.resolve()\n\t}\n\n\treset(delta: { x: number; y: number }): Promise<unknown> {\n\t\treturn Promise.resolve()\n\t}\n\n\tgetDelta(e: any): {\n\t\tx: number\n\t\ty: number\n\t} {\n\t\treturn {\n\t\t\tx: e.changedTouches[0].clientX - this.startPos.x,\n\t\t\ty: e.changedTouches[0].clientY - this.startPos.y,\n\t\t}\n\t}\n}\n"]}