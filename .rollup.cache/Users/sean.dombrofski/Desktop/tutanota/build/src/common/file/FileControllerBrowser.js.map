{"version":3,"file":"FileControllerBrowser.js","sourceRoot":"","sources":["../../../../src/common/file/FileControllerBrowser.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,gBAAgB,EAAE,MAAM,mBAAmB,CAAA;AAEpD,OAAO,EAAE,cAAc,EAAE,qBAAqB,EAAoB,YAAY,EAAE,MAAM,qBAAqB,CAAA;AAC3G,OAAO,EAAE,iBAAiB,EAAE,MAAM,uBAAuB,CAAA;AAEzD,OAAO,EAAE,mBAAmB,EAAiB,MAAM,kCAAkC,CAAA;AAErF,gBAAgB,EAAE,CAAA;AAElB,MAAM,OAAO,qBAAsB,SAAQ,cAAc;IACxD,YAAY,UAAsB,EAAE,WAA6B;QAChE,KAAK,CAAC,UAAU,EAAE,WAAW,CAAC,CAAA;IAC/B,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,IAAc;QAChC,OAAO,qBAAqB,CAAC,IAAI,CAAC,CAAA;IACnC,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,IAAkB;QAC1C,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAA;IAChC,CAAC;IAED,KAAK,CAAC,oBAAoB,CAAC,eAAgD;QAC1E,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAChC,OAAM;QACP,CAAC;QACD,mBAAmB,CAAC,eAAe,CAAC,CAAA;QACpC,MAAM,UAAU,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,YAAY,CAAC,eAAe,EAAE,GAAG,iBAAiB,EAAE,kBAAkB,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA;QAClJ,OAAO,MAAM,qBAAqB,CAAC,UAAU,CAAC,CAAA;IAC/C,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,eAA2B;QACxC,oGAAoG;IACrG,CAAC;IAES,KAAK,CAAC,mBAAmB,CAAC,eAAgD;QACnF,0EAA0E;QAC1E,OAAO,MAAM,IAAI,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAA;IACxD,CAAC;CACD","sourcesContent":["import { DataFile } from \"../api/common/DataFile\"\nimport { assertMainOrNode } from \"../api/common/Env\"\nimport { File as TutanotaFile } from \"../api/entities/tutanota/TypeRefs.js\"\nimport { FileController, openDataFileInBrowser, ProgressObserver, zipDataFiles } from \"./FileController.js\"\nimport { sortableTimestamp } from \"@tutao/tutanota-utils\"\nimport { BlobFacade } from \"../api/worker/facades/lazy/BlobFacade.js\"\nimport { assertOnlyDataFiles, FileReference } from \"../api/common/utils/FileUtils.js\"\n\nassertMainOrNode()\n\nexport class FileControllerBrowser extends FileController {\n\tconstructor(blobFacade: BlobFacade, guiDownload: ProgressObserver) {\n\t\tsuper(blobFacade, guiDownload)\n\t}\n\n\tasync saveDataFile(file: DataFile): Promise<void> {\n\t\treturn openDataFileInBrowser(file)\n\t}\n\n\tasync downloadAndDecrypt(file: TutanotaFile): Promise<DataFile | FileReference> {\n\t\treturn this.getAsDataFile(file)\n\t}\n\n\tasync writeDownloadedFiles(downloadedFiles: Array<FileReference | DataFile>): Promise<void> {\n\t\tif (downloadedFiles.length < 1) {\n\t\t\treturn\n\t\t}\n\t\tassertOnlyDataFiles(downloadedFiles)\n\t\tconst fileToSave = downloadedFiles.length > 1 ? await zipDataFiles(downloadedFiles, `${sortableTimestamp()}-attachments.zip`) : downloadedFiles[0]\n\t\treturn await openDataFileInBrowser(fileToSave)\n\t}\n\n\tasync cleanUp(downloadedFiles: DataFile[]): Promise<void> {\n\t\t// there is nothing to do since nothing gets saved until the browser puts it into the final location\n\t}\n\n\tprotected async openDownloadedFiles(downloadedFiles: Array<FileReference | DataFile>): Promise<void> {\n\t\t// opening and downloading a file is the same thing in browser environment\n\t\treturn await this.writeDownloadedFiles(downloadedFiles)\n\t}\n}\n"]}