{"version":3,"file":"CredentialsProvider.js","sourceRoot":"","sources":["../../../../../src/common/misc/credentials/CredentialsProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import type { CredentialEncryptionMode } from \"./CredentialEncryptionMode.js\"\nimport { InterWindowEventFacadeSendDispatcher } from \"../../native/common/generatedipc/InterWindowEventFacadeSendDispatcher.js\"\nimport { SqlCipherFacade } from \"../../native/common/generatedipc/SqlCipherFacade.js\"\nimport { CredentialsInfo } from \"../../native/common/generatedipc/CredentialsInfo.js\"\nimport { CredentialType } from \"./CredentialType.js\"\nimport { PersistedCredentials } from \"../../native/common/generatedipc/PersistedCredentials.js\"\nimport { NativeCredentialsFacade } from \"../../native/common/generatedipc/NativeCredentialsFacade\"\nimport { UnencryptedCredentials } from \"../../native/common/generatedipc/UnencryptedCredentials.js\"\nimport { isAdminClient, isBrowser } from \"../../api/common/Env.js\"\n\n/**\n * Main entry point to interact with credentials, i.e. storing and retrieving credentials from/to persistence.\n */\nexport class CredentialsProvider {\n\tconstructor(\n\t\tprivate readonly credentialsFacade: NativeCredentialsFacade,\n\t\tprivate readonly sqliteCipherFacade: SqlCipherFacade | null,\n\t\tprivate readonly interWindowEventSender: InterWindowEventFacadeSendDispatcher | null,\n\t) {}\n\n\t/**\n\t * Stores credentials. If credentials already exist for login, they will be overwritten.\n\t */\n\tasync store(credentials: UnencryptedCredentials): Promise<void> {\n\t\treturn this.credentialsFacade.store(credentials)\n\t}\n\n\t/**\n\t * Change the encrypted password for the stored credentials.\n\t */\n\tasync replacePassword(credentials: CredentialsInfo, encryptedPassword: string, encryptedPassphraseKey: Uint8Array): Promise<void> {\n\t\tconst encryptedCredentials = await this.getCredentialsByUserId(credentials.userId)\n\t\tif (encryptedCredentials == null) {\n\t\t\tthrow new Error(`Trying to replace password for credentials but credentials are not persisted: ${credentials.userId}`)\n\t\t}\n\t\t// Encrypted password is encrypted with the session key and is the same for encrypted and decrypted credentials, no additional logic is needed.\n\t\tconst newEncryptedCredentials: PersistedCredentials = {\n\t\t\t...encryptedCredentials,\n\t\t\tencryptedPassword,\n\t\t\tencryptedPassphraseKey,\n\t\t}\n\t\tawait this.credentialsFacade.storeEncrypted(newEncryptedCredentials)\n\t}\n\n\tasync getCredentialsInfoByUserId(userId: Id): Promise<CredentialsInfo | null> {\n\t\treturn (await this.getCredentialsByUserId(userId))?.credentialInfo ?? null\n\t}\n\n\tasync getAllInternalCredentials(): Promise<readonly PersistedCredentials[]> {\n\t\treturn this.credentialsFacade.loadAll()\n\t}\n\n\tprivate async getCredentialsByUserId(userId: Id): Promise<PersistedCredentials | null> {\n\t\tconst allCredentials = await this.credentialsFacade.loadAll()\n\t\treturn allCredentials.find((credential) => credential.credentialInfo.userId === userId) ?? null\n\t}\n\n\t/**\n\t * Returns the full credentials for the userId passed in.\n\t * @param userId\n\t */\n\tasync getDecryptedCredentialsByUserId(userId: Id): Promise<UnencryptedCredentials | null> {\n\t\treturn this.credentialsFacade.loadByUserId(userId)\n\t}\n\n\t/**\n\t * Returns the stored credentials infos of all internal users, i.e. users that have a \"real\" tutanota account and not the ones that\n\t * have a secure external mailbox. The returned array will be sorted by login.\n\t */\n\tasync getInternalCredentialsInfos(): Promise<ReadonlyArray<CredentialsInfo>> {\n\t\tconst allCredentials = await this.credentialsFacade.loadAll()\n\t\treturn allCredentials\n\t\t\t.filter((credential) => credential.credentialInfo.type === CredentialType.Internal)\n\t\t\t.map((credential) => credential.credentialInfo)\n\t\t\t.sort((a, b) => a.login.localeCompare(b.login))\n\t}\n\n\t/**\n\t * Deletes stored credentials with specified userId.\n\t * No-op if credentials are not there.\n\t * @param opts.deleteOfflineDb whether to delete offline database. Will delete by default.\n\t */\n\tasync deleteByUserId(userId: Id, opts: { deleteOfflineDb: boolean } = { deleteOfflineDb: true }): Promise<void> {\n\t\tawait this.interWindowEventSender?.localUserDataInvalidated(userId)\n\t\tif (opts.deleteOfflineDb) {\n\t\t\tawait this.sqliteCipherFacade?.deleteDb(userId)\n\t\t}\n\t\tawait this.credentialsFacade.deleteByUserId(userId)\n\t}\n\n\t/**\n\t * Sets the credentials encryption mode, i.e. how the intermediate key used for encrypting credentials is protected.\n\t * @param encryptionMode\n\t * @throws KeyPermanentlyInvalidatedError\n\t * @throws CredentialAuthenticationError\n\t */\n\tasync setCredentialEncryptionMode(encryptionMode: CredentialEncryptionMode): Promise<void> {\n\t\tawait this.credentialsFacade.setCredentialEncryptionMode(encryptionMode)\n\t\tthis.interWindowEventSender?.reloadDeviceConfig()\n\t}\n\n\t/**\n\t * Returns the credentials encryption mode, i.e. how the intermediate key used for encrypting credentials is protected.\n\t */\n\tgetCredentialEncryptionMode(): Promise<CredentialEncryptionMode | null> {\n\t\treturn this.credentialsFacade.getCredentialEncryptionMode()\n\t}\n\n\t/**\n\t * Returns all credentials encryption modes that are supported by the device.\n\t */\n\tasync getSupportedEncryptionModes(): Promise<ReadonlyArray<CredentialEncryptionMode>> {\n\t\treturn await this.credentialsFacade.getSupportedEncryptionModes()\n\t}\n\n\t/**\n\t * Removes all stored credentials as well as any settings associated with credentials encryption.\n\t */\n\tasync clearCredentials(reason: Error | string): Promise<void> {\n\t\tconsole.warn(\"clearing all stored credentials:\", reason)\n\t\tawait this.credentialsFacade.clear()\n\t}\n}\n\nexport function usingKeychainAuthenticationWithOptions(): boolean {\n\treturn !isBrowser() && !isAdminClient()\n}\n"]}