{"version":3,"file":"BlobAccessTokenFacade.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/facades/BlobAccessTokenFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { ArchiveDataType, BlobAccessTokenKind } from \"../../common/TutanotaConstants\"\nimport { assertWorkerOrNode } from \"../../common/Env\"\nimport { BlobAccessTokenService } from \"../../entities/storage/Services\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { BlobServerAccessInfo, createBlobAccessTokenPostIn, createBlobReadData, createBlobWriteData, createInstanceId } from \"../../entities/storage/TypeRefs\"\nimport { DateProvider } from \"../../common/DateProvider.js\"\nimport { resolveTypeReference } from \"../../common/EntityFunctions.js\"\nimport { AuthDataProvider } from \"./UserFacade.js\"\nimport { deduplicate, first, isEmpty, lazyMemoized, TypeRef } from \"@tutao/tutanota-utils\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { BlobLoadOptions } from \"./lazy/BlobFacade.js\"\nimport { BlobReferencingInstance } from \"../../common/utils/BlobUtils.js\"\n\nassertWorkerOrNode()\n\n/**\n * The BlobAccessTokenFacade requests blobAccessTokens from the BlobAccessTokenService to get or post to the BlobService (binary blobs)\n * or DefaultBlobElementResource (instances).\n *\n * All tokens are cached.\n */\nexport class BlobAccessTokenFacade {\n\t// cache for blob access tokens that are valid for the whole archive (key:<archiveId>)\n\t// cache for blob access tokens that are valid for blobs from a given instance were the user does not own the archive (key:<instanceElementId>).\n\tprivate readonly readCache: BlobAccessTokenCache\n\t// cache for upload requests are valid for the whole archive (key:<ownerGroup + archiveDataType>).\n\tprivate readonly writeCache: BlobAccessTokenCache\n\n\tconstructor(private readonly serviceExecutor: IServiceExecutor, private readonly authDataProvider: AuthDataProvider, dateProvider: DateProvider) {\n\t\tthis.readCache = new BlobAccessTokenCache(dateProvider)\n\t\tthis.writeCache = new BlobAccessTokenCache(dateProvider)\n\t}\n\n\t/**\n\t * Requests a token that allows uploading blobs for the given ArchiveDataType and ownerGroup.\n\t * @param archiveDataType The type of data that should be stored.\n\t * @param ownerGroupId The ownerGroup were the data belongs to (e.g. group of type mail)\n\t */\n\tasync requestWriteToken(archiveDataType: ArchiveDataType, ownerGroupId: Id): Promise<BlobServerAccessInfo> {\n\t\tconst requestNewToken = async () => {\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType,\n\t\t\t\twrite: createBlobWriteData({\n\t\t\t\t\tarchiveOwnerGroup: ownerGroupId,\n\t\t\t\t}),\n\t\t\t\tread: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest)\n\t\t\treturn blobAccessInfo\n\t\t}\n\t\tconst key = this.makeWriteCacheKey(ownerGroupId, archiveDataType)\n\t\treturn this.writeCache.getToken(key, [], requestNewToken)\n\t}\n\n\tprivate makeWriteCacheKey(ownerGroupId: string, archiveDataType: ArchiveDataType) {\n\t\treturn ownerGroupId + archiveDataType\n\t}\n\n\t/**\n\t * Remove a given write token from the cache.\n\t * @param archiveDataType\n\t * @param ownerGroupId\n\t */\n\tevictWriteToken(archiveDataType: ArchiveDataType, ownerGroupId: Id): void {\n\t\tconst key = this.makeWriteCacheKey(ownerGroupId, archiveDataType)\n\t\tthis.writeCache.evictArchiveOrGroupKey(key)\n\t}\n\n\t/**\n\t * Requests a token that grants read access to all blobs that are referenced by the given instances.\n\t * A user must be owner of the instance but must not be owner of the archive where the blobs are stored in.\n\t *\n\t * @param archiveDataType specify the data type\n\t * @param referencingInstances the instances that references the blobs\n\t * @param blobLoadOptions load options when loading blobs\n\t * @throws ProgrammingError if instances are not part of the same list or blobs are not part of the same archive.\n\t */\n\tasync requestReadTokenMultipleInstances(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstances: readonly BlobReferencingInstance[],\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<BlobServerAccessInfo> {\n\t\tif (isEmpty(referencingInstances)) {\n\t\t\tthrow new ProgrammingError(\"Must pass at least one referencing instance\")\n\t\t}\n\t\tconst instanceListId = referencingInstances[0].listId\n\t\tif (!referencingInstances.every((instance) => instance.listId === instanceListId)) {\n\t\t\tthrow new ProgrammingError(\"All referencing instances must be part of the same list\")\n\t\t}\n\n\t\tconst archiveId = this.getArchiveId(referencingInstances)\n\n\t\tconst requestNewToken = lazyMemoized(async () => {\n\t\t\tconst instanceIds = referencingInstances.map(({ elementId }) => createInstanceId({ instanceId: elementId }))\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType,\n\t\t\t\tread: createBlobReadData({\n\t\t\t\t\tarchiveId,\n\t\t\t\t\tinstanceListId,\n\t\t\t\t\tinstanceIds,\n\t\t\t\t}),\n\t\t\t\twrite: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest, blobLoadOptions)\n\t\t\treturn blobAccessInfo\n\t\t})\n\n\t\treturn this.readCache.getToken(\n\t\t\tarchiveId,\n\t\t\treferencingInstances.map((instance) => instance.elementId),\n\t\t\trequestNewToken,\n\t\t)\n\t}\n\n\t/**\n\t * Requests a token that grants read access to all blobs that are referenced by the given instance.\n\t * A user must be owner of the instance but must not be owner of the archive were the blobs are stored in.\n\t * @param archiveDataType specify the data type\n\t * @param referencingInstance the instance that references the blobs\n\t * @param blobLoadOptions load options when loading blobs\n\t */\n\tasync requestReadTokenBlobs(\n\t\tarchiveDataType: ArchiveDataType,\n\t\treferencingInstance: BlobReferencingInstance,\n\t\tblobLoadOptions: BlobLoadOptions,\n\t): Promise<BlobServerAccessInfo> {\n\t\tconst archiveId = this.getArchiveId([referencingInstance])\n\t\tconst requestNewToken = async () => {\n\t\t\tconst instanceListId = referencingInstance.listId\n\t\t\tconst instanceId = referencingInstance.elementId\n\t\t\tconst instanceIds = [createInstanceId({ instanceId })]\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType,\n\t\t\t\tread: createBlobReadData({\n\t\t\t\t\tarchiveId,\n\t\t\t\t\tinstanceListId,\n\t\t\t\t\tinstanceIds,\n\t\t\t\t}),\n\t\t\t\twrite: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest, blobLoadOptions)\n\t\t\treturn blobAccessInfo\n\t\t}\n\t\treturn this.readCache.getToken(archiveId, [referencingInstance.elementId], requestNewToken)\n\t}\n\n\t/**\n\t * Remove a given read blobs token from the cache.\n\t * @param referencingInstance\n\t */\n\tevictReadBlobsToken(referencingInstance: BlobReferencingInstance): void {\n\t\tthis.readCache.evictInstanceId(referencingInstance.elementId)\n\t\tconst archiveId = this.getArchiveId([referencingInstance])\n\t\tthis.readCache.evictArchiveOrGroupKey(archiveId)\n\t}\n\n\t/**\n\t * Remove a given read blobs token from the cache.\n\t * @param referencingInstances\n\t */\n\tevictReadBlobsTokenMultipleBlobs(referencingInstances: BlobReferencingInstance[]): void {\n\t\tthis.readCache.evictAll(referencingInstances.map((instance) => instance.elementId))\n\t\tconst archiveId = this.getArchiveId(referencingInstances)\n\t\tthis.readCache.evictArchiveOrGroupKey(archiveId)\n\t}\n\n\t/**\n\t * Requests a token that grants access to all blobs stored in the given archive. The user must own the archive (member of group)\n\t * @param archiveId ID for the archive to read blobs from\n\t */\n\tasync requestReadTokenArchive(archiveId: Id): Promise<BlobServerAccessInfo> {\n\t\tconst requestNewToken = async () => {\n\t\t\tconst tokenRequest = createBlobAccessTokenPostIn({\n\t\t\t\tarchiveDataType: null,\n\t\t\t\tread: createBlobReadData({\n\t\t\t\t\tarchiveId,\n\t\t\t\t\tinstanceIds: [],\n\t\t\t\t\tinstanceListId: null,\n\t\t\t\t}),\n\t\t\t\twrite: null,\n\t\t\t})\n\t\t\tconst { blobAccessInfo } = await this.serviceExecutor.post(BlobAccessTokenService, tokenRequest)\n\t\t\treturn blobAccessInfo\n\t\t}\n\t\treturn this.readCache.getToken(archiveId, [], requestNewToken)\n\t}\n\n\t/**\n\t * Remove a given read archive token from the cache.\n\t * @param archiveId\n\t */\n\tevictArchiveToken(archiveId: Id): void {\n\t\tthis.readCache.evictArchiveOrGroupKey(archiveId)\n\t}\n\n\tprivate getArchiveId(referencingInstances: readonly BlobReferencingInstance[]): Id {\n\t\tif (isEmpty(referencingInstances)) {\n\t\t\tthrow new ProgrammingError(\"Must pass at least one referencing instance\")\n\t\t}\n\t\tconst archiveIds = new Set<Id>()\n\t\tfor (const referencingInstance of referencingInstances) {\n\t\t\tif (isEmpty(referencingInstance.blobs)) {\n\t\t\t\tthrow new ProgrammingError(\"must pass blobs\")\n\t\t\t}\n\t\t\tfor (const blob of referencingInstance.blobs) {\n\t\t\t\tarchiveIds.add(blob.archiveId)\n\t\t\t}\n\t\t}\n\n\t\tif (archiveIds.size != 1) {\n\t\t\tthrow new Error(`only one archive id allowed, but was ${archiveIds}`)\n\t\t}\n\t\treturn referencingInstances[0].blobs[0].archiveId\n\t}\n\n\t/**\n\t *\n\t * @param blobServerAccessInfo\n\t * @param additionalRequestParams\n\t * @param typeRef the typeRef that shall be used to determine the correct model version\n\t */\n\tpublic async createQueryParams(blobServerAccessInfo: BlobServerAccessInfo, additionalRequestParams: Dict, typeRef: TypeRef<any>): Promise<Dict> {\n\t\tconst typeModel = await resolveTypeReference(typeRef)\n\t\treturn Object.assign(\n\t\t\tadditionalRequestParams,\n\t\t\t{\n\t\t\t\tblobAccessToken: blobServerAccessInfo.blobAccessToken,\n\t\t\t\tv: typeModel.version,\n\t\t\t},\n\t\t\tthis.authDataProvider.createAuthHeaders(),\n\t\t)\n\t}\n}\n\n/**\n * Checks if the given access token can be used for another blob service requests.\n * @param blobServerAccessInfo\n * @param dateProvider\n */\nfunction canBeUsedForAnotherRequest(blobServerAccessInfo: BlobServerAccessInfo, dateProvider: DateProvider): boolean {\n\treturn blobServerAccessInfo.expires.getTime() > dateProvider.now()\n}\n\nclass BlobAccessTokenCache {\n\tprivate readonly instanceMap: Map<Id, BlobServerAccessInfo> = new Map()\n\tprivate readonly archiveMap: Map<Id, BlobServerAccessInfo> = new Map()\n\n\tconstructor(private readonly dateProvider: DateProvider) {}\n\n\t/**\n\t * Get a token from the cache or from {@param loader}.\n\t * First will try to use the token keyed by {@param archiveOrGroupKey}, otherwise it will try to find a token valid for all of {@param instanceIds}.\n\t */\n\tpublic async getToken(\n\t\tarchiveOrGroupKey: Id | null,\n\t\tinstanceIds: readonly Id[],\n\t\tloader: () => Promise<BlobServerAccessInfo>,\n\t): Promise<BlobServerAccessInfo> {\n\t\tconst archiveToken = archiveOrGroupKey ? this.archiveMap.get(archiveOrGroupKey) : null\n\t\tif (archiveToken != null && canBeUsedForAnotherRequest(archiveToken, this.dateProvider)) {\n\t\t\treturn archiveToken\n\t\t}\n\n\t\tconst tokens = deduplicate(instanceIds.map((id) => this.instanceMap.get(id) ?? null))\n\t\tconst firstTokenFound = first(tokens)\n\t\tif (tokens.length != 1 || firstTokenFound == null || !canBeUsedForAnotherRequest(firstTokenFound, this.dateProvider)) {\n\t\t\tconst newToken = await loader()\n\t\t\tif (archiveOrGroupKey != null && newToken.tokenKind === BlobAccessTokenKind.Archive) {\n\t\t\t\tthis.archiveMap.set(archiveOrGroupKey, newToken)\n\t\t\t} else {\n\t\t\t\tfor (const id of instanceIds) {\n\t\t\t\t\tthis.instanceMap.set(id, newToken)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newToken\n\t\t} else {\n\t\t\treturn firstTokenFound\n\t\t}\n\t}\n\n\tpublic evictInstanceId(id: Id): void {\n\t\tthis.evictAll([id])\n\t}\n\n\tpublic evictArchiveOrGroupKey(id: Id): void {\n\t\tthis.archiveMap.delete(id)\n\t}\n\n\tpublic evictAll(ids: Id[]): void {\n\t\tfor (const id of ids) {\n\t\t\tthis.instanceMap.delete(id)\n\t\t}\n\t}\n}\n"]}