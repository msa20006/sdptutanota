{"version":3,"file":"TempFs.js","sourceRoot":"","sources":["../../../../../src/common/desktop/files/TempFs.ts"],"names":[],"mappings":"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","sourcesContent":["import path from \"node:path\"\nimport { ElectronExports, FsExports } from \"../ElectronExportTypes.js\"\nimport { CryptoFunctions } from \"../CryptoFns.js\"\nimport { base64ToBase64Url, uint8ArrayToBase64, uint8ArrayToHex } from \"@tutao/tutanota-utils\"\n\ntype TmpSub = \"reg\" | \"encrypted\" | \"decrypted\"\n\n/**\n * wrapper to access the tmp scratch file system used for downloading, uploading, encrypting and decrypting files before\n * putting them into the user's desired location.\n *\n * this currently randomizes file names before uploading files. ideally, we would prevent\n * file name collisions generally by always randomizing any file names written into this temp\n * location - the calling site has the actual file names and uses them for uploading and\n * putting files into the user's download folder.\n * */\nexport class TempFs {\n\tprivate readonly topLevelTempDir = \"tutanota\"\n\t/** we store all temporary files in a directory with a random name, so that the download location is not predictable */\n\tprivate readonly randomDirectoryName: string\n\n\tconstructor(private readonly fs: FsExports, private readonly electron: ElectronExports, private readonly cryptoFunctions: CryptoFunctions) {\n\t\tthis.randomDirectoryName = base64ToBase64Url(uint8ArrayToBase64(cryptoFunctions.randomBytes(16)))\n\t}\n\n\tclear() {\n\t\tconst topLvlTmpDir = path.join(this.electron.app.getPath(\"temp\"), this.topLevelTempDir)\n\t\ttry {\n\t\t\tconst tmps = this.fs.readdirSync(topLvlTmpDir)\n\t\t\tfor (const tmp of tmps) {\n\t\t\t\tconst tmpSubPath = path.join(topLvlTmpDir, tmp)\n\t\t\t\ttry {\n\t\t\t\t\tthis.fs.rmSync(tmpSubPath, { recursive: true })\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// ignore if the file was deleted between readdir and delete\n\t\t\t\t\t// or if it's not our tmp dir\n\t\t\t\t\tif (e.code !== \"ENOENT\" && e.code !== \"EACCES\") throw e\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// the tmp dir doesn't exist, everything's fine\n\t\t\tif (e.code !== \"ENOENT\") throw e\n\t\t}\n\t}\n\n\t/**\n\t * Get a path to the tutanota temporary directory\n\t * the hierarchy is\n\t * [electron tmp dir]\n\t * [tutanota tmp]\n\t *\n\t * the directory will be created if it doesn't already exist\n\t *\n\t * a randomly named subdirectory will be included\n\t *\n\t * if `noRandomDirectory` then random directory will not be included in the path,\n\t * and the whole directory will not be created\n\t * @returns {string}\n\t */\n\tgetTutanotaTempPath(): string {\n\t\tconst directory = path.join(this.electron.app.getPath(\"temp\"), this.topLevelTempDir, this.randomDirectoryName)\n\n\t\t// only readable by owner (current user)\n\t\tthis.fs.mkdirSync(directory, { recursive: true, mode: 0o700 })\n\n\t\treturn path.join(directory)\n\t}\n\n\tasync acquireSingleInstanceLock(): Promise<boolean> {\n\t\tconst lockfilePath = this.getLockFilePath()\n\t\t// first, put down a file in temp that contains our version.\n\t\t// will overwrite if it already exists.\n\t\t// errors are ignored and we fall back to a version agnostic single instance lock.\n\t\ttry {\n\t\t\tawait this.fs.promises.writeFile(lockfilePath, this.electron.app.getVersion(), \"utf8\")\n\t\t} catch (e) {\n\t\t\t// ignored!\n\t\t}\n\t\t// try to get the lock, if there's already an instance running,\n\t\t// it will get a message about this.\n\t\treturn this.electron.app.requestSingleInstanceLock()\n\t}\n\n\tprivate getLockFilePath() {\n\t\t// don't get temp dir path from DesktopDownloadManager because the path returned from there may be deleted at some point,\n\t\t// we want to put the lockfile in root tmp so it persists\n\t\treturn path.join(this.electron.app.getPath(\"temp\"), \"tutanota_desktop_lockfile\")\n\t}\n\n\t/**\n\t * reads the lockfile and then writes the own version into the lockfile\n\t * @returns {Promise<boolean>} whether the lock was overridden by another version since the last read\n\t */\n\tasync singleInstanceLockOverridden(): Promise<boolean> {\n\t\tconst lockfilePath = this.getLockFilePath()\n\t\tconst version = await this.fs.promises.readFile(lockfilePath, \"utf8\")\n\t\ttry {\n\t\t\tawait this.fs.promises.writeFile(lockfilePath, this.electron.app.getVersion(), \"utf8\")\n\t\t\treturn version !== this.electron.app.getVersion()\n\t\t} catch (e) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t/**\n\t * Writes contents with a random file name into the tmp directory\n\t * @param contents the contents of the file to write\n\t * @param subfolder the subfolder of the tmp files to write to\n\t * @param option the options for write file as encoding and file permissions\n\t * @returns path to the written file\n\t */\n\tasync writeToDisk(contents: string | Uint8Array, subfolder: TmpSub, option?: { encoding: BufferEncoding; mode: number }): Promise<string> {\n\t\tconst tmpPath = path.join(this.getTutanotaTempPath(), subfolder)\n\t\tawait this.fs.promises.mkdir(tmpPath, { recursive: true })\n\n\t\tconst filename = uint8ArrayToHex(this.cryptoFunctions.randomBytes(12))\n\t\tconst filePath = path.join(tmpPath, filename)\n\n\t\tawait this.fs.promises.writeFile(filePath, contents, option)\n\n\t\treturn filePath\n\t}\n\n\t/** removes the given subfolder of our tmp directory with all its contents */\n\tasync clearTmpSub(subFolder: string): Promise<void> {\n\t\tconst tmpPath = path.join(this.getTutanotaTempPath(), subFolder)\n\t\tthis.fs.rmSync(tmpPath, { force: true, recursive: true, maxRetries: 3 })\n\t}\n\n\tasync ensureEncryptedDir(): Promise<string> {\n\t\tconst downloadDirectory = this.getEncryptedTempDir()\n\t\tawait this.fs.promises.mkdir(downloadDirectory, { recursive: true })\n\t\treturn downloadDirectory\n\t}\n\n\tasync ensureUnencrytpedDir(): Promise<string> {\n\t\tconst downloadDirectory = this.getUnencryptedTempDir()\n\t\tawait this.fs.promises.mkdir(downloadDirectory, { recursive: true })\n\t\treturn downloadDirectory\n\t}\n\n\tprivate getEncryptedTempDir() {\n\t\treturn path.join(this.getTutanotaTempPath(), \"encrypted\")\n\t}\n\n\tprivate getUnencryptedTempDir() {\n\t\treturn path.join(this.getTutanotaTempPath(), \"decrypted\")\n\t}\n}\n"]}