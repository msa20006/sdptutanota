{"version":3,"file":"KeyAuthenticationFacade.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/facades/KeyAuthenticationFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { CryptoWrapper } from \"../crypto/CryptoWrapper.js\"\nimport { assertNotNull, concat, KeyVersion } from \"@tutao/tutanota-utils\"\nimport { Aes256Key, AesKey, bitArrayToUint8Array, EncryptedPqKeyPairs, KeyPairType, MacTag, PQPublicKeys } from \"@tutao/tutanota-crypto\"\nimport { assertWorkerOrNode } from \"../../common/Env.js\"\nimport { KeyMac, PubDistributionKey } from \"../../entities/sys/TypeRefs.js\"\nimport { PublicKeys } from \"./PublicKeyProvider.js\"\n\nassertWorkerOrNode()\n\ntype AuthenticationBindingData = {\n\tuserGroupId: Id\n\tadminGroupId: Id\n}\n\ntype BaseKeyAuthenticationParams = {\n\ttagType: keyof typeof systemMap\n\tsourceOfTrust: { [name: string]: AesKey }\n\t// this can be a user group key, an admin group key, an admin group public key or a distribution public key\n\tuntrustedKey: { [name: string]: AesKey | PQPublicKeys }\n\tbindingData: AuthenticationBindingData\n}\n\nexport type UserGroupKeyAuthenticationParams = BaseKeyAuthenticationParams & {\n\ttagType: \"USER_GROUP_KEY_TAG\"\n\tuntrustedKey: { newUserGroupKey: Aes256Key }\n\tsourceOfTrust: { currentUserGroupKey: AesKey }\n\tbindingData: AuthenticationBindingData & {\n\t\tcurrentUserGroupKeyVersion: KeyVersion\n\t\tnewUserGroupKeyVersion: KeyVersion\n\t\tnewAdminGroupKeyVersion: KeyVersion\n\t}\n}\n\n/**\n * A system to authenticate some key.\n */\ntype KeyAuthenticationSystem<T extends KeyAuthenticationParams> = {\n\t/**\n\t * Canonicalizes the data we want to authenticate, i.e., the new key and some binding data, into a byte array.\n\t * @param params\n\t */\n\tgenerateAuthenticationData(params: T): Uint8Array\n\t/**\n\t * Derives the authentication key from a trusted key and some additional binding parameters.\n\t * @param params\n\t * @param cryptoWrapper\n\t */\n\tderiveKey(params: T, cryptoWrapper: CryptoWrapper): Aes256Key\n}\n\n/**\n * Purpose: prove to admins that the new User Group Key is authentic.\n * By deriving this key from the current User Group Key, the admin knows that it was created by someone who had access to this key,\n * that is, either the user or another admin.\n */\nconst userGroupKeyAuthenticationSystem: KeyAuthenticationSystem<UserGroupKeyAuthenticationParams> = {\n\tderiveKey(\n\t\t{ bindingData: { userGroupId, adminGroupId, newAdminGroupKeyVersion, newUserGroupKeyVersion, currentUserGroupKeyVersion }, sourceOfTrust },\n\t\tcryptoWrapper,\n\t) {\n\t\treturn cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentUserGroupKeyVersion}, newAdminGroupKeyVersion: ${newAdminGroupKeyVersion}, newUserGroupKeyVersion: ${newUserGroupKeyVersion}`,\n\t\t\tkey: sourceOfTrust.currentUserGroupKey,\n\t\t\tcontext: \"newUserGroupKeyAuthKeyForRotationAsNonAdminUser\",\n\t\t})\n\t},\n\tgenerateAuthenticationData({ untrustedKey: { newUserGroupKey } }) {\n\t\treturn bitArrayToUint8Array(newUserGroupKey)\n\t},\n}\n\nexport type NewAdminPubKeyAuthenticationParams = BaseKeyAuthenticationParams & {\n\ttagType: \"NEW_ADMIN_PUB_KEY_TAG\"\n\tuntrustedKey: { newAdminPubKey: PQPublicKeys }\n\tsourceOfTrust: { receivingUserGroupKey: AesKey } // this receiving user is an admin receiving the new admin group pub keys\n\tbindingData: AuthenticationBindingData & {\n\t\tnewAdminGroupKeyVersion: KeyVersion\n\t\tcurrentReceivingUserGroupKeyVersion: KeyVersion\n\t}\n}\n\n/**\n * Purpose: prove to users that the new Admin Group Public Key is authentic.\n * By deriving this key from the current User Group Key, the user knows that it was created either by someone who had access to this key,\n * that is, either themselves or an admin.\n */\nconst newAdminPubKeyAuthenticationSystem: KeyAuthenticationSystem<NewAdminPubKeyAuthenticationParams> = {\n\tderiveKey({ bindingData: { userGroupId, adminGroupId, newAdminGroupKeyVersion, currentReceivingUserGroupKeyVersion }, sourceOfTrust }, cryptoWrapper) {\n\t\treturn cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentReceivingUserGroupKeyVersion}, newAdminGroupKeyVersion: ${newAdminGroupKeyVersion}`,\n\t\t\tkey: sourceOfTrust.receivingUserGroupKey,\n\t\t\tcontext: \"newAdminPubKeyAuthKeyForUserGroupKeyRotation\",\n\t\t})\n\t},\n\tgenerateAuthenticationData({\n\t\tuntrustedKey: {\n\t\t\tnewAdminPubKey: { eccPublicKey, kyberPublicKey },\n\t\t},\n\t}) {\n\t\treturn concat(eccPublicKey, kyberPublicKey.raw)\n\t},\n}\n\nexport type PubDistKeyAuthenticationParams = BaseKeyAuthenticationParams & {\n\ttagType: \"PUB_DIST_KEY_TAG\"\n\tuntrustedKey: { distPubKey: PQPublicKeys }\n\tsourceOfTrust: { currentAdminGroupKey: AesKey }\n\tbindingData: AuthenticationBindingData & {\n\t\tcurrentUserGroupKeyVersion: KeyVersion\n\t\tcurrentAdminGroupKeyVersion: KeyVersion\n\t}\n}\n\n/**\n * Purpose: prove to other admins that the Distribution Public Key is authentic.\n * By deriving this key from the current Admin Group Key, the admin knows that it was created by someone who had access to this key,\n * that is, either themselves or another admin.\n */\nconst pubDistKeyAuthenticationSystem: KeyAuthenticationSystem<PubDistKeyAuthenticationParams> = {\n\tderiveKey({ bindingData: { adminGroupId, userGroupId, currentUserGroupKeyVersion, currentAdminGroupKeyVersion }, sourceOfTrust }, cryptoWrapper) {\n\t\treturn cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentUserGroupKeyVersion}, currentAdminGroupKeyVersion: ${currentAdminGroupKeyVersion}`,\n\t\t\tkey: sourceOfTrust.currentAdminGroupKey,\n\t\t\tcontext: \"adminGroupDistKeyPairAuthKeyForMultiAdminRotation\",\n\t\t})\n\t},\n\tgenerateAuthenticationData({\n\t\tuntrustedKey: {\n\t\t\tdistPubKey: { eccPublicKey, kyberPublicKey },\n\t\t},\n\t}) {\n\t\treturn concat(eccPublicKey, kyberPublicKey.raw)\n\t},\n}\n\nexport type AdminSymKeyAuthenticationParams = BaseKeyAuthenticationParams & {\n\ttagType: \"ADMIN_SYM_KEY_TAG\"\n\tuntrustedKey: { newAdminGroupKey: Aes256Key }\n\tsourceOfTrust: { currentReceivingUserGroupKey: AesKey } // this receiving user is an admin receiving the new admin group sym key\n\tbindingData: AuthenticationBindingData & {\n\t\tnewAdminGroupKeyVersion: KeyVersion\n\t\tcurrentReceivingUserGroupKeyVersion: KeyVersion\n\t}\n}\n\n/**\n * Purpose: prove to other admins that the new Admin Group Symmetric Key is authentic.\n * By deriving this key from the current User Group Key, the admin user knows that it was created either by someone who had access to this key,\n * that is, either themselves or another admin.\n */\nconst adminSymKeyAuthenticationSystem: KeyAuthenticationSystem<AdminSymKeyAuthenticationParams> = {\n\tderiveKey({ bindingData: { adminGroupId, userGroupId, newAdminGroupKeyVersion, currentReceivingUserGroupKeyVersion }, sourceOfTrust }, cryptoWrapper) {\n\t\treturn cryptoWrapper.deriveKeyWithHkdf({\n\t\t\tsalt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentReceivingUserGroupKeyVersion}, newAdminGroupKeyVersion: ${newAdminGroupKeyVersion}`,\n\t\t\tkey: sourceOfTrust.currentReceivingUserGroupKey,\n\t\t\tcontext: \"newAdminSymKeyAuthKeyForMultiAdminRotationAsUser\",\n\t\t})\n\t},\n\tgenerateAuthenticationData({ untrustedKey: { newAdminGroupKey } }) {\n\t\treturn bitArrayToUint8Array(newAdminGroupKey)\n\t},\n}\n\nexport type KeyAuthenticationParams =\n\t| UserGroupKeyAuthenticationParams\n\t| NewAdminPubKeyAuthenticationParams\n\t| PubDistKeyAuthenticationParams\n\t| AdminSymKeyAuthenticationParams\n\nconst systemMap = {\n\tUSER_GROUP_KEY_TAG: userGroupKeyAuthenticationSystem,\n\tNEW_ADMIN_PUB_KEY_TAG: newAdminPubKeyAuthenticationSystem,\n\tPUB_DIST_KEY_TAG: pubDistKeyAuthenticationSystem,\n\tADMIN_SYM_KEY_TAG: adminSymKeyAuthenticationSystem,\n}\n\n/**\n * Authenticates keys by deriving trust in another key using a Message Authentication Code (MAC tag).\n */\nexport class KeyAuthenticationFacade {\n\tconstructor(private readonly cryptoWrapper: CryptoWrapper) {}\n\n\t/**\n\t * Computes a MAC tag using an existing key authentication system.\n\t * @param keyAuthenticationParams Parameters for the chosen key authentication system, containing trusted key, key to be verified, and binding data\n\t */\n\tpublic computeTag(keyAuthenticationParams: KeyAuthenticationParams): MacTag {\n\t\tconst keyAuthenticationSystem: KeyAuthenticationSystem<KeyAuthenticationParams> = systemMap[keyAuthenticationParams.tagType]\n\t\tconst authKey = keyAuthenticationSystem.deriveKey(keyAuthenticationParams, this.cryptoWrapper)\n\t\tconst authData = keyAuthenticationSystem.generateAuthenticationData(keyAuthenticationParams)\n\t\treturn this.cryptoWrapper.hmacSha256(authKey, authData)\n\t}\n\n\t/**\n\t * Verifies a MAC tag using an existing key authentication system.\n\t * @param keyAuthenticationParams Parameters for the chosen key authentication system, containing trusted key, key to be verified, and binding data\n\t * @param tag The MAC tag to be verified. Must be a branded MacTag, which you can get with brandKeyMac() in most cases\n\t */\n\tpublic verifyTag(keyAuthenticationParams: KeyAuthenticationParams, tag: MacTag): void {\n\t\tconst keyAuthenticationSystem: KeyAuthenticationSystem<KeyAuthenticationParams> = systemMap[keyAuthenticationParams.tagType]\n\t\tconst authKey = keyAuthenticationSystem.deriveKey(keyAuthenticationParams, this.cryptoWrapper)\n\t\tconst authData = keyAuthenticationSystem.generateAuthenticationData(keyAuthenticationParams)\n\t\tthis.cryptoWrapper.verifyHmacSha256(authKey, authData, tag)\n\t}\n}\n\ntype BrandedKeyMac = Omit<KeyMac, \"mac\"> & { tag: MacTag }\n\n/**\n * Brands a KeyMac so that it has a branded MacTag, which can be used in authentication methods.\n */\nexport function brandKeyMac(keyMac: KeyMac): BrandedKeyMac {\n\treturn keyMac as BrandedKeyMac\n}\n\n/**\n * Converts some form of public PQ keys to the PQPublicKeys type. Assumes pubEccKey and pubKyberKey exist.\n * @param kp\n */\nexport function asPQPublicKeys(kp: EncryptedPqKeyPairs | PubDistributionKey | PublicKeys): PQPublicKeys {\n\treturn {\n\t\tkeyPairType: KeyPairType.TUTA_CRYPT,\n\t\teccPublicKey: assertNotNull(kp.pubEccKey),\n\t\tkyberPublicKey: {\n\t\t\traw: assertNotNull(kp.pubKyberKey),\n\t\t},\n\t}\n}\n"]}