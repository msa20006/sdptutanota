{"version":3,"file":"EventBusClient.js","sourceRoot":"","sources":["../../../../../src/common/api/worker/EventBusClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { assertWorkerOrNode } from \"../common/Env\"\nimport {\n\tAccessBlockedError,\n\tAccessDeactivatedError,\n\tConnectionError,\n\thandleRestError,\n\tNotAuthorizedError,\n\tServiceUnavailableError,\n\tSessionExpiredError,\n} from \"../common/error/RestError\"\nimport {\n\tcreateWebsocketLeaderStatus,\n\tEntityEventBatch,\n\tEntityEventBatchTypeRef,\n\tEntityUpdate,\n\tWebsocketCounterData,\n\tWebsocketCounterDataTypeRef,\n\tWebsocketEntityData,\n\tWebsocketEntityDataTypeRef,\n\tWebsocketLeaderStatus,\n\tWebsocketLeaderStatusTypeRef,\n} from \"../entities/sys/TypeRefs.js\"\nimport { binarySearch, delay, getTypeId, identity, lastThrow, ofClass, promiseFilter, randomIntFromInterval, TypeRef } from \"@tutao/tutanota-utils\"\nimport { OutOfSyncError } from \"../common/error/OutOfSyncError\"\nimport { CloseEventBusOption, GroupType, SECOND_MS } from \"../common/TutanotaConstants\"\nimport { CancelledError } from \"../common/error/CancelledError\"\nimport { EntityClient } from \"../common/EntityClient\"\nimport type { QueuedBatch } from \"./EventQueue.js\"\nimport { EventQueue } from \"./EventQueue.js\"\nimport { ProgressMonitorDelegate } from \"./ProgressMonitorDelegate\"\nimport { compareOldestFirst, GENERATED_MAX_ID, GENERATED_MIN_ID, getElementId, getListId } from \"../common/utils/EntityUtils\"\nimport { InstanceMapper } from \"./crypto/InstanceMapper\"\nimport { WsConnectionState } from \"../main/WorkerClient\"\nimport { EntityRestCache } from \"./rest/DefaultEntityRestCache.js\"\nimport { SleepDetector } from \"./utils/SleepDetector.js\"\nimport sysModelInfo from \"../entities/sys/ModelInfo.js\"\nimport tutanotaModelInfo from \"../entities/tutanota/ModelInfo.js\"\nimport { resolveTypeReference } from \"../common/EntityFunctions.js\"\nimport { PhishingMarkerWebsocketData, PhishingMarkerWebsocketDataTypeRef, ReportedMailFieldMarker } from \"../entities/tutanota/TypeRefs\"\nimport { UserFacade } from \"./facades/UserFacade\"\nimport { ExposedProgressTracker } from \"../main/ProgressTracker.js\"\n\nassertWorkerOrNode()\n\nexport const enum EventBusState {\n\tAutomatic = \"automatic\",\n\t// automatic reconnection is enabled\n\tSuspended = \"suspended\",\n\t// automatic reconnection is suspended but can be enabled again\n\tTerminated = \"terminated\", // automatic reconnection is disabled and websocket is closed but can be opened again by calling connect explicit\n}\n\n// EntityEventBatches expire after 45 days. keep a time diff security of one day.\nexport const ENTITY_EVENT_BATCH_EXPIRE_MS = 44 * 24 * 60 * 60 * 1000\nconst RETRY_AFTER_SERVICE_UNAVAILABLE_ERROR_MS = 30000\nconst NORMAL_SHUTDOWN_CLOSE_CODE = 1\n/**\n * Reconnection interval bounds. When we reconnect we pick a random number of seconds in a range to prevent that all the clients connect at the same time which\n * would put unnecessary load on the server.\n * The range depends on the number of attempts and the server response.\n * */\nconst RECONNECT_INTERVAL = Object.freeze({\n\tSMALL: [5, 10],\n\tMEDIUM: [20, 40],\n\tLARGE: [60, 120],\n} as const)\n// we store the last 1000 event ids per group, so we know if an event was already processed.\n// it is not sufficient to check the last event id because a smaller event id may arrive later\n// than a bigger one if the requests are processed in parallel on the server\nconst MAX_EVENT_IDS_QUEUE_LENGTH = 1000\n\n/** Known types of messages that can be received over websocket. */\nconst enum MessageType {\n\tEntityUpdate = \"entityUpdate\",\n\tUnreadCounterUpdate = \"unreadCounterUpdate\",\n\tPhishingMarkers = \"phishingMarkers\",\n\tLeaderStatus = \"leaderStatus\",\n}\n\nexport const enum ConnectMode {\n\tInitial,\n\tReconnect,\n}\n\nexport interface EventBusListener {\n\tonWebsocketStateChanged(state: WsConnectionState): unknown\n\n\tonCounterChanged(counter: WebsocketCounterData): unknown\n\n\tonLeaderStatusChanged(leaderStatus: WebsocketLeaderStatus): unknown\n\n\tonEntityEventsReceived(events: EntityUpdate[], batchId: Id, groupId: Id): Promise<void>\n\n\t/**\n\t * @param markers only phishing (not spam) markers will be sent as event bus updates\n\t */\n\tonPhishingMarkersReceived(markers: ReportedMailFieldMarker[]): unknown\n\n\tonError(tutanotaError: Error): void\n}\n\nexport class EventBusClient {\n\tprivate state: EventBusState\n\tprivate socket: WebSocket | null\n\tprivate immediateReconnect: boolean = false // if true tries to reconnect immediately after the websocket is closed\n\n\t/**\n\t * Map from group id to last event ids (max. _MAX_EVENT_IDS_QUEUE_LENGTH). We keep them to avoid processing the same event twice if\n\t * it comes out of order from the server) and for requesting missed entity events on reconnect.\n\t *\n\t * We do not have to update these event ids if the groups of the user change because we always take the current users groups from the\n\t * LoginFacade.\n\t */\n\tprivate lastEntityEventIds: Map<Id, Array<Id>>\n\n\t/**\n\t * Last batch which was actually added to the queue. We need it to find out when the group is processed\n\t */\n\tprivate lastAddedBatchForGroup: Map<Id, Id>\n\n\tprivate lastAntiphishingMarkersId: Id | null = null\n\n\t/** Queue to process all events. */\n\tprivate readonly eventQueue: EventQueue\n\n\t/** Queue that handles incoming websocket messages only. Caches them until we process downloaded ones and then adds them to eventQueue. */\n\tprivate readonly entityUpdateMessageQueue: EventQueue\n\tprivate reconnectTimer: TimeoutID | null\n\tprivate connectTimer: TimeoutID | null\n\n\t/**\n\t * Represents a currently retried executing due to a ServiceUnavailableError\n\t */\n\tprivate serviceUnavailableRetry: Promise<void> | null = null\n\tprivate failedConnectionAttempts: number = 0\n\n\tconstructor(\n\t\tprivate readonly listener: EventBusListener,\n\t\tprivate readonly cache: EntityRestCache,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entity: EntityClient,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly socketFactory: (path: string) => WebSocket,\n\t\tprivate readonly sleepDetector: SleepDetector,\n\t\tprivate readonly progressTracker: ExposedProgressTracker,\n\t) {\n\t\t// We are not connected by default and will not try to unless connect() is called\n\t\tthis.state = EventBusState.Terminated\n\t\tthis.lastEntityEventIds = new Map()\n\t\tthis.lastAddedBatchForGroup = new Map()\n\t\tthis.socket = null\n\t\tthis.reconnectTimer = null\n\t\tthis.connectTimer = null\n\t\tthis.eventQueue = new EventQueue(\"ws_opt\", true, (modification) => this.eventQueueCallback(modification))\n\t\tthis.entityUpdateMessageQueue = new EventQueue(\"ws_msg\", false, (batch) => this.entityUpdateMessageQueueCallback(batch))\n\t\tthis.reset()\n\t}\n\n\tprivate reset() {\n\t\tthis.immediateReconnect = false\n\n\t\tthis.lastEntityEventIds.clear()\n\n\t\tthis.lastAddedBatchForGroup.clear()\n\n\t\tthis.eventQueue.pause()\n\n\t\tthis.eventQueue.clear()\n\n\t\tthis.serviceUnavailableRetry = null\n\t}\n\n\t/**\n\t * Opens a WebSocket connection to receive server events.\n\t * @param connectMode\n\t */\n\tconnect(connectMode: ConnectMode) {\n\t\tconsole.log(\"ws connect reconnect:\", connectMode === ConnectMode.Reconnect, \"state:\", this.state)\n\t\t// make sure a retry will be cancelled by setting _serviceUnavailableRetry to null\n\t\tthis.serviceUnavailableRetry = null\n\n\t\tthis.listener.onWebsocketStateChanged(WsConnectionState.connecting)\n\n\t\tthis.state = EventBusState.Automatic\n\t\tthis.connectTimer = null\n\n\t\tconst authHeaders = this.userFacade.createAuthHeaders()\n\n\t\t// Native query building is not supported in old browser, mithril is not available in the worker\n\t\tconst authQuery =\n\t\t\t\"modelVersions=\" +\n\t\t\tsysModelInfo.version +\n\t\t\t\".\" +\n\t\t\ttutanotaModelInfo.version +\n\t\t\t\"&clientVersion=\" +\n\t\t\tenv.versionNumber +\n\t\t\t\"&userId=\" +\n\t\t\tthis.userFacade.getLoggedInUser()._id +\n\t\t\t\"&accessToken=\" +\n\t\t\tauthHeaders.accessToken +\n\t\t\t(this.lastAntiphishingMarkersId ? \"&lastPhishingMarkersId=\" + this.lastAntiphishingMarkersId : \"\")\n\t\tconst path = \"/event?\" + authQuery\n\n\t\tthis.unsubscribeFromOldWebsocket()\n\n\t\tthis.socket = this.socketFactory(path)\n\t\tthis.socket.onopen = () => this.onOpen(connectMode)\n\t\tthis.socket.onclose = (event: CloseEvent) => this.onClose(event)\n\t\tthis.socket.onerror = (error: any) => this.onError(error)\n\t\tthis.socket.onmessage = (message: MessageEvent<string>) => this.onMessage(message)\n\n\t\tthis.sleepDetector.start(() => {\n\t\t\tconsole.log(\"ws sleep detected, reconnecting...\")\n\t\t\tthis.tryReconnect(true, true)\n\t\t})\n\t}\n\n\t/**\n\t * Sends a close event to the server and finally closes the connection.\n\t * The state of this event bus client is reset and the client is terminated (does not automatically reconnect) except reconnect == true\n\t */\n\tasync close(closeOption: CloseEventBusOption): Promise<void> {\n\t\tconsole.log(\"ws close closeOption: \", closeOption, \"state:\", this.state)\n\n\t\tswitch (closeOption) {\n\t\t\tcase CloseEventBusOption.Terminate:\n\t\t\t\tthis.terminate()\n\n\t\t\t\tbreak\n\n\t\t\tcase CloseEventBusOption.Pause:\n\t\t\t\tthis.state = EventBusState.Suspended\n\n\t\t\t\tthis.listener.onWebsocketStateChanged(WsConnectionState.connecting)\n\n\t\t\t\tbreak\n\n\t\t\tcase CloseEventBusOption.Reconnect:\n\t\t\t\tthis.listener.onWebsocketStateChanged(WsConnectionState.connecting)\n\n\t\t\t\tbreak\n\t\t}\n\n\t\tthis.socket?.close()\n\t}\n\n\tasync tryReconnect(closeIfOpen: boolean, enableAutomaticState: boolean, delay: number | null = null): Promise<void> {\n\t\tconsole.log(\"ws tryReconnect closeIfOpen:\", closeIfOpen, \"enableAutomaticState:\", enableAutomaticState, \"delay:\", delay)\n\n\t\tif (this.reconnectTimer) {\n\t\t\t// prevent reconnect race-condition\n\t\t\tclearTimeout(this.reconnectTimer)\n\t\t\tthis.reconnectTimer = null\n\t\t}\n\n\t\tif (!delay) {\n\t\t\tthis.reconnect(closeIfOpen, enableAutomaticState)\n\t\t} else {\n\t\t\tthis.reconnectTimer = setTimeout(() => this.reconnect(closeIfOpen, enableAutomaticState), delay)\n\t\t}\n\t}\n\n\t// Returning promise for tests\n\tprivate onOpen(connectMode: ConnectMode): Promise<void> {\n\t\tthis.failedConnectionAttempts = 0\n\t\tconsole.log(\"ws open state:\", this.state)\n\n\t\tconst p = this.initEntityEvents(connectMode)\n\n\t\tthis.listener.onWebsocketStateChanged(WsConnectionState.connected)\n\n\t\treturn p\n\t}\n\n\tprivate onError(error: any) {\n\t\tconsole.log(\"ws error:\", error, JSON.stringify(error), \"state:\", this.state)\n\t}\n\n\tprivate async onMessage(message: MessageEvent<string>): Promise<void> {\n\t\tconst [type, value] = message.data.split(\";\")\n\n\t\tswitch (type) {\n\t\t\tcase MessageType.EntityUpdate: {\n\t\t\t\tconst { eventBatchId, eventBatchOwner, eventBatch }: WebsocketEntityData = await this.instanceMapper.decryptAndMapToInstance(\n\t\t\t\t\tawait resolveTypeReference(WebsocketEntityDataTypeRef),\n\t\t\t\t\tJSON.parse(value),\n\t\t\t\t\tnull,\n\t\t\t\t)\n\t\t\t\tconst filteredEntityUpdates = await this.removeUnknownTypes(eventBatch)\n\t\t\t\tthis.entityUpdateMessageQueue.add(eventBatchId, eventBatchOwner, filteredEntityUpdates)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase MessageType.UnreadCounterUpdate: {\n\t\t\t\tconst counterData: WebsocketCounterData = await this.instanceMapper.decryptAndMapToInstance(\n\t\t\t\t\tawait resolveTypeReference(WebsocketCounterDataTypeRef),\n\t\t\t\t\tJSON.parse(value),\n\t\t\t\t\tnull,\n\t\t\t\t)\n\t\t\t\tthis.listener.onCounterChanged(counterData)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase MessageType.PhishingMarkers: {\n\t\t\t\tconst data: PhishingMarkerWebsocketData = await this.instanceMapper.decryptAndMapToInstance(\n\t\t\t\t\tawait resolveTypeReference(PhishingMarkerWebsocketDataTypeRef),\n\t\t\t\t\tJSON.parse(value),\n\t\t\t\t\tnull,\n\t\t\t\t)\n\t\t\t\tthis.lastAntiphishingMarkersId = data.lastId\n\t\t\t\tthis.listener.onPhishingMarkersReceived(data.markers)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase MessageType.LeaderStatus: {\n\t\t\t\tconst data: WebsocketLeaderStatus = await this.instanceMapper.decryptAndMapToInstance(\n\t\t\t\t\tawait resolveTypeReference(WebsocketLeaderStatusTypeRef),\n\t\t\t\t\tJSON.parse(value),\n\t\t\t\t\tnull,\n\t\t\t\t)\n\t\t\t\tawait this.userFacade.setLeaderStatus(data)\n\t\t\t\tawait this.listener.onLeaderStatusChanged(data)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tconsole.log(\"ws message with unknown type\", type)\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\t/**\n\t * Filters out specific types from @param entityUpdates that the client does not actually know about\n\t * (that are not in tutanotaTypes), and which should therefore not be processed.\n\t */\n\tprivate async removeUnknownTypes(eventBatch: EntityUpdate[]): Promise<EntityUpdate[]> {\n\t\treturn promiseFilter(eventBatch, async (entityUpdate) => {\n\t\t\tconst typeRef = new TypeRef(entityUpdate.application, entityUpdate.type)\n\t\t\ttry {\n\t\t\t\tawait resolveTypeReference(typeRef)\n\t\t\t\treturn true\n\t\t\t} catch (_error) {\n\t\t\t\tconsole.warn(\"ignoring entityEventUpdate for unknown type with typeId\", getTypeId(typeRef))\n\t\t\t\treturn false\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate onClose(event: CloseEvent) {\n\t\tthis.failedConnectionAttempts++\n\t\tconsole.log(\"ws close event:\", event, \"state:\", this.state)\n\n\t\tthis.userFacade.setLeaderStatus(\n\t\t\tcreateWebsocketLeaderStatus({\n\t\t\t\tleaderStatus: false,\n\t\t\t}),\n\t\t)\n\n\t\tthis.sleepDetector.stop()\n\n\t\t// Avoid running into penalties when trying to authenticate with an invalid session\n\t\t// NotAuthenticatedException 401, AccessDeactivatedException 470, AccessBlocked 472\n\t\t// do not catch session expired here because websocket will be reused when we authenticate again\n\t\tconst serverCode = event.code - 4000\n\n\t\tif ([NotAuthorizedError.CODE, AccessDeactivatedError.CODE, AccessBlockedError.CODE].includes(serverCode)) {\n\t\t\tthis.terminate()\n\t\t\tthis.listener.onError(handleRestError(serverCode, \"web socket error\", null, null))\n\t\t} else if (serverCode === SessionExpiredError.CODE) {\n\t\t\t// session is expired. do not try to reconnect until the user creates a new session\n\t\t\tthis.state = EventBusState.Suspended\n\t\t\tthis.listener.onWebsocketStateChanged(WsConnectionState.connecting)\n\t\t} else if (this.state === EventBusState.Automatic && this.userFacade.isFullyLoggedIn()) {\n\t\t\tthis.listener.onWebsocketStateChanged(WsConnectionState.connecting)\n\n\t\t\tif (this.immediateReconnect) {\n\t\t\t\tthis.immediateReconnect = false\n\t\t\t\tthis.tryReconnect(false, false)\n\t\t\t} else {\n\t\t\t\tlet reconnectionInterval: readonly [number, number]\n\n\t\t\t\tif (serverCode === NORMAL_SHUTDOWN_CLOSE_CODE) {\n\t\t\t\t\treconnectionInterval = RECONNECT_INTERVAL.LARGE\n\t\t\t\t} else if (this.failedConnectionAttempts === 1) {\n\t\t\t\t\treconnectionInterval = RECONNECT_INTERVAL.SMALL\n\t\t\t\t} else if (this.failedConnectionAttempts === 2) {\n\t\t\t\t\treconnectionInterval = RECONNECT_INTERVAL.MEDIUM\n\t\t\t\t} else {\n\t\t\t\t\treconnectionInterval = RECONNECT_INTERVAL.LARGE\n\t\t\t\t}\n\n\t\t\t\tthis.tryReconnect(false, false, SECOND_MS * randomIntFromInterval(reconnectionInterval[0], reconnectionInterval[1]))\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async initEntityEvents(connectMode: ConnectMode): Promise<void> {\n\t\t// pause processing entity update message while initializing event queue\n\t\tthis.entityUpdateMessageQueue.pause()\n\n\t\t// pause event queue and add all missed entity events first\n\t\tthis.eventQueue.pause()\n\n\t\tconst existingConnection = connectMode == ConnectMode.Reconnect && this.lastEntityEventIds.size > 0\n\t\tconst p = existingConnection ? this.loadMissedEntityEvents(this.eventQueue) : this.initOnNewConnection()\n\n\t\treturn p\n\t\t\t.then(() => {\n\t\t\t\tthis.entityUpdateMessageQueue.resume()\n\t\t\t\tthis.eventQueue.resume()\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(ConnectionError, (e) => {\n\t\t\t\t\tconsole.log(\"ws not connected in connect(), close websocket\", e)\n\t\t\t\t\tthis.close(CloseEventBusOption.Reconnect)\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(CancelledError, () => {\n\t\t\t\t\t// the processing was aborted due to a reconnect. do not reset any attributes because they might already be in use since reconnection\n\t\t\t\t\tconsole.log(\"ws cancelled retry process entity events after reconnect\")\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(ServiceUnavailableError, async (e) => {\n\t\t\t\t\t// a ServiceUnavailableError is a temporary error and we have to retry to avoid data inconsistencies\n\t\t\t\t\t// some EventBatches/missed events are processed already now\n\t\t\t\t\t// for an existing connection we just keep the current state and continue loading missed events for the other groups\n\t\t\t\t\t// for a new connection we reset the last entity event ids because otherwise this would not be completed in the next try\n\t\t\t\t\tif (!existingConnection) {\n\t\t\t\t\t\tthis.lastEntityEventIds.clear()\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log(\"ws retry init entity events in \", RETRY_AFTER_SERVICE_UNAVAILABLE_ERROR_MS, e)\n\t\t\t\t\tlet promise = delay(RETRY_AFTER_SERVICE_UNAVAILABLE_ERROR_MS).then(() => {\n\t\t\t\t\t\t// if we have a websocket reconnect we have to stop retrying\n\t\t\t\t\t\tif (this.serviceUnavailableRetry === promise) {\n\t\t\t\t\t\t\tconsole.log(\"ws retry initializing entity events\")\n\t\t\t\t\t\t\treturn this.initEntityEvents(connectMode)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(\"ws cancel initializing entity events\")\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tthis.serviceUnavailableRetry = promise\n\t\t\t\t\treturn promise\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(OutOfSyncError, async (e) => {\n\t\t\t\t\t// we did not check for updates for too long, so some missed EntityEventBatches can not be loaded any more\n\t\t\t\t\t// purge cache if out of sync\n\t\t\t\t\tawait this.cache.purgeStorage()\n\t\t\t\t\t// We want users to re-login. By the time we get here they probably already have loaded some entities which we cannot update\n\t\t\t\t\tthrow e\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch((e) => {\n\t\t\t\tthis.entityUpdateMessageQueue.resume()\n\n\t\t\t\tthis.eventQueue.resume()\n\n\t\t\t\tthis.listener.onError(e)\n\t\t\t})\n\t}\n\n\tprivate async initOnNewConnection() {\n\t\tconst { lastIds, someIdsWereCached } = await this.retrieveLastEntityEventIds()\n\t\t// First, we record lastEntityEventIds. We need this to know what we need to re-fetch.\n\t\t// This is not the same as the cache because we might have already downloaded them but cache might not have processed them yet.\n\t\t// Important: do it in one step so that we don't have partial IDs in the map in case an error occurs.\n\t\tthis.lastEntityEventIds = lastIds\n\n\t\t// Second, we need to initialize the cache too.\n\t\tif (someIdsWereCached) {\n\t\t\t// If some of the last IDs were retrieved from the cache then we want to load from that point to bring cache up-to-date. This is mostly important for\n\t\t\t// persistent cache.\n\t\t\tawait this.loadMissedEntityEvents(this.eventQueue)\n\t\t} else {\n\t\t\t// If the cache is clean then this is a clean cache (either ephemeral after first connect or persistent with empty DB).\n\t\t\t// We need to record the time even if we don't process anything to later know if we are out of sync or not.\n\t\t\tawait this.cache.recordSyncTime()\n\t\t}\n\t}\n\n\t/**\n\t * Gets the latest event batch ids for each of the users groups or min id if there is no event batch yet.\n\t * This is needed to know from where to start loading missed events when we connect.\n\t */\n\tprivate async retrieveLastEntityEventIds(): Promise<{ lastIds: Map<Id, Array<Id>>; someIdsWereCached: boolean }> {\n\t\t// set all last event ids in one step to avoid that we have just set them for a few groups when a ServiceUnavailableError occurs\n\t\tconst lastIds: Map<Id, Array<Id>> = new Map()\n\t\tlet someIdsWereCached = false\n\t\tfor (const groupId of this.eventGroups()) {\n\t\t\tconst cachedBatchId = await this.cache.getLastEntityEventBatchForGroup(groupId)\n\t\t\tif (cachedBatchId != null) {\n\t\t\t\tlastIds.set(groupId, [cachedBatchId])\n\t\t\t\tsomeIdsWereCached = true\n\t\t\t} else {\n\t\t\t\tconst batches = await this.entity.loadRange(EntityEventBatchTypeRef, groupId, GENERATED_MAX_ID, 1, true)\n\t\t\t\tconst batchId = batches.length === 1 ? getElementId(batches[0]) : GENERATED_MIN_ID\n\t\t\t\tlastIds.set(groupId, [batchId])\n\t\t\t\t// In case we don't receive any events for the group this time we want to still download from this point next time.\n\t\t\t\tawait this.cache.setLastEntityEventBatchForGroup(groupId, batchId)\n\t\t\t}\n\t\t}\n\n\t\treturn { lastIds, someIdsWereCached }\n\t}\n\n\t/** Load event batches since the last time we were connected to bring cache and other things up-to-date.\n\t * @param eventQueue is passed in for testing\n\t * @VisibleForTesting\n\t * */\n\tasync loadMissedEntityEvents(eventQueue: EventQueue): Promise<void> {\n\t\tif (!this.userFacade.isFullyLoggedIn()) {\n\t\t\treturn\n\t\t}\n\n\t\tawait this.checkOutOfSync()\n\n\t\tlet eventBatches: EntityEventBatch[] = []\n\t\tfor (let groupId of this.eventGroups()) {\n\t\t\tconst eventBatchForGroup = await this.loadEntityEventsForGroup(groupId)\n\t\t\teventBatches = eventBatches.concat(eventBatchForGroup)\n\t\t}\n\n\t\tconst timeSortedEventBatches = eventBatches.sort((a, b) => compareOldestFirst(getElementId(a), getElementId(b)))\n\t\t// Count all batches that will actually be processed so that the progress is correct\n\t\tlet totalExpectedBatches = 0\n\t\tfor (const batch of timeSortedEventBatches) {\n\t\t\tconst filteredEntityUpdates = await this.removeUnknownTypes(batch.events)\n\t\t\tconst batchWasAddedToQueue = this.addBatch(getElementId(batch), getListId(batch), filteredEntityUpdates, eventQueue)\n\t\t\tif (batchWasAddedToQueue) {\n\t\t\t\ttotalExpectedBatches++\n\t\t\t}\n\t\t}\n\n\t\t// We only have the correct amount of total work after adding all entity event batches.\n\t\t// The progress for processed batches is tracked inside the event queue.\n\t\tconst progressMonitor = new ProgressMonitorDelegate(this.progressTracker, totalExpectedBatches + 1)\n\t\tconsole.log(\"ws\", `progress monitor expects ${totalExpectedBatches} events`)\n\t\tawait progressMonitor.workDone(1) // show progress right away\n\t\teventQueue.setProgressMonitor(progressMonitor)\n\n\t\t// We've loaded all the batches, we've added them to the queue, we can let the cache remember sync point for us to detect out of sync now.\n\t\t// It is possible that we will record the time before the batch will be processed but the risk is low.\n\t\tawait this.cache.recordSyncTime()\n\t}\n\n\tprivate async loadEntityEventsForGroup(groupId: Id): Promise<EntityEventBatch[]> {\n\t\ttry {\n\t\t\treturn await this.entity.loadAll(EntityEventBatchTypeRef, groupId, this.getLastEventBatchIdOrMinIdForGroup(groupId))\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\tconsole.log(\"ws could not download entity updates, lost permission\")\n\t\t\t\treturn []\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async checkOutOfSync() {\n\t\t// We try to detect whether event batches have already expired.\n\t\t// If this happened we don't need to download anything, we need to purge the cache and start all over.\n\t\tif (await this.cache.isOutOfSync()) {\n\t\t\t// We handle it where we initialize the connection and purge the cache there.\n\t\t\tthrow new OutOfSyncError(\"some missed EntityEventBatches cannot be loaded any more\")\n\t\t}\n\t}\n\n\tprivate async eventQueueCallback(modification: QueuedBatch): Promise<void> {\n\t\ttry {\n\t\t\tawait this.processEventBatch(modification)\n\t\t} catch (e) {\n\t\t\tconsole.log(\"ws error while processing event batches\", e)\n\t\t\tthis.listener.onError(e)\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tprivate async entityUpdateMessageQueueCallback(batch: QueuedBatch): Promise<void> {\n\t\tthis.addBatch(batch.batchId, batch.groupId, batch.events, this.eventQueue)\n\t\tthis.eventQueue.resume()\n\t}\n\n\tprivate unsubscribeFromOldWebsocket() {\n\t\tif (this.socket) {\n\t\t\t// Remove listeners. We don't want old socket to mess our state\n\t\t\tthis.socket.onopen = this.socket.onclose = this.socket.onerror = this.socket.onmessage = identity\n\t\t}\n\t}\n\n\tprivate async terminate(): Promise<void> {\n\t\tthis.state = EventBusState.Terminated\n\n\t\tthis.reset()\n\n\t\tthis.listener.onWebsocketStateChanged(WsConnectionState.terminated)\n\t}\n\n\t/**\n\t * Tries to reconnect the websocket if it is not connected.\n\t */\n\tprivate reconnect(closeIfOpen: boolean, enableAutomaticState: boolean) {\n\t\tconsole.log(\n\t\t\t\"ws reconnect socket.readyState: (CONNECTING=0, OPEN=1, CLOSING=2, CLOSED=3): \" + (this.socket ? this.socket.readyState : \"null\"),\n\t\t\t\"state:\",\n\t\t\tthis.state,\n\t\t\t\"closeIfOpen:\",\n\t\t\tcloseIfOpen,\n\t\t\t\"enableAutomaticState:\",\n\t\t\tenableAutomaticState,\n\t\t)\n\n\t\tif (this.state !== EventBusState.Terminated && enableAutomaticState) {\n\t\t\tthis.state = EventBusState.Automatic\n\t\t}\n\n\t\tif (closeIfOpen && this.socket && this.socket.readyState === WebSocket.OPEN) {\n\t\t\tthis.immediateReconnect = true\n\t\t\tthis.socket.close()\n\t\t} else if (\n\t\t\t(this.socket == null || this.socket.readyState === WebSocket.CLOSED || this.socket.readyState === WebSocket.CLOSING) &&\n\t\t\tthis.state !== EventBusState.Terminated &&\n\t\t\tthis.userFacade.isFullyLoggedIn()\n\t\t) {\n\t\t\t// Don't try to connect right away because connection may not be actually there\n\t\t\t// see #1165\n\t\t\tif (this.connectTimer) {\n\t\t\t\tclearTimeout(this.connectTimer)\n\t\t\t}\n\n\t\t\tthis.connectTimer = setTimeout(() => this.connect(ConnectMode.Reconnect), 100)\n\t\t}\n\t}\n\n\tprivate addBatch(batchId: Id, groupId: Id, events: ReadonlyArray<EntityUpdate>, eventQueue: EventQueue): boolean {\n\t\tconst lastForGroup = this.lastEntityEventIds.get(groupId) || []\n\t\t// find the position for inserting into last entity events (negative value is considered as not present in the array)\n\t\tconst index = binarySearch(lastForGroup, batchId, compareOldestFirst)\n\t\tlet wasAdded\n\n\t\tif (index < 0) {\n\t\t\tlastForGroup.splice(-index, 0, batchId)\n\t\t\t// only add the batch if it was not process before\n\t\t\twasAdded = eventQueue.add(batchId, groupId, events)\n\t\t} else {\n\t\t\twasAdded = false\n\t\t}\n\n\t\tif (lastForGroup.length > MAX_EVENT_IDS_QUEUE_LENGTH) {\n\t\t\tlastForGroup.shift()\n\t\t}\n\n\t\tthis.lastEntityEventIds.set(batchId, lastForGroup)\n\n\t\tif (wasAdded) {\n\t\t\tthis.lastAddedBatchForGroup.set(groupId, batchId)\n\t\t}\n\t\treturn wasAdded\n\t}\n\n\tprivate async processEventBatch(batch: QueuedBatch): Promise<void> {\n\t\ttry {\n\t\t\tif (this.isTerminated()) return\n\t\t\tconst filteredEvents = await this.cache.entityEventsReceived(batch)\n\t\t\tif (!this.isTerminated()) await this.listener.onEntityEventsReceived(filteredEvents, batch.batchId, batch.groupId)\n\t\t} catch (e) {\n\t\t\tif (e instanceof ServiceUnavailableError) {\n\t\t\t\t// a ServiceUnavailableError is a temporary error and we have to retry to avoid data inconsistencies\n\t\t\t\tconsole.log(\"ws retry processing event in 30s\", e)\n\t\t\t\tconst retryPromise = delay(RETRY_AFTER_SERVICE_UNAVAILABLE_ERROR_MS).then(() => {\n\t\t\t\t\t// if we have a websocket reconnect we have to stop retrying\n\t\t\t\t\tif (this.serviceUnavailableRetry === retryPromise) {\n\t\t\t\t\t\treturn this.processEventBatch(batch)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new CancelledError(\"stop retry processing after service unavailable due to reconnect\")\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tthis.serviceUnavailableRetry = retryPromise\n\t\t\t\treturn retryPromise\n\t\t\t} else {\n\t\t\t\tconsole.log(\"EVENT\", \"error\", e)\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getLastEventBatchIdOrMinIdForGroup(groupId: Id): Id {\n\t\tconst lastIds = this.lastEntityEventIds.get(groupId)\n\n\t\treturn lastIds && lastIds.length > 0 ? lastThrow(lastIds) : GENERATED_MIN_ID\n\t}\n\n\tprivate isTerminated() {\n\t\treturn this.state === EventBusState.Terminated\n\t}\n\n\tprivate eventGroups(): Id[] {\n\t\treturn this.userFacade\n\t\t\t.getLoggedInUser()\n\t\t\t.memberships.filter((membership) => membership.groupType !== GroupType.MailingList)\n\t\t\t.map((membership) => membership.group)\n\t\t\t.concat(this.userFacade.getLoggedInUser().userGroup.group)\n\t}\n}\n"]}