{"version":3,"file":"EventBusEventCoordinator.js","sourceRoot":"","sources":["../../../../../src/common/api/worker/EventBusEventCoordinator.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventBusListener } from \"./EventBusClient.js\"\nimport { WsConnectionState } from \"../main/WorkerClient.js\"\nimport {\n\tEntityUpdate,\n\tGroupKeyUpdateTypeRef,\n\tUserGroupKeyDistributionTypeRef,\n\tUserTypeRef,\n\tWebsocketCounterData,\n\tWebsocketLeaderStatus,\n} from \"../entities/sys/TypeRefs.js\"\nimport { ReportedMailFieldMarker } from \"../entities/tutanota/TypeRefs.js\"\nimport { WebsocketConnectivityListener } from \"../../misc/WebsocketConnectivityModel.js\"\nimport { isAdminClient, isTest } from \"../common/Env.js\"\nimport { MailFacade } from \"./facades/lazy/MailFacade.js\"\nimport { UserFacade } from \"./facades/UserFacade.js\"\nimport { EntityClient } from \"../common/EntityClient.js\"\nimport { AccountType, OperationType } from \"../common/TutanotaConstants.js\"\nimport { isSameTypeRefByAttr, lazyAsync } from \"@tutao/tutanota-utils\"\nimport { isSameId } from \"../common/utils/EntityUtils.js\"\nimport { ExposedEventController } from \"../main/EventController.js\"\nimport { ConfigurationDatabase } from \"./facades/lazy/ConfigurationDatabase.js\"\nimport { KeyRotationFacade } from \"./facades/KeyRotationFacade.js\"\nimport { CacheManagementFacade } from \"./facades/lazy/CacheManagementFacade.js\"\nimport type { QueuedBatch } from \"./EventQueue.js\"\n\n/** A bit of glue to distribute event bus events across the app. */\nexport class EventBusEventCoordinator implements EventBusListener {\n\tconstructor(\n\t\tprivate readonly connectivityListener: WebsocketConnectivityListener,\n\t\tprivate readonly mailFacade: lazyAsync<MailFacade>,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly eventController: ExposedEventController,\n\t\tprivate readonly configurationDatabase: lazyAsync<ConfigurationDatabase>,\n\t\tprivate readonly keyRotationFacade: KeyRotationFacade,\n\t\tprivate readonly cacheManagementFacade: lazyAsync<CacheManagementFacade>,\n\t\tprivate readonly sendError: (error: Error) => Promise<void>,\n\t\tprivate readonly appSpecificBatchHandling: (queuedBatch: QueuedBatch[]) => void,\n\t) {}\n\n\tonWebsocketStateChanged(state: WsConnectionState) {\n\t\tthis.connectivityListener.updateWebSocketState(state)\n\t}\n\n\tasync onEntityEventsReceived(events: EntityUpdate[], batchId: Id, groupId: Id): Promise<void> {\n\t\tawait this.entityEventsReceived(events)\n\t\tawait (await this.mailFacade()).entityEventsReceived(events)\n\t\tawait this.eventController.onEntityUpdateReceived(events, groupId)\n\t\t// Call the indexer in this last step because now the processed event is stored and the indexer has a separate event queue that\n\t\t// shall not receive the event twice.\n\t\tif (!isTest() && !isAdminClient()) {\n\t\t\tconst queuedBatch = { groupId, batchId, events }\n\t\t\tconst configurationDatabase = await this.configurationDatabase()\n\t\t\tawait configurationDatabase.onEntityEventsReceived(queuedBatch)\n\t\t\tthis.appSpecificBatchHandling([queuedBatch])\n\t\t}\n\t}\n\n\t/**\n\t * @param markers only phishing (not spam) marker will be sent as websocket updates\n\t */\n\tasync onPhishingMarkersReceived(markers: ReportedMailFieldMarker[]) {\n\t\t;(await this.mailFacade()).phishingMarkersUpdateReceived(markers)\n\t}\n\n\tonError(tutanotaError: Error) {\n\t\tthis.sendError(tutanotaError)\n\t}\n\n\tonLeaderStatusChanged(leaderStatus: WebsocketLeaderStatus) {\n\t\tthis.connectivityListener.onLeaderStatusChanged(leaderStatus)\n\t\tif (!isAdminClient()) {\n\t\t\tconst user = this.userFacade.getUser()\n\t\t\tif (leaderStatus.leaderStatus && user && user.accountType !== AccountType.EXTERNAL) {\n\t\t\t\tthis.keyRotationFacade.processPendingKeyRotationsAndUpdates(user)\n\t\t\t} else {\n\t\t\t\tthis.keyRotationFacade.reset()\n\t\t\t}\n\t\t}\n\t}\n\n\tonCounterChanged(counter: WebsocketCounterData) {\n\t\tthis.eventController.onCountersUpdateReceived(counter)\n\t}\n\n\tprivate async entityEventsReceived(data: EntityUpdate[]): Promise<void> {\n\t\t// This is a compromise to not add entityClient to UserFacade which would introduce a circular dep.\n\t\tconst groupKeyUpdates: IdTuple[] = [] // GroupKeyUpdates all in the same list\n\t\tconst user = this.userFacade.getUser()\n\t\tif (user == null) return\n\t\tfor (const update of data) {\n\t\t\tif (\n\t\t\t\tupdate.operation === OperationType.UPDATE &&\n\t\t\t\tisSameTypeRefByAttr(UserTypeRef, update.application, update.type) &&\n\t\t\t\tisSameId(user._id, update.instanceId)\n\t\t\t) {\n\t\t\t\tawait this.userFacade.updateUser(await this.entityClient.load(UserTypeRef, user._id))\n\t\t\t} else if (\n\t\t\t\t(update.operation === OperationType.CREATE || update.operation === OperationType.UPDATE) &&\n\t\t\t\tisSameTypeRefByAttr(UserGroupKeyDistributionTypeRef, update.application, update.type) &&\n\t\t\t\tisSameId(user.userGroup.group, update.instanceId)\n\t\t\t) {\n\t\t\t\tawait (await this.cacheManagementFacade()).tryUpdatingUserGroupKey()\n\t\t\t} else if (update.operation === OperationType.CREATE && isSameTypeRefByAttr(GroupKeyUpdateTypeRef, update.application, update.type)) {\n\t\t\t\tgroupKeyUpdates.push([update.instanceListId, update.instanceId])\n\t\t\t}\n\t\t}\n\t\tawait this.keyRotationFacade.updateGroupMemberships(groupKeyUpdates)\n\t}\n}\n"]}