{"version":3,"file":"Sql.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/offline/Sql.ts"],"names":[],"mappings":"AAAA,OAAO,EAA4C,WAAW,EAAE,MAAM,eAAe,CAAA;AAErF;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AACH,MAAM,UAAU,GAAG,CAAC,UAAgC,EAAE,GAAG,cAA0C;IAClG,IAAI,KAAK,GAAG,EAAE,CAAA;IACd,IAAI,MAAM,GAAqB,EAAE,CAAA;IACjC,IAAI,CAAS,CAAA;IACb,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5C,KAAK,IAAI,UAAU,CAAC,CAAC,CAAC,CAAA;QACtB,MAAM,KAAK,GAAG,cAAc,CAAC,CAAC,CAAC,CAAA;QAC/B,IAAI,KAAK,YAAY,WAAW,EAAE,CAAC;YAClC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAA;YACnB,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAA;QAC9C,CAAC;aAAM,CAAC;YACP,KAAK,IAAI,GAAG,CAAA;YACZ,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAA;QAChC,CAAC;IACF,CAAC;IACD,KAAK,IAAI,UAAU,CAAC,CAAC,CAAC,CAAA;IACtB,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,CAAA;AACzB,CAAC;AAID;;GAEG;AACH,MAAM,UAAU,IAAI,CAAC,UAAgC,EAAE,GAAG,cAA0C;IACnG,IAAI,KAAK,GAAG,EAAE,CAAA;IACd,IAAI,MAAM,GAAe,EAAE,CAAA;IAC3B,IAAI,CAAS,CAAA;IACb,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5C,KAAK,IAAI,UAAU,CAAC,CAAC,CAAC,CAAA;QACtB,MAAM,KAAK,GAAG,cAAc,CAAC,CAAC,CAAC,CAAA;QAC/B,IAAI,KAAK,YAAY,WAAW,EAAE,CAAC;YAClC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAA;YACnB,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAA;QAC7B,CAAC;aAAM,CAAC;YACP,KAAK,IAAI,GAAG,CAAA;YACZ,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACnB,CAAC;IACF,CAAC;IACD,KAAK,IAAI,UAAU,CAAC,CAAC,CAAC,CAAA;IACtB,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,CAAA;AACzB,CAAC;AAED,MAAM,OAAO,WAAW;IACF;IAAuB;IAA5C,YAAqB,IAAY,EAAW,MAAkB;QAAzC,SAAI,GAAJ,IAAI,CAAQ;QAAW,WAAM,GAAN,MAAM,CAAY;IAAG,CAAC;CAClE","sourcesContent":["import { FormattedQuery, SqlValue, TaggedSqlValue, tagSqlValue } from \"./SqlValue.js\"\n\n/**\n * this tagged template function exists because android doesn't allow us to define SQL functions, so we have made a way to inline\n * SQL fragments into queries.\n * to make it less error-prone, we automate the generation of the params array for the actual sql call.\n * In this way, we offload the escaping of actual user content to the SQL engine, which makes this safe from an SQLI point of view.\n *\n * usage example:\n * const type = \"sys/User\"\n * const listId = \"someList\"\n * const startId = \"ABC\"\n * sql`SELECT entity FROM list_entities WHERE type = ${type} AND listId = ${listId} AND ${firstIdBigger(startId, \"elementId\")}`\n *\n * this will result in\n * const {query, params} = {\n *     query: `SELECT entity FROM list_entities WHERE type = ? AND listId = ? AND (CASE WHEN length(?) > length(elementId) THEN 1 WHEN length(?) < length(elementId) THEN 0 ELSE ? > elementId END)`,\n *     params: [\n *     \t\t{type: SqlType.String, value: \"sys/User\"},\n *     \t\t{type: SqlType.String, value: \"someList\"},\n *     \t\t{type: SqlType.String, value: \"ABC\"},\n *     \t\t{type: SqlType.String, value: \"ABC\"},\n *     \t\t{type: SqlType.String, value: \"ABC\"}\n *     ]\n * }\n *\n * which can be consumed by sql.run(query, params).\n *\n * It is important that the caller ensures that the amount of SQL variables does not exceed MAX_SAFE_SQL_VARS!\n * Violating this rule will lead to an uncaught error with bad stack traces.\n */\nexport function sql(queryParts: TemplateStringsArray, ...paramInstances: (SqlValue | SqlFragment)[]): FormattedQuery {\n\tlet query = \"\"\n\tlet params: TaggedSqlValue[] = []\n\tlet i: number\n\tfor (i = 0; i < paramInstances.length; i++) {\n\t\tquery += queryParts[i]\n\t\tconst param = paramInstances[i]\n\t\tif (param instanceof SqlFragment) {\n\t\t\tquery += param.text\n\t\t\tparams.push(...param.params.map(tagSqlValue))\n\t\t} else {\n\t\t\tquery += \"?\"\n\t\t\tparams.push(tagSqlValue(param))\n\t\t}\n\t}\n\tquery += queryParts[i]\n\treturn { query, params }\n}\n\nexport type UntaggedQuery = { query: string; params: readonly SqlValue[] }\n\n/**\n * Like {@link sql} but without tagging the values\n */\nexport function usql(queryParts: TemplateStringsArray, ...paramInstances: (SqlValue | SqlFragment)[]): UntaggedQuery {\n\tlet query = \"\"\n\tlet params: SqlValue[] = []\n\tlet i: number\n\tfor (i = 0; i < paramInstances.length; i++) {\n\t\tquery += queryParts[i]\n\t\tconst param = paramInstances[i]\n\t\tif (param instanceof SqlFragment) {\n\t\t\tquery += param.text\n\t\t\tparams.push(...param.params)\n\t\t} else {\n\t\t\tquery += \"?\"\n\t\t\tparams.push(param)\n\t\t}\n\t}\n\tquery += queryParts[i]\n\treturn { query, params }\n}\n\nexport class SqlFragment {\n\tconstructor(readonly text: string, readonly params: SqlValue[]) {}\n}\n"]}