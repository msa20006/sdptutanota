{"version":3,"file":"MailAddressFacade.js","sourceRoot":"","sources":["../../../../../../../src/common/api/worker/facades/lazy/MailAddressFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import type { GroupInfo, MailAddressAliasServiceReturn, MailAddressAvailability } from \"../../../entities/sys/TypeRefs.js\"\nimport {\n\tcreateDomainMailAddressAvailabilityData,\n\tcreateMailAddressAliasGetIn,\n\tcreateMailAddressAliasServiceData,\n\tcreateMailAddressAliasServiceDataDelete,\n\tcreateMultipleMailAddressAvailabilityData,\n\tcreateStringWrapper,\n\tGroupInfoTypeRef,\n\tGroupTypeRef,\n\tUserTypeRef,\n} from \"../../../entities/sys/TypeRefs.js\"\nimport { DomainMailAddressAvailabilityService, MailAddressAliasService, MultipleMailAddressAvailabilityService } from \"../../../entities/sys/Services.js\"\nimport { assertWorkerOrNode } from \"../../../common/Env.js\"\nimport { IServiceExecutor } from \"../../../common/ServiceRequest.js\"\nimport { UserFacade } from \"../UserFacade.js\"\nimport { EntityClient } from \"../../../common/EntityClient.js\"\nimport {\n\tcreateMailAddressProperties,\n\tcreateMailboxProperties,\n\tMailboxGroupRoot,\n\tMailboxGroupRootTypeRef,\n\tMailboxProperties,\n\tMailboxPropertiesTypeRef,\n} from \"../../../entities/tutanota/TypeRefs.js\"\nimport { assertNotNull, findAndRemove, getFirstOrThrow, KeyVersion, ofClass } from \"@tutao/tutanota-utils\"\nimport { getEnabledMailAddressesForGroupInfo } from \"../../../common/utils/GroupUtils.js\"\nimport { PreconditionFailedError } from \"../../../common/error/RestError.js\"\nimport { ProgrammingError } from \"../../../common/error/ProgrammingError.js\"\nimport { GroupManagementFacade } from \"./GroupManagementFacade.js\"\n\nimport { VersionedKey } from \"../../crypto/CryptoWrapper.js\"\n\nassertWorkerOrNode()\n\nexport class MailAddressFacade {\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly groupManagement: GroupManagementFacade,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly nonCachingEntityClient: EntityClient,\n\t) {}\n\n\t/**\n\t * For legacy accounts the given userGroupId is ignored since the alias counters are for the customer\n\t */\n\tgetAliasCounters(userGroupId: Id): Promise<MailAddressAliasServiceReturn> {\n\t\tconst data = createMailAddressAliasGetIn({ targetGroup: userGroupId })\n\t\treturn this.serviceExecutor.get(MailAddressAliasService, data)\n\t}\n\n\tisMailAddressAvailable(mailAddress: string): Promise<boolean> {\n\t\tif (this.userFacade.isFullyLoggedIn()) {\n\t\t\tconst data = createDomainMailAddressAvailabilityData({ mailAddress })\n\t\t\treturn this.serviceExecutor.get(DomainMailAddressAvailabilityService, data).then((result) => result.available)\n\t\t} else {\n\t\t\treturn this.areMailAddressesAvailable([mailAddress]).then((result) => getFirstOrThrow(result).available)\n\t\t}\n\t}\n\n\tasync areMailAddressesAvailable(mailAddresses: string[]): Promise<MailAddressAvailability[]> {\n\t\tconst data = createMultipleMailAddressAvailabilityData({\n\t\t\tmailAddresses: mailAddresses.map((mailAddress) => createStringWrapper({ value: mailAddress })),\n\t\t})\n\t\tconst result = await this.serviceExecutor.get(MultipleMailAddressAvailabilityService, data)\n\t\treturn result.availabilities\n\t}\n\n\t/**\n\t * Add an {@param alias} to {@param targetGroupId}.\n\t * {@param targetGroupId} is *not* a Mail group, it is currently only a user group.\n\t *\n\t * Can only be done by an admin.\n\t */\n\tasync addMailAlias(targetGroupId: Id, alias: string): Promise<void> {\n\t\tconst data = createMailAddressAliasServiceData({\n\t\t\tgroup: targetGroupId,\n\t\t\tmailAddress: alias,\n\t\t})\n\t\tawait this.serviceExecutor.post(MailAddressAliasService, data)\n\t}\n\n\t/**\n\t * Enable/disable an {@param alias} on {@param targetGroupId}.\n\t * {@param targetGroupId} is *not* a Mail group, it is currently only a user group.\n\t *\n\t * {@param restore} means whether the alias will be enabled or disabled.\n\t *\n\t * Can only be done by an admin.\n\t */\n\tasync setMailAliasStatus(targetGroupId: Id, alias: string, restore: boolean): Promise<void> {\n\t\tconst deleteData = createMailAddressAliasServiceDataDelete({\n\t\t\tmailAddress: alias,\n\t\t\trestore,\n\t\t\tgroup: targetGroupId,\n\t\t})\n\t\tawait this.serviceExecutor.delete(MailAddressAliasService, deleteData)\n\t}\n\n\t/**\n\t * Get mailAddress to senderName mappings for mail group that the specified user is a member of.\n\t * if no user is given, the operation is attempted as an admin of the given group.\n\t * */\n\tasync getSenderNames(mailGroupId: Id, viaUser?: Id): Promise<Map<string, string>> {\n\t\tconst mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser)\n\t\treturn this.collectSenderNames(mailboxProperties)\n\t}\n\n\t/**\n\t * Set mailAddress to senderName mapping for mail group that the specified user is a member of.\n\t * if no user is specified, the operation will be attempted as an admin of the given group.\n\t * */\n\tasync setSenderName(mailGroupId: Id, mailAddress: string, senderName: string, viaUser?: Id): Promise<Map<string, string>> {\n\t\tconst mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser)\n\t\tlet mailAddressProperty = mailboxProperties.mailAddressProperties.find((p) => p.mailAddress === mailAddress)\n\t\tif (mailAddressProperty == null) {\n\t\t\tmailAddressProperty = createMailAddressProperties({\n\t\t\t\tmailAddress,\n\t\t\t\tsenderName: \"\",\n\t\t\t})\n\t\t\tmailboxProperties.mailAddressProperties.push(mailAddressProperty)\n\t\t}\n\t\tmailAddressProperty.senderName = senderName\n\t\tconst updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser)\n\t\treturn this.collectSenderNames(updatedProperties)\n\t}\n\n\t/**\n\t * remove the sender name of the given mail address.\n\t * If no user is given, the operation will be attempted as an admin of the group.\n\t */\n\tasync removeSenderName(mailGroupId: Id, mailAddress: string, viaUser: Id): Promise<Map<string, string>> {\n\t\tconst mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser)\n\t\tfindAndRemove(mailboxProperties.mailAddressProperties, (p) => p.mailAddress === mailAddress)\n\t\tconst updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser)\n\t\treturn this.collectSenderNames(updatedProperties)\n\t}\n\n\tprivate async getOrCreateMailboxProperties(mailGroupId: Id, viaUser?: Id): Promise<MailboxProperties> {\n\t\t// Using non-caching entityClient because we are not a member of the user's mail group, and we won't receive updates for it\n\t\tconst mailboxGroupRoot = await this.nonCachingEntityClient.load(MailboxGroupRootTypeRef, mailGroupId)\n\n\t\tif (mailboxGroupRoot.mailboxProperties == null) {\n\t\t\tconst currentGroupKey = viaUser\n\t\t\t\t? await this.groupManagement.getCurrentGroupKeyViaUser(mailGroupId, viaUser)\n\t\t\t\t: await this.groupManagement.getCurrentGroupKeyViaAdminEncGKey(mailGroupId)\n\t\t\tmailboxGroupRoot.mailboxProperties = await this.createMailboxProperties(mailboxGroupRoot, currentGroupKey)\n\t\t}\n\n\t\tconst groupKeyProvider = async (version: KeyVersion) =>\n\t\t\tviaUser\n\t\t\t\t? await this.groupManagement.getGroupKeyViaUser(mailGroupId, version, viaUser)\n\t\t\t\t: await this.groupManagement.getGroupKeyViaAdminEncGKey(mailGroupId, version)\n\t\tconst mailboxProperties = await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxGroupRoot.mailboxProperties, {\n\t\t\townerKeyProvider: groupKeyProvider,\n\t\t})\n\n\t\treturn mailboxProperties.mailAddressProperties.length === 0 ? this.mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) : mailboxProperties\n\t}\n\n\t/**\n\t * set the legacy sender name (groupInfo.name) of the group on all assigned mail addresses.\n\t * if no user is given, the operation will be attempted as an admin of the group of the given mailboxProperties.\n\t * */\n\tprivate async mailboxPropertiesWithLegacySenderName(mailboxProperties: MailboxProperties, viaUser?: Id): Promise<MailboxProperties> {\n\t\tconst groupInfo = viaUser ? await this.loadUserGroupInfo(viaUser) : await this.loadMailGroupInfo(mailboxProperties._ownerGroup!)\n\t\tconst legacySenderName = groupInfo.name\n\t\tconst mailAddresses = getEnabledMailAddressesForGroupInfo(groupInfo)\n\t\tfor (const mailAddress of mailAddresses) {\n\t\t\tmailboxProperties.mailAddressProperties.push(\n\t\t\t\tcreateMailAddressProperties({\n\t\t\t\t\tmailAddress,\n\t\t\t\t\tsenderName: legacySenderName,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t\treturn this.updateMailboxProperties(mailboxProperties, viaUser)\n\t}\n\n\tprivate async loadUserGroupInfo(userId: Id): Promise<GroupInfo> {\n\t\tconst user = await this.nonCachingEntityClient.load(UserTypeRef, userId)\n\t\treturn await this.nonCachingEntityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo)\n\t}\n\n\tprivate async loadMailGroupInfo(groupId: Id): Promise<GroupInfo> {\n\t\tconst group = await this.nonCachingEntityClient.load(GroupTypeRef, groupId)\n\t\treturn await this.nonCachingEntityClient.load(GroupInfoTypeRef, group.groupInfo)\n\t}\n\n\tprivate async createMailboxProperties(mailboxGroupRoot: MailboxGroupRoot, groupKey: VersionedKey): Promise<Id> {\n\t\tconst _ownerGroup = mailboxGroupRoot._ownerGroup\n\t\tconst mailboxProperties = createMailboxProperties({\n\t\t\t...(_ownerGroup != null ? { _ownerGroup } : null), // only set it if it is not null\n\t\t\treportMovedMails: \"\",\n\t\t\tmailAddressProperties: [],\n\t\t})\n\t\t// Using non-caching entityClient because we are not a member of the user's mail group and we won't receive updates for it\n\t\treturn this.nonCachingEntityClient.setup(null, mailboxProperties, undefined, { ownerKey: groupKey }).catch(\n\t\t\tofClass(PreconditionFailedError, (e) => {\n\t\t\t\t// in admin case it is much harder to run into it because we use non-caching entityClient but it is still possible\n\t\t\t\tif (e.data && e.data.startsWith(\"exists:\")) {\n\t\t\t\t\tconst existingId = e.data.substring(\"exists:\".length)\n\t\t\t\t\tconsole.log(\"mailboxProperties already exists\", existingId)\n\t\t\t\t\treturn existingId\n\t\t\t\t} else {\n\t\t\t\t\tthrow new ProgrammingError(`Could not create mailboxProperties, precondition: ${e.data}`)\n\t\t\t\t}\n\t\t\t}),\n\t\t)\n\t}\n\n\tprivate async updateMailboxProperties(mailboxProperties: MailboxProperties, viaUser?: Id): Promise<MailboxProperties> {\n\t\tconst groupKeyProvider = async (version: KeyVersion) =>\n\t\t\tviaUser\n\t\t\t\t? await this.groupManagement.getGroupKeyViaUser(assertNotNull(mailboxProperties._ownerGroup), version, viaUser)\n\t\t\t\t: await this.groupManagement.getGroupKeyViaAdminEncGKey(assertNotNull(mailboxProperties._ownerGroup), version)\n\t\tawait this.nonCachingEntityClient.update(mailboxProperties, { ownerKeyProvider: groupKeyProvider })\n\t\treturn await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxProperties._id, { ownerKeyProvider: groupKeyProvider })\n\t}\n\n\tprivate async collectSenderNames(mailboxProperties: MailboxProperties): Promise<Map<string, string>> {\n\t\tconst result = new Map<string, string>()\n\t\tfor (const data of mailboxProperties.mailAddressProperties) {\n\t\t\tresult.set(data.mailAddress, data.senderName)\n\t\t}\n\t\treturn result\n\t}\n}\n"]}