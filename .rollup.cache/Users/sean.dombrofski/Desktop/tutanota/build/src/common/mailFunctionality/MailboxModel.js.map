{"version":3,"file":"MailboxModel.js","sourceRoot":"","sources":["../../../../src/common/mailFunctionality/MailboxModel.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tcreateMailAddressProperties,\n\tcreateMailboxProperties,\n\tMailBox,\n\tMailboxGroupRoot,\n\tMailboxGroupRootTypeRef,\n\tMailboxProperties,\n\tMailboxPropertiesTypeRef,\n\tMailBoxTypeRef,\n} from \"../api/entities/tutanota/TypeRefs.js\"\nimport { Group, GroupInfo, GroupInfoTypeRef, GroupMembership, GroupTypeRef } from \"../api/entities/sys/TypeRefs.js\"\nimport Stream from \"mithril/stream\"\nimport stream from \"mithril/stream\"\nimport { EventController } from \"../api/main/EventController.js\"\nimport { EntityClient } from \"../api/common/EntityClient.js\"\nimport { LoginController } from \"../api/main/LoginController.js\"\nimport { assertNotNull, lazyMemoized, ofClass } from \"@tutao/tutanota-utils\"\nimport { OperationType } from \"../api/common/TutanotaConstants.js\"\nimport { getEnabledMailAddressesWithUser } from \"./SharedMailUtils.js\"\nimport { PreconditionFailedError } from \"../api/common/error/RestError.js\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../api/common/utils/EntityUpdateUtils.js\"\nimport m from \"mithril\"\nimport { ProgrammingError } from \"../api/common/error/ProgrammingError.js\"\nimport { isSameId } from \"../api/common/utils/EntityUtils.js\"\n\nexport type MailboxDetail = {\n\tmailbox: MailBox\n\tmailGroupInfo: GroupInfo\n\tmailGroup: Group\n\tmailboxGroupRoot: MailboxGroupRoot\n}\n\nexport type MailboxCounters = Record<Id, Record<string, number>>\n\nexport class MailboxModel {\n\t/** Empty stream until init() is finished, exposed mostly for map()-ing, use getMailboxDetails to get a promise */\n\treadonly mailboxDetails: Stream<MailboxDetail[]> = stream()\n\tprivate initialization: Promise<void> | null = null\n\t/**\n\t * Map from MailboxGroupRoot id to MailboxProperties\n\t * A way to avoid race conditions in case we try to create mailbox properties from multiple places.\n\t *\n\t */\n\tprivate mailboxPropertiesPromises: Map<Id, Promise<MailboxProperties>> = new Map()\n\n\tconstructor(private readonly eventController: EventController, private readonly entityClient: EntityClient, private readonly logins: LoginController) {}\n\n\t// only init listeners once\n\tprivate readonly initListeners = lazyMemoized(() => {\n\t\tthis.eventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId))\n\t})\n\n\tinit(): Promise<void> {\n\t\t// if we are in the process of loading do not start another one in parallel\n\t\tif (this.initialization) {\n\t\t\treturn this.initialization\n\t\t}\n\t\tthis.initListeners()\n\n\t\treturn this._init()\n\t}\n\n\tprivate _init(): Promise<void> {\n\t\tconst mailGroupMemberships = this.logins.getUserController().getMailGroupMemberships()\n\t\tconst mailBoxDetailsPromises = mailGroupMemberships.map((m) => this.mailboxDetailsFromMembership(m))\n\t\tthis.initialization = Promise.all(mailBoxDetailsPromises).then((details) => {\n\t\t\tthis.mailboxDetails(details)\n\t\t})\n\t\treturn this.initialization.catch((e) => {\n\t\t\tconsole.warn(\"mailbox model initialization failed!\", e)\n\t\t\tthis.initialization = null\n\t\t\tthrow e\n\t\t})\n\t}\n\n\t/**\n\t * load mailbox details from a mailgroup membership\n\t */\n\tprivate async mailboxDetailsFromMembership(membership: GroupMembership): Promise<MailboxDetail> {\n\t\tconst [mailboxGroupRoot, mailGroupInfo, mailGroup] = await Promise.all([\n\t\t\tthis.entityClient.load(MailboxGroupRootTypeRef, membership.group),\n\t\t\tthis.entityClient.load(GroupInfoTypeRef, membership.groupInfo),\n\t\t\tthis.entityClient.load(GroupTypeRef, membership.group),\n\t\t])\n\t\tconst mailbox = await this.entityClient.load(MailBoxTypeRef, mailboxGroupRoot.mailbox)\n\t\treturn {\n\t\t\tmailbox,\n\t\t\tmailGroupInfo,\n\t\t\tmailGroup,\n\t\t\tmailboxGroupRoot,\n\t\t}\n\t}\n\n\t/**\n\t * Get the list of MailboxDetails that this user has access to from their memberships.\n\t *\n\t * Will wait for successful initialization.\n\t */\n\tasync getMailboxDetails(): Promise<Array<MailboxDetail>> {\n\t\t// If details are there, use them\n\t\tif (this.mailboxDetails()) {\n\t\t\treturn this.mailboxDetails()\n\t\t} else {\n\t\t\t// If they are not there, trigger loading again (just in case) but do not fail and wait until we actually have the details.\n\t\t\t// This is so that the rest of the app is not in the broken state if details fail to load but is just waiting until the success.\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tthis.init()\n\t\t\t\tconst end = this.mailboxDetails.map((details) => {\n\t\t\t\t\tresolve(details)\n\t\t\t\t\tend.end(true)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\n\tasync getMailboxDetailByMailboxId(mailboxId: Id): Promise<MailboxDetail | null> {\n\t\tconst allDetails = await this.getMailboxDetails()\n\t\treturn allDetails.find((detail) => isSameId(detail.mailbox._id, mailboxId)) ?? null\n\t}\n\n\tasync getMailboxDetailsForMailGroup(mailGroupId: Id): Promise<MailboxDetail> {\n\t\tconst mailboxDetails = await this.getMailboxDetails()\n\t\treturn assertNotNull(\n\t\t\tmailboxDetails.find((md) => mailGroupId === md.mailGroup._id),\n\t\t\t\"Mailbox detail for mail group does not exist\",\n\t\t)\n\t}\n\n\tasync getUserMailboxDetails(): Promise<MailboxDetail> {\n\t\tconst userMailGroupMembership = this.logins.getUserController().getUserMailGroupMembership()\n\t\tconst mailboxDetails = await this.getMailboxDetails()\n\t\treturn assertNotNull(\n\t\t\tmailboxDetails.find((md) => md.mailGroup._id === userMailGroupMembership.group),\n\t\t\t\"Mailbox detail for user does not exist\",\n\t\t)\n\t}\n\n\tasync entityEventsReceived(updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: Id): Promise<void> {\n\t\tfor (const update of updates) {\n\t\t\tif (isUpdateForTypeRef(GroupInfoTypeRef, update)) {\n\t\t\t\tif (update.operation === OperationType.UPDATE) {\n\t\t\t\t\tawait this._init()\n\t\t\t\t\tm.redraw()\n\t\t\t\t}\n\t\t\t} else if (this.logins.getUserController().isUpdateForLoggedInUserInstance(update, eventOwnerGroupId)) {\n\t\t\t\tlet newMemberships = this.logins.getUserController().getMailGroupMemberships()\n\t\t\t\tconst mailboxDetails = await this.getMailboxDetails()\n\n\t\t\t\tif (newMemberships.length !== mailboxDetails.length) {\n\t\t\t\t\tawait this._init()\n\t\t\t\t\tm.redraw()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getMailboxProperties(mailboxGroupRoot: MailboxGroupRoot): Promise<MailboxProperties> {\n\t\t// MailboxProperties is an encrypted instance that is created lazily. When we create it the reference is automatically written to the MailboxGroupRoot.\n\t\t// Unfortunately we will only get updated new MailboxGroupRoot with the next EntityUpdate.\n\t\t// To prevent parallel creation attempts we do two things:\n\t\t//  - we save the loading promise to avoid calling setup() twice in parallel\n\t\t//  - we set mailboxProperties reference manually (we could save the id elsewhere but it's easier this way)\n\n\t\t// If we are already loading/creating, just return it to avoid races\n\t\tconst existingPromise = this.mailboxPropertiesPromises.get(mailboxGroupRoot._id)\n\t\tif (existingPromise) {\n\t\t\treturn existingPromise\n\t\t}\n\n\t\tconst promise: Promise<MailboxProperties> = this.loadOrCreateMailboxProperties(mailboxGroupRoot)\n\t\tthis.mailboxPropertiesPromises.set(mailboxGroupRoot._id, promise)\n\t\treturn promise.finally(() => this.mailboxPropertiesPromises.delete(mailboxGroupRoot._id))\n\t}\n\n\tasync loadOrCreateMailboxProperties(mailboxGroupRoot: MailboxGroupRoot): Promise<MailboxProperties> {\n\t\tif (!mailboxGroupRoot.mailboxProperties) {\n\t\t\tmailboxGroupRoot.mailboxProperties = await this.entityClient\n\t\t\t\t.setup(\n\t\t\t\t\tnull,\n\t\t\t\t\tcreateMailboxProperties({\n\t\t\t\t\t\t_ownerGroup: mailboxGroupRoot._ownerGroup ?? \"\",\n\t\t\t\t\t\treportMovedMails: \"0\",\n\t\t\t\t\t\tmailAddressProperties: [],\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.catch(\n\t\t\t\t\tofClass(PreconditionFailedError, (e) => {\n\t\t\t\t\t\t// We try to prevent race conditions but they can still happen with multiple clients trying ot create mailboxProperties at the same time.\n\t\t\t\t\t\t// We send special precondition from the server with an existing id.\n\t\t\t\t\t\tif (e.data && e.data.startsWith(\"exists:\")) {\n\t\t\t\t\t\t\tconst existingId = e.data.substring(\"exists:\".length)\n\t\t\t\t\t\t\tconsole.log(\"mailboxProperties already exists\", existingId)\n\t\t\t\t\t\t\treturn existingId\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new ProgrammingError(`Could not create mailboxProperties, precondition: ${e.data}`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t}\n\t\tconst mailboxProperties = await this.entityClient.load(MailboxPropertiesTypeRef, mailboxGroupRoot.mailboxProperties)\n\t\tif (mailboxProperties.mailAddressProperties.length === 0) {\n\t\t\tawait this.migrateFromOldSenderName(mailboxGroupRoot, mailboxProperties)\n\t\t}\n\t\treturn mailboxProperties\n\t}\n\n\t/** If there was no sender name configured before take the user's name and assign it to all email addresses. */\n\tprivate async migrateFromOldSenderName(mailboxGroupRoot: MailboxGroupRoot, mailboxProperties: MailboxProperties) {\n\t\tconst userGroupInfo = this.logins.getUserController().userGroupInfo\n\t\tconst legacySenderName = userGroupInfo.name\n\t\tconst mailboxDetails = await this.getMailboxDetailsForMailGroup(mailboxGroupRoot._id)\n\t\tconst mailAddresses = getEnabledMailAddressesWithUser(mailboxDetails, userGroupInfo)\n\t\tfor (const mailAddress of mailAddresses) {\n\t\t\tmailboxProperties.mailAddressProperties.push(\n\t\t\t\tcreateMailAddressProperties({\n\t\t\t\t\tmailAddress,\n\t\t\t\t\tsenderName: legacySenderName,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t\tawait this.entityClient.update(mailboxProperties)\n\t}\n}\n"]}