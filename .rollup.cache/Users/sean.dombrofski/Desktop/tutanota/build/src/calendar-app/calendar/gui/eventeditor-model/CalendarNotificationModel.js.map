{"version":3,"file":"CalendarNotificationModel.js","sourceRoot":"","sources":["../../../../../../src/calendar-app/calendar/gui/eventeditor-model/CalendarNotificationModel.ts"],"names":[],"mappings":"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","sourcesContent":["import { SendMailModel } from \"../../../../common/mailFunctionality/SendMailModel.js\"\nimport { CalendarNotificationSender } from \"../../view/CalendarNotificationSender.js\"\nimport { LoginController } from \"../../../../common/api/main/LoginController.js\"\nimport { CalendarEvent } from \"../../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { ProgrammingError } from \"../../../../common/api/common/error/ProgrammingError.js\"\nimport { AccountType, CalendarAttendeeStatus } from \"../../../../common/api/common/TutanotaConstants.js\"\nimport { clone } from \"@tutao/tutanota-utils\"\nimport { TooManyRequestsError } from \"../../../../common/api/common/error/RestError.js\"\nimport { UserError } from \"../../../../common/api/main/UserError.js\"\nimport { getNonOrganizerAttendees } from \"./CalendarEventModel.js\"\nimport { UpgradeRequiredError } from \"../../../../common/api/main/UpgradeRequiredError.js\"\n\n/** all the people that may be interested in changes to an event get stored in these models.\n * if one of them is null, it's because there is no one that needs that kind of update.\n * */\nexport type CalendarNotificationSendModels = {\n\tinviteModel: SendMailModel | null\n\tupdateModel: SendMailModel | null\n\tcancelModel: SendMailModel | null\n\tresponseModel: SendMailModel | null\n}\n\n/** contains the logic to distribute the necessary updates to whom it may concern\n *  and checks the preconditions\n * */\nexport class CalendarNotificationModel {\n\tconstructor(private readonly notificationSender: CalendarNotificationSender, private readonly loginController: LoginController) {}\n\n\t/**\n\t * send all notifications required for the new event, determined by the contents of the sendModels parameter.\n\t *\n\t * will modify the attendee list of newEvent if invites/cancellations are sent.\n\t */\n\tasync send(event: CalendarEvent, recurrenceIds: Array<Date>, sendModels: CalendarNotificationSendModels): Promise<void> {\n\t\tif (sendModels.updateModel == null && sendModels.cancelModel == null && sendModels.inviteModel == null && sendModels.responseModel == null) {\n\t\t\treturn\n\t\t}\n\t\tif (\n\t\t\t// sending responses is OK for free users.\n\t\t\t(sendModels.updateModel != null || sendModels.cancelModel != null || sendModels.inviteModel != null) &&\n\t\t\t!(await hasPlanWithInvites(this.loginController))\n\t\t) {\n\t\t\tconst { getAvailablePlansWithCalendarInvites } = await import(\"../../../../common/subscription/SubscriptionUtils.js\")\n\t\t\tthrow new UpgradeRequiredError(\"upgradeRequired_msg\", await getAvailablePlansWithCalendarInvites())\n\t\t}\n\t\t// we need to exclude the exclusions that are only there because of altered instances specifically\n\t\t// so google calendar handles our invitations\n\t\tconst recurrenceTimes = recurrenceIds.map((date) => date.getTime())\n\t\tconst originalExclusions = event.repeatRule?.excludedDates ?? []\n\t\tconst filteredExclusions = originalExclusions.filter(({ date }) => !recurrenceTimes.includes(date.getTime()))\n\t\tif (event.repeatRule != null) event.repeatRule.excludedDates = filteredExclusions\n\n\t\ttry {\n\t\t\tconst invitePromise = sendModels.inviteModel != null ? this.sendInvites(event, sendModels.inviteModel) : Promise.resolve()\n\t\t\tconst cancelPromise = sendModels.cancelModel != null ? this.sendCancellation(event, sendModels.cancelModel) : Promise.resolve()\n\t\t\tconst updatePromise = sendModels.updateModel != null ? this.sendUpdates(event, sendModels.updateModel) : Promise.resolve()\n\t\t\tconst responsePromise = sendModels.responseModel != null ? this.respondToOrganizer(event, sendModels.responseModel) : Promise.resolve()\n\t\t\tawait Promise.all([invitePromise, cancelPromise, updatePromise, responsePromise])\n\t\t} finally {\n\t\t\tif (event.repeatRule != null) event.repeatRule.excludedDates = originalExclusions\n\t\t}\n\t}\n\n\t/**\n\t * invite all new attendees for an event and set their status from \"ADDED\" to \"NEEDS_ACTION\"\n\t * @param event will be modified if invites are sent.\n\t * @param inviteModel\n\t * @private\n\t */\n\tprivate async sendInvites(event: CalendarEvent, inviteModel: SendMailModel): Promise<void> {\n\t\tif (event.organizer == null || inviteModel?.allRecipients().length === 0) {\n\t\t\tthrow new ProgrammingError(\"event has no organizer or no invitable attendees, can't send invites.\")\n\t\t}\n\t\tconst newAttendees = getNonOrganizerAttendees(event).filter((a) => a.status === CalendarAttendeeStatus.ADDED)\n\t\tawait inviteModel.waitForResolvedRecipients()\n\t\tif (event.invitedConfidentially != null) {\n\t\t\tinviteModel.setConfidential(event.invitedConfidentially)\n\t\t}\n\t\tawait this.notificationSender.sendInvite(event, inviteModel)\n\t\tfor (const attendee of newAttendees) {\n\t\t\tif (attendee.status === CalendarAttendeeStatus.ADDED) {\n\t\t\t\tattendee.status = CalendarAttendeeStatus.NEEDS_ACTION\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendCancellation(event: CalendarEvent, cancelModel: SendMailModel): Promise<void> {\n\t\tconst updatedEvent = clone(event)\n\n\t\ttry {\n\t\t\tif (event.invitedConfidentially != null) {\n\t\t\t\tcancelModel.setConfidential(event.invitedConfidentially)\n\t\t\t}\n\t\t\tawait this.notificationSender.sendCancellation(updatedEvent, cancelModel)\n\t\t} catch (e) {\n\t\t\tif (e instanceof TooManyRequestsError) {\n\t\t\t\tthrow new UserError(\"mailAddressDelay_msg\") // This will be caught and open error dialog\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendUpdates(event: CalendarEvent, updateModel: SendMailModel): Promise<void> {\n\t\tawait updateModel.waitForResolvedRecipients()\n\t\tif (event.invitedConfidentially != null) {\n\t\t\tupdateModel.setConfidential(event.invitedConfidentially)\n\t\t}\n\t\tawait this.notificationSender.sendUpdate(event, updateModel)\n\t}\n\n\t/**\n\t * send a response mail to the organizer as stated on the original event. calling this for an event that is not an invite or\n\t * does not contain address as an attendee or that has no organizer is an error.\n\t * @param newEvent the event to send the update for, this should be identical to existingEvent except for the own status.\n\t * @param responseModel\n\t * @private\n\t */\n\tprivate async respondToOrganizer(newEvent: CalendarEvent, responseModel: SendMailModel): Promise<void> {\n\t\tawait responseModel.waitForResolvedRecipients()\n\t\tif (newEvent.invitedConfidentially != null) {\n\t\t\tresponseModel.setConfidential(newEvent.invitedConfidentially)\n\t\t}\n\n\t\tawait this.notificationSender.sendResponse(newEvent, responseModel)\n\t\tresponseModel.dispose()\n\t}\n}\n\n/** determine if we should show the \"sending invites is not available for your plan, please upgrade\" dialog\n * to the currently logged in user.\n */\nexport async function hasPlanWithInvites(loginController: LoginController): Promise<boolean> {\n\tconst userController = loginController.getUserController()\n\tconst { user } = userController\n\tif (user.accountType === AccountType.FREE || user.accountType === AccountType.EXTERNAL) {\n\t\treturn false\n\t}\n\n\tconst customer = await loginController.getUserController().loadCustomer()\n\n\treturn (await userController.getPlanConfig()).eventInvites\n}\n"]}