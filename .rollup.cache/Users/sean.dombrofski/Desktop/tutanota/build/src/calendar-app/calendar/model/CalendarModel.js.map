{"version":3,"file":"CalendarModel.js","sourceRoot":"","sources":["../../../../../src/calendar-app/calendar/model/CalendarModel.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\t$Promisable,\n\tassertNotNull,\n\tclone,\n\tdeepEqual,\n\tdefer,\n\tDeferredObject,\n\tdowncast,\n\tfilterInt,\n\tgetFromMap,\n\tisSameDay,\n\tRequire,\n\tsymmetricDifference,\n} from \"@tutao/tutanota-utils\"\nimport { CalendarMethod, EXTERNAL_CALENDAR_SYNC_INTERVAL, FeatureType, OperationType } from \"../../../common/api/common/TutanotaConstants\"\nimport { EventController } from \"../../../common/api/main/EventController\"\nimport {\n\tcreateDateWrapper,\n\tcreateMembershipRemoveData,\n\tGroup,\n\tGroupInfo,\n\tGroupInfoTypeRef,\n\tGroupMembership,\n\tGroupTypeRef,\n\tUser,\n\tUserAlarmInfo,\n\tUserAlarmInfoTypeRef,\n} from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport {\n\tCalendarEvent,\n\tCalendarEventTypeRef,\n\tCalendarEventUpdate,\n\tCalendarEventUpdateTypeRef,\n\tCalendarGroupRoot,\n\tCalendarGroupRootTypeRef,\n\tcreateDefaultAlarmInfo,\n\tcreateGroupSettings,\n\tFileTypeRef,\n\tGroupSettings,\n\tUserSettingsGroupRootTypeRef,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { isApp, isDesktop } from \"../../../common/api/common/Env\"\nimport type { LoginController } from \"../../../common/api/main/LoginController\"\nimport { LockedError, NotAuthorizedError, NotFoundError, PreconditionFailedError } from \"../../../common/api/common/error/RestError\"\nimport type { ParsedCalendarData, ParsedEvent } from \"../../../common/calendar/import/CalendarImporter.js\"\nimport { ParserError } from \"../../../common/misc/parsing/ParserCombinator\"\nimport { ProgressTracker } from \"../../../common/api/main/ProgressTracker\"\nimport type { IProgressMonitor } from \"../../../common/api/common/utils/ProgressMonitor\"\nimport { NoopProgressMonitor } from \"../../../common/api/common/utils/ProgressMonitor\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport type { MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { elementIdPart, getElementId, isSameId, listIdPart, removeTechnicalFields } from \"../../../common/api/common/utils/EntityUtils\"\nimport type { AlarmScheduler } from \"../../../common/calendar/date/AlarmScheduler.js\"\nimport { Notifications, NotificationType } from \"../../../common/gui/Notifications\"\nimport m from \"mithril\"\nimport type { CalendarEventInstance, CalendarEventProgenitor, CalendarFacade } from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport {\n\tAlarmInfoTemplate,\n\tCachingMode,\n\tCalendarEventAlteredInstance,\n\tCalendarEventUidIndexEntry,\n} from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport { IServiceExecutor } from \"../../../common/api/common/ServiceRequest\"\nimport { MembershipService } from \"../../../common/api/entities/sys/Services\"\nimport { FileController } from \"../../../common/file/FileController\"\nimport { findAttendeeInAddresses, serializeAlarmInterval } from \"../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { TutanotaError } from \"@tutao/tutanota-error\"\nimport { SessionKeyNotFoundError } from \"../../../common/api/common/error/SessionKeyNotFoundError.js\"\nimport Stream from \"mithril/stream\"\nimport { ObservableLazyLoaded } from \"../../../common/api/common/utils/ObservableLazyLoaded.js\"\nimport { UserController } from \"../../../common/api/main/UserController.js\"\nimport { formatDateWithWeekdayAndTime, formatTime } from \"../../../common/misc/Formatter.js\"\nimport { EntityUpdateData, isUpdateFor, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport {\n\tAlarmInterval,\n\tassignEventId,\n\tCalendarEventValidity,\n\tcheckEventValidity,\n\tgetTimeZone,\n\thasSourceUrl,\n} from \"../../../common/calendar/date/CalendarUtils.js\"\nimport { isSharedGroupOwner, loadGroupMembers } from \"../../../common/sharing/GroupUtils.js\"\nimport { ExternalCalendarFacade } from \"../../../common/native/common/generatedipc/ExternalCalendarFacade.js\"\nimport { DeviceConfig } from \"../../../common/misc/DeviceConfig.js\"\nimport { locator } from \"../../../common/api/main/CommonLocator.js\"\nimport { EventImportRejectionReason, parseCalendarStringData, sortOutParsedEvents, SyncStatus } from \"../../../common/calendar/import/ImportExportUtils.js\"\nimport { UserError } from \"../../../common/api/main/UserError.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel.js\"\nimport { NativePushServiceApp } from \"../../../common/native/main/NativePushServiceApp.js\"\n\nconst TAG = \"[CalendarModel]\"\nexport type CalendarInfo = {\n\tgroupRoot: CalendarGroupRoot\n\tgroupInfo: GroupInfo\n\tgroup: Group\n\tshared: boolean\n\tuserIsOwner: boolean\n\tisExternal: boolean\n}\n\nexport function assertEventValidity(event: CalendarEvent) {\n\tswitch (checkEventValidity(event)) {\n\t\tcase CalendarEventValidity.InvalidContainsInvalidDate:\n\t\t\tthrow new UserError(\"invalidDate_msg\")\n\t\tcase CalendarEventValidity.InvalidEndBeforeStart:\n\t\t\tthrow new UserError(\"startAfterEnd_label\")\n\t\tcase CalendarEventValidity.InvalidPre1970:\n\t\t\t// shouldn't happen while the check in setStartDate is still there, resetting the date each time\n\t\t\tthrow new UserError(\"pre1970Start_msg\")\n\t\tcase CalendarEventValidity.Valid:\n\t\t// event is valid, nothing to do\n\t}\n}\n\nexport class CalendarModel {\n\t/**\n\t * Map from calendar event element id to the deferred object with a promise of getting CREATE event for this calendar event. We need to do that because\n\t * entity updates for CalendarEvent and UserAlarmInfo come in different batches and we need to wait for the event when we want to process new alarm.\n\t *\n\t * We use the counter to remove the pending request from map when all alarms are processed. We want to do that in case the event gets updated and we need\n\t * to wait for the new version of the event.\n\t */\n\tprivate pendingAlarmRequests: Map<\n\t\tstring,\n\t\t{\n\t\t\tpendingAlarmCounter: number\n\t\t\tdeferred: DeferredObject<void>\n\t\t}\n\t> = new Map()\n\tprivate readonly userAlarmToAlarmInfo: Map<string, string> = new Map()\n\tprivate readonly fileIdToSkippedCalendarEventUpdates: Map<Id, CalendarEventUpdate> = new Map()\n\n\tprivate readProgressMonitor: Generator<IProgressMonitor>\n\n\t/**\n\t * Map from group id to CalendarInfo\n\t */\n\tprivate readonly calendarInfos = new ObservableLazyLoaded<ReadonlyMap<Id, CalendarInfo>>(() => {\n\t\tconst monitor: IProgressMonitor = this.readProgressMonitor.next().value\n\t\tconst calendarInfoPromise = this.loadOrCreateCalendarInfo(monitor)\n\t\tmonitor.completed()\n\t\treturn calendarInfoPromise\n\t}, new Map())\n\n\tconstructor(\n\t\tprivate readonly notifications: Notifications,\n\t\tprivate readonly alarmScheduler: () => Promise<AlarmScheduler>,\n\t\teventController: EventController,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly progressTracker: ProgressTracker,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly mailboxModel: MailboxModel,\n\t\tprivate readonly calendarFacade: CalendarFacade,\n\t\tprivate readonly fileController: FileController,\n\t\tprivate readonly zone: string,\n\t\tprivate readonly externalCalendarFacade: ExternalCalendarFacade | null,\n\t\tprivate readonly deviceConfig: DeviceConfig,\n\t\tprivate readonly pushService: NativePushServiceApp | null,\n\t) {\n\t\tthis.readProgressMonitor = oneShotProgressMonitorGenerator(progressTracker, logins.getUserController())\n\t\teventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId))\n\t}\n\n\tgetCalendarInfos(): Promise<ReadonlyMap<Id, CalendarInfo>> {\n\t\treturn this.calendarInfos.getAsync()\n\t}\n\n\tgetCalendarInfosStream(): Stream<ReadonlyMap<Id, CalendarInfo>> {\n\t\treturn this.calendarInfos.stream\n\t}\n\n\tasync createEvent(event: CalendarEvent, alarmInfos: ReadonlyArray<AlarmInfoTemplate>, zone: string, groupRoot: CalendarGroupRoot): Promise<void> {\n\t\tawait this.doCreate(event, zone, groupRoot, alarmInfos)\n\t}\n\n\t/** Update existing event when time did not change */\n\tasync updateEvent(\n\t\tnewEvent: CalendarEvent,\n\t\tnewAlarms: ReadonlyArray<AlarmInfoTemplate>,\n\t\tzone: string,\n\t\tgroupRoot: CalendarGroupRoot,\n\t\texistingEvent: CalendarEvent,\n\t): Promise<CalendarEvent> {\n\t\tif (existingEvent._id == null) {\n\t\t\tthrow new Error(\"Invalid existing event for update: no id\")\n\t\t}\n\n\t\tif (existingEvent.uid != null && newEvent.uid !== existingEvent.uid) {\n\t\t\tthrow new Error(\"Invalid existing event for update: mismatched uids.\")\n\t\t}\n\n\t\t// in cases where start time or calendar changed, we need to change the event id and so need to delete/recreate.\n\t\t// it's also possible that the event has to be moved from the long event list to the short event list or vice versa.\n\t\tif (\n\t\t\texistingEvent._ownerGroup !== groupRoot._id ||\n\t\t\tnewEvent.startTime.getTime() !== existingEvent.startTime.getTime() ||\n\t\t\t(await didLongStateChange(newEvent, existingEvent, zone))\n\t\t) {\n\t\t\t// We should reload the instance here because session key and permissions are updated when we recreate event.\n\t\t\tawait this.doCreate(newEvent, zone, groupRoot, newAlarms, existingEvent)\n\t\t\treturn await this.entityClient.load<CalendarEvent>(CalendarEventTypeRef, newEvent._id)\n\t\t} else {\n\t\t\tnewEvent._ownerGroup = groupRoot._id\n\t\t\t// We can't load updated event here because cache is not updated yet. We also shouldn't need to load it, we have the latest\n\t\t\t// version\n\t\t\tawait this.calendarFacade.updateCalendarEvent(newEvent, newAlarms, existingEvent)\n\t\t\treturn newEvent\n\t\t}\n\t}\n\n\t/** Load map from group/groupRoot ID to the calendar info */\n\tprivate async loadCalendarInfos(progressMonitor: IProgressMonitor): Promise<ReadonlyMap<Id, CalendarInfo>> {\n\t\tconst userController = this.logins.getUserController()\n\n\t\tconst notFoundMemberships: GroupMembership[] = []\n\t\tconst groupInstances: Array<[CalendarGroupRoot, GroupInfo, Group]> = []\n\t\tfor (const membership of userController.getCalendarMemberships()) {\n\t\t\ttry {\n\t\t\t\tconst result = await Promise.all([\n\t\t\t\t\tthis.entityClient.load(CalendarGroupRootTypeRef, membership.group),\n\t\t\t\t\tthis.entityClient.load(GroupInfoTypeRef, membership.groupInfo),\n\t\t\t\t\tthis.entityClient.load(GroupTypeRef, membership.group),\n\t\t\t\t])\n\t\t\t\tgroupInstances.push(result)\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\tnotFoundMemberships.push(membership)\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t\tprogressMonitor.workDone(3)\n\t\t}\n\n\t\tconst calendarInfos: Map<Id, CalendarInfo> = new Map()\n\t\tconst groupSettings = userController.userSettingsGroupRoot.groupSettings\n\t\tfor (const [groupRoot, groupInfo, group] of groupInstances) {\n\t\t\ttry {\n\t\t\t\tconst groupMembers = await loadGroupMembers(group, this.entityClient)\n\t\t\t\tconst shared = groupMembers.length > 1\n\t\t\t\tconst userIsOwner = !shared || isSharedGroupOwner(group, userController.userId)\n\t\t\t\tconst isExternal = hasSourceUrl(groupSettings.find((groupSettings) => groupSettings.group === group._id))\n\t\t\t\tcalendarInfos.set(groupRoot._id, {\n\t\t\t\t\tgroupRoot,\n\t\t\t\t\tgroupInfo,\n\t\t\t\t\tgroup: group,\n\t\t\t\t\tshared,\n\t\t\t\t\tuserIsOwner,\n\t\t\t\t\tisExternal,\n\t\t\t\t})\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\t\tconsole.log(\"NotAuthorizedError when initializing calendar. Calendar has been removed \")\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// cleanup inconsistent memberships\n\t\tfor (const membership of notFoundMemberships) {\n\t\t\t// noinspection ES6MissingAwait\n\t\t\tthis.serviceExecutor\n\t\t\t\t.delete(\n\t\t\t\t\tMembershipService,\n\t\t\t\t\tcreateMembershipRemoveData({\n\t\t\t\t\t\tuser: userController.userId,\n\t\t\t\t\t\tgroup: membership.group,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.catch((e) => console.log(\"error cleaning up membership for group: \", membership.group))\n\t\t}\n\t\treturn calendarInfos\n\t}\n\n\tpublic async fetchExternalCalendar(url: string): Promise<string> {\n\t\tif (!this.externalCalendarFacade) throw new Error(`externalCalendarFacade is ${typeof this.externalCalendarFacade} at CalendarModel`)\n\t\tconst calendarStr = await this.externalCalendarFacade?.fetchExternalCalendar(url)\n\t\treturn calendarStr ?? \"\"\n\t}\n\n\tpublic scheduleExternalCalendarSync() {\n\t\tsetInterval(() => {\n\t\t\tthis.syncExternalCalendars().catch((e) => console.error(e.message))\n\t\t}, EXTERNAL_CALENDAR_SYNC_INTERVAL)\n\t}\n\n\tpublic async syncExternalCalendars(\n\t\tgroupSettings: GroupSettings[] | null = null,\n\t\tsyncInterval: number = EXTERNAL_CALENDAR_SYNC_INTERVAL,\n\t\tlongErrorMessage: boolean = false,\n\t\tforceSync: boolean = false,\n\t) {\n\t\tif (!this.externalCalendarFacade || !locator.logins.isFullyLoggedIn()) {\n\t\t\treturn\n\t\t}\n\n\t\tlet existingGroupSettings = groupSettings\n\t\tconst userController = this.logins.getUserController()\n\n\t\tconst groupRootsPromises: Promise<CalendarGroupRoot>[] = []\n\t\tlet calendarGroupRootsList: CalendarGroupRoot[] = []\n\t\tfor (const membership of userController.getCalendarMemberships()) {\n\t\t\tgroupRootsPromises.push(this.entityClient.load(CalendarGroupRootTypeRef, membership.group))\n\t\t}\n\t\tcalendarGroupRootsList = await Promise.all(groupRootsPromises)\n\n\t\tif (!existingGroupSettings) {\n\t\t\tconst { groupSettings: gSettings } = await locator.entityClient.load(UserSettingsGroupRootTypeRef, userController.user.userGroup.group)\n\t\t\texistingGroupSettings = gSettings\n\t\t}\n\n\t\tconst skippedCalendars: Map<Id, { calendarName: string; error: Error }> = new Map()\n\t\tfor (const { sourceUrl, group, name } of existingGroupSettings) {\n\t\t\tif (!sourceUrl) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst lastSyncEntry = this.deviceConfig.getLastExternalCalendarSync().get(group)\n\t\t\tconst offset = 1000 // Add an offset to account for cpu speed when storing or generating timestamps\n\t\t\tconst shouldSkipSync =\n\t\t\t\t!forceSync &&\n\t\t\t\tlastSyncEntry?.lastSyncStatus === SyncStatus.Success &&\n\t\t\t\tlastSyncEntry.lastSuccessfulSync &&\n\t\t\t\tDate.now() + offset - lastSyncEntry.lastSuccessfulSync < syncInterval\n\t\t\tif (shouldSkipSync) continue\n\n\t\t\tconst currentCalendarGroupRoot = calendarGroupRootsList.find((calendarGroupRoot) => isSameId(calendarGroupRoot._id, group)) ?? null\n\t\t\tif (!currentCalendarGroupRoot) {\n\t\t\t\tconsole.error(`Trying to sync a calendar the user isn't subscribed to anymore: ${group}`)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlet parsedExternalEvents: ParsedEvent[] = []\n\t\t\ttry {\n\t\t\t\tconst externalCalendar = await this.fetchExternalCalendar(sourceUrl)\n\t\t\t\tparsedExternalEvents = parseCalendarStringData(externalCalendar, getTimeZone()).contents\n\t\t\t} catch (error) {\n\t\t\t\tlet calendarName = name\n\t\t\t\tif (!calendarName) {\n\t\t\t\t\tconst calendars = await this.getCalendarInfos()\n\t\t\t\t\tcalendarName = calendars.get(group)?.groupInfo.name!\n\t\t\t\t}\n\t\t\t\tskippedCalendars.set(group, { calendarName, error })\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst existingEventList = await loadAllEvents(currentCalendarGroupRoot)\n\n\t\t\tconst operationsLog: {\n\t\t\t\tskipped: CalendarEvent[]\n\t\t\t\tupdated: CalendarEvent[]\n\t\t\t\tcreated: CalendarEvent[]\n\t\t\t\tdeleted: CalendarEvent[]\n\t\t\t} = {\n\t\t\t\tskipped: [],\n\t\t\t\tupdated: [],\n\t\t\t\tcreated: [],\n\t\t\t\tdeleted: [],\n\t\t\t}\n\t\t\t/**\n\t\t\t * Sync strategy\n\t\t\t * - Replace duplicates\n\t\t\t * - Add new\n\t\t\t * - Remove rest\n\t\t\t */\n\t\t\tconst { rejectedEvents, eventsForCreation } = sortOutParsedEvents(parsedExternalEvents, existingEventList, currentCalendarGroupRoot, getTimeZone())\n\t\t\tconst duplicates = rejectedEvents.get(EventImportRejectionReason.Duplicate) ?? []\n\n\t\t\t// Replacing duplicates with changes\n\t\t\tfor (const duplicatedEvent of duplicates) {\n\t\t\t\tconst existingEvent = existingEventList.find((event) => event.uid === duplicatedEvent.uid)\n\t\t\t\tif (!existingEvent) {\n\t\t\t\t\tconsole.warn(\"Found a duplicate without an existing event!\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif (this.eventHasSameFields(duplicatedEvent, existingEvent)) {\n\t\t\t\t\toperationsLog.skipped.push(duplicatedEvent)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tawait this.updateEventWithExternal(existingEvent, duplicatedEvent)\n\t\t\t\toperationsLog.updated.push(duplicatedEvent)\n\t\t\t}\n\t\t\tconsole.log(TAG, `${operationsLog.skipped.length} events skipped (duplication without changes)`)\n\t\t\tconsole.log(TAG, `${operationsLog.updated.length} events updated (duplication with changes)`)\n\n\t\t\t// Add new event\n\t\t\tfor (const { event } of eventsForCreation) {\n\t\t\t\tassignEventId(event, getTimeZone(), currentCalendarGroupRoot)\n\t\t\t\t// Reset ownerEncSessionKey because it cannot be set for new entity, it will be assigned by the CryptoFacade\n\t\t\t\tevent._ownerEncSessionKey = null\n\n\t\t\t\tif (event.repeatRule != null) {\n\t\t\t\t\tevent.repeatRule.excludedDates = event.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date }))\n\t\t\t\t}\n\t\t\t\t// Reset permissions because server will assign them\n\t\t\t\tdowncast(event)._permissions = null\n\t\t\t\tevent._ownerGroup = currentCalendarGroupRoot._id\n\t\t\t\tassertEventValidity(event)\n\t\t\t\toperationsLog.created.push(event)\n\t\t\t}\n\t\t\tawait this.calendarFacade.saveImportedCalendarEvents(eventsForCreation, 0)\n\t\t\tconsole.log(TAG, `${operationsLog.created.length} events created`)\n\n\t\t\t// Remove rest\n\t\t\tconst eventsToRemove = existingEventList.filter(\n\t\t\t\t(existingEvent) => !parsedExternalEvents.some((externalEvent) => externalEvent.event.uid === existingEvent.uid),\n\t\t\t)\n\t\t\tfor (const event of eventsToRemove) {\n\t\t\t\tawait this.deleteEvent(event).catch((err) => {\n\t\t\t\t\tif (err instanceof NotFoundError) {\n\t\t\t\t\t\treturn console.log(`Already deleted event`, event)\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow err\n\t\t\t\t})\n\t\t\t\toperationsLog.deleted.push(event)\n\t\t\t}\n\t\t\tconsole.log(TAG, `${operationsLog.deleted.length} events removed`)\n\n\t\t\tthis.deviceConfig.updateLastSync(group)\n\t\t}\n\n\t\tif (skippedCalendars.size) {\n\t\t\tlet errorMessage = lang.get(\"iCalSync_error\") + (longErrorMessage ? \"\\n\\n\" : \"\")\n\t\t\tfor (const [group, details] of skippedCalendars.entries()) {\n\t\t\t\tif (longErrorMessage) errorMessage += `${details.calendarName} - ${details.error.message}\\n`\n\t\t\t\tthis.deviceConfig.updateLastSync(group, SyncStatus.Failed)\n\t\t\t}\n\t\t\tthrow new Error(errorMessage)\n\t\t}\n\t}\n\n\tprivate eventHasSameFields(a: CalendarEvent, b: CalendarEvent) {\n\t\treturn (\n\t\t\ta.startTime.valueOf() === b.startTime.valueOf() &&\n\t\t\ta.endTime.valueOf() === b.endTime.valueOf() &&\n\t\t\tdeepEqual({ ...a.attendees }, { ...b.attendees }) &&\n\t\t\ta.summary === b.summary &&\n\t\t\ta.sequence === b.sequence &&\n\t\t\ta.location === b.location &&\n\t\t\ta.description === b.description &&\n\t\t\tdeepEqual(a.organizer, b.organizer) &&\n\t\t\tdeepEqual(a.repeatRule, b.repeatRule) &&\n\t\t\ta.recurrenceId?.valueOf() === b.recurrenceId?.valueOf()\n\t\t)\n\t}\n\n\tprivate async loadOrCreateCalendarInfo(progressMonitor: IProgressMonitor): Promise<ReadonlyMap<Id, CalendarInfo>> {\n\t\tconst { findFirstPrivateCalendar } = await import(\"../../../common/calendar/date/CalendarUtils.js\")\n\t\tconst calendarInfos = await this.loadCalendarInfos(progressMonitor)\n\n\t\tif (!this.logins.isInternalUserLoggedIn() || findFirstPrivateCalendar(calendarInfos)) {\n\t\t\treturn calendarInfos\n\t\t} else {\n\t\t\tawait this.createCalendar(\"\", null, [], null)\n\t\t\treturn await this.loadCalendarInfos(progressMonitor)\n\t\t}\n\t}\n\n\tasync createCalendar(name: string, color: string | null, alarms: AlarmInterval[], sourceUrl: string | null): Promise<Group> {\n\t\t// when a calendar group is added, a group membership is added to the user. we might miss this websocket event\n\t\t// during startup if the websocket is not connected fast enough. Therefore, we explicitly update the user\n\t\t// this should be removed once we handle missed events during startup\n\t\tconst { user, group } = await this.calendarFacade.addCalendar(name)\n\t\tthis.logins.getUserController().user = user\n\n\t\tconst serializedAlarms = alarms.map((alarm) => createDefaultAlarmInfo({ trigger: serializeAlarmInterval(alarm) }))\n\t\tif (color != null) {\n\t\t\tconst { userSettingsGroupRoot } = this.logins.getUserController()\n\t\t\tconst newGroupSettings = createGroupSettings({\n\t\t\t\tgroup: group._id,\n\t\t\t\tcolor: color,\n\t\t\t\tname: null,\n\t\t\t\tdefaultAlarmsList: serializedAlarms,\n\t\t\t\tsourceUrl,\n\t\t\t})\n\n\t\t\tuserSettingsGroupRoot.groupSettings.push(newGroupSettings)\n\t\t\tawait this.entityClient.update(userSettingsGroupRoot)\n\t\t}\n\n\t\treturn group\n\t}\n\n\tprivate async doCreate(\n\t\tevent: CalendarEvent,\n\t\tzone: string,\n\t\tgroupRoot: CalendarGroupRoot,\n\t\talarmInfos: ReadonlyArray<AlarmInfoTemplate>,\n\t\texistingEvent?: CalendarEvent,\n\t): Promise<void> {\n\t\t// If the event was copied it might still carry some fields for re-encryption. We can't reuse them.\n\t\tremoveTechnicalFields(event)\n\t\tconst { assignEventId } = await import(\"../../../common/calendar/date/CalendarUtils\")\n\t\t// if values of the existing events have changed that influence the alarm time then delete the old event and create a new\n\t\t// one.\n\t\tassignEventId(event, zone, groupRoot)\n\t\t// Reset ownerEncSessionKey because it cannot be set for new entity, it will be assigned by the CryptoFacade\n\t\tevent._ownerEncSessionKey = null\n\t\tif (event.repeatRule != null) {\n\t\t\tevent.repeatRule.excludedDates = event.repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date }))\n\t\t}\n\t\t// Reset permissions because server will assign them\n\t\tdowncast(event)._permissions = null\n\t\tevent._ownerGroup = groupRoot._id\n\t\treturn await this.calendarFacade.saveCalendarEvent(event, alarmInfos, existingEvent ?? null)\n\t}\n\n\tasync deleteEvent(event: CalendarEvent): Promise<void> {\n\t\treturn await this.entityClient.erase(event)\n\t}\n\n\t/**\n\t * get the \"primary\" event of a series - the one that contains the repeat rule and is not a repeated or a rescheduled instance.\n\t *\n\t * note about recurrenceId in event series https://stackoverflow.com/questions/11456406/recurrence-id-in-icalendar-rfc-5545\n\t */\n\tasync resolveCalendarEventProgenitor({ uid }: Pick<CalendarEvent, \"uid\">): Promise<CalendarEvent | null> {\n\t\treturn (await this.getEventsByUid(assertNotNull(uid, \"could not resolve progenitor: no uid\")))?.progenitor ?? null\n\t}\n\n\tprivate async loadAndProcessCalendarUpdates(): Promise<void> {\n\t\tconst { mailboxGroupRoot } = await this.mailboxModel.getUserMailboxDetails()\n\t\tconst { calendarEventUpdates } = mailboxGroupRoot\n\t\tif (calendarEventUpdates == null) return\n\n\t\tconst invites = await this.entityClient.loadAll(CalendarEventUpdateTypeRef, calendarEventUpdates.list)\n\t\tfor (const invite of invites) {\n\t\t\tawait this.handleCalendarEventUpdate(invite)\n\t\t}\n\t}\n\n\t/**\n\t * Get calendar infos, creating a new calendar info if none exist\n\t * Not async because we want to return the result directly if it is available when called\n\t * otherwise we return a promise\n\t */\n\tgetCalendarInfosCreateIfNeeded(): $Promisable<ReadonlyMap<Id, CalendarInfo>> {\n\t\tif (this.calendarInfos.isLoaded() && this.calendarInfos.getLoaded().size > 0) {\n\t\t\treturn this.calendarInfos.getLoaded()\n\t\t}\n\n\t\treturn Promise.resolve().then(async () => {\n\t\t\tconst calendars = await this.calendarInfos.getAsync()\n\n\t\t\tif (calendars.size > 0) {\n\t\t\t\treturn calendars\n\t\t\t} else {\n\t\t\t\tawait this.createCalendar(\"\", null, [], null)\n\t\t\t\treturn this.calendarInfos.reload()\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate async getCalendarDataForUpdate(fileId: IdTuple): Promise<ParsedCalendarData | null> {\n\t\ttry {\n\t\t\t// We are not supposed to load files without the key provider, but we hope that the key\n\t\t\t// was already resolved and the entity updated.\n\t\t\tconst file = await this.entityClient.load(FileTypeRef, fileId)\n\t\t\tconst dataFile = await this.fileController.getAsDataFile(file)\n\t\t\tconst { parseCalendarFile } = await import(\"../../../common/calendar/import/CalendarImporter.js\")\n\t\t\treturn await parseCalendarFile(dataFile)\n\t\t} catch (e) {\n\t\t\tif (e instanceof SessionKeyNotFoundError) {\n\t\t\t\t// owner enc session key not updated yet - see NoOwnerEncSessionKeyForCalendarEventError's comment\n\t\t\t\tthrow new NoOwnerEncSessionKeyForCalendarEventError(\"no owner enc session key found on the calendar data's file\")\n\t\t\t}\n\t\t\tif (e instanceof ParserError || e instanceof NotFoundError) {\n\t\t\t\tconsole.warn(TAG, \"could not get calendar update data\", e)\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tprivate async handleCalendarEventUpdate(update: CalendarEventUpdate): Promise<void> {\n\t\t// we want to delete the CalendarEventUpdate after we are done, even, in some cases, if something went wrong.\n\t\ttry {\n\t\t\tconst parsedCalendarData = await this.getCalendarDataForUpdate(update.file)\n\t\t\tif (parsedCalendarData != null) {\n\t\t\t\tawait this.processCalendarData(update.sender, parsedCalendarData)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthorizedError) {\n\t\t\t\t// we might be authorized in the near future if some permission is delayed, unlikely to be permanent.\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: not authorized\", e)\n\t\t\t\treturn\n\t\t\t} else if (e instanceof PreconditionFailedError) {\n\t\t\t\t// unclear where precon would be thrown, probably in the blob store?\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: precondition failed\", e)\n\t\t\t\treturn\n\t\t\t} else if (e instanceof LockedError) {\n\t\t\t\t// we can try again after the lock is released\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: locked\", e)\n\t\t\t\treturn\n\t\t\t} else if (e instanceof NotFoundError) {\n\t\t\t\t// either the updated event(s) or the file data could not be found,\n\t\t\t\t// so we should try to delete since the update itself is obsolete.\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update: not found\", e)\n\t\t\t} else if (e instanceof NoOwnerEncSessionKeyForCalendarEventError) {\n\t\t\t\t// we will get an update with the mail and sk soon, then we'll be able to finish this.\n\t\t\t\t// we will re-enter this function and erase it then.\n\t\t\t\tthis.fileIdToSkippedCalendarEventUpdates.set(elementIdPart(update.file), update)\n\t\t\t\tconsole.warn(TAG, `could not process calendar update: ${e.message}`, e)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\t// unknown error that may lead to permanently stuck update if not cleared\n\t\t\t\t// this includes CryptoErrors due to #5753 that we want to still monitor\n\t\t\t\t// but now they only occur once\n\t\t\t\tconsole.warn(TAG, \"could not process calendar update:\", e)\n\t\t\t\tawait this.eraseUpdate(update)\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tawait this.eraseUpdate(update)\n\t}\n\n\t/**\n\t * try to delete a calendar update from the server, ignoring errors\n\t * @param update the update to erase\n\t * @private\n\t */\n\tprivate async eraseUpdate(update: CalendarEventUpdate): Promise<void> {\n\t\ttry {\n\t\t\tawait this.entityClient.erase(update)\n\t\t} catch (e) {\n\t\t\tconsole.log(TAG, \"failed to delete update:\", e.name)\n\t\t}\n\t}\n\n\t/** whether the operation could be performed or not */\n\tasync deleteEventsByUid(uid: string): Promise<void> {\n\t\tconst entry = await this.calendarFacade.getEventsByUid(uid)\n\t\tif (entry == null) {\n\t\t\tconsole.log(\"could not find an uid index entry to delete event\")\n\t\t\treturn\n\t\t}\n\t\t// not doing this in parallel because we would get locked errors\n\t\tfor (const e of entry.alteredInstances) {\n\t\t\tawait this.deleteEvent(e)\n\t\t}\n\t\tif (entry.progenitor) {\n\t\t\tawait this.deleteEvent(entry.progenitor)\n\t\t}\n\t}\n\n\t/** process a calendar update retrieved from the server automatically. will not apply updates to event series that do not\n\t *  exist on the server yet (that's being done by calling processCalendarEventMessage manually)\n\t * public for testing */\n\tasync processCalendarData(sender: string, calendarData: ParsedCalendarData): Promise<void> {\n\t\tif (calendarData.contents.length === 0) {\n\t\t\tconsole.log(TAG, `Calendar update with no events, ignoring`)\n\t\t\treturn\n\t\t}\n\n\t\tif (calendarData.contents[0].event.uid == null) {\n\t\t\tconsole.log(TAG, \"invalid event update without UID, ignoring.\")\n\t\t\treturn\n\t\t}\n\n\t\t// we can have multiple cases here:\n\t\t// 1. calendarData has one event and it's the progenitor\n\t\t// 2. calendarData has one event and it's an altered occurrence\n\t\t// 3. it's both (thunderbird sends ical files with multiple events)\n\n\t\t// Load the events bypassing the cache because we might have already processed some updates and they might have changed the events we are about to load.\n\t\t// We want to operate on the latest events only, otherwise we might lose some data.\n\t\tconst dbEvents = await this.calendarFacade.getEventsByUid(calendarData.contents[0].event.uid, CachingMode.Bypass)\n\n\t\tif (dbEvents == null) {\n\t\t\t// if we ever want to display event invites in the calendar before accepting them,\n\t\t\t// we probably need to do something else here.\n\t\t\tconsole.log(TAG, \"received event update for event that has not been saved to the server, ignoring.\")\n\t\t\treturn\n\t\t}\n\t\tconst method = calendarData.method\n\t\tfor (const content of calendarData.contents) {\n\t\t\tconst updateAlarms = content.alarms\n\t\t\tconst updateEvent = content.event\n\t\t\t// this automatically applies REQUESTs for creating parts of the existing event series that do not exist yet\n\t\t\t// like accepting another altered instance invite or accepting the progenitor after accepting only an altered instance.\n\t\t\tawait this.processCalendarEventMessage(sender, method, updateEvent, updateAlarms, dbEvents)\n\t\t}\n\t}\n\n\t/**\n\t * Processing calendar update - bring events in calendar up-to-date with ical data sent via email.\n\t * calendar data are currently processed for\n\t * - REQUEST: here we have two cases:\n\t *     - there is an existing event: we apply the update to that event and do the necessary changes to the other parts of the series that may already exist\n\t *     - there is no existing event: create the event as received, and do the necessary changes to the other parts of the series that may already exist\n\t * - REPLY: update attendee status,\n\t * - CANCEL: we delete existing event instance\n\t *\n\t * @param sender\n\t * @param method\n\t * @param updateEvent the actual instance that needs to be updated\n\t * @param updateAlarms\n\t * @param target either the existing event to update or the calendar group Id to create the event in in case of a new event.\n\t */\n\tasync processCalendarEventMessage(\n\t\tsender: string,\n\t\tmethod: string,\n\t\tupdateEvent: Require<\"uid\", CalendarEvent>,\n\t\tupdateAlarms: Array<AlarmInfoTemplate>,\n\t\ttarget: CalendarEventUidIndexEntry,\n\t): Promise<void> {\n\t\tconst updateEventTime = updateEvent.recurrenceId?.getTime()\n\t\tconst targetDbEvent = updateEventTime == null ? target.progenitor : target.alteredInstances.find((e) => e.recurrenceId.getTime() === updateEventTime)\n\t\tif (targetDbEvent == null) {\n\t\t\tif (method === CalendarMethod.REQUEST) {\n\t\t\t\t// we got a REQUEST for which we do not have a saved version of the particular instance (progenitor or altered)\n\t\t\t\t// it may be\n\t\t\t\t// - a single-instance update that created this altered instance\n\t\t\t\t// - the user got the progenitor invite for a series. it's possible that there's\n\t\t\t\t//   already altered instances of this series on the server.\n\t\t\t\treturn await this.processCalendarAccept(target, updateEvent, updateAlarms)\n\t\t\t} else if (target.progenitor?.repeatRule != null && updateEvent.recurrenceId != null && method === CalendarMethod.CANCEL) {\n\t\t\t\t// some calendaring apps send a cancellation for an altered instance with a RECURRENCE-ID when\n\t\t\t\t// users delete a single instance from a series even though that instance was never published as altered.\n\t\t\t\t// we can just add the exclusion to the progenitor. this would be another argument for marking\n\t\t\t\t// altered-instance-exclusions in some way distinct from \"normal\" exclusions\n\t\t\t\ttarget.alteredInstances.push(updateEvent as CalendarEventAlteredInstance)\n\t\t\t\t// this will now modify the progenitor to have the required exclusions\n\t\t\t\treturn await this.processCalendarUpdate(target, target.progenitor, target.progenitor)\n\t\t\t} else {\n\t\t\t\tconsole.log(TAG, `got something that's not a REQUEST for nonexistent server event on uid:`, method)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tconst sentByOrganizer: boolean = targetDbEvent.organizer != null && targetDbEvent.organizer.address === sender\n\t\tif (method === CalendarMethod.REPLY) {\n\t\t\treturn this.processCalendarReply(sender, targetDbEvent, updateEvent)\n\t\t} else if (sentByOrganizer && method === CalendarMethod.REQUEST) {\n\t\t\treturn await this.processCalendarUpdate(target, targetDbEvent, updateEvent)\n\t\t} else if (sentByOrganizer && method === CalendarMethod.CANCEL) {\n\t\t\treturn await this.processCalendarCancellation(targetDbEvent)\n\t\t} else {\n\t\t\tconsole.log(TAG, `${method} update sent not by organizer, ignoring.`)\n\t\t}\n\t}\n\n\t/** process either a request for an existing progenitor or an existing altered instance.\n\t * @param dbTarget the uid entry containing the other events that are known to us that belong to this event series.\n\t * @param dbEvent the version of updateEvent stored on the server. must be identical to dbTarget.progenitor or one of dbTarget.alteredInstances\n\t * @param updateEvent the event that contains the new version of dbEvent. */\n\tprivate async processCalendarUpdate(dbTarget: CalendarEventUidIndexEntry, dbEvent: CalendarEventInstance, updateEvent: CalendarEvent): Promise<void> {\n\t\tconsole.log(TAG, \"processing request for existing event instance\")\n\t\tconst { repeatRuleWithExcludedAlteredInstances } = await import(\"../gui/eventeditor-model/CalendarEventWhenModel.js\")\n\t\t// some providers do not increment the sequence for all edit operations (like google when changing the summary)\n\t\t// we'd rather apply the same update too often than miss some, and this enables us to update our own status easily\n\t\t// without having to increment the sequence.\n\t\tif (filterInt(dbEvent.sequence) > filterInt(updateEvent.sequence)) {\n\t\t\tconsole.log(TAG, \"got update for outdated event version, ignoring.\")\n\t\t\treturn\n\t\t}\n\t\tif (updateEvent.recurrenceId == null && updateEvent.repeatRule != null) {\n\t\t\t// the update is for a repeating progenitor. we need to exclude all known altered instances from its repeat rule.\n\t\t\tupdateEvent.repeatRule = repeatRuleWithExcludedAlteredInstances(\n\t\t\t\tupdateEvent,\n\t\t\t\tdbTarget.alteredInstances.map((r) => r.recurrenceId),\n\t\t\t\tthis.zone,\n\t\t\t)\n\t\t}\n\t\t// If the update is for the altered occurrence, we do not need to update the progenitor, it already has the exclusion.\n\t\t// If we get into this function we already have the altered occurrence in db.\n\n\t\t// write the progenitor back to the uid index entry so that the subsequent updates from the same file get the updated instance\n\t\tdbTarget.progenitor = (await this.updateEventWithExternal(dbEvent, updateEvent)) as CalendarEventProgenitor\n\t}\n\n\t/**\n\t * do not call this for anything but a REQUEST\n\t * @param dbTarget the progenitor that must have a repeat rule and an exclusion for this event to be accepted, the known altered instances and the ownergroup.\n\t * @param updateEvent the event to create\n\t * @param alarms alarms to set up for this user/event\n\t */\n\tprivate async processCalendarAccept(\n\t\tdbTarget: CalendarEventUidIndexEntry,\n\t\tupdateEvent: Require<\"uid\", CalendarEvent>,\n\t\talarms: Array<AlarmInfoTemplate>,\n\t): Promise<void> {\n\t\tconsole.log(TAG, \"processing new instance request\")\n\t\tconst { repeatRuleWithExcludedAlteredInstances } = await import(\"../gui/eventeditor-model/CalendarEventWhenModel.js\")\n\t\tif (updateEvent.recurrenceId != null && dbTarget.progenitor != null && dbTarget.progenitor.repeatRule != null) {\n\t\t\t// request for a new altered instance. we'll try adding the exclusion for this instance to the progenitor if possible\n\t\t\t// since not all calendar apps add altered instances to the list of exclusions.\n\t\t\tconst updatedProgenitor = clone(dbTarget.progenitor)\n\t\t\tupdatedProgenitor.repeatRule = repeatRuleWithExcludedAlteredInstances(updatedProgenitor, [updateEvent.recurrenceId], this.zone)\n\t\t\tdbTarget.progenitor = (await this.doUpdateEvent(dbTarget.progenitor, updatedProgenitor)) as CalendarEventProgenitor\n\t\t} else if (updateEvent.recurrenceId == null && updateEvent.repeatRule != null && dbTarget.alteredInstances.length > 0) {\n\t\t\t// request to add the progenitor to the calendar. we have to exclude all altered instances that are known to us from it.\n\t\t\tupdateEvent.repeatRule = repeatRuleWithExcludedAlteredInstances(\n\t\t\t\tupdateEvent,\n\t\t\t\tdbTarget.alteredInstances.map((r) => r.recurrenceId),\n\t\t\t\tthis.zone,\n\t\t\t)\n\t\t}\n\t\tlet calendarGroupRoot\n\t\ttry {\n\t\t\tcalendarGroupRoot = await this.entityClient.load(CalendarGroupRootTypeRef, dbTarget.ownerGroup)\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof NotFoundError) && !(e instanceof NotAuthorizedError)) throw e\n\t\t\tconsole.log(TAG, \"tried to create new progenitor or got new altered instance for progenitor in nonexistent/inaccessible calendar, ignoring\")\n\t\t\treturn\n\t\t}\n\t\treturn await this.doCreate(updateEvent, \"\", calendarGroupRoot, alarms)\n\t}\n\n\t/** Someone replied whether they attend an event or not. this MUST be applied to all instances in our\n\t * model since we keep attendee lists in sync for now. */\n\tprivate async processCalendarReply(sender: string, dbEvent: CalendarEvent, updateEvent: CalendarEvent): Promise<void> {\n\t\tconsole.log(\"processing calendar reply\")\n\t\t// first check if the sender of the email is in the attendee list\n\t\tconst replyAttendee = findAttendeeInAddresses(updateEvent.attendees, [sender])\n\n\t\tif (replyAttendee == null) {\n\t\t\tconsole.log(TAG, \"Sender is not among attendees, ignoring\", replyAttendee)\n\t\t\treturn\n\t\t}\n\n\t\tconst newEvent = clone(dbEvent)\n\t\t// check if the attendee is still in the attendee list of the latest event\n\t\tconst dbAttendee = findAttendeeInAddresses(newEvent.attendees, [replyAttendee.address.address])\n\n\t\tif (dbAttendee == null) {\n\t\t\tconsole.log(TAG, \"attendee was not found\", dbEvent._id, replyAttendee)\n\t\t\treturn\n\t\t}\n\n\t\tdbAttendee.status = replyAttendee.status\n\t\tawait this.doUpdateEvent(dbEvent, newEvent)\n\t}\n\n\t/** handle an event cancellation - either the whole series (progenitor got cancelled)\n\t * or the altered occurrence. */\n\tprivate async processCalendarCancellation(dbEvent: CalendarEventInstance): Promise<void> {\n\t\tconsole.log(TAG, \"processing cancellation\")\n\t\t// not having UID is technically an error, but we'll do our best (the event came from the server after all)\n\t\tif (dbEvent.recurrenceId == null && dbEvent.uid != null) {\n\t\t\treturn await this.deleteEventsByUid(dbEvent.uid)\n\t\t} else {\n\t\t\t// either this has a recurrenceId and we only delete that instance\n\t\t\t// or we don't have a uid to get all instances.\n\t\t\treturn await this.entityClient.erase(dbEvent)\n\t\t}\n\t}\n\n\t/**\n\t * Update {@param dbEvent} stored on the server with {@param icsEvent} from the ics file.\n\t */\n\tasync updateEventWithExternal(dbEvent: CalendarEvent, icsEvent: CalendarEvent): Promise<CalendarEvent> {\n\t\tconst newEvent = clone(dbEvent)\n\t\tnewEvent.startTime = icsEvent.startTime\n\t\tnewEvent.endTime = icsEvent.endTime\n\t\tnewEvent.attendees = icsEvent.attendees\n\t\tnewEvent.summary = icsEvent.summary\n\t\tnewEvent.sequence = icsEvent.sequence\n\t\tnewEvent.location = icsEvent.location\n\t\tnewEvent.description = icsEvent.description\n\t\tnewEvent.organizer = icsEvent.organizer\n\t\tnewEvent.repeatRule = icsEvent.repeatRule\n\t\tnewEvent.recurrenceId = icsEvent.recurrenceId\n\t\treturn await this.doUpdateEvent(dbEvent, newEvent)\n\t}\n\n\tasync doUpdateEvent(dbEvent: CalendarEvent, newEvent: CalendarEvent): Promise<CalendarEvent> {\n\t\tconst [alarms, groupRoot] = await Promise.all([\n\t\t\tthis.loadAlarms(dbEvent.alarmInfos, this.logins.getUserController().user),\n\t\t\tthis.entityClient.load<CalendarGroupRoot>(CalendarGroupRootTypeRef, assertNotNull(dbEvent._ownerGroup)),\n\t\t])\n\t\tconst alarmInfos = alarms.map((a) => a.alarmInfo)\n\t\treturn await this.updateEvent(newEvent, alarmInfos, \"\", groupRoot, dbEvent)\n\t}\n\n\tasync init(): Promise<void> {\n\t\tawait this.scheduleAlarmsLocally()\n\t\tawait this.loadAndProcessCalendarUpdates()\n\t}\n\n\tasync scheduleAlarmsLocally(): Promise<void> {\n\t\tif (!this.localAlarmsEnabled()) return\n\n\t\tconst pushIdentifier = this.pushService?.getLoadedPushIdentifier()\n\t\tif (pushIdentifier && pushIdentifier.disabled) {\n\t\t\treturn console.log(\"Push identifier disabled. Skipping alarm schedule\")\n\t\t}\n\n\t\tconst eventsWithInfos = await this.calendarFacade.loadAlarmEvents()\n\t\tconst scheduler: AlarmScheduler = await this.alarmScheduler()\n\t\tfor (let { event, userAlarmInfos } of eventsWithInfos) {\n\t\t\tfor (let userAlarmInfo of userAlarmInfos) {\n\t\t\t\tthis.scheduleUserAlarmInfo(event, userAlarmInfo, scheduler)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync loadAlarms(alarmInfos: Array<IdTuple>, user: User): Promise<Array<UserAlarmInfo>> {\n\t\tconst { alarmInfoList } = user\n\n\t\tif (alarmInfoList == null) {\n\t\t\treturn []\n\t\t}\n\n\t\tconst ids = alarmInfos.filter((alarmInfoId) => isSameId(listIdPart(alarmInfoId), alarmInfoList.alarms))\n\n\t\tif (ids.length === 0) {\n\t\t\treturn []\n\t\t}\n\n\t\treturn this.entityClient.loadMultiple(UserAlarmInfoTypeRef, listIdPart(ids[0]), ids.map(elementIdPart))\n\t}\n\n\tasync deleteCalendar(calendar: CalendarInfo): Promise<void> {\n\t\tawait this.calendarFacade.deleteCalendar(calendar.groupRoot._id)\n\t\tthis.deviceConfig.removeLastSync(calendar.group._id)\n\t}\n\n\tasync getEventsByUid(uid: string): Promise<CalendarEventUidIndexEntry | null> {\n\t\treturn this.calendarFacade.getEventsByUid(uid)\n\t}\n\n\tprivate async entityEventsReceived(updates: ReadonlyArray<EntityUpdateData>, eventOwnerGroupId: Id): Promise<void> {\n\t\tconst calendarInfos = await this.calendarInfos.getAsync()\n\t\t// We iterate over the alarms twice: once to collect them and to set the counter correctly and the second time to actually process them.\n\t\tconst alarmEventsToProcess: UserAlarmInfo[] = []\n\t\tfor (const entityEventData of updates) {\n\t\t\t// apps handle alarms natively. this code is a candidate to move into\n\t\t\t// a generic web/native alarm handler\n\t\t\tif (isUpdateForTypeRef(UserAlarmInfoTypeRef, entityEventData) && !isApp()) {\n\t\t\t\tif (entityEventData.operation === OperationType.CREATE) {\n\t\t\t\t\t// Updates for UserAlarmInfo and CalendarEvent come in a\n\t\t\t\t\t// separate batches and there's a race between loading of the\n\t\t\t\t\t// UserAlarmInfo and creation of the event.\n\t\t\t\t\t// We try to load UserAlarmInfo. Then we wait until the\n\t\t\t\t\t// CalendarEvent is there (which might already be true)\n\t\t\t\t\t// and load it.\n\t\t\t\t\t// All alarms for the same event come in the same batch so\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst userAlarmInfo = await this.entityClient.load(UserAlarmInfoTypeRef, [entityEventData.instanceListId, entityEventData.instanceId])\n\t\t\t\t\t\talarmEventsToProcess.push(userAlarmInfo)\n\t\t\t\t\t\tconst deferredEvent = this.getPendingAlarmRequest(userAlarmInfo.alarmInfo.calendarRef.elementId)\n\t\t\t\t\t\tdeferredEvent.pendingAlarmCounter++\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\t\tconsole.log(TAG, e, \"Event or alarm were not found: \", entityEventData, e)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (entityEventData.operation === OperationType.DELETE && !isApp()) {\n\t\t\t\t\tawait this.cancelUserAlarmInfo(entityEventData.instanceId)\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(CalendarEventTypeRef, entityEventData)) {\n\t\t\t\tif (entityEventData.operation === OperationType.CREATE || entityEventData.operation === OperationType.UPDATE) {\n\t\t\t\t\tconst deferredEvent = this.getPendingAlarmRequest(entityEventData.instanceId)\n\t\t\t\t\tdeferredEvent.deferred.resolve(undefined)\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(CalendarEventUpdateTypeRef, entityEventData) && entityEventData.operation === OperationType.CREATE) {\n\t\t\t\ttry {\n\t\t\t\t\tconst invite = await this.entityClient.load(CalendarEventUpdateTypeRef, [entityEventData.instanceListId, entityEventData.instanceId])\n\t\t\t\t\tawait this.handleCalendarEventUpdate(invite)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\tconsole.log(TAG, \"invite not found\", [entityEventData.instanceListId, entityEventData.instanceId], e)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(FileTypeRef, entityEventData)) {\n\t\t\t\t// with a file update, the owner enc session key should be present now so we can try to process any skipped calendar event updates\n\t\t\t\t// (see NoOwnerEncSessionKeyForCalendarEventError's comment)\n\t\t\t\tconst skippedCalendarEventUpdate = this.fileIdToSkippedCalendarEventUpdates.get(entityEventData.instanceId)\n\t\t\t\tif (skippedCalendarEventUpdate) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.handleCalendarEventUpdate(skippedCalendarEventUpdate)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\t\tconsole.log(TAG, \"invite not found\", [entityEventData.instanceListId, entityEventData.instanceId], e)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.fileIdToSkippedCalendarEventUpdates.delete(entityEventData.instanceId)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.logins.getUserController().isUpdateForLoggedInUserInstance(entityEventData, eventOwnerGroupId)) {\n\t\t\t\tconst calendarMemberships = this.logins.getUserController().getCalendarMemberships()\n\t\t\t\tconst oldGroupIds = new Set(calendarInfos.keys())\n\t\t\t\tconst newGroupIds = new Set(calendarMemberships.map((m) => m.group))\n\t\t\t\tconst diff = symmetricDifference(oldGroupIds, newGroupIds)\n\n\t\t\t\tif (diff.size !== 0) {\n\t\t\t\t\tthis.calendarInfos.reload()\n\t\t\t\t}\n\t\t\t} else if (isUpdateForTypeRef(GroupInfoTypeRef, entityEventData)) {\n\t\t\t\t// the batch does not belong to that group so we need to find if we actually care about the related GroupInfo\n\t\t\t\tfor (const { groupInfo } of calendarInfos.values()) {\n\t\t\t\t\tif (isUpdateFor(groupInfo, entityEventData)) {\n\t\t\t\t\t\tthis.calendarInfos.reload()\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isApp()) {\n\t\t\tconst pushIdentifier = this.pushService?.getLoadedPushIdentifier()\n\t\t\tif (pushIdentifier && pushIdentifier.disabled) {\n\t\t\t\treturn console.log(\"Push identifier disabled. Skipping alarm schedule\")\n\t\t\t}\n\t\t}\n\n\t\t// in the apps, this array is guaranteed to be empty.\n\t\tfor (const userAlarmInfo of alarmEventsToProcess) {\n\t\t\tconst { listId, elementId } = userAlarmInfo.alarmInfo.calendarRef\n\t\t\tconst deferredEvent = this.getPendingAlarmRequest(elementId)\n\t\t\t// Don't wait for the deferred event promise because it can lead to a deadlock.\n\t\t\t// Since issue #2264 we process event batches sequentially and the\n\t\t\t// deferred event can never be resolved until the calendar event update is received.\n\t\t\tdeferredEvent.deferred.promise = deferredEvent.deferred.promise.then(async () => {\n\t\t\t\tdeferredEvent.pendingAlarmCounter--\n\t\t\t\tif (deferredEvent.pendingAlarmCounter === 0) {\n\t\t\t\t\tthis.pendingAlarmRequests.delete(elementId)\n\t\t\t\t}\n\t\t\t\tconst calendarEvent = await this.entityClient.load(CalendarEventTypeRef, [listId, elementId])\n\t\t\t\tconst scheduler = await this.alarmScheduler()\n\t\t\t\ttry {\n\t\t\t\t\tthis.scheduleUserAlarmInfo(calendarEvent, userAlarmInfo, scheduler)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof NotFoundError) {\n\t\t\t\t\t\tconsole.log(TAG, \"event not found\", [listId, elementId])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate getPendingAlarmRequest(elementId: string) {\n\t\treturn getFromMap(this.pendingAlarmRequests, elementId, () => ({ pendingAlarmCounter: 0, deferred: defer() }))\n\t}\n\n\tprivate localAlarmsEnabled(): boolean {\n\t\treturn !isApp() && !isDesktop() && this.logins.isInternalUserLoggedIn() && !this.logins.isEnabled(FeatureType.DisableCalendar)\n\t}\n\n\tprivate scheduleUserAlarmInfo(event: CalendarEvent, userAlarmInfo: UserAlarmInfo, scheduler: AlarmScheduler): void {\n\t\tthis.userAlarmToAlarmInfo.set(getElementId(userAlarmInfo), userAlarmInfo.alarmInfo.alarmIdentifier)\n\n\t\tscheduler.scheduleAlarm(event, userAlarmInfo.alarmInfo, event.repeatRule, (eventTime, summary) => {\n\t\t\tconst { title, body } = formatNotificationForDisplay(eventTime, summary)\n\t\t\tthis.notifications.showNotification(\n\t\t\t\tNotificationType.Calendar,\n\t\t\t\ttitle,\n\t\t\t\t{\n\t\t\t\t\tbody,\n\t\t\t\t},\n\t\t\t\t() => m.route.set(\"/calendar\"),\n\t\t\t)\n\t\t})\n\t}\n\n\tprivate async cancelUserAlarmInfo(userAlarmInfoId: Id): Promise<any> {\n\t\tconst identifier = this.userAlarmToAlarmInfo.get(userAlarmInfoId)\n\n\t\tif (identifier) {\n\t\t\tconst alarmScheduler = await this.alarmScheduler()\n\t\t\talarmScheduler.cancelAlarm(identifier)\n\t\t}\n\t}\n\n\t// VisibleForTesting\n\tgetFileIdToSkippedCalendarEventUpdates(): Map<Id, CalendarEventUpdate> {\n\t\treturn this.fileIdToSkippedCalendarEventUpdates\n\t}\n\n\tgetBirthdayEventTitle(contactName: string) {\n\t\treturn lang.get(\"birthdayEvent_title\", {\n\t\t\t\"{name}\": contactName,\n\t\t})\n\t}\n\n\tgetAgeString(age: number) {\n\t\treturn lang.get(\"birthdayEventAge_title\", { \"{age}\": age })\n\t}\n}\n\n/** return false when the given events (representing the new and old version of the same event) are both long events\n * or both short events, true otherwise */\nasync function didLongStateChange(newEvent: CalendarEvent, existingEvent: CalendarEvent, zone: string): Promise<boolean> {\n\tconst { isLongEvent } = await import(\"../../../common/calendar/date/CalendarUtils.js\")\n\treturn isLongEvent(newEvent, zone) !== isLongEvent(existingEvent, zone)\n}\n\n/**\n * This is used due us receiving calendar events before updateOwnerEncSessionKey gets triggered, and thus we can't load calendar data attachments. This is\n * required due to our permission system and the fact that bucket keys are not immediately accessible from File, only Mail.\n *\n * This is a limitation that should be addressed in the future.\n */\nclass NoOwnerEncSessionKeyForCalendarEventError extends TutanotaError {\n\tconstructor(message: string) {\n\t\tsuper(\"NoOwnerEncSessionKeyForCalendarEventError\", message)\n\t}\n}\n\n/**\n * yield the given monitor one time and then switch to noOp monitors forever\n */\nfunction* oneShotProgressMonitorGenerator(progressTracker: ProgressTracker, userController: UserController): Generator<IProgressMonitor> {\n\t// load all calendars. if there is no calendar yet, create one\n\t// we load three instances per calendar / CalendarGroupRoot / GroupInfo / Group\n\tconst workPerCalendar = 3\n\tconst totalWork = userController.getCalendarMemberships().length * workPerCalendar\n\t// the first time we want a real progress monitor but any time we would reload we don't need it\n\tconst realMonitorId = progressTracker.registerMonitorSync(totalWork)\n\tconst realMonitor = assertNotNull(progressTracker.getMonitor(realMonitorId))\n\tyield realMonitor\n\twhile (true) {\n\t\tyield new NoopProgressMonitor()\n\t}\n}\n\nexport function formatNotificationForDisplay(eventTime: Date, summary: string): { title: string; body: string } {\n\tlet dateString: string\n\n\tif (isSameDay(eventTime, new Date())) {\n\t\tdateString = formatTime(eventTime)\n\t} else {\n\t\tdateString = formatDateWithWeekdayAndTime(eventTime)\n\t}\n\n\tconst body = `${dateString} ${summary}`\n\n\treturn { body, title: body }\n}\n\nasync function loadAllEvents(groupRoot: CalendarGroupRoot): Promise<Array<CalendarEvent>> {\n\treturn Promise.all([\n\t\tlocator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.longEvents),\n\t\tlocator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.shortEvents),\n\t]).then((results) => results.flat())\n}\n"]}