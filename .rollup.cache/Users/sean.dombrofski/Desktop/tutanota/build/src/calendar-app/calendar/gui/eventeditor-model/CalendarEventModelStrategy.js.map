{"version":3,"file":"CalendarEventModelStrategy.js","sourceRoot":"","sources":["../../../../../../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventModelStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * this file contains the strategies used to create, edit and delete calendar events under different scenarios.\n * the scenarios are mostly divided into deciding the type of operation (edit, delete, create)\n * and the scope of the operation (only the clicked instance or all instances)\n * */\nimport { CalendarEvent } from \"../../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { assertEventValidity, CalendarModel } from \"../../model/CalendarModel.js\"\nimport { CalendarNotificationModel } from \"./CalendarNotificationModel.js\"\nimport { assertNotNull, identity } from \"@tutao/tutanota-utils\"\nimport { generateUid } from \"../../../../common/calendar/date/CalendarUtils.js\"\nimport {\n\tassembleCalendarEventEditResult,\n\tassembleEditResultAndAssignFromExisting,\n\tassignEventIdentity,\n\tCalendarEventEditModels,\n\tCalendarOperation,\n\tShowProgressCallback,\n} from \"./CalendarEventModel.js\"\nimport { LoginController } from \"../../../../common/api/main/LoginController.js\"\nimport { DateTime } from \"luxon\"\nimport { RecipientField } from \"../../../../common/mailFunctionality/SharedMailUtils.js\"\n\n/** when starting an edit or delete operation of an event, we\n * need to know how to apply it and whether to send updates. */\nexport interface CalendarEventModelStrategy {\n\t/** apply the changes to the server and notify attendees */\n\tapply(): Promise<void>\n\n\t/** check if the current state of the operation would cause updates to be sent*/\n\tmayRequireSendingUpdates(): boolean\n\n\teditModels: CalendarEventEditModels\n}\n\n/** strategies to apply calendar operations with some common setup */\nexport class CalendarEventApplyStrategies {\n\tconstructor(\n\t\tprivate readonly calendarModel: CalendarModel,\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly notificationModel: CalendarNotificationModel,\n\t\tprivate readonly lazyRecurrenceIds: (uid?: string | null) => Promise<Array<Date>>,\n\t\tprivate readonly showProgress: ShowProgressCallback = identity,\n\t\tprivate readonly zone: string,\n\t) {}\n\n\t/**\n\t * save a new event to the selected calendar, invite all attendees except for the organizer and set up alarms.\n\t */\n\tasync saveNewEvent(editModels: CalendarEventEditModels): Promise<void> {\n\t\tconst { eventValues, newAlarms, sendModels, calendar } = assembleCalendarEventEditResult(editModels)\n\t\tconst uid = generateUid(calendar.group._id, Date.now())\n\t\tconst newEvent = assignEventIdentity(eventValues, { uid })\n\t\tassertEventValidity(newEvent)\n\t\tconst { groupRoot } = calendar\n\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\t\t\t\tawait this.calendarModel.createEvent(newEvent, newAlarms, this.zone, groupRoot)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** all instances of an event will be updated. if the recurrenceIds are invalidated (rrule or startTime changed),\n\t * will delete all altered instances and exclusions. */\n\tasync saveEntireExistingEvent(editModelsForProgenitor: CalendarEventEditModels, existingEvent: CalendarEvent): Promise<void> {\n\t\tconst uid = assertNotNull(existingEvent.uid, \"no uid to update existing event\")\n\t\tassertNotNull(existingEvent?._id, \"no id to update existing event\")\n\t\tassertNotNull(existingEvent?._ownerGroup, \"no ownerGroup to update existing event\")\n\t\tassertNotNull(existingEvent?._permissions, \"no permissions to update existing event\")\n\n\t\tconst { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(\n\t\t\texistingEvent,\n\t\t\teditModelsForProgenitor,\n\t\t\tCalendarOperation.EditAll,\n\t\t)\n\t\tconst { groupRoot } = calendar\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tconst recurrenceIds: Array<Date> = await this.lazyRecurrenceIds(uid)\n\t\t\t\tawait this.notificationModel.send(newEvent, recurrenceIds, sendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, existingEvent)\n\t\t\t\tconst invalidateAlteredInstances = newEvent.repeatRule && newEvent.repeatRule.excludedDates.length === 0\n\n\t\t\t\tconst newDuration = editModelsForProgenitor.whenModel.duration\n\t\t\t\tconst index = await this.calendarModel.getEventsByUid(uid)\n\t\t\t\tif (index == null) return\n\n\t\t\t\t// note: if we ever allow editing guests separately, we need to update this to not use the\n\t\t\t\t// note: progenitor edit models since the guest list might be different from the instance\n\t\t\t\t// note: we're looking at.\n\t\t\t\tfor (const occurrence of index.alteredInstances) {\n\t\t\t\t\tif (invalidateAlteredInstances) {\n\t\t\t\t\t\teditModelsForProgenitor.whoModel.shouldSendUpdates = true\n\t\t\t\t\t\tconst { sendModels } = assembleEditResultAndAssignFromExisting(occurrence, editModelsForProgenitor, CalendarOperation.EditThis)\n\t\t\t\t\t\t// in cases where guests were removed and the start time/repeat rule changed, we might\n\t\t\t\t\t\t// have both a cancel model (containing the removed recipients) and an update model (the rest)\n\t\t\t\t\t\t// we're copying all of them to cancel if the altered instances were invalidated, since the\n\t\t\t\t\t\t// update (and invite for that matter) is irrelevant for those instances.\n\t\t\t\t\t\tfor (const recipient of sendModels.cancelModel?.allRecipients() ?? []) {\n\t\t\t\t\t\t\tsendModels.updateModel?.addRecipient(RecipientField.BCC, recipient)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsendModels.cancelModel = sendModels.updateModel\n\t\t\t\t\t\tsendModels.updateModel = null\n\t\t\t\t\t\tsendModels.inviteModel = null\n\t\t\t\t\t\tawait this.notificationModel.send(occurrence, [], sendModels)\n\t\t\t\t\t\tawait this.calendarModel.deleteEvent(occurrence)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst { newEvent, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(\n\t\t\t\t\t\t\toccurrence,\n\t\t\t\t\t\t\teditModelsForProgenitor,\n\t\t\t\t\t\t\tCalendarOperation.EditThis,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t// we need to use the time we had before, not the time of the progenitor (which did not change since we still have altered occurrences)\n\t\t\t\t\t\tnewEvent.startTime = occurrence.startTime\n\t\t\t\t\t\tnewEvent.endTime = DateTime.fromJSDate(newEvent.startTime, { zone: this.zone }).plus(newDuration).toJSDate()\n\t\t\t\t\t\t// altered instances never have a repeat rule\n\t\t\t\t\t\tnewEvent.repeatRule = null\n\t\t\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\t\t\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, occurrence)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})(),\n\t\t)\n\t}\n\n\tasync saveNewAlteredInstance({\n\t\teditModels,\n\t\teditModelsForProgenitor,\n\t\texistingInstance,\n\t\tprogenitor,\n\t}: {\n\t\teditModels: CalendarEventEditModels\n\t\teditModelsForProgenitor: CalendarEventEditModels\n\t\texistingInstance: CalendarEvent\n\t\tprogenitor: CalendarEvent\n\t}) {\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\t// NEW: edit models that we used so far are for the new event (rescheduled one). this should be an invite.\n\t\t\t\tconst { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(\n\t\t\t\t\texistingInstance,\n\t\t\t\t\teditModels,\n\t\t\t\t\tCalendarOperation.EditThis,\n\t\t\t\t)\n\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\n\t\t\t\t// OLD: but we need to update the existing one as well, to add an exclusion for the original instance that we edited.\n\t\t\t\teditModelsForProgenitor.whoModel.shouldSendUpdates = true\n\t\t\t\teditModelsForProgenitor.whenModel.excludeDate(existingInstance.startTime)\n\t\t\t\tconst {\n\t\t\t\t\tnewEvent: newProgenitor,\n\t\t\t\t\tsendModels: progenitorSendModels,\n\t\t\t\t\tnewAlarms: progenitorAlarms,\n\t\t\t\t} = assembleEditResultAndAssignFromExisting(progenitor, editModelsForProgenitor, CalendarOperation.EditAll)\n\t\t\t\tconst recurrenceIds = await this.lazyRecurrenceIds(progenitor.uid)\n\t\t\t\trecurrenceIds.push(existingInstance.startTime)\n\t\t\t\tawait this.notificationModel.send(newProgenitor, recurrenceIds, progenitorSendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newProgenitor, progenitorAlarms, this.zone, calendar.groupRoot, progenitor)\n\n\t\t\t\t// NEW\n\t\t\t\tconst { groupRoot } = calendar\n\t\t\t\tawait this.calendarModel.createEvent(newEvent, newAlarms, this.zone, groupRoot)\n\t\t\t})(),\n\t\t)\n\t}\n\n\tasync saveExistingAlteredInstance(editModels: CalendarEventEditModels, existingInstance: CalendarEvent): Promise<void> {\n\t\tconst { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(existingInstance, editModels, CalendarOperation.EditThis)\n\t\tconst { groupRoot } = calendar\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, existingInstance)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** delete a whole event and all the instances generated by it */\n\tasync deleteEntireExistingEvent(editModels: CalendarEventEditModels, existingEvent: CalendarEvent): Promise<void> {\n\t\teditModels.whoModel.shouldSendUpdates = true\n\t\tconst { sendModels } = assembleCalendarEventEditResult(editModels)\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tconst alteredOccurrences = await this.calendarModel.getEventsByUid(assertNotNull(existingEvent.uid))\n\t\t\t\tif (alteredOccurrences) {\n\t\t\t\t\tfor (const occurrence of alteredOccurrences.alteredInstances) {\n\t\t\t\t\t\tif (occurrence.attendees.length === 0) continue\n\t\t\t\t\t\tconst { sendModels } = assembleEditResultAndAssignFromExisting(occurrence, editModels, CalendarOperation.DeleteAll)\n\t\t\t\t\t\tsendModels.cancelModel = sendModels.updateModel\n\t\t\t\t\t\tsendModels.updateModel = null\n\t\t\t\t\t\tawait this.notificationModel.send(occurrence, [], sendModels)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsendModels.cancelModel = sendModels.updateModel\n\t\t\t\tsendModels.updateModel = null\n\t\t\t\tawait this.notificationModel.send(existingEvent, [], sendModels)\n\t\t\t\tif (existingEvent.uid != null) {\n\t\t\t\t\tawait this.calendarModel.deleteEventsByUid(existingEvent.uid)\n\t\t\t\t}\n\t\t\t\t// doing this explicitly because we might have clicked an event that's not listed in\n\t\t\t\t// the uid index for some reason. this prevents bugs from creating undeletable events.\n\t\t\t\tawait this.calendarModel.deleteEvent(existingEvent)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** add an exclusion to the progenitor and send an update. */\n\tasync excludeSingleInstance(editModelsForProgenitor: CalendarEventEditModels, existingInstance: CalendarEvent, progenitor: CalendarEvent): Promise<void> {\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\teditModelsForProgenitor.whoModel.shouldSendUpdates = true\n\t\t\t\teditModelsForProgenitor.whenModel.excludeDate(existingInstance.startTime)\n\t\t\t\tconst { newEvent, sendModels, calendar, newAlarms } = assembleEditResultAndAssignFromExisting(\n\t\t\t\t\tprogenitor,\n\t\t\t\t\teditModelsForProgenitor,\n\t\t\t\t\tCalendarOperation.DeleteThis,\n\t\t\t\t)\n\t\t\t\tconst recurrenceIds = await this.lazyRecurrenceIds(progenitor.uid)\n\t\t\t\tawait this.notificationModel.send(newEvent, recurrenceIds, sendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, calendar.groupRoot, progenitor)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** only remove a single altered instance from the server & the uid index. will not modify the progenitor. */\n\tasync deleteAlteredInstance(editModels: CalendarEventEditModels, existingAlteredInstance: CalendarEvent): Promise<void> {\n\t\teditModels.whoModel.shouldSendUpdates = true\n\t\tconst { sendModels } = assembleCalendarEventEditResult(editModels)\n\t\tsendModels.cancelModel = sendModels.updateModel\n\t\tsendModels.updateModel = null\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tawait this.notificationModel.send(existingAlteredInstance, [], sendModels)\n\t\t\t\tawait this.calendarModel.deleteEvent(existingAlteredInstance)\n\t\t\t})(),\n\t\t)\n\t}\n}\n"]}