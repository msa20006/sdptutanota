{"version":3,"file":"CalendarParser.js","sourceRoot":"","sources":["../../../../../src/calendar-app/calendar/export/CalendarParser.ts"],"names":[],"mappings":"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","sourcesContent":["import { DAY_IN_MILLIS, filterInt, neverNull, Require } from \"@tutao/tutanota-utils\"\nimport { DateTime, Duration, IANAZone } from \"luxon\"\nimport {\n\tCalendarEvent,\n\tCalendarEventAttendee,\n\tcreateCalendarEvent,\n\tcreateCalendarEventAttendee,\n\tcreateEncryptedMailAddress,\n\tEncryptedMailAddress,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { CalendarAdvancedRepeatRule, createCalendarAdvancedRepeatRule, DateWrapper, RepeatRule } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { createDateWrapper, createRepeatRule } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport type { Parser } from \"../../../common/misc/parsing/ParserCombinator\"\nimport {\n\tcombineParsers,\n\tmakeCharacterParser,\n\tmakeEitherParser,\n\tmakeNotCharacterParser,\n\tmakeSeparatedByParser,\n\tmakeZeroOrMoreParser,\n\tmapParser,\n\tmaybeParse,\n\tnumberParser,\n\tParserError,\n\tStringIterator,\n} from \"../../../common/misc/parsing/ParserCombinator\"\nimport WindowsZones from \"./WindowsZones\"\nimport type { ParsedCalendarData } from \"../../../common/calendar/import/CalendarImporter.js\"\nimport { isMailAddress } from \"../../../common/misc/FormatValidator\"\nimport { CalendarAttendeeStatus, CalendarMethod, EndType, RepeatPeriod, reverse } from \"../../../common/api/common/TutanotaConstants\"\nimport { AlarmInterval, AlarmIntervalUnit } from \"../../../common/calendar/date/CalendarUtils.js\"\nimport { AlarmInfoTemplate } from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport { serializeAlarmInterval } from \"../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { BYRULE_MAP } from \"../../../common/calendar/import/ImportExportUtils.js\"\n\nfunction parseDateString(dateString: string): {\n\tyear: number\n\tmonth: number\n\tday: number\n} {\n\tconst year = parseInt(dateString.slice(0, 4))\n\tconst month = parseInt(dateString.slice(4, 6))\n\tconst day = parseInt(dateString.slice(6, 8))\n\treturn {\n\t\tyear,\n\t\tmonth,\n\t\tday,\n\t}\n}\n\ntype PropertyParamValue = string\ntype Property = {\n\tname: string\n\tparams: Record<string, PropertyParamValue>\n\tvalue: string\n}\ntype ICalObject = {\n\ttype: string\n\tproperties: Array<Property>\n\tchildren: Array<ICalObject>\n}\n\nfunction getProp(obj: ICalObject, tag: string, optional: false): Property\nfunction getProp(obj: ICalObject, tag: string, optional: true): Property | null | undefined\nfunction getProp(obj: ICalObject, tag: string, optional: boolean): Property | null | undefined\nfunction getProp(obj: ICalObject, tag: string, optional: boolean): Property | null | undefined {\n\tconst prop = obj.properties.find((p) => p.name === tag)\n\tif (!optional && prop == null) throw new ParserError(`Missing prop ${tag}`)\n\treturn prop\n}\n\nfunction getPropStringValue(obj: ICalObject, tag: string, optional: false): string\nfunction getPropStringValue(obj: ICalObject, tag: string, optional: true): string | null | undefined\nfunction getPropStringValue(obj: ICalObject, tag: string, optional: boolean): string | null | undefined {\n\tconst prop = getProp(obj, tag, optional)\n\tif (!optional && typeof prop?.value !== \"string\") throw new ParserError(`value of ${tag} is not of type string, got ${JSON.stringify(prop)}`)\n\treturn prop?.value\n}\n\n// Left side of the semicolon\nconst parameterStringValueParser: Parser<string> = (iterator) => {\n\tlet value = \"\"\n\n\tlet next\n\twhile ((next = iterator.peek()) && /[:;,]/.test(next) === false) {\n\t\tvalue += neverNull(iterator.next().value)\n\t}\n\n\treturn value\n}\n\nconst escapedStringValueParser: Parser<string> = (iterator: StringIterator) => {\n\tif (iterator.next().value !== '\"') {\n\t\tthrow new ParserError(\"Not a quoted value\")\n\t}\n\n\tlet value = \"\"\n\n\twhile (iterator.peek() && iterator.peek() !== '\"') {\n\t\tvalue += neverNull(iterator.next().value)\n\t}\n\n\tif (!(iterator.peek() === '\"')) {\n\t\tthrow new Error(\"Not a quoted value, does not end with quote: \" + value)\n\t}\n\n\titerator.next()\n\treturn value\n}\n\nconst propertyParametersKeyValueParser: Parser<[string, string, string]> = combineParsers(\n\tparsePropertyName,\n\tmakeCharacterParser(\"=\"),\n\tmakeEitherParser(escapedStringValueParser, parameterStringValueParser),\n)\n\nconst parsePropertyParameters = combineParsers(\n\tmakeCharacterParser(\";\"),\n\tmakeSeparatedByParser(/*separator*/ makeCharacterParser(\";\"), /*value*/ propertyParametersKeyValueParser),\n)\n\n// make sure the slashes are _always_ replaced first\n// unless you're using an actual parser for this.\n// otherwise we get fun stuff like \";\\\" -> \"\\;\\\" -> \"\\\\;\\\\\"\n// instead of \";\\\" -> \";\\\\\" -> \"\\;\\\\\"\nexport const iCalReplacements = {\n\t\"\\\\\": \"\\\\\\\\\",\n\t\";\": \"\\\\;\",\n\t\",\": \"\\\\,\",\n\t\"\\n\": \"\\\\n\",\n}\n\nconst revICalReplacements = reverse(iCalReplacements)\n\n// Right side of the semicolon\n\n/**\n * Parses everything until the end of the string and unescapes what it should\n */\nconst anyStringUnescapeParser: Parser<string> = (iterator) => {\n\tlet value = \"\"\n\tlet lastCharacter: string | null = null\n\n\twhile (iterator.peek()) {\n\t\tlastCharacter = iterator.next().value\n\n\t\tif (lastCharacter === \"\\\\\") {\n\t\t\tconst next = iterator.peek()\n\t\t\tif (next != null && next in iCalReplacements) {\n\t\t\t\tcontinue\n\t\t\t} else if (iterator.peek() === \"n\") {\n\t\t\t\titerator.next()\n\t\t\t\tvalue += \"\\n\"\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tvalue += neverNull(lastCharacter)\n\t}\n\n\treturn value\n}\n\n/**\n * Parses everything until the semicolon character\n */\nconst propertyStringValueParser: Parser<string> = (iterator) => {\n\tlet value = \"\"\n\n\tlet next\n\twhile ((next = iterator.peek()) && /[;]/.test(next) === false) {\n\t\tvalue += neverNull(iterator.next().value)\n\t}\n\n\treturn value\n}\n\n/**\n * Parses values separated by commas\n */\nconst separatedByCommaParser: Parser<Array<string>> = makeSeparatedByParser(\n\tmakeCharacterParser(\",\"),\n\tmapParser(makeZeroOrMoreParser(makeNotCharacterParser(\",\")), (arr) => arr.join(\"\")),\n)\n\n/**\n * Parses the whole property (both sides)\n */\nexport const propertySequenceParser: Parser<[string, [string, Array<[string, string, string]>] | null, string, string]> = combineParsers(\n\tparsePropertyName,\n\tmaybeParse(parsePropertyParameters),\n\tmakeCharacterParser(\":\"),\n\tanyStringUnescapeParser,\n)\n\nexport function parseProperty(data: string): Property | null {\n\ttry {\n\t\tconst sequence = propertySequenceParser(new StringIterator(data))\n\t\tconst name = sequence[0]\n\t\tconst params: Record<string, string> = {}\n\n\t\tif (sequence[1]) {\n\t\t\tfor (const [name, _eq, value] of sequence[1][1]) {\n\t\t\t\tparams[name] = value\n\t\t\t}\n\t\t}\n\n\t\tconst value = sequence[3]\n\t\treturn {\n\t\t\tname,\n\t\t\tparams,\n\t\t\tvalue,\n\t\t}\n\t} catch (e) {\n\t\treturn null // Returning null to avoid raising parser errors so we can ignore the current broken data/property\n\t}\n}\n\n/**\n * Parses single key=value pair on the right side of the semicolon (value side)\n */\nconst propertyKeyValueParser: Parser<[string, string, string]> = combineParsers(parsePropertyName, makeCharacterParser(\"=\"), propertyStringValueParser)\n\n/**\n * Parses multiple key=value pair on the right side of the semicolon (value side)\n */\nconst valuesSeparatedBySemicolonParser: Parser<Array<[string, string, string]>> = makeSeparatedByParser(makeCharacterParser(\";\"), propertyKeyValueParser)\n\n/**\n * Parses multiple key=value pair on the right side of the semicolon (value side)\n */\nexport function parsePropertyKeyValue(data: string): Record<string, string> {\n\tconst values = valuesSeparatedBySemicolonParser(new StringIterator(data))\n\tconst result: Record<string, string> = {}\n\tfor (const [key, _eq, value] of values) {\n\t\tresult[key] = value\n\t}\n\treturn result\n}\n\nfunction parseIcalObject(tag: string, iterator: Iterator<string>): ICalObject {\n\tlet iteration = iterator.next()\n\tlet properties: Property[] = []\n\tlet children: ICalObject[] = []\n\n\twhile (!iteration.done && iteration.value) {\n\t\tconst property = parseProperty(iteration.value)\n\n\t\tif (!property) {\n\t\t\t// Ignoring broken properties, if there is any mandatory properties missing the function getContents will raise an error later\n\t\t\titeration = iterator.next()\n\t\t\tcontinue\n\t\t}\n\n\t\tif (property.name === \"END\" && property.value === tag) {\n\t\t\treturn {\n\t\t\t\ttype: tag,\n\t\t\t\tproperties,\n\t\t\t\tchildren,\n\t\t\t}\n\t\t}\n\n\t\tif (property.name === \"BEGIN\") {\n\t\t\tif (typeof property.value !== \"string\") throw new ParserError(\"BEGIN with array value\")\n\t\t\tchildren.push(parseIcalObject(property.value, iterator))\n\t\t} else {\n\t\t\tproperties.push(property)\n\t\t}\n\n\t\titeration = iterator.next()\n\t}\n\n\tthrow new ParserError(\"no end for tag \" + tag)\n}\n\nexport function parseICalendar(stringData: string): ICalObject {\n\tconst withFoldedLines = stringData\n\t\t.replace(/\\r?\\n\\s/g, \"\")\n\t\t.split(/\\r?\\n/)\n\t\t.filter((e) => e !== \"\")\n\tconst iterator = withFoldedLines.values()\n\tconst firstLine = iterator.next()\n\n\tif (firstLine.value !== \"BEGIN:VCALENDAR\") {\n\t\tthrow new ParserError(\"Not a VCALENDAR: \" + String(firstLine.value))\n\t}\n\n\treturn parseIcalObject(\"VCALENDAR\", iterator)\n}\n\nfunction parseAlarm(alarmObject: ICalObject, startTime: Date): AlarmInfoTemplate | null {\n\tconst triggerValue = getPropStringValue(alarmObject, \"TRIGGER\", false)\n\tconst alarmInterval: AlarmInterval | null = triggerToAlarmInterval(startTime, triggerValue)\n\treturn alarmInterval != null\n\t\t? {\n\t\t\t\ttrigger: serializeAlarmInterval(alarmInterval),\n\t\t\t\talarmIdentifier: \"\",\n\t\t  }\n\t\t: null\n}\n\n/** visible for testing */\nexport function triggerToAlarmInterval(eventStart: Date, triggerValue: string): AlarmInterval | null {\n\t// Absolute time\n\tif (triggerValue.endsWith(\"Z\")) {\n\t\t// For absolute time we just convert the trigger to minutes. There might be a bigger unit that can express it but we don't have to take care about time\n\t\t// zones or daylight saving in this case and it's simpler this way.\n\t\tconst triggerTime = parseTime(triggerValue).date\n\t\tconst tillEvent = eventStart.getTime() - triggerTime.getTime()\n\t\tconst minutes = Duration.fromMillis(tillEvent).as(\"minutes\")\n\t\treturn { unit: AlarmIntervalUnit.MINUTE, value: minutes }\n\t} else {\n\t\t// If we have relative trigger expressed in units we want to find the smallest unit that will fit. Unlike iCal we do not support multiple units so\n\t\t// we have to pick one.\n\t\tconst duration = parseDuration(triggerValue)\n\n\t\tif (duration.positive) {\n\t\t\treturn null\n\t\t}\n\n\t\tlet smallestUnit: AlarmIntervalUnit = AlarmIntervalUnit.MINUTE\n\t\tif (duration.week) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.WEEK\n\t\t}\n\t\tif (duration.day) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.DAY\n\t\t}\n\t\tif (duration.hour) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.HOUR\n\t\t}\n\t\tif (duration.minute) {\n\t\t\tsmallestUnit = AlarmIntervalUnit.MINUTE\n\t\t}\n\t\tconst luxonDuration = { week: duration.week, day: duration.day, minute: duration.minute, hour: duration.hour }\n\t\tlet value\n\t\tswitch (smallestUnit) {\n\t\t\tcase AlarmIntervalUnit.WEEK:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"weeks\")\n\t\t\t\tbreak\n\t\t\tcase AlarmIntervalUnit.DAY:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"days\")\n\t\t\t\tbreak\n\t\t\tcase AlarmIntervalUnit.HOUR:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"hours\")\n\t\t\t\tbreak\n\t\t\tcase AlarmIntervalUnit.MINUTE:\n\t\t\t\tvalue = Duration.fromObject(luxonDuration).as(\"minutes\")\n\t\t\t\tbreak\n\t\t}\n\t\treturn { unit: smallestUnit, value }\n\t}\n}\n\nexport function parseRrule(rawRruleValue: string, tzId: string | null): RepeatRule {\n\tlet rruleValue\n\n\ttry {\n\t\trruleValue = parsePropertyKeyValue(rawRruleValue)\n\t} catch (e) {\n\t\tif (e instanceof ParserError) {\n\t\t\tthrow new ParserError(\"RRULE is not an object \" + e.message)\n\t\t} else {\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tconst frequency = icalFrequencyToRepeatPeriod(rruleValue[\"FREQ\"])\n\tconst until = rruleValue[\"UNTIL\"] ? parseUntilRruleTime(rruleValue[\"UNTIL\"], tzId) : null\n\tconst count = rruleValue[\"COUNT\"] ? parseInt(rruleValue[\"COUNT\"]) : null\n\tconst endType: EndType = until != null ? EndType.UntilDate : count != null ? EndType.Count : EndType.Never\n\tconst interval = rruleValue[\"INTERVAL\"] ? parseInt(rruleValue[\"INTERVAL\"]) : 1\n\tconst repeatRule = createRepeatRule({\n\t\tendValue: until ? String(until.getTime()) : count ? String(count) : null,\n\t\tendType: endType,\n\t\tinterval: String(interval),\n\t\tfrequency: frequency,\n\t\texcludedDates: [],\n\t\ttimeZone: \"\",\n\t\tadvancedRules: parseAdvancedRule(rruleValue),\n\t})\n\n\tif (typeof tzId === \"string\") {\n\t\trepeatRule.timeZone = tzId\n\t}\n\n\treturn repeatRule\n}\n\nexport function parseAdvancedRule(rrule: Record<string, string>): CalendarAdvancedRepeatRule[] {\n\tconst advancedRepeatRules: CalendarAdvancedRepeatRule[] = []\n\tfor (const rruleKey in rrule) {\n\t\tif (!BYRULE_MAP.has(rruleKey)) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor (const interval of rrule[rruleKey].split(\",\")) {\n\t\t\tif (interval === \"\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tadvancedRepeatRules.push(\n\t\t\t\tcreateCalendarAdvancedRepeatRule({\n\t\t\t\t\truleType: BYRULE_MAP.get(rruleKey)!.toString(),\n\t\t\t\t\tinterval,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n\treturn advancedRepeatRules\n}\n\nexport function parseExDates(excludedDatesProps: Property[]): DateWrapper[] {\n\t// it's possible that we have duplicated entries since this data comes from whereever, this deduplicates it.\n\tconst allExDates: Map<number, DateWrapper> = new Map<number, DateWrapper>()\n\tfor (let excludedDatesProp of excludedDatesProps) {\n\t\tconst tzId = getTzId(excludedDatesProp)\n\t\tconst values = separatedByCommaParser(new StringIterator(excludedDatesProp.value))\n\t\tfor (let value of values) {\n\t\t\tconst { date: exDate } = parseTime(value, tzId ?? undefined)\n\t\t\tallExDates.set(exDate.getTime(), createDateWrapper({ date: exDate }))\n\t\t}\n\t}\n\treturn [...allExDates.values()].sort((dateWrapper1, dateWrapper2) => dateWrapper1.date.getTime() - dateWrapper2.date.getTime())\n}\n\nexport function parseRecurrenceId(recurrenceIdProp: Property, tzId: string | null): Date {\n\tconst components = parseTimeIntoComponents(recurrenceIdProp.value)\n\t// rrule until is inclusive in ical but exclusive in Tutanota\n\tconst filledComponents = components\n\t// if minute is not provided it is an all day date YYYYMMDD\n\tconst allDay = !(\"minute\" in components)\n\t// We don't use the zone from the components (RRULE) but the one from start time if it was given.\n\t// Don't ask me why but that's how it is.\n\tconst effectiveZone = allDay ? \"UTC\" : components.zone ?? getTzId(recurrenceIdProp) ?? tzId ?? undefined\n\tdelete filledComponents[\"zone\"]\n\tconst luxonDate = DateTime.fromObject(filledComponents, { zone: effectiveZone })\n\treturn toValidJSDate(luxonDate, recurrenceIdProp.value, tzId)\n}\n\n/**\n * @returns new end time\n */\nfunction parseEventDuration(durationValue: string, startTime: Date): Date {\n\tconst duration = parseDuration(durationValue)\n\tlet durationInMillis = 0\n\n\tif (duration.week) {\n\t\tdurationInMillis += DAY_IN_MILLIS * 7 * duration.week\n\t}\n\n\tif (duration.day) {\n\t\tdurationInMillis += DAY_IN_MILLIS * duration.day\n\t}\n\n\tif (duration.hour) {\n\t\tdurationInMillis += 1000 * 60 * 60 * duration.hour\n\t}\n\n\tif (duration.minute) {\n\t\tdurationInMillis += 1000 * 60 * duration.minute\n\t}\n\n\treturn new Date(startTime.getTime() + durationInMillis)\n}\n\nfunction getTzId(prop: Property): string | null {\n\tlet tzId: string | null = null\n\tconst tzIdValue = prop.params[\"TZID\"]\n\n\tif (tzIdValue) {\n\t\tif (IANAZone.isValidZone(tzIdValue)) {\n\t\t\ttzId = tzIdValue\n\t\t} else if (tzIdValue in WindowsZones) {\n\t\t\ttzId = WindowsZones[tzIdValue as keyof typeof WindowsZones]\n\t\t}\n\t}\n\n\treturn tzId\n}\n\nfunction oneDayDurationEnd(startTime: Date, allDay: boolean, tzId: string | null, zone: string): Date {\n\treturn DateTime.fromJSDate(startTime, {\n\t\tzone: allDay ? \"UTC\" : tzId || zone,\n\t})\n\t\t.plus({\n\t\t\tday: 1,\n\t\t})\n\t\t.toJSDate()\n}\n\nconst MAILTO_PREFIX_REGEX = /^mailto:(.*)/i\n\nfunction parseMailtoValue(value: string) {\n\tconst match = value.match(MAILTO_PREFIX_REGEX)\n\treturn match && match[1]\n}\n\nexport const calendarAttendeeStatusToParstat: Record<CalendarAttendeeStatus, string> = {\n\t// WE map ADDED to NEEDS-ACTION for sending out invites\n\t[CalendarAttendeeStatus.ADDED]: \"NEEDS-ACTION\",\n\t[CalendarAttendeeStatus.NEEDS_ACTION]: \"NEEDS-ACTION\",\n\t[CalendarAttendeeStatus.ACCEPTED]: \"ACCEPTED\",\n\t[CalendarAttendeeStatus.DECLINED]: \"DECLINED\",\n\t[CalendarAttendeeStatus.TENTATIVE]: \"TENTATIVE\",\n}\nconst parstatToCalendarAttendeeStatus: Record<string, CalendarAttendeeStatus> = reverse(calendarAttendeeStatusToParstat)\n\nexport function parseCalendarEvents(icalObject: ICalObject, zone: string): ParsedCalendarData {\n\tconst methodProp = getProp(icalObject, \"METHOD\", true)\n\tconst method = methodProp ? methodProp.value : CalendarMethod.PUBLISH\n\tconst eventObjects = icalObject.children.filter((obj) => obj.type === \"VEVENT\")\n\tconst contents = getContents(eventObjects, zone)\n\n\treturn {\n\t\tmethod,\n\t\tcontents,\n\t}\n}\n\nfunction getContents(eventObjects: ICalObject[], zone: string) {\n\treturn eventObjects.map((eventObj, index) => {\n\t\tconst startProp = getProp(eventObj, \"DTSTART\", false)\n\t\tconst tzId = getTzId(startProp)\n\t\tconst { date: startTime, allDay } = parseTime(startProp.value, tzId ?? undefined)\n\n\t\t// start time and tzid is sorted, so we can worry about event identity now before proceeding...\n\t\tlet hasValidUid = false\n\t\tlet uid: string | null = null\n\t\ttry {\n\t\t\tuid = getPropStringValue(eventObj, \"UID\", false)\n\t\t\thasValidUid = true\n\t\t} catch (e) {\n\t\t\tif (e instanceof ParserError) {\n\t\t\t\t// Also parse event and create new UID if none is set\n\t\t\t\tuid = `import-${Date.now()}-${index}@tuta.com`\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tconst recurrenceIdProp = getProp(eventObj, \"RECURRENCE-ID\", true)\n\t\tlet recurrenceId: Date | null = null\n\t\tif (recurrenceIdProp != null && hasValidUid) {\n\t\t\t// if we generated the UID, we have no way of knowing which event series this recurrenceId refers to.\n\t\t\t// in that case, we just don't add the recurrenceId and import the event as a standalone.\n\t\t\trecurrenceId = parseRecurrenceId(recurrenceIdProp, tzId)\n\t\t}\n\n\t\tconst endTime = parseEndTime(eventObj, allDay, startTime, tzId, zone)\n\n\t\tlet summary: string = \"\"\n\t\tconst maybeSummary = parseICalText(eventObj, \"SUMMARY\")\n\t\tif (maybeSummary) summary = maybeSummary\n\n\t\tlet location: string = \"\"\n\t\tconst maybeLocation = parseICalText(eventObj, \"LOCATION\")\n\t\tif (maybeLocation) location = maybeLocation\n\n\t\tconst rruleProp = getPropStringValue(eventObj, \"RRULE\", true)\n\t\tconst excludedDateProps = eventObj.properties.filter((p) => p.name === \"EXDATE\")\n\n\t\tlet repeatRule: RepeatRule | null = null\n\t\tif (rruleProp != null) {\n\t\t\trepeatRule = parseRrule(rruleProp, tzId)\n\t\t\trepeatRule.excludedDates = parseExDates(excludedDateProps)\n\t\t}\n\n\t\tconst description = parseICalText(eventObj, \"DESCRIPTION\") ?? \"\"\n\n\t\tconst sequenceProp = getProp(eventObj, \"SEQUENCE\", true)\n\t\tlet sequence: string = \"0\"\n\t\tif (sequenceProp) {\n\t\t\tconst sequenceNumber = filterInt(sequenceProp.value)\n\n\t\t\tif (Number.isNaN(sequenceNumber)) {\n\t\t\t\tthrow new ParserError(\"SEQUENCE value is not a number\")\n\t\t\t}\n\n\t\t\t// Convert it back to NumberString. Could use original one but this feels more robust.\n\t\t\tsequence = String(sequenceNumber)\n\t\t}\n\n\t\tconst attendees = getAttendees(eventObj)\n\n\t\tconst organizerProp = getProp(eventObj, \"ORGANIZER\", true)\n\t\tlet organizer: EncryptedMailAddress | null = null\n\t\tif (organizerProp) {\n\t\t\tconst organizerAddress = parseMailtoValue(organizerProp.value)\n\n\t\t\tif (organizerAddress && isMailAddress(organizerAddress, false)) {\n\t\t\t\torganizer = createEncryptedMailAddress({\n\t\t\t\t\taddress: organizerAddress,\n\t\t\t\t\tname: organizerProp.params[\"name\"] || \"\",\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconsole.log(\"organizer has no address or address is invalid, ignoring: \", organizerAddress)\n\t\t\t}\n\t\t}\n\n\t\tconst event = createCalendarEvent({\n\t\t\tdescription,\n\t\t\tstartTime,\n\t\t\tendTime,\n\t\t\tuid,\n\t\t\trecurrenceId,\n\t\t\tsummary,\n\t\t\tlocation,\n\t\t\trepeatRule,\n\t\t\tsequence,\n\t\t\tattendees,\n\t\t\torganizer,\n\t\t\thashedUid: null,\n\t\t\tinvitedConfidentially: null,\n\t\t\talarmInfos: [],\n\t\t}) as Require<\"uid\", CalendarEvent>\n\n\t\tlet alarms: AlarmInfoTemplate[] = []\n\n\t\ttry {\n\t\t\talarms = getAlarms(eventObj, startTime)\n\t\t} catch (e) {\n\t\t\tconsole.log(\"alarm is invalid for event: \", event.summary, event.startTime)\n\t\t}\n\n\t\treturn {\n\t\t\tevent,\n\t\t\talarms,\n\t\t}\n\t})\n}\n\nfunction getAttendees(eventObj: ICalObject) {\n\tlet attendees: CalendarEventAttendee[] = []\n\tfor (const property of eventObj.properties) {\n\t\tif (property.name === \"ATTENDEE\") {\n\t\t\tconst attendeeAddress = parseMailtoValue(property.value)\n\n\t\t\tif (!attendeeAddress || !isMailAddress(attendeeAddress, false)) {\n\t\t\t\tconsole.log(\"attendee has no address or address is invalid, ignoring: \", attendeeAddress)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst partStatString = property.params[\"PARTSTAT\"]\n\t\t\tconst status = partStatString ? parstatToCalendarAttendeeStatus[partStatString] : CalendarAttendeeStatus.NEEDS_ACTION\n\n\t\t\tif (!status) {\n\t\t\t\tconsole.log(`attendee has invalid partsat: ${partStatString}, ignoring`)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tattendees.push(\n\t\t\t\tcreateCalendarEventAttendee({\n\t\t\t\t\taddress: createEncryptedMailAddress({\n\t\t\t\t\t\taddress: attendeeAddress,\n\t\t\t\t\t\tname: property.params[\"CN\"] || \"\",\n\t\t\t\t\t}),\n\t\t\t\t\tstatus,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n\treturn attendees\n}\n\nfunction getAlarms(eventObj: ICalObject, startTime: Date): AlarmInfoTemplate[] {\n\tconst alarms: AlarmInfoTemplate[] = []\n\tfor (const alarmChild of eventObj.children) {\n\t\tif (alarmChild.type === \"VALARM\") {\n\t\t\tconst newAlarm = parseAlarm(alarmChild, startTime)\n\t\t\tif (newAlarm) alarms.push(newAlarm)\n\t\t}\n\t}\n\treturn alarms\n}\n\n/**\n * Parses text properties according to the iCal standard.\n * https://icalendar.org/iCalendar-RFC-5545/3-3-11-text.html\n * @param eventObj\n * @param tag\n */\nfunction parseICalText(eventObj: ICalObject, tag: string) {\n\tlet text = getPropStringValue(eventObj, tag, true)\n\tfor (const rawEscape in revICalReplacements) {\n\t\tif (rawEscape === \"\\\\n\") {\n\t\t\ttext = text?.replace(\"\\\\N\", revICalReplacements[rawEscape])\n\t\t}\n\t\ttext = text?.replace(rawEscape, revICalReplacements[rawEscape])\n\t}\n\treturn text\n}\n\nfunction parseEndTime(eventObj: ICalObject, allDay: boolean, startTime: Date, tzId: string | null, zone: string): Date {\n\tconst endProp = getProp(eventObj, \"DTEND\", true)\n\n\tif (endProp) {\n\t\tif (typeof endProp.value !== \"string\") throw new ParserError(\"DTEND value is not a string\")\n\t\tconst endTzId = getTzId(endProp)\n\t\tconst parsedEndTime = parseTime(endProp.value, typeof endTzId === \"string\" ? endTzId : undefined)\n\t\tconst endTime = parsedEndTime.date\n\t\tif (endTime > startTime) return endTime\n\n\t\t// as per RFC, these are _technically_ illegal: https://tools.ietf.org/html/rfc5545#section-3.8.2.2\n\t\tif (allDay) {\n\t\t\t// if the startTime indicates an all-day event, we want to preserve that.\n\t\t\t// we'll assume a 1-day duration.\n\t\t\treturn DateTime.fromJSDate(startTime).plus({ day: 1 }).toJSDate()\n\t\t} else {\n\t\t\t// we make a best effort to deliver alarms at the set interval before startTime and set the\n\t\t\t// event duration to be 1 second\n\t\t\t// as of now:\n\t\t\t// * this displays as ending the same minute it starts in the tutanota calendar\n\t\t\t// * gets exported with a duration of 1 second\n\t\t\treturn DateTime.fromJSDate(startTime).plus({ second: 1 }).toJSDate()\n\t\t}\n\t} else {\n\t\tconst durationValue = getPropStringValue(eventObj, \"DURATION\", true)\n\n\t\tif (durationValue) {\n\t\t\treturn parseEventDuration(durationValue, startTime)\n\t\t} else {\n\t\t\t// >For cases where a \"VEVENT\" calendar component specifies a \"DTSTART\" property with a DATE value type but no \"DTEND\" nor\n\t\t\t// \"DURATION\" property, the event's duration is taken to be one day.\n\t\t\t//\n\t\t\t// https://tools.ietf.org/html/rfc5545#section-3.6.1\n\t\t\treturn oneDayDurationEnd(startTime, allDay, tzId, zone)\n\t\t}\n\t}\n}\n\ntype ICalDuration = {\n\tpositive: boolean\n\tday?: number\n\tweek?: number\n\thour?: number\n\tminute?: number\n}\n\nfunction icalFrequencyToRepeatPeriod(value: string): RepeatPeriod {\n\tconst convertedValue = {\n\t\tDAILY: RepeatPeriod.DAILY,\n\t\tWEEKLY: RepeatPeriod.WEEKLY,\n\t\tMONTHLY: RepeatPeriod.MONTHLY,\n\t\tYEARLY: RepeatPeriod.ANNUALLY,\n\t}[value]\n\tif (convertedValue == null) {\n\t\tthrow new ParserError(\"Invalid frequency: \" + value)\n\t}\n\treturn convertedValue\n}\n\nexport function repeatPeriodToIcalFrequency(repeatPeriod: RepeatPeriod) {\n\t// Separate variable to declare mapping type\n\tconst mapping: Record<RepeatPeriod, string> = {\n\t\t[RepeatPeriod.DAILY]: \"DAILY\",\n\t\t[RepeatPeriod.WEEKLY]: \"WEEKLY\",\n\t\t[RepeatPeriod.MONTHLY]: \"MONTHLY\",\n\t\t[RepeatPeriod.ANNUALLY]: \"YEARLY\",\n\t}\n\treturn mapping[repeatPeriod]\n}\n\ntype DateComponents = {\n\tyear: number\n\tmonth: number\n\tday: number\n\tzone?: string\n}\ntype TimeComponents = {\n\thour: number\n\tminute: number\n}\ntype DateTimeComponents = DateComponents & TimeComponents\n\n/** parse a time */\nexport function parseTimeIntoComponents(value: string): DateComponents | DateTimeComponents {\n\tconst trimmedValue = value.trim()\n\n\tif (/[0-9]{8}T[0-9]{6}Z/.test(trimmedValue)) {\n\t\t// date with time in UTC\n\t\tconst { year, month, day } = parseDateString(trimmedValue)\n\t\tconst hour = parseInt(trimmedValue.slice(9, 11))\n\t\tconst minute = parseInt(trimmedValue.slice(11, 13))\n\t\treturn {\n\t\t\tyear,\n\t\t\tmonth,\n\t\t\tday,\n\t\t\thour,\n\t\t\tminute,\n\t\t\tzone: \"UTC\",\n\t\t}\n\t} else if (/[0-9]{8}T[0-9]{6}/.test(trimmedValue)) {\n\t\t// date with time in local timezone\n\t\tconst { year, month, day } = parseDateString(trimmedValue)\n\t\tconst hour = parseInt(trimmedValue.slice(9, 11))\n\t\tconst minute = parseInt(trimmedValue.slice(11, 13))\n\t\treturn {\n\t\t\tyear,\n\t\t\tmonth,\n\t\t\tday,\n\t\t\thour,\n\t\t\tminute,\n\t\t}\n\t} else if (/[0-9]{8}/.test(trimmedValue)) {\n\t\t// all day events\n\t\treturn Object.assign({}, parseDateString(trimmedValue))\n\t} else {\n\t\tthrow new ParserError(\"Failed to parse time: \" + trimmedValue)\n\t}\n}\n\nexport function parseUntilRruleTime(value: string, zone: string | null): Date {\n\tconst components = parseTimeIntoComponents(value)\n\t// rrule until is inclusive in ical but exclusive in Tutanota\n\tconst filledComponents = components\n\t// if minute is not provided it is an all day date YYYYMMDD\n\tconst allDay = !(\"minute\" in components)\n\t// We don't use the zone from the components (RRULE) but the one from start time if it was given.\n\t// Don't ask me why but that's how it is.\n\tconst effectiveZone = allDay ? \"UTC\" : zone ?? undefined\n\tdelete filledComponents[\"zone\"]\n\tconst luxonDate = DateTime.fromObject(filledComponents, { zone: effectiveZone })\n\tconst startOfNextDay = luxonDate\n\t\t.plus({\n\t\t\tday: 1,\n\t\t})\n\t\t.startOf(\"day\")\n\treturn toValidJSDate(startOfNextDay, value, zone)\n}\n\n/**\n * parse a ical time string and return a JS Date object along with a flag that determines\n * whether the time should be considered part of an all-day event\n * @param value {string} the time string to be parsed\n * @param zone {string} the time zone to use\n */\nexport function parseTime(\n\tvalue: string,\n\tzone?: string,\n): {\n\tdate: Date\n\tallDay: boolean\n} {\n\tconst components = parseTimeIntoComponents(value)\n\t// if minute is not provided it is an all day date YYYYMMDD\n\tconst allDay = !(\"minute\" in components)\n\tconst effectiveZone = allDay ? \"UTC\" : components.zone ?? zone\n\tdelete components[\"zone\"]\n\tconst filledComponents = Object.assign(\n\t\t{},\n\t\tallDay\n\t\t\t? {\n\t\t\t\t\thour: 0,\n\t\t\t\t\tminute: 0,\n\t\t\t\t\tsecond: 0,\n\t\t\t\t\tmillisecond: 0,\n\t\t\t  }\n\t\t\t: {},\n\t\tcomponents,\n\t)\n\n\ttry {\n\t\tconst dateTime = DateTime.fromObject(filledComponents, { zone: effectiveZone })\n\t\treturn { date: toValidJSDate(dateTime, value, zone ?? null), allDay }\n\t} catch (e) {\n\t\tif (e instanceof ParserError) {\n\t\t\tthrow e\n\t\t}\n\t\tthrow new ParserError(\n\t\t\t`failed to parse time from ${value} to ${JSON.stringify(filledComponents)}, effectiveZone: ${effectiveZone}, original error: ${e.message}`,\n\t\t)\n\t}\n}\n\nfunction toValidJSDate(dateTime: DateTime, value: string, zone: string | null): Date {\n\tif (!dateTime.isValid) {\n\t\tthrow new ParserError(`Date value ${value} is invalid in zone ${String(zone)}`)\n\t}\n\n\treturn dateTime.toJSDate()\n}\n\nfunction parsePropertyName(iterator: StringIterator): string {\n\tlet text = \"\"\n\n\tlet next\n\twhile ((next = iterator.peek()) && /[a-zA-Z0-9-_]/.test(next)) {\n\t\ttext += neverNull(iterator.next().value)\n\t}\n\n\tif (text === \"\") {\n\t\tthrow new ParserError(\"could not parse property name: \" + iterator.peek())\n\t}\n\n\treturn text\n}\n\nconst secondDurationParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"S\"))\nconst minuteDurationParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"M\"))\nconst hourDurationParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"H\"))\ntype TimeDuration = {\n\ttype: \"time\"\n\thour?: number\n\tminute?: number\n\tsecond?: number\n}\ntype DateDuration = {\n\ttype: \"date\"\n\tday: number\n\ttime: TimeDuration | null\n}\ntype WeekDuration = {\n\ttype: \"week\"\n\tweek: number\n}\nconst durationTimeParser = mapParser(\n\tcombineParsers(makeCharacterParser(\"T\"), maybeParse(hourDurationParser), maybeParse(minuteDurationParser), maybeParse(secondDurationParser)),\n\t(parsed) => {\n\t\t//Note: we parse for seconds in case they are there, but do not have that as an option, so they are ignored\n\t\tlet hour, minute\n\n\t\t// the first item in parsed is T (if time is there)\n\t\tif (parsed[1]) {\n\t\t\thour = parsed[1][0]\n\t\t}\n\t\tif (parsed[2]) {\n\t\t\tminute = parsed[2][0]\n\t\t}\n\n\t\treturn {\n\t\t\thour,\n\t\t\tminute,\n\t\t}\n\t},\n)\nconst durationDayParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"D\"))\nconst durationWeekParser: Parser<[number, string]> = combineParsers(numberParser, makeCharacterParser(\"W\"))\nconst durationParser = mapParser(\n\tcombineParsers(\n\t\tmaybeParse(makeEitherParser(makeCharacterParser(\"+\"), makeCharacterParser(\"-\"))),\n\t\tmakeCharacterParser(\"P\"),\n\t\tmaybeParse(durationWeekParser),\n\t\tmaybeParse(durationDayParser),\n\t\tmaybeParse(durationTimeParser),\n\t),\n\t(parsed) => {\n\t\tconst positive = parsed[0] !== \"-\"\n\t\tlet week, day, hour, minute\n\t\tif (parsed[2]) {\n\t\t\tweek = parsed[2][0]\n\t\t}\n\t\tif (parsed[3]) {\n\t\t\tday = parsed[3][0]\n\t\t}\n\n\t\treturn {\n\t\t\tpositive,\n\t\t\tweek,\n\t\t\tday,\n\t\t\thour: parsed[4]?.hour,\n\t\t\tminute: parsed[4]?.minute,\n\t\t}\n\t},\n)\n\nexport function parseDuration(value: string): ICalDuration {\n\tconst iterator = new StringIterator(value)\n\tconst duration = durationParser(iterator)\n\n\tif (iterator.peek()) {\n\t\tthrow new ParserError(\"Could not parse duration completely\")\n\t}\n\n\treturn duration\n}\n"]}