{"version":3,"file":"MailListModel.js","sourceRoot":"","sources":["../../../../../src/mail-app/mail/model/MailListModel.ts"],"names":[],"mappings":"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","sourcesContent":["import { ListFilter, ListModel } from \"../../../common/misc/ListModel\"\nimport { Mail, MailFolder, MailFolderTypeRef, MailSetEntry, MailSetEntryTypeRef, MailTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs\"\nimport {\n\tCUSTOM_MAX_ID,\n\tcustomIdToUint8array,\n\tdeconstructMailSetEntryId,\n\telementIdPart,\n\tgetElementId,\n\tisSameId,\n\tlistIdPart,\n} from \"../../../common/api/common/utils/EntityUtils\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient\"\nimport { ConversationPrefProvider } from \"../view/ConversationViewModel\"\nimport { assertMainOrNode } from \"../../../common/api/common/Env\"\nimport { assertNotNull, compare, promiseFilter } from \"@tutao/tutanota-utils\"\nimport { ListLoadingState, ListState } from \"../../../common/gui/base/List\"\nimport Stream from \"mithril/stream\"\nimport { EntityUpdateData, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils\"\nimport { MailSetKind, OperationType } from \"../../../common/api/common/TutanotaConstants\"\nimport { InboxRuleHandler } from \"./InboxRuleHandler\"\nimport { MailModel } from \"./MailModel\"\nimport { ListFetchResult } from \"../../../common/gui/base/ListUtils\"\nimport { isOfflineError } from \"../../../common/api/common/utils/ErrorUtils\"\nimport { ExposedCacheStorage } from \"../../../common/api/worker/rest/DefaultEntityRestCache\"\n\nassertMainOrNode()\n\n/**\n * Internal representation of a loaded mail\n *\n * @VisibleForTesting\n */\nexport interface LoadedMail {\n\treadonly mail: Mail\n\treadonly mailSetEntry: MailSetEntry\n\treadonly labels: ReadonlyArray<MailFolder>\n}\n\n/**\n * Handles fetching and resolving mail set entries into mails as well as handling sorting.\n */\nexport class MailListModel {\n\t// Id = MailSetEntry element id\n\tprivate readonly listModel: ListModel<LoadedMail, Id>\n\n\t// keep a reverse map for going from Mail element id -> LoadedMail\n\tprivate readonly mailMap: Map<Id, LoadedMail> = new Map()\n\n\tconstructor(\n\t\tprivate readonly mailSet: MailFolder,\n\t\tprivate readonly conversationPrefProvider: ConversationPrefProvider,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly mailModel: MailModel,\n\t\tprivate readonly inboxRuleHandler: InboxRuleHandler,\n\t\tprivate readonly cacheStorage: ExposedCacheStorage,\n\t) {\n\t\tthis.listModel = new ListModel({\n\t\t\tfetch: (lastFetchedItem, count) => {\n\t\t\t\tconst lastFetchedId = lastFetchedItem?.mailSetEntry?._id ?? [mailSet.entries, CUSTOM_MAX_ID]\n\t\t\t\treturn this.loadMails(lastFetchedId, count)\n\t\t\t},\n\n\t\t\tsortCompare: (item1, item2) => {\n\t\t\t\t// Mail set entry ID has the timestamp and mail element ID\n\t\t\t\tconst item1Id = getElementId(item1.mailSetEntry)\n\t\t\t\tconst item2Id = getElementId(item2.mailSetEntry)\n\n\t\t\t\t// Sort in reverse order to ensure newer mails are first\n\t\t\t\treturn compare(customIdToUint8array(item2Id), customIdToUint8array(item1Id))\n\t\t\t},\n\n\t\t\tgetItemId: (item) => getElementId(item.mailSetEntry),\n\n\t\t\tisSameId: (id1, id2) => id1 === id2,\n\n\t\t\tautoSelectBehavior: () => this.conversationPrefProvider.getMailAutoSelectBehavior(),\n\t\t})\n\t}\n\n\tget items(): Mail[] {\n\t\treturn this._loadedMails().map((mail) => mail.mail)\n\t}\n\n\tget loadingStatus(): ListLoadingState {\n\t\treturn this.listModel.state.loadingStatus\n\t}\n\n\tget stateStream(): Stream<ListState<Mail>> {\n\t\treturn this.listModel.stateStream.map((state) => {\n\t\t\tconst items = state.items.map((item) => item.mail)\n\t\t\tconst selectedItems: Set<Mail> = new Set()\n\t\t\tfor (const item of state.selectedItems) {\n\t\t\t\tselectedItems.add(item.mail)\n\t\t\t}\n\t\t\tconst newState: ListState<Mail> = {\n\t\t\t\t...state,\n\t\t\t\titems,\n\t\t\t\tselectedItems,\n\t\t\t}\n\t\t\treturn newState\n\t\t})\n\t}\n\n\tisLoadingAll(): boolean {\n\t\treturn this.listModel.state.loadingAll\n\t}\n\n\tisItemSelected(mailId: Id): boolean {\n\t\tconst loadedMail = this.mailMap.get(mailId)\n\t\tif (loadedMail == null) {\n\t\t\treturn false\n\t\t}\n\t\treturn this.listModel.isItemSelected(getElementId(loadedMail.mailSetEntry))\n\t}\n\n\tgetMail(mailElementId: Id): Mail | null {\n\t\treturn this.getLoadedMailByMailId(mailElementId)?.mail ?? null\n\t}\n\n\tgetLabelsForMail(mail: Mail): ReadonlyArray<MailFolder> {\n\t\treturn this.getLoadedMailByMailInstance(mail)?.labels ?? []\n\t}\n\n\tgetMailSetEntry(mailSetEntryId: Id): MailSetEntry | null {\n\t\treturn this.getLoadedMailByMailSetId(mailSetEntryId)?.mailSetEntry ?? null\n\t}\n\n\tasync loadAndSelect(mailId: Id, shouldStop: () => boolean): Promise<Mail | null> {\n\t\tconst mailFinder = (loadedMail: LoadedMail) => isSameId(getElementId(loadedMail.mail), mailId)\n\t\tconst mail = await this.listModel.loadAndSelect(mailFinder, shouldStop)\n\t\treturn mail?.mail ?? null\n\t}\n\n\tonSingleSelection(mail: Mail) {\n\t\tthis.listModel.onSingleSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)))\n\t}\n\n\tselectNone() {\n\t\tthis.listModel.selectNone()\n\t}\n\n\tcancelLoadAll() {\n\t\tthis.listModel.cancelLoadAll()\n\t}\n\n\tasync loadInitial() {\n\t\tawait this.listModel.loadInitial()\n\t}\n\n\tgetSelectedAsArray(): Array<Mail> {\n\t\treturn this.listModel.getSelectedAsArray().map(({ mail }) => mail)\n\t}\n\n\tasync handleEntityUpdate(update: EntityUpdateData) {\n\t\tif (isUpdateForTypeRef(MailFolderTypeRef, update)) {\n\t\t\t// If a label is modified, we want to update all mails that reference it, which requires linearly iterating\n\t\t\t// through all mails. There are more efficient ways we could do this, such as by keeping track of each label\n\t\t\t// we've retrieved from the database and just update that, but we want to avoid adding more maps that we\n\t\t\t// have to maintain.\n\t\t\tif (update.operation === OperationType.UPDATE) {\n\t\t\t\tconst mailSetId: IdTuple = [update.instanceListId, update.instanceId]\n\t\t\t\tfor (const loadedMail of this.mailMap.values()) {\n\t\t\t\t\tconst hasMailSet = loadedMail.labels.some((label) => isSameId(mailSetId, label._id))\n\t\t\t\t\tif (!hasMailSet) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// MailModel's entity event listener should have been fired first\n\t\t\t\t\tconst labels = this.mailModel.getLabelsForMail(loadedMail.mail)\n\t\t\t\t\tconst newMailEntry = {\n\t\t\t\t\t\t...loadedMail,\n\t\t\t\t\t\tlabels,\n\t\t\t\t\t}\n\t\t\t\t\tthis._updateSingleMail(newMailEntry)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isUpdateForTypeRef(MailSetEntryTypeRef, update) && isSameId(this.mailSet.entries, update.instanceListId)) {\n\t\t\t// Adding/removing to this list (MailSetEntry doesn't have any fields to update, so we don't need to handle this)\n\t\t\tif (update.operation === OperationType.DELETE) {\n\t\t\t\tconst mail = this.getLoadedMailByMailSetId(update.instanceId)\n\t\t\t\tif (mail) {\n\t\t\t\t\tthis.mailMap.delete(getElementId(mail.mail))\n\t\t\t\t}\n\t\t\t\tawait this.listModel.deleteLoadedItem(update.instanceId)\n\t\t\t} else if (update.operation === OperationType.CREATE) {\n\t\t\t\tconst loadedMail = await this.loadSingleMail([update.instanceListId, update.instanceId])\n\t\t\t\tawait this.listModel.waitLoad(async () => {\n\t\t\t\t\tif (this.listModel.canInsertItem(loadedMail)) {\n\t\t\t\t\t\tthis.listModel.insertLoadedItem(loadedMail)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t} else if (isUpdateForTypeRef(MailTypeRef, update)) {\n\t\t\t// We only need to handle updates for Mail.\n\t\t\t// Mail deletion will also be handled in MailSetEntry delete/create.\n\t\t\tconst mailItem = this.mailMap.get(update.instanceId)\n\t\t\tif (mailItem != null && update.operation === OperationType.UPDATE) {\n\t\t\t\tconst newMailData = await this.entityClient.load(MailTypeRef, [update.instanceListId, update.instanceId])\n\t\t\t\tconst labels = this.mailModel.getLabelsForMail(newMailData) // in case labels were added/removed\n\t\t\t\tconst newMailItem = {\n\t\t\t\t\t...mailItem,\n\t\t\t\t\tlabels,\n\t\t\t\t\tmail: newMailData,\n\t\t\t\t}\n\t\t\t\tthis._updateSingleMail(newMailItem)\n\t\t\t}\n\t\t}\n\t}\n\n\tareAllSelected(): boolean {\n\t\treturn this.listModel.areAllSelected()\n\t}\n\n\tselectAll() {\n\t\tthis.listModel.selectAll()\n\t}\n\n\tonSingleInclusiveSelection(mail: Mail, clearSelectionOnMultiSelectStart?: boolean) {\n\t\tthis.listModel.onSingleInclusiveSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)), clearSelectionOnMultiSelectStart)\n\t}\n\n\tselectRangeTowards(mail: Mail) {\n\t\tthis.listModel.selectRangeTowards(assertNotNull(this.getLoadedMailByMailInstance(mail)))\n\t}\n\n\tselectPrevious(multiselect: boolean) {\n\t\tthis.listModel.selectPrevious(multiselect)\n\t}\n\n\tselectNext(multiselect: boolean) {\n\t\tthis.listModel.selectNext(multiselect)\n\t}\n\n\tonSingleExclusiveSelection(mail: Mail) {\n\t\tthis.listModel.onSingleExclusiveSelection(assertNotNull(this.getLoadedMailByMailInstance(mail)))\n\t}\n\n\tisInMultiselect(): boolean {\n\t\treturn this.listModel.state.inMultiselect\n\t}\n\n\tenterMultiselect() {\n\t\tthis.listModel.enterMultiselect()\n\t}\n\n\tasync loadAll() {\n\t\tawait this.listModel.loadAll()\n\t}\n\n\tsetFilter(filter: ListFilter<Mail> | null) {\n\t\tthis.listModel.setFilter(filter && ((loadedMail: LoadedMail) => filter(loadedMail.mail)))\n\t}\n\n\tisEmptyAndDone(): boolean {\n\t\treturn this.listModel.isEmptyAndDone()\n\t}\n\n\tasync loadMore() {\n\t\tawait this.listModel.loadMore()\n\t}\n\n\tasync retryLoading() {\n\t\tawait this.listModel.retryLoading()\n\t}\n\n\tstopLoading() {\n\t\tthis.listModel.stopLoading()\n\t}\n\n\tprivate getLoadedMailByMailId(mailId: Id): LoadedMail | null {\n\t\treturn this.mailMap.get(mailId) ?? null\n\t}\n\n\tprivate getLoadedMailByMailSetId(mailId: Id): LoadedMail | null {\n\t\treturn this.mailMap.get(deconstructMailSetEntryId(mailId).mailId) ?? null\n\t}\n\n\tprivate getLoadedMailByMailInstance(mail: Mail): LoadedMail | null {\n\t\treturn this.getLoadedMailByMailId(getElementId(mail))\n\t}\n\n\t/**\n\t * Load mails, applying inbox rules as needed\n\t */\n\tprivate async loadMails(startingId: IdTuple, count: number): Promise<ListFetchResult<LoadedMail>> {\n\t\tlet items: LoadedMail[] = []\n\t\tlet complete = false\n\n\t\ttry {\n\t\t\tconst mailSetEntries = await this.entityClient.loadRange(MailSetEntryTypeRef, listIdPart(startingId), elementIdPart(startingId), count, true)\n\n\t\t\t// Check for completeness before loading/filtering mails, as we may end up with even fewer mails than retrieved in either case\n\t\t\tcomplete = mailSetEntries.length < count\n\t\t\tif (mailSetEntries.length > 0) {\n\t\t\t\titems = await this.resolveMailSetEntries(mailSetEntries, this.defaultMailProvider)\n\t\t\t\titems = await this.applyInboxRulesToEntries(items)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (isOfflineError(e)) {\n\t\t\t\t// Attempt loading from the cache if we failed to get mails and/or mailset entries\n\t\t\t\t// Note that we may have items if it was just inbox rules that failed\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\t// Set the request as incomplete so that we make another request later (see `loadMailsFromCache` comment)\n\t\t\t\t\tcomplete = false\n\t\t\t\t\titems = await this.loadMailsFromCache(startingId, count)\n\t\t\t\t\tif (items.length === 0) {\n\t\t\t\t\t\tthrow e // we couldn't get anything from the cache!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\n\t\tthis.updateMailMap(items)\n\t\treturn {\n\t\t\titems,\n\t\t\tcomplete,\n\t\t}\n\t}\n\n\t/**\n\t * Load mails from the cache rather than remotely\n\t */\n\tprivate async loadMailsFromCache(startId: IdTuple, count: number): Promise<LoadedMail[]> {\n\t\t// The way the cache works is that it tries to fulfill the API contract of returning as many items as requested as long as it can.\n\t\t// This is problematic for offline where we might not have the full page of emails loaded (e.g. we delete part as it's too old, or we move emails\n\t\t// around). Because of that cache will try to load additional items from the server in order to return `count` items. If it fails to load them,\n\t\t// it will not return anything and instead will throw an error.\n\t\t// This is generally fine but in case of offline we want to display everything that we have cached. For that we fetch directly from the cache,\n\t\t// give it to the list and let list make another request (and almost certainly fail that request) to show a retry button. This way we both show\n\t\t// the items we have and also show that we couldn't load everything.\n\t\tconst mailSetEntries = await this.cacheStorage.provideFromRange(MailSetEntryTypeRef, listIdPart(startId), elementIdPart(startId), count, true)\n\t\treturn await this.resolveMailSetEntries(mailSetEntries, (list, elements) => this.cacheStorage.provideMultiple(MailTypeRef, list, elements))\n\t}\n\n\t/**\n\t * Apply inbox rules to an array of mails, returning all mails that were not moved\n\t */\n\tprivate async applyInboxRulesToEntries(entries: LoadedMail[]): Promise<LoadedMail[]> {\n\t\tif (this.mailSet.folderType !== MailSetKind.INBOX || entries.length === 0) {\n\t\t\treturn entries\n\t\t}\n\t\tconst mailboxDetail = await this.mailModel.getMailboxDetailsForMailFolder(this.mailSet)\n\t\tif (!mailboxDetail) {\n\t\t\treturn entries\n\t\t}\n\t\treturn await promiseFilter(entries, async (entry) => {\n\t\t\tconst ruleApplied = await this.inboxRuleHandler.findAndApplyMatchingRule(mailboxDetail, entry.mail, true)\n\t\t\treturn ruleApplied == null\n\t\t})\n\t}\n\n\tprivate async loadSingleMail(id: IdTuple): Promise<LoadedMail> {\n\t\tconst mailSetEntry = await this.entityClient.load(MailSetEntryTypeRef, id)\n\t\tconst loadedMails = await this.resolveMailSetEntries([mailSetEntry], this.defaultMailProvider)\n\t\tthis.updateMailMap(loadedMails)\n\t\treturn assertNotNull(loadedMails[0])\n\t}\n\n\t/**\n\t * Loads all Mail instances for each MailSetEntry, returning a tuple of each\n\t */\n\tprivate async resolveMailSetEntries(\n\t\tmailSetEntries: MailSetEntry[],\n\t\tmailProvider: (listId: Id, elementIds: Id[]) => Promise<Mail[]>,\n\t): Promise<LoadedMail[]> {\n\t\t// Sort all mails into mailbags so we can retrieve them with loadMultiple\n\t\tconst mailListMap: Map<Id, Id[]> = new Map()\n\t\tfor (const entry of mailSetEntries) {\n\t\t\tconst mailBag = listIdPart(entry.mail)\n\t\t\tconst mailElementId = elementIdPart(entry.mail)\n\t\t\tlet mailIds = mailListMap.get(mailBag)\n\t\t\tif (!mailIds) {\n\t\t\t\tmailIds = []\n\t\t\t\tmailListMap.set(mailBag, mailIds)\n\t\t\t}\n\t\t\tmailIds.push(mailElementId)\n\t\t}\n\n\t\t// Retrieve all mails by mailbag\n\t\tconst allMails: Map<Id, Mail> = new Map()\n\t\tfor (const [list, elements] of mailListMap) {\n\t\t\tconst mails = await mailProvider(list, elements)\n\t\t\tfor (const mail of mails) {\n\t\t\t\tallMails.set(getElementId(mail), mail)\n\t\t\t}\n\t\t}\n\n\t\t// Build our array\n\t\tconst loadedMails: LoadedMail[] = []\n\t\tfor (const mailSetEntry of mailSetEntries) {\n\t\t\tconst mail = allMails.get(elementIdPart(mailSetEntry.mail))\n\n\t\t\t// Mail may have been deleted in the meantime\n\t\t\tif (!mail) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Resolve labels\n\t\t\tconst labels: MailFolder[] = this.mailModel.getLabelsForMail(mail)\n\t\t\tloadedMails.push({ mailSetEntry, mail, labels })\n\t\t}\n\n\t\treturn loadedMails\n\t}\n\n\tprivate updateMailMap(mails: LoadedMail[]) {\n\t\tfor (const mail of mails) {\n\t\t\tthis.mailMap.set(getElementId(mail.mail), mail)\n\t\t}\n\t}\n\n\t// @VisibleForTesting\n\t_updateSingleMail(mail: LoadedMail) {\n\t\tthis.updateMailMap([mail])\n\t\tthis.listModel.updateLoadedItem(mail)\n\t}\n\n\t// @VisibleForTesting\n\t_loadedMails(): readonly LoadedMail[] {\n\t\treturn this.listModel.state.items\n\t}\n\n\tprivate readonly defaultMailProvider = (listId: Id, elements: Id[]): Promise<Mail[]> => {\n\t\treturn this.entityClient.loadMultiple(MailTypeRef, listId, elements)\n\t}\n}\n"]}