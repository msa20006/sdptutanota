{"version":3,"file":"ContactMergeUtils.js","sourceRoot":"","sources":["../../../../src/mail-app/contacts/ContactMergeUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { ContactComparisonResult, IndifferentContactComparisonResult } from \"../../common/api/common/TutanotaConstants\"\nimport { neverNull } from \"@tutao/tutanota-utils\"\nimport { isoDateToBirthday } from \"../../common/api/common/utils/BirthdayUtils\"\nimport type { Contact } from \"../../common/api/entities/tutanota/TypeRefs.js\"\nimport type { ContactMailAddress } from \"../../common/api/entities/tutanota/TypeRefs.js\"\nimport type { Birthday } from \"../../common/api/entities/tutanota/TypeRefs.js\"\nimport type { ContactAddress } from \"../../common/api/entities/tutanota/TypeRefs.js\"\nimport type { ContactPhoneNumber } from \"../../common/api/entities/tutanota/TypeRefs.js\"\nimport type { ContactSocialId } from \"../../common/api/entities/tutanota/TypeRefs.js\"\n\n/**\n * returns all contacts that are deletable because another contact exists that is exactly the same, and all contacts that look similar and therfore may be merged.\n * contacts are never returned in both \"mergable\" and \"deletable\"\n * contact similarity is checked transitively, i.e. if a similar to b and b similar to c, then a similar to c\n */\nexport function getMergeableContacts(inputContacts: Contact[]): {\n\tmergeable: Contact[][]\n\tdeletable: Contact[]\n} {\n\tlet mergableContacts: Contact[][] = []\n\tlet duplicateContacts: Contact[] = []\n\tlet contacts = inputContacts.slice()\n\tlet firstContactIndex = 0\n\n\twhile (firstContactIndex < contacts.length - 1) {\n\t\tlet currentMergableContacts: Contact[] = []\n\t\tlet firstContact = contacts[firstContactIndex]\n\t\tcurrentMergableContacts.push(firstContact)\n\t\tlet secondContactIndex = firstContactIndex + 1\n\n\t\t// run through all contacts after the first and compare them with the first (+ all others already in the currentMergableArray)\n\t\twhile (secondContactIndex < contacts.length) {\n\t\t\tlet secondContact = contacts[secondContactIndex]\n\n\t\t\tif (firstContact._id[1] !== secondContact._id[1]) {\n\t\t\t\t// should not happen, just to be safe\n\t\t\t\tlet overallResult = ContactComparisonResult.Unique\n\n\t\t\t\t// compare the current second contact with all in the currentMergableArray to find out if the overall comparison result is equal, similar or unique\n\t\t\t\tfor (let i = 0; i < currentMergableContacts.length; i++) {\n\t\t\t\t\tlet result = _compareContactsForMerge(currentMergableContacts[i], secondContact)\n\n\t\t\t\t\tif (result === ContactComparisonResult.Equal) {\n\t\t\t\t\t\toverallResult = ContactComparisonResult.Equal\n\t\t\t\t\t\tbreak // equal is always the final result\n\t\t\t\t\t} else if (result === ContactComparisonResult.Similar) {\n\t\t\t\t\t\toverallResult = ContactComparisonResult.Similar // continue checking the other contacts in currentMergableContacts to see if there is an equal one\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the contacts are unique, so we do not have to check the others\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (overallResult === ContactComparisonResult.Equal) {\n\t\t\t\t\tduplicateContacts.push(secondContact)\n\t\t\t\t\tcontacts.splice(secondContactIndex, 1)\n\t\t\t\t} else if (overallResult === ContactComparisonResult.Similar) {\n\t\t\t\t\tcurrentMergableContacts.push(secondContact)\n\t\t\t\t\tcontacts.splice(secondContactIndex, 1)\n\t\t\t\t} else {\n\t\t\t\t\tsecondContactIndex++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (currentMergableContacts.length > 1) {\n\t\t\tmergableContacts.push(currentMergableContacts)\n\t\t}\n\n\t\tfirstContactIndex++\n\t}\n\n\treturn {\n\t\tmergeable: mergableContacts,\n\t\tdeletable: duplicateContacts,\n\t}\n}\n\n/**\n * merges two contacts (eliminatedContact is merged into keptContact). outside this function keptContact must be updated on the server and eliminatedContact must be deleted\n */\nexport function mergeContacts(keptContact: Contact, eliminatedContact: Contact): void {\n\tkeptContact.firstName = _getMergedNameField(keptContact.firstName, eliminatedContact.firstName)\n\tkeptContact.lastName = _getMergedNameField(keptContact.lastName, eliminatedContact.lastName)\n\tkeptContact.title = neverNull(_getMergedOtherField(keptContact.title, eliminatedContact.title, \", \"))\n\tkeptContact.comment = neverNull(_getMergedOtherField(keptContact.comment, eliminatedContact.comment, \"\\n\\n\"))\n\tkeptContact.company = neverNull(_getMergedOtherField(keptContact.company, eliminatedContact.company, \", \"))\n\tkeptContact.nickname = _getMergedOtherField(keptContact.nickname, eliminatedContact.nickname, \", \")\n\tkeptContact.role = neverNull(_getMergedOtherField(keptContact.role, eliminatedContact.role, \", \"))\n\tkeptContact.birthdayIso = _getMergedBirthdays(keptContact.birthdayIso, eliminatedContact.birthdayIso)\n\tkeptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses)\n\tkeptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers)\n\tkeptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds)\n\tkeptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses)\n\tkeptContact.presharedPassword = neverNull(_getMergedOtherField(keptContact.presharedPassword, eliminatedContact.presharedPassword, \"\")) // the passwords are never different and not null\n}\n\n/**\n * Result is unique if preshared passwords are not equal and are not empty.\n * Result is equal if all fields are equal or empty (types are ignored).\n * Result is similar if one of:\n * 1. name result is equal or similar and birthday result is similar or oneEmpty or equal or bothEmpty\n * 2. name result (bothEmpty or oneEmpty) and mail or phone result is similar or equal and birthday result is similar or oneEmpty or equal or bothEmpty\n * Otherwise the result is unique\n * Export for testing\n */\nexport function _compareContactsForMerge(contact1: Contact, contact2: Contact): ContactComparisonResult {\n\tlet nameResult = _compareFullName(contact1, contact2)\n\n\tlet mailResult = _compareMailAddresses(contact1.mailAddresses, contact2.mailAddresses)\n\n\tlet phoneResult = _comparePhoneNumbers(contact1.phoneNumbers, contact2.phoneNumbers)\n\n\tlet birthdayResult = _compareBirthdays(contact1, contact2)\n\n\tlet residualContactFieldsEqual = _areResidualContactFieldsEqual(contact1, contact2)\n\n\tif (\n\t\tbirthdayResult !== ContactComparisonResult.Unique &&\n\t\t(!contact1.presharedPassword || !contact2.presharedPassword || contact1.presharedPassword === contact2.presharedPassword)\n\t) {\n\t\tif (\n\t\t\t(nameResult === ContactComparisonResult.Equal || nameResult === IndifferentContactComparisonResult.BothEmpty) &&\n\t\t\t(mailResult === ContactComparisonResult.Equal || mailResult === IndifferentContactComparisonResult.BothEmpty) &&\n\t\t\t(phoneResult === ContactComparisonResult.Equal || phoneResult === IndifferentContactComparisonResult.BothEmpty) &&\n\t\t\tresidualContactFieldsEqual\n\t\t) {\n\t\t\tif (birthdayResult === IndifferentContactComparisonResult.BothEmpty || birthdayResult === ContactComparisonResult.Equal) {\n\t\t\t\treturn ContactComparisonResult.Equal\n\t\t\t} else {\n\t\t\t\treturn ContactComparisonResult.Similar\n\t\t\t}\n\t\t} else if (nameResult === ContactComparisonResult.Equal || nameResult === ContactComparisonResult.Similar) {\n\t\t\treturn ContactComparisonResult.Similar\n\t\t} else if (\n\t\t\t(nameResult === IndifferentContactComparisonResult.BothEmpty || nameResult === IndifferentContactComparisonResult.OneEmpty) &&\n\t\t\t(mailResult === ContactComparisonResult.Similar ||\n\t\t\t\tphoneResult === ContactComparisonResult.Similar ||\n\t\t\t\tmailResult === ContactComparisonResult.Equal ||\n\t\t\t\tphoneResult === ContactComparisonResult.Equal)\n\t\t) {\n\t\t\treturn ContactComparisonResult.Similar\n\t\t} else {\n\t\t\treturn ContactComparisonResult.Unique\n\t\t}\n\t} else {\n\t\treturn ContactComparisonResult.Unique\n\t}\n}\n\n/**\n * Names are equal if the last names are available and equal and first names are equal or first names are available and equal and last names are equal.\n * Names are similar if the last names are available and equal and at least one first name is empty or like equal but case insensitive.\n * Returns null if the contacts names are not comparable, i.e. one of the contacts first and last names are empty.\n * Export for testing\n */\nexport function _compareFullName(contact1: Contact, contact2: Contact): ContactComparisonResult | IndifferentContactComparisonResult {\n\tif (contact1.firstName === contact2.firstName && contact1.lastName === contact2.lastName && (contact1.lastName || contact1.firstName)) {\n\t\treturn ContactComparisonResult.Equal\n\t} else if (!contact1.firstName && !contact1.lastName && !contact2.firstName && !contact2.lastName) {\n\t\treturn IndifferentContactComparisonResult.BothEmpty\n\t} else if ((!contact1.firstName && !contact1.lastName) || (!contact2.firstName && !contact2.lastName)) {\n\t\treturn IndifferentContactComparisonResult.OneEmpty\n\t} else if (\n\t\tcontact1.firstName.toLowerCase() === contact2.firstName.toLowerCase() &&\n\t\tcontact1.lastName.toLowerCase() === contact2.lastName.toLowerCase() &&\n\t\tcontact1.lastName\n\t) {\n\t\treturn ContactComparisonResult.Similar\n\t} else if ((!contact1.firstName || !contact2.firstName) && contact1.lastName.toLowerCase() === contact2.lastName.toLowerCase() && contact1.lastName) {\n\t\treturn ContactComparisonResult.Similar\n\t} else {\n\t\treturn ContactComparisonResult.Unique\n\t}\n}\n\n/**\n * Provides name1 if it is not empty, otherwise name2\n * Export for testing\n */\nexport function _getMergedNameField(name1: string, name2: string): string {\n\tif (name1) {\n\t\treturn name1\n\t} else {\n\t\treturn name2\n\t}\n}\n\n/**\n * If the mail addresses (type is ignored) are all equal (order in array is ignored), the addresses are equal.\n * If at least one mail address is equal and all others are unique, the result is similar. If the mail addresses are equal (only case insensitive), then the result is also similar.\n * If one mail address list is empty, the result is oneEmpty because the mail addresses are not comparable.\n * If both are empty the result is both empty because the mail addresses are not comparable.\n * Otherwise the result is unique.\n * Export for testing\n */\nexport function _compareMailAddresses(\n\tcontact1MailAddresses: ContactMailAddress[],\n\tcontact2MailAddresses: ContactMailAddress[],\n): ContactComparisonResult | IndifferentContactComparisonResult {\n\treturn _compareValues(\n\t\tcontact1MailAddresses.map((m) => m.address),\n\t\tcontact2MailAddresses.map((m) => m.address),\n\t)\n}\n\n/**\n * Export for testing\n */\nexport function _getMergedEmailAddresses(mailAddresses1: ContactMailAddress[], mailAddresses2: ContactMailAddress[]): ContactMailAddress[] {\n\tlet filteredMailAddresses2 = mailAddresses2.filter((ma2) => {\n\t\treturn !mailAddresses1.some((ma1) => ma1.address.toLowerCase() === ma2.address.toLowerCase())\n\t})\n\treturn mailAddresses1.concat(filteredMailAddresses2)\n}\n\n/**\n * Export for testing\n */\nexport function _comparePhoneNumbers(\n\tcontact1PhoneNumbers: ContactPhoneNumber[],\n\tcontact2PhoneNumbers: ContactPhoneNumber[],\n): ContactComparisonResult | IndifferentContactComparisonResult {\n\treturn _compareValues(\n\t\tcontact1PhoneNumbers.map((m) => m.number),\n\t\tcontact2PhoneNumbers.map((m) => m.number),\n\t)\n}\n\n/**\n * Export for testing\n */\nexport function _getMergedPhoneNumbers(phoneNumbers1: ContactPhoneNumber[], phoneNumbers2: ContactPhoneNumber[]): ContactPhoneNumber[] {\n\tlet filteredNumbers2 = phoneNumbers2.filter((ma2) => {\n\t\tconst isIncludedInPhoneNumbers1 = phoneNumbers1.find((ma1) => ma1.number.replace(/\\s/g, \"\") === ma2.number.replace(/\\s/g, \"\"))\n\t\treturn !isIncludedInPhoneNumbers1\n\t})\n\treturn phoneNumbers1.concat(filteredNumbers2)\n}\n\n/**\n * used for clarifying of the unique and equal cases in compareContacts\n * Export for testing\n * returns similar only if socialids ore addresses are similar. Return of similar is basicaly not needed\n */\nexport function _areResidualContactFieldsEqual(contact1: Contact, contact2: Contact): boolean {\n\treturn (\n\t\t_isEqualOtherField(contact1.comment, contact2.comment) &&\n\t\t_isEqualOtherField(contact1.company, contact2.company) &&\n\t\t_isEqualOtherField(contact1.nickname, contact2.nickname) &&\n\t\t_isEqualOtherField(contact1.role, contact2.role) &&\n\t\t_isEqualOtherField(contact1.title, contact2.title) &&\n\t\t_isEqualOtherField(contact1.presharedPassword, contact2.presharedPassword) &&\n\t\t_areSocialIdsEqual(contact1.socialIds, contact2.socialIds) &&\n\t\t_areAddressesEqual(contact1.addresses, contact2.addresses)\n\t)\n}\n\nfunction _areSocialIdsEqual(contact1SocialIds: ContactSocialId[], contact2SocialIds: ContactSocialId[]): boolean {\n\tlet result = _compareValues(\n\t\tcontact1SocialIds.map((m) => m.socialId),\n\t\tcontact2SocialIds.map((m) => m.socialId),\n\t)\n\n\treturn result === IndifferentContactComparisonResult.BothEmpty || result === ContactComparisonResult.Equal\n}\n\n/**\n * Export for testing\n */\nexport function _getMergedSocialIds(socialIds1: ContactSocialId[], socialIds2: ContactSocialId[]): ContactSocialId[] {\n\tlet filteredSocialIds2 = socialIds2.filter((ma2) => {\n\t\treturn !socialIds1.some((ma1) => ma1.socialId === ma2.socialId)\n\t})\n\treturn socialIds1.concat(filteredSocialIds2)\n}\n\nfunction _areAddressesEqual(contact1Addresses: ContactAddress[], contact2Addresses: ContactAddress[]): boolean {\n\tlet result = _compareValues(\n\t\tcontact1Addresses.map((m) => m.address),\n\t\tcontact2Addresses.map((m) => m.address),\n\t)\n\n\treturn result === IndifferentContactComparisonResult.BothEmpty || result === ContactComparisonResult.Equal\n}\n\n/**\n * Export for testing\n */\nexport function _getMergedAddresses(addresses1: ContactAddress[], addresses2: ContactAddress[]): ContactAddress[] {\n\tlet filteredAddresses2 = addresses2.filter((ma2) => {\n\t\treturn !addresses1.some((ma1) => ma1.address === ma2.address)\n\t})\n\treturn addresses1.concat(filteredAddresses2)\n}\n\n/**\n * Export for testing\n */\nexport function _compareBirthdays(contact1: Contact, contact2: Contact): ContactComparisonResult | IndifferentContactComparisonResult {\n\tconst b1 = _convertIsoBirthday(contact1.birthdayIso)\n\n\tconst b2 = _convertIsoBirthday(contact2.birthdayIso)\n\n\tif (b1 && b2) {\n\t\tif (b1.day === b2.day && b1.month === b2.month) {\n\t\t\tif (b1.year === b2.year) {\n\t\t\t\treturn ContactComparisonResult.Equal\n\t\t\t} else if (b1.year && b2.year && b1.year !== b2.year) {\n\t\t\t\t// if we detect that one birthday has more information (year) we use that date\n\t\t\t\treturn ContactComparisonResult.Unique\n\t\t\t} else {\n\t\t\t\treturn ContactComparisonResult.Similar\n\t\t\t}\n\t\t} else {\n\t\t\treturn ContactComparisonResult.Unique\n\t\t}\n\t} else if ((contact1.birthdayIso && !contact2.birthdayIso) || (!contact1.birthdayIso && contact2.birthdayIso)) {\n\t\treturn IndifferentContactComparisonResult.OneEmpty\n\t} else {\n\t\treturn IndifferentContactComparisonResult.BothEmpty\n\t}\n}\n\nfunction _convertIsoBirthday(isoBirthday: string | null): Birthday | null {\n\tif (isoBirthday) {\n\t\ttry {\n\t\t\treturn isoDateToBirthday(isoBirthday)\n\t\t} catch (e) {\n\t\t\tconsole.log(\"failed to parse birthday\", e)\n\t\t\treturn null\n\t\t}\n\t} else {\n\t\treturn null\n\t}\n}\n\nfunction _compareValues(values1: string[], values2: string[]): ContactComparisonResult | IndifferentContactComparisonResult {\n\tif (values1.length === 0 && values2.length === 0) {\n\t\treturn IndifferentContactComparisonResult.BothEmpty\n\t} else if (values1.length === 0 || values2.length === 0) {\n\t\treturn IndifferentContactComparisonResult.OneEmpty\n\t}\n\n\tlet equalAddresses = values2.filter((c2) => values1.find((c1) => c1.trim() === c2.trim()))\n\n\tif (values1.length === values2.length && values1.length === equalAddresses.length) {\n\t\treturn ContactComparisonResult.Equal\n\t}\n\n\tlet equalAddressesInsensitive = values2.filter((c2) => values1.find((c1) => c1.trim().toLowerCase() === c2.trim().toLowerCase()))\n\n\tif (equalAddressesInsensitive.length > 0) {\n\t\treturn ContactComparisonResult.Similar\n\t}\n\n\treturn ContactComparisonResult.Unique\n}\n\n/**\n * Returns equal if both values are equal and unique otherwise\n */\nfunction _isEqualOtherField(otherAttribute1: string | null, otherAttribute2: string | null): boolean {\n\t// regard null as \"\"\n\tif (otherAttribute1 == null) {\n\t\totherAttribute1 = \"\"\n\t}\n\n\tif (otherAttribute2 == null) {\n\t\totherAttribute2 = \"\"\n\t}\n\n\treturn otherAttribute1 === otherAttribute2\n}\n\n/**\n * Provides the value that exists or both separated by the given separator if both have some content\n * Export for testing\n */\nexport function _getMergedOtherField(otherAttribute1: string | null, otherAttribute2: string | null, separator: string): string | null {\n\tif (otherAttribute1 === otherAttribute2) {\n\t\treturn otherAttribute2\n\t} else if (otherAttribute1 && otherAttribute2) {\n\t\treturn otherAttribute1 + separator + otherAttribute2\n\t} else if (!otherAttribute1 && otherAttribute2) {\n\t\treturn otherAttribute2\n\t} else {\n\t\treturn otherAttribute1\n\t}\n}\n\n/**\n * Export for testing\n */\nexport function _getMergedBirthdays(birthday1: string | null, birthday2: string | null): string | null {\n\tconst b1 = _convertIsoBirthday(birthday1)\n\n\tconst b2 = _convertIsoBirthday(birthday2)\n\n\tif (b1 && b2) {\n\t\tif (b1.year) {\n\t\t\treturn birthday1\n\t\t} else if (b2.year) {\n\t\t\treturn birthday2\n\t\t} else {\n\t\t\treturn birthday1\n\t\t}\n\t} else if (birthday1) {\n\t\treturn birthday1\n\t} else if (birthday2) {\n\t\treturn birthday2\n\t} else {\n\t\treturn null\n\t}\n}\n"]}