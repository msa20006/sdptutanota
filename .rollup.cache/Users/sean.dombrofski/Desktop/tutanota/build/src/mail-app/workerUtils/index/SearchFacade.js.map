{"version":3,"file":"SearchFacade.js","sourceRoot":"","sources":["../../../../../src/mail-app/workerUtils/index/SearchFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import { MailTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { DbTransaction } from \"../../../common/api/worker/search/DbFacade.js\"\nimport { resolveTypeReference } from \"../../../common/api/common/EntityFunctions.js\"\nimport {\n\tarrayHash,\n\tasyncFind,\n\tcontains,\n\tdowncast,\n\tgetDayShifted,\n\tgetStartOfDay,\n\tisEmpty,\n\tisNotNull,\n\tisSameTypeRef,\n\tneverNull,\n\tofClass,\n\tpromiseMap,\n\tpromiseMapCompat,\n\tPromiseMapFn,\n\ttokenize,\n\tTypeRef,\n\tuint8ArrayToBase64,\n} from \"@tutao/tutanota-utils\"\nimport type {\n\tDb,\n\tDecryptedSearchIndexEntry,\n\tElementDataDbRow,\n\tEncryptedSearchIndexEntry,\n\tEncryptedSearchIndexEntryWithHash,\n\tKeyToEncryptedIndexEntries,\n\tKeyToIndexEntries,\n\tMoreResultsIndexEntry,\n\tSearchIndexEntry,\n\tSearchIndexMetaDataDbRow,\n\tSearchIndexMetadataEntry,\n\tSearchIndexMetaDataRow,\n\tSearchRestriction,\n\tSearchResult,\n} from \"../../../common/api/worker/search/SearchTypes.js\"\nimport type { TypeInfo } from \"../../../common/api/worker/search/IndexUtils.js\"\nimport {\n\tdecryptMetaData,\n\tdecryptSearchIndexEntry,\n\tencryptIndexKeyBase64,\n\tgetIdFromEncSearchIndexEntry,\n\tgetPerformanceTimestamp,\n\tmarkEnd,\n\tmarkStart,\n\tprintMeasure,\n\ttypeRefToTypeInfo,\n} from \"../../../common/api/worker/search/IndexUtils.js\"\nimport { FULL_INDEXED_TIMESTAMP, NOTHING_INDEXED_TIMESTAMP } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { compareNewestFirst, elementIdPart, firstBiggerThanSecond, timestampToGeneratedId } from \"../../../common/api/common/utils/EntityUtils.js\"\nimport { INITIAL_MAIL_INDEX_INTERVAL_DAYS, MailIndexer } from \"./MailIndexer.js\"\nimport { SuggestionFacade } from \"./SuggestionFacade.js\"\nimport { AssociationType, Cardinality, ValueType } from \"../../../common/api/common/EntityConstants.js\"\nimport { NotAuthorizedError, NotFoundError } from \"../../../common/api/common/error/RestError.js\"\nimport { iterateBinaryBlocks } from \"../../../common/api/worker/search/SearchIndexEncoding.js\"\nimport type { BrowserData } from \"../../../common/misc/ClientConstants.js\"\nimport type { TypeModel } from \"../../../common/api/common/EntityTypes.js\"\nimport { EntityClient } from \"../../../common/api/common/EntityClient.js\"\nimport { UserFacade } from \"../../../common/api/worker/facades/UserFacade.js\"\nimport { ElementDataOS, SearchIndexMetaDataOS, SearchIndexOS, SearchIndexWordsIndex } from \"../../../common/api/worker/search/IndexTables.js\"\n\ntype RowsToReadForIndexKey = {\n\tindexKey: string\n\trows: Array<SearchIndexMetadataEntry>\n}\n\nexport class SearchFacade {\n\t_db: Db\n\t_mailIndexer: MailIndexer\n\t_suggestionFacades: SuggestionFacade<any>[]\n\t_promiseMapCompat: PromiseMapFn\n\t_entityClient: EntityClient\n\n\tconstructor(\n\t\tprivate readonly userFacade: UserFacade,\n\t\tdb: Db,\n\t\tmailIndexer: MailIndexer,\n\t\tsuggestionFacades: SuggestionFacade<any>[],\n\t\tbrowserData: BrowserData,\n\t\tentityClient: EntityClient,\n\t) {\n\t\tthis._db = db\n\t\tthis._mailIndexer = mailIndexer\n\t\tthis._suggestionFacades = suggestionFacades\n\t\tthis._promiseMapCompat = promiseMapCompat(browserData.needsMicrotaskHack)\n\t\tthis._entityClient = entityClient\n\t}\n\n\t/****************************** SEARCH ******************************/\n\n\t/**\n\t * Invoke an AND-query.\n\t * @param query is tokenized. All tokens must be matched by the result (AND-query)\n\t * @param minSuggestionCount If minSuggestionCount > 0 regards the last query token as suggestion token and includes suggestion results for that token, but not less than minSuggestionCount\n\t * @returns The result ids are sorted by id from newest to oldest\n\t */\n\tsearch(query: string, restriction: SearchRestriction, minSuggestionCount: number, maxResults?: number): Promise<SearchResult> {\n\t\treturn this._db.initialized.then(() => {\n\t\t\tlet searchTokens = tokenize(query)\n\t\t\tlet result: SearchResult = {\n\t\t\t\tquery,\n\t\t\t\trestriction,\n\t\t\t\tresults: [],\n\t\t\t\tcurrentIndexTimestamp: this._getSearchEndTimestamp(restriction),\n\t\t\t\tlastReadSearchIndexRow: searchTokens.map((token) => [token, null]),\n\t\t\t\tmatchWordOrder: searchTokens.length > 1 && query.startsWith('\"') && query.endsWith('\"'),\n\t\t\t\tmoreResults: [],\n\t\t\t\tmoreResultsEntries: [],\n\t\t\t}\n\n\t\t\tif (searchTokens.length > 0) {\n\t\t\t\tlet isFirstWordSearch = searchTokens.length === 1\n\t\t\t\tlet before = getPerformanceTimestamp()\n\n\t\t\t\tlet suggestionFacade = this._suggestionFacades.find((f) => isSameTypeRef(f.type, restriction.type))\n\n\t\t\t\tlet searchPromise\n\n\t\t\t\tif (minSuggestionCount > 0 && isFirstWordSearch && suggestionFacade) {\n\t\t\t\t\tlet addSuggestionBefore = getPerformanceTimestamp()\n\t\t\t\t\tsearchPromise = this._addSuggestions(searchTokens[0], suggestionFacade, minSuggestionCount, result).then(() => {\n\t\t\t\t\t\tif (result.results.length < minSuggestionCount) {\n\t\t\t\t\t\t\t// there may be fields that are not indexed with suggestions but which we can find with the normal search\n\t\t\t\t\t\t\t// TODO: let suggestion facade and search facade know which fields are\n\t\t\t\t\t\t\t// indexed with suggestions, so that we\n\t\t\t\t\t\t\t// 1) know if we also have to search normally and\n\t\t\t\t\t\t\t// 2) in which fields we have to search for second word suggestions because now we would also find words of non-suggestion fields as second words\n\t\t\t\t\t\t\tlet searchForTokensAfterSuggestionsBefore = getPerformanceTimestamp()\n\t\t\t\t\t\t\treturn this._startOrContinueSearch(result).then((result) => {\n\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t} else if (minSuggestionCount > 0 && !isFirstWordSearch && suggestionFacade) {\n\t\t\t\t\tlet suggestionToken = neverNull(result.lastReadSearchIndexRow.pop())[0]\n\t\t\t\t\tsearchPromise = this._startOrContinueSearch(result).then(() => {\n\t\t\t\t\t\t// we now filter for the suggestion token manually because searching for suggestions for the last word and reducing the initial search result with them can lead to\n\t\t\t\t\t\t// dozens of searches without any effect when the seach token is found in too many contacts, e.g. in the email address with the ending \"de\"\n\t\t\t\t\t\tresult.results.sort(compareNewestFirst)\n\t\t\t\t\t\treturn this._loadAndReduce(restriction, result, suggestionToken, minSuggestionCount)\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tsearchPromise = this._startOrContinueSearch(result, maxResults)\n\t\t\t\t}\n\n\t\t\t\treturn searchPromise.then(() => {\n\t\t\t\t\tresult.results.sort(compareNewestFirst)\n\t\t\t\t\treturn result\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve(result)\n\t\t\t}\n\t\t})\n\t}\n\n\tasync _loadAndReduce(restriction: SearchRestriction, result: SearchResult, suggestionToken: string, minSuggestionCount: number): Promise<void> {\n\t\tif (result.results.length > 0) {\n\t\t\tconst model = await resolveTypeReference(restriction.type)\n\t\t\t// if we want the exact search order we try to find the complete sequence of words in an attribute of the instance.\n\t\t\t// for other cases we only check that an attribute contains a word that starts with suggestion word\n\t\t\tconst suggestionQuery = result.matchWordOrder ? normalizeQuery(result.query) : suggestionToken\n\t\t\tconst finalResults: IdTuple[] = []\n\n\t\t\tfor (const id of result.results) {\n\t\t\t\tif (finalResults.length >= minSuggestionCount) {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tlet entity\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tentity = await this._entityClient.load(restriction.type, id)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e instanceof NotFoundError || e instanceof NotAuthorizedError) {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst found = await this._containsSuggestionToken(entity, model, restriction.attributeIds, suggestionQuery, result.matchWordOrder)\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tfinalResults.push(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.results = finalResults\n\t\t} else {\n\t\t\treturn Promise.resolve()\n\t\t}\n\t}\n\n\t/**\n\t * Looks for a word in any of the entities string values or aggregations string values that starts with suggestionToken.\n\t * @param attributeIds Only looks in these attribute ids (or all its string values if it is an aggregation attribute id. If null, looks in all string values and aggregations.\n\t */\n\t_containsSuggestionToken(\n\t\tentity: Record<string, any>,\n\t\tmodel: TypeModel,\n\t\tattributeIds: number[] | null,\n\t\tsuggestionToken: string,\n\t\tmatchWordOrder: boolean,\n\t): Promise<boolean> {\n\t\tlet attributeNames: string[]\n\n\t\tif (!attributeIds) {\n\t\t\tattributeNames = Object.keys(model.values).concat(Object.keys(model.associations))\n\t\t} else {\n\t\t\tattributeNames = attributeIds.map((id) =>\n\t\t\t\tneverNull(\n\t\t\t\t\tObject.keys(model.values).find((valueName) => model.values[valueName].id === id) ||\n\t\t\t\t\t\tObject.keys(model.associations).find((associationName) => model.associations[associationName].id === id),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\treturn asyncFind(attributeNames, async (attributeName) => {\n\t\t\tif (model.values[attributeName] && model.values[attributeName].type === ValueType.String && entity[attributeName]) {\n\t\t\t\tif (matchWordOrder) {\n\t\t\t\t\treturn Promise.resolve(normalizeQuery(entity[attributeName]).indexOf(suggestionToken) !== -1)\n\t\t\t\t} else {\n\t\t\t\t\tlet words = tokenize(entity[attributeName])\n\t\t\t\t\treturn Promise.resolve(words.some((w) => w.startsWith(suggestionToken)))\n\t\t\t\t}\n\t\t\t} else if (model.associations[attributeName] && model.associations[attributeName].type === AssociationType.Aggregation && entity[attributeName]) {\n\t\t\t\tlet aggregates = model.associations[attributeName].cardinality === Cardinality.Any ? entity[attributeName] : [entity[attributeName]]\n\t\t\t\tconst refModel = await resolveTypeReference(new TypeRef(model.app, model.associations[attributeName].refType))\n\t\t\t\treturn asyncFind(aggregates, (aggregate) => {\n\t\t\t\t\treturn this._containsSuggestionToken(downcast<Record<string, any>>(aggregate), refModel, null, suggestionToken, matchWordOrder)\n\t\t\t\t}).then((found) => found != null)\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve(false)\n\t\t\t}\n\t\t}).then((found) => found != null)\n\t}\n\n\t_startOrContinueSearch(searchResult: SearchResult, maxResults?: number): Promise<void> {\n\t\tmarkStart(\"findIndexEntries\")\n\n\t\tconst nextScheduledIndexingRun = getStartOfDay(getDayShifted(new Date(this._mailIndexer.currentIndexTimestamp), INITIAL_MAIL_INDEX_INTERVAL_DAYS))\n\t\tconst theDayAfterTomorrow = getStartOfDay(getDayShifted(new Date(), 1))\n\n\t\tif (searchResult.moreResults.length === 0 && nextScheduledIndexingRun.getTime() > theDayAfterTomorrow.getTime() && !this._mailIndexer.isIndexing) {\n\t\t\tthis._mailIndexer.extendIndexIfNeeded(\n\t\t\t\tthis.userFacade.getLoggedInUser(),\n\t\t\t\tgetStartOfDay(getDayShifted(new Date(), -INITIAL_MAIL_INDEX_INTERVAL_DAYS)).getTime(),\n\t\t\t)\n\t\t}\n\n\t\tlet moreResultsEntries: Promise<Array<MoreResultsIndexEntry>>\n\n\t\tif (maxResults && searchResult.moreResults.length >= maxResults) {\n\t\t\tmoreResultsEntries = Promise.resolve(searchResult.moreResults)\n\t\t} else {\n\t\t\tmoreResultsEntries = this._findIndexEntries(searchResult, maxResults)\n\t\t\t\t.then((keyToEncryptedIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"findIndexEntries\")\n\t\t\t\t\tmarkStart(\"_filterByEncryptedId\")\n\t\t\t\t\treturn this._filterByEncryptedId(keyToEncryptedIndexEntries)\n\t\t\t\t})\n\t\t\t\t.then((keyToEncryptedIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_filterByEncryptedId\")\n\t\t\t\t\tmarkStart(\"_decryptSearchResult\")\n\t\t\t\t\treturn this._decryptSearchResult(keyToEncryptedIndexEntries)\n\t\t\t\t})\n\t\t\t\t.then((keyToIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_decryptSearchResult\")\n\t\t\t\t\tmarkStart(\"_filterByTypeAndAttributeAndTime\")\n\t\t\t\t\treturn this._filterByTypeAndAttributeAndTime(keyToIndexEntries, searchResult.restriction)\n\t\t\t\t})\n\t\t\t\t.then((keyToIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_filterByTypeAndAttributeAndTime\")\n\t\t\t\t\tmarkStart(\"_reduceWords\")\n\t\t\t\t\treturn this._reduceWords(keyToIndexEntries, searchResult.matchWordOrder)\n\t\t\t\t})\n\t\t\t\t.then((searchIndexEntries) => {\n\t\t\t\t\tmarkEnd(\"_reduceWords\")\n\t\t\t\t\tmarkStart(\"_reduceToUniqueElementIds\")\n\t\t\t\t\treturn this._reduceToUniqueElementIds(searchIndexEntries, searchResult)\n\t\t\t\t})\n\t\t\t\t.then((additionalEntries) => {\n\t\t\t\t\tmarkEnd(\"_reduceToUniqueElementIds\")\n\t\t\t\t\treturn additionalEntries.concat(searchResult.moreResults)\n\t\t\t\t})\n\t\t}\n\n\t\treturn moreResultsEntries\n\t\t\t.then((searchIndexEntries: MoreResultsIndexEntry[]) => {\n\t\t\t\tmarkStart(\"_filterByListIdAndGroupSearchResults\")\n\t\t\t\treturn this._filterByListIdAndGroupSearchResults(searchIndexEntries, searchResult, maxResults)\n\t\t\t})\n\t\t\t.then((result) => {\n\t\t\t\tmarkEnd(\"_filterByListIdAndGroupSearchResults\")\n\t\t\t\tif (typeof self !== \"undefined\") {\n\t\t\t\t\tprintMeasure(\"query: \" + searchResult.query + \", maxResults: \" + String(maxResults), [\n\t\t\t\t\t\t\"findIndexEntries\",\n\t\t\t\t\t\t\"_filterByEncryptedId\",\n\t\t\t\t\t\t\"_decryptSearchResult\",\n\t\t\t\t\t\t\"_filterByTypeAndAttributeAndTime\",\n\t\t\t\t\t\t\"_reduceWords\",\n\t\t\t\t\t\t\"_reduceToUniqueElementIds\",\n\t\t\t\t\t\t\"_filterByListIdAndGroupSearchResults\",\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t})\n\t}\n\n\t/**\n\t * Adds suggestions for the given searchToken to the searchResult until at least minSuggestionCount results are existing\n\t */\n\t_addSuggestions(searchToken: string, suggestionFacade: SuggestionFacade<any>, minSuggestionCount: number, searchResult: SearchResult): Promise<any> {\n\t\tlet suggestions = suggestionFacade.getSuggestions(searchToken)\n\t\treturn promiseMap(suggestions, (suggestion) => {\n\t\t\tif (searchResult.results.length < minSuggestionCount) {\n\t\t\t\tconst suggestionResult: SearchResult = {\n\t\t\t\t\tquery: suggestion,\n\t\t\t\t\trestriction: searchResult.restriction,\n\t\t\t\t\tresults: searchResult.results,\n\t\t\t\t\tcurrentIndexTimestamp: searchResult.currentIndexTimestamp,\n\t\t\t\t\tlastReadSearchIndexRow: [[suggestion, null]],\n\t\t\t\t\tmatchWordOrder: false,\n\t\t\t\t\tmoreResults: [],\n\t\t\t\t\tmoreResultsEntries: [],\n\t\t\t\t}\n\t\t\t\treturn this._startOrContinueSearch(suggestionResult)\n\t\t\t}\n\t\t})\n\t}\n\n\t_findIndexEntries(searchResult: SearchResult, maxResults: number | null | undefined): Promise<KeyToEncryptedIndexEntries[]> {\n\t\tconst typeInfo = typeRefToTypeInfo(searchResult.restriction.type)\n\t\tconst firstSearchTokenInfo = searchResult.lastReadSearchIndexRow[0]\n\t\t// First read all metadata to narrow time range we search in.\n\t\treturn this._db.dbFacade.createTransaction(true, [SearchIndexOS, SearchIndexMetaDataOS]).then((transaction) => {\n\t\t\treturn this._promiseMapCompat(searchResult.lastReadSearchIndexRow, (tokenInfo, index) => {\n\t\t\t\tconst [searchToken] = tokenInfo\n\t\t\t\tlet indexKey = encryptIndexKeyBase64(this._db.key, searchToken, this._db.iv)\n\t\t\t\treturn transaction.get(SearchIndexMetaDataOS, indexKey, SearchIndexWordsIndex).then((metaData: SearchIndexMetaDataDbRow | null) => {\n\t\t\t\t\tif (!metaData) {\n\t\t\t\t\t\ttokenInfo[1] = 0 // \"we've read all\" (because we don't have anything\n\n\t\t\t\t\t\t// If there's no metadata for key, return empty result\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid: -index,\n\t\t\t\t\t\t\tword: indexKey,\n\t\t\t\t\t\t\trows: [],\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn decryptMetaData(this._db.key, metaData)\n\t\t\t\t})\n\t\t\t})\n\t\t\t\t.thenOrApply((metaRows) => {\n\t\t\t\t\t// Find index entry rows in which we will search.\n\t\t\t\t\tconst rowsToReadForIndexKeys = this._findRowsToReadFromMetaData(firstSearchTokenInfo, metaRows, typeInfo, maxResults)\n\n\t\t\t\t\t// Iterate each query token\n\t\t\t\t\treturn this._promiseMapCompat(rowsToReadForIndexKeys, (rowsToRead: RowsToReadForIndexKey) => {\n\t\t\t\t\t\t// For each token find token entries in the rows we've found\n\t\t\t\t\t\treturn this._promiseMapCompat(rowsToRead.rows, (entry) => this._findEntriesForMetadata(transaction, entry))\n\t\t\t\t\t\t\t.thenOrApply((a) => a.flat())\n\t\t\t\t\t\t\t.thenOrApply((indexEntries: EncryptedSearchIndexEntry[]) => {\n\t\t\t\t\t\t\t\treturn indexEntries.map((entry) => ({\n\t\t\t\t\t\t\t\t\tencEntry: entry,\n\t\t\t\t\t\t\t\t\tidHash: arrayHash(getIdFromEncSearchIndexEntry(entry)),\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.thenOrApply((indexEntries: EncryptedSearchIndexEntryWithHash[]) => {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tindexKey: rowsToRead.indexKey,\n\t\t\t\t\t\t\t\t\tindexEntries: indexEntries,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}).value\n\t\t\t\t\t}).value\n\t\t\t\t})\n\t\t\t\t.toPromise()\n\t\t})\n\t}\n\n\t_findRowsToReadFromMetaData(\n\t\tfirstTokenInfo: [string, number | null],\n\t\tsafeMetaDataRows: Array<SearchIndexMetaDataRow>,\n\t\ttypeInfo: TypeInfo,\n\t\tmaxResults: number | null | undefined,\n\t): Array<RowsToReadForIndexKey> {\n\t\t// \"Leading row\" narrows down time range in which we search in this iteration\n\t\t// Doesn't matter for correctness which one it is (because query is always AND) but matters for performance\n\t\t// For now arbitrarily picked first (usually it's the most specific part anyway)\n\t\tconst leadingRow = safeMetaDataRows[0]\n\t\tconst otherRows = safeMetaDataRows.slice(1)\n\n\t\tconst rangeForLeadingRow = this._findRowsToRead(leadingRow, typeInfo, firstTokenInfo[1] || Number.MAX_SAFE_INTEGER, maxResults)\n\n\t\tconst rowsForLeadingRow = [\n\t\t\t{\n\t\t\t\tindexKey: leadingRow.word,\n\t\t\t\trows: rangeForLeadingRow.metaEntries,\n\t\t\t},\n\t\t]\n\t\tfirstTokenInfo[1] = rangeForLeadingRow.oldestTimestamp\n\t\tconst rowsForOtherRows = otherRows.map((r) => {\n\t\t\treturn {\n\t\t\t\tindexKey: r.word,\n\t\t\t\trows: this._findRowsToReadByTimeRange(r, typeInfo, rangeForLeadingRow.newestRowTimestamp, rangeForLeadingRow.oldestTimestamp),\n\t\t\t}\n\t\t})\n\t\treturn rowsForLeadingRow.concat(rowsForOtherRows)\n\t}\n\n\t_findEntriesForMetadata(transaction: DbTransaction, entry: SearchIndexMetadataEntry): Promise<EncryptedSearchIndexEntry[]> {\n\t\treturn transaction.get(SearchIndexOS, entry.key).then((indexEntriesRow) => {\n\t\t\tif (!indexEntriesRow) return []\n\t\t\tconst result = new Array(entry.size)\n\t\t\titerateBinaryBlocks(indexEntriesRow as Uint8Array, (block, s, e, iteration) => {\n\t\t\t\tresult[iteration] = block\n\t\t\t})\n\t\t\treturn result\n\t\t})\n\t}\n\n\t_findRowsToReadByTimeRange(\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\ttypeInfo: TypeInfo,\n\t\tfromNewestTimestamp: number,\n\t\ttoOldestTimestamp: number,\n\t): Array<SearchIndexMetadataEntry> {\n\t\tconst filteredRows = metaData.rows.filter((r) => r.app === typeInfo.appId && r.type === typeInfo.typeId)\n\t\tfilteredRows.reverse()\n\t\tconst passedRows: SearchIndexMetadataEntry[] = []\n\n\t\tfor (let row of filteredRows) {\n\t\t\tif (row.oldestElementTimestamp < fromNewestTimestamp) {\n\t\t\t\tpassedRows.push(row)\n\n\t\t\t\tif (row.oldestElementTimestamp <= toOldestTimestamp) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn passedRows\n\t}\n\n\t_findRowsToRead(\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\ttypeInfo: TypeInfo,\n\t\tmustBeOlderThan: number,\n\t\tmaxResults: number | null | undefined,\n\t): {\n\t\tmetaEntries: Array<SearchIndexMetadataEntry>\n\t\toldestTimestamp: number\n\t\tnewestRowTimestamp: number\n\t} {\n\t\tconst filteredRows = metaData.rows.filter((r) => r.app === typeInfo.appId && r.type === typeInfo.typeId)\n\t\tfilteredRows.reverse()\n\t\tlet entitiesToRead = 0\n\t\tlet lastReadRowTimestamp = 0\n\t\tlet newestRowTimestamp = Number.MAX_SAFE_INTEGER\n\t\tlet rowsToRead\n\n\t\tif (maxResults) {\n\t\t\trowsToRead = []\n\n\t\t\tfor (let r of filteredRows) {\n\t\t\t\tif (r.oldestElementTimestamp < mustBeOlderThan) {\n\t\t\t\t\tif (entitiesToRead < 1000) {\n\t\t\t\t\t\tentitiesToRead += r.size\n\t\t\t\t\t\tlastReadRowTimestamp = r.oldestElementTimestamp\n\t\t\t\t\t\trowsToRead.push(r)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewestRowTimestamp = r.oldestElementTimestamp\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trowsToRead = filteredRows\n\t\t}\n\n\t\treturn {\n\t\t\tmetaEntries: rowsToRead,\n\t\t\toldestTimestamp: lastReadRowTimestamp,\n\t\t\tnewestRowTimestamp: newestRowTimestamp,\n\t\t}\n\t}\n\n\t/**\n\t * Reduces the search result by filtering out all mailIds that don't match all search tokens\n\t */\n\t_filterByEncryptedId(results: KeyToEncryptedIndexEntries[]): KeyToEncryptedIndexEntries[] {\n\t\tlet matchingEncIds: Set<number> | null = null\n\t\tfor (const keyToEncryptedIndexEntry of results) {\n\t\t\tif (matchingEncIds == null) {\n\t\t\t\tmatchingEncIds = new Set(keyToEncryptedIndexEntry.indexEntries.map((entry) => entry.idHash))\n\t\t\t} else {\n\t\t\t\tconst filtered = new Set<number>()\n\t\t\t\tfor (const indexEntry of keyToEncryptedIndexEntry.indexEntries) {\n\t\t\t\t\tif (matchingEncIds.has(indexEntry.idHash)) {\n\t\t\t\t\t\tfiltered.add(indexEntry.idHash)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatchingEncIds = filtered\n\t\t\t}\n\t\t}\n\t\treturn results.map((r) => {\n\t\t\treturn {\n\t\t\t\tindexKey: r.indexKey,\n\t\t\t\tindexEntries: r.indexEntries.filter((entry) => matchingEncIds?.has(entry.idHash)),\n\t\t\t}\n\t\t})\n\t}\n\n\t_decryptSearchResult(results: KeyToEncryptedIndexEntries[]): KeyToIndexEntries[] {\n\t\treturn results.map((searchResult) => {\n\t\t\treturn {\n\t\t\t\tindexKey: searchResult.indexKey,\n\t\t\t\tindexEntries: searchResult.indexEntries.map((entry) => decryptSearchIndexEntry(this._db.key, entry.encEntry, this._db.iv)),\n\t\t\t}\n\t\t})\n\t}\n\n\t_filterByTypeAndAttributeAndTime(results: KeyToIndexEntries[], restriction: SearchRestriction): KeyToIndexEntries[] {\n\t\t// first filter each index entry by itself\n\t\tlet endTimestamp = this._getSearchEndTimestamp(restriction)\n\n\t\tconst minIncludedId = timestampToGeneratedId(endTimestamp)\n\t\tconst maxExcludedId = restriction.start ? timestampToGeneratedId(restriction.start + 1) : null\n\t\tfor (const result of results) {\n\t\t\tresult.indexEntries = result.indexEntries.filter((entry) => {\n\t\t\t\treturn this._isValidAttributeAndTime(restriction, entry, minIncludedId, maxExcludedId)\n\t\t\t})\n\t\t}\n\t\t// now filter all ids that are in all of the search words\n\t\tlet matchingIds: Set<Id> | null = null\n\t\tfor (const keyToIndexEntry of results) {\n\t\t\tif (!matchingIds) {\n\t\t\t\tmatchingIds = new Set(keyToIndexEntry.indexEntries.map((entry) => entry.id))\n\t\t\t} else {\n\t\t\t\tlet filtered = new Set<Id>()\n\t\t\t\tfor (const entry of keyToIndexEntry.indexEntries) {\n\t\t\t\t\tif (matchingIds.has(entry.id)) {\n\t\t\t\t\t\tfiltered.add(entry.id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatchingIds = filtered\n\t\t\t}\n\t\t}\n\t\treturn results.map((r) => {\n\t\t\treturn {\n\t\t\t\tindexKey: r.indexKey,\n\t\t\t\tindexEntries: r.indexEntries.filter((entry) => matchingIds?.has(entry.id)),\n\t\t\t}\n\t\t})\n\t}\n\n\t_isValidAttributeAndTime(restriction: SearchRestriction, entry: SearchIndexEntry, minIncludedId: Id, maxExcludedId: Id | null): boolean {\n\t\tif (restriction.attributeIds) {\n\t\t\tif (!contains(restriction.attributeIds, entry.attribute)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tif (maxExcludedId) {\n\t\t\t// timestampToGeneratedId provides the lowest id with the given timestamp (server id and counter set to 0),\n\t\t\t// so we add one millisecond to make sure all ids of the timestamp are covered\n\t\t\tif (!firstBiggerThanSecond(maxExcludedId, entry.id)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn !firstBiggerThanSecond(minIncludedId, entry.id)\n\t}\n\n\t_reduceWords(results: KeyToIndexEntries[], matchWordOrder: boolean): ReadonlyArray<DecryptedSearchIndexEntry> {\n\t\tif (matchWordOrder) {\n\t\t\treturn results[0].indexEntries.filter((firstWordEntry) => {\n\t\t\t\t// reduce the filtered positions for this first word entry and its attribute with each next word to those that are in order\n\t\t\t\tlet filteredPositions = firstWordEntry.positions.slice()\n\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tlet entry = results[i].indexEntries.find((e) => e.id === firstWordEntry.id && e.attribute === firstWordEntry.attribute)\n\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\tfilteredPositions = filteredPositions.filter((firstWordPosition) =>\n\t\t\t\t\t\t\tneverNull(entry).positions.find((position) => position === firstWordPosition + i),\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the id was probably not found for the same attribute as the current filtered positions, so we could not find all words in order in the same attribute\n\t\t\t\t\t\tfilteredPositions = []\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn filteredPositions.length > 0\n\t\t\t})\n\t\t} else {\n\t\t\t// all ids must appear in all words now, so we can use any of the entries lists\n\t\t\treturn results[0].indexEntries\n\t\t}\n\t}\n\n\t_reduceToUniqueElementIds(results: ReadonlyArray<DecryptedSearchIndexEntry>, previousResult: SearchResult): ReadonlyArray<MoreResultsIndexEntry> {\n\t\tconst uniqueIds = new Set<string>()\n\t\treturn results.filter((entry) => {\n\t\t\tif (!uniqueIds.has(entry.id) && !previousResult.results.some((r) => r[1] === entry.id)) {\n\t\t\t\tuniqueIds.add(entry.id)\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t})\n\t}\n\n\t_filterByListIdAndGroupSearchResults(\n\t\tindexEntries: Array<MoreResultsIndexEntry>,\n\t\tsearchResult: SearchResult,\n\t\tmaxResults: number | null | undefined,\n\t): Promise<void> {\n\t\tindexEntries.sort((l, r) => compareNewestFirst(l.id, r.id))\n\t\t// We filter out everything we've processed from moreEntries, even if we didn't include it\n\t\t// downcast: Array of optional elements in not subtype of non-optional elements\n\t\tconst entriesCopy: Array<MoreResultsIndexEntry | null> = downcast(indexEntries.slice())\n\t\t// Results are added in the random order and we may filter some of them out. We need to sort them.\n\t\t// Use separate array to only sort new results and not all of them.\n\t\treturn this._db.dbFacade\n\t\t\t.createTransaction(true, [ElementDataOS])\n\t\t\t.then((transaction) =>\n\t\t\t\t// As an attempt to optimize search we look for items in parallel. Promise.map iterates in arbitrary order!\n\t\t\t\t// BUT! we have to look at all of them! Otherwise, we may return them in the wrong order.\n\t\t\t\t// We cannot return elements 10, 15, 20 if we didn't return element 5 first, no one will ask for it later.\n\t\t\t\t// The best thing performance-wise would be to split into chunks of certain length and process them in parallel and stop after certain chunk.\n\t\t\t\tpromiseMap(\n\t\t\t\t\tindexEntries.slice(0, maxResults || indexEntries.length + 1),\n\t\t\t\t\tasync (entry, index) => {\n\t\t\t\t\t\treturn transaction.get(ElementDataOS, uint8ArrayToBase64(entry.encId)).then((elementData: ElementDataDbRow | null) => {\n\t\t\t\t\t\t\t// mark result index id as processed to not query result in next load more operation\n\t\t\t\t\t\t\tentriesCopy[index] = null\n\n\t\t\t\t\t\t\tif (elementData) {\n\t\t\t\t\t\t\t\treturn [elementData[0], entry.id] as IdTuple\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tconcurrency: 5,\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t)\n\t\t\t.then((intermediateResults) => intermediateResults.filter(isNotNull))\n\t\t\t.then(async (intermediateResults) => {\n\t\t\t\t// apply folder restrictions to intermediateResults\n\n\t\t\t\tif (isEmpty(searchResult.restriction.folderIds)) {\n\t\t\t\t\t// no folder restrictions (ALL)\n\t\t\t\t\treturn intermediateResults\n\t\t\t\t} else {\n\t\t\t\t\t// some folder restrictions (e.g. INBOX)\n\n\t\t\t\t\t// With the new mailSet architecture (static mail lists) we need to load every mail\n\t\t\t\t\t// in order to check in which mailSet (folder) a mail is included in.\n\t\t\t\t\tconst mails = await Promise.all(\n\t\t\t\t\t\tintermediateResults.map((intermediateResultId) =>\n\t\t\t\t\t\t\tthis._entityClient.load(MailTypeRef, intermediateResultId).catch(\n\t\t\t\t\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\t\t\t\t\tconsole.log(`Could not find updated mail ${JSON.stringify(intermediateResultId)}`)\n\t\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t\treturn mails\n\t\t\t\t\t\t.filter(isNotNull)\n\t\t\t\t\t\t.filter((mail) => {\n\t\t\t\t\t\t\tlet folderIds: Array<Id> = mail.sets.map((setId) => elementIdPart(setId))\n\t\t\t\t\t\t\treturn folderIds.some((folderId) => searchResult.restriction.folderIds.includes(folderId))\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.map((mail) => mail._id)\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then((newResults) => {\n\t\t\t\tsearchResult.results.push(...(newResults as IdTuple[]))\n\t\t\t\tsearchResult.moreResults = entriesCopy.filter(isNotNull)\n\t\t\t})\n\t}\n\n\tasync getMoreSearchResults(searchResult: SearchResult, moreResultCount: number): Promise<SearchResult> {\n\t\tawait this._startOrContinueSearch(searchResult, moreResultCount)\n\t\treturn searchResult\n\t}\n\n\t_getSearchEndTimestamp(restriction: SearchRestriction): number {\n\t\tif (restriction.end) {\n\t\t\treturn restriction.end\n\t\t} else if (isSameTypeRef(MailTypeRef, restriction.type)) {\n\t\t\treturn this._mailIndexer.currentIndexTimestamp === NOTHING_INDEXED_TIMESTAMP ? Date.now() : this._mailIndexer.currentIndexTimestamp\n\t\t} else {\n\t\t\treturn FULL_INDEXED_TIMESTAMP\n\t\t}\n\t}\n}\n\nfunction normalizeQuery(query: string): string {\n\treturn tokenize(query).join(\" \")\n}\n"]}