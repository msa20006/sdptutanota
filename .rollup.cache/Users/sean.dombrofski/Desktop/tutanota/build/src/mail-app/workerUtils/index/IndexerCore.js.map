{"version":3,"file":"IndexerCore.js","sourceRoot":"","sources":["../../../../../src/mail-app/workerUtils/index/IndexerCore.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DbTransaction } from \"../../../common/api/worker/search/DbFacade.js\"\nimport type { $Promisable, DeferredObject, PromiseMapFn } from \"@tutao/tutanota-utils\"\nimport {\n\tarrayHash,\n\tbyteLength,\n\tdefer,\n\tfindLastIndex,\n\tgetFromMap,\n\tgroupByAndMap,\n\tlastThrow,\n\tmergeMaps,\n\tneverNull,\n\tnoOp,\n\tPromisableWrapper,\n\tpromiseMapCompat,\n\ttokenize,\n\tTypeRef,\n\tuint8ArrayToBase64,\n} from \"@tutao/tutanota-utils\"\nimport { elementIdPart, firstBiggerThanSecond, generatedIdToTimestamp, listIdPart } from \"../../../common/api/common/utils/EntityUtils.js\"\nimport {\n\tcompareMetaEntriesOldest,\n\tdecryptIndexKey,\n\tdecryptMetaData,\n\tencryptIndexKeyBase64,\n\tencryptIndexKeyUint8Array,\n\tencryptMetaData,\n\tencryptSearchIndexEntry,\n\tgetIdFromEncSearchIndexEntry,\n\tgetPerformanceTimestamp,\n\ttypeRefToTypeInfo,\n} from \"../../../common/api/worker/search/IndexUtils.js\"\nimport type {\n\tAttributeHandler,\n\tB64EncIndexKey,\n\tDb,\n\tEncInstanceIdWithTimestamp,\n\tEncryptedSearchIndexEntry,\n\tEncSearchIndexEntryWithTimestamp,\n\tEncWordToMetaRow,\n\tGroupData,\n\tIndexUpdate,\n\tSearchIndexDbRow,\n\tSearchIndexEntry,\n\tSearchIndexMetaDataDbRow,\n\tSearchIndexMetadataEntry,\n\tSearchIndexMetaDataRow,\n} from \"../../../common/api/worker/search/SearchTypes.js\"\nimport type { QueuedBatch } from \"../../../common/api/worker/EventQueue.js\"\nimport { EventQueue } from \"../../../common/api/worker/EventQueue.js\"\nimport { CancelledError } from \"../../../common/api/common/error/CancelledError.js\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError.js\"\nimport type { BrowserData } from \"../../../common/misc/ClientConstants.js\"\nimport { InvalidDatabaseStateError } from \"../../../common/api/common/error/InvalidDatabaseStateError.js\"\nimport {\n\tappendBinaryBlocks,\n\tcalculateNeededSpaceForNumbers,\n\tdecodeNumbers,\n\tencodeNumbers,\n\titerateBinaryBlocks,\n\tremoveBinaryBlockRanges,\n} from \"../../../common/api/worker/search/SearchIndexEncoding.js\"\nimport type { EntityUpdate } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { aes256EncryptSearchIndexEntry, unauthenticatedAesDecrypt } from \"@tutao/tutanota-crypto\"\nimport {\n\tElementDataOS,\n\tGroupDataOS,\n\tMetaDataOS,\n\tSearchIndexMetaDataOS,\n\tSearchIndexOS,\n\tSearchIndexWordsIndex,\n} from \"../../../common/api/worker/search/IndexTables.js\"\n\nconst SEARCH_INDEX_ROW_LENGTH = 1000\n\n/**\n * Object to store the current indexedDb write operation. In case of background mode on iOS we have to abort the current write\n * and restart the write after app goes to foreground again.\n */\ntype WriteOperation = {\n\ttransaction: DbTransaction | null\n\toperation: (transaction: DbTransaction) => Promise<void>\n\ttransactionFactory: () => Promise<DbTransaction>\n\tdeferred: DeferredObject<void>\n\tisAbortedForBackgroundMode: boolean\n}\n\n/**\n * Class which executes operation on the indexing tables.\n *\n * Some functions return null instead of Promise because\n * IndexedDB transaction usually lives only till the end\n * of the event loop iteration and promise scheduling\n * somehow manages to break that and commit transaction\n * too early.\n */\nexport class IndexerCore {\n\tqueue: EventQueue\n\tdb: Db\n\tprivate _isStopped: boolean\n\tprivate _promiseMapCompat: PromiseMapFn\n\tprivate _needsExplicitIds: boolean\n\tprivate _explicitIdStart: number\n\tprivate _currentWriteOperation: WriteOperation | null = null\n\t_stats!: {\n\t\tindexingTime: number\n\t\tstorageTime: number\n\t\tpreparingTime: number\n\t\tmailcount: number\n\t\tstoredBytes: number\n\t\tencryptionTime: number\n\t\twriteRequests: number\n\t\tlargestColumn: number\n\t\twords: number\n\t\tindexedBytes: number\n\t}\n\n\tconstructor(db: Db, queue: EventQueue, browserData: BrowserData) {\n\t\tthis.queue = queue\n\t\tthis.db = db\n\t\tthis._isStopped = false\n\t\tthis._promiseMapCompat = promiseMapCompat(browserData.needsMicrotaskHack)\n\t\tthis._needsExplicitIds = browserData.needsExplicitIDBIds\n\t\tthis._explicitIdStart = Date.now()\n\t\tthis.resetStats()\n\t}\n\n\t/****************************************** Preparing the update ***********************************************/\n\n\t/**\n\t * Converts an instances into a map from words to a list of SearchIndexEntries.\n\t */\n\tcreateIndexEntriesForAttributes(instance: Record<string, any>, attributes: AttributeHandler[]): Map<string, SearchIndexEntry[]> {\n\t\tlet indexEntries: Map<string, SearchIndexEntry>[] = attributes.map((attributeHandler) => {\n\t\t\tif (typeof attributeHandler.value !== \"function\") {\n\t\t\t\tthrow new ProgrammingError(\"Value for attributeHandler is not a function: \" + JSON.stringify(attributeHandler.attribute))\n\t\t\t}\n\n\t\t\tlet value = attributeHandler.value()\n\t\t\tlet tokens = tokenize(value)\n\t\t\tthis._stats.indexedBytes += byteLength(value)\n\t\t\tlet attributeKeyToIndexMap: Map<string, SearchIndexEntry> = new Map()\n\n\t\t\tfor (let index = 0; index < tokens.length; index++) {\n\t\t\t\tlet token = tokens[index]\n\n\t\t\t\tif (!attributeKeyToIndexMap.has(token)) {\n\t\t\t\t\tattributeKeyToIndexMap.set(token, {\n\t\t\t\t\t\tid: instance._id instanceof Array ? instance._id[1] : instance._id,\n\t\t\t\t\t\tattribute: attributeHandler.attribute.id,\n\t\t\t\t\t\tpositions: [index],\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tneverNull(attributeKeyToIndexMap.get(token)).positions.push(index)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn attributeKeyToIndexMap\n\t\t})\n\t\treturn mergeMaps(indexEntries)\n\t}\n\n\t/**\n\t * Encrypt search index entries created by {@link createIndexEntriesForAttributes} and put them into the {@param indexUpdate}.\n\t * @param id of the instance\n\t * @param ownerGroup of the instance\n\t * @param keyToIndexEntries map from search index keys (words which you can search for) to index entries\n\t * @param indexUpdate IndexUpdate for which {@code create} fields will be populated\n\t */\n\tencryptSearchIndexEntries(id: IdTuple, ownerGroup: Id, keyToIndexEntries: Map<string, SearchIndexEntry[]>, indexUpdate: IndexUpdate): void {\n\t\tconst encryptionTimeStart = getPerformanceTimestamp()\n\t\tconst listId = listIdPart(id)\n\t\tconst encInstanceId = encryptIndexKeyUint8Array(this.db.key, elementIdPart(id), this.db.iv)\n\t\tconst encInstanceIdB64 = uint8ArrayToBase64(encInstanceId)\n\t\tconst elementIdTimestamp = generatedIdToTimestamp(elementIdPart(id))\n\t\tconst encWordsB64: string[] = []\n\t\tfor (const [indexKey, value] of keyToIndexEntries.entries()) {\n\t\t\tconst encWordB64 = encryptIndexKeyBase64(this.db.key, indexKey, this.db.iv)\n\t\t\tencWordsB64.push(encWordB64)\n\t\t\tconst encIndexEntries = getFromMap(indexUpdate.create.indexMap, encWordB64, () => [])\n\t\t\tfor (const indexEntry of value)\n\t\t\t\tencIndexEntries.push({\n\t\t\t\t\tentry: encryptSearchIndexEntry(this.db.key, indexEntry, encInstanceId),\n\t\t\t\t\ttimestamp: elementIdTimestamp,\n\t\t\t\t})\n\t\t}\n\t\tindexUpdate.create.encInstanceIdToElementData.set(encInstanceIdB64, {\n\t\t\tlistId,\n\t\t\tencWordsB64,\n\t\t\townerGroup,\n\t\t})\n\t\tthis._stats.encryptionTime += getPerformanceTimestamp() - encryptionTimeStart\n\t}\n\n\t/**\n\t * Process delete event before applying to the index.\n\t */\n\tasync _processDeleted(event: EntityUpdate, indexUpdate: IndexUpdate): Promise<void> {\n\t\tconst encInstanceIdPlain = encryptIndexKeyUint8Array(this.db.key, event.instanceId, this.db.iv)\n\t\tconst encInstanceIdB64 = uint8ArrayToBase64(encInstanceIdPlain)\n\t\tconst { appId, typeId } = typeRefToTypeInfo(new TypeRef(event.application, event.type))\n\t\tconst transaction = await this.db.dbFacade.createTransaction(true, [ElementDataOS])\n\t\tconst elementData = await transaction.get(ElementDataOS, encInstanceIdB64)\n\t\tif (!elementData) {\n\t\t\treturn\n\t\t}\n\n\t\t// We need to find SearchIndex rows which we want to update. In the ElementData we have references to the metadata and we can find\n\t\t// corresponding SearchIndex row in it.\n\t\tconst metaDataRowKeysBinary = unauthenticatedAesDecrypt(this.db.key, elementData[1], true)\n\t\t// For every word we have a metadata reference and we want to update them all.\n\t\tconst metaDataRowKeys = decodeNumbers(metaDataRowKeysBinary)\n\t\tfor (const metaDataRowKey of metaDataRowKeys) {\n\t\t\t// We add current instance into list of instances to delete for each word\n\t\t\tconst ids = getFromMap(indexUpdate.delete.searchMetaRowToEncInstanceIds, metaDataRowKey, () => [])\n\t\t\tids.push({\n\t\t\t\tencInstanceId: encInstanceIdPlain,\n\t\t\t\tappId,\n\t\t\t\ttypeId,\n\t\t\t\ttimestamp: generatedIdToTimestamp(event.instanceId),\n\t\t\t})\n\t\t}\n\t\tindexUpdate.delete.encInstanceIds.push(encInstanceIdB64)\n\t}\n\n\t/********************************************* Manipulating the state ***********************************************/\n\tstopProcessing() {\n\t\tthis._isStopped = true\n\t\tthis.queue.clear()\n\t}\n\n\tisStoppedProcessing(): boolean {\n\t\treturn this._isStopped\n\t}\n\n\tstartProcessing() {\n\t\tthis._isStopped = false\n\t}\n\n\taddBatchesToQueue(batches: QueuedBatch[]): void {\n\t\tif (!this._isStopped) {\n\t\t\tthis.queue.addBatches(batches)\n\t\t}\n\t}\n\n\t/*********************************************** Writing index update ***********************************************/\n\n\t/**\n\t * Apply populated {@param indexUpdate} to the database.\n\t */\n\twriteIndexUpdate(\n\t\tdataPerGroup: Array<{\n\t\t\tgroupId: Id\n\t\t\tindexTimestamp: number\n\t\t}>,\n\t\tindexUpdate: IndexUpdate,\n\t): Promise<void> {\n\t\treturn this._writeIndexUpdate(indexUpdate, (t) => this._updateGroupDataIndexTimestamp(dataPerGroup, t))\n\t}\n\n\twriteIndexUpdateWithBatchId(groupId: Id, batchId: Id, indexUpdate: IndexUpdate): Promise<void> {\n\t\treturn this._writeIndexUpdate(indexUpdate, (t) => this._updateGroupDataBatchId(groupId, batchId, t))\n\t}\n\n\t_writeIndexUpdate(indexUpdate: IndexUpdate, updateGroupData: (t: DbTransaction) => $Promisable<void>): Promise<void> {\n\t\treturn this._executeOperation({\n\t\t\ttransaction: null,\n\t\t\ttransactionFactory: () => this.db.dbFacade.createTransaction(false, [SearchIndexOS, SearchIndexMetaDataOS, ElementDataOS, MetaDataOS, GroupDataOS]),\n\t\t\toperation: (transaction) => {\n\t\t\t\tlet startTimeStorage = getPerformanceTimestamp()\n\n\t\t\t\tif (this._isStopped) {\n\t\t\t\t\treturn Promise.reject(new CancelledError(\"mail indexing cancelled\"))\n\t\t\t\t}\n\n\t\t\t\treturn (\n\t\t\t\t\tthis._moveIndexedInstance(indexUpdate, transaction)\n\t\t\t\t\t\t.thenOrApply(() => this._deleteIndexedInstance(indexUpdate, transaction))\n\t\t\t\t\t\t.thenOrApply(() => this._insertNewIndexEntries(indexUpdate, transaction))\n\t\t\t\t\t\t.thenOrApply((rowKeys: EncWordToMetaRow | null) => rowKeys && this._insertNewElementData(indexUpdate, transaction, rowKeys))\n\t\t\t\t\t\t.thenOrApply(() => updateGroupData(transaction))\n\t\t\t\t\t\t.thenOrApply(() => {\n\t\t\t\t\t\t\treturn transaction.wait().then(() => {\n\t\t\t\t\t\t\t\tthis._stats.storageTime += getPerformanceTimestamp() - startTimeStorage\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}) // a la catch(). Must be done in the next step because didReject is not invoked for the current Promise, only for the previous one.\n\t\t\t\t\t\t// It's probably a bad idea to convert to the Promise first and then catch because it may do Promise.resolve() and this will schedule to\n\t\t\t\t\t\t// the next event loop iteration and the context will be closed and it will be too late to abort(). Even worse, it will be commited to\n\t\t\t\t\t\t// IndexedDB already and it will be inconsistent (oops).\n\t\t\t\t\t\t.thenOrApply(noOp, (e) => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!transaction.aborted) transaction.abort()\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tconsole.warn(\"abort has failed: \", e) // Ignore if abort has failed\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.toPromise()\n\t\t\t\t)\n\t\t\t},\n\t\t\tdeferred: defer(),\n\t\t\tisAbortedForBackgroundMode: false,\n\t\t})\n\t}\n\n\t_executeOperation(operation: WriteOperation): Promise<void> {\n\t\tthis._currentWriteOperation = operation\n\t\treturn operation.transactionFactory().then((transaction) => {\n\t\t\toperation.transaction = transaction\n\t\t\toperation\n\t\t\t\t.operation(transaction)\n\t\t\t\t.then((it) => {\n\t\t\t\t\tthis._currentWriteOperation = null\n\t\t\t\t\toperation.deferred.resolve()\n\t\t\t\t\treturn it\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tif (operation.isAbortedForBackgroundMode) {\n\t\t\t\t\t\tconsole.log(\"transaction has been aborted because of background mode\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (env.mode !== \"Test\") {\n\t\t\t\t\t\t\tconsole.log(\"rejecting operation with error\", e)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toperation.deferred.reject(e)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\treturn operation.deferred.promise\n\t\t})\n\t}\n\n\tonVisibilityChanged(visible: boolean) {\n\t\tconst operation = this._currentWriteOperation\n\n\t\tif (!visible && operation && operation.transaction) {\n\t\t\tconsole.log(\"abort indexedDb transaction operation because background mode\")\n\n\t\t\ttry {\n\t\t\t\tneverNull(operation.transaction).abort()\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"Error when aborting on visibility change\", e)\n\t\t\t}\n\n\t\t\toperation.isAbortedForBackgroundMode = true\n\t\t}\n\n\t\tif (visible && operation) {\n\t\t\tconsole.log(\"restart indexedDb transaction operation after background mode\")\n\t\t\toperation.isAbortedForBackgroundMode = false\n\n\t\t\tthis._executeOperation(operation)\n\t\t}\n\t}\n\n\t_moveIndexedInstance(indexUpdate: IndexUpdate, transaction: DbTransaction): PromisableWrapper<void> {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (indexUpdate.move.length === 0) return PromisableWrapper.from(undefined) // keep transaction context open (only for Safari)\n\n\t\tconst promise = Promise.all(\n\t\t\tindexUpdate.move.map((moveInstance) => {\n\t\t\t\treturn transaction.get(ElementDataOS, moveInstance.encInstanceId).then((elementData) => {\n\t\t\t\t\tif (elementData) {\n\t\t\t\t\t\telementData[0] = moveInstance.newListId\n\t\t\t\t\t\ttransaction.put(ElementDataOS, moveInstance.encInstanceId, elementData)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}),\n\t\t).then(noOp)\n\t\treturn PromisableWrapper.from(promise)\n\t}\n\n\t/**\n\t * Apply \"delete\" updates to the database\n\t * @private\n\t */\n\t_deleteIndexedInstance(indexUpdate: IndexUpdate, transaction: DbTransaction): Promise<void> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (indexUpdate.delete.searchMetaRowToEncInstanceIds.size === 0) return null // keep transaction context open\n\n\t\tlet deleteElementDataPromise = Promise.all(indexUpdate.delete.encInstanceIds.map((encInstanceId) => transaction.delete(ElementDataOS, encInstanceId)))\n\t\t// For each word we have list of instances we want to remove\n\t\treturn Promise.all(\n\t\t\tArray.from(indexUpdate.delete.searchMetaRowToEncInstanceIds).map(([metaRowKey, encInstanceIds]) =>\n\t\t\t\tthis._deleteSearchIndexEntries(transaction, metaRowKey, encInstanceIds),\n\t\t\t),\n\t\t)\n\t\t\t.then(() => deleteElementDataPromise)\n\t\t\t.then(noOp)\n\t}\n\n\t/**\n\t * Remove all {@param instanceInfos} from the SearchIndex entries and metadata entreis specified by the {@param metaRowKey}.\n\t * @private\n\t */\n\t_deleteSearchIndexEntries(transaction: DbTransaction, metaRowKey: number, instanceInfos: EncInstanceIdWithTimestamp[]): Promise<any> {\n\t\tthis._cancelIfNeeded()\n\n\t\t// Collect hashes of all instances we want to delete to check it faster later\n\t\tconst encInstanceIdSet = new Set(instanceInfos.map((e) => arrayHash(e.encInstanceId)))\n\t\treturn transaction.get(SearchIndexMetaDataOS, metaRowKey).then((encMetaDataRow) => {\n\t\t\tif (!encMetaDataRow) {\n\t\t\t\t// already deleted\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst metaDataRow = decryptMetaData(this.db.key, encMetaDataRow)\n\t\t\t// add meta data to set to only update meta data once when deleting multiple instances\n\t\t\tconst metaDataEntriesSet = new Set() as Set<SearchIndexMetadataEntry>\n\t\t\tfor (const info of instanceInfos) {\n\t\t\t\t// For each instance we find SearchIndex row it belongs to by timestamp\n\t\t\t\tconst entryIndex = this._findMetaDataEntryByTimestamp(metaDataRow, info.timestamp, info.appId, info.typeId)\n\n\t\t\t\tif (entryIndex === -1) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\"could not find MetaDataEntry, info:\",\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\"rows: \",\n\t\t\t\t\t\tmetaDataRow.rows.map((r) => JSON.stringify(r)),\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tmetaDataEntriesSet.add(metaDataRow.rows[entryIndex])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For each SearchIndex row we need to update...\n\t\t\tconst updateSearchIndex = this._promiseMapCompat(Array.from(metaDataEntriesSet), (metaEntry) => {\n\t\t\t\treturn transaction.get(SearchIndexOS, metaEntry.key).then((indexEntriesRow) => {\n\t\t\t\t\tif (!indexEntriesRow) return\n\t\t\t\t\t// Find all entries we need to remove by hash of the encrypted ID\n\t\t\t\t\tconst rangesToRemove: Array<[number, number]> = []\n\t\t\t\t\titerateBinaryBlocks(indexEntriesRow, (block, start, end) => {\n\t\t\t\t\t\tif (encInstanceIdSet.has(arrayHash(getIdFromEncSearchIndexEntry(block)))) {\n\t\t\t\t\t\t\trangesToRemove.push([start, end])\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tif (rangesToRemove.length === 0) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else if (metaEntry.size === rangesToRemove.length) {\n\t\t\t\t\t\tmetaEntry.size = 0\n\t\t\t\t\t\treturn transaction.delete(SearchIndexOS, metaEntry.key)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst trimmed = removeBinaryBlockRanges(indexEntriesRow, rangesToRemove)\n\t\t\t\t\t\tmetaEntry.size -= rangesToRemove.length\n\t\t\t\t\t\treturn transaction.put(SearchIndexOS, metaEntry.key, trimmed)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\n\t\t\treturn updateSearchIndex.thenOrApply(() => {\n\t\t\t\tmetaDataRow.rows = metaDataRow.rows.filter((r) => r.size > 0)\n\n\t\t\t\tif (metaDataRow.rows.length === 0) {\n\t\t\t\t\treturn transaction.delete(SearchIndexMetaDataOS, metaDataRow.id)\n\t\t\t\t} else {\n\t\t\t\t\treturn transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(this.db.key, metaDataRow))\n\t\t\t\t}\n\t\t\t}).value\n\t\t})\n\t}\n\n\t_insertNewElementData(indexUpdate: IndexUpdate, transaction: DbTransaction, encWordToMetaRow: EncWordToMetaRow): Promise<unknown> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (indexUpdate.create.encInstanceIdToElementData.size === 0) return null // keep transaction context open (only in Safari)\n\n\t\tlet promises: Promise<unknown>[] = []\n\t\tfor (const [b64EncInstanceId, elementDataSurrogate] of indexUpdate.create.encInstanceIdToElementData.entries()) {\n\t\t\tconst metaRows = elementDataSurrogate.encWordsB64.map((w) => encWordToMetaRow[w])\n\t\t\tconst rowKeysBinary = new Uint8Array(calculateNeededSpaceForNumbers(metaRows))\n\t\t\tencodeNumbers(metaRows, rowKeysBinary)\n\t\t\tconst encMetaRowKeys = aes256EncryptSearchIndexEntry(this.db.key, rowKeysBinary)\n\t\t\tpromises.push(transaction.put(ElementDataOS, b64EncInstanceId, [elementDataSurrogate.listId, encMetaRowKeys, elementDataSurrogate.ownerGroup]))\n\t\t}\n\t\treturn Promise.all(promises)\n\t}\n\n\t_insertNewIndexEntries(indexUpdate: IndexUpdate, transaction: DbTransaction): Promise<EncWordToMetaRow> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tlet keys = [...indexUpdate.create.indexMap.keys()]\n\t\tconst encWordToMetaRow: EncWordToMetaRow = {}\n\n\t\tconst result = this._promiseMapCompat(\n\t\t\tkeys,\n\t\t\t(encWordB64) => {\n\t\t\t\tconst encryptedEntries = neverNull(indexUpdate.create.indexMap.get(encWordB64))\n\t\t\t\treturn this._putEncryptedEntity(\n\t\t\t\t\tindexUpdate.typeInfo.appId,\n\t\t\t\t\tindexUpdate.typeInfo.typeId,\n\t\t\t\t\ttransaction,\n\t\t\t\t\tencWordB64,\n\t\t\t\t\tencWordToMetaRow,\n\t\t\t\t\tencryptedEntries,\n\t\t\t\t)\n\t\t\t},\n\t\t\t{\n\t\t\t\tconcurrency: 2,\n\t\t\t},\n\t\t).value\n\n\t\treturn result instanceof Promise ? result.then(() => encWordToMetaRow) : null\n\t}\n\n\t_putEncryptedEntity(\n\t\tappId: number,\n\t\ttypeId: number,\n\t\ttransaction: DbTransaction,\n\t\tencWordB64: B64EncIndexKey,\n\t\tencWordToMetaRow: EncWordToMetaRow,\n\t\tencryptedEntries: Array<EncSearchIndexEntryWithTimestamp>,\n\t): Promise<unknown> | null {\n\t\tthis._cancelIfNeeded()\n\n\t\tif (encryptedEntries.length <= 0) {\n\t\t\treturn null\n\t\t}\n\n\t\treturn this._getOrCreateSearchIndexMeta(transaction, encWordB64)\n\t\t\t.then((metaData: SearchIndexMetaDataRow) => {\n\t\t\t\tencryptedEntries.sort((a, b) => a.timestamp - b.timestamp)\n\n\t\t\t\tconst writeResult = this._writeEntries(transaction, encryptedEntries, metaData, appId, typeId)\n\n\t\t\t\treturn writeResult.thenOrApply(() => metaData).value\n\t\t\t})\n\t\t\t.then((metaData) => {\n\t\t\t\tconst columnSize = metaData.rows.reduce((result, metaDataEntry) => result + metaDataEntry.size, 0)\n\t\t\t\tthis._stats.writeRequests += 1\n\t\t\t\tthis._stats.largestColumn = columnSize > this._stats.largestColumn ? columnSize : this._stats.largestColumn\n\t\t\t\tthis._stats.storedBytes += encryptedEntries.reduce((sum, e) => sum + e.entry.length, 0)\n\t\t\t\tencWordToMetaRow[encWordB64] = metaData.id\n\t\t\t\treturn transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(this.db.key, metaData))\n\t\t\t})\n\t}\n\n\t/**\n\t * Insert {@param entries} into the database for the corresponding {@param metaData}.\n\t * Metadata entries for each type are sorted from oldest to newest. Each metadata entry has oldest element timestamp. Timestamps of newer entries make a\n\t * time border for the newest. Timestamp for entry is considered fixed (unless it's the first entry).\n\t * The strategy is following:\n\t * First, try to find matching row by the oldest id of the entries we want to insert.\n\t * If we've found one, put everything that matches time frame of this row into it (it's bounded by the next row, if present). Put the rest into newer\n\t * rows.\n\t * If we didn't find one, we may try to extend the oldest row, because it's not bounded by the other row.\n\t * When we append something to the row, we check if its size would exceed {@link SEARCH_INDEX_ROW_LENGTH}. If it is, we do splitting,\n\t * {@see _appendIndexEntriesToRow}.\n\t * @private\n\t */\n\t_writeEntries(\n\t\ttransaction: DbTransaction,\n\t\tentries: Array<EncSearchIndexEntryWithTimestamp>,\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\tappId: number,\n\t\ttypeId: number,\n\t): PromisableWrapper<void> {\n\t\tif (entries.length === 0) {\n\t\t\t// Prevent IDB timeouts in Safari casued by Promise.resolve()\n\t\t\treturn PromisableWrapper.from(undefined)\n\t\t}\n\n\t\tconst oldestTimestamp = entries[0].timestamp\n\n\t\tconst indexOfMetaEntry = this._findMetaDataEntryByTimestamp(metaData, oldestTimestamp, appId, typeId)\n\n\t\tif (indexOfMetaEntry !== -1) {\n\t\t\tconst nextEntry = this._nextEntryOfType(metaData, indexOfMetaEntry + 1, appId, typeId)\n\n\t\t\tif (!nextEntry) {\n\t\t\t\treturn this._appendIndexEntriesToRow(transaction, metaData, indexOfMetaEntry, entries)\n\t\t\t} else {\n\t\t\t\tconst [toCurrentOne, toNextOnes] = this._splitByTimestamp(entries, nextEntry.oldestElementTimestamp)\n\n\t\t\t\treturn this._appendIndexEntriesToRow(transaction, metaData, indexOfMetaEntry, toCurrentOne).thenOrApply(() =>\n\t\t\t\t\tthis._writeEntries(transaction, toNextOnes, metaData, appId, typeId),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\t// we have not found any entry which oldest id is lower than oldest id to add but there can be other entries\n\t\t\tconst firstEntry = this._nextEntryOfType(metaData, 0, appId, typeId)\n\n\t\t\t// 1. We have a first entry.\n\t\t\t//   i: We have a second entry. Check how much fits into the first block\n\t\t\t//     a. It's not oversized. Write to it.\n\t\t\t//     b. It is oversized. Create a new block.\n\t\t\t//   ii: We don't have a second entry. Check if we can fit everything into the first block\n\t\t\t//     a. It's not eversized. Write to it.\n\t\t\t//     b. It's oversized. Create a new one.\n\t\t\t// 2. We don't have a first entry. Just create a new row with everything.\n\t\t\tif (firstEntry) {\n\t\t\t\tconst indexOfFirstEntry = metaData.rows.indexOf(firstEntry)\n\n\t\t\t\tconst secondEntry = this._nextEntryOfType(metaData, indexOfFirstEntry + 1, appId, typeId)\n\n\t\t\t\tconst [toFirstOne, toNextOnes] = secondEntry ? this._splitByTimestamp(entries, secondEntry.oldestElementTimestamp) : [entries, []]\n\n\t\t\t\tif (firstEntry.size + toFirstOne.length < SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t\t\treturn this._appendIndexEntriesToRow(transaction, metaData, indexOfFirstEntry, toFirstOne).thenOrApply(() =>\n\t\t\t\t\t\tthis._writeEntries(transaction, toNextOnes, metaData, appId, typeId),\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tconst [toNewOne, toCurrentOne] = this._splitByTimestamp(toFirstOne, firstEntry.oldestElementTimestamp)\n\n\t\t\t\t\treturn PromisableWrapper.from(this._createNewRow(transaction, metaData, toNewOne, oldestTimestamp, appId, typeId)).thenOrApply(() =>\n\t\t\t\t\t\tthis._writeEntries(transaction, toCurrentOne.concat(toNextOnes), metaData, appId, typeId),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this._createNewRow(transaction, metaData, entries, oldestTimestamp, appId, typeId)\n\t\t\t}\n\t\t}\n\t}\n\n\t_nextEntryOfType(metaData: SearchIndexMetaDataRow, startIndex: number, appId: number, typeId: number): SearchIndexMetadataEntry | null {\n\t\tfor (let i = startIndex; i < metaData.rows.length; i++) {\n\t\t\tif (metaData.rows[i].app === appId && metaData.rows[i].type === typeId) {\n\t\t\t\treturn metaData.rows[i]\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\t/**\n\t * Split {@param entries} (must be sorted!) into two arrays: before and after the timestamp.\n\t * @private\n\t */\n\t_splitByTimestamp(\n\t\tentries: Array<EncSearchIndexEntryWithTimestamp>,\n\t\ttimestamp: number,\n\t): [Array<EncSearchIndexEntryWithTimestamp>, Array<EncSearchIndexEntryWithTimestamp>] {\n\t\tconst indexOfSplit = entries.findIndex((entry) => entry.timestamp >= timestamp)\n\n\t\tif (indexOfSplit === -1) {\n\t\t\treturn [entries, []]\n\t\t}\n\n\t\tconst below = entries.slice(0, indexOfSplit)\n\t\tconst above = entries.slice(indexOfSplit)\n\t\treturn [below, above]\n\t}\n\n\t/**\n\t * Append {@param entries} to the row specified by the {@param metaEntryIndex}. If the row size exceeds {@link SEARCH_INDEX_ROW_LENGTH}, then\n\t * split it into two rows.\n\t * @private\n\t */\n\t_appendIndexEntriesToRow(\n\t\ttransaction: DbTransaction,\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\tmetaEntryIndex: number,\n\t\tentries: Array<EncSearchIndexEntryWithTimestamp>,\n\t): PromisableWrapper<void> {\n\t\tif (entries.length === 0) {\n\t\t\treturn new PromisableWrapper(undefined)\n\t\t}\n\n\t\tconst metaEntry = metaData.rows[metaEntryIndex]\n\n\t\tif (metaEntry.size + entries.length > SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t// load existing row\n\t\t\t// decrypt ids\n\t\t\t// sort by id\n\t\t\t// split\n\t\t\treturn PromisableWrapper.from(\n\t\t\t\ttransaction.get(SearchIndexOS, metaEntry.key).then((binaryBlock: SearchIndexDbRow | null) => {\n\t\t\t\t\tif (!binaryBlock) {\n\t\t\t\t\t\tthrow new InvalidDatabaseStateError(\"non existing index row\")\n\t\t\t\t\t}\n\n\t\t\t\t\tconst timestampToEntries: Map<number, Array<Uint8Array>> = new Map()\n\t\t\t\t\tconst existingIds = new Set()\n\t\t\t\t\t// Iterate all entries in a block, decrypt id of each and put it into the map\n\t\t\t\t\titerateBinaryBlocks(binaryBlock, (encSearchIndexEntry) => {\n\t\t\t\t\t\tconst encId = getIdFromEncSearchIndexEntry(encSearchIndexEntry)\n\t\t\t\t\t\texistingIds.add(arrayHash(encId))\n\t\t\t\t\t\tconst decId = decryptIndexKey(this.db.key, encId, this.db.iv)\n\t\t\t\t\t\tconst timeStamp = generatedIdToTimestamp(decId)\n\t\t\t\t\t\tgetFromMap(timestampToEntries, timeStamp, () => []).push(encSearchIndexEntry)\n\t\t\t\t\t})\n\t\t\t\t\t// Also add new entries\n\t\t\t\t\tfor (const { entry, timestamp } of entries) {\n\t\t\t\t\t\tgetFromMap(timestampToEntries, timestamp, () => []).push(entry)\n\t\t\t\t\t}\n\t\t\t\t\t// Prefer to put entries into the first row if it's not initial indexing (we are likely to grow second row in the future)\n\t\t\t\t\t// Prefer to put entries into the second row if it's initial indexing (we are likely to grow the first row because we move back in time)\n\t\t\t\t\tconst isLastEntry = this._nextEntryOfType(metaData, metaEntryIndex + 1, metaEntry.app, metaEntry.type) == null\n\n\t\t\t\t\tconst rows = this._distributeEntities(timestampToEntries, isLastEntry)\n\n\t\t\t\t\t// keep the oldest timestamp in the existing meta data entry to ensure that when continuing search we don't get the same meta data entry twice.\n\t\t\t\t\tconst [appendRow, newRows] = [rows[0], rows.slice(1)]\n\t\t\t\t\tconst firstRowBinary = appendBinaryBlocks(appendRow.row)\n\t\t\t\t\tconst requestPromises = [\n\t\t\t\t\t\ttransaction.put(SearchIndexOS, metaEntry.key, firstRowBinary).then(() => {\n\t\t\t\t\t\t\tmetaEntry.size = appendRow.row.length\n\t\t\t\t\t\t\tmetaEntry.oldestElementTimestamp = appendRow.oldestElementTimestamp\n\t\t\t\t\t\t\treturn metaEntry.key\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tthis._promiseMapCompat(\n\t\t\t\t\t\t\tnewRows,\n\t\t\t\t\t\t\t(row) => {\n\t\t\t\t\t\t\t\tconst binaryRow = appendBinaryBlocks(row.row)\n\t\t\t\t\t\t\t\treturn transaction.put(SearchIndexOS, null, binaryRow).then((newSearchIndexRowId) => {\n\t\t\t\t\t\t\t\t\tmetaData.rows.push({\n\t\t\t\t\t\t\t\t\t\tkey: newSearchIndexRowId,\n\t\t\t\t\t\t\t\t\t\tsize: row.row.length,\n\t\t\t\t\t\t\t\t\t\tapp: metaEntry.app,\n\t\t\t\t\t\t\t\t\t\ttype: metaEntry.type,\n\t\t\t\t\t\t\t\t\t\toldestElementTimestamp: row.oldestElementTimestamp,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconcurrency: 2,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t).value,\n\t\t\t\t\t]\n\t\t\t\t\treturn Promise.all(requestPromises).then(() => {\n\t\t\t\t\t\tmetaData.rows.sort(compareMetaEntriesOldest)\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\treturn PromisableWrapper.from(\n\t\t\t\ttransaction.get(SearchIndexOS, metaEntry.key).then((indexEntriesRow) => {\n\t\t\t\t\tlet safeRow = indexEntriesRow || new Uint8Array(0)\n\t\t\t\t\tconst resultRow = appendBinaryBlocks(\n\t\t\t\t\t\tentries.map((e) => e.entry),\n\t\t\t\t\t\tsafeRow,\n\t\t\t\t\t)\n\t\t\t\t\treturn transaction.put(SearchIndexOS, metaEntry.key, resultRow).then(() => {\n\t\t\t\t\t\tmetaEntry.size += entries.length\n\t\t\t\t\t\t// when adding entries to an existing row it is guaranteed that all added elements are newer.\n\t\t\t\t\t\t// We don't have to update oldestTimestamp of the meta data.\n\t\t\t\t\t\t// ...except when we're growing the first row, then we should do that\n\t\t\t\t\t\tmetaEntry.oldestElementTimestamp = Math.min(entries[0].timestamp, metaEntry.oldestElementTimestamp)\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n\n\t_distributeEntities(\n\t\ttimestampToEntries: Map<number, Array<EncryptedSearchIndexEntry>>,\n\t\tpreferFirst: boolean,\n\t): Array<{\n\t\trow: Array<Uint8Array>\n\t\toldestElementTimestamp: number\n\t}> {\n\t\tconst sortedTimestamps = Array.from(timestampToEntries.keys()).sort((l, r) => l - r)\n\n\t\t// If we append to the newest IDs, then try to saturate older rows\n\t\tif (preferFirst) {\n\t\t\tconst rows = [\n\t\t\t\t{\n\t\t\t\t\trow: [] as Array<EncryptedSearchIndexEntry>,\n\t\t\t\t\toldestElementTimestamp: sortedTimestamps[0],\n\t\t\t\t},\n\t\t\t]\n\t\t\tfor (const id of sortedTimestamps) {\n\t\t\t\tconst encryptedEntries = neverNull(timestampToEntries.get(id))\n\n\t\t\t\tif (lastThrow(rows).row.length + encryptedEntries.length > SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t\t\trows.push({\n\t\t\t\t\t\trow: [],\n\t\t\t\t\t\toldestElementTimestamp: id,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tlastThrow(rows).row.push(...encryptedEntries)\n\t\t\t}\n\t\t\treturn rows\n\t\t} else {\n\t\t\t// If we append in the middle, then try to saturate new row\n\t\t\tconst rows = [\n\t\t\t\t{\n\t\t\t\t\trow: [] as EncryptedSearchIndexEntry[],\n\t\t\t\t\toldestElementTimestamp: Number.MAX_SAFE_INTEGER,\n\t\t\t\t},\n\t\t\t]\n\t\t\tconst reveresId = sortedTimestamps.slice().reverse()\n\t\t\tfor (const id of reveresId) {\n\t\t\t\tconst encryptedEntries = neverNull(timestampToEntries.get(id))\n\n\t\t\t\tif (rows[0].row.length + encryptedEntries.length > SEARCH_INDEX_ROW_LENGTH) {\n\t\t\t\t\trows.unshift({\n\t\t\t\t\t\trow: [],\n\t\t\t\t\t\toldestElementTimestamp: id,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\trows[0].row.unshift(...encryptedEntries)\n\t\t\t\trows[0].oldestElementTimestamp = Math.min(rows[0].oldestElementTimestamp, id)\n\t\t\t}\n\t\t\treturn rows\n\t\t}\n\t}\n\n\t_createNewRow(\n\t\ttransaction: DbTransaction,\n\t\tmetaData: SearchIndexMetaDataRow,\n\t\tencryptedSearchIndexEntries: Array<EncSearchIndexEntryWithTimestamp>,\n\t\toldestTimestamp: number,\n\t\tappId: number,\n\t\ttypeId: number,\n\t): PromisableWrapper<void> {\n\t\tconst byTimestamp = groupByAndMap(\n\t\t\tencryptedSearchIndexEntries,\n\t\t\t(e) => e.timestamp,\n\t\t\t(e) => e.entry,\n\t\t)\n\n\t\tconst distributed = this._distributeEntities(byTimestamp, false)\n\n\t\treturn this._promiseMapCompat(\n\t\t\tdistributed,\n\t\t\t({ row, oldestElementTimestamp }) => {\n\t\t\t\tconst binaryRow = appendBinaryBlocks(row)\n\t\t\t\treturn transaction.put(SearchIndexOS, null, binaryRow).then((newRowId) => {\n\t\t\t\t\t// Oldest entries come in front\n\t\t\t\t\tmetaData.rows.push({\n\t\t\t\t\t\tkey: newRowId,\n\t\t\t\t\t\tsize: row.length,\n\t\t\t\t\t\tapp: appId,\n\t\t\t\t\t\ttype: typeId,\n\t\t\t\t\t\toldestElementTimestamp,\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t\t{\n\t\t\t\tconcurrency: 2,\n\t\t\t},\n\t\t).thenOrApply(() => {\n\t\t\tmetaData.rows.sort(compareMetaEntriesOldest)\n\t\t})\n\t}\n\n\t_findMetaDataEntryByTimestamp(metaData: SearchIndexMetaDataRow, oldestTimestamp: number, appId: number, typeId: number): number {\n\t\treturn findLastIndex(metaData.rows, (r) => r.app === appId && r.type === typeId && r.oldestElementTimestamp <= oldestTimestamp)\n\t}\n\n\t_getOrCreateSearchIndexMeta(transaction: DbTransaction, encWordBase64: B64EncIndexKey): Promise<SearchIndexMetaDataRow> {\n\t\treturn transaction.get(SearchIndexMetaDataOS, encWordBase64, SearchIndexWordsIndex).then((metaData: SearchIndexMetaDataDbRow | null) => {\n\t\t\tif (metaData) {\n\t\t\t\treturn decryptMetaData(this.db.key, metaData)\n\t\t\t} else {\n\t\t\t\tconst metaTemplate: Partial<SearchIndexMetaDataDbRow> = {\n\t\t\t\t\tword: encWordBase64,\n\t\t\t\t\trows: new Uint8Array(0),\n\t\t\t\t}\n\n\t\t\t\tif (this._needsExplicitIds) {\n\t\t\t\t\tmetaTemplate.id = this._explicitIdStart++\n\t\t\t\t}\n\n\t\t\t\treturn transaction.put(SearchIndexMetaDataOS, null, metaTemplate).then((rowId) => {\n\t\t\t\t\tthis._stats.words += 1\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: rowId,\n\t\t\t\t\t\tword: encWordBase64,\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\t_updateGroupDataIndexTimestamp(\n\t\tdataPerGroup: Array<{\n\t\t\tgroupId: Id\n\t\t\tindexTimestamp: number\n\t\t}>,\n\t\ttransaction: DbTransaction,\n\t): $Promisable<void> {\n\t\treturn this._promiseMapCompat(dataPerGroup, (data) => {\n\t\t\tconst { groupId, indexTimestamp } = data\n\t\t\treturn transaction.get(GroupDataOS, groupId).then((groupData: GroupData | null) => {\n\t\t\t\tif (!groupData) {\n\t\t\t\t\tthrow new InvalidDatabaseStateError(\"GroupData not available for group \" + groupId)\n\t\t\t\t}\n\n\t\t\t\tgroupData.indexTimestamp = indexTimestamp\n\t\t\t\treturn transaction.put(GroupDataOS, groupId, groupData)\n\t\t\t})\n\t\t}).thenOrApply(() => {}).value\n\t}\n\n\t_updateGroupDataBatchId(groupId: Id, batchId: Id, transaction: DbTransaction): Promise<void> {\n\t\treturn transaction.get(GroupDataOS, groupId).then((groupData: GroupData | null) => {\n\t\t\tif (!groupData) {\n\t\t\t\tthrow new InvalidDatabaseStateError(\"GroupData not available for group \" + groupId)\n\t\t\t}\n\n\t\t\tif (groupData.lastBatchIds.length > 0 && groupData.lastBatchIds.indexOf(batchId) !== -1) {\n\t\t\t\t// concurrent indexing (multiple tabs)\n\t\t\t\tconsole.warn(\"Abort transaction on updating group data: concurrent access\", groupId, batchId)\n\t\t\t\ttransaction.abort()\n\t\t\t} else {\n\t\t\t\tlet newIndex = groupData.lastBatchIds.findIndex((indexedBatchId) => firstBiggerThanSecond(batchId, indexedBatchId))\n\n\t\t\t\tif (newIndex !== -1) {\n\t\t\t\t\tgroupData.lastBatchIds.splice(newIndex, 0, batchId)\n\t\t\t\t} else {\n\t\t\t\t\tgroupData.lastBatchIds.push(batchId) // new batch is oldest of all stored batches\n\t\t\t\t}\n\n\t\t\t\tif (groupData.lastBatchIds.length > 1000) {\n\t\t\t\t\tgroupData.lastBatchIds = groupData.lastBatchIds.slice(0, 1000)\n\t\t\t\t}\n\n\t\t\t\treturn transaction.put(GroupDataOS, groupId, groupData)\n\t\t\t}\n\t\t})\n\t}\n\n\t_cancelIfNeeded() {\n\t\tif (this._isStopped) {\n\t\t\tthrow new CancelledError(\"indexing cancelled\")\n\t\t}\n\t}\n\n\tresetStats() {\n\t\tthis._stats = {\n\t\t\tindexingTime: 0,\n\t\t\tstorageTime: 0,\n\t\t\tpreparingTime: 0,\n\t\t\tmailcount: 0,\n\t\t\tstoredBytes: 0,\n\t\t\tencryptionTime: 0,\n\t\t\twriteRequests: 0,\n\t\t\tlargestColumn: 0,\n\t\t\twords: 0,\n\t\t\tindexedBytes: 0,\n\t\t}\n\t}\n\n\tprintStatus() {\n\t\tconst totalTime = this._stats.storageTime + this._stats.preparingTime\n\t\tconst statsWithDownloading = Object.assign({}, this._stats, {\n\t\t\tdownloadingTime: this._stats.preparingTime - this._stats.indexingTime - this._stats.encryptionTime,\n\t\t})\n\t\tconsole.log(JSON.stringify(statsWithDownloading), \"total time: \", totalTime)\n\t}\n}\n"]}