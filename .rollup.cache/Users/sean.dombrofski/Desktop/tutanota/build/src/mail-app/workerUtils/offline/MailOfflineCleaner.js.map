{"version":3,"file":"MailOfflineCleaner.js","sourceRoot":"","sources":["../../../../../src/mail-app/workerUtils/offline/MailOfflineCleaner.ts"],"names":[],"mappings":"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","sourcesContent":["import { UserTypeRef } from \"../../../common/api/entities/sys/TypeRefs.js\"\nimport { AccountType, OFFLINE_STORAGE_DEFAULT_TIME_RANGE_DAYS } from \"../../../common/api/common/TutanotaConstants.js\"\nimport { assertNotNull, DAY_IN_MILLIS, groupByAndMap } from \"@tutao/tutanota-utils\"\nimport {\n\tconstructMailSetEntryId,\n\tCUSTOM_MAX_ID,\n\telementIdPart,\n\tfirstBiggerThanSecond,\n\tfirstBiggerThanSecondCustomId,\n\tGENERATED_MAX_ID,\n\tgetElementId,\n\tlistIdPart,\n\ttimestampToGeneratedId,\n} from \"../../../common/api/common/utils/EntityUtils.js\"\nimport {\n\tFileTypeRef,\n\tMailBoxTypeRef,\n\tMailDetailsBlobTypeRef,\n\tMailDetailsDraftTypeRef,\n\tMailFolderTypeRef,\n\tMailSetEntryTypeRef,\n\tMailTypeRef,\n} from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { FolderSystem } from \"../../../common/api/common/mail/FolderSystem.js\"\nimport { OfflineStorage, OfflineStorageCleaner } from \"../../../common/api/worker/offline/OfflineStorage.js\"\nimport { isDraft, isSpamOrTrashFolder } from \"../../mail/model/MailChecks.js\"\n\nexport class MailOfflineCleaner implements OfflineStorageCleaner {\n\tasync cleanOfflineDb(offlineStorage: OfflineStorage, timeRangeDays: number | null, userId: Id, now: number): Promise<void> {\n\t\tconst user = await offlineStorage.get(UserTypeRef, null, userId)\n\n\t\t// Free users always have default time range regardless of what is stored\n\t\tconst isFreeUser = user?.accountType === AccountType.FREE\n\t\tconst timeRange = isFreeUser || timeRangeDays == null ? OFFLINE_STORAGE_DEFAULT_TIME_RANGE_DAYS : timeRangeDays\n\t\tconst daysSinceDayAfterEpoch = now / DAY_IN_MILLIS - 1\n\t\tconst timeRangeMillisSafe = Math.min(daysSinceDayAfterEpoch, timeRange) * DAY_IN_MILLIS\n\t\t// from May 15th 2109 onward, exceeding daysSinceDayAfterEpoch in the time range setting will\n\t\t// lead to an overflow in our 42 bit timestamp in the id.\n\t\tconst cutoffTimestamp = now - timeRangeMillisSafe\n\n\t\tconst mailBoxes = await offlineStorage.getElementsOfType(MailBoxTypeRef)\n\t\tconst cutoffId = timestampToGeneratedId(cutoffTimestamp)\n\t\tfor (const mailBox of mailBoxes) {\n\t\t\tconst isMailsetMigrated = mailBox.currentMailBag != null\n\t\t\tconst folders = await offlineStorage.getWholeList(MailFolderTypeRef, mailBox.folders!.folders)\n\t\t\tif (isMailsetMigrated) {\n\t\t\t\t// Deleting MailSetEntries first to make sure that once we start deleting Mail\n\t\t\t\t// we don't have any MailSetEntries that reference that Mail anymore.\n\t\t\t\tconst folderSystem = new FolderSystem(folders)\n\t\t\t\tfor (const mailSet of folders) {\n\t\t\t\t\tif (isSpamOrTrashFolder(folderSystem, mailSet)) {\n\t\t\t\t\t\tawait this.deleteMailSetEntries(offlineStorage, mailSet.entries, CUSTOM_MAX_ID)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst customCutoffId = constructMailSetEntryId(new Date(cutoffTimestamp), GENERATED_MAX_ID)\n\t\t\t\t\t\tawait this.deleteMailSetEntries(offlineStorage, mailSet.entries, customCutoffId)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// TODO MailSet cleanup\n\t\t\t\tconst mailListIds = [mailBox.currentMailBag!, ...mailBox.archivedMailBags].map((mailbag) => mailbag.mails)\n\t\t\t\tfor (const mailListId of mailListIds) {\n\t\t\t\t\tawait this.deleteMailListLegacy(offlineStorage, mailListId, cutoffId)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This method deletes mails from {@param listId} what are older than {@param cutoffId} as well as associated data.\n\t *\n\t * it's considered legacy because once we start importing mail into mail bags, maintaining mail list ranges doesn't make\n\t * sense anymore - mail order in a list is arbitrary at that point.\n\t *\n\t * For each mail we delete the mail, its body, headers, all references mail set entries and all referenced attachments.\n\t *\n\t * When we delete the Files, we also delete the whole range for the user's File list. We need to delete the whole\n\t * range because we only have one file list per mailbox, so if we delete something from the middle of it, the range\n\t * will no longer be valid. (this is future proofing, because as of now there is not going to be a Range set for the\n\t * File list anyway, since we currently do not do range requests for Files.\n\t *\n\t * We do not delete ConversationEntries because:\n\t *  1. They are in the same list for the whole conversation so we can't adjust the range\n\t *  2. We might need them in the future for showing the whole thread\n\t */\n\tprivate async deleteMailListLegacy(offlineStorage: OfflineStorage, listId: Id, cutoffId: Id): Promise<void> {\n\t\t// We lock access to the \"ranges\" db here in order to prevent race conditions when accessing the \"ranges\" database.\n\t\tawait offlineStorage.lockRangesDbAccess(listId)\n\t\ttry {\n\t\t\t// This must be done before deleting mails to know what the new range has to be\n\t\t\tawait offlineStorage.updateRangeForListAndDeleteObsoleteData(MailTypeRef, listId, cutoffId)\n\t\t} finally {\n\t\t\t// We unlock access to the \"ranges\" db here. We lock it in order to prevent race conditions when accessing the \"ranges\" database.\n\t\t\tawait offlineStorage.unlockRangesDbAccess(listId)\n\t\t}\n\n\t\tconst mailsToDelete: IdTuple[] = []\n\t\tconst attachmentsToDelete: IdTuple[] = []\n\t\tconst mailDetailsBlobToDelete: IdTuple[] = []\n\t\tconst mailDetailsDraftToDelete: IdTuple[] = []\n\n\t\tconst mails = await offlineStorage.getWholeList(MailTypeRef, listId)\n\t\tfor (let mail of mails) {\n\t\t\tif (firstBiggerThanSecond(cutoffId, getElementId(mail))) {\n\t\t\t\tmailsToDelete.push(mail._id)\n\t\t\t\tfor (const id of mail.attachments) {\n\t\t\t\t\tattachmentsToDelete.push(id)\n\t\t\t\t}\n\n\t\t\t\tif (isDraft(mail)) {\n\t\t\t\t\tconst mailDetailsId = assertNotNull(mail.mailDetailsDraft)\n\t\t\t\t\tmailDetailsDraftToDelete.push(mailDetailsId)\n\t\t\t\t} else {\n\t\t\t\t\t// mailDetailsBlob\n\t\t\t\t\tconst mailDetailsId = assertNotNull(mail.mailDetails)\n\t\t\t\t\tmailDetailsBlobToDelete.push(mailDetailsId)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let [listId, elementIds] of groupByAndMap(mailDetailsBlobToDelete, listIdPart, elementIdPart).entries()) {\n\t\t\tawait offlineStorage.deleteIn(MailDetailsBlobTypeRef, listId, elementIds)\n\t\t}\n\t\tfor (let [listId, elementIds] of groupByAndMap(mailDetailsDraftToDelete, listIdPart, elementIdPart).entries()) {\n\t\t\tawait offlineStorage.deleteIn(MailDetailsDraftTypeRef, listId, elementIds)\n\t\t}\n\t\tfor (let [listId, elementIds] of groupByAndMap(attachmentsToDelete, listIdPart, elementIdPart).entries()) {\n\t\t\tawait offlineStorage.deleteIn(FileTypeRef, listId, elementIds)\n\t\t\tawait offlineStorage.deleteRange(FileTypeRef, listId)\n\t\t}\n\n\t\tawait offlineStorage.deleteIn(MailTypeRef, listId, mailsToDelete.map(elementIdPart))\n\t}\n\n\t/**\n\t * delete all mail set entries of a mail set that reference some mail with a receivedDate older than\n\t * cutoffTimestamp. this doesn't clean up mails or their associated data because we could be breaking the\n\t * offline list range invariant by deleting data from the middle of a mail range. cleaning up mails is done\n\t * the legacy way currently even for mailset users.\n\t */\n\tprivate async deleteMailSetEntries(offlineStorage: OfflineStorage, entriesListId: Id, cutoffId: Id) {\n\t\tawait offlineStorage.lockRangesDbAccess(entriesListId)\n\t\ttry {\n\t\t\tawait offlineStorage.updateRangeForListAndDeleteObsoleteData(MailSetEntryTypeRef, entriesListId, cutoffId)\n\t\t} finally {\n\t\t\t// We unlock access to the \"ranges\" db here. We lock it in order to prevent race conditions when accessing the \"ranges\" database.\n\t\t\tawait offlineStorage.unlockRangesDbAccess(entriesListId)\n\t\t}\n\n\t\tconst mailSetEntriesToDelete: IdTuple[] = []\n\t\tconst mailSetEntries = await offlineStorage.getWholeList(MailSetEntryTypeRef, entriesListId)\n\t\tfor (let mailSetEntry of mailSetEntries) {\n\t\t\tif (firstBiggerThanSecondCustomId(cutoffId, getElementId(mailSetEntry))) {\n\t\t\t\tmailSetEntriesToDelete.push(mailSetEntry._id)\n\t\t\t}\n\t\t}\n\n\t\tawait offlineStorage.deleteIn(MailSetEntryTypeRef, entriesListId, mailSetEntriesToDelete.map(elementIdPart))\n\t}\n}\n"]}