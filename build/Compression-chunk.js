
//#region src/common/api/worker/Compression.ts
const UNCOMPRESSED_MAX_SIZE = 1048576;
function uncompress(input) {
	const endIndex = input.length;
	let output = new Uint8Array(input.length * 6);
	let j = 0;
	for (let i = 0, n = endIndex; i < n;) {
		let token = input[i++];
		let literals_length = token >> 4;
		if (literals_length > 0) {
			let l$1 = literals_length + 240;
			while (l$1 === 255) {
				l$1 = input[i++];
				literals_length += l$1;
			}
			let end$1 = i + literals_length;
			const sizeNeeded$1 = j + (end$1 - i);
			if (output.length < sizeNeeded$1) {
				const newSize = Math.max(output.length * 2, sizeNeeded$1);
				const newOutput = new Uint8Array(newSize);
				newOutput.set(output);
				output = newOutput;
			}
			while (i < end$1) output[j++] = input[i++];
			if (i === n) break;
		}
		let offset = input[i++] | input[i++] << 8;
		if (offset === 0 || offset > j) throw new Error(`Invalid offset value. i: ${i}, -(i-2): ${-(i - 2)}`);
		let match_length = token & 15;
		let l = match_length + 240;
		while (l === 255) {
			l = input[i++];
			match_length += l;
		}
		let pos = j - offset;
		let end = j + match_length + 4;
		const sizeNeeded = end;
		if (output.length < sizeNeeded) {
			const newSize = Math.max(output.length * 2, sizeNeeded);
			const newOutput = new Uint8Array(newSize);
			newOutput.set(output);
			output = newOutput;
		}
		while (j < end) output[j++] = output[pos++];
	}
	return output.slice(0, j);
}
const MAX_INPUT_SIZE = 2113929216;
const MIN_MATCH = 4;
const HASH_LOG = 16;
const HASH_SHIFT = MIN_MATCH * 8 - HASH_LOG;
const HASH_SIZE = 1 << HASH_LOG;
const COPY_LENGTH = 8;
const MF_LIMIT = COPY_LENGTH + MIN_MATCH;
const SKIP_STRENGTH = 6;
const ML_BITS = 4;
const ML_MASK = (1 << ML_BITS) - 1;
const RUN_BITS = 8 - ML_BITS;
const RUN_MASK = (1 << RUN_BITS) - 1;
const HASHER = 2654435761;
function compressBound(isize) {
	return isize > MAX_INPUT_SIZE ? 0 : isize + isize / 255 + 16 | 0;
}
function compress(source) {
	if (source.length === 0) return new Uint8Array(0);
	const dest = new Uint8Array(compressBound(source.length));
	const hashTable = new Array(HASH_SIZE).fill(0);
	let sourcePos = 0;
	let destPos = 0;
	let anchor = 0;
	let step = 1;
	let findMatchAttempts = (1 << SKIP_STRENGTH) + 3;
	const srcLength = source.length - MF_LIMIT;
	while (sourcePos + MIN_MATCH < srcLength) {
		const sequenceLowBits = source[sourcePos + 1] << 8 | source[sourcePos];
		const sequenceHighBits = source[sourcePos + 3] << 8 | source[sourcePos + 2];
		const hash = Math.imul(sequenceLowBits | sequenceHighBits << 16, HASHER) >>> HASH_SHIFT;
		let ref = hashTable[hash] - 1;
		hashTable[hash] = sourcePos + 1;
		if (ref < 0 || sourcePos - ref >>> 16 > 0 || (source[ref + 3] << 8 | source[ref + 2]) != sequenceHighBits || (source[ref + 1] << 8 | source[ref]) != sequenceLowBits) {
			step = findMatchAttempts++ >> SKIP_STRENGTH;
			sourcePos += step;
			continue;
		}
		findMatchAttempts = (1 << SKIP_STRENGTH) + 3;
		const literals_length$1 = sourcePos - anchor;
		const offset = sourcePos - ref;
		sourcePos += MIN_MATCH;
		ref += MIN_MATCH;
		let match_length = sourcePos;
		while (sourcePos < srcLength && source[sourcePos] == source[ref]) {
			sourcePos++;
			ref++;
		}
		match_length = sourcePos - match_length;
		const token = match_length < ML_MASK ? match_length : ML_MASK;
		if (literals_length$1 >= RUN_MASK) {
			let len;
			dest[destPos++] = (RUN_MASK << ML_BITS) + token;
			for (len = literals_length$1 - RUN_MASK; len > 254; len -= 255) dest[destPos++] = 255;
			dest[destPos++] = len;
		} else dest[destPos++] = (literals_length$1 << ML_BITS) + token;
		for (let i = 0; i < literals_length$1; i++) dest[destPos++] = source[anchor + i];
		dest[destPos++] = offset;
		dest[destPos++] = offset >> 8;
		if (match_length >= ML_MASK) {
			match_length -= ML_MASK;
			while (match_length >= 255) {
				match_length -= 255;
				dest[destPos++] = 255;
			}
			dest[destPos++] = match_length;
		}
		anchor = sourcePos;
	}
	const literals_length = source.length - anchor;
	if (literals_length >= RUN_MASK) {
		let ln = literals_length - RUN_MASK;
		dest[destPos++] = RUN_MASK << ML_BITS;
		while (ln > 254) {
			dest[destPos++] = 255;
			ln -= 255;
		}
		dest[destPos++] = ln;
	} else dest[destPos++] = literals_length << ML_BITS;
	sourcePos = anchor;
	while (sourcePos < source.length) dest[destPos++] = source[sourcePos++];
	return dest.slice(0, destPos);
}

//#endregion
export { UNCOMPRESSED_MAX_SIZE, compress, uncompress };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tcHJlc3Npb24tY2h1bmsuanMiLCJuYW1lcyI6WyJpbnB1dDogVWludDhBcnJheSIsImwiLCJlbmQiLCJzaXplTmVlZGVkIiwiaXNpemU6IG51bWJlciIsInNvdXJjZTogVWludDhBcnJheSIsImxpdGVyYWxzX2xlbmd0aCJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vYXBpL3dvcmtlci9Db21wcmVzc2lvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGx6NCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIHJvdXRpbmVzIGFkb3B0ZWQgZnJvbSB0aGUgbm9kZS1sejQgbGlicmFyeVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BpZXJyZWMvbm9kZS1sejRcbiAqICh3aGljaCBpcyBhIHBvcnQgb2YgdGhlIG9yaWdpbmFsIExaNCBsaWJyYXJ5IGh0dHA6Ly93d3cubHo0Lm9yZykuXG4gKlxuICogbm9kZS1sejQgZG9lcyBhIGxvdCBvZiB0aGluZ3Mgd2UgZG9uJ3QgbmVlZCBhbmQgZHJhZ3MgTm9kZSBCdWZmZXIgYW5kXG4gKiB3aGF0bm90IHdpdGggaXQgYW5kIHN1YnNlcXVlbnRseSB3ZWlnaHRzIDEwM0tCLlxuICpcbiAqIE1vZGlmaWVkIHRvIGluY2x1ZGUgYXV0by1yZXNpemluZyBvZiB0aGUgYnVmZmVyIGFuZCBzbGljaW5nIG9mIHRoZSBkYXRhLlxuICovXG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTIgUGllcnJlIEN1cnRvXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFRoZSBsYXJnZXN0IGEgbWFpbCBib2R5IGNhbiBiZSB0byBzZW5kLiBTZWUgU3RyaW5nVXRpbHMgaW4gVHV0YURiXG4gKi9cbmV4cG9ydCBjb25zdCBVTkNPTVBSRVNTRURfTUFYX1NJWkUgPSAxMDI0ICogMTAyNFxuXG4vKipcbiAqIERlY29kZSBhIGJsb2NrLiBBc3N1bXB0aW9uczogaW5wdXQgY29udGFpbnMgYWxsIHNlcXVlbmNlcyBvZiBhXG4gKiBjaHVuay5cbiAqIEBwYXJhbSBpbnB1dCB7QnVmZmVyfSBpbnB1dCBkYXRhXG4gKiBAdGhyb3dzIG9uIGludmFsaWQgb2Zmc2V0XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSBkZWNvZGVkIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuY29tcHJlc3MoaW5wdXQ6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcblx0Y29uc3QgZW5kSW5kZXggPSBpbnB1dC5sZW5ndGhcblx0bGV0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAqIDYpXG5cdGxldCBqID0gMFxuXG5cdC8vIFByb2Nlc3MgZWFjaCBzZXF1ZW5jZSBpbiB0aGUgaW5jb21pbmcgZGF0YVxuXHRmb3IgKGxldCBpID0gMCwgbiA9IGVuZEluZGV4OyBpIDwgbjsgKSB7XG5cdFx0bGV0IHRva2VuID0gaW5wdXRbaSsrXVxuXHRcdC8vIExpdGVyYWxzXG5cdFx0bGV0IGxpdGVyYWxzX2xlbmd0aCA9IHRva2VuID4+IDRcblxuXHRcdGlmIChsaXRlcmFsc19sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyBsZW5ndGggb2YgbGl0ZXJhbHNcblx0XHRcdGxldCBsID0gbGl0ZXJhbHNfbGVuZ3RoICsgMjQwXG5cblx0XHRcdHdoaWxlIChsID09PSAyNTUpIHtcblx0XHRcdFx0bCA9IGlucHV0W2krK11cblx0XHRcdFx0bGl0ZXJhbHNfbGVuZ3RoICs9IGxcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29weSB0aGUgbGl0ZXJhbHNcblx0XHRcdGxldCBlbmQgPSBpICsgbGl0ZXJhbHNfbGVuZ3RoXG5cdFx0XHRjb25zdCBzaXplTmVlZGVkID0gaiArIChlbmQgLSBpKVxuXG5cdFx0XHRpZiAob3V0cHV0Lmxlbmd0aCA8IHNpemVOZWVkZWQpIHtcblx0XHRcdFx0Y29uc3QgbmV3U2l6ZSA9IE1hdGgubWF4KG91dHB1dC5sZW5ndGggKiAyLCBzaXplTmVlZGVkKVxuXHRcdFx0XHRjb25zdCBuZXdPdXRwdXQgPSBuZXcgVWludDhBcnJheShuZXdTaXplKVxuXHRcdFx0XHRuZXdPdXRwdXQuc2V0KG91dHB1dClcblx0XHRcdFx0b3V0cHV0ID0gbmV3T3V0cHV0XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlIChpIDwgZW5kKSBvdXRwdXRbaisrXSA9IGlucHV0W2krK11cblxuXHRcdFx0Ly8gRW5kIG9mIGJ1ZmZlcj9cblx0XHRcdGlmIChpID09PSBuKSBicmVhayAvLyByZXR1cm4galxuXHRcdH1cblxuXHRcdC8vIE1hdGNoIGNvcHlcblx0XHQvLyAyIGJ5dGVzIG9mZnNldCAobGl0dGxlIGVuZGlhbilcblx0XHRsZXQgb2Zmc2V0ID0gaW5wdXRbaSsrXSB8IChpbnB1dFtpKytdIDw8IDgpXG5cblx0XHQvLyAwIGlzIGFuIGludmFsaWQgb2Zmc2V0IHZhbHVlXG5cdFx0aWYgKG9mZnNldCA9PT0gMCB8fCBvZmZzZXQgPiBqKSB7XG5cdFx0XHQvLyB3YXM6XG5cdFx0XHQvLyByZXR1cm4gLShpIC0gMilcblx0XHRcdHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvZmZzZXQgdmFsdWUuIGk6ICR7aX0sIC0oaS0yKTogJHstKGkgLSAyKX1gKVxuXHRcdH1cblxuXHRcdC8vIGxlbmd0aCBvZiBtYXRjaCBjb3B5XG5cdFx0bGV0IG1hdGNoX2xlbmd0aCA9IHRva2VuICYgMHhmXG5cdFx0bGV0IGwgPSBtYXRjaF9sZW5ndGggKyAyNDBcblxuXHRcdHdoaWxlIChsID09PSAyNTUpIHtcblx0XHRcdGwgPSBpbnB1dFtpKytdXG5cdFx0XHRtYXRjaF9sZW5ndGggKz0gbFxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIG1hdGNoXG5cdFx0bGV0IHBvcyA9IGogLSBvZmZzZXQgLy8gcG9zaXRpb24gb2YgdGhlIG1hdGNoIGNvcHkgaW4gdGhlIGN1cnJlbnQgb3V0cHV0XG5cblx0XHRsZXQgZW5kID0gaiArIG1hdGNoX2xlbmd0aCArIDQgLy8gbWlubWF0Y2ggPSA0XG5cblx0XHRjb25zdCBzaXplTmVlZGVkID0gZW5kXG5cblx0XHRpZiAob3V0cHV0Lmxlbmd0aCA8IHNpemVOZWVkZWQpIHtcblx0XHRcdGNvbnN0IG5ld1NpemUgPSBNYXRoLm1heChvdXRwdXQubGVuZ3RoICogMiwgc2l6ZU5lZWRlZClcblx0XHRcdGNvbnN0IG5ld091dHB1dCA9IG5ldyBVaW50OEFycmF5KG5ld1NpemUpXG5cdFx0XHRuZXdPdXRwdXQuc2V0KG91dHB1dClcblx0XHRcdG91dHB1dCA9IG5ld091dHB1dFxuXHRcdH1cblxuXHRcdHdoaWxlIChqIDwgZW5kKSBvdXRwdXRbaisrXSA9IG91dHB1dFtwb3MrK11cblx0fVxuXG5cdHJldHVybiBvdXRwdXQuc2xpY2UoMCwgailcbn1cblxuY29uc3QgTUFYX0lOUFVUX1NJWkUgPSAweDdlMDAwMDAwXG5jb25zdCBNSU5fTUFUQ0ggPSA0XG5jb25zdCBIQVNIX0xPRyA9IDE2XG5jb25zdCBIQVNIX1NISUZUID0gTUlOX01BVENIICogOCAtIEhBU0hfTE9HXG5jb25zdCBIQVNIX1NJWkUgPSAxIDw8IEhBU0hfTE9HXG5jb25zdCBDT1BZX0xFTkdUSCA9IDhcbmNvbnN0IE1GX0xJTUlUID0gQ09QWV9MRU5HVEggKyBNSU5fTUFUQ0hcbmNvbnN0IFNLSVBfU1RSRU5HVEggPSA2XG5jb25zdCBNTF9CSVRTID0gNFxuY29uc3QgTUxfTUFTSyA9ICgxIDw8IE1MX0JJVFMpIC0gMVxuY29uc3QgUlVOX0JJVFMgPSA4IC0gTUxfQklUU1xuY29uc3QgUlVOX01BU0sgPSAoMSA8PCBSVU5fQklUUykgLSAxXG5jb25zdCBIQVNIRVIgPSAyNjU0NDM1NzYxXG5cbi8vIENvbXByZXNzQm91bmQgcmV0dXJucyB0aGUgbWF4aW11bSBsZW5ndGggb2YgYSBsejQgYmxvY2ssIGdpdmVuIGl0J3MgdW5jb21wcmVzc2VkIGxlbmd0aFxuZnVuY3Rpb24gY29tcHJlc3NCb3VuZChpc2l6ZTogbnVtYmVyKSB7XG5cdHJldHVybiBpc2l6ZSA+IE1BWF9JTlBVVF9TSVpFID8gMCA6IChpc2l6ZSArIGlzaXplIC8gMjU1ICsgMTYpIHwgMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3Moc291cmNlOiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG5cdGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMClcblx0Y29uc3QgZGVzdCA9IG5ldyBVaW50OEFycmF5KGNvbXByZXNzQm91bmQoc291cmNlLmxlbmd0aCkpXG5cdC8vIFY4IG9wdGltaXphdGlvbjogbm9uIHNwYXJzZSBhcnJheSB3aXRoIGludGVnZXJzXG5cdGNvbnN0IGhhc2hUYWJsZSA9IG5ldyBBcnJheShIQVNIX1NJWkUpLmZpbGwoMClcblx0bGV0IHNvdXJjZVBvcyA9IDBcblx0bGV0IGRlc3RQb3MgPSAwXG5cdGxldCBhbmNob3IgPSAwXG5cdGxldCBzdGVwID0gMVxuXHRsZXQgZmluZE1hdGNoQXR0ZW1wdHMgPSAoMSA8PCBTS0lQX1NUUkVOR1RIKSArIDNcblx0Y29uc3Qgc3JjTGVuZ3RoID0gc291cmNlLmxlbmd0aCAtIE1GX0xJTUlUXG5cblx0d2hpbGUgKHNvdXJjZVBvcyArIE1JTl9NQVRDSCA8IHNyY0xlbmd0aCkge1xuXHRcdC8vIEZpbmQgYSBtYXRjaFxuXHRcdC8vIG1pbiBtYXRjaCBvZiA0IGJ5dGVzIGFrYSBzZXF1ZW5jZVxuXHRcdGNvbnN0IHNlcXVlbmNlTG93Qml0cyA9IChzb3VyY2Vbc291cmNlUG9zICsgMV0gPDwgOCkgfCBzb3VyY2Vbc291cmNlUG9zXVxuXHRcdGNvbnN0IHNlcXVlbmNlSGlnaEJpdHMgPSAoc291cmNlW3NvdXJjZVBvcyArIDNdIDw8IDgpIHwgc291cmNlW3NvdXJjZVBvcyArIDJdXG5cdFx0Ly8gY29tcHV0ZSBoYXNoIGZvciB0aGUgY3VycmVudCBzZXF1ZW5jZVxuXHRcdGNvbnN0IGhhc2ggPSBNYXRoLmltdWwoc2VxdWVuY2VMb3dCaXRzIHwgKHNlcXVlbmNlSGlnaEJpdHMgPDwgMTYpLCBIQVNIRVIpID4+PiBIQVNIX1NISUZUXG5cdFx0Ly8gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VxdWVuY2UgbWF0Y2hpbmcgdGhlIGhhc2hcblx0XHQvLyBOQi4gc2luY2UgMiBkaWZmZXJlbnQgc2VxdWVuY2VzIG1heSBoYXZlIHRoZSBzYW1lIGhhc2hcblx0XHQvLyBpdCBpcyBkb3VibGUtY2hlY2tlZCBiZWxvd1xuXHRcdC8vIGRvIC0xIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW5pdGlhbGl6ZWQgYW5kIHVuaW5pdGlhbGl6ZWQgdmFsdWVzXG5cdFx0bGV0IHJlZiA9IGhhc2hUYWJsZVtoYXNoXSAtIDFcblx0XHQvLyBzYXZlIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2VxdWVuY2UgaW4gaGFzaCB0YWJsZVxuXHRcdGhhc2hUYWJsZVtoYXNoXSA9IHNvdXJjZVBvcyArIDFcblxuXHRcdC8vIGZpcnN0IHJlZmVyZW5jZSBvciB3aXRoaW4gNjRrIGxpbWl0IG9yIGN1cnJlbnQgc2VxdWVuY2UgIT09IGhhc2hlZCBvbmU6IG5vIG1hdGNoXG5cdFx0aWYgKFxuXHRcdFx0cmVmIDwgMCB8fFxuXHRcdFx0KHNvdXJjZVBvcyAtIHJlZikgPj4+IDE2ID4gMCB8fFxuXHRcdFx0KChzb3VyY2VbcmVmICsgM10gPDwgOCkgfCBzb3VyY2VbcmVmICsgMl0pICE9IHNlcXVlbmNlSGlnaEJpdHMgfHxcblx0XHRcdCgoc291cmNlW3JlZiArIDFdIDw8IDgpIHwgc291cmNlW3JlZl0pICE9IHNlcXVlbmNlTG93Qml0c1xuXHRcdCkge1xuXHRcdFx0Ly8gaW5jcmVhc2Ugc3RlcCBpZiBub3RoaW5nIGZvdW5kIHdpdGhpbiBsaW1pdFxuXHRcdFx0c3RlcCA9IGZpbmRNYXRjaEF0dGVtcHRzKysgPj4gU0tJUF9TVFJFTkdUSFxuXHRcdFx0c291cmNlUG9zICs9IHN0ZXBcblx0XHRcdGNvbnRpbnVlXG5cdFx0fVxuXG5cdFx0ZmluZE1hdGNoQXR0ZW1wdHMgPSAoMSA8PCBTS0lQX1NUUkVOR1RIKSArIDNcblx0XHQvLyBnb3QgYSBtYXRjaFxuXHRcdGNvbnN0IGxpdGVyYWxzX2xlbmd0aCA9IHNvdXJjZVBvcyAtIGFuY2hvclxuXHRcdGNvbnN0IG9mZnNldCA9IHNvdXJjZVBvcyAtIHJlZlxuXHRcdC8vIE1JTl9NQVRDSCBhbHJlYWR5IHZlcmlmaWVkXG5cdFx0c291cmNlUG9zICs9IE1JTl9NQVRDSFxuXHRcdHJlZiArPSBNSU5fTUFUQ0hcblx0XHQvLyBtb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoICg+PU1JTl9NQVRDSClcblx0XHRsZXQgbWF0Y2hfbGVuZ3RoID0gc291cmNlUG9zXG5cblx0XHR3aGlsZSAoc291cmNlUG9zIDwgc3JjTGVuZ3RoICYmIHNvdXJjZVtzb3VyY2VQb3NdID09IHNvdXJjZVtyZWZdKSB7XG5cdFx0XHRzb3VyY2VQb3MrK1xuXHRcdFx0cmVmKytcblx0XHR9XG5cblx0XHQvLyBtYXRjaCBsZW5ndGhcblx0XHRtYXRjaF9sZW5ndGggPSBzb3VyY2VQb3MgLSBtYXRjaF9sZW5ndGhcblx0XHQvLyB0b2tlblxuXHRcdGNvbnN0IHRva2VuID0gbWF0Y2hfbGVuZ3RoIDwgTUxfTUFTSyA/IG1hdGNoX2xlbmd0aCA6IE1MX01BU0tcblxuXHRcdC8vIGVuY29kZSBsaXRlcmFscyBsZW5ndGhcblx0XHRpZiAobGl0ZXJhbHNfbGVuZ3RoID49IFJVTl9NQVNLKSB7XG5cdFx0XHRsZXQgbGVuXG5cdFx0XHQvLyBhZGQgbWF0Y2ggbGVuZ3RoIHRvIHRoZSB0b2tlblxuXHRcdFx0ZGVzdFtkZXN0UG9zKytdID0gKFJVTl9NQVNLIDw8IE1MX0JJVFMpICsgdG9rZW5cblxuXHRcdFx0Zm9yIChsZW4gPSBsaXRlcmFsc19sZW5ndGggLSBSVU5fTUFTSzsgbGVuID4gMjU0OyBsZW4gLT0gMjU1KSB7XG5cdFx0XHRcdGRlc3RbZGVzdFBvcysrXSA9IDI1NVxuXHRcdFx0fVxuXG5cdFx0XHRkZXN0W2Rlc3RQb3MrK10gPSBsZW5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYWRkIG1hdGNoIGxlbmd0aCB0byB0aGUgdG9rZW5cblx0XHRcdGRlc3RbZGVzdFBvcysrXSA9IChsaXRlcmFsc19sZW5ndGggPDwgTUxfQklUUykgKyB0b2tlblxuXHRcdH1cblxuXHRcdC8vIHdyaXRlIGxpdGVyYWxzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXRlcmFsc19sZW5ndGg7IGkrKykge1xuXHRcdFx0ZGVzdFtkZXN0UG9zKytdID0gc291cmNlW2FuY2hvciArIGldXG5cdFx0fVxuXG5cdFx0Ly8gZW5jb2RlIG9mZnNldFxuXHRcdGRlc3RbZGVzdFBvcysrXSA9IG9mZnNldFxuXHRcdGRlc3RbZGVzdFBvcysrXSA9IG9mZnNldCA+PiA4XG5cblx0XHQvLyBlbmNvZGUgbWF0Y2ggbGVuZ3RoXG5cdFx0aWYgKG1hdGNoX2xlbmd0aCA+PSBNTF9NQVNLKSB7XG5cdFx0XHRtYXRjaF9sZW5ndGggLT0gTUxfTUFTS1xuXG5cdFx0XHR3aGlsZSAobWF0Y2hfbGVuZ3RoID49IDI1NSkge1xuXHRcdFx0XHRtYXRjaF9sZW5ndGggLT0gMjU1XG5cdFx0XHRcdGRlc3RbZGVzdFBvcysrXSA9IDI1NVxuXHRcdFx0fVxuXG5cdFx0XHRkZXN0W2Rlc3RQb3MrK10gPSBtYXRjaF9sZW5ndGhcblx0XHR9XG5cblx0XHRhbmNob3IgPSBzb3VyY2VQb3Ncblx0fVxuXG5cdC8vIFdyaXRlIGxhc3QgbGl0ZXJhbHNcblx0Ly8gZW5jb2RlIGxpdGVyYWxzIGxlbmd0aFxuXHRjb25zdCBsaXRlcmFsc19sZW5ndGggPSBzb3VyY2UubGVuZ3RoIC0gYW5jaG9yXG5cblx0aWYgKGxpdGVyYWxzX2xlbmd0aCA+PSBSVU5fTUFTSykge1xuXHRcdGxldCBsbiA9IGxpdGVyYWxzX2xlbmd0aCAtIFJVTl9NQVNLXG5cdFx0Ly8gYWRkIG1hdGNoIGxlbmd0aCB0byB0aGUgdG9rZW5cblx0XHRkZXN0W2Rlc3RQb3MrK10gPSBSVU5fTUFTSyA8PCBNTF9CSVRTXG5cblx0XHR3aGlsZSAobG4gPiAyNTQpIHtcblx0XHRcdGRlc3RbZGVzdFBvcysrXSA9IDI1NVxuXHRcdFx0bG4gLT0gMjU1XG5cdFx0fVxuXG5cdFx0ZGVzdFtkZXN0UG9zKytdID0gbG5cblx0fSBlbHNlIHtcblx0XHQvLyBhZGQgbWF0Y2ggbGVuZ3RoIHRvIHRoZSB0b2tlblxuXHRcdGRlc3RbZGVzdFBvcysrXSA9IGxpdGVyYWxzX2xlbmd0aCA8PCBNTF9CSVRTXG5cdH1cblxuXHQvLyB3cml0ZSBsaXRlcmFsc1xuXHRzb3VyY2VQb3MgPSBhbmNob3JcblxuXHR3aGlsZSAoc291cmNlUG9zIDwgc291cmNlLmxlbmd0aCkge1xuXHRcdGRlc3RbZGVzdFBvcysrXSA9IHNvdXJjZVtzb3VyY2VQb3MrK11cblx0fVxuXG5cdHJldHVybiBkZXN0LnNsaWNlKDAsIGRlc3RQb3MpXG59XG5cbmV4cG9ydCBjbGFzcyB6Q29tcHJlc3Npb25FcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG5cdFx0c3VwZXIobWVzc2FnZSlcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOztNQW9DYSx3QkFBd0I7QUFTOUIsU0FBUyxXQUFXQSxPQUErQjtDQUN6RCxNQUFNLFdBQVcsTUFBTTtDQUN2QixJQUFJLFNBQVMsSUFBSSxXQUFXLE1BQU0sU0FBUztDQUMzQyxJQUFJLElBQUk7QUFHUixNQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxJQUFJLElBQUs7RUFDdEMsSUFBSSxRQUFRLE1BQU07RUFFbEIsSUFBSSxrQkFBa0IsU0FBUztBQUUvQixNQUFJLGtCQUFrQixHQUFHO0dBRXhCLElBQUlDLE1BQUksa0JBQWtCO0FBRTFCLFVBQU9BLFFBQU0sS0FBSztBQUNqQixVQUFJLE1BQU07QUFDVix1QkFBbUJBO0dBQ25CO0dBR0QsSUFBSUMsUUFBTSxJQUFJO0dBQ2QsTUFBTUMsZUFBYSxLQUFLRCxRQUFNO0FBRTlCLE9BQUksT0FBTyxTQUFTQyxjQUFZO0lB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