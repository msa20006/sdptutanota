import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { groupBy, partition } from "./dist2-chunk.js";
import { MailSetKind, isFolder } from "./TutanotaConstants-chunk.js";
import { elementIdPart, getElementId, isSameId } from "./EntityUtils-chunk.js";

//#region src/common/api/common/utils/Scheduler.ts
const SET_TIMEOUT_LIMIT = 2147483647;
var SchedulerImpl = class {
	/**
	* This points from the originally scheduled timeout to the most recent timeout
	*/
	bridgedTimeouts;
	constructor(dateProvider, systemTimeout, systemInterval) {
		this.dateProvider = dateProvider;
		this.systemTimeout = systemTimeout;
		this.systemInterval = systemInterval;
		this.bridgedTimeouts = new Map();
	}
	scheduleAt(callback, date) {
		let timeoutId;
		const wrappedCallback = () => {
			this.bridgedTimeouts.delete(timeoutId);
			callback();
		};
		timeoutId = this.scheduleAtInternal(wrappedCallback, date);
		return timeoutId;
	}
	scheduleAfter(thunk, after) {
		const date = new Date(this.dateProvider.now() + after);
		return this.scheduleAt(thunk, date);
	}
	/** We have separate internal version which does not re-wrap the thunk. */
	scheduleAtInternal(thunk, date) {
		const now = this.dateProvider.now();
		const then = date.getTime();
		const diff = Math.max(then - now, 0);
		let timeoutId;
		if (diff > SET_TIMEOUT_LIMIT) timeoutId = this.systemTimeout.setTimeout(() => {
			const newTimeoutId = this.scheduleAtInternal(thunk, date);
			this.bridgedTimeouts.set(timeoutId, newTimeoutId);
		}, SET_TIMEOUT_LIMIT);
else timeoutId = this.systemTimeout.setTimeout(thunk, diff);
		return timeoutId;
	}
	unscheduleTimeout(id) {
		const rescheduledId = this.bridgedTimeouts.get(id) || id;
		this.bridgedTimeouts.delete(rescheduledId);
		return this.systemTimeout.clearTimeout(rescheduledId);
	}
	schedulePeriodic(thunk, ms) {
		if (ms > SET_TIMEOUT_LIMIT) throw new Error("Attempting to schedule periodic task but the period is too big: " + ms);
		return this.systemInterval.setInterval(thunk, ms);
	}
	unschedulePeriodic(id) {
		this.systemInterval.clearInterval(id);
	}
};

//#endregion
//#region src/common/api/common/utils/NoZoneDateProvider.ts
var NoZoneDateProvider = class {
	now() {
		return Date.now();
	}
	timeZone() {
		throw new ProgrammingError("timeZone is not available in worker");
	}
};

//#endregion
//#region src/common/api/common/DomainConfigProvider.ts
var DomainConfigProvider = class {
	/** Get domain config for the current domain (staticUrl or the one the app is running on). */
	getCurrentDomainConfig() {
		const url = new URL(env.staticUrl ?? location.href);
		const port = url.port;
		const hostname = url.hostname;
		const protocol = url.protocol;
		return this.getDomainConfigForHostname(hostname, protocol, port);
	}
	getDomainConfigForHostname(hostname, protocol = "https:", port) {
		const staticConfig = env.domainConfigs[hostname];
		if (staticConfig) return staticConfig;
else {
			const fullHostName = hostname + (port ? `:${port}` : "");
			const dynamicConfig = env.domainConfigs["{hostname}"];
			const entries = Object.entries(dynamicConfig).map(([key, value]) => {
				const replacedValue = typeof value === "string" ? value.replace("{hostname}", fullHostName).replace("{protocol}", protocol) : value;
				return [key, replacedValue];
			});
			return Object.fromEntries(entries);
		}
	}
};

//#endregion
//#region src/common/api/common/mail/FolderSystem.ts
var FolderSystem = class {
	systemSubtrees;
	customSubtrees;
	importedMailSet;
	constructor(mailSets) {
		const [folders, nonFolders] = partition(mailSets, (f) => isFolder(f));
		const folderByParent = groupBy(folders, (folder) => folder.parentFolder ? elementIdPart(folder.parentFolder) : null);
		const topLevelFolders = folders.filter((f) => f.parentFolder == null);
		const [systemFolders, customFolders] = partition(topLevelFolders, (f) => f.folderType !== MailSetKind.CUSTOM);
		this.importedMailSet = nonFolders.find((f) => f.folderType === MailSetKind.Imported) || null;
		this.systemSubtrees = systemFolders.sort(compareSystem).map((f) => this.makeSubtree(folderByParent, f, compareCustom));
		this.customSubtrees = customFolders.sort(compareCustom).map((f) => this.makeSubtree(folderByParent, f, compareCustom));
	}
	getIndentedList(excludeFolder = null) {
		return [...this.getIndentedFolderList(this.systemSubtrees, excludeFolder), ...this.getIndentedFolderList(this.customSubtrees, excludeFolder)];
	}
	/** Search for a specific folder type. Some mailboxes might not have some system folders! */
	getSystemFolderByType(type) {
		return this.systemSubtrees.find((f) => f.folder.folderType === type)?.folder ?? null;
	}
	getFolderById(folderId) {
		const subtree = this.getFolderByIdInSubtrees(this.systemSubtrees, folderId) ?? this.getFolderByIdInSubtrees(this.customSubtrees, folderId);
		return subtree?.folder ?? null;
	}
	getFolderByMail(mail) {
		const sets = mail.sets;
		for (const setId of sets) {
			const folder = this.getFolderById(elementIdPart(setId));
			if (folder != null) return folder;
		}
		return null;
	}
	/**
	* Returns the children of a parent (applies only to custom folders)
	* if no parent is given, the top level custom folders are returned
	*/
	getCustomFoldersOfParent(parent) {
		if (parent) {
			const parentFolder = this.getFolderByIdInSubtrees([...this.customSubtrees, ...this.systemSubtrees], elementIdPart(parent));
			return parentFolder ? parentFolder.children.map((child) => child.folder) : [];
		} else return this.customSubtrees.map((subtree) => subtree.folder);
	}
	getDescendantFoldersOfParent(parent) {
		const parentFolder = this.getFolderByIdInSubtrees([...this.customSubtrees, ...this.systemSubtrees], elementIdPart(parent));
		if (parentFolder) return this.getIndentedFolderList([parentFolder]).slice(1);
else return [];
	}
	/** returns all parents of the folder, including the folder itself */
	getPathToFolder(folderId) {
		return this.getPathToFolderInSubtrees(this.systemSubtrees, folderId) ?? this.getPathToFolderInSubtrees(this.customSubtrees, folderId) ?? [];
	}
	checkFolderForAncestor(folder, potentialAncestorId) {
		let currentFolderPointer = folder;
		while (true) {
			if (currentFolderPointer?.parentFolder == null) return false;
else if (isSameId(currentFolderPointer.parentFolder, potentialAncestorId)) return true;
			currentFolderPointer = this.getFolderById(elementIdPart(currentFolderPointer.parentFolder));
		}
	}
	getIndentedFolderList(subtrees, excludeFolder = null, currentLevel = 0) {
		const plainList = [];
		for (const subtree of subtrees) if (!excludeFolder || !isSameId(subtree.folder._id, excludeFolder._id)) {
			plainList.push({
				level: currentLevel,
				folder: subtree.folder
			});
			plainList.push(...this.getIndentedFolderList(subtree.children, excludeFolder, currentLevel + 1));
		}
		return plainList;
	}
	getIndentedSystemList() {
		return this.systemSubtrees.map((subtree) => {
			return {
				level: 0,
				folder: subtree.folder
			};
		});
	}
	getFolderByIdInSubtrees(systems, folderId) {
		return this.getFolderBy(systems, (system) => isSameId(getElementId(system.folder), folderId));
	}
	getFolderBy(systems, predicate) {
		const topLevel = systems.find(predicate);
		if (topLevel) return topLevel;
else for (const topLevelSystem of systems) {
			const found = this.getFolderBy(topLevelSystem.children, predicate);
			if (found) return found;
		}
		return null;
	}
	getPathToFolderInSubtrees(systems, folderId) {
		for (const system of systems) {
			if (isSameId(system.folder._id, folderId)) return [system.folder];
			const subpath = this.getPathToFolderInSubtrees(system.children, folderId);
			if (subpath) return [system.folder].concat(...subpath);
		}
		return null;
	}
	makeSubtree(folderByParent, parent, comparator) {
		const childrenFolders = folderByParent.get(getElementId(parent));
		if (childrenFolders) {
			const childSystems = childrenFolders.slice().sort(comparator).map((child) => this.makeSubtree(folderByParent, child, comparator));
			return {
				folder: parent,
				children: childSystems
			};
		} else return {
			folder: parent,
			children: []
		};
	}
};
function compareCustom(folder1, folder2) {
	return folder1.name.localeCompare(folder2.name);
}
const folderTypeToOrder = {
	[MailSetKind.INBOX]: 0,
	[MailSetKind.DRAFT]: 1,
	[MailSetKind.SENT]: 2,
	[MailSetKind.TRASH]: 4,
	[MailSetKind.ARCHIVE]: 5,
	[MailSetKind.SPAM]: 6,
	[MailSetKind.ALL]: 7
};
function compareSystem(folder1, folder2) {
	const order1 = folderTypeToOrder[folder1.folderType] ?? 7;
	const order2 = folderTypeToOrder[folder2.folderType] ?? 7;
	return order1 - order2;
}

//#endregion
export { DomainConfigProvider, FolderSystem, NoZoneDateProvider, SchedulerImpl };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9sZGVyU3lzdGVtLWNodW5rLmpzIiwibmFtZXMiOlsiZGF0ZVByb3ZpZGVyOiBEYXRlUHJvdmlkZXIiLCJzeXN0ZW1UaW1lb3V0OiBTeXN0ZW1UaW1lb3V0Iiwic3lzdGVtSW50ZXJ2YWw6IFN5c3RlbUludGVydmFsIiwiY2FsbGJhY2s6IFRodW5rIiwiZGF0ZTogRGF0ZSIsInRpbWVvdXRJZDogVGltZW91dElEIiwidGh1bms6IFRodW5rIiwiYWZ0ZXI6IG51bWJlciIsImlkOiBTY2hlZHVsZWRUaW1lb3V0SWQiLCJtczogbnVtYmVyIiwiaWQ6IFNjaGVkdWxlZFBlcmlvZGljSWQiLCJob3N0bmFtZTogc3RyaW5nIiwicHJvdG9jb2w6IHN0cmluZyIsInBvcnQ/OiBzdHJpbmciLCJtYWlsU2V0czogcmVhZG9ubHkgTWFpbEZvbGRlcltdIiwiZXhjbHVkZUZvbGRlcjogTWFpbEZvbGRlciB8IG51bGwiLCJ0eXBlOiBPbWl0PE1haWxTZXRLaW5kLCBNYWlsU2V0S2luZC5DVVNUT00+IiwiZm9sZGVySWQ6IElkIiwibWFpbDogTWFpbCIsInBhcmVudDogSWRUdXBsZSB8IG51bGwiLCJwYXJlbnQ6IElkVHVwbGUiLCJmb2xkZXJJZDogSWRUdXBsZSIsImZvbGRlcjogTWFpbEZvbGRlciIsInBvdGVudGlhbEFuY2VzdG9ySWQ6IElkVHVwbGUiLCJjdXJyZW50Rm9sZGVyUG9pbnRlcjogTWFpbEZvbGRlciB8IG51bGwiLCJzdWJ0cmVlczogUmVhZG9ubHlBcnJheTxGb2xkZXJTdWJ0cmVlPiIsImN1cnJlbnRMZXZlbDogbnVtYmVyIiwicGxhaW5MaXN0OiBJbmRlbnRlZEZvbGRlcltdIiwic3lzdGVtczogUmVhZG9ubHlBcnJheTxGb2xkZXJTdWJ0cmVlPiIsInByZWRpY2F0ZTogKHN1YnRyZWU6IEZvbGRlclN1YnRyZWUpID0+IGJvb2xlYW4iLCJzeXN0ZW1zOiByZWFkb25seSBGb2xkZXJTdWJ0cmVlW10iLCJmb2xkZXJCeVBhcmVudDogTWFwPElkIHwgbnVsbCwgcmVhZG9ubHkgTWFpbEZvbGRlcltdPiIsInBhcmVudDogTWFpbEZvbGRlciIsImNvbXBhcmF0b3I6IEZvbGRlckNvbXBhcmF0b3IiLCJmb2xkZXIxOiBNYWlsRm9sZGVyIiwiZm9sZGVyMjogTWFpbEZvbGRlciIsImZvbGRlclR5cGVUb09yZGVyOiBSZWNvcmQ8U3lzdGVtTWFpbEZvbGRlclR5cGVzLCBudW1iZXI+Il0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9hcGkvY29tbW9uL3V0aWxzL1NjaGVkdWxlci50cyIsIi4uL3NyYy9jb21tb24vYXBpL2NvbW1vbi91dGlscy9Ob1pvbmVEYXRlUHJvdmlkZXIudHMiLCIuLi9zcmMvY29tbW9uL2FwaS9jb21tb24vRG9tYWluQ29uZmlnUHJvdmlkZXIudHMiLCIuLi9zcmMvY29tbW9uL2FwaS9jb21tb24vbWFpbC9Gb2xkZXJTeXN0ZW0udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBUaHVuayB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgRGF0ZVByb3ZpZGVyIH0gZnJvbSBcIi4uL0RhdGVQcm92aWRlci5qc1wiXG5cbmV4cG9ydCB0eXBlIFNjaGVkdWxlZFRpbWVvdXRJZCA9IFRpbWVvdXRJRFxuZXhwb3J0IHR5cGUgU2NoZWR1bGVkUGVyaW9kaWNJZCA9IFRpbWVvdXRJRFxuXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVkdWxlciB7XG5cdHNjaGVkdWxlQXQodGh1bms6IFRodW5rLCBkYXRlOiBEYXRlKTogU2NoZWR1bGVkVGltZW91dElkXG5cblx0dW5zY2hlZHVsZVRpbWVvdXQoaWQ6IFNjaGVkdWxlZFRpbWVvdXRJZCk6IHZvaWRcblxuXHRzY2hlZHVsZUFmdGVyKHRodW5rOiBUaHVuaywgYWZ0ZXI6IG51bWJlcik6IFNjaGVkdWxlZFRpbWVvdXRJZFxuXG5cdHNjaGVkdWxlUGVyaW9kaWModGh1bms6IFRodW5rLCBwZXJpb2Q6IG51bWJlcik6IFNjaGVkdWxlZFBlcmlvZGljSWRcblxuXHR1bnNjaGVkdWxlUGVyaW9kaWMoaWQ6IFNjaGVkdWxlZFBlcmlvZGljSWQpOiB2b2lkXG59XG5cbi8qKlxuICogc2V0VGltZW91dCgpIG9ubHkgd29ya3Mgb24gMzJiaXQgaW50ZWdlcnMsIGl0IGRvZXNuJ3QgZG8gd2hhdCB5b3UgZXhwZWN0IG9uIGxvbmdlciBpbnRlcnZhbHMuIElmIHlvdSB1c2UgU2NoZWR1bGVyIHlvdSBzaG91bGQgbm90XG4gKiB3b3JyeSBhYm91dCBpdCwgbWFpbmx5IGV4cG9ydGVkIGZvciB0ZXN0cy5cbiAqICovXG5leHBvcnQgY29uc3QgU0VUX1RJTUVPVVRfTElNSVQgPSAweDdmZmZmZmZmXG5cbi8qKiBEZWZhdWx0IGltcGwgb2YgdGltZW91dCBmdW5jdGlvbnMsIHVzZWZ1bCBmb3IgdGVzdGluZyAqL1xuZXhwb3J0IHR5cGUgU3lzdGVtVGltZW91dCA9IHtcblx0Ly8gQ29weWluZyBpdCBiZWNhdXNlIHRzIGhhcyBzb21lIHdlaXJkIHByb3BlcnRpZXMgYXR0YWNoIHRvIGl0IGluIG5vZGUgdHNsaWIuXG5cdC8vIG5vLWFyZyB2ZXJzaW9uIGJlY2F1c2UgbGFtYmFkYXMgZXhpc3QuXG5cdHNldFRpbWVvdXQoY2FsbGJhY2s6ICgpID0+IHZvaWQsIG1zOiBudW1iZXIpOiBudW1iZXJcblx0Y2xlYXJUaW1lb3V0OiB0eXBlb2YgY2xlYXJUaW1lb3V0XG59XG5cbi8qKiBEZWZhdWx0IGltcGwgb2YgaW50ZXJ2YWwgZnVuY3Rpb25zLCB1c2VmdWwgZm9yIHRlc3RpbmcgKi9cbmV4cG9ydCB0eXBlIFN5c3RlbUludGVydmFsID0ge1xuXHQvLyBDb3B5aW5nIGl0IGJlY2F1c2UgdHMgaGFzIHNvbWUgd2VpcmQgcHJvcGVydGllcyBhdHRhY2ggdG8gaXQgaW4gbm9kZSB0c2xpYi5cblx0Ly8gbm8tYXJnIHZlcnNpb24gYmVjYXVzZSBsYW1iYWRhcyBleGlzdC5cblx0c2V0SW50ZXJ2YWwoY2FsbGJhY2s6ICgpID0+IHZvaWQsIG1zOiBudW1iZXIpOiBudW1iZXJcblx0Y2xlYXJJbnRlcnZhbDogdHlwZW9mIGNsZWFySW50ZXJ2YWxcbn1cblxuZXhwb3J0IGNsYXNzIFNjaGVkdWxlckltcGwgaW1wbGVtZW50cyBTY2hlZHVsZXIge1xuXHQvKipcblx0ICogVGhpcyBwb2ludHMgZnJvbSB0aGUgb3JpZ2luYWxseSBzY2hlZHVsZWQgdGltZW91dCB0byB0aGUgbW9zdCByZWNlbnQgdGltZW91dFxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBicmlkZ2VkVGltZW91dHM6IE1hcDxTY2hlZHVsZWRUaW1lb3V0SWQsIFNjaGVkdWxlZFRpbWVvdXRJZD5cblxuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGRhdGVQcm92aWRlcjogRGF0ZVByb3ZpZGVyLCBwcml2YXRlIHJlYWRvbmx5IHN5c3RlbVRpbWVvdXQ6IFN5c3RlbVRpbWVvdXQsIHByaXZhdGUgcmVhZG9ubHkgc3lzdGVtSW50ZXJ2YWw6IFN5c3RlbUludGVydmFsKSB7XG5cdFx0dGhpcy5icmlkZ2VkVGltZW91dHMgPSBuZXcgTWFwKClcblx0fVxuXG5cdHNjaGVkdWxlQXQoY2FsbGJhY2s6IFRodW5rLCBkYXRlOiBEYXRlKTogU2NoZWR1bGVkVGltZW91dElkIHtcblx0XHRsZXQgdGltZW91dElkOiBUaW1lb3V0SURcblxuXHRcdC8vIENhbGwgdGhlIHRodW5rIGFuZCBjbGVhbiB1cCB0aW1lb3V0IGluIHRoZSBtYXBcblx0XHRjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLmJyaWRnZWRUaW1lb3V0cy5kZWxldGUodGltZW91dElkKVxuXG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXG5cdFx0dGltZW91dElkID0gdGhpcy5zY2hlZHVsZUF0SW50ZXJuYWwod3JhcHBlZENhbGxiYWNrLCBkYXRlKVxuXHRcdHJldHVybiB0aW1lb3V0SWRcblx0fVxuXG5cdHNjaGVkdWxlQWZ0ZXIodGh1bms6IFRodW5rLCBhZnRlcjogbnVtYmVyKTogU2NoZWR1bGVkVGltZW91dElkIHtcblx0XHRjb25zdCBkYXRlID0gbmV3IERhdGUodGhpcy5kYXRlUHJvdmlkZXIubm93KCkgKyBhZnRlcilcblx0XHRyZXR1cm4gdGhpcy5zY2hlZHVsZUF0KHRodW5rLCBkYXRlKVxuXHR9XG5cblx0LyoqIFdlIGhhdmUgc2VwYXJhdGUgaW50ZXJuYWwgdmVyc2lvbiB3aGljaCBkb2VzIG5vdCByZS13cmFwIHRoZSB0aHVuay4gKi9cblx0cHJpdmF0ZSBzY2hlZHVsZUF0SW50ZXJuYWwodGh1bms6IFRodW5rLCBkYXRlOiBEYXRlKTogU2NoZWR1bGVkVGltZW91dElkIHtcblx0XHRjb25zdCBub3cgPSB0aGlzLmRhdGVQcm92aWRlci5ub3coKVxuXG5cdFx0Y29uc3QgdGhlbiA9IGRhdGUuZ2V0VGltZSgpXG5cdFx0Y29uc3QgZGlmZiA9IE1hdGgubWF4KHRoZW4gLSBub3csIDApXG5cdFx0bGV0IHRpbWVvdXRJZDogVGltZW91dElEXG5cblx0XHRpZiAoZGlmZiA+IFNFVF9USU1FT1VUX0xJTUlUKSB7XG5cdFx0XHR0aW1lb3V0SWQgPSB0aGlzLnN5c3RlbVRpbWVvdXQuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IG5ld1RpbWVvdXRJZCA9IHRoaXMuc2NoZWR1bGVBdEludGVybmFsKHRodW5rLCBkYXRlKVxuXG5cdFx0XHRcdHRoaXMuYnJpZGdlZFRpbWVvdXRzLnNldCh0aW1lb3V0SWQsIG5ld1RpbWVvdXRJZClcblx0XHRcdH0sIFNFVF9USU1FT1VUX0xJTUlUKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aW1lb3V0SWQgPSB0aGlzLnN5c3RlbVRpbWVvdXQuc2V0VGltZW91dCh0aHVuaywgZGlmZilcblx0XHR9XG5cblx0XHRyZXR1cm4gdGltZW91dElkXG5cdH1cblxuXHR1bnNjaGVkdWxlVGltZW91dChpZDogU2NoZWR1bGVkVGltZW91dElkKTogdm9pZCB7XG5cdFx0Y29uc3QgcmVzY2hlZHVsZWRJZCA9IHRoaXMuYnJpZGdlZFRpbWVvdXRzLmdldChpZCkgfHwgaWRcblxuXHRcdHRoaXMuYnJpZGdlZFRpbWVvdXRzLmRlbGV0ZShyZXNjaGVkdWxlZElkKVxuXG5cdFx0cmV0dXJuIHRoaXMuc3lzdGVtVGltZW91dC5jbGVhclRpbWVvdXQocmVzY2hlZHVsZWRJZClcblx0fVxuXG5cdHNjaGVkdWxlUGVyaW9kaWModGh1bms6IFRodW5rLCBtczogbnVtYmVyKTogU2NoZWR1bGVkUGVyaW9kaWNJZCB7XG5cdFx0Ly8gSW50ZXJ2YWxzIGJpZ2dlciB0aGFuIDMyIGJpdCBpbnQgd2lsbCBub3Qgd29yayBvdXQtb2YtdGhlLWJveCBhbmQgd2UgZG8gbm90IHdhbnQgdG8gaW1wbGVtZW50IGJyaWRnaW5nIGZvciB0aGVtIGFzIHRoaXMgaXMgYSB2ZXJ5IHJhcmUgY2FzZSBhbmQgaXNcblx0XHQvLyB1c3VhbGx5IGEgYnVnLlxuXHRcdGlmIChtcyA+IFNFVF9USU1FT1VUX0xJTUlUKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHNjaGVkdWxlIHBlcmlvZGljIHRhc2sgYnV0IHRoZSBwZXJpb2QgaXMgdG9vIGJpZzogXCIgKyBtcylcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc3lzdGVtSW50ZXJ2YWwuc2V0SW50ZXJ2YWwodGh1bmssIG1zKVxuXHR9XG5cblx0dW5zY2hlZHVsZVBlcmlvZGljKGlkOiBTY2hlZHVsZWRQZXJpb2RpY0lkKSB7XG5cdFx0dGhpcy5zeXN0ZW1JbnRlcnZhbC5jbGVhckludGVydmFsKGlkKVxuXHR9XG59XG4iLCJpbXBvcnQgeyBQcm9ncmFtbWluZ0Vycm9yIH0gZnJvbSBcIi4uL2Vycm9yL1Byb2dyYW1taW5nRXJyb3IuanNcIlxuaW1wb3J0IHsgRGF0ZVByb3ZpZGVyIH0gZnJvbSBcIi4uL0RhdGVQcm92aWRlci5qc1wiXG5cbmV4cG9ydCBjbGFzcyBOb1pvbmVEYXRlUHJvdmlkZXIgaW1wbGVtZW50cyBEYXRlUHJvdmlkZXIge1xuXHRub3coKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gRGF0ZS5ub3coKVxuXHR9XG5cblx0dGltZVpvbmUoKTogc3RyaW5nIHtcblx0XHR0aHJvdyBuZXcgUHJvZ3JhbW1pbmdFcnJvcihcInRpbWVab25lIGlzIG5vdCBhdmFpbGFibGUgaW4gd29ya2VyXCIpXG5cdH1cbn1cbiIsImV4cG9ydCBjbGFzcyBEb21haW5Db25maWdQcm92aWRlciB7XG5cdC8qKiBHZXQgZG9tYWluIGNvbmZpZyBmb3IgdGhlIGN1cnJlbnQgZG9tYWluIChzdGF0aWNVcmwgb3IgdGhlIG9uZSB0aGUgYXBwIGlzIHJ1bm5pbmcgb24pLiAqL1xuXHRnZXRDdXJyZW50RG9tYWluQ29uZmlnKCk6IERvbWFpbkNvbmZpZyB7XG5cdFx0Ly8gSXQgaXMgYW1iaWd1b3VzIHdoYXQgdG8gZG8gd2hlbiB3ZSBydW4gd2Vic2l0ZSBvbiBvbmUgZG9tYWluIGJ1dCBoYXZlIHN0YXRpYyBVUkwgZm9yIGFub3RoZXJcblx0XHQvLyBvbmUgYnV0IHRoaXMgYWN0dWFsbHkgc2hvdWxkbid0IGhhcHBlbi5cblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKGVudi5zdGF0aWNVcmwgPz8gbG9jYXRpb24uaHJlZilcblx0XHRjb25zdCBwb3J0ID0gdXJsLnBvcnRcblx0XHRjb25zdCBob3N0bmFtZSA9IHVybC5ob3N0bmFtZVxuXHRcdGNvbnN0IHByb3RvY29sID0gdXJsLnByb3RvY29sXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RG9tYWluQ29uZmlnRm9ySG9zdG5hbWUoaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0KVxuXHR9XG5cblx0Z2V0RG9tYWluQ29uZmlnRm9ySG9zdG5hbWUoaG9zdG5hbWU6IHN0cmluZywgcHJvdG9jb2w6IHN0cmluZyA9IFwiaHR0cHM6XCIsIHBvcnQ/OiBzdHJpbmcpOiBEb21haW5Db25maWcge1xuXHRcdGNvbnN0IHN0YXRpY0NvbmZpZyA9IGVudi5kb21haW5Db25maWdzW2hvc3RuYW1lXVxuXHRcdGlmIChzdGF0aWNDb25maWcpIHtcblx0XHRcdHJldHVybiBzdGF0aWNDb25maWdcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZnVsbEhvc3ROYW1lID0gaG9zdG5hbWUgKyAocG9ydCA/IGA6JHtwb3J0fWAgOiBcIlwiKVxuXHRcdFx0Y29uc3QgZHluYW1pY0NvbmZpZyA9IGVudi5kb21haW5Db25maWdzW1wie2hvc3RuYW1lfVwiXVxuXHRcdFx0Y29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGR5bmFtaWNDb25maWcpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VkVmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5yZXBsYWNlKFwie2hvc3RuYW1lfVwiLCBmdWxsSG9zdE5hbWUpLnJlcGxhY2UoXCJ7cHJvdG9jb2x9XCIsIHByb3RvY29sKSA6IHZhbHVlXG5cdFx0XHRcdHJldHVybiBba2V5LCByZXBsYWNlZFZhbHVlXVxuXHRcdFx0fSlcblx0XHRcdHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcylcblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCB7IGdyb3VwQnksIHBhcnRpdGlvbiB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgTWFpbCwgTWFpbEZvbGRlciB9IGZyb20gXCIuLi8uLi9lbnRpdGllcy90dXRhbm90YS9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBpc0ZvbGRlciwgTWFpbFNldEtpbmQgfSBmcm9tIFwiLi4vVHV0YW5vdGFDb25zdGFudHMuanNcIlxuaW1wb3J0IHsgZWxlbWVudElkUGFydCwgZ2V0RWxlbWVudElkLCBpc1NhbWVJZCB9IGZyb20gXCIuLi91dGlscy9FbnRpdHlVdGlscy5qc1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZW50ZWRGb2xkZXIge1xuXHRsZXZlbDogbnVtYmVyXG5cdGZvbGRlcjogTWFpbEZvbGRlclxufVxuXG4vKiogQWNjZXNzb3IgZm9yIHRoZSBmb2xkZXIgdHJlZXMuICovXG5leHBvcnQgY2xhc3MgRm9sZGVyU3lzdGVtIHtcblx0cmVhZG9ubHkgc3lzdGVtU3VidHJlZXM6IFJlYWRvbmx5QXJyYXk8Rm9sZGVyU3VidHJlZT5cblx0cmVhZG9ubHkgY3VzdG9tU3VidHJlZXM6IFJlYWRvbmx5QXJyYXk8Rm9sZGVyU3VidHJlZT5cblx0cmVhZG9ubHkgaW1wb3J0ZWRNYWlsU2V0OiBSZWFkb25seTxNYWlsRm9sZGVyIHwgbnVsbD5cblxuXHRjb25zdHJ1Y3RvcihtYWlsU2V0czogcmVhZG9ubHkgTWFpbEZvbGRlcltdKSB7XG5cdFx0Y29uc3QgW2ZvbGRlcnMsIG5vbkZvbGRlcnNdID0gcGFydGl0aW9uKG1haWxTZXRzLCAoZikgPT4gaXNGb2xkZXIoZikpXG5cdFx0Y29uc3QgZm9sZGVyQnlQYXJlbnQgPSBncm91cEJ5KGZvbGRlcnMsIChmb2xkZXIpID0+IChmb2xkZXIucGFyZW50Rm9sZGVyID8gZWxlbWVudElkUGFydChmb2xkZXIucGFyZW50Rm9sZGVyKSA6IG51bGwpKVxuXHRcdGNvbnN0IHRvcExldmVsRm9sZGVycyA9IGZvbGRlcnMuZmlsdGVyKChmKSA9PiBmLnBhcmVudEZvbGRlciA9PSBudWxsKVxuXG5cdFx0Y29uc3QgW3N5c3RlbUZvbGRlcnMsIGN1c3RvbUZvbGRlcnNdID0gcGFydGl0aW9uKHRvcExldmVsRm9sZGVycywgKGYpID0+IGYuZm9sZGVyVHlwZSAhPT0gTWFpbFNldEtpbmQuQ1VTVE9NKVxuXG5cdFx0dGhpcy5pbXBvcnRlZE1haWxTZXQgPSBub25Gb2xkZXJzLmZpbmQoKGYpID0+IGYuZm9sZGVyVHlwZSA9PT0gTWFpbFNldEtpbmQuSW1wb3J0ZWQpIHx8IG51bGxcblx0XHR0aGlzLnN5c3RlbVN1YnRyZWVzID0gc3lzdGVtRm9sZGVycy5zb3J0KGNvbXBhcmVTeXN0ZW0pLm1hcCgoZikgPT4gdGhpcy5tYWtlU3VidHJlZShmb2xkZXJCeVBhcmVudCwgZiwgY29tcGFyZUN1c3RvbSkpXG5cdFx0dGhpcy5jdXN0b21TdWJ0cmVlcyA9IGN1c3RvbUZvbGRlcnMuc29ydChjb21wYXJlQ3VzdG9tKS5tYXAoKGYpID0+IHRoaXMubWFrZVN1YnRyZWUoZm9sZGVyQnlQYXJlbnQsIGYsIGNvbXBhcmVDdXN0b20pKVxuXHR9XG5cblx0Z2V0SW5kZW50ZWRMaXN0KGV4Y2x1ZGVGb2xkZXI6IE1haWxGb2xkZXIgfCBudWxsID0gbnVsbCk6IEluZGVudGVkRm9sZGVyW10ge1xuXHRcdHJldHVybiBbLi4udGhpcy5nZXRJbmRlbnRlZEZvbGRlckxpc3QodGhpcy5zeXN0ZW1TdWJ0cmVlcywgZXhjbHVkZUZvbGRlciksIC4uLnRoaXMuZ2V0SW5kZW50ZWRGb2xkZXJMaXN0KHRoaXMuY3VzdG9tU3VidHJlZXMsIGV4Y2x1ZGVGb2xkZXIpXVxuXHR9XG5cblx0LyoqIFNlYXJjaCBmb3IgYSBzcGVjaWZpYyBmb2xkZXIgdHlwZS4gU29tZSBtYWlsYm94ZXMgbWlnaHQgbm90IGhhdmUgc29tZSBzeXN0ZW0gZm9sZGVycyEgKi9cblx0Z2V0U3lzdGVtRm9sZGVyQnlUeXBlKHR5cGU6IE9taXQ8TWFpbFNldEtpbmQsIE1haWxTZXRLaW5kLkNVU1RPTT4pOiBNYWlsRm9sZGVyIHwgbnVsbCB7XG5cdFx0cmV0dXJuIHRoaXMuc3lzdGVtU3VidHJlZXMuZmluZCgoZikgPT4gZi5mb2xkZXIuZm9sZGVyVHlwZSA9PT0gdHlwZSk/LmZvbGRlciA/PyBudWxsXG5cdH1cblxuXHRnZXRGb2xkZXJCeUlkKGZvbGRlcklkOiBJZCk6IE1haWxGb2xkZXIgfCBudWxsIHtcblx0XHRjb25zdCBzdWJ0cmVlID0gdGhpcy5nZXRGb2xkZXJCeUlkSW5TdWJ0cmVlcyh0aGlzLnN5c3RlbVN1YnRyZWVzLCBmb2xkZXJJZCkgPz8gdGhpcy5nZXRGb2xkZXJCeUlkSW5TdWJ0cmVlcyh0aGlzLmN1c3RvbVN1YnRyZWVzLCBmb2xkZXJJZClcblx0XHRyZXR1cm4gc3VidHJlZT8uZm9sZGVyID8/IG51bGxcblx0fVxuXG5cdGdldEZvbGRlckJ5TWFpbChtYWlsOiBNYWlsKTogTWFpbEZvbGRlciB8IG51bGwge1xuXHRcdGNvbnN0IHNldHMgPSBtYWlsLnNldHNcblx0XHRmb3IgKGNvbnN0IHNldElkIG9mIHNldHMpIHtcblx0XHRcdGNvbnN0IGZvbGRlciA9IHRoaXMuZ2V0Rm9sZGVyQnlJZChlbGVtZW50SWRQYXJ0KHNldElkKSlcblx0XHRcdGlmIChmb2xkZXIgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZm9sZGVyXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY2hpbGRyZW4gb2YgYSBwYXJlbnQgKGFwcGxpZXMgb25seSB0byBjdXN0b20gZm9sZGVycylcblx0ICogaWYgbm8gcGFyZW50IGlzIGdpdmVuLCB0aGUgdG9wIGxldmVsIGN1c3RvbSBmb2xkZXJzIGFyZSByZXR1cm5lZFxuXHQgKi9cblx0Z2V0Q3VzdG9tRm9sZGVyc09mUGFyZW50KHBhcmVudDogSWRUdXBsZSB8IG51bGwpOiBNYWlsRm9sZGVyW10ge1xuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdGNvbnN0IHBhcmVudEZvbGRlciA9IHRoaXMuZ2V0Rm9sZGVyQnlJZEluU3VidHJlZXMoWy4uLnRoaXMuY3VzdG9tU3VidHJlZXMsIC4uLnRoaXMuc3lzdGVtU3VidHJlZXNdLCBlbGVtZW50SWRQYXJ0KHBhcmVudCkpXG5cdFx0XHRyZXR1cm4gcGFyZW50Rm9sZGVyID8gcGFyZW50Rm9sZGVyLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLmZvbGRlcikgOiBbXVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXN0b21TdWJ0cmVlcy5tYXAoKHN1YnRyZWUpID0+IHN1YnRyZWUuZm9sZGVyKVxuXHRcdH1cblx0fVxuXG5cdGdldERlc2NlbmRhbnRGb2xkZXJzT2ZQYXJlbnQocGFyZW50OiBJZFR1cGxlKTogSW5kZW50ZWRGb2xkZXJbXSB7XG5cdFx0Y29uc3QgcGFyZW50Rm9sZGVyID0gdGhpcy5nZXRGb2xkZXJCeUlkSW5TdWJ0cmVlcyhbLi4udGhpcy5jdXN0b21TdWJ0cmVlcywgLi4udGhpcy5zeXN0ZW1TdWJ0cmVlc10sIGVsZW1lbnRJZFBhcnQocGFyZW50KSlcblx0XHRpZiAocGFyZW50Rm9sZGVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbmRlbnRlZEZvbGRlckxpc3QoW3BhcmVudEZvbGRlcl0pLnNsaWNlKDEpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBbXVxuXHRcdH1cblx0fVxuXG5cdC8qKiByZXR1cm5zIGFsbCBwYXJlbnRzIG9mIHRoZSBmb2xkZXIsIGluY2x1ZGluZyB0aGUgZm9sZGVyIGl0c2VsZiAqL1xuXHRnZXRQYXRoVG9Gb2xkZXIoZm9sZGVySWQ6IElkVHVwbGUpOiBNYWlsRm9sZGVyW10ge1xuXHRcdHJldHVybiB0aGlzLmdldFBhdGhUb0ZvbGRlckluU3VidHJlZXModGhpcy5zeXN0ZW1TdWJ0cmVlcywgZm9sZGVySWQpID8/IHRoaXMuZ2V0UGF0aFRvRm9sZGVySW5TdWJ0cmVlcyh0aGlzLmN1c3RvbVN1YnRyZWVzLCBmb2xkZXJJZCkgPz8gW11cblx0fVxuXG5cdGNoZWNrRm9sZGVyRm9yQW5jZXN0b3IoZm9sZGVyOiBNYWlsRm9sZGVyLCBwb3RlbnRpYWxBbmNlc3RvcklkOiBJZFR1cGxlKTogYm9vbGVhbiB7XG5cdFx0bGV0IGN1cnJlbnRGb2xkZXJQb2ludGVyOiBNYWlsRm9sZGVyIHwgbnVsbCA9IGZvbGRlclxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRpZiAoY3VycmVudEZvbGRlclBvaW50ZXI/LnBhcmVudEZvbGRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fSBlbHNlIGlmIChpc1NhbWVJZChjdXJyZW50Rm9sZGVyUG9pbnRlci5wYXJlbnRGb2xkZXIsIHBvdGVudGlhbEFuY2VzdG9ySWQpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50Rm9sZGVyUG9pbnRlciA9IHRoaXMuZ2V0Rm9sZGVyQnlJZChlbGVtZW50SWRQYXJ0KGN1cnJlbnRGb2xkZXJQb2ludGVyLnBhcmVudEZvbGRlcikpXG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBnZXRJbmRlbnRlZEZvbGRlckxpc3Qoc3VidHJlZXM6IFJlYWRvbmx5QXJyYXk8Rm9sZGVyU3VidHJlZT4sIGV4Y2x1ZGVGb2xkZXI6IE1haWxGb2xkZXIgfCBudWxsID0gbnVsbCwgY3VycmVudExldmVsOiBudW1iZXIgPSAwKTogSW5kZW50ZWRGb2xkZXJbXSB7XG5cdFx0Y29uc3QgcGxhaW5MaXN0OiBJbmRlbnRlZEZvbGRlcltdID0gW11cblx0XHRmb3IgKGNvbnN0IHN1YnRyZWUgb2Ygc3VidHJlZXMpIHtcblx0XHRcdGlmICghZXhjbHVkZUZvbGRlciB8fCAhaXNTYW1lSWQoc3VidHJlZS5mb2xkZXIuX2lkLCBleGNsdWRlRm9sZGVyLl9pZCkpIHtcblx0XHRcdFx0cGxhaW5MaXN0LnB1c2goeyBsZXZlbDogY3VycmVudExldmVsLCBmb2xkZXI6IHN1YnRyZWUuZm9sZGVyIH0pXG5cdFx0XHRcdHBsYWluTGlzdC5wdXNoKC4uLnRoaXMuZ2V0SW5kZW50ZWRGb2xkZXJMaXN0KHN1YnRyZWUuY2hpbGRyZW4sIGV4Y2x1ZGVGb2xkZXIsIGN1cnJlbnRMZXZlbCArIDEpKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGxhaW5MaXN0XG5cdH1cblxuXHRwcml2YXRlIGdldEluZGVudGVkU3lzdGVtTGlzdCgpOiBJbmRlbnRlZEZvbGRlcltdIHtcblx0XHRyZXR1cm4gdGhpcy5zeXN0ZW1TdWJ0cmVlcy5tYXAoKHN1YnRyZWUpID0+IHtcblx0XHRcdHJldHVybiB7IGxldmVsOiAwLCBmb2xkZXI6IHN1YnRyZWUuZm9sZGVyIH1cblx0XHR9KVxuXHR9XG5cblx0cHJpdmF0ZSBnZXRGb2xkZXJCeUlkSW5TdWJ0cmVlcyhzeXN0ZW1zOiBSZWFkb25seUFycmF5PEZvbGRlclN1YnRyZWU+LCBmb2xkZXJJZDogSWQpOiBGb2xkZXJTdWJ0cmVlIHwgbnVsbCB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9sZGVyQnkoc3lzdGVtcywgKHN5c3RlbSkgPT4gaXNTYW1lSWQoZ2V0RWxlbWVudElkKHN5c3RlbS5mb2xkZXIpLCBmb2xkZXJJZCkpXG5cdH1cblxuXHRwcml2YXRlIGdldEZvbGRlckJ5KHN5c3RlbXM6IFJlYWRvbmx5QXJyYXk8Rm9sZGVyU3VidHJlZT4sIHByZWRpY2F0ZTogKHN1YnRyZWU6IEZvbGRlclN1YnRyZWUpID0+IGJvb2xlYW4pOiBGb2xkZXJTdWJ0cmVlIHwgbnVsbCB7XG5cdFx0Y29uc3QgdG9wTGV2ZWwgPSBzeXN0ZW1zLmZpbmQocHJlZGljYXRlKVxuXHRcdGlmICh0b3BMZXZlbCkge1xuXHRcdFx0cmV0dXJuIHRvcExldmVsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoY29uc3QgdG9wTGV2ZWxTeXN0ZW0gb2Ygc3lzdGVtcykge1xuXHRcdFx0XHRjb25zdCBmb3VuZCA9IHRoaXMuZ2V0Rm9sZGVyQnkodG9wTGV2ZWxTeXN0ZW0uY2hpbGRyZW4sIHByZWRpY2F0ZSlcblx0XHRcdFx0aWYgKGZvdW5kKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZvdW5kXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGxcblx0fVxuXG5cdHByaXZhdGUgZ2V0UGF0aFRvRm9sZGVySW5TdWJ0cmVlcyhzeXN0ZW1zOiByZWFkb25seSBGb2xkZXJTdWJ0cmVlW10sIGZvbGRlcklkOiBJZFR1cGxlKTogTWFpbEZvbGRlcltdIHwgbnVsbCB7XG5cdFx0Zm9yIChjb25zdCBzeXN0ZW0gb2Ygc3lzdGVtcykge1xuXHRcdFx0aWYgKGlzU2FtZUlkKHN5c3RlbS5mb2xkZXIuX2lkLCBmb2xkZXJJZCkpIHtcblx0XHRcdFx0cmV0dXJuIFtzeXN0ZW0uZm9sZGVyXVxuXHRcdFx0fVxuXHRcdFx0Y29uc3Qgc3VicGF0aCA9IHRoaXMuZ2V0UGF0aFRvRm9sZGVySW5TdWJ0cmVlcyhzeXN0ZW0uY2hpbGRyZW4sIGZvbGRlcklkKVxuXHRcdFx0aWYgKHN1YnBhdGgpIHtcblx0XHRcdFx0cmV0dXJuIFtzeXN0ZW0uZm9sZGVyXS5jb25jYXQoLi4uc3VicGF0aClcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGxcblx0fVxuXG5cdHByaXZhdGUgbWFrZVN1YnRyZWUoZm9sZGVyQnlQYXJlbnQ6IE1hcDxJZCB8IG51bGwsIHJlYWRvbmx5IE1haWxGb2xkZXJbXT4sIHBhcmVudDogTWFpbEZvbGRlciwgY29tcGFyYXRvcjogRm9sZGVyQ29tcGFyYXRvcik6IEZvbGRlclN1YnRyZWUge1xuXHRcdGNvbnN0IGNoaWxkcmVuRm9sZGVycyA9IGZvbGRlckJ5UGFyZW50LmdldChnZXRFbGVtZW50SWQocGFyZW50KSlcblx0XHRpZiAoY2hpbGRyZW5Gb2xkZXJzKSB7XG5cdFx0XHRjb25zdCBjaGlsZFN5c3RlbXMgPSBjaGlsZHJlbkZvbGRlcnNcblx0XHRcdFx0LnNsaWNlKClcblx0XHRcdFx0LnNvcnQoY29tcGFyYXRvcilcblx0XHRcdFx0Lm1hcCgoY2hpbGQpID0+IHRoaXMubWFrZVN1YnRyZWUoZm9sZGVyQnlQYXJlbnQsIGNoaWxkLCBjb21wYXJhdG9yKSlcblx0XHRcdHJldHVybiB7IGZvbGRlcjogcGFyZW50LCBjaGlsZHJlbjogY2hpbGRTeXN0ZW1zIH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHsgZm9sZGVyOiBwYXJlbnQsIGNoaWxkcmVuOiBbXSB9XG5cdFx0fVxuXHR9XG59XG5cbnR5cGUgRm9sZGVyQ29tcGFyYXRvciA9IChmb2xkZXIxOiBNYWlsRm9sZGVyLCBmb2xkZXIyOiBNYWlsRm9sZGVyKSA9PiBudW1iZXJcblxuZnVuY3Rpb24gY29tcGFyZUN1c3RvbShmb2xkZXIxOiBNYWlsRm9sZGVyLCBmb2xkZXIyOiBNYWlsRm9sZGVyKTogbnVtYmVyIHtcblx0cmV0dXJuIGZvbGRlcjEubmFtZS5sb2NhbGVDb21wYXJlKGZvbGRlcjIubmFtZSlcbn1cblxudHlwZSBTeXN0ZW1NYWlsRm9sZGVyVHlwZXMgPSBFeGNsdWRlPE1haWxTZXRLaW5kLCBNYWlsU2V0S2luZC5DVVNUT00gfCBNYWlsU2V0S2luZC5MQUJFTCB8IE1haWxTZXRLaW5kLkltcG9ydGVkPlxuXG5jb25zdCBmb2xkZXJUeXBlVG9PcmRlcjogUmVjb3JkPFN5c3RlbU1haWxGb2xkZXJUeXBlcywgbnVtYmVyPiA9IHtcblx0W01haWxTZXRLaW5kLklOQk9YXTogMCxcblx0W01haWxTZXRLaW5kLkRSQUZUXTogMSxcblx0W01haWxTZXRLaW5kLlNFTlRdOiAyLFxuXHRbTWFpbFNldEtpbmQuVFJBU0hdOiA0LFxuXHRbTWFpbFNldEtpbmQuQVJDSElWRV06IDUsXG5cdFtNYWlsU2V0S2luZC5TUEFNXTogNixcblx0W01haWxTZXRLaW5kLkFMTF06IDcsXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVTeXN0ZW0oZm9sZGVyMTogTWFpbEZvbGRlciwgZm9sZGVyMjogTWFpbEZvbGRlcik6IG51bWJlciB7XG5cdGNvbnN0IG9yZGVyMSA9IGZvbGRlclR5cGVUb09yZGVyW2ZvbGRlcjEuZm9sZGVyVHlwZSBhcyBTeXN0ZW1NYWlsRm9sZGVyVHlwZXNdID8/IDdcblx0Y29uc3Qgb3JkZXIyID0gZm9sZGVyVHlwZVRvT3JkZXJbZm9sZGVyMi5mb2xkZXJUeXBlIGFzIFN5c3RlbU1haWxGb2xkZXJUeXBlc10gPz8gN1xuXHRyZXR1cm4gb3JkZXIxIC0gb3JkZXIyXG59XG5cbi8qKlxuICogYW4gYXJyYXkgb2YgRm9sZGVyU3lzdGVtcyByZXByZXNlbnQgYWxsIGZvbGRlcnMuXG4gKiB0aGUgdG9wIGZvbGRlcnMgYXJlIHRoZSB0b3BsZXZlbCBmb2xkZXJzIGluIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBzdWJmb2xkZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvbGRlclN1YnRyZWUge1xuXHRyZWFkb25seSBmb2xkZXI6IE1haWxGb2xkZXJcblx0cmVhZG9ubHkgY2hpbGRyZW46IHJlYWRvbmx5IEZvbGRlclN1YnRyZWVbXVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7TUFzQmEsb0JBQW9CO0lBa0JwQixnQkFBTixNQUF5Qzs7OztDQUkvQyxBQUFpQjtDQUVqQixZQUE2QkEs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