import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { groupBy, isNotEmpty, partition } from "./dist2-chunk.js";
import { MailSetKind, isFolder } from "./TutanotaConstants-chunk.js";
import { elementIdPart, getElementId, getListId, isSameId } from "./EntityUtils-chunk.js";

//#region src/common/api/common/utils/Scheduler.ts
const SET_TIMEOUT_LIMIT = 2147483647;
var SchedulerImpl = class {
	/**
	* This points from the originally scheduled timeout to the most recent timeout
	*/
	bridgedTimeouts;
	constructor(dateProvider, systemTimeout, systemInterval) {
		this.dateProvider = dateProvider;
		this.systemTimeout = systemTimeout;
		this.systemInterval = systemInterval;
		this.bridgedTimeouts = new Map();
	}
	scheduleAt(callback, date) {
		let timeoutId;
		const wrappedCallback = () => {
			this.bridgedTimeouts.delete(timeoutId);
			callback();
		};
		timeoutId = this.scheduleAtInternal(wrappedCallback, date);
		return timeoutId;
	}
	scheduleAfter(thunk, after) {
		const date = new Date(this.dateProvider.now() + after);
		return this.scheduleAt(thunk, date);
	}
	/** We have separate internal version which does not re-wrap the thunk. */
	scheduleAtInternal(thunk, date) {
		const now = this.dateProvider.now();
		const then = date.getTime();
		const diff = Math.max(then - now, 0);
		let timeoutId;
		if (diff > SET_TIMEOUT_LIMIT) timeoutId = this.systemTimeout.setTimeout(() => {
			const newTimeoutId = this.scheduleAtInternal(thunk, date);
			this.bridgedTimeouts.set(timeoutId, newTimeoutId);
		}, SET_TIMEOUT_LIMIT);
else timeoutId = this.systemTimeout.setTimeout(thunk, diff);
		return timeoutId;
	}
	unscheduleTimeout(id) {
		const rescheduledId = this.bridgedTimeouts.get(id) || id;
		this.bridgedTimeouts.delete(rescheduledId);
		return this.systemTimeout.clearTimeout(rescheduledId);
	}
	schedulePeriodic(thunk, ms) {
		if (ms > SET_TIMEOUT_LIMIT) throw new Error("Attempting to schedule periodic task but the period is too big: " + ms);
		return this.systemInterval.setInterval(thunk, ms);
	}
	unschedulePeriodic(id) {
		this.systemInterval.clearInterval(id);
	}
};

//#endregion
//#region src/common/api/common/utils/NoZoneDateProvider.ts
var NoZoneDateProvider = class {
	now() {
		return Date.now();
	}
	timeZone() {
		throw new ProgrammingError("timeZone is not available in worker");
	}
};

//#endregion
//#region src/common/api/common/DomainConfigProvider.ts
var DomainConfigProvider = class {
	/** Get domain config for the current domain (staticUrl or the one the app is running on). */
	getCurrentDomainConfig() {
		const url = new URL(env.staticUrl ?? location.href);
		const port = url.port;
		const hostname = url.hostname;
		const protocol = url.protocol;
		return this.getDomainConfigForHostname(hostname, protocol, port);
	}
	getDomainConfigForHostname(hostname, protocol = "https:", port) {
		const staticConfig = env.domainConfigs[hostname];
		if (staticConfig) return staticConfig;
else {
			const fullHostName = hostname + (port ? `:${port}` : "");
			const dynamicConfig = env.domainConfigs["{hostname}"];
			const entries = Object.entries(dynamicConfig).map(([key, value]) => {
				const replacedValue = typeof value === "string" ? value.replace("{hostname}", fullHostName).replace("{protocol}", protocol) : value;
				return [key, replacedValue];
			});
			return Object.fromEntries(entries);
		}
	}
};

//#endregion
//#region src/common/api/common/mail/FolderSystem.ts
var FolderSystem = class {
	systemSubtrees;
	customSubtrees;
	importedMailSet;
	constructor(mailSets) {
		const [folders, nonFolders] = partition(mailSets, (f) => isFolder(f));
		const folderByParent = groupBy(folders, (folder) => folder.parentFolder ? elementIdPart(folder.parentFolder) : null);
		const topLevelFolders = folders.filter((f) => f.parentFolder == null);
		const [systemFolders, customFolders] = partition(topLevelFolders, (f) => f.folderType !== MailSetKind.CUSTOM);
		this.importedMailSet = nonFolders.find((f) => f.folderType === MailSetKind.Imported) || null;
		this.systemSubtrees = systemFolders.sort(compareSystem).map((f) => this.makeSubtree(folderByParent, f, compareCustom));
		this.customSubtrees = customFolders.sort(compareCustom).map((f) => this.makeSubtree(folderByParent, f, compareCustom));
	}
	getIndentedList(excludeFolder = null) {
		return [...this.getIndentedFolderList(this.systemSubtrees, excludeFolder), ...this.getIndentedFolderList(this.customSubtrees, excludeFolder)];
	}
	/** Search for a specific folder type. Some mailboxes might not have some system folders! */
	getSystemFolderByType(type) {
		return this.systemSubtrees.find((f) => f.folder.folderType === type)?.folder ?? null;
	}
	getFolderById(folderId) {
		const subtree = this.getFolderByIdInSubtrees(this.systemSubtrees, folderId) ?? this.getFolderByIdInSubtrees(this.customSubtrees, folderId);
		return subtree?.folder ?? null;
	}
	getFolderByMail(mail) {
		const sets = mail.sets;
		if (isNotEmpty(sets)) {
			for (const setId of sets) {
				const folder = this.getFolderById(elementIdPart(setId));
				if (folder != null) return folder;
			}
			return null;
		} else return this.getFolderByMailListIdLegacy(getListId(mail));
	}
	getFolderByMailListIdLegacy(mailListId) {
		const subtree = this.getFolderByMailListIdInSubtrees(this.systemSubtrees, mailListId) ?? this.getFolderByMailListIdInSubtrees(this.customSubtrees, mailListId);
		return subtree?.folder ?? null;
	}
	/**
	* Returns the children of a parent (applies only to custom folders)
	* if no parent is given, the top level custom folders are returned
	*/
	getCustomFoldersOfParent(parent) {
		if (parent) {
			const parentFolder = this.getFolderByIdInSubtrees([...this.customSubtrees, ...this.systemSubtrees], elementIdPart(parent));
			return parentFolder ? parentFolder.children.map((child) => child.folder) : [];
		} else return this.customSubtrees.map((subtree) => subtree.folder);
	}
	getDescendantFoldersOfParent(parent) {
		const parentFolder = this.getFolderByIdInSubtrees([...this.customSubtrees, ...this.systemSubtrees], elementIdPart(parent));
		if (parentFolder) return this.getIndentedFolderList([parentFolder]).slice(1);
else return [];
	}
	/** returns all parents of the folder, including the folder itself */
	getPathToFolder(folderId) {
		return this.getPathToFolderInSubtrees(this.systemSubtrees, folderId) ?? this.getPathToFolderInSubtrees(this.customSubtrees, folderId) ?? [];
	}
	checkFolderForAncestor(folder, potentialAncestorId) {
		let currentFolderPointer = folder;
		while (true) {
			if (currentFolderPointer?.parentFolder == null) return false;
else if (isSameId(currentFolderPointer.parentFolder, potentialAncestorId)) return true;
			currentFolderPointer = this.getFolderById(elementIdPart(currentFolderPointer.parentFolder));
		}
	}
	getIndentedFolderList(subtrees, excludeFolder = null, currentLevel = 0) {
		const plainList = [];
		for (const subtree of subtrees) if (!excludeFolder || !isSameId(subtree.folder._id, excludeFolder._id)) {
			plainList.push({
				level: currentLevel,
				folder: subtree.folder
			});
			plainList.push(...this.getIndentedFolderList(subtree.children, excludeFolder, currentLevel + 1));
		}
		return plainList;
	}
	getIndentedSystemList() {
		return this.systemSubtrees.map((subtree) => {
			return {
				level: 0,
				folder: subtree.folder
			};
		});
	}
	getFolderByIdInSubtrees(systems, folderId) {
		return this.getFolderBy(systems, (system) => isSameId(getElementId(system.folder), folderId));
	}
	getFolderByMailListIdInSubtrees(systems, mailListId) {
		return this.getFolderBy(systems, (subtree) => isSameId(subtree.folder.mails, mailListId));
	}
	getFolderBy(systems, predicate) {
		const topLevel = systems.find(predicate);
		if (topLevel) return topLevel;
else for (const topLevelSystem of systems) {
			const found = this.getFolderBy(topLevelSystem.children, predicate);
			if (found) return found;
		}
		return null;
	}
	getPathToFolderInSubtrees(systems, folderId) {
		for (const system of systems) {
			if (isSameId(system.folder._id, folderId)) return [system.folder];
			const subpath = this.getPathToFolderInSubtrees(system.children, folderId);
			if (subpath) return [system.folder].concat(...subpath);
		}
		return null;
	}
	makeSubtree(folderByParent, parent, comparator) {
		const childrenFolders = folderByParent.get(getElementId(parent));
		if (childrenFolders) {
			const childSystems = childrenFolders.slice().sort(comparator).map((child) => this.makeSubtree(folderByParent, child, comparator));
			return {
				folder: parent,
				children: childSystems
			};
		} else return {
			folder: parent,
			children: []
		};
	}
};
function compareCustom(folder1, folder2) {
	return folder1.name.localeCompare(folder2.name);
}
const folderTypeToOrder = {
	[MailSetKind.INBOX]: 0,
	[MailSetKind.DRAFT]: 1,
	[MailSetKind.SENT]: 2,
	[MailSetKind.TRASH]: 4,
	[MailSetKind.ARCHIVE]: 5,
	[MailSetKind.SPAM]: 6,
	[MailSetKind.ALL]: 7
};
function compareSystem(folder1, folder2) {
	const order1 = folderTypeToOrder[folder1.folderType] ?? 7;
	const order2 = folderTypeToOrder[folder2.folderType] ?? 7;
	return order1 - order2;
}

//#endregion
export { DomainConfigProvider, FolderSystem, NoZoneDateProvider, SchedulerImpl };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9sZGVyU3lzdGVtLWNodW5rLmpzIiwibmFtZXMiOlsiZGF0ZVByb3ZpZGVyOiBEYXRlUHJvdmlkZXIiLCJzeXN0ZW1UaW1lb3V0OiBTeXN0ZW1UaW1lb3V0Iiwic3lzdGVtSW50ZXJ2YWw6IFN5c3RlbUludGVydmFsIiwiY2FsbGJhY2s6IFRodW5rIiwiZGF0ZTogRGF0ZSIsInRpbWVvdXRJZDogVGltZW91dElEIiwidGh1bms6IFRodW5rIiwiYWZ0ZXI6IG51bWJlciIsImlkOiBTY2hlZHVsZWRUaW1lb3V0SWQiLCJtczogbnVtYmVyIiwiaWQ6IFNjaGVkdWxlZFBlcmlvZGljSWQiLCJob3N0bmFtZTogc3RyaW5nIiwicHJvdG9jb2w6IHN0cmluZyIsInBvcnQ/OiBzdHJpbmciLCJtYWlsU2V0czogcmVhZG9ubHkgTWFpbEZvbGRlcltdIiwiZXhjbHVkZUZvbGRlcjogTWFpbEZvbGRlciB8IG51bGwiLCJ0eXBlOiBPbWl0PE1haWxTZXRLaW5kLCBNYWlsU2V0S2luZC5DVVNUT00+IiwiZm9sZGVySWQ6IElkIiwibWFpbDogTWFpbCIsIm1haWxMaXN0SWQ6IElkIiwicGFyZW50OiBJZFR1cGxlIHwgbnVsbCIsInBhcmVudDogSWRUdXBsZSIsImZvbGRlcklkOiBJZFR1cGxlIiwiZm9sZGVyOiBNYWlsRm9sZGVyIiwicG90ZW50aWFsQW5jZXN0b3JJZDogSWRUdXBsZSIsImN1cnJlbnRGb2xkZXJQb2ludGVyOiBNYWlsRm9sZGVyIHwgbnVsbCIsInN1YnRyZWVzOiBSZWFkb25seUFycmF5PEZvbGRlclN1YnRyZWU+IiwiY3VycmVudExldmVsOiBudW1iZXIiLCJwbGFpbkxpc3Q6IEluZGVudGVkRm9sZGVyW10iLCJzeXN0ZW1zOiBSZWFkb25seUFycmF5PEZvbGRlclN1YnRyZWU+IiwicHJlZGljYXRlOiAoc3VidHJlZTogRm9sZGVyU3VidHJlZSkgPT4gYm9vbGVhbiIsInN5c3RlbXM6IHJlYWRvbmx5IEZvbGRlclN1YnRyZWVbXSIsImZvbGRlckJ5UGFyZW50OiBNYXA8SWQgfCBudWxsLCByZWFkb25seSBNYWlsRm9sZGVyW10+IiwicGFyZW50OiBNYWlsRm9sZGVyIiwiY29tcGFyYXRvcjogRm9sZGVyQ29tcGFyYXRvciIsImZvbGRlcjE6IE1haWxGb2xkZXIiLCJmb2xkZXIyOiBNYWlsRm9sZGVyIiwiZm9sZGVyVHlwZVRvT3JkZXI6IFJlY29yZDxTeXN0ZW1NYWlsRm9sZGVyVHlwZXMsIG51bWJlcj4iXSwic291cmNlcyI6WyIuLi9zcmMvY29tbW9uL2FwaS9jb21tb24vdXRpbHMvU2NoZWR1bGVyLnRzIiwiLi4vc3JjL2NvbW1vbi9hcGkvY29tbW9uL3V0aWxzL05vWm9uZURhdGVQcm92aWRlci50cyIsIi4uL3NyYy9jb21tb24vYXBpL2NvbW1vbi9Eb21haW5Db25maWdQcm92aWRlci50cyIsIi4uL3NyYy9jb21tb24vYXBpL2NvbW1vbi9tYWlsL0ZvbGRlclN5c3RlbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFRodW5rIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBEYXRlUHJvdmlkZXIgfSBmcm9tIFwiLi4vRGF0ZVByb3ZpZGVyLmpzXCJcblxuZXhwb3J0IHR5cGUgU2NoZWR1bGVkVGltZW91dElkID0gVGltZW91dElEXG5leHBvcnQgdHlwZSBTY2hlZHVsZWRQZXJpb2RpY0lkID0gVGltZW91dElEXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZWR1bGVyIHtcblx0c2NoZWR1bGVBdCh0aHVuazogVGh1bmssIGRhdGU6IERhdGUpOiBTY2hlZHVsZWRUaW1lb3V0SWRcblxuXHR1bnNjaGVkdWxlVGltZW91dChpZDogU2NoZWR1bGVkVGltZW91dElkKTogdm9pZFxuXG5cdHNjaGVkdWxlQWZ0ZXIodGh1bms6IFRodW5rLCBhZnRlcjogbnVtYmVyKTogU2NoZWR1bGVkVGltZW91dElkXG5cblx0c2NoZWR1bGVQZXJpb2RpYyh0aHVuazogVGh1bmssIHBlcmlvZDogbnVtYmVyKTogU2NoZWR1bGVkUGVyaW9kaWNJZFxuXG5cdHVuc2NoZWR1bGVQZXJpb2RpYyhpZDogU2NoZWR1bGVkUGVyaW9kaWNJZCk6IHZvaWRcbn1cblxuLyoqXG4gKiBzZXRUaW1lb3V0KCkgb25seSB3b3JrcyBvbiAzMmJpdCBpbnRlZ2VycywgaXQgZG9lc24ndCBkbyB3aGF0IHlvdSBleHBlY3Qgb24gbG9uZ2VyIGludGVydmFscy4gSWYgeW91IHVzZSBTY2hlZHVsZXIgeW91IHNob3VsZCBub3RcbiAqIHdvcnJ5IGFib3V0IGl0LCBtYWlubHkgZXhwb3J0ZWQgZm9yIHRlc3RzLlxuICogKi9cbmV4cG9ydCBjb25zdCBTRVRfVElNRU9VVF9MSU1JVCA9IDB4N2ZmZmZmZmZcblxuLyoqIERlZmF1bHQgaW1wbCBvZiB0aW1lb3V0IGZ1bmN0aW9ucywgdXNlZnVsIGZvciB0ZXN0aW5nICovXG5leHBvcnQgdHlwZSBTeXN0ZW1UaW1lb3V0ID0ge1xuXHQvLyBDb3B5aW5nIGl0IGJlY2F1c2UgdHMgaGFzIHNvbWUgd2VpcmQgcHJvcGVydGllcyBhdHRhY2ggdG8gaXQgaW4gbm9kZSB0c2xpYi5cblx0Ly8gbm8tYXJnIHZlcnNpb24gYmVjYXVzZSBsYW1iYWRhcyBleGlzdC5cblx0c2V0VGltZW91dChjYWxsYmFjazogKCkgPT4gdm9pZCwgbXM6IG51bWJlcik6IG51bWJlclxuXHRjbGVhclRpbWVvdXQ6IHR5cGVvZiBjbGVhclRpbWVvdXRcbn1cblxuLyoqIERlZmF1bHQgaW1wbCBvZiBpbnRlcnZhbCBmdW5jdGlvbnMsIHVzZWZ1bCBmb3IgdGVzdGluZyAqL1xuZXhwb3J0IHR5cGUgU3lzdGVtSW50ZXJ2YWwgPSB7XG5cdC8vIENvcHlpbmcgaXQgYmVjYXVzZSB0cyBoYXMgc29tZSB3ZWlyZCBwcm9wZXJ0aWVzIGF0dGFjaCB0byBpdCBpbiBub2RlIHRzbGliLlxuXHQvLyBuby1hcmcgdmVyc2lvbiBiZWNhdXNlIGxhbWJhZGFzIGV4aXN0LlxuXHRzZXRJbnRlcnZhbChjYWxsYmFjazogKCkgPT4gdm9pZCwgbXM6IG51bWJlcik6IG51bWJlclxuXHRjbGVhckludGVydmFsOiB0eXBlb2YgY2xlYXJJbnRlcnZhbFxufVxuXG5leHBvcnQgY2xhc3MgU2NoZWR1bGVySW1wbCBpbXBsZW1lbnRzIFNjaGVkdWxlciB7XG5cdC8qKlxuXHQgKiBUaGlzIHBvaW50cyBmcm9tIHRoZSBvcmlnaW5hbGx5IHNjaGVkdWxlZCB0aW1lb3V0IHRvIHRoZSBtb3N0IHJlY2VudCB0aW1lb3V0XG5cdCAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IGJyaWRnZWRUaW1lb3V0czogTWFwPFNjaGVkdWxlZFRpbWVvdXRJZCwgU2NoZWR1bGVkVGltZW91dElkPlxuXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZGF0ZVByb3ZpZGVyOiBEYXRlUHJvdmlkZXIsIHByaXZhdGUgcmVhZG9ubHkgc3lzdGVtVGltZW91dDogU3lzdGVtVGltZW91dCwgcHJpdmF0ZSByZWFkb25seSBzeXN0ZW1JbnRlcnZhbDogU3lzdGVtSW50ZXJ2YWwpIHtcblx0XHR0aGlzLmJyaWRnZWRUaW1lb3V0cyA9IG5ldyBNYXAoKVxuXHR9XG5cblx0c2NoZWR1bGVBdChjYWxsYmFjazogVGh1bmssIGRhdGU6IERhdGUpOiBTY2hlZHVsZWRUaW1lb3V0SWQge1xuXHRcdGxldCB0aW1lb3V0SWQ6IFRpbWVvdXRJRFxuXG5cdFx0Ly8gQ2FsbCB0aGUgdGh1bmsgYW5kIGNsZWFuIHVwIHRpbWVvdXQgaW4gdGhlIG1hcFxuXHRcdGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICgpID0+IHtcblx0XHRcdHRoaXMuYnJpZGdlZFRpbWVvdXRzLmRlbGV0ZSh0aW1lb3V0SWQpXG5cblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cblx0XHR0aW1lb3V0SWQgPSB0aGlzLnNjaGVkdWxlQXRJbnRlcm5hbCh3cmFwcGVkQ2FsbGJhY2ssIGRhdGUpXG5cdFx0cmV0dXJuIHRpbWVvdXRJZFxuXHR9XG5cblx0c2NoZWR1bGVBZnRlcih0aHVuazogVGh1bmssIGFmdGVyOiBudW1iZXIpOiBTY2hlZHVsZWRUaW1lb3V0SWQge1xuXHRcdGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGVQcm92aWRlci5ub3coKSArIGFmdGVyKVxuXHRcdHJldHVybiB0aGlzLnNjaGVkdWxlQXQodGh1bmssIGRhdGUpXG5cdH1cblxuXHQvKiogV2UgaGF2ZSBzZXBhcmF0ZSBpbnRlcm5hbCB2ZXJzaW9uIHdoaWNoIGRvZXMgbm90IHJlLXdyYXAgdGhlIHRodW5rLiAqL1xuXHRwcml2YXRlIHNjaGVkdWxlQXRJbnRlcm5hbCh0aHVuazogVGh1bmssIGRhdGU6IERhdGUpOiBTY2hlZHVsZWRUaW1lb3V0SWQge1xuXHRcdGNvbnN0IG5vdyA9IHRoaXMuZGF0ZVByb3ZpZGVyLm5vdygpXG5cblx0XHRjb25zdCB0aGVuID0gZGF0ZS5nZXRUaW1lKClcblx0XHRjb25zdCBkaWZmID0gTWF0aC5tYXgodGhlbiAtIG5vdywgMClcblx0XHRsZXQgdGltZW91dElkOiBUaW1lb3V0SURcblxuXHRcdGlmIChkaWZmID4gU0VUX1RJTUVPVVRfTElNSVQpIHtcblx0XHRcdHRpbWVvdXRJZCA9IHRoaXMuc3lzdGVtVGltZW91dC5zZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0Y29uc3QgbmV3VGltZW91dElkID0gdGhpcy5zY2hlZHVsZUF0SW50ZXJuYWwodGh1bmssIGRhdGUpXG5cblx0XHRcdFx0dGhpcy5icmlkZ2VkVGltZW91dHMuc2V0KHRpbWVvdXRJZCwgbmV3VGltZW91dElkKVxuXHRcdFx0fSwgU0VUX1RJTUVPVVRfTElNSVQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbWVvdXRJZCA9IHRoaXMuc3lzdGVtVGltZW91dC5zZXRUaW1lb3V0KHRodW5rLCBkaWZmKVxuXHRcdH1cblxuXHRcdHJldHVybiB0aW1lb3V0SWRcblx0fVxuXG5cdHVuc2NoZWR1bGVUaW1lb3V0KGlkOiBTY2hlZHVsZWRUaW1lb3V0SWQpOiB2b2lkIHtcblx0XHRjb25zdCByZXNjaGVkdWxlZElkID0gdGhpcy5icmlkZ2VkVGltZW91dHMuZ2V0KGlkKSB8fCBpZFxuXG5cdFx0dGhpcy5icmlkZ2VkVGltZW91dHMuZGVsZXRlKHJlc2NoZWR1bGVkSWQpXG5cblx0XHRyZXR1cm4gdGhpcy5zeXN0ZW1UaW1lb3V0LmNsZWFyVGltZW91dChyZXNjaGVkdWxlZElkKVxuXHR9XG5cblx0c2NoZWR1bGVQZXJpb2RpYyh0aHVuazogVGh1bmssIG1zOiBudW1iZXIpOiBTY2hlZHVsZWRQZXJpb2RpY0lkIHtcblx0XHQvLyBJbnRlcnZhbHMgYmlnZ2VyIHRoYW4gMzIgYml0IGludCB3aWxsIG5vdCB3b3JrIG91dC1vZi10aGUtYm94IGFuZCB3ZSBkbyBub3Qgd2FudCB0byBpbXBsZW1lbnQgYnJpZGdpbmcgZm9yIHRoZW0gYXMgdGhpcyBpcyBhIHZlcnkgcmFyZSBjYXNlIGFuZCBpc1xuXHRcdC8vIHVzdWFsbHkgYSBidWcuXG5cdFx0aWYgKG1zID4gU0VUX1RJTUVPVVRfTElNSVQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gc2NoZWR1bGUgcGVyaW9kaWMgdGFzayBidXQgdGhlIHBlcmlvZCBpcyB0b28gYmlnOiBcIiArIG1zKVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zeXN0ZW1JbnRlcnZhbC5zZXRJbnRlcnZhbCh0aHVuaywgbXMpXG5cdH1cblxuXHR1bnNjaGVkdWxlUGVyaW9kaWMoaWQ6IFNjaGVkdWxlZFBlcmlvZGljSWQpIHtcblx0XHR0aGlzLnN5c3RlbUludGVydmFsLmNsZWFySW50ZXJ2YWwoaWQpXG5cdH1cbn1cbiIsImltcG9ydCB7IFByb2dyYW1taW5nRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3IvUHJvZ3JhbW1pbmdFcnJvci5qc1wiXG5pbXBvcnQgeyBEYXRlUHJvdmlkZXIgfSBmcm9tIFwiLi4vRGF0ZVByb3ZpZGVyLmpzXCJcblxuZXhwb3J0IGNsYXNzIE5vWm9uZURhdGVQcm92aWRlciBpbXBsZW1lbnRzIERhdGVQcm92aWRlciB7XG5cdG5vdygpOiBudW1iZXIge1xuXHRcdHJldHVybiBEYXRlLm5vdygpXG5cdH1cblxuXHR0aW1lWm9uZSgpOiBzdHJpbmcge1xuXHRcdHRocm93IG5ldyBQcm9ncmFtbWluZ0Vycm9yKFwidGltZVpvbmUgaXMgbm90IGF2YWlsYWJsZSBpbiB3b3JrZXJcIilcblx0fVxufVxuIiwiZXhwb3J0IGNsYXNzIERvbWFpbkNvbmZpZ1Byb3ZpZGVyIHtcblx0LyoqIEdldCBkb21haW4gY29uZmlnIGZvciB0aGUgY3VycmVudCBkb21haW4gKHN0YXRpY1VybCBvciB0aGUgb25lIHRoZSBhcHAgaXMgcnVubmluZyBvbikuICovXG5cdGdldEN1cnJlbnREb21haW5Db25maWcoKTogRG9tYWluQ29uZmlnIHtcblx0XHQvLyBJdCBpcyBhbWJpZ3VvdXMgd2hhdCB0byBkbyB3aGVuIHdlIHJ1biB3ZWJzaXRlIG9uIG9uZSBkb21haW4gYnV0IGhhdmUgc3RhdGljIFVSTCBmb3IgYW5vdGhlclxuXHRcdC8vIG9uZSBidXQgdGhpcyBhY3R1YWxseSBzaG91bGRuJ3QgaGFwcGVuLlxuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoZW52LnN0YXRpY1VybCA/PyBsb2NhdGlvbi5ocmVmKVxuXHRcdGNvbnN0IHBvcnQgPSB1cmwucG9ydFxuXHRcdGNvbnN0IGhvc3RuYW1lID0gdXJsLmhvc3RuYW1lXG5cdFx0Y29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblx0XHRyZXR1cm4gdGhpcy5nZXREb21haW5Db25maWdGb3JIb3N0bmFtZShob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQpXG5cdH1cblxuXHRnZXREb21haW5Db25maWdGb3JIb3N0bmFtZShob3N0bmFtZTogc3RyaW5nLCBwcm90b2NvbDogc3RyaW5nID0gXCJodHRwczpcIiwgcG9ydD86IHN0cmluZyk6IERvbWFpbkNvbmZpZyB7XG5cdFx0Y29uc3Qgc3RhdGljQ29uZmlnID0gZW52LmRvbWFpbkNvbmZpZ3NbaG9zdG5hbWVdXG5cdFx0aWYgKHN0YXRpY0NvbmZpZykge1xuXHRcdFx0cmV0dXJuIHN0YXRpY0NvbmZpZ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBmdWxsSG9zdE5hbWUgPSBob3N0bmFtZSArIChwb3J0ID8gYDoke3BvcnR9YCA6IFwiXCIpXG5cdFx0XHRjb25zdCBkeW5hbWljQ29uZmlnID0gZW52LmRvbWFpbkNvbmZpZ3NbXCJ7aG9zdG5hbWV9XCJdXG5cdFx0XHRjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZHluYW1pY0NvbmZpZykubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZWRWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnJlcGxhY2UoXCJ7aG9zdG5hbWV9XCIsIGZ1bGxIb3N0TmFtZSkucmVwbGFjZShcIntwcm90b2NvbH1cIiwgcHJvdG9jb2wpIDogdmFsdWVcblx0XHRcdFx0cmV0dXJuIFtrZXksIHJlcGxhY2VkVmFsdWVdXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKVxuXHRcdH1cblx0fVxufVxuIiwiaW1wb3J0IHsgZ3JvdXBCeSwgaXNOb3RFbXB0eSwgcGFydGl0aW9uIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBNYWlsLCBNYWlsRm9sZGVyIH0gZnJvbSBcIi4uLy4uL2VudGl0aWVzL3R1dGFub3RhL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IGlzRm9sZGVyLCBNYWlsU2V0S2luZCB9IGZyb20gXCIuLi9UdXRhbm90YUNvbnN0YW50cy5qc1wiXG5pbXBvcnQgeyBlbGVtZW50SWRQYXJ0LCBnZXRFbGVtZW50SWQsIGdldExpc3RJZCwgaXNTYW1lSWQgfSBmcm9tIFwiLi4vdXRpbHMvRW50aXR5VXRpbHMuanNcIlxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGVudGVkRm9sZGVyIHtcblx0bGV2ZWw6IG51bWJlclxuXHRmb2xkZXI6IE1haWxGb2xkZXJcbn1cblxuLyoqIEFjY2Vzc29yIGZvciB0aGUgZm9sZGVyIHRyZWVzLiAqL1xuZXhwb3J0IGNsYXNzIEZvbGRlclN5c3RlbSB7XG5cdHJlYWRvbmx5IHN5c3RlbVN1YnRyZWVzOiBSZWFkb25seUFycmF5PEZvbGRlclN1YnRyZWU+XG5cdHJlYWRvbmx5IGN1c3RvbVN1YnRyZWVzOiBSZWFkb25seUFycmF5PEZvbGRlclN1YnRyZWU+XG5cdHJlYWRvbmx5IGltcG9ydGVkTWFpbFNldDogUmVhZG9ubHk8TWFpbEZvbGRlciB8IG51bGw+XG5cblx0Y29uc3RydWN0b3IobWFpbFNldHM6IHJlYWRvbmx5IE1haWxGb2xkZXJbXSkge1xuXHRcdGNvbnN0IFtmb2xkZXJzLCBub25Gb2xkZXJzXSA9IHBhcnRpdGlvbihtYWlsU2V0cywgKGYpID0+IGlzRm9sZGVyKGYpKVxuXHRcdGNvbnN0IGZvbGRlckJ5UGFyZW50ID0gZ3JvdXBCeShmb2xkZXJzLCAoZm9sZGVyKSA9PiAoZm9sZGVyLnBhcmVudEZvbGRlciA/IGVsZW1lbnRJZFBhcnQoZm9sZGVyLnBhcmVudEZvbGRlcikgOiBudWxsKSlcblx0XHRjb25zdCB0b3BMZXZlbEZvbGRlcnMgPSBmb2xkZXJzLmZpbHRlcigoZikgPT4gZi5wYXJlbnRGb2xkZXIgPT0gbnVsbClcblxuXHRcdGNvbnN0IFtzeXN0ZW1Gb2xkZXJzLCBjdXN0b21Gb2xkZXJzXSA9IHBhcnRpdGlvbih0b3BMZXZlbEZvbGRlcnMsIChmKSA9PiBmLmZvbGRlclR5cGUgIT09IE1haWxTZXRLaW5kLkNVU1RPTSlcblxuXHRcdHRoaXMuaW1wb3J0ZWRNYWlsU2V0ID0gbm9uRm9sZGVycy5maW5kKChmKSA9PiBmLmZvbGRlclR5cGUgPT09IE1haWxTZXRLaW5kLkltcG9ydGVkKSB8fCBudWxsXG5cdFx0dGhpcy5zeXN0ZW1TdWJ0cmVlcyA9IHN5c3RlbUZvbGRlcnMuc29ydChjb21wYXJlU3lzdGVtKS5tYXAoKGYpID0+IHRoaXMubWFrZVN1YnRyZWUoZm9sZGVyQnlQYXJlbnQsIGYsIGNvbXBhcmVDdXN0b20pKVxuXHRcdHRoaXMuY3VzdG9tU3VidHJlZXMgPSBjdXN0b21Gb2xkZXJzLnNvcnQoY29tcGFyZUN1c3RvbSkubWFwKChmKSA9PiB0aGlzLm1ha2VTdWJ0cmVlKGZvbGRlckJ5UGFyZW50LCBmLCBjb21wYXJlQ3VzdG9tKSlcblx0fVxuXG5cdGdldEluZGVudGVkTGlzdChleGNsdWRlRm9sZGVyOiBNYWlsRm9sZGVyIHwgbnVsbCA9IG51bGwpOiBJbmRlbnRlZEZvbGRlcltdIHtcblx0XHRyZXR1cm4gWy4uLnRoaXMuZ2V0SW5kZW50ZWRGb2xkZXJMaXN0KHRoaXMuc3lzdGVtU3VidHJlZXMsIGV4Y2x1ZGVGb2xkZXIpLCAuLi50aGlzLmdldEluZGVudGVkRm9sZGVyTGlzdCh0aGlzLmN1c3RvbVN1YnRyZWVzLCBleGNsdWRlRm9sZGVyKV1cblx0fVxuXG5cdC8qKiBTZWFyY2ggZm9yIGEgc3BlY2lmaWMgZm9sZGVyIHR5cGUuIFNvbWUgbWFpbGJveGVzIG1pZ2h0IG5vdCBoYXZlIHNvbWUgc3lzdGVtIGZvbGRlcnMhICovXG5cdGdldFN5c3RlbUZvbGRlckJ5VHlwZSh0eXBlOiBPbWl0PE1haWxTZXRLaW5kLCBNYWlsU2V0S2luZC5DVVNUT00+KTogTWFpbEZvbGRlciB8IG51bGwge1xuXHRcdHJldHVybiB0aGlzLnN5c3RlbVN1YnRyZWVzLmZpbmQoKGYpID0+IGYuZm9sZGVyLmZvbGRlclR5cGUgPT09IHR5cGUpPy5mb2xkZXIgPz8gbnVsbFxuXHR9XG5cblx0Z2V0Rm9sZGVyQnlJZChmb2xkZXJJZDogSWQpOiBNYWlsRm9sZGVyIHwgbnVsbCB7XG5cdFx0Y29uc3Qgc3VidHJlZSA9IHRoaXMuZ2V0Rm9sZGVyQnlJZEluU3VidHJlZXModGhpcy5zeXN0ZW1TdWJ0cmVlcywgZm9sZGVySWQpID8/IHRoaXMuZ2V0Rm9sZGVyQnlJZEluU3VidHJlZXModGhpcy5jdXN0b21TdWJ0cmVlcywgZm9sZGVySWQpXG5cdFx0cmV0dXJuIHN1YnRyZWU/LmZvbGRlciA/PyBudWxsXG5cdH1cblxuXHRnZXRGb2xkZXJCeU1haWwobWFpbDogTWFpbCk6IE1haWxGb2xkZXIgfCBudWxsIHtcblx0XHRjb25zdCBzZXRzID0gbWFpbC5zZXRzXG5cdFx0aWYgKGlzTm90RW1wdHkoc2V0cykpIHtcblx0XHRcdGZvciAoY29uc3Qgc2V0SWQgb2Ygc2V0cykge1xuXHRcdFx0XHRjb25zdCBmb2xkZXIgPSB0aGlzLmdldEZvbGRlckJ5SWQoZWxlbWVudElkUGFydChzZXRJZCkpXG5cdFx0XHRcdGlmIChmb2xkZXIgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBmb2xkZXJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGxcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Rm9sZGVyQnlNYWlsTGlzdElkTGVnYWN5KGdldExpc3RJZChtYWlsKSlcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdldEZvbGRlckJ5TWFpbExpc3RJZExlZ2FjeShtYWlsTGlzdElkOiBJZCk6IE1haWxGb2xkZXIgfCBudWxsIHtcblx0XHRjb25zdCBzdWJ0cmVlID1cblx0XHRcdHRoaXMuZ2V0Rm9sZGVyQnlNYWlsTGlzdElkSW5TdWJ0cmVlcyh0aGlzLnN5c3RlbVN1YnRyZWVzLCBtYWlsTGlzdElkKSA/PyB0aGlzLmdldEZvbGRlckJ5TWFpbExpc3RJZEluU3VidHJlZXModGhpcy5jdXN0b21TdWJ0cmVlcywgbWFpbExpc3RJZClcblx0XHRyZXR1cm4gc3VidHJlZT8uZm9sZGVyID8/IG51bGxcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiBvZiBhIHBhcmVudCAoYXBwbGllcyBvbmx5IHRvIGN1c3RvbSBmb2xkZXJzKVxuXHQgKiBpZiBubyBwYXJlbnQgaXMgZ2l2ZW4sIHRoZSB0b3AgbGV2ZWwgY3VzdG9tIGZvbGRlcnMgYXJlIHJldHVybmVkXG5cdCAqL1xuXHRnZXRDdXN0b21Gb2xkZXJzT2ZQYXJlbnQocGFyZW50OiBJZFR1cGxlIHwgbnVsbCk6IE1haWxGb2xkZXJbXSB7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0Y29uc3QgcGFyZW50Rm9sZGVyID0gdGhpcy5nZXRGb2xkZXJCeUlkSW5TdWJ0cmVlcyhbLi4udGhpcy5jdXN0b21TdWJ0cmVlcywgLi4udGhpcy5zeXN0ZW1TdWJ0cmVlc10sIGVsZW1lbnRJZFBhcnQocGFyZW50KSlcblx0XHRcdHJldHVybiBwYXJlbnRGb2xkZXIgPyBwYXJlbnRGb2xkZXIuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuZm9sZGVyKSA6IFtdXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmN1c3RvbVN1YnRyZWVzLm1hcCgoc3VidHJlZSkgPT4gc3VidHJlZS5mb2xkZXIpXG5cdFx0fVxuXHR9XG5cblx0Z2V0RGVzY2VuZGFudEZvbGRlcnNPZlBhcmVudChwYXJlbnQ6IElkVHVwbGUpOiBJbmRlbnRlZEZvbGRlcltdIHtcblx0XHRjb25zdCBwYXJlbnRGb2xkZXIgPSB0aGlzLmdldEZvbGRlckJ5SWRJblN1YnRyZWVzKFsuLi50aGlzLmN1c3RvbVN1YnRyZWVzLCAuLi50aGlzLnN5c3RlbVN1YnRyZWVzXSwgZWxlbWVudElkUGFydChwYXJlbnQpKVxuXHRcdGlmIChwYXJlbnRGb2xkZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEluZGVudGVkRm9sZGVyTGlzdChbcGFyZW50Rm9sZGVyXSkuc2xpY2UoMSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFtdXG5cdFx0fVxuXHR9XG5cblx0LyoqIHJldHVybnMgYWxsIHBhcmVudHMgb2YgdGhlIGZvbGRlciwgaW5jbHVkaW5nIHRoZSBmb2xkZXIgaXRzZWxmICovXG5cdGdldFBhdGhUb0ZvbGRlcihmb2xkZXJJZDogSWRUdXBsZSk6IE1haWxGb2xkZXJbXSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGF0aFRvRm9sZGVySW5TdWJ0cmVlcyh0aGlzLnN5c3RlbVN1YnRyZWVzLCBmb2xkZXJJZCkgPz8gdGhpcy5nZXRQYXRoVG9Gb2xkZXJJblN1YnRyZWVzKHRoaXMuY3VzdG9tU3VidHJlZXMsIGZvbGRlcklkKSA/PyBbXVxuXHR9XG5cblx0Y2hlY2tGb2xkZXJGb3JBbmNlc3Rvcihmb2xkZXI6IE1haWxGb2xkZXIsIHBvdGVudGlhbEFuY2VzdG9ySWQ6IElkVHVwbGUpOiBib29sZWFuIHtcblx0XHRsZXQgY3VycmVudEZvbGRlclBvaW50ZXI6IE1haWxGb2xkZXIgfCBudWxsID0gZm9sZGVyXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGlmIChjdXJyZW50Rm9sZGVyUG9pbnRlcj8ucGFyZW50Rm9sZGVyID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9IGVsc2UgaWYgKGlzU2FtZUlkKGN1cnJlbnRGb2xkZXJQb2ludGVyLnBhcmVudEZvbGRlciwgcG90ZW50aWFsQW5jZXN0b3JJZCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdGN1cnJlbnRGb2xkZXJQb2ludGVyID0gdGhpcy5nZXRGb2xkZXJCeUlkKGVsZW1lbnRJZFBhcnQoY3VycmVudEZvbGRlclBvaW50ZXIucGFyZW50Rm9sZGVyKSlcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdldEluZGVudGVkRm9sZGVyTGlzdChzdWJ0cmVlczogUmVhZG9ubHlBcnJheTxGb2xkZXJTdWJ0cmVlPiwgZXhjbHVkZUZvbGRlcjogTWFpbEZvbGRlciB8IG51bGwgPSBudWxsLCBjdXJyZW50TGV2ZWw6IG51bWJlciA9IDApOiBJbmRlbnRlZEZvbGRlcltdIHtcblx0XHRjb25zdCBwbGFpbkxpc3Q6IEluZGVudGVkRm9sZGVyW10gPSBbXVxuXHRcdGZvciAoY29uc3Qgc3VidHJlZSBvZiBzdWJ0cmVlcykge1xuXHRcdFx0aWYgKCFleGNsdWRlRm9sZGVyIHx8ICFpc1NhbWVJZChzdWJ0cmVlLmZvbGRlci5faWQsIGV4Y2x1ZGVGb2xkZXIuX2lkKSkge1xuXHRcdFx0XHRwbGFpbkxpc3QucHVzaCh7IGxldmVsOiBjdXJyZW50TGV2ZWwsIGZvbGRlcjogc3VidHJlZS5mb2xkZXIgfSlcblx0XHRcdFx0cGxhaW5MaXN0LnB1c2goLi4udGhpcy5nZXRJbmRlbnRlZEZvbGRlckxpc3Qoc3VidHJlZS5jaGlsZHJlbiwgZXhjbHVkZUZvbGRlciwgY3VycmVudExldmVsICsgMSkpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwbGFpbkxpc3Rcblx0fVxuXG5cdHByaXZhdGUgZ2V0SW5kZW50ZWRTeXN0ZW1MaXN0KCk6IEluZGVudGVkRm9sZGVyW10ge1xuXHRcdHJldHVybiB0aGlzLnN5c3RlbVN1YnRyZWVzLm1hcCgoc3VidHJlZSkgPT4ge1xuXHRcdFx0cmV0dXJuIHsgbGV2ZWw6IDAsIGZvbGRlcjogc3VidHJlZS5mb2xkZXIgfVxuXHRcdH0pXG5cdH1cblxuXHRwcml2YXRlIGdldEZvbGRlckJ5SWRJblN1YnRyZWVzKHN5c3RlbXM6IFJlYWRvbmx5QXJyYXk8Rm9sZGVyU3VidHJlZT4sIGZvbGRlcklkOiBJZCk6IEZvbGRlclN1YnRyZWUgfCBudWxsIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRGb2xkZXJCeShzeXN0ZW1zLCAoc3lzdGVtKSA9PiBpc1NhbWVJZChnZXRFbGVtZW50SWQoc3lzdGVtLmZvbGRlciksIGZvbGRlcklkKSlcblx0fVxuXG5cdHByaXZhdGUgZ2V0Rm9sZGVyQnlNYWlsTGlzdElkSW5TdWJ0cmVlcyhzeXN0ZW1zOiBSZWFkb25seUFycmF5PEZvbGRlclN1YnRyZWU+LCBtYWlsTGlzdElkOiBJZCk6IEZvbGRlclN1YnRyZWUgfCBudWxsIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRGb2xkZXJCeShzeXN0ZW1zLCAoc3VidHJlZSkgPT4gaXNTYW1lSWQoc3VidHJlZS5mb2xkZXIubWFpbHMsIG1haWxMaXN0SWQpKVxuXHR9XG5cblx0cHJpdmF0ZSBnZXRGb2xkZXJCeShzeXN0ZW1zOiBSZWFkb25seUFycmF5PEZvbGRlclN1YnRyZWU+LCBwcmVkaWNhdGU6IChzdWJ0cmVlOiBGb2xkZXJTdWJ0cmVlKSA9PiBib29sZWFuKTogRm9sZGVyU3VidHJlZSB8IG51bGwge1xuXHRcdGNvbnN0IHRvcExldmVsID0gc3lzdGVtcy5maW5kKHByZWRpY2F0ZSlcblx0XHRpZiAodG9wTGV2ZWwpIHtcblx0XHRcdHJldHVybiB0b3BMZXZlbFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGNvbnN0IHRvcExldmVsU3lzdGVtIG9mIHN5c3RlbXMpIHtcblx0XHRcdFx0Y29uc3QgZm91bmQgPSB0aGlzLmdldEZvbGRlckJ5KHRvcExldmVsU3lzdGVtLmNoaWxkcmVuLCBwcmVkaWNhdGUpXG5cdFx0XHRcdGlmIChmb3VuZCkge1xuXHRcdFx0XHRcdHJldHVybiBmb3VuZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsXG5cdH1cblxuXHRwcml2YXRlIGdldFBhdGhUb0ZvbGRlckluU3VidHJlZXMoc3lzdGVtczogcmVhZG9ubHkgRm9sZGVyU3VidHJlZVtdLCBmb2xkZXJJZDogSWRUdXBsZSk6IE1haWxGb2xkZXJbXSB8IG51bGwge1xuXHRcdGZvciAoY29uc3Qgc3lzdGVtIG9mIHN5c3RlbXMpIHtcblx0XHRcdGlmIChpc1NhbWVJZChzeXN0ZW0uZm9sZGVyLl9pZCwgZm9sZGVySWQpKSB7XG5cdFx0XHRcdHJldHVybiBbc3lzdGVtLmZvbGRlcl1cblx0XHRcdH1cblx0XHRcdGNvbnN0IHN1YnBhdGggPSB0aGlzLmdldFBhdGhUb0ZvbGRlckluU3VidHJlZXMoc3lzdGVtLmNoaWxkcmVuLCBmb2xkZXJJZClcblx0XHRcdGlmIChzdWJwYXRoKSB7XG5cdFx0XHRcdHJldHVybiBbc3lzdGVtLmZvbGRlcl0uY29uY2F0KC4uLnN1YnBhdGgpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsXG5cdH1cblxuXHRwcml2YXRlIG1ha2VTdWJ0cmVlKGZvbGRlckJ5UGFyZW50OiBNYXA8SWQgfCBudWxsLCByZWFkb25seSBNYWlsRm9sZGVyW10+LCBwYXJlbnQ6IE1haWxGb2xkZXIsIGNvbXBhcmF0b3I6IEZvbGRlckNvbXBhcmF0b3IpOiBGb2xkZXJTdWJ0cmVlIHtcblx0XHRjb25zdCBjaGlsZHJlbkZvbGRlcnMgPSBmb2xkZXJCeVBhcmVudC5nZXQoZ2V0RWxlbWVudElkKHBhcmVudCkpXG5cdFx0aWYgKGNoaWxkcmVuRm9sZGVycykge1xuXHRcdFx0Y29uc3QgY2hpbGRTeXN0ZW1zID0gY2hpbGRyZW5Gb2xkZXJzXG5cdFx0XHRcdC5zbGljZSgpXG5cdFx0XHRcdC5zb3J0KGNvbXBhcmF0b3IpXG5cdFx0XHRcdC5tYXAoKGNoaWxkKSA9PiB0aGlzLm1ha2VTdWJ0cmVlKGZvbGRlckJ5UGFyZW50LCBjaGlsZCwgY29tcGFyYXRvcikpXG5cdFx0XHRyZXR1cm4geyBmb2xkZXI6IHBhcmVudCwgY2hpbGRyZW46IGNoaWxkU3lzdGVtcyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7IGZvbGRlcjogcGFyZW50LCBjaGlsZHJlbjogW10gfVxuXHRcdH1cblx0fVxufVxuXG50eXBlIEZvbGRlckNvbXBhcmF0b3IgPSAoZm9sZGVyMTogTWFpbEZvbGRlciwgZm9sZGVyMjogTWFpbEZvbGRlcikgPT4gbnVtYmVyXG5cbmZ1bmN0aW9uIGNvbXBhcmVDdXN0b20oZm9sZGVyMTogTWFpbEZvbGRlciwgZm9sZGVyMjogTWFpbEZvbGRlcik6IG51bWJlciB7XG5cdHJldHVybiBmb2xkZXIxLm5hbWUubG9jYWxlQ29tcGFyZShmb2xkZXIyLm5hbWUpXG59XG5cbnR5cGUgU3lzdGVtTWFpbEZvbGRlclR5cGVzID0gRXhjbHVkZTxNYWlsU2V0S2luZCwgTWFpbFNldEtpbmQuQ1VTVE9NIHwgTWFpbFNldEtpbmQuTEFCRUwgfCBNYWlsU2V0S2luZC5JbXBvcnRlZD5cblxuY29uc3QgZm9sZGVyVHlwZVRvT3JkZXI6IFJlY29yZDxTeXN0ZW1NYWlsRm9sZGVyVHlwZXMsIG51bWJlcj4gPSB7XG5cdFtNYWlsU2V0S2luZC5JTkJPWF06IDAsXG5cdFtNYWlsU2V0S2luZC5EUkFGVF06IDEsXG5cdFtNYWlsU2V0S2luZC5TRU5UXTogMixcblx0W01haWxTZXRLaW5kLlRSQVNIXTogNCxcblx0W01haWxTZXRLaW5kLkFSQ0hJVkVdOiA1LFxuXHRbTWFpbFNldEtpbmQuU1BBTV06IDYsXG5cdFtNYWlsU2V0S2luZC5BTExdOiA3LFxufVxuXG5mdW5jdGlvbiBjb21wYXJlU3lzdGVtKGZvbGRlcjE6IE1haWxGb2xkZXIsIGZvbGRlcjI6IE1haWxGb2xkZXIpOiBudW1iZXIge1xuXHRjb25zdCBvcmRlcjEgPSBmb2xkZXJUeXBlVG9PcmRlcltmb2xkZXIxLmZvbGRlclR5cGUgYXMgU3lzdGVtTWFpbEZvbGRlclR5cGVzXSA/PyA3XG5cdGNvbnN0IG9yZGVyMiA9IGZvbGRlclR5cGVUb09yZGVyW2ZvbGRlcjIuZm9sZGVyVHlwZSBhcyBTeXN0ZW1NYWlsRm9sZGVyVHlwZXNdID8/IDdcblx0cmV0dXJuIG9yZGVyMSAtIG9yZGVyMlxufVxuXG4vKipcbiAqIGFuIGFycmF5IG9mIEZvbGRlclN5c3RlbXMgcmVwcmVzZW50IGFsbCBmb2xkZXJzLlxuICogdGhlIHRvcCBmb2xkZXJzIGFyZSB0aGUgdG9wbGV2ZWwgZm9sZGVycyBpbiB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgc3ViZm9sZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGb2xkZXJTdWJ0cmVlIHtcblx0cmVhZG9ubHkgZm9sZGVyOiBNYWlsRm9sZGVyXG5cdHJlYWRvbmx5IGNoaWxkcmVuOiByZWFkb25seSBGb2xkZXJTdWJ0cmVlW11cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O01Bc0JhLG9CQUFvQjtJQWtCcEIsZ0JBQU4sTUFBeUM7Ozs7Q0FJL0MsQUFBaUI7Q0FFakIsWUFBNkJBLGNBQTZDQyxlQUErQ0MsZ0JBQWdDO0VBaUV6SixLQWpFNkI7RUFpRTVCLEtBakV5RTtFQWlFeEUsS0FqRXVIO0FBQ3hILE9BQUssa0JBQWtCLElBQUk7Q0FDM0I7Q0FFRCxXQUFXQyxVQUFpQkMsTUFBZ0M7RUFDM0QsSUFBSUM7RUFHSixNQUFNLGtCQUFrQixNQUFNO0FBQzdCLFFBQUssZ0JBQWdCLE9BQU8sVUFBVTtBQUV0QyxhQUFVO0VBQ1Y7QUFFRCxjQUFZLEtBQUssbUJBQW1CLGlC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