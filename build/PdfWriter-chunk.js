import "./dist-chunk.js";
import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { concat, hexToUint8Array } from "./dist2-chunk.js";
import { Deflater, GENERATION_NUMBER, NEW_LINE, PDF_DEFAULT_OBJECTS, PDF_METADATA, PdfStreamEncoding } from "./Deflater-chunk.js";

//#region src/common/api/worker/pdf/PdfObject.ts
var PdfObject = class {
	objectNumber;
	bytePosition = -1;
	objectDictionary = new Map();
	constructor(objectNumber, objectDictionary) {
		this.objectNumber = objectNumber;
		this.objectDictionary = objectDictionary;
	}
	getDictionary() {
		return this.objectDictionary;
	}
	getObjectNumber() {
		return this.objectNumber;
	}
	getBytePosition() {
		return this.bytePosition;
	}
	/**
	* Set the dictionary of the object to be one with all references resolved (string, string)
	*/
	setResolvedDictionary(map) {
		this.objectDictionary = map;
	}
	/**
	* Set the byte-position of the object which is the byte in the PDF file at which the object's declaration starts
	*/
	setBytePosition(bytePosition) {
		this.bytePosition = bytePosition;
	}
	/**
	* Encode the object into a Uint8Array to enable writing it into a buffer / file
	* @param textEncoder
	*/
	encodeToUInt8Array(textEncoder) {
		return new Uint8Array([...textEncoder.encode(this.parseObjectHead()), ...textEncoder.encode(this.parseObjectTail())]);
	}
	/**
	* Convert the object's head data into PDF syntax
	*/
	parseObjectHead() {
		let head = `${this.objectNumber} ${GENERATION_NUMBER} obj${NEW_LINE}<<${NEW_LINE}`;
		for (const [key, val] of this.objectDictionary) {
			if (typeof val !== "string") throw new Error(`Unresolved reference in object: ${this.objectNumber}. Unresolved reference found as value of: "${key}". Cannot encode an object that has unresolved references, aborting...`);
			head += `/${key} ${val}`;
		}
		head += `${NEW_LINE}>>${NEW_LINE}`;
		return head;
	}
	/**
	* Convert the object's tail data into PDF syntax
	*/
	parseObjectTail() {
		return `endobj${NEW_LINE}`;
	}
};

//#endregion
//#region src/common/api/worker/pdf/PdfStreamObject.ts
var PdfStreamObject = class extends PdfObject {
	stream;
	constructor(objectNumber, objectDictionary, stream, streamEncoding) {
		super(objectNumber, objectDictionary);
		this.stream = stream;
		if (streamEncoding !== "NONE") this.objectDictionary.set("Filter", streamEncoding);
		this.objectDictionary.set("Length", stream.byteLength.toString());
	}
	encodeToUInt8Array(textEncoder) {
		return new Uint8Array([
			...textEncoder.encode(this.parseObjectHead()),
			...this.stream,
			...textEncoder.encode(this.parseObjectTail())
		]);
	}
	parseObjectHead() {
		let head = `${this.objectNumber} ${GENERATION_NUMBER} obj${NEW_LINE}<<${NEW_LINE}`;
		for (const [key, val] of this.objectDictionary) head += `/${key} ${val}`;
		head += `${NEW_LINE}>>${NEW_LINE}stream${NEW_LINE}`;
		return head;
	}
	parseObjectTail() {
		return `${NEW_LINE}endstream${NEW_LINE}endobj${NEW_LINE}`;
	}
};

//#endregion
//#region src/common/api/worker/pdf/PdfWriter.ts
const PDF_HEADER = hexToUint8Array("255044462d322e300a25e2e3cfd30a");
const ZERO_OBJECT_ENTRY = "0000000000 65535 f";
var PdfWriter = class {
	textEncoder;
	customFetch;
	deflater;
	byteLengthPosition = PDF_HEADER.byteLength;
	pdfObjectList = [];
	referenceTable = new Map();
	cachedResources;
	constructor(textEncoder, customFetch) {
		this.textEncoder = textEncoder;
		this.customFetch = customFetch;
		this.deflater = new Deflater();
		this.cachedResources = undefined;
	}
	/**
	* Add all PDF default objects to this writer that are necessary for any functioning document, see "PdfConstants"
	*/
	setupDefaultObjects() {
		for (const object of PDF_DEFAULT_OBJECTS) this.createObject(object.dictionary, object.refId);
	}
	/**
	* Create a new PDF object
	* @param objectDictionary Map of the object dictionary
	* @param refId ID by which other objects can reference this object
	*/
	createObject(objectDictionary, refId = "") {
		if (this.referenceTable.has(refId)) throw new ProgrammingError(`already defined object refId ${refId}`);
		const obj = new PdfObject(this.pdfObjectList.length + 1, objectDictionary);
		if (refId.length > 0) this.referenceTable.set(refId, obj);
		this.pdfObjectList.push(obj);
	}
	/**
	* Create a new PDF object with stream data
	* @param objectDictionary Map of the object dictionary. Must not provide stream-specific data
	* @param stream The stream of the object
	* @param streamEncoding The encoding of the stream
	* @param refId ID by which other objects can reference this object
	*/
	createStreamObject(objectDictionary, stream, streamEncoding, refId = "") {
		if (this.referenceTable.has(refId)) throw new ProgrammingError(`already defined stream refId ${refId}`);
		const obj = new PdfStreamObject(this.pdfObjectList.length + 1, objectDictionary, stream, streamEncoding);
		if (refId.length > 0) this.referenceTable.set(refId, obj);
		this.pdfObjectList.push(obj);
	}
	/**
	* Get a PDF object added to this writer by its ID
	* @param refId The id of the desired object
	*/
	getObjectByRefId(refId) {
		const obj = this.referenceTable.get(refId);
		if (obj != null) return obj;
else throw new Error(`Invalid ReferenceId: ${refId}. No object was found that has this refId. Reference can't be resolved, aborting...`);
	}
	/**
	* Write the cross-reference table of the PDF which is a special object lookup table for PDF readers
	*/
	makeXRefTable() {
		let xref = `xref${NEW_LINE}0 ${this.pdfObjectList.length + 1}${NEW_LINE}${ZERO_OBJECT_ENTRY} ${NEW_LINE}`;
		for (const pdfObject of this.pdfObjectList) {
			if (pdfObject.getBytePosition() === -1) throw new Error(`Found an object with invalid byte-position! ${pdfObject.getObjectNumber()}`);
			xref += `${("0000000000" + pdfObject.getBytePosition()).slice(-10)} 00000 n ${NEW_LINE}`;
		}
		return xref;
	}
	/**
	* Write the trailer of the PDF which is a special object pointing at the "Catalog object" and additional metadata
	* @param identifier A preferably unique string
	*/
	makeTrailer(identifier) {
		let trailer = `trailer${NEW_LINE}<<${NEW_LINE}`;
		trailer += `/Size ${this.pdfObjectList.length + 1}`;
		trailer += `/Root ${this.pdfReferenceToString({ refId: "CATALOG" })}`;
		trailer += `/ID [(${identifier})(${identifier})]`;
		trailer += `${NEW_LINE}>>${NEW_LINE}startxref${NEW_LINE}${this.byteLengthPosition}${NEW_LINE}%%EOF`;
		return trailer;
	}
	/**
	* Resolve all references to other objects in a PDF dictionary
	* This replaces every refId with the string "objNumber 0 R" which is PDF syntax for referencing other objects
	* Returns the PDF dictionary as Map of <string, string> allowing it to be encoded
	* @param objDictionary The dictionary t
	*/
	resolveReferences(objDictionary) {
		const newMap = new Map();
		for (const [key, value] of objDictionary) newMap.set(key, this.resolveDictValue(value));
		return newMap;
	}
	/**
	* Resolve a PdfDictValue into its string equivalent
	* @param value Value to resolve
	*/
	resolveDictValue(value) {
		if (typeof value !== "string") if (value instanceof Map) return this.pdfDictionaryToString(value);
else if (Array.isArray(value)) return this.pdfListToString(value);
else return this.pdfReferenceToString(value);
else return value;
	}
	pdfReferenceToString(objectReference) {
		const referencedObject = this.getObjectByRefId(objectReference.refId);
		return `${referencedObject.getObjectNumber()} ${GENERATION_NUMBER} R`;
	}
	pdfListToString(objectReferences) {
		let referenceString = "[ ";
		for (const objRef of objectReferences) referenceString += this.resolveDictValue(objRef) + " ";
		referenceString += "]";
		return referenceString;
	}
	pdfDictionaryToString(objectReferenceDict) {
		let referenceString = "<< ";
		for (const [key, value] of objectReferenceDict) referenceString += `/${key} ${this.resolveDictValue(value)} `;
		referenceString += ">>";
		return referenceString;
	}
	/**
	* Calculate the byte-position for a given object
	* @param object The object that should have its byte-position be calculated
	* @param encodedObject The provided object in encoded format to allow calculation for the next object
	*/
	calculateBytePositions(object, encodedObject) {
		object.setBytePosition(this.byteLengthPosition);
		this.byteLengthPosition += encodedObject.byteLength;
	}
	/**
	* Add all resource objects (stream objects) to the PDF. These are referenced by the "default objects" but need to be dynamically generated because they
	* include a huge amount of stream data / need to read their stream data in from external resources (base64 encoded)
	*/
	async setupResourceObjects() {
		const baseUrl = typeof location === "undefined" ? "" : location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "");
		if (!this.cachedResources) this.cachedResources = await Promise.all([
			"/pdf/SourceSans3-Regular.ttf",
			"/pdf/SourceSans3-Bold.ttf",
			"/pdf/sRGB2014.icc",
			"/pdf/identity_h.cmap",
			"/pdf/tutanota_logo_en.jpg"
		].map((url) => typeof this.customFetch !== "undefined" ? this.customFetch(baseUrl + url).then((r) => r.arrayBuffer()) : fetch(baseUrl + url).then((r) => r.arrayBuffer())));
		const [fontRegular, fontBold, colorProfile, cmap, tutaImage] = this.cachedResources;
		this.createStreamObject(new Map([["Length1", fontRegular.byteLength.toString()]]), await this.deflater.deflate(fontRegular), PdfStreamEncoding.FLATE, "FONT_REGULAR_FILE");
		this.createStreamObject(new Map([["Length1", fontBold.byteLength.toString()]]), await this.deflater.deflate(fontBold), PdfStreamEncoding.FLATE, "FONT_BOLD_FILE");
		this.createStreamObject(new Map([
			["Type", "/CMap"],
			["CMapName", "/Identity-H "],
			["CIDSystemInfo", "<< /Registry (Adobe) /Ordering (Identity) /Supplement 0 >>"]
		]), await this.deflater.deflate(cmap), PdfStreamEncoding.FLATE, "CMAP");
		this.createStreamObject(new Map([["Length1", colorProfile.byteLength.toString()], ["N", "3"]]), await this.deflater.deflate(colorProfile), PdfStreamEncoding.FLATE, "DEST_OUTPUT_PROFILE");
		this.createStreamObject(new Map([
			["Name", "/Im1"],
			["Type", "/XObject"],
			["Subtype", "/Image"],
			["Width", "600"],
			["Height", "209"],
			["BitsPerComponent", "8"],
			["ColorSpace", "/DeviceRGB"]
		]), new Uint8Array(tutaImage), PdfStreamEncoding.DCT, "IMG_TUTA_LOGO");
		const todayDate = new Date();
		const metaData = PDF_METADATA.replace("{slotCreateDate}", todayDate.toISOString()).replace("{slotModifyDate}", todayDate.toISOString());
		this.createStreamObject(new Map([["Type", "/Metadata"], ["Subtype", "/XML"]]), new Uint8Array(this.textEncoder.encode(metaData)), PdfStreamEncoding.NONE, "METADATA");
	}
	/**
	* Writes the PDF file and return its entire data as a Uint8Array
	* @pre baseUrl must be defined
	*/
	async writePdfFile() {
		await this.setupResourceObjects();
		const encodedObjects = [];
		encodedObjects.push(PDF_HEADER);
		for (const obj of this.pdfObjectList) {
			obj.setResolvedDictionary(this.resolveReferences(obj.getDictionary()));
			const encodedObject = obj.encodeToUInt8Array(this.textEncoder);
			this.calculateBytePositions(obj, encodedObject);
			encodedObjects.push(encodedObject);
		}
		encodedObjects.push(this.textEncoder.encode(this.makeXRefTable()));
		encodedObjects.push(this.textEncoder.encode(this.makeTrailer(Date.now().toString())));
		return concat(...encodedObjects);
	}
};

//#endregion
export { PdfWriter };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGRmV3JpdGVyLWNodW5rLmpzIiwibmFtZXMiOlsib2JqZWN0TnVtYmVyOiBudW1iZXIiLCJvYmplY3REaWN0aW9uYXJ5OiBNYXA8c3RyaW5nLCBQZGZEaWN0VmFsdWU+IiwibWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+IiwiYnl0ZVBvc2l0aW9uOiBudW1iZXIiLCJ0ZXh0RW5jb2RlcjogVGV4dEVuY29kZXIiLCJvYmplY3ROdW1iZXI6IG51bWJlciIsIm9iamVjdERpY3Rpb25hcnk6IE1hcDxzdHJpbmcsIFBkZkRpY3RWYWx1ZT4iLCJzdHJlYW06IFVpbnQ4QXJyYXkiLCJzdHJlYW1FbmNvZGluZzogUGRmU3RyZWFtRW5jb2RpbmciLCJ0ZXh0RW5jb2RlcjogVGV4dEVuY29kZXIiLCJ0ZXh0RW5jb2RlcjogVGV4dEVuY29kZXIiLCJjdXN0b21GZXRjaDogR2xvYmFsRmV0Y2ggfCB1bmRlZmluZWQiLCJvYmplY3REaWN0aW9uYXJ5OiBNYXA8c3RyaW5nLCBQZGZEaWN0VmFsdWU+IiwicmVmSWQ6IHN0cmluZyIsInN0cmVhbTogVWludDhBcnJheSIsInN0cmVhbUVuY29kaW5nOiBQZGZTdHJlYW1FbmNvZGluZyIsImlkZW50aWZpZXI6IHN0cmluZyIsIm9iakRpY3Rpb25hcnk6IE1hcDxzdHJpbmcsIFBkZkRpY3RWYWx1ZT4iLCJ2YWx1ZTogUGRmRGljdFZhbHVlIiwib2JqZWN0UmVmZXJlbmNlOiBQZGZPYmplY3RSZWYiLCJvYmplY3RSZWZlcmVuY2VzOiBQZGZEaWN0VmFsdWVbXSIsIm9iamVjdFJlZmVyZW5jZURpY3Q6IE1hcDxzdHJpbmcsIFBkZkRpY3RWYWx1ZT4iLCJvYmplY3Q6IFBkZk9iamVjdCIsImVuY29kZWRPYmplY3Q6IFVpbnQ4QXJyYXkiLCJlbmNvZGVkT2JqZWN0czogVWludDhBcnJheVtdIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9hcGkvd29ya2VyL3BkZi9QZGZPYmplY3QudHMiLCIuLi9zcmMvY29tbW9uL2FwaS93b3JrZXIvcGRmL1BkZlN0cmVhbU9iamVjdC50cyIsIi4uL3NyYy9jb21tb24vYXBpL3dvcmtlci9wZGYvUGRmV3JpdGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdFTkVSQVRJT05fTlVNQkVSLCBORVdfTElORSwgUGRmRGljdFZhbHVlIH0gZnJvbSBcIi4vUGRmQ29uc3RhbnRzLmpzXCJcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb2JqZWN0cyBpbiBQREYuXG4gKiBIb2xkcyBkYXRhIGluIGZvcm0gb2YgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2hpY2ggbWlycm9yIHRoZSBhY3R1YWwgUERGIG9iamVjdCdzIFwib2JqZWN0IGRpY3Rpb25hcnlcIlxuICovXG5leHBvcnQgY2xhc3MgUGRmT2JqZWN0IHtcblx0cHJvdGVjdGVkIHJlYWRvbmx5IG9iamVjdE51bWJlcjogbnVtYmVyXG5cdHByb3RlY3RlZCBieXRlUG9zaXRpb246IG51bWJlciA9IC0xXG5cdHByb3RlY3RlZCBvYmplY3REaWN0aW9uYXJ5OiBNYXA8c3RyaW5nLCBQZGZEaWN0VmFsdWU+ID0gbmV3IE1hcDxzdHJpbmcsIFBkZkRpY3RWYWx1ZT4oKVxuXG5cdGNvbnN0cnVjdG9yKG9iamVjdE51bWJlcjogbnVtYmVyLCBvYmplY3REaWN0aW9uYXJ5OiBNYXA8c3RyaW5nLCBQZGZEaWN0VmFsdWU+KSB7XG5cdFx0dGhpcy5vYmplY3ROdW1iZXIgPSBvYmplY3ROdW1iZXJcblx0XHR0aGlzLm9iamVjdERpY3Rpb25hcnkgPSBvYmplY3REaWN0aW9uYXJ5XG5cdH1cblxuXHRwdWJsaWMgZ2V0RGljdGlvbmFyeSgpOiBNYXA8c3RyaW5nLCBQZGZEaWN0VmFsdWU+IHtcblx0XHRyZXR1cm4gdGhpcy5vYmplY3REaWN0aW9uYXJ5XG5cdH1cblxuXHRwdWJsaWMgZ2V0T2JqZWN0TnVtYmVyKCkge1xuXHRcdHJldHVybiB0aGlzLm9iamVjdE51bWJlclxuXHR9XG5cblx0cHVibGljIGdldEJ5dGVQb3NpdGlvbigpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmJ5dGVQb3NpdGlvblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGljdGlvbmFyeSBvZiB0aGUgb2JqZWN0IHRvIGJlIG9uZSB3aXRoIGFsbCByZWZlcmVuY2VzIHJlc29sdmVkIChzdHJpbmcsIHN0cmluZylcblx0ICovXG5cdHB1YmxpYyBzZXRSZXNvbHZlZERpY3Rpb25hcnkobWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+KSB7XG5cdFx0dGhpcy5vYmplY3REaWN0aW9uYXJ5ID0gbWFwXG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBieXRlLXBvc2l0aW9uIG9mIHRoZSBvYmplY3Qgd2hpY2ggaXMgdGhlIGJ5dGUgaW4gdGhlIFBERiBmaWxlIGF0IHdoaWNoIHRoZSBvYmplY3QncyBkZWNsYXJhdGlvbiBzdGFydHNcblx0ICovXG5cdHB1YmxpYyBzZXRCeXRlUG9zaXRpb24oYnl0ZVBvc2l0aW9uOiBudW1iZXIpIHtcblx0XHR0aGlzLmJ5dGVQb3NpdGlvbiA9IGJ5dGVQb3NpdGlvblxuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZSB0aGUgb2JqZWN0IGludG8gYSBVaW50OEFycmF5IHRvIGVuYWJsZSB3cml0aW5nIGl0IGludG8gYSBidWZmZXIgLyBmaWxlXG5cdCAqIEBwYXJhbSB0ZXh0RW5jb2RlclxuXHQgKi9cblx0cHVibGljIGVuY29kZVRvVUludDhBcnJheSh0ZXh0RW5jb2RlcjogVGV4dEVuY29kZXIpOiBVaW50OEFycmF5IHtcblx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWy4uLnRleHRFbmNvZGVyLmVuY29kZSh0aGlzLnBhcnNlT2JqZWN0SGVhZCgpKSwgLi4udGV4dEVuY29kZXIuZW5jb2RlKHRoaXMucGFyc2VPYmplY3RUYWlsKCkpXSlcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoZSBvYmplY3QncyBoZWFkIGRhdGEgaW50byBQREYgc3ludGF4XG5cdCAqL1xuXHRwdWJsaWMgcGFyc2VPYmplY3RIZWFkKCk6IHN0cmluZyB7XG5cdFx0bGV0IGhlYWQgPSBgJHt0aGlzLm9iamVjdE51bWJlcn0gJHtHRU5FUkFUSU9OX05VTUJFUn0gb2JqJHtORVdfTElORX08PCR7TkVXX0xJTkV9YFxuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLm9iamVjdERpY3Rpb25hcnkpIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0YFVucmVzb2x2ZWQgcmVmZXJlbmNlIGluIG9iamVjdDogJHt0aGlzLm9iamVjdE51bWJlcn0uIFVucmVzb2x2ZWQgcmVmZXJlbmNlIGZvdW5kIGFzIHZhbHVlIG9mOiBcIiR7a2V5fVwiLiBDYW5ub3QgZW5jb2RlIGFuIG9iamVjdCB0aGF0IGhhcyB1bnJlc29sdmVkIHJlZmVyZW5jZXMsIGFib3J0aW5nLi4uYCxcblx0XHRcdFx0KVxuXHRcdFx0aGVhZCArPSBgLyR7a2V5fSAke3ZhbH1gXG5cdFx0fVxuXHRcdGhlYWQgKz0gYCR7TkVXX0xJTkV9Pj4ke05FV19MSU5FfWBcblx0XHRyZXR1cm4gaGVhZFxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIG9iamVjdCdzIHRhaWwgZGF0YSBpbnRvIFBERiBzeW50YXhcblx0ICovXG5cdHB1YmxpYyBwYXJzZU9iamVjdFRhaWwoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gYGVuZG9iaiR7TkVXX0xJTkV9YFxuXHR9XG59XG4iLCJpbXBvcnQgeyBQZGZPYmplY3QgfSBmcm9tIFwiLi9QZGZPYmplY3QuanNcIlxuaW1wb3J0IHsgR0VORVJBVElPTl9OVU1CRVIsIE5FV19MSU5FLCBQZGZEaWN0VmFsdWUsIFBkZlN0cmVhbUVuY29kaW5nIH0gZnJvbSBcIi4vUGRmQ29uc3RhbnRzLmpzXCJcblxuLyoqXG4gKiBQREYgb2JqZWN0IHdpdGggYW4gYWRkaXRpb25hbCBzdHJlYW0uXG4gKiBUaGUgc3RyZWFtIHJlcXVpcmVzIGRpZmZlcmVudCBlbmNvZGluZyBzeW50YXhcbiAqL1xuZXhwb3J0IGNsYXNzIFBkZlN0cmVhbU9iamVjdCBleHRlbmRzIFBkZk9iamVjdCB7XG5cdHByaXZhdGUgcmVhZG9ubHkgc3RyZWFtOiBVaW50OEFycmF5XG5cblx0Y29uc3RydWN0b3Iob2JqZWN0TnVtYmVyOiBudW1iZXIsIG9iamVjdERpY3Rpb25hcnk6IE1hcDxzdHJpbmcsIFBkZkRpY3RWYWx1ZT4sIHN0cmVhbTogVWludDhBcnJheSwgc3RyZWFtRW5jb2Rpbmc6IFBkZlN0cmVhbUVuY29kaW5nKSB7XG5cdFx0c3VwZXIob2JqZWN0TnVtYmVyLCBvYmplY3REaWN0aW9uYXJ5KVxuXHRcdHRoaXMuc3RyZWFtID0gc3RyZWFtXG5cdFx0aWYgKHN0cmVhbUVuY29kaW5nICE9PSBcIk5PTkVcIikge1xuXHRcdFx0dGhpcy5vYmplY3REaWN0aW9uYXJ5LnNldChcIkZpbHRlclwiLCBzdHJlYW1FbmNvZGluZylcblx0XHR9XG5cdFx0dGhpcy5vYmplY3REaWN0aW9uYXJ5LnNldChcIkxlbmd0aFwiLCBzdHJlYW0uYnl0ZUxlbmd0aC50b1N0cmluZygpKVxuXHR9XG5cblx0cHVibGljIGVuY29kZVRvVUludDhBcnJheSh0ZXh0RW5jb2RlcjogVGV4dEVuY29kZXIpOiBVaW50OEFycmF5IHtcblx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWy4uLnRleHRFbmNvZGVyLmVuY29kZSh0aGlzLnBhcnNlT2JqZWN0SGVhZCgpKSwgLi4udGhpcy5zdHJlYW0sIC4uLnRleHRFbmNvZGVyLmVuY29kZSh0aGlzLnBhcnNlT2JqZWN0VGFpbCgpKV0pXG5cdH1cblxuXHRwdWJsaWMgcGFyc2VPYmplY3RIZWFkKCk6IHN0cmluZyB7XG5cdFx0bGV0IGhlYWQgPSBgJHt0aGlzLm9iamVjdE51bWJlcn0gJHtHRU5FUkFUSU9OX05VTUJFUn0gb2JqJHtORVdfTElORX08PCR7TkVXX0xJTkV9YFxuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLm9iamVjdERpY3Rpb25hcnkpIHtcblx0XHRcdGhlYWQgKz0gYC8ke2tleX0gJHt2YWx9YFxuXHRcdH1cblx0XHRoZWFkICs9IGAke05FV19MSU5FfT4+JHtORVdfTElORX1zdHJlYW0ke05FV19MSU5FfWBcblx0XHRyZXR1cm4gaGVhZFxuXHR9XG5cblx0cHVibGljIHBhcnNlT2JqZWN0VGFpbCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiBgJHtORVdfTElORX1lbmRzdHJlYW0ke05FV19MSU5FfWVuZG9iaiR7TkVXX0xJTkV9YFxuXHR9XG59XG4iLCJpbXBvcnQgeyBQZGZPYmplY3QgfSBmcm9tIFwiLi9QZGZPYmplY3QuanNcIlxuaW1wb3J0IHsgR0VORVJBVElPTl9OVU1CRVIsIE5FV19MSU5FLCBQREZfREVGQVVMVF9PQkpFQ1RTLCBQREZfTUVUQURBVEEsIFBkZkRpY3RWYWx1ZSwgUGRmT2JqZWN0UmVmLCBQZGZTdHJlYW1FbmNvZGluZyB9IGZyb20gXCIuL1BkZkNvbnN0YW50cy5qc1wiXG5pbXBvcnQgeyBQZGZTdHJlYW1PYmplY3QgfSBmcm9tIFwiLi9QZGZTdHJlYW1PYmplY3QuanNcIlxuaW1wb3J0IHsgY29uY2F0LCBoZXhUb1VpbnQ4QXJyYXkgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzXCJcbmltcG9ydCB7IERlZmxhdGVyIH0gZnJvbSBcIi4vRGVmbGF0ZXIuanNcIlxuaW1wb3J0IHsgUHJvZ3JhbW1pbmdFcnJvciB9IGZyb20gXCIuLi8uLi9jb21tb24vZXJyb3IvUHJvZ3JhbW1pbmdFcnJvci5qc1wiXG5cbi8vIEJpbmFyeSBoZWFkZXIgc3BlY2lmeWluZyB0aGUgUERGIHZlcnNpb24gKDIuMCA9IFwiMzIyZTMwXCIpIGFuZCB0aGUgZmFjdCB0aGF0IGJpbmFyeSBkYXRhIGlzIHByZXNlbnQgaW4gdGhlIGZpbGVcbmNvbnN0IFBERl9IRUFERVIgPSBoZXhUb1VpbnQ4QXJyYXkoXCIyNTUwNDQ0NjJkMzIyZTMwMGEyNWUyZTNjZmQzMGFcIilcbi8vIFNwZWNpYWwgUERGIG9iamVjdCB3aXRoIG51bWJlciAwLiBPbmx5IGFwcGVhcnMgaW4geHJlZiB0YWJsZVxuY29uc3QgWkVST19PQkpFQ1RfRU5UUlkgPSBcIjAwMDAwMDAwMDAgNjU1MzUgZlwiXG5cbnR5cGUgR2xvYmFsRmV0Y2ggPSB0eXBlb2YgZ2xvYmFsLmZldGNoXG5cbi8qKlxuICogT2JqZWN0IHdoaWNoIG1hbmFnZXMgdGhlIGxvdy1sZXZlbCBidWlsZGluZyBvZiBhIFBERiBkb2N1bWVudCBieSBtYW5hZ2luZyBvYmplY3RzIGFuZCB0aGVpciByZWxhdGlvbiB0byBlYWNoIG90aGVyLlxuICogRm9yIGhpZ2gtbGV2ZWwgZnVuY3Rpb25hbGl0eSBzZWUgXCJQZGZEb2N1bWVudFwiIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBQZGZXcml0ZXIge1xuXHRwcml2YXRlIHJlYWRvbmx5IHRleHRFbmNvZGVyOiBUZXh0RW5jb2RlclxuXHRwcml2YXRlIHJlYWRvbmx5IGN1c3RvbUZldGNoOiBHbG9iYWxGZXRjaCB8IHVuZGVmaW5lZFxuXHRwcml2YXRlIHJlYWRvbmx5IGRlZmxhdGVyOiBEZWZsYXRlclxuXHRwcml2YXRlIGJ5dGVMZW5ndGhQb3NpdGlvbiA9IFBERl9IRUFERVIuYnl0ZUxlbmd0aFxuXHRwcml2YXRlIHBkZk9iamVjdExpc3Q6IFBkZk9iamVjdFtdID0gW11cblx0cHJpdmF0ZSByZWZlcmVuY2VUYWJsZTogTWFwPHN0cmluZywgUGRmT2JqZWN0PiA9IG5ldyBNYXA8c3RyaW5nLCBQZGZPYmplY3Q+KClcblx0cHJpdmF0ZSBjYWNoZWRSZXNvdXJjZXM6IEFycmF5QnVmZmVyW10gfCB1bmRlZmluZWRcblxuXHRjb25zdHJ1Y3Rvcih0ZXh0RW5jb2RlcjogVGV4dEVuY29kZXIsIGN1c3RvbUZldGNoOiBHbG9iYWxGZXRjaCB8IHVuZGVmaW5lZCkge1xuXHRcdHRoaXMudGV4dEVuY29kZXIgPSB0ZXh0RW5jb2RlclxuXHRcdHRoaXMuY3VzdG9tRmV0Y2ggPSBjdXN0b21GZXRjaFxuXHRcdHRoaXMuZGVmbGF0ZXIgPSBuZXcgRGVmbGF0ZXIoKVxuXHRcdHRoaXMuY2FjaGVkUmVzb3VyY2VzID0gdW5kZWZpbmVkXG5cdH1cblxuXHQvKipcblx0ICogQWRkIGFsbCBQREYgZGVmYXVsdCBvYmplY3RzIHRvIHRoaXMgd3JpdGVyIHRoYXQgYXJlIG5lY2Vzc2FyeSBmb3IgYW55IGZ1bmN0aW9uaW5nIGRvY3VtZW50LCBzZWUgXCJQZGZDb25zdGFudHNcIlxuXHQgKi9cblx0c2V0dXBEZWZhdWx0T2JqZWN0cygpIHtcblx0XHRmb3IgKGNvbnN0IG9iamVjdCBvZiBQREZfREVGQVVMVF9PQkpFQ1RTKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZU9iamVjdChvYmplY3QuZGljdGlvbmFyeSwgb2JqZWN0LnJlZklkKVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgUERGIG9iamVjdFxuXHQgKiBAcGFyYW0gb2JqZWN0RGljdGlvbmFyeSBNYXAgb2YgdGhlIG9iamVjdCBkaWN0aW9uYXJ5XG5cdCAqIEBwYXJhbSByZWZJZCBJRCBieSB3aGljaCBvdGhlciBvYmplY3RzIGNhbiByZWZlcmVuY2UgdGhpcyBvYmplY3Rcblx0ICovXG5cdGNyZWF0ZU9iamVjdChvYmplY3REaWN0aW9uYXJ5OiBNYXA8c3RyaW5nLCBQZGZEaWN0VmFsdWU+LCByZWZJZDogc3RyaW5nID0gXCJcIik6IHZvaWQge1xuXHRcdGlmICh0aGlzLnJlZmVyZW5jZVRhYmxlLmhhcyhyZWZJZCkpIHtcblx0XHRcdHRocm93IG5ldyBQcm9ncmFtbWluZ0Vycm9yKGBhbHJlYWR5IGRlZmluZWQgb2JqZWN0IHJlZklkICR7cmVmSWR9YClcblx0XHR9XG5cdFx0Y29uc3Qgb2JqID0gbmV3IFBkZk9iamVjdCh0aGlzLnBkZk9iamVjdExpc3QubGVuZ3RoICsgMSwgb2JqZWN0RGljdGlvbmFyeSlcblx0XHRpZiAocmVmSWQubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5yZWZlcmVuY2VUYWJsZS5zZXQocmVmSWQsIG9iailcblx0XHR9XG5cdFx0dGhpcy5wZGZPYmplY3RMaXN0LnB1c2gob2JqKVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBQREYgb2JqZWN0IHdpdGggc3RyZWFtIGRhdGFcblx0ICogQHBhcmFtIG9iamVjdERpY3Rpb25hcnkgTWFwIG9mIHRoZSBvYmplY3QgZGljdGlvbmFyeS4gTXVzdCBub3QgcHJvdmlkZSBzdHJlYW0tc3BlY2lmaWMgZGF0YVxuXHQgKiBAcGFyYW0gc3RyZWFtIFRoZSBzdHJlYW0gb2YgdGhlIG9iamVjdFxuXHQgKiBAcGFyYW0gc3RyZWFtRW5jb2RpbmcgVGhlIGVuY29kaW5nIG9mIHRoZSBzdHJlYW1cblx0ICogQHBhcmFtIHJlZklkIElEIGJ5IHdoaWNoIG90aGVyIG9iamVjdHMgY2FuIHJlZmVyZW5jZSB0aGlzIG9iamVjdFxuXHQgKi9cblx0Y3JlYXRlU3RyZWFtT2JqZWN0KG9iamVjdERpY3Rpb25hcnk6IE1hcDxzdHJpbmcsIFBkZkRpY3RWYWx1ZT4sIHN0cmVhbTogVWludDhBcnJheSwgc3RyZWFtRW5jb2Rpbmc6IFBkZlN0cmVhbUVuY29kaW5nLCByZWZJZDogc3RyaW5nID0gXCJcIik6IHZvaWQge1xuXHRcdGlmICh0aGlzLnJlZmVyZW5jZVRhYmxlLmhhcyhyZWZJZCkpIHtcblx0XHRcdHRocm93IG5ldyBQcm9ncmFtbWluZ0Vycm9yKGBhbHJlYWR5IGRlZmluZWQgc3RyZWFtIHJlZklkICR7cmVmSWR9YClcblx0XHR9XG5cdFx0Y29uc3Qgb2JqID0gbmV3IFBkZlN0cmVhbU9iamVjdCh0aGlzLnBkZk9iamVjdExpc3QubGVuZ3RoICsgMSwgb2JqZWN0RGljdGlvbmFyeSwgc3RyZWFtLCBzdHJlYW1FbmNvZGluZylcblx0XHRpZiAocmVmSWQubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5yZWZlcmVuY2VUYWJsZS5zZXQocmVmSWQsIG9iailcblx0XHR9XG5cdFx0dGhpcy5wZGZPYmplY3RMaXN0LnB1c2gob2JqKVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhIFBERiBvYmplY3QgYWRkZWQgdG8gdGhpcyB3cml0ZXIgYnkgaXRzIElEXG5cdCAqIEBwYXJhbSByZWZJZCBUaGUgaWQgb2YgdGhlIGRlc2lyZWQgb2JqZWN0XG5cdCAqL1xuXHRnZXRPYmplY3RCeVJlZklkKHJlZklkOiBzdHJpbmcpOiBQZGZPYmplY3Qge1xuXHRcdGNvbnN0IG9iaiA9IHRoaXMucmVmZXJlbmNlVGFibGUuZ2V0KHJlZklkKVxuXHRcdGlmIChvYmogIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG9ialxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgUmVmZXJlbmNlSWQ6ICR7cmVmSWR9LiBObyBvYmplY3Qgd2FzIGZvdW5kIHRoYXQgaGFzIHRoaXMgcmVmSWQuIFJlZmVyZW5jZSBjYW4ndCBiZSByZXNvbHZlZCwgYWJvcnRpbmcuLi5gKVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZSB0aGUgY3Jvc3MtcmVmZXJlbmNlIHRhYmxlIG9mIHRoZSBQREYgd2hpY2ggaXMgYSBzcGVjaWFsIG9iamVjdCBsb29rdXAgdGFibGUgZm9yIFBERiByZWFkZXJzXG5cdCAqL1xuXHRtYWtlWFJlZlRhYmxlKCk6IHN0cmluZyB7XG5cdFx0bGV0IHhyZWYgPSBgeHJlZiR7TkVXX0xJTkV9MCAke3RoaXMucGRmT2JqZWN0TGlzdC5sZW5ndGggKyAxfSR7TkVXX0xJTkV9JHtaRVJPX09CSkVDVF9FTlRSWX0gJHtORVdfTElORX1gXG5cdFx0Zm9yIChjb25zdCBwZGZPYmplY3Qgb2YgdGhpcy5wZGZPYmplY3RMaXN0KSB7XG5cdFx0XHRpZiAocGRmT2JqZWN0LmdldEJ5dGVQb3NpdGlvbigpID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBhbiBvYmplY3Qgd2l0aCBpbnZhbGlkIGJ5dGUtcG9zaXRpb24hICR7cGRmT2JqZWN0LmdldE9iamVjdE51bWJlcigpfWApXG5cdFx0XHQvLyBSZXBsYWNlIHRoZSBcIjAwMDAwMDAwMDBcIiB2YWx1ZSB3aXRoIHRoZSBieXRlLXBvc2l0aW9uIGJ1dCBrZWVwIGFsbCBsZWFkaW5nIHplcm9zXG5cdFx0XHR4cmVmICs9IGAkeyhcIjAwMDAwMDAwMDBcIiArIHBkZk9iamVjdC5nZXRCeXRlUG9zaXRpb24oKSkuc2xpY2UoLTEwKX0gMDAwMDAgbiAke05FV19MSU5FfWBcblx0XHR9XG5cdFx0cmV0dXJuIHhyZWZcblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZSB0aGUgdHJhaWxlciBvZiB0aGUgUERGIHdoaWNoIGlzIGEgc3BlY2lhbCBvYmplY3QgcG9pbnRpbmcgYXQgdGhlIFwiQ2F0YWxvZyBvYmplY3RcIiBhbmQgYWRkaXRpb25hbCBtZXRhZGF0YVxuXHQgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByZWZlcmFibHkgdW5pcXVlIHN0cmluZ1xuXHQgKi9cblx0bWFrZVRyYWlsZXIoaWRlbnRpZmllcjogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRsZXQgdHJhaWxlciA9IGB0cmFpbGVyJHtORVdfTElORX08PCR7TkVXX0xJTkV9YFxuXHRcdHRyYWlsZXIgKz0gYC9TaXplICR7dGhpcy5wZGZPYmplY3RMaXN0Lmxlbmd0aCArIDF9YFxuXHRcdHRyYWlsZXIgKz0gYC9Sb290ICR7dGhpcy5wZGZSZWZlcmVuY2VUb1N0cmluZyh7IHJlZklkOiBcIkNBVEFMT0dcIiB9KX1gXG5cdFx0dHJhaWxlciArPSBgL0lEIFsoJHtpZGVudGlmaWVyfSkoJHtpZGVudGlmaWVyfSldYFxuXHRcdHRyYWlsZXIgKz0gYCR7TkVXX0xJTkV9Pj4ke05FV19MSU5FfXN0YXJ0eHJlZiR7TkVXX0xJTkV9JHt0aGlzLmJ5dGVMZW5ndGhQb3NpdGlvbn0ke05FV19MSU5FfSUlRU9GYFxuXHRcdHJldHVybiB0cmFpbGVyXG5cdH1cblxuXHQvKipcblx0ICogUmVzb2x2ZSBhbGwgcmVmZXJlbmNlcyB0byBvdGhlciBvYmplY3RzIGluIGEgUERGIGRpY3Rpb25hcnlcblx0ICogVGhpcyByZXBsYWNlcyBldmVyeSByZWZJZCB3aXRoIHRoZSBzdHJpbmcgXCJvYmpOdW1iZXIgMCBSXCIgd2hpY2ggaXMgUERGIHN5bnRheCBmb3IgcmVmZXJlbmNpbmcgb3RoZXIgb2JqZWN0c1xuXHQgKiBSZXR1cm5zIHRoZSBQREYgZGljdGlvbmFyeSBhcyBNYXAgb2YgPHN0cmluZywgc3RyaW5nPiBhbGxvd2luZyBpdCB0byBiZSBlbmNvZGVkXG5cdCAqIEBwYXJhbSBvYmpEaWN0aW9uYXJ5IFRoZSBkaWN0aW9uYXJ5IHRcblx0ICovXG5cdHJlc29sdmVSZWZlcmVuY2VzKG9iakRpY3Rpb25hcnk6IE1hcDxzdHJpbmcsIFBkZkRpY3RWYWx1ZT4pOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcblx0XHRjb25zdCBuZXdNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqRGljdGlvbmFyeSkge1xuXHRcdFx0bmV3TWFwLnNldChrZXksIHRoaXMucmVzb2x2ZURpY3RWYWx1ZSh2YWx1ZSkpXG5cdFx0fVxuXHRcdHJldHVybiBuZXdNYXBcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlIGEgUGRmRGljdFZhbHVlIGludG8gaXRzIHN0cmluZyBlcXVpdmFsZW50XG5cdCAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byByZXNvbHZlXG5cdCAqL1xuXHRyZXNvbHZlRGljdFZhbHVlKHZhbHVlOiBQZGZEaWN0VmFsdWUpOiBzdHJpbmcge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuXHRcdFx0XHQvLyBWYWx1ZSBpcyBhIG5lc3RlZCBkaXJlY3RvcnksIHJlY3Vyc2l2ZWx5IHJlc29sdmUgYWxsIHJlZmVyZW5jZXMgaW4gdGhlIG5lc3RlZCBkaXJlY3RvcnkgYW5kIGNvbnZlcnQgdG8gc3RyaW5nXG5cdFx0XHRcdHJldHVybiB0aGlzLnBkZkRpY3Rpb25hcnlUb1N0cmluZyh2YWx1ZSlcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0Ly8gVmFsdWUgaXMgYSBsaXN0LCBpdGVyYXRlIG92ZXIgYWxsIGVsZW1lbnRzLCByZXNvbHZlIHRoZW0gaWYgbmVjZXNzYXJ5IGFuZCBjb252ZXJ0IHRvIHN0cmluZ1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wZGZMaXN0VG9TdHJpbmcodmFsdWUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBWYWx1ZSBpcyBhIHNpbmd1bGFyIHJlZmVyZW5jZSwgcmVzb2x2ZSBpdCBpbnRvIGEgc3RyaW5nXG5cdFx0XHRcdHJldHVybiB0aGlzLnBkZlJlZmVyZW5jZVRvU3RyaW5nKHZhbHVlKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBWYWx1ZSBpcyBhIHN0cmluZywga2VlcCBpdFxuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fVxuXHR9XG5cblx0cGRmUmVmZXJlbmNlVG9TdHJpbmcob2JqZWN0UmVmZXJlbmNlOiBQZGZPYmplY3RSZWYpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHJlZmVyZW5jZWRPYmplY3QgPSB0aGlzLmdldE9iamVjdEJ5UmVmSWQob2JqZWN0UmVmZXJlbmNlLnJlZklkKVxuXHRcdHJldHVybiBgJHtyZWZlcmVuY2VkT2JqZWN0LmdldE9iamVjdE51bWJlcigpfSAke0dFTkVSQVRJT05fTlVNQkVSfSBSYFxuXHR9XG5cblx0cGRmTGlzdFRvU3RyaW5nKG9iamVjdFJlZmVyZW5jZXM6IFBkZkRpY3RWYWx1ZVtdKTogc3RyaW5nIHtcblx0XHRsZXQgcmVmZXJlbmNlU3RyaW5nID0gXCJbXCIgKyBcIiBcIlxuXHRcdGZvciAoY29uc3Qgb2JqUmVmIG9mIG9iamVjdFJlZmVyZW5jZXMpIHtcblx0XHRcdHJlZmVyZW5jZVN0cmluZyArPSB0aGlzLnJlc29sdmVEaWN0VmFsdWUob2JqUmVmKSArIFwiIFwiXG5cdFx0fVxuXHRcdHJlZmVyZW5jZVN0cmluZyArPSBcIl1cIlxuXHRcdHJldHVybiByZWZlcmVuY2VTdHJpbmdcblx0fVxuXG5cdHBkZkRpY3Rpb25hcnlUb1N0cmluZyhvYmplY3RSZWZlcmVuY2VEaWN0OiBNYXA8c3RyaW5nLCBQZGZEaWN0VmFsdWU+KTogc3RyaW5nIHtcblx0XHRsZXQgcmVmZXJlbmNlU3RyaW5nID0gXCI8PFwiICsgXCIgXCJcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmplY3RSZWZlcmVuY2VEaWN0KSB7XG5cdFx0XHRyZWZlcmVuY2VTdHJpbmcgKz0gYC8ke2tleX0gJHt0aGlzLnJlc29sdmVEaWN0VmFsdWUodmFsdWUpfSBgXG5cdFx0fVxuXHRcdHJlZmVyZW5jZVN0cmluZyArPSBcIj4+XCJcblx0XHRyZXR1cm4gcmVmZXJlbmNlU3RyaW5nXG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHRoZSBieXRlLXBvc2l0aW9uIGZvciBhIGdpdmVuIG9iamVjdFxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdGhhdCBzaG91bGQgaGF2ZSBpdHMgYnl0ZS1wb3NpdGlvbiBiZSBjYWxjdWxhdGVkXG5cdCAqIEBwYXJhbSBlbmNvZGVkT2JqZWN0IFRoZSBwcm92aWRlZCBvYmplY3QgaW4gZW5jb2RlZCBmb3JtYXQgdG8gYWxsb3cgY2FsY3VsYXRpb24gZm9yIHRoZSBuZXh0IG9iamVjdFxuXHQgKi9cblx0Y2FsY3VsYXRlQnl0ZVBvc2l0aW9ucyhvYmplY3Q6IFBkZk9iamVjdCwgZW5jb2RlZE9iamVjdDogVWludDhBcnJheSkge1xuXHRcdG9iamVjdC5zZXRCeXRlUG9zaXRpb24odGhpcy5ieXRlTGVuZ3RoUG9zaXRpb24pXG5cdFx0dGhpcy5ieXRlTGVuZ3RoUG9zaXRpb24gKz0gZW5jb2RlZE9iamVjdC5ieXRlTGVuZ3RoXG5cdH1cblxuXHQvKipcblx0ICogQWRkIGFsbCByZXNvdXJjZSBvYmplY3RzIChzdHJlYW0gb2JqZWN0cykgdG8gdGhlIFBERi4gVGhlc2UgYXJlIHJlZmVyZW5jZWQgYnkgdGhlIFwiZGVmYXVsdCBvYmplY3RzXCIgYnV0IG5lZWQgdG8gYmUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIGJlY2F1c2UgdGhleVxuXHQgKiBpbmNsdWRlIGEgaHVnZSBhbW91bnQgb2Ygc3RyZWFtIGRhdGEgLyBuZWVkIHRvIHJlYWQgdGhlaXIgc3RyZWFtIGRhdGEgaW4gZnJvbSBleHRlcm5hbCByZXNvdXJjZXMgKGJhc2U2NCBlbmNvZGVkKVxuXHQgKi9cblx0YXN5bmMgc2V0dXBSZXNvdXJjZU9iamVjdHMoKSB7XG5cdFx0Y29uc3QgYmFzZVVybCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiXCIgOiBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3RuYW1lICsgKGxvY2F0aW9uLnBvcnQgPyBcIjpcIiArIGxvY2F0aW9uLnBvcnQgOiBcIlwiKVxuXHRcdGlmICghdGhpcy5jYWNoZWRSZXNvdXJjZXMpIHtcblx0XHRcdHRoaXMuY2FjaGVkUmVzb3VyY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG5cdFx0XHRcdFtcIi9wZGYvU291cmNlU2FuczMtUmVndWxhci50dGZcIiwgXCIvcGRmL1NvdXJjZVNhbnMzLUJvbGQudHRmXCIsIFwiL3BkZi9zUkdCMjAxNC5pY2NcIiwgXCIvcGRmL2lkZW50aXR5X2guY21hcFwiLCBcIi9wZGYvdHV0YW5vdGFfbG9nb19lbi5qcGdcIl0ubWFwKFxuXHRcdFx0XHRcdCh1cmwpID0+XG5cdFx0XHRcdFx0XHR0eXBlb2YgdGhpcy5jdXN0b21GZXRjaCAhPT0gXCJ1bmRlZmluZWRcIlxuXHRcdFx0XHRcdFx0XHQ/IHRoaXMuY3VzdG9tRmV0Y2goYmFzZVVybCArIHVybCkudGhlbigocikgPT4gci5hcnJheUJ1ZmZlcigpKVxuXHRcdFx0XHRcdFx0XHQ6IGZldGNoKGJhc2VVcmwgKyB1cmwpLnRoZW4oKHIpID0+IHIuYXJyYXlCdWZmZXIoKSksXG5cdFx0XHRcdCksXG5cdFx0XHQpXG5cdFx0fVxuXHRcdGNvbnN0IFtmb250UmVndWxhciwgZm9udEJvbGQsIGNvbG9yUHJvZmlsZSwgY21hcCwgdHV0YUltYWdlXSA9IHRoaXMuY2FjaGVkUmVzb3VyY2VzXG5cblx0XHQvLyBSZWd1bGFyIGZvbnQgZmlsZVxuXHRcdHRoaXMuY3JlYXRlU3RyZWFtT2JqZWN0KFxuXHRcdFx0bmV3IE1hcChbW1wiTGVuZ3RoMVwiLCBmb250UmVndWxhci5ieXRlTGVuZ3RoLnRvU3RyaW5nKCldXSksXG5cdFx0XHRhd2FpdCB0aGlzLmRlZmxhdGVyLmRlZmxhdGUoZm9udFJlZ3VsYXIpLFxuXHRcdFx0UGRmU3RyZWFtRW5jb2RpbmcuRkxBVEUsXG5cdFx0XHRcIkZPTlRfUkVHVUxBUl9GSUxFXCIsXG5cdFx0KVxuXHRcdC8vIEJvbGQgZm9udCBmaWxlXG5cdFx0dGhpcy5jcmVhdGVTdHJlYW1PYmplY3QoXG5cdFx0XHRuZXcgTWFwKFtbXCJMZW5ndGgxXCIsIGZvbnRCb2xkLmJ5dGVMZW5ndGgudG9TdHJpbmcoKV1dKSxcblx0XHRcdGF3YWl0IHRoaXMuZGVmbGF0ZXIuZGVmbGF0ZShmb250Qm9sZCksXG5cdFx0XHRQZGZTdHJlYW1FbmNvZGluZy5GTEFURSxcblx0XHRcdFwiRk9OVF9CT0xEX0ZJTEVcIixcblx0XHQpXG5cdFx0Ly8gSWRlbnRpdHkgQ01hcFxuXHRcdHRoaXMuY3JlYXRlU3RyZWFtT2JqZWN0KFxuXHRcdFx0bmV3IE1hcChbXG5cdFx0XHRcdFtcIlR5cGVcIiwgXCIvQ01hcFwiXSxcblx0XHRcdFx0W1wiQ01hcE5hbWVcIiwgXCIvSWRlbnRpdHktSCBcIl0sXG5cdFx0XHRcdFtcIkNJRFN5c3RlbUluZm9cIiwgXCI8PCAvUmVnaXN0cnkgKEFkb2JlKSAvT3JkZXJpbmcgKElkZW50aXR5KSAvU3VwcGxlbWVudCAwID4+XCJdLFxuXHRcdFx0XSksXG5cdFx0XHRhd2FpdCB0aGlzLmRlZmxhdGVyLmRlZmxhdGUoY21hcCksXG5cdFx0XHRQZGZTdHJlYW1FbmNvZGluZy5GTEFURSxcblx0XHRcdFwiQ01BUFwiLFxuXHRcdClcblx0XHQvLyBDb2xvciBwcm9maWxlXG5cdFx0dGhpcy5jcmVhdGVTdHJlYW1PYmplY3QoXG5cdFx0XHRuZXcgTWFwKFtcblx0XHRcdFx0W1wiTGVuZ3RoMVwiLCBjb2xvclByb2ZpbGUuYnl0ZUxlbmd0aC50b1N0cmluZygpXSxcblx0XHRcdFx0W1wiTlwiLCBcIjNcIl0sXG5cdFx0XHRdKSxcblx0XHRcdGF3YWl0IHRoaXMuZGVmbGF0ZXIuZGVmbGF0ZShjb2xvclByb2ZpbGUpLFxuXHRcdFx0UGRmU3RyZWFtRW5jb2RpbmcuRkxBVEUsXG5cdFx0XHRcIkRFU1RfT1VUUFVUX1BST0ZJTEVcIixcblx0XHQpXG5cdFx0Ly8gVHV0YSBsb2dvIGFzIHJhc3RlciBpbWFnZVxuXHRcdHRoaXMuY3JlYXRlU3RyZWFtT2JqZWN0KFxuXHRcdFx0bmV3IE1hcChbXG5cdFx0XHRcdFtcIk5hbWVcIiwgXCIvSW0xXCJdLFxuXHRcdFx0XHRbXCJUeXBlXCIsIFwiL1hPYmplY3RcIl0sXG5cdFx0XHRcdFtcIlN1YnR5cGVcIiwgXCIvSW1hZ2VcIl0sXG5cdFx0XHRcdFtcIldpZHRoXCIsIFwiNjAwXCJdLFxuXHRcdFx0XHRbXCJIZWlnaHRcIiwgXCIyMDlcIl0sXG5cdFx0XHRcdFtcIkJpdHNQZXJDb21wb25lbnRcIiwgXCI4XCJdLFxuXHRcdFx0XHRbXCJDb2xvclNwYWNlXCIsIFwiL0RldmljZVJHQlwiXSxcblx0XHRcdF0pLFxuXHRcdFx0bmV3IFVpbnQ4QXJyYXkodHV0YUltYWdlKSxcblx0XHRcdFBkZlN0cmVhbUVuY29kaW5nLkRDVCxcblx0XHRcdFwiSU1HX1RVVEFfTE9HT1wiLFxuXHRcdClcblx0XHQvLyBNZXRhZGF0YVxuXHRcdGNvbnN0IHRvZGF5RGF0ZSA9IG5ldyBEYXRlKClcblx0XHRjb25zdCBtZXRhRGF0YSA9IFBERl9NRVRBREFUQS5yZXBsYWNlKFwie3Nsb3RDcmVhdGVEYXRlfVwiLCB0b2RheURhdGUudG9JU09TdHJpbmcoKSkucmVwbGFjZShcIntzbG90TW9kaWZ5RGF0ZX1cIiwgdG9kYXlEYXRlLnRvSVNPU3RyaW5nKCkpXG5cdFx0dGhpcy5jcmVhdGVTdHJlYW1PYmplY3QoXG5cdFx0XHRuZXcgTWFwKFtcblx0XHRcdFx0W1wiVHlwZVwiLCBcIi9NZXRhZGF0YVwiXSxcblx0XHRcdFx0W1wiU3VidHlwZVwiLCBcIi9YTUxcIl0sXG5cdFx0XHRdKSxcblx0XHRcdG5ldyBVaW50OEFycmF5KHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKG1ldGFEYXRhKSksXG5cdFx0XHRQZGZTdHJlYW1FbmNvZGluZy5OT05FLFxuXHRcdFx0XCJNRVRBREFUQVwiLFxuXHRcdClcblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgdGhlIFBERiBmaWxlIGFuZCByZXR1cm4gaXRzIGVudGlyZSBkYXRhIGFzIGEgVWludDhBcnJheVxuXHQgKiBAcHJlIGJhc2VVcmwgbXVzdCBiZSBkZWZpbmVkXG5cdCAqL1xuXHRhc3luYyB3cml0ZVBkZkZpbGUoKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG5cdFx0Ly8gU2V0IHVwIHRoZSBvYmplY3RzIHJlcXVpcmluZyBleHRlcm5hbCByZXNvdXJjZXMgbGFzdFxuXHRcdGF3YWl0IHRoaXMuc2V0dXBSZXNvdXJjZU9iamVjdHMoKVxuXG5cdFx0Ly8gRW5jb2RlIGFsbCBjb21wb25lbnRzIG9mIHRoZSBmaWxlIGludG8gdWludDhhcnJheXMgZm9yIHdyaXRpbmdcblx0XHRjb25zdCBlbmNvZGVkT2JqZWN0czogVWludDhBcnJheVtdID0gW11cblx0XHRlbmNvZGVkT2JqZWN0cy5wdXNoKFBERl9IRUFERVIpIC8vIEhlYWRlciBpcyB3cml0dGVuIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGVcblx0XHRmb3IgKGNvbnN0IG9iaiBvZiB0aGlzLnBkZk9iamVjdExpc3QpIHtcblx0XHRcdC8vIEJvZHkgaW5jbHVkZXMgYWxsIG9iamVjdHMgYW5kIHN0cmVhbXNcblx0XHRcdG9iai5zZXRSZXNvbHZlZERpY3Rpb25hcnkodGhpcy5yZXNvbHZlUmVmZXJlbmNlcyhvYmouZ2V0RGljdGlvbmFyeSgpKSkgLy8gV2l0aCBhbGwgb2JqZWN0cyBwcmVzZW50LCByZXNvbHZlIGFsbCB0aGVpciByZWZlcmVuY2VzXG5cdFx0XHRjb25zdCBlbmNvZGVkT2JqZWN0ID0gb2JqLmVuY29kZVRvVUludDhBcnJheSh0aGlzLnRleHRFbmNvZGVyKSAvLyBFbmNvZGUgdGhlIG9iamVjdCB0byB1aW50OGFycmF5XG5cdFx0XHR0aGlzLmNhbGN1bGF0ZUJ5dGVQb3NpdGlvbnMob2JqLCBlbmNvZGVkT2JqZWN0KSAvLyBDYWxjdWxhdGUgdGhlIG9iamVjdHMgYnl0ZS1wb3NpdGlvbiBieSBjb25zaWRlcmluZyBpdHMgZW5jb2RlZCBmb3JtXG5cdFx0XHRlbmNvZGVkT2JqZWN0cy5wdXNoKGVuY29kZWRPYmplY3QpXG5cdFx0fVxuXHRcdGVuY29kZWRPYmplY3RzLnB1c2godGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodGhpcy5tYWtlWFJlZlRhYmxlKCkpKSAvLyBNYWtlIHhyZWYgdGFibGUgd2hpY2ggcmVxdWlyZXMgYWxsIG9iamVjdCdzIGNhbGN1bGF0ZWQgYnl0ZS1wb3NpdGlvbnNcblx0XHRlbmNvZGVkT2JqZWN0cy5wdXNoKHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHRoaXMubWFrZVRyYWlsZXIoRGF0ZS5ub3coKS50b1N0cmluZygpKSkpIC8vIE1ha2UgdHJhaWxlclxuXG5cdFx0cmV0dXJuIGNvbmNhdCguLi5lbmNvZGVkT2JqZWN0cylcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7SUFNYSxZQUFOLE1BQWdCO0NBQ3RCLEFBQW1CO0NBQ25CLEFBQVUsZUFBdUI7Q0FDakMsQUFBVSxtQkFBOEMsSUFBSTtDQUU1RCxZQUFZQSxjQUFzQkMsa0JBQTZDO0FBQzlFLE9BQUssZUFBZTtBQUNwQixPQUFLLG1CQUFtQjtDQUN4QjtDQUVELEFBQU8sZ0JBQTJDO0FBQ2pELFNBQU8sS0FBSztDQUNaO0NBRUQsQUFBTyxrQkFBa0I7QUFDeEIsU0FBTyxLQUFLO0NBQ1o7Q0FFRCxBQUFPLGtCQUEwQjtBQUNoQyxTQUFPLEtBQUs7Q0FDWjs7OztDQUtELEFBQU8sc0JBQXNCQyxLQUEwQjtBQUN0RCxPQUFLLG1CQUFtQjtDQUN4Qjs7OztDQUtELEFBQU8sZ0JBQWdC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