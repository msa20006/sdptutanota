import { __toESM } from "./chunk-chunk.js";
import "./dist-chunk.js";
import "./ProgrammingError-chunk.js";
import { assertMainOrNode } from "./Env-chunk.js";
import { assertNotNull, delay, filterInt, isNotNull, lastThrow } from "./dist2-chunk.js";
import { GENERATED_MAX_ID, getElementId, isSameId } from "./EntityUtils-chunk.js";
import "./ParserCombinator-chunk.js";
import { require_stream } from "./stream-chunk.js";
import { ExportError, ExportErrorReason, FileOpenError, isOfflineError } from "./ErrorUtils-chunk.js";
import "./RestError-chunk.js";
import "./OutOfSyncError-chunk.js";
import { CancelledError } from "./CancelledError-chunk.js";
import { SuspensionError } from "./SuspensionError-chunk.js";
import "./LoginIncompleteError-chunk.js";
import "./CryptoError-chunk.js";
import "./RecipientsNotFoundError-chunk.js";
import "./DbError-chunk.js";
import "./QuotaExceededError-chunk.js";
import "./DeviceStorageUnavailableError-chunk.js";
import "./MailBodyTooLargeError-chunk.js";
import "./ImportError-chunk.js";
import "./WebauthnError-chunk.js";
import "./PermissionError-chunk.js";

//#region src/mail-app/native/main/MailExportController.ts
var import_stream = __toESM(require_stream(), 1);
assertMainOrNode();
const TAG = "MailboxExport";
var MailExportController = class {
	_state = (0, import_stream.default)({ type: "idle" });
	servers;
	serverIndex = 0;
	constructor(mailExportFacade, sanitizer, exportFacade, logins, mailboxModel, scheduler) {
		this.mailExportFacade = mailExportFacade;
		this.sanitizer = sanitizer;
		this.exportFacade = exportFacade;
		this.logins = logins;
		this.mailboxModel = mailboxModel;
		this.scheduler = scheduler;
	}
	get state() {
		return this._state;
	}
	get userId() {
		return this.logins.getUserController().userId;
	}
	/**
	* Start exporting the mailbox for the user
	* @param mailboxDetail
	*/
	async startExport(mailboxDetail) {
		const allMailBags = [assertNotNull(mailboxDetail.mailbox.currentMailBag), ...mailboxDetail.mailbox.archivedMailBags];
		try {
			await this.exportFacade.startMailboxExport(this.userId, mailboxDetail.mailbox._id, allMailBags[0]._id, GENERATED_MAX_ID);
		} catch (e) {
			if (e instanceof CancelledError) {
				console.log("Export start cancelled");
				return;
			} else if (e instanceof ExportError && e.data === ExportErrorReason.LockedForUser) {
				this._state({ type: "locked" });
				return;
			} else throw e;
		}
		this._state({
			type: "exporting",
			mailboxDetail,
			progress: 0,
			exportedMails: 0
		});
		await this.runExport(mailboxDetail, allMailBags, GENERATED_MAX_ID);
	}
	async resumeIfNeeded() {
		const exportState = await this.exportFacade.getMailboxExportState(this.userId);
		console.log(TAG, `Export, previous state: ${exportState?.type}`);
		if (exportState) {
			if (exportState.type === "running") {
				const mailboxDetail = await this.mailboxModel.getMailboxDetailByMailboxId(exportState.mailboxId);
				if (mailboxDetail == null) {
					console.warn(TAG, `Did not find mailbox to resume export: ${exportState.mailboxId}`);
					await this.cancelExport();
					return;
				}
				this._state({
					type: "exporting",
					mailboxDetail,
					progress: 0,
					exportedMails: exportState.exportedMails
				});
				await this.resumeExport(mailboxDetail, exportState.mailBagId, exportState.mailId);
			} else if (exportState.type === "finished") {
				const mailboxDetail = await this.mailboxModel.getMailboxDetailByMailboxId(exportState.mailboxId);
				if (mailboxDetail == null) {
					console.warn(TAG, `Did not find mailbox to resume export: ${exportState.mailboxId}`);
					await this.cancelExport();
					return;
				}
				this._state({
					type: "finished",
					mailboxDetail
				});
			} else if (exportState.type === "locked") {
				this._state({ type: "locked" });
				this.scheduler.scheduleAfter(() => this.resumeIfNeeded(), 3e5);
			}
		}
	}
	async openExportDirectory() {
		if (this._state().type === "finished") await this.exportFacade.openExportDirectory(this.userId);
	}
	/**
	* When the user wants to cancel the exporting
	*/
	async cancelExport() {
		this._state({ type: "idle" });
		await this.exportFacade.clearExportState(this.userId);
	}
	async resumeExport(mailboxDetail, mailbagId, mailId) {
		console.log(TAG, `Resuming export from mail bag: ${mailbagId} ${mailId}`);
		const allMailBags = [assertNotNull(mailboxDetail.mailbox.currentMailBag), ...mailboxDetail.mailbox.archivedMailBags];
		const currentMailBagIndex = allMailBags.findIndex((mb) => mb._id === mailbagId);
		const mailBags = allMailBags.slice(currentMailBagIndex);
		await this.runExport(mailboxDetail, mailBags, mailId);
	}
	async runExport(mailboxDetail, mailBags, mailId) {
		this.servers = await this.mailExportFacade.getExportServers(mailboxDetail.mailGroup);
		for (const mailBag of mailBags) {
			await this.exportMailBag(mailBag, mailId);
			if (this._state().type !== "exporting") return;
		}
		if (this._state().type !== "exporting") return;
		await this.exportFacade.endMailboxExport(this.userId);
		this._state({
			type: "finished",
			mailboxDetail
		});
	}
	async exportMailBag(mailBag, startId) {
		let currentStartId = startId;
		while (true) try {
			const downloadedMails = await this.mailExportFacade.loadFixedNumberOfMailsWithCache(mailBag.mails, currentStartId, this.getServerUrl());
			if (downloadedMails.length === 0) break;
			const downloadedMailDetails = await this.mailExportFacade.loadMailDetails(downloadedMails);
			const attachmentInfo = await this.mailExportFacade.loadAttachments(downloadedMails, this.getServerUrl());
			for (const { mail, mailDetails } of downloadedMailDetails) {
				if (this._state().type !== "exporting") return;
				const mailAttachmentInfo = mail.attachments.map((attachmentId) => attachmentInfo.find((attachment) => isSameId(attachment._id, attachmentId))).filter(isNotNull);
				const attachments = await this.mailExportFacade.loadAttachmentData(mail, mailAttachmentInfo);
				const { makeMailBundle } = await import("./Bundler-chunk.js");
				const mailBundle = makeMailBundle(this.sanitizer, mail, mailDetails, attachments);
				if (this._state().type !== "exporting") return;
				try {
					await this.exportFacade.saveMailboxExport(mailBundle, this.userId, mailBag._id, getElementId(mail));
				} catch (e) {
					if (e instanceof FileOpenError) {
						this._state({
							type: "error",
							message: e.message
						});
						return;
					} else throw e;
				}
			}
			currentStartId = getElementId(lastThrow(downloadedMails));
			const currentState = this._state();
			if (currentState.type != "exporting") return;
			this._state({
				...currentState,
				exportedMails: currentState.exportedMails + downloadedMails.length
			});
		} catch (e) {
			if (isOfflineError(e)) {
				console.log(TAG, "Offline, will retry later");
				await delay(6e4);
			} else if (e instanceof SuspensionError) {
				const timeToWait = Math.max(filterInt(assertNotNull(e.data)), 1);
				console.log(TAG, `Pausing for ${Math.floor(timeToWait / 1e3 + .5)} seconds`);
				await delay(timeToWait);
				if (this._state().type !== "exporting") return;
			} else throw e;
			console.log(TAG, "Trying to continue with export");
		}
	}
	getServerUrl() {
		if (this.servers) {
			this.serverIndex += 1;
			if (this.serverIndex >= this.servers.length) this.serverIndex = 0;
			return this.servers[this.serverIndex].url;
		}
		throw new Error("No servers");
	}
};

//#endregion
export { MailExportController };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFpbEV4cG9ydENvbnRyb2xsZXItY2h1bmsuanMiLCJuYW1lcyI6WyJtYWlsRXhwb3J0RmFjYWRlOiBNYWlsRXhwb3J0RmFjYWRlIiwic2FuaXRpemVyOiBIdG1sU2FuaXRpemVyIiwiZXhwb3J0RmFjYWRlOiBFeHBvcnRGYWNhZGUiLCJsb2dpbnM6IExvZ2luQ29udHJvbGxlciIsIm1haWxib3hNb2RlbDogTWFpbGJveE1vZGVsIiwic2NoZWR1bGVyOiBTY2hlZHVsZXIiLCJtYWlsYm94RGV0YWlsOiBNYWlsYm94RGV0YWlsIiwibWFpbGJhZ0lkOiBJZCIsIm1haWxJZDogSWQiLCJtYWlsQmFnczogTWFpbEJhZ1tdIiwibWFpbEJhZzogTWFpbEJhZyIsInN0YXJ0SWQ6IElkIl0sInNvdXJjZXMiOlsiLi4vc3JjL21haWwtYXBwL25hdGl2ZS9tYWluL01haWxFeHBvcnRDb250cm9sbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1haWxib3hEZXRhaWwsIE1haWxib3hNb2RlbCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vbWFpbEZ1bmN0aW9uYWxpdHkvTWFpbGJveE1vZGVsLmpzXCJcbmltcG9ydCBTdHJlYW0gZnJvbSBcIm1pdGhyaWwvc3RyZWFtXCJcbmltcG9ydCBzdHJlYW0gZnJvbSBcIm1pdGhyaWwvc3RyZWFtXCJcbmltcG9ydCB7IE1haWxCYWcgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9lbnRpdGllcy90dXRhbm90YS9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBHRU5FUkFURURfTUFYX0lELCBnZXRFbGVtZW50SWQsIGlzU2FtZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL3V0aWxzL0VudGl0eVV0aWxzLmpzXCJcbmltcG9ydCB7IGFzc2VydE5vdE51bGwsIGRlbGF5LCBmaWx0ZXJJbnQsIGlzTm90TnVsbCwgbGFzdFRocm93IH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBIdG1sU2FuaXRpemVyIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9taXNjL0h0bWxTYW5pdGl6ZXIuanNcIlxuaW1wb3J0IHsgRXhwb3J0RmFjYWRlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9uYXRpdmUvY29tbW9uL2dlbmVyYXRlZGlwYy9FeHBvcnRGYWNhZGUuanNcIlxuaW1wb3J0IHsgTG9naW5Db250cm9sbGVyIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvbWFpbi9Mb2dpbkNvbnRyb2xsZXIuanNcIlxuaW1wb3J0IHsgQ2FuY2VsbGVkRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9jb21tb24vZXJyb3IvQ2FuY2VsbGVkRXJyb3IuanNcIlxuaW1wb3J0IHsgRmlsZU9wZW5FcnJvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL2NvbW1vbi9lcnJvci9GaWxlT3BlbkVycm9yLmpzXCJcbmltcG9ydCB7IGlzT2ZmbGluZUVycm9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL3V0aWxzL0Vycm9yVXRpbHMuanNcIlxuaW1wb3J0IHsgTWFpbEV4cG9ydEZhY2FkZSB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL3dvcmtlci9mYWNhZGVzL2xhenkvTWFpbEV4cG9ydEZhY2FkZS5qc1wiXG5pbXBvcnQgeyBTdXNwZW5zaW9uRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9jb21tb24vZXJyb3IvU3VzcGVuc2lvbkVycm9yXCJcbmltcG9ydCB7IFNjaGVkdWxlciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL2NvbW1vbi91dGlscy9TY2hlZHVsZXJcIlxuaW1wb3J0IHsgRXhwb3J0RXJyb3IsIEV4cG9ydEVycm9yUmVhc29uIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL2Vycm9yL0V4cG9ydEVycm9yXCJcbmltcG9ydCB7IEJsb2JTZXJ2ZXJVcmwgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9lbnRpdGllcy9zdG9yYWdlL1R5cGVSZWZzXCJcbmltcG9ydCB7IGFzc2VydE1haW5Pck5vZGUgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9jb21tb24vRW52XCJcblxuYXNzZXJ0TWFpbk9yTm9kZSgpXG5cbmV4cG9ydCB0eXBlIE1haWxFeHBvcnRTdGF0ZSA9XG5cdHwgeyB0eXBlOiBcImlkbGVcIiB9XG5cdHwgeyB0eXBlOiBcImV4cG9ydGluZ1wiOyBtYWlsYm94RGV0YWlsOiBNYWlsYm94RGV0YWlsOyBwcm9ncmVzczogbnVtYmVyOyBleHBvcnRlZE1haWxzOiBudW1iZXIgfVxuXHR8IHsgdHlwZTogXCJsb2NrZWRcIiB9XG5cdHwgeyB0eXBlOiBcImVycm9yXCI7IG1lc3NhZ2U6IHN0cmluZyB9XG5cdHwge1xuXHRcdFx0dHlwZTogXCJmaW5pc2hlZFwiXG5cdFx0XHRtYWlsYm94RGV0YWlsOiBNYWlsYm94RGV0YWlsXG5cdCAgfVxuXG5jb25zdCBUQUcgPSBcIk1haWxib3hFeHBvcnRcIlxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8ga2VlcCB0aGUgc3RhdGUgb2YgbWFpbCBleHBvcnRpbmcgd2l0aCB0aGUgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1haWxFeHBvcnRDb250cm9sbGVyIHtcblx0cHJpdmF0ZSBfc3RhdGU6IFN0cmVhbTxNYWlsRXhwb3J0U3RhdGU+ID0gc3RyZWFtKHsgdHlwZTogXCJpZGxlXCIgfSlcblx0cHJpdmF0ZSBzZXJ2ZXJzPzogQmxvYlNlcnZlclVybFtdXG5cdHByaXZhdGUgc2VydmVySW5kZXg6IG51bWJlciA9IDBcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIHJlYWRvbmx5IG1haWxFeHBvcnRGYWNhZGU6IE1haWxFeHBvcnRGYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBzYW5pdGl6ZXI6IEh0bWxTYW5pdGl6ZXIsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBleHBvcnRGYWNhZGU6IEV4cG9ydEZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGxvZ2luczogTG9naW5Db250cm9sbGVyLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgbWFpbGJveE1vZGVsOiBNYWlsYm94TW9kZWwsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBzY2hlZHVsZXI6IFNjaGVkdWxlcixcblx0KSB7fVxuXG5cdGdldCBzdGF0ZSgpOiBTdHJlYW08TWFpbEV4cG9ydFN0YXRlPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXRlXG5cdH1cblxuXHRwcml2YXRlIGdldCB1c2VySWQoKTogSWQge1xuXHRcdHJldHVybiB0aGlzLmxvZ2lucy5nZXRVc2VyQ29udHJvbGxlcigpLnVzZXJJZFxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IGV4cG9ydGluZyB0aGUgbWFpbGJveCBmb3IgdGhlIHVzZXJcblx0ICogQHBhcmFtIG1haWxib3hEZXRhaWxcblx0ICovXG5cdGFzeW5jIHN0YXJ0RXhwb3J0KG1haWxib3hEZXRhaWw6IE1haWxib3hEZXRhaWwpIHtcblx0XHRjb25zdCBhbGxNYWlsQmFncyA9IFthc3NlcnROb3ROdWxsKG1haWxib3hEZXRhaWwubWFpbGJveC5jdXJyZW50TWFpbEJhZyksIC4uLm1haWxib3hEZXRhaWwubWFpbGJveC5hcmNoaXZlZE1haWxCYWdzXVxuXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHRoaXMuZXhwb3J0RmFjYWRlLnN0YXJ0TWFpbGJveEV4cG9ydCh0aGlzLnVzZXJJZCwgbWFpbGJveERldGFpbC5tYWlsYm94Ll9pZCwgYWxsTWFpbEJhZ3NbMF0uX2lkLCBHRU5FUkFURURfTUFYX0lEKVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlIGluc3RhbmNlb2YgQ2FuY2VsbGVkRXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJFeHBvcnQgc3RhcnQgY2FuY2VsbGVkXCIpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fSBlbHNlIGlmIChlIGluc3RhbmNlb2YgRXhwb3J0RXJyb3IgJiYgZS5kYXRhID09PSBFeHBvcnRFcnJvclJlYXNvbi5Mb2NrZWRGb3JVc2VyKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRlKHsgdHlwZTogXCJsb2NrZWRcIiB9KVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGVcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zdGF0ZSh7IHR5cGU6IFwiZXhwb3J0aW5nXCIsIG1haWxib3hEZXRhaWw6IG1haWxib3hEZXRhaWwsIHByb2dyZXNzOiAwLCBleHBvcnRlZE1haWxzOiAwIH0pXG5cblx0XHRhd2FpdCB0aGlzLnJ1bkV4cG9ydChtYWlsYm94RGV0YWlsLCBhbGxNYWlsQmFncywgR0VORVJBVEVEX01BWF9JRClcblx0fVxuXG5cdGFzeW5jIHJlc3VtZUlmTmVlZGVkKCkge1xuXHRcdGNvbnN0IGV4cG9ydFN0YXRlID0gYXdhaXQgdGhpcy5leHBvcnRGYWNhZGUuZ2V0TWFpbGJveEV4cG9ydFN0YXRlKHRoaXMudXNlcklkKVxuXHRcdGNvbnNvbGUubG9nKFRBRywgYEV4cG9ydCwgcHJldmlvdXMgc3RhdGU6ICR7ZXhwb3J0U3RhdGU/LnR5cGV9YClcblx0XHRpZiAoZXhwb3J0U3RhdGUpIHtcblx0XHRcdGlmIChleHBvcnRTdGF0ZS50eXBlID09PSBcInJ1bm5pbmdcIikge1xuXHRcdFx0XHRjb25zdCBtYWlsYm94RGV0YWlsID0gYXdhaXQgdGhpcy5tYWlsYm94TW9kZWwuZ2V0TWFpbGJveERldGFpbEJ5TWFpbGJveElkKGV4cG9ydFN0YXRlLm1haWxib3hJZClcblx0XHRcdFx0aWYgKG1haWxib3hEZXRhaWwgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihUQUcsIGBEaWQgbm90IGZpbmQgbWFpbGJveCB0byByZXN1bWUgZXhwb3J0OiAke2V4cG9ydFN0YXRlLm1haWxib3hJZH1gKVxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuY2FuY2VsRXhwb3J0KClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9zdGF0ZSh7XG5cdFx0XHRcdFx0dHlwZTogXCJleHBvcnRpbmdcIixcblx0XHRcdFx0XHRtYWlsYm94RGV0YWlsOiBtYWlsYm94RGV0YWlsLFxuXHRcdFx0XHRcdHByb2dyZXNzOiAwLFxuXHRcdFx0XHRcdGV4cG9ydGVkTWFpbHM6IGV4cG9ydFN0YXRlLmV4cG9ydGVkTWFpbHMsXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGF3YWl0IHRoaXMucmVzdW1lRXhwb3J0KG1haWxib3hEZXRhaWwsIGV4cG9ydFN0YXRlLm1haWxCYWdJZCwgZXhwb3J0U3RhdGUubWFpbElkKVxuXHRcdFx0fSBlbHNlIGlmIChleHBvcnRTdGF0ZS50eXBlID09PSBcImZpbmlzaGVkXCIpIHtcblx0XHRcdFx0Y29uc3QgbWFpbGJveERldGFpbCA9IGF3YWl0IHRoaXMubWFpbGJveE1vZGVsLmdldE1haWxib3hEZXRhaWxCeU1haWxib3hJZChleHBvcnRTdGF0ZS5tYWlsYm94SWQpXG5cdFx0XHRcdGlmIChtYWlsYm94RGV0YWlsID09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oVEFHLCBgRGlkIG5vdCBmaW5kIG1haWxib3ggdG8gcmVzdW1lIGV4cG9ydDogJHtleHBvcnRTdGF0ZS5tYWlsYm94SWR9YClcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmNhbmNlbEV4cG9ydCgpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc3RhdGUoeyB0eXBlOiBcImZpbmlzaGVkXCIsIG1haWxib3hEZXRhaWw6IG1haWxib3hEZXRhaWwgfSlcblx0XHRcdH0gZWxzZSBpZiAoZXhwb3J0U3RhdGUudHlwZSA9PT0gXCJsb2NrZWRcIikge1xuXHRcdFx0XHR0aGlzLl9zdGF0ZSh7IHR5cGU6IFwibG9ja2VkXCIgfSlcblx0XHRcdFx0dGhpcy5zY2hlZHVsZXIuc2NoZWR1bGVBZnRlcigoKSA9PiB0aGlzLnJlc3VtZUlmTmVlZGVkKCksIDEwMDAgKiA2MCAqIDUpIC8vIDUgbWluXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgb3BlbkV4cG9ydERpcmVjdG9yeSgpIHtcblx0XHRpZiAodGhpcy5fc3RhdGUoKS50eXBlID09PSBcImZpbmlzaGVkXCIpIHtcblx0XHRcdGF3YWl0IHRoaXMuZXhwb3J0RmFjYWRlLm9wZW5FeHBvcnREaXJlY3RvcnkodGhpcy51c2VySWQpXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFdoZW4gdGhlIHVzZXIgd2FudHMgdG8gY2FuY2VsIHRoZSBleHBvcnRpbmdcblx0ICovXG5cdGFzeW5jIGNhbmNlbEV4cG9ydCgpIHtcblx0XHR0aGlzLl9zdGF0ZSh7IHR5cGU6IFwiaWRsZVwiIH0pXG5cdFx0YXdhaXQgdGhpcy5leHBvcnRGYWNhZGUuY2xlYXJFeHBvcnRTdGF0ZSh0aGlzLnVzZXJJZClcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcmVzdW1lRXhwb3J0KG1haWxib3hEZXRhaWw6IE1haWxib3hEZXRhaWwsIG1haWxiYWdJZDogSWQsIG1haWxJZDogSWQpIHtcblx0XHRjb25zb2xlLmxvZyhUQUcsIGBSZXN1bWluZyBleHBvcnQgZnJvbSBtYWlsIGJhZzogJHttYWlsYmFnSWR9ICR7bWFpbElkfWApXG5cdFx0Y29uc3QgYWxsTWFpbEJhZ3MgPSBbYXNzZXJ0Tm90TnVsbChtYWlsYm94RGV0YWlsLm1haWxib3guY3VycmVudE1haWxCYWcpLCAuLi5tYWlsYm94RGV0YWlsLm1haWxib3guYXJjaGl2ZWRNYWlsQmFnc11cblx0XHRjb25zdCBjdXJyZW50TWFpbEJhZ0luZGV4ID0gYWxsTWFpbEJhZ3MuZmluZEluZGV4KChtYikgPT4gbWIuX2lkID09PSBtYWlsYmFnSWQpXG5cdFx0Y29uc3QgbWFpbEJhZ3MgPSBhbGxNYWlsQmFncy5zbGljZShjdXJyZW50TWFpbEJhZ0luZGV4KVxuXG5cdFx0YXdhaXQgdGhpcy5ydW5FeHBvcnQobWFpbGJveERldGFpbCwgbWFpbEJhZ3MsIG1haWxJZClcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcnVuRXhwb3J0KG1haWxib3hEZXRhaWw6IE1haWxib3hEZXRhaWwsIG1haWxCYWdzOiBNYWlsQmFnW10sIG1haWxJZDogSWQpIHtcblx0XHR0aGlzLnNlcnZlcnMgPSBhd2FpdCB0aGlzLm1haWxFeHBvcnRGYWNhZGUuZ2V0RXhwb3J0U2VydmVycyhtYWlsYm94RGV0YWlsLm1haWxHcm91cClcblx0XHRmb3IgKGNvbnN0IG1haWxCYWcgb2YgbWFpbEJhZ3MpIHtcblx0XHRcdGF3YWl0IHRoaXMuZXhwb3J0TWFpbEJhZyhtYWlsQmFnLCBtYWlsSWQpXG5cdFx0XHRpZiAodGhpcy5fc3RhdGUoKS50eXBlICE9PSBcImV4cG9ydGluZ1wiKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9zdGF0ZSgpLnR5cGUgIT09IFwiZXhwb3J0aW5nXCIpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRhd2FpdCB0aGlzLmV4cG9ydEZhY2FkZS5lbmRNYWlsYm94RXhwb3J0KHRoaXMudXNlcklkKVxuXHRcdHRoaXMuX3N0YXRlKHsgdHlwZTogXCJmaW5pc2hlZFwiLCBtYWlsYm94RGV0YWlsOiBtYWlsYm94RGV0YWlsIH0pXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGV4cG9ydE1haWxCYWcobWFpbEJhZzogTWFpbEJhZywgc3RhcnRJZDogSWQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRsZXQgY3VycmVudFN0YXJ0SWQgPSBzdGFydElkXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGRvd25sb2FkZWRNYWlscyA9IGF3YWl0IHRoaXMubWFpbEV4cG9ydEZhY2FkZS5sb2FkRml4ZWROdW1iZXJPZk1haWxzV2l0aENhY2hlKG1haWxCYWcubWFpbHMsIGN1cnJlbnRTdGFydElkLCB0aGlzLmdldFNlcnZlclVybCgpKVxuXHRcdFx0XHRpZiAoZG93bmxvYWRlZE1haWxzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkb3dubG9hZGVkTWFpbERldGFpbHMgPSBhd2FpdCB0aGlzLm1haWxFeHBvcnRGYWNhZGUubG9hZE1haWxEZXRhaWxzKGRvd25sb2FkZWRNYWlscylcblx0XHRcdFx0Y29uc3QgYXR0YWNobWVudEluZm8gPSBhd2FpdCB0aGlzLm1haWxFeHBvcnRGYWNhZGUubG9hZEF0dGFjaG1lbnRzKGRvd25sb2FkZWRNYWlscywgdGhpcy5nZXRTZXJ2ZXJVcmwoKSlcblx0XHRcdFx0Zm9yIChjb25zdCB7IG1haWwsIG1haWxEZXRhaWxzIH0gb2YgZG93bmxvYWRlZE1haWxEZXRhaWxzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXRlKCkudHlwZSAhPT0gXCJleHBvcnRpbmdcIikge1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IG1haWxBdHRhY2htZW50SW5mbyA9IG1haWwuYXR0YWNobWVudHNcblx0XHRcdFx0XHRcdC5tYXAoKGF0dGFjaG1lbnRJZCkgPT4gYXR0YWNobWVudEluZm8uZmluZCgoYXR0YWNobWVudCkgPT4gaXNTYW1lSWQoYXR0YWNobWVudC5faWQsIGF0dGFjaG1lbnRJZCkpKVxuXHRcdFx0XHRcdFx0LmZpbHRlcihpc05vdE51bGwpXG5cdFx0XHRcdFx0Y29uc3QgYXR0YWNobWVudHMgPSBhd2FpdCB0aGlzLm1haWxFeHBvcnRGYWNhZGUubG9hZEF0dGFjaG1lbnREYXRhKG1haWwsIG1haWxBdHRhY2htZW50SW5mbylcblx0XHRcdFx0XHRjb25zdCB7IG1ha2VNYWlsQnVuZGxlIH0gPSBhd2FpdCBpbXBvcnQoXCIuLi8uLi9tYWlsL2V4cG9ydC9CdW5kbGVyLmpzXCIpXG5cdFx0XHRcdFx0Y29uc3QgbWFpbEJ1bmRsZSA9IG1ha2VNYWlsQnVuZGxlKHRoaXMuc2FuaXRpemVyLCBtYWlsLCBtYWlsRGV0YWlscywgYXR0YWNobWVudHMpXG5cblx0XHRcdFx0XHQvLyBjYW4ndCB3cml0ZSBleHBvcnQgaWYgaXQgd2FzIGNhbmNlbGVkXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXRlKCkudHlwZSAhPT0gXCJleHBvcnRpbmdcIikge1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmV4cG9ydEZhY2FkZS5zYXZlTWFpbGJveEV4cG9ydChtYWlsQnVuZGxlLCB0aGlzLnVzZXJJZCwgbWFpbEJhZy5faWQsIGdldEVsZW1lbnRJZChtYWlsKSlcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEZpbGVPcGVuRXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhdGUoeyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IGUubWVzc2FnZSB9KVxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VycmVudFN0YXJ0SWQgPSBnZXRFbGVtZW50SWQobGFzdFRocm93KGRvd25sb2FkZWRNYWlscykpXG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuX3N0YXRlKClcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZS50eXBlICE9IFwiZXhwb3J0aW5nXCIpIHtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9zdGF0ZSh7IC4uLmN1cnJlbnRTdGF0ZSwgZXhwb3J0ZWRNYWlsczogY3VycmVudFN0YXRlLmV4cG9ydGVkTWFpbHMgKyBkb3dubG9hZGVkTWFpbHMubGVuZ3RoIH0pXG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGlmIChpc09mZmxpbmVFcnJvcihlKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgXCJPZmZsaW5lLCB3aWxsIHJldHJ5IGxhdGVyXCIpXG5cdFx0XHRcdFx0YXdhaXQgZGVsYXkoMTAwMCAqIDYwKSAvLyAxIG1pblxuXHRcdFx0XHR9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBTdXNwZW5zaW9uRXJyb3IpIHtcblx0XHRcdFx0XHRjb25zdCB0aW1lVG9XYWl0ID0gTWF0aC5tYXgoZmlsdGVySW50KGFzc2VydE5vdE51bGwoZS5kYXRhKSksIDEpXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coVEFHLCBgUGF1c2luZyBmb3IgJHtNYXRoLmZsb29yKHRpbWVUb1dhaXQgLyAxMDAwICsgMC41KX0gc2Vjb25kc2ApXG5cdFx0XHRcdFx0YXdhaXQgZGVsYXkodGltZVRvV2FpdClcblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhdGUoKS50eXBlICE9PSBcImV4cG9ydGluZ1wiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgXCJUcnlpbmcgdG8gY29udGludWUgd2l0aCBleHBvcnRcIilcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdldFNlcnZlclVybCgpOiBzdHJpbmcge1xuXHRcdGlmICh0aGlzLnNlcnZlcnMpIHtcblx0XHRcdHRoaXMuc2VydmVySW5kZXggKz0gMVxuXHRcdFx0aWYgKHRoaXMuc2VydmVySW5kZXggPj0gdGhpcy5zZXJ2ZXJzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLnNlcnZlckluZGV4ID0gMFxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuc2VydmVyc1t0aGlzLnNlcnZlckluZGV4XS51cmxcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gc2VydmVyc1wiKVxuXHR9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLGtCQUFrQjtBQVlsQixNQUFNLE1BQU07SUFLQyx1QkFBTixNQUEyQjtDQUNqQyxBQUFRLFNBQWtDLDJCQUFPLEVBQUUsTUFBTSxPQUFR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