import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { assertNotNull, isKeyVersion } from "./dist2-chunk.js";
import { customIdToString, getElementId, isSameId, stringToCustomId } from "./EntityUtils-chunk.js";
import { GroupKeyTypeRef, GroupTypeRef } from "./TypeRefs2-chunk.js";
import { NotFoundError } from "./RestError-chunk.js";
import { CryptoError } from "./CryptoError-chunk.js";
import { decryptKey, decryptKeyPair, isRsaOrRsaEccKeyPair } from "./dist3-chunk.js";

//#region src/common/api/worker/facades/KeyLoaderFacade.ts
var KeyLoaderFacade = class {
	constructor(keyCache, userFacade, entityClient, cacheManagementFacade) {
		this.keyCache = keyCache;
		this.userFacade = userFacade;
		this.entityClient = entityClient;
		this.cacheManagementFacade = cacheManagementFacade;
	}
	/**
	* Load the symmetric group key for the groupId with the provided requestedVersion.
	* @param groupId the id of the group
	* @param requestedVersion the requestedVersion of the key to be loaded
	* @param currentGroupKey needs to be set if the user is not a member of the group (e.g. an admin)
	*/
	async loadSymGroupKey(groupId, requestedVersion, currentGroupKey) {
		if (currentGroupKey != null && currentGroupKey.version < requestedVersion) throw new Error(`Provided current group key is too old (${currentGroupKey.version}) to load the requested version ${requestedVersion} for group ${groupId}`);
		const groupKey = currentGroupKey ?? await this.getCurrentSymGroupKey(groupId);
		if (groupKey.version === requestedVersion) return groupKey.object;
else if (groupKey.version < requestedVersion) {
			await (await this.cacheManagementFacade()).refreshKeyCache(groupId);
			const refreshedGroupKey = await this.getCurrentSymGroupKey(groupId);
			return this.loadSymGroupKey(groupId, requestedVersion, refreshedGroupKey);
		} else {
			const group = await this.entityClient.load(GroupTypeRef, groupId);
			const { symmetricGroupKey } = await this.findFormerGroupKey(group, groupKey, requestedVersion);
			return symmetricGroupKey;
		}
	}
	async getCurrentSymGroupKey(groupId) {
		if (isSameId(groupId, this.userFacade.getUserGroupId())) return this.getCurrentSymUserGroupKey();
		return this.keyCache.getCurrentGroupKey(groupId, () => this.loadAndDecryptCurrentSymGroupKey(groupId));
	}
	async loadSymUserGroupKey(requestedVersion) {
		let currentUserGroupKey = this.getCurrentSymUserGroupKey();
		if (currentUserGroupKey.version < requestedVersion) {
			await (await this.cacheManagementFacade()).refreshKeyCache(this.userFacade.getUserGroupId());
			currentUserGroupKey = this.getCurrentSymUserGroupKey();
		}
		return this.loadSymGroupKey(this.userFacade.getUserGroupId(), requestedVersion, currentUserGroupKey);
	}
	getCurrentSymUserGroupKey() {
		return this.userFacade.getCurrentUserGroupKey();
	}
	async loadKeypair(keyPairGroupId, requestedVersion) {
		let group = await this.entityClient.load(GroupTypeRef, keyPairGroupId);
		let currentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId);
		if (requestedVersion > currentGroupKey.version) {
			group = (await (await this.cacheManagementFacade()).refreshKeyCache(keyPairGroupId)).group;
			currentGroupKey = await this.getCurrentSymGroupKey(keyPairGroupId);
		}
		return await this.loadKeyPairImpl(group, requestedVersion, currentGroupKey);
	}
	async loadCurrentKeyPair(groupId) {
		let group = await this.entityClient.load(GroupTypeRef, groupId);
		let currentGroupKey = await this.getCurrentSymGroupKey(groupId);
		if (parseKeyVersion(group.groupKeyVersion) !== currentGroupKey.version) {
			group = (await (await this.cacheManagementFacade()).refreshKeyCache(groupId)).group;
			currentGroupKey = await this.getCurrentSymGroupKey(groupId);
			if (parseKeyVersion(group.groupKeyVersion) !== currentGroupKey.version) throw new Error(`inconsistent key version state in cache and key cache for group ${groupId}`);
		}
		return {
			object: this.validateAndDecryptKeyPair(group.currentKeys, groupId, currentGroupKey),
			version: parseKeyVersion(group.groupKeyVersion)
		};
	}
	async loadKeyPairImpl(group, requestedVersion, currentGroupKey) {
		const keyPairGroupId = group._id;
		let keyPair;
		let symGroupKey;
		if (requestedVersion > currentGroupKey.version) throw new Error(`Not possible to get newer key version than is cached for group ${keyPairGroupId}`);
else if (requestedVersion === currentGroupKey.version) {
			symGroupKey = currentGroupKey;
			if (parseKeyVersion(group.groupKeyVersion) === currentGroupKey.version) keyPair = group.currentKeys;
else {
				const formerGroupKey = await this.loadFormerGroupKeyInstance(group, currentGroupKey.version);
				keyPair = formerGroupKey.keyPair;
			}
		} else {
			const { symmetricGroupKey, groupKeyInstance } = await this.findFormerGroupKey(group, currentGroupKey, requestedVersion);
			keyPair = groupKeyInstance.keyPair;
			symGroupKey = {
				object: symmetricGroupKey,
				version: requestedVersion
			};
		}
		return this.validateAndDecryptKeyPair(keyPair, keyPairGroupId, symGroupKey);
	}
	async loadFormerGroupKeyInstance(group, version) {
		const formerKeysList = assertNotNull(group.formerGroupKeys).list;
		return await this.entityClient.load(GroupKeyTypeRef, [formerKeysList, convertKeyVersionToCustomId(version)]);
	}
	/**
	*
	* @param groupId MUST NOT be the user group id!
	* @private
	*/
	async loadAndDecryptCurrentSymGroupKey(groupId) {
		if (isSameId(groupId, this.userFacade.getUserGroupId())) throw new ProgrammingError("Must not add the user group to the regular group key cache");
		const groupMembership = this.userFacade.getMembership(groupId);
		const requiredUserGroupKey = await this.loadSymUserGroupKey(parseKeyVersion(groupMembership.symKeyVersion));
		return {
			version: parseKeyVersion(groupMembership.groupKeyVersion),
			object: decryptKey(requiredUserGroupKey, groupMembership.symEncGKey)
		};
	}
	async findFormerGroupKey(group, currentGroupKey, targetKeyVersion) {
		const formerKeysList = assertNotNull(group.formerGroupKeys).list;
		const startId = convertKeyVersionToCustomId(currentGroupKey.version);
		const amountOfKeysIncludingTarget = currentGroupKey.version - targetKeyVersion;
		const formerKeys = await this.entityClient.loadRange(GroupKeyTypeRef, formerKeysList, startId, amountOfKeysIncludingTarget, true);
		let lastVersion = currentGroupKey.version;
		let lastGroupKey = currentGroupKey.object;
		let lastGroupKeyInstance = null;
		for (const formerKey of formerKeys) {
			const version = this.decodeGroupKeyVersion(getElementId(formerKey));
			if (version + 1 > lastVersion) continue;
else if (version + 1 === lastVersion) {
				lastGroupKey = decryptKey(lastGroupKey, formerKey.ownerEncGKey);
				lastVersion = version;
				lastGroupKeyInstance = formerKey;
				if (lastVersion <= targetKeyVersion) break;
			} else throw new Error(`unexpected version ${version}; expected ${lastVersion}`);
		}
		if (lastVersion !== targetKeyVersion || !lastGroupKeyInstance) throw new Error(`could not get version (last version is ${lastVersion} of ${formerKeys.length} key(s) loaded from list ${formerKeysList})`);
		return {
			symmetricGroupKey: lastGroupKey,
			groupKeyInstance: lastGroupKeyInstance
		};
	}
	decodeGroupKeyVersion(id) {
		return parseKeyVersion(customIdToString(id));
	}
	validateAndDecryptKeyPair(keyPair, groupId, groupKey) {
		if (keyPair == null) throw new NotFoundError(`no key pair on group ${groupId}`);
		const decryptedKeyPair = decryptKeyPair(groupKey.object, keyPair);
		if (groupKey.version !== 0 && isRsaOrRsaEccKeyPair(decryptedKeyPair)) throw new CryptoError("received an rsa key pair in a version other than 0: " + groupKey.version);
		return decryptedKeyPair;
	}
};
function convertKeyVersionToCustomId(version) {
	return stringToCustomId(String(version));
}
function parseKeyVersion(version) {
	const versionAsNumber = Number(version);
	return checkKeyVersionConstraints(versionAsNumber);
}
function checkKeyVersionConstraints(version) {
	if (!isKeyVersion(version)) throw new CryptoError("key version is not a non-negative integer");
	return version;
}

//#endregion
export { KeyLoaderFacade, checkKeyVersionConstraints, parseKeyVersion };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiS2V5TG9hZGVyRmFjYWRlLWNodW5rLmpzIiwibmFtZXMiOlsia2V5Q2FjaGU6IEtleUNhY2hlIiwidXNlckZhY2FkZTogVXNlckZhY2FkZSIsImVudGl0eUNsaWVudDogRW50aXR5Q2xpZW50IiwiY2FjaGVNYW5hZ2VtZW50RmFjYWRlOiBsYXp5QXN5bmM8Q2FjaGVNYW5hZ2VtZW50RmFjYWRlPiIsImdyb3VwSWQ6IElkIiwicmVxdWVzdGVkVmVyc2lvbjogS2V5VmVyc2lvbiIsImN1cnJlbnRHcm91cEtleT86IFZlcnNpb25lZEtleSIsImtleVBhaXJHcm91cElkOiBJZCIsImdyb3VwOiBHcm91cCIsImN1cnJlbnRHcm91cEtleTogVmVyc2lvbmVkS2V5Iiwia2V5UGFpcjogS2V5UGFpciB8IG51bGwiLCJzeW1Hcm91cEtleTogVmVyc2lvbmVkS2V5IiwidmVyc2lvbjogS2V5VmVyc2lvbiIsInRhcmdldEtleVZlcnNpb246IEtleVZlcnNpb24iLCJmb3JtZXJLZXlzOiBHcm91cEtleVtdIiwibGFzdEdyb3VwS2V5SW5zdGFuY2U6IEdyb3VwS2V5IHwgbnVsbCIsImlkOiBJZCIsImdyb3VwS2V5OiBWZXJzaW9uZWRLZXkiLCJ2ZXJzaW9uOiBOdW1iZXJTdHJpbmciLCJ2ZXJzaW9uOiBudW1iZXIiXSwic291cmNlcyI6WyIuLi9zcmMvY29tbW9uL2FwaS93b3JrZXIvZmFjYWRlcy9LZXlMb2FkZXJGYWNhZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW50aXR5Q2xpZW50IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9FbnRpdHlDbGllbnQuanNcIlxuaW1wb3J0IHsgQWVzS2V5LCBBc3ltbWV0cmljS2V5UGFpciwgZGVjcnlwdEtleSwgZGVjcnlwdEtleVBhaXIsIEVuY3J5cHRlZEtleVBhaXJzLCBpc1JzYU9yUnNhRWNjS2V5UGFpciB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtY3J5cHRvXCJcbmltcG9ydCB7IEdyb3VwLCBHcm91cEtleSwgR3JvdXBLZXlUeXBlUmVmLCBHcm91cFR5cGVSZWYsIEtleVBhaXIgfSBmcm9tIFwiLi4vLi4vZW50aXRpZXMvc3lzL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IGlzS2V5VmVyc2lvbiwgS2V5VmVyc2lvbiwgVmVyc2lvbmVkIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlscy9kaXN0L1V0aWxzLmpzXCJcbmltcG9ydCB7IFVzZXJGYWNhZGUgfSBmcm9tIFwiLi9Vc2VyRmFjYWRlLmpzXCJcbmltcG9ydCB7IE5vdEZvdW5kRXJyb3IgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2Vycm9yL1Jlc3RFcnJvci5qc1wiXG5pbXBvcnQgeyBjdXN0b21JZFRvU3RyaW5nLCBnZXRFbGVtZW50SWQsIGlzU2FtZUlkLCBzdHJpbmdUb0N1c3RvbUlkIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlscy9FbnRpdHlVdGlscy5qc1wiXG5pbXBvcnQgeyBLZXlDYWNoZSB9IGZyb20gXCIuL0tleUNhY2hlLmpzXCJcbmltcG9ydCB7IGFzc2VydE5vdE51bGwsIGxhenlBc3luYyB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgQ2FjaGVNYW5hZ2VtZW50RmFjYWRlIH0gZnJvbSBcIi4vbGF6eS9DYWNoZU1hbmFnZW1lbnRGYWNhZGUuanNcIlxuaW1wb3J0IHsgUHJvZ3JhbW1pbmdFcnJvciB9IGZyb20gXCIuLi8uLi9jb21tb24vZXJyb3IvUHJvZ3JhbW1pbmdFcnJvci5qc1wiXG5pbXBvcnQgeyBDcnlwdG9FcnJvciB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtY3J5cHRvL2Vycm9yLmpzXCJcbmltcG9ydCB7IFZlcnNpb25lZEtleSB9IGZyb20gXCIuLi9jcnlwdG8vQ3J5cHRvV3JhcHBlci5qc1wiXG5cbi8qKlxuICogTG9hZCBzeW1tZXRyaWMgYW5kIGFzeW1tZXRyaWMga2V5cyBhbmQgZGVjcnlwdCB0aGVtLlxuICogSGFuZGxlIGdyb3VwIGtleSB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY2xhc3MgS2V5TG9hZGVyRmFjYWRlIHtcblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSByZWFkb25seSBrZXlDYWNoZTogS2V5Q2FjaGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1c2VyRmFjYWRlOiBVc2VyRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgZW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjYWNoZU1hbmFnZW1lbnRGYWNhZGU6IGxhenlBc3luYzxDYWNoZU1hbmFnZW1lbnRGYWNhZGU+LFxuXHQpIHt9XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIHN5bW1ldHJpYyBncm91cCBrZXkgZm9yIHRoZSBncm91cElkIHdpdGggdGhlIHByb3ZpZGVkIHJlcXVlc3RlZFZlcnNpb24uXG5cdCAqIEBwYXJhbSBncm91cElkIHRoZSBpZCBvZiB0aGUgZ3JvdXBcblx0ICogQHBhcmFtIHJlcXVlc3RlZFZlcnNpb24gdGhlIHJlcXVlc3RlZFZlcnNpb24gb2YgdGhlIGtleSB0byBiZSBsb2FkZWRcblx0ICogQHBhcmFtIGN1cnJlbnRHcm91cEtleSBuZWVkcyB0byBiZSBzZXQgaWYgdGhlIHVzZXIgaXMgbm90IGEgbWVtYmVyIG9mIHRoZSBncm91cCAoZS5nLiBhbiBhZG1pbilcblx0ICovXG5cdGFzeW5jIGxvYWRTeW1Hcm91cEtleShncm91cElkOiBJZCwgcmVxdWVzdGVkVmVyc2lvbjogS2V5VmVyc2lvbiwgY3VycmVudEdyb3VwS2V5PzogVmVyc2lvbmVkS2V5KTogUHJvbWlzZTxBZXNLZXk+IHtcblx0XHRpZiAoY3VycmVudEdyb3VwS2V5ICE9IG51bGwgJiYgY3VycmVudEdyb3VwS2V5LnZlcnNpb24gPCByZXF1ZXN0ZWRWZXJzaW9uKSB7XG5cdFx0XHQvLyB3ZSBtaWdodCBub3QgaGF2ZSB0aGUgbWVtYmVyc2hpcCBmb3IgdGhpcyBncm91cC4gc28gdGhlIGNhbGxlciBuZWVkcyB0byBoYW5kbGUgaXQgYnkgcmVmcmVzaGluZyB0aGUgY2FjaGVcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YFByb3ZpZGVkIGN1cnJlbnQgZ3JvdXAga2V5IGlzIHRvbyBvbGQgKCR7Y3VycmVudEdyb3VwS2V5LnZlcnNpb259KSB0byBsb2FkIHRoZSByZXF1ZXN0ZWQgdmVyc2lvbiAke3JlcXVlc3RlZFZlcnNpb259IGZvciBncm91cCAke2dyb3VwSWR9YCxcblx0XHRcdClcblx0XHR9XG5cdFx0Y29uc3QgZ3JvdXBLZXkgPSBjdXJyZW50R3JvdXBLZXkgPz8gKGF3YWl0IHRoaXMuZ2V0Q3VycmVudFN5bUdyb3VwS2V5KGdyb3VwSWQpKVxuXG5cdFx0aWYgKGdyb3VwS2V5LnZlcnNpb24gPT09IHJlcXVlc3RlZFZlcnNpb24pIHtcblx0XHRcdHJldHVybiBncm91cEtleS5vYmplY3Rcblx0XHR9IGVsc2UgaWYgKGdyb3VwS2V5LnZlcnNpb24gPCByZXF1ZXN0ZWRWZXJzaW9uKSB7XG5cdFx0XHQvLyB0aGUgbGF0ZXN0IGtleSBpcyBub3QgY2FjaGVkLCBzbyB3ZSB1cGRhdGUgdGhlIHVzZXIgYW5kIHRyeSBhZ2FpblxuXHRcdFx0Ly8gdGhpcyBjYW4gc3RpbGwgZmFpbCBhcyB3ZSBtaWdodCBiZSB0b28gc2xvdyB3aXRoIHByb2Nlc3Npbmcgc29tZSB1cGRhdGUgZS5nLiBhIEdyb3VwS2V5VXBkYXRlXG5cdFx0XHQvLyAod2UgYXJlIG1lbWJlciBvZiBhIHNoYXJlZCBncm91cCByb3RhdGVkIGJ5IHNvbWVvbmUgZWxzZSBhbmQgdGhlIG5ldyBtZW1iZXJzaGlwIGlzIG5vdCB5ZXQgb24gdGhlIHVzZXIpXG5cdFx0XHRhd2FpdCAoYXdhaXQgdGhpcy5jYWNoZU1hbmFnZW1lbnRGYWNhZGUoKSkucmVmcmVzaEtleUNhY2hlKGdyb3VwSWQpXG5cdFx0XHQvLyBUaGVyZSBpcyBubyBwb2ludCBpbiByZS10cnlpbmcgd2l0aCB0aGUgb3V0ZGF0ZWQgY3VycmVudCBncm91cCBrZXlcblx0XHRcdGNvbnN0IHJlZnJlc2hlZEdyb3VwS2V5ID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50U3ltR3JvdXBLZXkoZ3JvdXBJZCkgLy8gd2UgcGFzcyB0aGUgY3VycmVudEdyb3VwS2V5IHRvIGJyZWFrIHRoZSByZWN1cnNpb25cblx0XHRcdHJldHVybiB0aGlzLmxvYWRTeW1Hcm91cEtleShncm91cElkLCByZXF1ZXN0ZWRWZXJzaW9uLCByZWZyZXNoZWRHcm91cEtleSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gd2UgbG9hZCBhIGZvcm1lciBrZXkgYXMgdGhlIGNhY2hlZCBvbmUgaXMgbmV3ZXI6IGdyb3VwS2V5LnJlcXVlc3RlZFZlcnNpb24gPiByZXF1ZXN0ZWRWZXJzaW9uXG5cdFx0XHRjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoR3JvdXBUeXBlUmVmLCBncm91cElkKVxuXHRcdFx0Y29uc3QgeyBzeW1tZXRyaWNHcm91cEtleSB9ID0gYXdhaXQgdGhpcy5maW5kRm9ybWVyR3JvdXBLZXkoZ3JvdXAsIGdyb3VwS2V5LCByZXF1ZXN0ZWRWZXJzaW9uKVxuXHRcdFx0cmV0dXJuIHN5bW1ldHJpY0dyb3VwS2V5XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgZ2V0Q3VycmVudFN5bUdyb3VwS2V5KGdyb3VwSWQ6IElkKTogUHJvbWlzZTxWZXJzaW9uZWRLZXk+IHtcblx0XHQvLyBUaGUgY3VycmVudCB1c2VyIGdyb3VwIGtleSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBtYXAgb2YgY3VycmVudCBrZXlzLCBiZWNhdXNlIHdlIG9ubHkga2VlcCBhIGNvcHkgaW4gdXNlckZhY2FkZVxuXHRcdGlmIChpc1NhbWVJZChncm91cElkLCB0aGlzLnVzZXJGYWNhZGUuZ2V0VXNlckdyb3VwSWQoKSkpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEN1cnJlbnRTeW1Vc2VyR3JvdXBLZXkoKVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5rZXlDYWNoZS5nZXRDdXJyZW50R3JvdXBLZXkoZ3JvdXBJZCwgKCkgPT4gdGhpcy5sb2FkQW5kRGVjcnlwdEN1cnJlbnRTeW1Hcm91cEtleShncm91cElkKSlcblx0fVxuXG5cdGFzeW5jIGxvYWRTeW1Vc2VyR3JvdXBLZXkocmVxdWVzdGVkVmVyc2lvbjogS2V5VmVyc2lvbik6IFByb21pc2U8QWVzS2V5PiB7XG5cdFx0Ly8gd2UgcHJvdmlkZSB0aGUgY3VycmVudCB1c2VyIGdyb3VwIGtleSB0byBicmVhayBhIHBvc3NpYmx5IGluZmluaXRlIHJlY3Vyc2lvblxuXHRcdGxldCBjdXJyZW50VXNlckdyb3VwS2V5ID0gdGhpcy5nZXRDdXJyZW50U3ltVXNlckdyb3VwS2V5KClcblx0XHRpZiAoY3VycmVudFVzZXJHcm91cEtleS52ZXJzaW9uIDwgcmVxdWVzdGVkVmVyc2lvbikge1xuXHRcdFx0YXdhaXQgKGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VtZW50RmFjYWRlKCkpLnJlZnJlc2hLZXlDYWNoZSh0aGlzLnVzZXJGYWNhZGUuZ2V0VXNlckdyb3VwSWQoKSlcblx0XHRcdGN1cnJlbnRVc2VyR3JvdXBLZXkgPSB0aGlzLmdldEN1cnJlbnRTeW1Vc2VyR3JvdXBLZXkoKVxuXHRcdFx0Ly8gaWYgdGhlIGtleSBpcyBzdGlsbCBvdXRkYXRlZCBsb2FkU3ltR3JvdXBLZXkgd2lsbCB0aHJvdyAtIHdlIHRyaWVkIG91ciBiZXN0LlxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5sb2FkU3ltR3JvdXBLZXkodGhpcy51c2VyRmFjYWRlLmdldFVzZXJHcm91cElkKCksIHJlcXVlc3RlZFZlcnNpb24sIGN1cnJlbnRVc2VyR3JvdXBLZXkpXG5cdH1cblxuXHRnZXRDdXJyZW50U3ltVXNlckdyb3VwS2V5KCk6IFZlcnNpb25lZEtleSB7XG5cdFx0cmV0dXJuIHRoaXMudXNlckZhY2FkZS5nZXRDdXJyZW50VXNlckdyb3VwS2V5KClcblx0fVxuXG5cdGFzeW5jIGxvYWRLZXlwYWlyKGtleVBhaXJHcm91cElkOiBJZCwgcmVxdWVzdGVkVmVyc2lvbjogS2V5VmVyc2lvbik6IFByb21pc2U8QXN5bW1ldHJpY0tleVBhaXI+IHtcblx0XHRsZXQgZ3JvdXAgPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKEdyb3VwVHlwZVJlZiwga2V5UGFpckdyb3VwSWQpXG5cdFx0bGV0IGN1cnJlbnRHcm91cEtleSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFN5bUdyb3VwS2V5KGtleVBhaXJHcm91cElkKVxuXG5cdFx0aWYgKHJlcXVlc3RlZFZlcnNpb24gPiBjdXJyZW50R3JvdXBLZXkudmVyc2lvbikge1xuXHRcdFx0Z3JvdXAgPSAoYXdhaXQgKGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VtZW50RmFjYWRlKCkpLnJlZnJlc2hLZXlDYWNoZShrZXlQYWlyR3JvdXBJZCkpLmdyb3VwXG5cdFx0XHRjdXJyZW50R3JvdXBLZXkgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRTeW1Hcm91cEtleShrZXlQYWlyR3JvdXBJZClcblx0XHR9XG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMubG9hZEtleVBhaXJJbXBsKGdyb3VwLCByZXF1ZXN0ZWRWZXJzaW9uLCBjdXJyZW50R3JvdXBLZXkpXG5cdH1cblxuXHRhc3luYyBsb2FkQ3VycmVudEtleVBhaXIoZ3JvdXBJZDogSWQpOiBQcm9taXNlPFZlcnNpb25lZDxBc3ltbWV0cmljS2V5UGFpcj4+IHtcblx0XHRsZXQgZ3JvdXAgPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKEdyb3VwVHlwZVJlZiwgZ3JvdXBJZClcblxuXHRcdGxldCBjdXJyZW50R3JvdXBLZXkgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRTeW1Hcm91cEtleShncm91cElkKVxuXHRcdGlmIChwYXJzZUtleVZlcnNpb24oZ3JvdXAuZ3JvdXBLZXlWZXJzaW9uKSAhPT0gY3VycmVudEdyb3VwS2V5LnZlcnNpb24pIHtcblx0XHRcdC8vIFRoZXJlIGlzIGEgcmFjZSBjb25kaXRpb24gYWZ0ZXIgcm90YXRpbmcgdGhlIGdyb3VwIGtleSB3ZXJlIHRoZSBncm91cCBlbnRpdHkgaW4gdGhlIGNhY2hlIGlzIG5vdCBpbiBzeW5jIHdpdGggY3VycmVudCBrZXkgdmVyc2lvbiBpbiB0aGUga2V5IGNhY2hlLlxuXHRcdFx0Ly8gZ3JvdXAuZ3JvdXBLZXlWZXJzaW9uIG1pZ2h0IGJlIG5ld2VyIHRoYW4gY3VycmVudEdyb3VwS2V5LnZlcnNpb24uXG5cdFx0XHQvLyBXZSByZWxvYWQgZ3JvdXAgYW5kIHVzZXIgYW5kIHJlZnJlc2ggZW50aXR5IGFuZCBrZXkgY2FjaGUgdG8gc3luY2hyb25pemUgYm90aCBjYWNoZXMuXG5cdFx0XHRncm91cCA9IChhd2FpdCAoYXdhaXQgdGhpcy5jYWNoZU1hbmFnZW1lbnRGYWNhZGUoKSkucmVmcmVzaEtleUNhY2hlKGdyb3VwSWQpKS5ncm91cFxuXHRcdFx0Y3VycmVudEdyb3VwS2V5ID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50U3ltR3JvdXBLZXkoZ3JvdXBJZClcblx0XHRcdGlmIChwYXJzZUtleVZlcnNpb24oZ3JvdXAuZ3JvdXBLZXlWZXJzaW9uKSAhPT0gY3VycmVudEdyb3VwS2V5LnZlcnNpb24pIHtcblx0XHRcdFx0Ly8gd2Ugc3RpbGwgZG8gbm90IGhhdmUgdGhlIHByb3BlciBzdGF0ZSB0byBnZXQgdGhlIGN1cnJlbnQga2V5IHBhaXJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQga2V5IHZlcnNpb24gc3RhdGUgaW4gY2FjaGUgYW5kIGtleSBjYWNoZSBmb3IgZ3JvdXAgJHtncm91cElkfWApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7IG9iamVjdDogdGhpcy52YWxpZGF0ZUFuZERlY3J5cHRLZXlQYWlyKGdyb3VwLmN1cnJlbnRLZXlzLCBncm91cElkLCBjdXJyZW50R3JvdXBLZXkpLCB2ZXJzaW9uOiBwYXJzZUtleVZlcnNpb24oZ3JvdXAuZ3JvdXBLZXlWZXJzaW9uKSB9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGxvYWRLZXlQYWlySW1wbChncm91cDogR3JvdXAsIHJlcXVlc3RlZFZlcnNpb246IEtleVZlcnNpb24sIGN1cnJlbnRHcm91cEtleTogVmVyc2lvbmVkS2V5KSB7XG5cdFx0Y29uc3Qga2V5UGFpckdyb3VwSWQgPSBncm91cC5faWRcblx0XHRsZXQga2V5UGFpcjogS2V5UGFpciB8IG51bGxcblx0XHRsZXQgc3ltR3JvdXBLZXk6IFZlcnNpb25lZEtleVxuXHRcdGlmIChyZXF1ZXN0ZWRWZXJzaW9uID4gY3VycmVudEdyb3VwS2V5LnZlcnNpb24pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTm90IHBvc3NpYmxlIHRvIGdldCBuZXdlciBrZXkgdmVyc2lvbiB0aGFuIGlzIGNhY2hlZCBmb3IgZ3JvdXAgJHtrZXlQYWlyR3JvdXBJZH1gKVxuXHRcdH0gZWxzZSBpZiAocmVxdWVzdGVkVmVyc2lvbiA9PT0gY3VycmVudEdyb3VwS2V5LnZlcnNpb24pIHtcblx0XHRcdHN5bUdyb3VwS2V5ID0gY3VycmVudEdyb3VwS2V5XG5cdFx0XHRpZiAocGFyc2VLZXlWZXJzaW9uKGdyb3VwLmdyb3VwS2V5VmVyc2lvbikgPT09IGN1cnJlbnRHcm91cEtleS52ZXJzaW9uKSB7XG5cdFx0XHRcdGtleVBhaXIgPSBncm91cC5jdXJyZW50S2V5c1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gd2UgbG9hZCBieSB0aGUgdmVyc2lvbiBhbmQgdGh1cyBjYW4gYmUgc3VyZSB0aGF0IHdlIGFyZSBhYmxlIHRvIGRlY3J5cHQgdGhpcyBrZXlcblx0XHRcdFx0Y29uc3QgZm9ybWVyR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmxvYWRGb3JtZXJHcm91cEtleUluc3RhbmNlKGdyb3VwLCBjdXJyZW50R3JvdXBLZXkudmVyc2lvbilcblx0XHRcdFx0a2V5UGFpciA9IGZvcm1lckdyb3VwS2V5LmtleVBhaXJcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbG9hZCBhIGZvcm1lciBrZXkgcGFpcjogZ3JvdXBLZXlWZXJzaW9uIDwgZ3JvdXBLZXkudmVyc2lvblxuXHRcdFx0Y29uc3QgeyBzeW1tZXRyaWNHcm91cEtleSwgZ3JvdXBLZXlJbnN0YW5jZSB9ID0gYXdhaXQgdGhpcy5maW5kRm9ybWVyR3JvdXBLZXkoZ3JvdXAsIGN1cnJlbnRHcm91cEtleSwgcmVxdWVzdGVkVmVyc2lvbilcblx0XHRcdGtleVBhaXIgPSBncm91cEtleUluc3RhbmNlLmtleVBhaXJcblx0XHRcdHN5bUdyb3VwS2V5ID0geyBvYmplY3Q6IHN5bW1ldHJpY0dyb3VwS2V5LCB2ZXJzaW9uOiByZXF1ZXN0ZWRWZXJzaW9uIH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMudmFsaWRhdGVBbmREZWNyeXB0S2V5UGFpcihrZXlQYWlyLCBrZXlQYWlyR3JvdXBJZCwgc3ltR3JvdXBLZXkpXG5cdH1cblxuXHRhc3luYyBsb2FkRm9ybWVyR3JvdXBLZXlJbnN0YW5jZShncm91cDogR3JvdXAsIHZlcnNpb246IEtleVZlcnNpb24pOiBQcm9taXNlPEdyb3VwS2V5PiB7XG5cdFx0Y29uc3QgZm9ybWVyS2V5c0xpc3QgPSBhc3NlcnROb3ROdWxsKGdyb3VwLmZvcm1lckdyb3VwS2V5cykubGlzdFxuXHRcdHJldHVybiBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKEdyb3VwS2V5VHlwZVJlZiwgW2Zvcm1lcktleXNMaXN0LCBjb252ZXJ0S2V5VmVyc2lvblRvQ3VzdG9tSWQodmVyc2lvbildKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBncm91cElkIE1VU1QgTk9UIGJlIHRoZSB1c2VyIGdyb3VwIGlkIVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBsb2FkQW5kRGVjcnlwdEN1cnJlbnRTeW1Hcm91cEtleShncm91cElkOiBJZCkge1xuXHRcdGlmIChpc1NhbWVJZChncm91cElkLCB0aGlzLnVzZXJGYWNhZGUuZ2V0VXNlckdyb3VwSWQoKSkpIHtcblx0XHRcdHRocm93IG5ldyBQcm9ncmFtbWluZ0Vycm9yKFwiTXVzdCBub3QgYWRkIHRoZSB1c2VyIGdyb3VwIHRvIHRoZSByZWd1bGFyIGdyb3VwIGtleSBjYWNoZVwiKVxuXHRcdH1cblx0XHRjb25zdCBncm91cE1lbWJlcnNoaXAgPSB0aGlzLnVzZXJGYWNhZGUuZ2V0TWVtYmVyc2hpcChncm91cElkKVxuXHRcdGNvbnN0IHJlcXVpcmVkVXNlckdyb3VwS2V5ID0gYXdhaXQgdGhpcy5sb2FkU3ltVXNlckdyb3VwS2V5KHBhcnNlS2V5VmVyc2lvbihncm91cE1lbWJlcnNoaXAuc3ltS2V5VmVyc2lvbikpXG5cdFx0cmV0dXJuIHtcblx0XHRcdHZlcnNpb246IHBhcnNlS2V5VmVyc2lvbihncm91cE1lbWJlcnNoaXAuZ3JvdXBLZXlWZXJzaW9uKSxcblx0XHRcdG9iamVjdDogZGVjcnlwdEtleShyZXF1aXJlZFVzZXJHcm91cEtleSwgZ3JvdXBNZW1iZXJzaGlwLnN5bUVuY0dLZXkpLFxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZmluZEZvcm1lckdyb3VwS2V5KFxuXHRcdGdyb3VwOiBHcm91cCxcblx0XHRjdXJyZW50R3JvdXBLZXk6IFZlcnNpb25lZEtleSxcblx0XHR0YXJnZXRLZXlWZXJzaW9uOiBLZXlWZXJzaW9uLFxuXHQpOiBQcm9taXNlPHsgc3ltbWV0cmljR3JvdXBLZXk6IEFlc0tleTsgZ3JvdXBLZXlJbnN0YW5jZTogR3JvdXBLZXkgfT4ge1xuXHRcdGNvbnN0IGZvcm1lcktleXNMaXN0ID0gYXNzZXJ0Tm90TnVsbChncm91cC5mb3JtZXJHcm91cEtleXMpLmxpc3Rcblx0XHQvLyBzdGFydCBpZCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBvZiB0aGUgcmFuZ2UgcmVxdWVzdCwgc28gd2UgbmVlZCB0byBzdGFydCBhdCBjdXJyZW50IHZlcnNpb24uXG5cdFx0Y29uc3Qgc3RhcnRJZCA9IGNvbnZlcnRLZXlWZXJzaW9uVG9DdXN0b21JZChjdXJyZW50R3JvdXBLZXkudmVyc2lvbilcblx0XHRjb25zdCBhbW91bnRPZktleXNJbmNsdWRpbmdUYXJnZXQgPSBjdXJyZW50R3JvdXBLZXkudmVyc2lvbiAtIHRhcmdldEtleVZlcnNpb25cblxuXHRcdGNvbnN0IGZvcm1lcktleXM6IEdyb3VwS2V5W10gPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkUmFuZ2UoR3JvdXBLZXlUeXBlUmVmLCBmb3JtZXJLZXlzTGlzdCwgc3RhcnRJZCwgYW1vdW50T2ZLZXlzSW5jbHVkaW5nVGFyZ2V0LCB0cnVlKVxuXG5cdFx0bGV0IGxhc3RWZXJzaW9uID0gY3VycmVudEdyb3VwS2V5LnZlcnNpb25cblx0XHRsZXQgbGFzdEdyb3VwS2V5ID0gY3VycmVudEdyb3VwS2V5Lm9iamVjdFxuXHRcdGxldCBsYXN0R3JvdXBLZXlJbnN0YW5jZTogR3JvdXBLZXkgfCBudWxsID0gbnVsbFxuXG5cdFx0Zm9yIChjb25zdCBmb3JtZXJLZXkgb2YgZm9ybWVyS2V5cykge1xuXHRcdFx0Y29uc3QgdmVyc2lvbiA9IHRoaXMuZGVjb2RlR3JvdXBLZXlWZXJzaW9uKGdldEVsZW1lbnRJZChmb3JtZXJLZXkpKVxuXHRcdFx0aWYgKHZlcnNpb24gKyAxID4gbGFzdFZlcnNpb24pIHtcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH0gZWxzZSBpZiAodmVyc2lvbiArIDEgPT09IGxhc3RWZXJzaW9uKSB7XG5cdFx0XHRcdGxhc3RHcm91cEtleSA9IGRlY3J5cHRLZXkobGFzdEdyb3VwS2V5LCBmb3JtZXJLZXkub3duZXJFbmNHS2V5KVxuXHRcdFx0XHRsYXN0VmVyc2lvbiA9IHZlcnNpb25cblx0XHRcdFx0bGFzdEdyb3VwS2V5SW5zdGFuY2UgPSBmb3JtZXJLZXlcblx0XHRcdFx0aWYgKGxhc3RWZXJzaW9uIDw9IHRhcmdldEtleVZlcnNpb24pIHtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdmVyc2lvbiAke3ZlcnNpb259OyBleHBlY3RlZCAke2xhc3RWZXJzaW9ufWApXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGxhc3RWZXJzaW9uICE9PSB0YXJnZXRLZXlWZXJzaW9uIHx8ICFsYXN0R3JvdXBLZXlJbnN0YW5jZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgZ2V0IHZlcnNpb24gKGxhc3QgdmVyc2lvbiBpcyAke2xhc3RWZXJzaW9ufSBvZiAke2Zvcm1lcktleXMubGVuZ3RofSBrZXkocykgbG9hZGVkIGZyb20gbGlzdCAke2Zvcm1lcktleXNMaXN0fSlgKVxuXHRcdH1cblxuXHRcdHJldHVybiB7IHN5bW1ldHJpY0dyb3VwS2V5OiBsYXN0R3JvdXBLZXksIGdyb3VwS2V5SW5zdGFuY2U6IGxhc3RHcm91cEtleUluc3RhbmNlIH1cblx0fVxuXG5cdHByaXZhdGUgZGVjb2RlR3JvdXBLZXlWZXJzaW9uKGlkOiBJZCk6IEtleVZlcnNpb24ge1xuXHRcdHJldHVybiBwYXJzZUtleVZlcnNpb24oY3VzdG9tSWRUb1N0cmluZyhpZCkpXG5cdH1cblxuXHRwcml2YXRlIHZhbGlkYXRlQW5kRGVjcnlwdEtleVBhaXIoa2V5UGFpcjogS2V5UGFpciB8IG51bGwsIGdyb3VwSWQ6IElkLCBncm91cEtleTogVmVyc2lvbmVkS2V5KSB7XG5cdFx0aWYgKGtleVBhaXIgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoYG5vIGtleSBwYWlyIG9uIGdyb3VwICR7Z3JvdXBJZH1gKVxuXHRcdH1cblx0XHQvLyB0aGlzIGNhc3QgaXMgYWNjZXB0YWJsZSBhcyB0aG9zZSBhcmUgdGhlIGNvbnN0cmFpbnRzIHdlIGhhdmUgb24gS2V5UGFpci4gd2UganVzdCBjYW5ub3Qga25vdyB3aGljaCBvbmUgd2UgaGF2ZSBzdGF0aWNhbGx5XG5cdFx0Y29uc3QgZGVjcnlwdGVkS2V5UGFpciA9IGRlY3J5cHRLZXlQYWlyKGdyb3VwS2V5Lm9iamVjdCwga2V5UGFpciBhcyBFbmNyeXB0ZWRLZXlQYWlycylcblx0XHRpZiAoZ3JvdXBLZXkudmVyc2lvbiAhPT0gMCAmJiBpc1JzYU9yUnNhRWNjS2V5UGFpcihkZWNyeXB0ZWRLZXlQYWlyKSkge1xuXHRcdFx0dGhyb3cgbmV3IENyeXB0b0Vycm9yKFwicmVjZWl2ZWQgYW4gcnNhIGtleSBwYWlyIGluIGEgdmVyc2lvbiBvdGhlciB0aGFuIDA6IFwiICsgZ3JvdXBLZXkudmVyc2lvbilcblx0XHR9XG5cdFx0cmV0dXJuIGRlY3J5cHRlZEtleVBhaXJcblx0fVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0S2V5VmVyc2lvblRvQ3VzdG9tSWQodmVyc2lvbjogS2V5VmVyc2lvbikge1xuXHRyZXR1cm4gc3RyaW5nVG9DdXN0b21JZChTdHJpbmcodmVyc2lvbikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUtleVZlcnNpb24odmVyc2lvbjogTnVtYmVyU3RyaW5nKTogS2V5VmVyc2lvbiB7XG5cdGNvbnN0IHZlcnNpb25Bc051bWJlciA9IE51bWJlcih2ZXJzaW9uKVxuXHRyZXR1cm4gY2hlY2tLZXlWZXJzaW9uQ29uc3RyYWludHModmVyc2lvbkFzTnVtYmVyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tLZXlWZXJzaW9uQ29uc3RyYWludHModmVyc2lvbjogbnVtYmVyKTogS2V5VmVyc2lvbiB7XG5cdGlmICghaXNLZXlWZXJzaW9uKHZlcnNpb24pKSB7XG5cdFx0dGhyb3cgbmV3IENyeXB0b0Vycm9yKFwia2V5IHZlcnNpb24gaXMgbm90IGEgbm9uLW5lZ2F0aXZlIGludGVnZXJcIilcblx0fVxuXHRyZXR1cm4gdmVyc2lvblxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7SUFrQmEsa0JBQU4sTUFBc0I7Q0FDNUIsWUFDa0JBLFVBQ0FDLFlBQ0FDLGNBQ0FDLHVCQUNoQjtFQTRNRixLQWhOa0I7RUFnTmpCLEtBL01pQjtFQStNaEIsS0E5TWdCO0VBOE1mLEtBN01lO0NBQ2Q7Ozs7Ozs7Q0FRSixNQUFNLGdCQUFnQkMsU0FBYUMsa0JBQThCQyxpQkFBaUQ7QUFDakgsTUFBSSxtQkFBbUIsUUFBUSxnQkFBZ0IsVUFBVSxpQkFFeEQsT0FBTSxJQUFJLE9BQ1IseUNBQXlDLGdCQUFnQixRQUFRLGtDQUFrQyxpQkFBaUIsYUFB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