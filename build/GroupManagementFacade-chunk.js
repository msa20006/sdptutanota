import "./dist-chunk.js";
import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { assertWorkerOrNode } from "./Env-chunk.js";
import { assertNotNull, freshVersioned, getFirstOrThrow, isNotEmpty, neverNull } from "./dist2-chunk.js";
import { CounterType, GroupType, PublicKeyIdentifierType } from "./TutanotaConstants-chunk.js";
import "./EntityUtils-chunk.js";
import "./TypeModels-chunk.js";
import { createCreateMailGroupData, createDeleteGroupData, createInternalGroupData, createUserAreaGroupData, createUserAreaGroupDeleteData, createUserAreaGroupPostData } from "./TypeRefs-chunk.js";
import "./TypeModels2-chunk.js";
import { AdministratedGroupTypeRef, CustomerTypeRef, GroupInfoTypeRef, GroupTypeRef, UserTypeRef, createLocalAdminGroupReplacementData, createLocalAdminRemovalPostIn, createMembershipAddData, createMembershipRemoveData } from "./TypeRefs2-chunk.js";
import "./CryptoError-chunk.js";
import { LocalAdminRemovalService, MembershipService } from "./Services-chunk.js";
import "./dist3-chunk.js";
import { encryptKeyWithVersionedKey, encryptString } from "./CryptoWrapper-chunk.js";
import { CalendarService, ContactListGroupService, MailGroupService, TemplateGroupService } from "./Services2-chunk.js";
import { isGlobalAdmin } from "./UserUtils-chunk.js";

//#region src/common/api/worker/facades/lazy/GroupManagementFacade.ts
assertWorkerOrNode();
var GroupManagementFacade = class {
	constructor(userFacade, counters, entityClient, serviceExecutor, pqFacade, keyLoaderFacade, cacheManagementFacade, asymmetricCryptoFacade, cryptoWrapper) {
		this.userFacade = userFacade;
		this.counters = counters;
		this.entityClient = entityClient;
		this.serviceExecutor = serviceExecutor;
		this.pqFacade = pqFacade;
		this.keyLoaderFacade = keyLoaderFacade;
		this.cacheManagementFacade = cacheManagementFacade;
		this.asymmetricCryptoFacade = asymmetricCryptoFacade;
		this.cryptoWrapper = cryptoWrapper;
	}
	async readUsedSharedMailGroupStorage(group) {
		return this.counters.readCounterValue(CounterType.UserStorageLegacy, neverNull(group.customer), group._id);
	}
	async createMailGroup(name, mailAddress) {
		const adminGroupIds = this.userFacade.getGroupIds(GroupType.Admin);
		const adminGroupId = getFirstOrThrow(adminGroupIds);
		let adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		let customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(this.userFacade.getGroupId(GroupType.Customer));
		let mailGroupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey());
		let mailGroupInfoSessionKey = this.cryptoWrapper.aes256RandomKey();
		let mailboxSessionKey = this.cryptoWrapper.aes256RandomKey();
		const keyPair = await this.pqFacade.generateKeyPairs();
		const mailGroupData = this.generateInternalGroupData(keyPair, mailGroupKey.object, mailGroupInfoSessionKey, adminGroupId, adminGroupKey, customerGroupKey);
		const mailEncMailboxSessionKey = encryptKeyWithVersionedKey(mailGroupKey, mailboxSessionKey);
		const data = createCreateMailGroupData({
			mailAddress,
			encryptedName: encryptString(mailGroupInfoSessionKey, name),
			mailEncMailboxSessionKey: mailEncMailboxSessionKey.key,
			groupData: mailGroupData
		});
		await this.serviceExecutor.post(MailGroupService, data);
	}
	/**
	* Generates keys for the new group and prepares the group data object to create the group.
	*
	* @param name Name of the group
	*/
	async generateUserAreaGroupData(name) {
		const userGroup = await this.entityClient.load(GroupTypeRef, this.userFacade.getUserGroupId());
		const adminGroupId = neverNull(userGroup.admin);
		let adminGroupKey = null;
		if (this.userFacade.getAllGroupIds().indexOf(adminGroupId) !== -1) adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		const customerGroupId = this.userFacade.getGroupId(GroupType.Customer);
		const customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(customerGroupId);
		const userGroupKey = this.userFacade.getCurrentUserGroupKey();
		const groupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey());
		const groupRootSessionKey = this.cryptoWrapper.aes256RandomKey();
		const groupInfoSessionKey = this.cryptoWrapper.aes256RandomKey();
		const userEncGroupKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object);
		const adminEncGroupKey = adminGroupKey ? encryptKeyWithVersionedKey(adminGroupKey, groupKey.object) : null;
		const customerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(customerGroupKey, groupInfoSessionKey);
		const groupEncGroupRootSessionKey = encryptKeyWithVersionedKey(groupKey, groupRootSessionKey);
		return createUserAreaGroupData({
			groupEncGroupRootSessionKey: groupEncGroupRootSessionKey.key,
			customerEncGroupInfoSessionKey: customerEncGroupInfoSessionKey.key,
			userEncGroupKey: userEncGroupKey.key,
			groupInfoEncName: encryptString(groupInfoSessionKey, name),
			adminEncGroupKey: adminEncGroupKey?.key ?? null,
			adminGroup: adminGroupId,
			customerKeyVersion: customerEncGroupInfoSessionKey.encryptingKeyVersion.toString(),
			userKeyVersion: userGroupKey.version.toString(),
			adminKeyVersion: adminEncGroupKey?.encryptingKeyVersion.toString() ?? null
		});
	}
	async createCalendar(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const postData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(CalendarService, postData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		const group = await this.entityClient.load(GroupTypeRef, postGroupData.group);
		const user = await this.cacheManagementFacade.reloadUser();
		return {
			user,
			group
		};
	}
	async createTemplateGroup(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const serviceData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(TemplateGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		await this.cacheManagementFacade.reloadUser();
		return postGroupData.group;
	}
	async createContactListGroup(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const serviceData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(ContactListGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		const group = await this.entityClient.load(GroupTypeRef, postGroupData.group);
		await this.cacheManagementFacade.reloadUser();
		return group;
	}
	async deleteContactListGroup(groupRoot) {
		const serviceData = createUserAreaGroupDeleteData({ group: groupRoot._id });
		await this.serviceExecutor.delete(ContactListGroupService, serviceData);
	}
	/**
	* Assemble the data transfer type to create a new internal group on the server.
	* The group key version is not needed because it is always zero.
	*/
	generateInternalGroupData(keyPair, groupKey, groupInfoSessionKey, adminGroupId, adminGroupKey, ownerGroupKey) {
		const adminEncGroupKey = encryptKeyWithVersionedKey(adminGroupKey, groupKey);
		const ownerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(ownerGroupKey, groupInfoSessionKey);
		return createInternalGroupData({
			pubRsaKey: null,
			groupEncPrivRsaKey: null,
			pubEccKey: keyPair.eccKeyPair.publicKey,
			groupEncPrivEccKey: this.cryptoWrapper.encryptEccKey(groupKey, keyPair.eccKeyPair.privateKey),
			pubKyberKey: this.cryptoWrapper.kyberPublicKeyToBytes(keyPair.kyberKeyPair.publicKey),
			groupEncPrivKyberKey: this.cryptoWrapper.encryptKyberKey(groupKey, keyPair.kyberKeyPair.privateKey),
			adminGroup: adminGroupId,
			adminEncGroupKey: adminEncGroupKey.key,
			ownerEncGroupInfoSessionKey: ownerEncGroupInfoSessionKey.key,
			adminKeyVersion: adminEncGroupKey.encryptingKeyVersion.toString(),
			ownerKeyVersion: ownerEncGroupInfoSessionKey.encryptingKeyVersion.toString()
		});
	}
	async addUserToGroup(user, groupId) {
		const userGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(user.userGroup.group);
		const groupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId);
		const symEncGKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object);
		const data = createMembershipAddData({
			user: user._id,
			group: groupId,
			symEncGKey: symEncGKey.key,
			groupKeyVersion: String(groupKey.version),
			symKeyVersion: symEncGKey.encryptingKeyVersion.toString()
		});
		await this.serviceExecutor.post(MembershipService, data);
	}
	async removeUserFromGroup(userId, groupId) {
		const data = createMembershipRemoveData({
			user: userId,
			group: groupId
		});
		await this.serviceExecutor.delete(MembershipService, data);
	}
	async deactivateGroup(group, restore) {
		const data = createDeleteGroupData({
			group: group._id,
			restore
		});
		if (group.type === GroupType.Mail) await this.serviceExecutor.delete(MailGroupService, data);
else throw new Error("invalid group type for deactivation");
	}
	async getGroupKeyViaUser(groupId, version, viaUser) {
		const currentGroupKey = await this.getCurrentGroupKeyViaUser(groupId, viaUser);
		return this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey);
	}
	/**
	* Get a group key for any group we are admin and know some member of.
	*
	* Unlike {@link getCurrentGroupKeyViaAdminEncGKey} this should work for any group because we will actually go a "long" route of decrypting userGroupKey of the
	* member and decrypting group key with that.
	*/
	async getCurrentGroupKeyViaUser(groupId, viaUser) {
		const user = await this.entityClient.load(UserTypeRef, viaUser);
		const membership = user.memberships.find((m) => m.group === groupId);
		if (membership == null) throw new Error(`User doesn't have this group membership! User: ${viaUser} groupId: ${groupId}`);
		const requiredUserGroupKeyVersion = membership.symKeyVersion;
		const requiredUserGroupKey = await this.getGroupKeyViaAdminEncGKey(user.userGroup.group, Number(requiredUserGroupKeyVersion));
		const key = this.cryptoWrapper.decryptKey(requiredUserGroupKey, membership.symEncGKey);
		const version = Number(membership.groupKeyVersion);
		return {
			object: key,
			version
		};
	}
	async getGroupKeyViaAdminEncGKey(groupId, version) {
		if (this.userFacade.hasGroup(groupId)) return this.keyLoaderFacade.loadSymGroupKey(groupId, version);
else {
			const currentGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId);
			return this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey);
		}
	}
	/**
	* @returns true if the group currently has an adminEncGKey. This may be an asymmetrically encrypted one.
	*/
	hasAdminEncGKey(group) {
		return group.adminGroupEncGKey != null && group.adminGroupEncGKey.length !== 0 || group.pubAdminGroupEncGKey != null;
	}
	/**
	* Get a group key for certain group types.
	*
	* Some groups (e.g. user groups or shared mailboxes) have adminGroupEncGKey set on creation. For those groups we can fairly easily get a group key without
	* decrypting userGroupKey of some member of that group.
	*/
	async getCurrentGroupKeyViaAdminEncGKey(groupId) {
		if (this.userFacade.hasGroup(groupId)) return this.keyLoaderFacade.getCurrentSymGroupKey(groupId);
else {
			const group = await this.cacheManagementFacade.reloadGroup(groupId);
			if (!this.hasAdminEncGKey(group)) throw new ProgrammingError("Group doesn't have adminGroupEncGKey, you can't get group key this way");
			if (!(group.admin && this.userFacade.hasGroup(group.admin))) throw new Error(`The user is not a member of the admin group ${group.admin} when trying to get the group key for group ${groupId}`);
			const requiredAdminKeyVersion = Number(group.adminGroupKeyVersion ?? 0);
			if (group.adminGroupEncGKey != null) return await this.decryptViaSymmetricAdminGKey(group, requiredAdminKeyVersion);
else return await this.decryptViaAsymmetricAdminGKey(group, requiredAdminKeyVersion);
		}
	}
	async decryptViaSymmetricAdminGKey(group, requiredAdminKeyVersion) {
		const requiredAdminGroupKey = await this.keyLoaderFacade.loadSymGroupKey(assertNotNull(group.admin), requiredAdminKeyVersion);
		const decryptedKey = this.cryptoWrapper.decryptKey(requiredAdminGroupKey, assertNotNull(group.adminGroupEncGKey));
		return {
			object: decryptedKey,
			version: Number(group.groupKeyVersion)
		};
	}
	async decryptViaAsymmetricAdminGKey(group, requiredAdminKeyVersion) {
		const requiredAdminGroupKeyPair = await this.keyLoaderFacade.loadKeypair(assertNotNull(group.admin), requiredAdminKeyVersion);
		const pubEncKeyData = assertNotNull(group.pubAdminGroupEncGKey);
		const decryptedKey = await this.asymmetricCryptoFacade.decryptSymKeyWithKeyPairAndAuthenticate(requiredAdminGroupKeyPair, pubEncKeyData, {
			identifier: group._id,
			identifierType: PublicKeyIdentifierType.GROUP_ID
		});
		return {
			object: decryptedKey.decryptedAesKey,
			version: Number(group.groupKeyVersion)
		};
	}
	/**
	* Context: removal of local admins
	* Problem: local admins encrypted the user group key of their users with their admin group key but global admin can't
	* decrypt these with their admin group key.
	* We want the global admin to still be able to decrypt user data.
	*
	* This function will decrypt the user group key with the local admin group key and then encrypt it with the global admin group key
	* Please note that this function is free of side effects, it only returns a new reference of the newly modified group.
	*
	* @param globalAdminGroupKey the key of the global admin that will encrypt the user group key
	* @param localAdminGroupKey the key of the local admin that was used to encrypt the user group key and will be used to decrypt the user group key
	* @param userGroup the user group that needs its adminEncGroupKey to be replaced
	*/
	async replaceLocalAdminEncGroupKeyWithGlobalAdminEncGroupKey(globalAdminGroupKey, localAdminGroupKey, userGroup) {
		const localAdminEncUserGroupKey = assertNotNull(userGroup.adminGroupEncGKey);
		const decryptedUserGroupKey = this.cryptoWrapper.decryptKey(localAdminGroupKey, localAdminEncUserGroupKey);
		const globalAdminEncUserGroupKey = this.cryptoWrapper.encryptKey(globalAdminGroupKey.object, decryptedUserGroupKey);
		const groupUpdate = createLocalAdminGroupReplacementData({
			adminGroupKeyVersion: String(globalAdminGroupKey.version),
			adminGroupEncGKey: globalAdminEncUserGroupKey,
			groupId: userGroup._id,
			groupKeyVersion: userGroup.groupKeyVersion
		});
		return groupUpdate;
	}
	/**
	* Since local admins won't be supported anymore and will be removed we need to let the
	* global admin access the locally administrated group data.
	* As its name suggest this function migrate the users administrated by the local admins
	* to the global admin of the customer so that the global admin can have direct
	* encryption and decryption of its users group keys.
	*/
	async migrateLocalAdminsToGlobalAdmins() {
		const user = this.userFacade.getLoggedInUser();
		if (!isGlobalAdmin(user)) return;
		const customer = await this.entityClient.load(CustomerTypeRef, assertNotNull(user.customer));
		const teamGroupInfos = await this.entityClient.loadAll(GroupInfoTypeRef, customer.teamGroups);
		const localAdminGroupInfos = teamGroupInfos.filter((group) => group.groupType === GroupType.LocalAdmin);
		const adminGroupId = customer.adminGroup;
		const adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		const postIn = createLocalAdminRemovalPostIn({ groupUpdates: [] });
		for (let localAdminGroupInfo of localAdminGroupInfos) {
			const localAdminGroup = await this.entityClient.load(GroupTypeRef, localAdminGroupInfo.group);
			const administratedGroupsListId = localAdminGroup.administratedGroups?.items;
			if (administratedGroupsListId == null) return null;
			const administratedGroups = await this.entityClient.loadAll(AdministratedGroupTypeRef, administratedGroupsListId);
			const thisLocalAdminGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(localAdminGroup._id);
			for (let ag of administratedGroups) {
				const thisRelatedGroupInfo = await this.entityClient.load(GroupInfoTypeRef, ag.groupInfo);
				const thisRelatedGroup = await this.entityClient.load(GroupTypeRef, thisRelatedGroupInfo.group);
				const groupUpdate = await this.replaceLocalAdminEncGroupKeyWithGlobalAdminEncGroupKey(adminGroupKey, thisLocalAdminGroupKey.object, thisRelatedGroup);
				postIn.groupUpdates.push(groupUpdate);
			}
		}
		if (isNotEmpty(postIn.groupUpdates)) await this.serviceExecutor.post(LocalAdminRemovalService, postIn);
	}
};

//#endregion
export { GroupManagementFacade };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JvdXBNYW5hZ2VtZW50RmFjYWRlLWNodW5rLmpzIiwibmFtZXMiOlsidXNlckZhY2FkZTogVXNlckZhY2FkZSIsImNvdW50ZXJzOiBDb3VudGVyRmFjYWRlIiwiZW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQiLCJzZXJ2aWNlRXhlY3V0b3I6IElTZXJ2aWNlRXhlY3V0b3IiLCJwcUZhY2FkZTogUFFGYWNhZGUiLCJrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSIsImNhY2hlTWFuYWdlbWVudEZhY2FkZTogQ2FjaGVNYW5hZ2VtZW50RmFjYWRlIiwiYXN5bW1ldHJpY0NyeXB0b0ZhY2FkZTogQXN5bW1ldHJpY0NyeXB0b0ZhY2FkZSIsImNyeXB0b1dyYXBwZXI6IENyeXB0b1dyYXBwZXIiLCJncm91cDogR3JvdXAiLCJuYW1lOiBzdHJpbmciLCJtYWlsQWRkcmVzczogc3RyaW5nIiwiYWRtaW5Hcm91cEtleTogVmVyc2lvbmVkS2V5IHwgbnVsbCIsImdyb3VwUm9vdDogQ29udGFjdExpc3RHcm91cFJvb3QiLCJrZXlQYWlyOiBQUUtleVBhaXJzIiwiZ3JvdXBLZXk6IEFlc0tleSIsImdyb3VwSW5mb1Nlc3Npb25LZXk6IEFlc0tleSIsImFkbWluR3JvdXBJZDogSWQgfCBudWxsIiwiYWRtaW5Hcm91cEtleTogVmVyc2lvbmVkS2V5Iiwib3duZXJHcm91cEtleTogVmVyc2lvbmVkS2V5IiwidXNlcjogVXNlciIsImdyb3VwSWQ6IElkIiwidXNlcklkOiBJZCIsInJlc3RvcmU6IGJvb2xlYW4iLCJ2ZXJzaW9uOiBudW1iZXIiLCJ2aWFVc2VyOiBJZCIsInJlcXVpcmVkQWRtaW5LZXlWZXJzaW9uOiBudW1iZXIiLCJnbG9iYWxBZG1pbkdyb3VwS2V5OiBWZXJzaW9uZWRLZXkiLCJsb2NhbEFkbWluR3JvdXBLZXk6IEFlc0tleSIsInVzZXJHcm91cDogR3JvdXAiLCJhZG1pbkdyb3VwSWQ6IElkIiwiYWRtaW5pc3RyYXRlZEdyb3VwczogQXJyYXk8QWRtaW5pc3RyYXRlZEdyb3VwPiJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vYXBpL3dvcmtlci9mYWNhZGVzL2xhenkvR3JvdXBNYW5hZ2VtZW50RmFjYWRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvdW50ZXJUeXBlLCBHcm91cFR5cGUsIFB1YmxpY0tleUlkZW50aWZpZXJUeXBlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9UdXRhbm90YUNvbnN0YW50cy5qc1wiXG5pbXBvcnQgdHlwZSB7IENvbnRhY3RMaXN0R3JvdXBSb290LCBJbnRlcm5hbEdyb3VwRGF0YSwgVXNlckFyZWFHcm91cERhdGEgfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvdHV0YW5vdGEvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHtcblx0Y3JlYXRlQ3JlYXRlTWFpbEdyb3VwRGF0YSxcblx0Y3JlYXRlRGVsZXRlR3JvdXBEYXRhLFxuXHRjcmVhdGVJbnRlcm5hbEdyb3VwRGF0YSxcblx0Y3JlYXRlVXNlckFyZWFHcm91cERhdGEsXG5cdGNyZWF0ZVVzZXJBcmVhR3JvdXBEZWxldGVEYXRhLFxuXHRjcmVhdGVVc2VyQXJlYUdyb3VwUG9zdERhdGEsXG59IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy90dXRhbm90YS9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBhc3NlcnROb3ROdWxsLCBmcmVzaFZlcnNpb25lZCwgZ2V0Rmlyc3RPclRocm93LCBpc05vdEVtcHR5LCBuZXZlck51bGwgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzXCJcbmltcG9ydCB7XG5cdEFkbWluaXN0cmF0ZWRHcm91cCxcblx0QWRtaW5pc3RyYXRlZEdyb3VwVHlwZVJlZixcblx0Y3JlYXRlTG9jYWxBZG1pbkdyb3VwUmVwbGFjZW1lbnREYXRhLFxuXHRjcmVhdGVMb2NhbEFkbWluUmVtb3ZhbFBvc3RJbixcblx0Y3JlYXRlTWVtYmVyc2hpcEFkZERhdGEsXG5cdGNyZWF0ZU1lbWJlcnNoaXBSZW1vdmVEYXRhLFxuXHRDdXN0b21lclR5cGVSZWYsXG5cdEdyb3VwLFxuXHRHcm91cEluZm9UeXBlUmVmLFxuXHRHcm91cFR5cGVSZWYsXG5cdExvY2FsQWRtaW5Hcm91cFJlcGxhY2VtZW50RGF0YSxcblx0VXNlcixcblx0VXNlclR5cGVSZWYsXG59IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgQ291bnRlckZhY2FkZSB9IGZyb20gXCIuL0NvdW50ZXJGYWNhZGUuanNcIlxuaW1wb3J0IHsgRW50aXR5Q2xpZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9FbnRpdHlDbGllbnQuanNcIlxuaW1wb3J0IHsgYXNzZXJ0V29ya2VyT3JOb2RlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9FbnYuanNcIlxuaW1wb3J0IHsgSVNlcnZpY2VFeGVjdXRvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vU2VydmljZVJlcXVlc3QuanNcIlxuaW1wb3J0IHsgQ2FsZW5kYXJTZXJ2aWNlLCBDb250YWN0TGlzdEdyb3VwU2VydmljZSwgTWFpbEdyb3VwU2VydmljZSwgVGVtcGxhdGVHcm91cFNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvdHV0YW5vdGEvU2VydmljZXMuanNcIlxuaW1wb3J0IHsgTG9jYWxBZG1pblJlbW92YWxTZXJ2aWNlLCBNZW1iZXJzaGlwU2VydmljZSB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvU2VydmljZXMuanNcIlxuaW1wb3J0IHsgVXNlckZhY2FkZSB9IGZyb20gXCIuLi9Vc2VyRmFjYWRlLmpzXCJcbmltcG9ydCB7IFByb2dyYW1taW5nRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2Vycm9yL1Byb2dyYW1taW5nRXJyb3IuanNcIlxuaW1wb3J0IHsgUFFGYWNhZGUgfSBmcm9tIFwiLi4vUFFGYWNhZGUuanNcIlxuaW1wb3J0IHsgS2V5TG9hZGVyRmFjYWRlIH0gZnJvbSBcIi4uL0tleUxvYWRlckZhY2FkZS5qc1wiXG5pbXBvcnQgeyBDYWNoZU1hbmFnZW1lbnRGYWNhZGUgfSBmcm9tIFwiLi9DYWNoZU1hbmFnZW1lbnRGYWNhZGUuanNcIlxuaW1wb3J0IHsgQ3J5cHRvV3JhcHBlciwgZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXksIGVuY3J5cHRTdHJpbmcsIFZlcnNpb25lZEtleSB9IGZyb20gXCIuLi8uLi9jcnlwdG8vQ3J5cHRvV3JhcHBlci5qc1wiXG5pbXBvcnQgeyBBc3ltbWV0cmljQ3J5cHRvRmFjYWRlIH0gZnJvbSBcIi4uLy4uL2NyeXB0by9Bc3ltbWV0cmljQ3J5cHRvRmFjYWRlLmpzXCJcbmltcG9ydCB7IEFlc0tleSwgUFFLZXlQYWlycyB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtY3J5cHRvXCJcbmltcG9ydCB7IGlzR2xvYmFsQWRtaW4gfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3V0aWxzL1VzZXJVdGlscy5qc1wiXG5cbmFzc2VydFdvcmtlck9yTm9kZSgpXG5cbmV4cG9ydCBjbGFzcyBHcm91cE1hbmFnZW1lbnRGYWNhZGUge1xuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIHJlYWRvbmx5IHVzZXJGYWNhZGU6IFVzZXJGYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjb3VudGVyczogQ291bnRlckZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGVudGl0eUNsaWVudDogRW50aXR5Q2xpZW50LFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgc2VydmljZUV4ZWN1dG9yOiBJU2VydmljZUV4ZWN1dG9yLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgcHFGYWNhZGU6IFBRRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkga2V5TG9hZGVyRmFjYWRlOiBLZXlMb2FkZXJGYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjYWNoZU1hbmFnZW1lbnRGYWNhZGU6IENhY2hlTWFuYWdlbWVudEZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGFzeW1tZXRyaWNDcnlwdG9GYWNhZGU6IEFzeW1tZXRyaWNDcnlwdG9GYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjcnlwdG9XcmFwcGVyOiBDcnlwdG9XcmFwcGVyLFxuXHQpIHt9XG5cblx0YXN5bmMgcmVhZFVzZWRTaGFyZWRNYWlsR3JvdXBTdG9yYWdlKGdyb3VwOiBHcm91cCk6IFByb21pc2U8bnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuY291bnRlcnMucmVhZENvdW50ZXJWYWx1ZShDb3VudGVyVHlwZS5Vc2VyU3RvcmFnZUxlZ2FjeSwgbmV2ZXJOdWxsKGdyb3VwLmN1c3RvbWVyKSwgZ3JvdXAuX2lkKVxuXHR9XG5cblx0YXN5bmMgY3JlYXRlTWFpbEdyb3VwKG5hbWU6IHN0cmluZywgbWFpbEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGFkbWluR3JvdXBJZHMgPSB0aGlzLnVzZXJGYWNhZGUuZ2V0R3JvdXBJZHMoR3JvdXBUeXBlLkFkbWluKVxuXHRcdGNvbnN0IGFkbWluR3JvdXBJZCA9IGdldEZpcnN0T3JUaHJvdyhhZG1pbkdyb3VwSWRzKVxuXG5cdFx0bGV0IGFkbWluR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmtleUxvYWRlckZhY2FkZS5nZXRDdXJyZW50U3ltR3JvdXBLZXkoYWRtaW5Hcm91cElkKVxuXHRcdGxldCBjdXN0b21lckdyb3VwS2V5ID0gYXdhaXQgdGhpcy5rZXlMb2FkZXJGYWNhZGUuZ2V0Q3VycmVudFN5bUdyb3VwS2V5KHRoaXMudXNlckZhY2FkZS5nZXRHcm91cElkKEdyb3VwVHlwZS5DdXN0b21lcikpXG5cdFx0bGV0IG1haWxHcm91cEtleSA9IGZyZXNoVmVyc2lvbmVkKHRoaXMuY3J5cHRvV3JhcHBlci5hZXMyNTZSYW5kb21LZXkoKSlcblxuXHRcdGxldCBtYWlsR3JvdXBJbmZvU2Vzc2lvbktleSA9IHRoaXMuY3J5cHRvV3JhcHBlci5hZXMyNTZSYW5kb21LZXkoKVxuXHRcdGxldCBtYWlsYm94U2Vzc2lvbktleSA9IHRoaXMuY3J5cHRvV3JhcHBlci5hZXMyNTZSYW5kb21LZXkoKVxuXHRcdGNvbnN0IGtleVBhaXIgPSBhd2FpdCB0aGlzLnBxRmFjYWRlLmdlbmVyYXRlS2V5UGFpcnMoKVxuXHRcdGNvbnN0IG1haWxHcm91cERhdGEgPSB0aGlzLmdlbmVyYXRlSW50ZXJuYWxHcm91cERhdGEoXG5cdFx0XHRrZXlQYWlyLFxuXHRcdFx0bWFpbEdyb3VwS2V5Lm9iamVjdCxcblx0XHRcdG1haWxHcm91cEluZm9TZXNzaW9uS2V5LFxuXHRcdFx0YWRtaW5Hcm91cElkLFxuXHRcdFx0YWRtaW5Hcm91cEtleSxcblx0XHRcdGN1c3RvbWVyR3JvdXBLZXksXG5cdFx0KVxuXG5cdFx0Y29uc3QgbWFpbEVuY01haWxib3hTZXNzaW9uS2V5ID0gZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXkobWFpbEdyb3VwS2V5LCBtYWlsYm94U2Vzc2lvbktleSlcblxuXHRcdGNvbnN0IGRhdGEgPSBjcmVhdGVDcmVhdGVNYWlsR3JvdXBEYXRhKHtcblx0XHRcdG1haWxBZGRyZXNzLFxuXHRcdFx0ZW5jcnlwdGVkTmFtZTogZW5jcnlwdFN0cmluZyhtYWlsR3JvdXBJbmZvU2Vzc2lvbktleSwgbmFtZSksXG5cdFx0XHRtYWlsRW5jTWFpbGJveFNlc3Npb25LZXk6IG1haWxFbmNNYWlsYm94U2Vzc2lvbktleS5rZXksXG5cdFx0XHRncm91cERhdGE6IG1haWxHcm91cERhdGEsXG5cdFx0fSlcblx0XHRhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5wb3N0KE1haWxHcm91cFNlcnZpY2UsIGRhdGEpXG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGtleXMgZm9yIHRoZSBuZXcgZ3JvdXAgYW5kIHByZXBhcmVzIHRoZSBncm91cCBkYXRhIG9iamVjdCB0byBjcmVhdGUgdGhlIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBncm91cFxuXHQgKi9cblx0YXN5bmMgZ2VuZXJhdGVVc2VyQXJlYUdyb3VwRGF0YShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJBcmVhR3JvdXBEYXRhPiB7XG5cdFx0Ly8gYWRtaW5Hcm91cCBJcyBub3Qgc2V0IHdoZW4gZ2VuZXJhdGluZyBuZXcgY3VzdG9tZXIsIHRoZW4gdGhlIGFkbWluIGdyb3VwIHdpbGwgYmUgdGhlIGFkbWluIG9mIHRoZSBjdXN0b21lclxuXHRcdC8vIGFkbWluR3JvdXBLZXkgSXMgbm90IHNldCB3aGVuIGdlbmVyYXRpbmcgY2FsZW5kYXIgYXMgbm9ybWFsIHVzZXJcblx0XHRjb25zdCB1c2VyR3JvdXAgPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKEdyb3VwVHlwZVJlZiwgdGhpcy51c2VyRmFjYWRlLmdldFVzZXJHcm91cElkKCkpXG5cdFx0Y29uc3QgYWRtaW5Hcm91cElkID0gbmV2ZXJOdWxsKHVzZXJHcm91cC5hZG1pbikgLy8gdXNlciBncm91cCBoYXMgYWx3YXlzIGFkbWluIGdyb3VwXG5cblx0XHRsZXQgYWRtaW5Hcm91cEtleTogVmVyc2lvbmVkS2V5IHwgbnVsbCA9IG51bGxcblxuXHRcdGlmICh0aGlzLnVzZXJGYWNhZGUuZ2V0QWxsR3JvdXBJZHMoKS5pbmRleE9mKGFkbWluR3JvdXBJZCkgIT09IC0xKSB7XG5cdFx0XHQvLyBnZXRHcm91cEtleSB0aHJvd3MgYW4gZXJyb3IgaWYgdXNlciBpcyBub3QgbWVtYmVyIG9mIHRoYXQgZ3JvdXAgLSBzbyBjaGVjayBmaXJzdFxuXHRcdFx0YWRtaW5Hcm91cEtleSA9IGF3YWl0IHRoaXMua2V5TG9hZGVyRmFjYWRlLmdldEN1cnJlbnRTeW1Hcm91cEtleShhZG1pbkdyb3VwSWQpXG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VzdG9tZXJHcm91cElkID0gdGhpcy51c2VyRmFjYWRlLmdldEdyb3VwSWQoR3JvdXBUeXBlLkN1c3RvbWVyKVxuXHRcdGNvbnN0IGN1c3RvbWVyR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmtleUxvYWRlckZhY2FkZS5nZXRDdXJyZW50U3ltR3JvdXBLZXkoY3VzdG9tZXJHcm91cElkKVxuXHRcdGNvbnN0IHVzZXJHcm91cEtleSA9IHRoaXMudXNlckZhY2FkZS5nZXRDdXJyZW50VXNlckdyb3VwS2V5KClcblx0XHRjb25zdCBncm91cEtleSA9IGZyZXNoVmVyc2lvbmVkKHRoaXMuY3J5cHRvV3JhcHBlci5hZXMyNTZSYW5kb21LZXkoKSlcblxuXHRcdGNvbnN0IGdyb3VwUm9vdFNlc3Npb25LZXkgPSB0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KClcblx0XHRjb25zdCBncm91cEluZm9TZXNzaW9uS2V5ID0gdGhpcy5jcnlwdG9XcmFwcGVyLmFlczI1NlJhbmRvbUtleSgpXG5cblx0XHRjb25zdCB1c2VyRW5jR3JvdXBLZXkgPSBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleSh1c2VyR3JvdXBLZXksIGdyb3VwS2V5Lm9iamVjdClcblx0XHRjb25zdCBhZG1pbkVuY0dyb3VwS2V5ID0gYWRtaW5Hcm91cEtleSA/IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KGFkbWluR3JvdXBLZXksIGdyb3VwS2V5Lm9iamVjdCkgOiBudWxsXG5cdFx0Y29uc3QgY3VzdG9tZXJFbmNHcm91cEluZm9TZXNzaW9uS2V5ID0gZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXkoY3VzdG9tZXJHcm91cEtleSwgZ3JvdXBJbmZvU2Vzc2lvbktleSlcblx0XHRjb25zdCBncm91cEVuY0dyb3VwUm9vdFNlc3Npb25LZXkgPSBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleShncm91cEtleSwgZ3JvdXBSb290U2Vzc2lvbktleSlcblxuXHRcdHJldHVybiBjcmVhdGVVc2VyQXJlYUdyb3VwRGF0YSh7XG5cdFx0XHRncm91cEVuY0dyb3VwUm9vdFNlc3Npb25LZXk6IGdyb3VwRW5jR3JvdXBSb290U2Vzc2lvbktleS5rZXksXG5cdFx0XHRjdXN0b21lckVuY0dyb3VwSW5mb1Nlc3Npb25LZXk6IGN1c3RvbWVyRW5jR3JvdXBJbmZvU2Vzc2lvbktleS5rZXksXG5cdFx0XHR1c2VyRW5jR3JvdXBLZXk6IHVzZXJFbmNHcm91cEtleS5rZXksXG5cdFx0XHRncm91cEluZm9FbmNOYW1lOiBlbmNyeXB0U3RyaW5nKGdyb3VwSW5mb1Nlc3Npb25LZXksIG5hbWUpLFxuXHRcdFx0YWRtaW5FbmNHcm91cEtleTogYWRtaW5FbmNHcm91cEtleT8ua2V5ID8/IG51bGwsXG5cdFx0XHRhZG1pbkdyb3VwOiBhZG1pbkdyb3VwSWQsXG5cdFx0XHRjdXN0b21lcktleVZlcnNpb246IGN1c3RvbWVyRW5jR3JvdXBJbmZvU2Vzc2lvbktleS5lbmNyeXB0aW5nS2V5VmVyc2lvbi50b1N0cmluZygpLFxuXHRcdFx0dXNlcktleVZlcnNpb246IHVzZXJHcm91cEtleS52ZXJzaW9uLnRvU3RyaW5nKCksXG5cdFx0XHRhZG1pbktleVZlcnNpb246IGFkbWluRW5jR3JvdXBLZXk/LmVuY3J5cHRpbmdLZXlWZXJzaW9uLnRvU3RyaW5nKCkgPz8gbnVsbCxcblx0XHR9KVxuXHR9XG5cblx0YXN5bmMgY3JlYXRlQ2FsZW5kYXIobmFtZTogc3RyaW5nKTogUHJvbWlzZTx7IHVzZXI6IFVzZXI7IGdyb3VwOiBHcm91cCB9PiB7XG5cdFx0Y29uc3QgZ3JvdXBEYXRhID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVVzZXJBcmVhR3JvdXBEYXRhKG5hbWUpXG5cdFx0Y29uc3QgcG9zdERhdGEgPSBjcmVhdGVVc2VyQXJlYUdyb3VwUG9zdERhdGEoe1xuXHRcdFx0Z3JvdXBEYXRhLFxuXHRcdH0pXG5cdFx0Y29uc3QgcG9zdEdyb3VwRGF0YSA9IGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoQ2FsZW5kYXJTZXJ2aWNlLCBwb3N0RGF0YSwgeyBzZXNzaW9uS2V5OiB0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KCkgfSkgLy8gd2UgZXhwZWN0IGEgc2Vzc2lvbiBrZXkgdG8gYmUgZGVmaW5lZCBhcyB0aGUgZW50aXR5IGlzIG1hcmtlZCBlbmNyeXB0ZWRcblx0XHRjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoR3JvdXBUeXBlUmVmLCBwb3N0R3JvdXBEYXRhLmdyb3VwKVxuXHRcdGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlbWVudEZhY2FkZS5yZWxvYWRVc2VyKClcblxuXHRcdHJldHVybiB7IHVzZXIsIGdyb3VwIH1cblx0fVxuXG5cdGFzeW5jIGNyZWF0ZVRlbXBsYXRlR3JvdXAobmFtZTogc3RyaW5nKTogUHJvbWlzZTxJZD4ge1xuXHRcdGNvbnN0IGdyb3VwRGF0YSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVVc2VyQXJlYUdyb3VwRGF0YShuYW1lKVxuXHRcdGNvbnN0IHNlcnZpY2VEYXRhID0gY3JlYXRlVXNlckFyZWFHcm91cFBvc3REYXRhKHtcblx0XHRcdGdyb3VwRGF0YSxcblx0XHR9KVxuXG5cdFx0Y29uc3QgcG9zdEdyb3VwRGF0YSA9IGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoVGVtcGxhdGVHcm91cFNlcnZpY2UsIHNlcnZpY2VEYXRhLCB7IHNlc3Npb25LZXk6IHRoaXMuY3J5cHRvV3JhcHBlci5hZXMyNTZSYW5kb21LZXkoKSB9KSAvLyB3ZSBleHBlY3QgYSBzZXNzaW9uIGtleSB0byBiZSBkZWZpbmVkIGFzIHRoZSBlbnRpdHkgaXMgbWFya2VkIGVuY3J5cHRlZFxuXG5cdFx0YXdhaXQgdGhpcy5jYWNoZU1hbmFnZW1lbnRGYWNhZGUucmVsb2FkVXNlcigpXG5cblx0XHRyZXR1cm4gcG9zdEdyb3VwRGF0YS5ncm91cFxuXHR9XG5cblx0YXN5bmMgY3JlYXRlQ29udGFjdExpc3RHcm91cChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPEdyb3VwPiB7XG5cdFx0Y29uc3QgZ3JvdXBEYXRhID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVVzZXJBcmVhR3JvdXBEYXRhKG5hbWUpXG5cdFx0Y29uc3Qgc2VydmljZURhdGEgPSBjcmVhdGVVc2VyQXJlYUdyb3VwUG9zdERhdGEoe1xuXHRcdFx0Z3JvdXBEYXRhLFxuXHRcdH0pXG5cdFx0Y29uc3QgcG9zdEdyb3VwRGF0YSA9IGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoQ29udGFjdExpc3RHcm91cFNlcnZpY2UsIHNlcnZpY2VEYXRhLCB7IHNlc3Npb25LZXk6IHRoaXMuY3J5cHRvV3JhcHBlci5hZXMyNTZSYW5kb21LZXkoKSB9KSAvLyB3ZSBleHBlY3QgYSBzZXNzaW9uIGtleSB0byBiZSBkZWZpbmVkIGFzIHRoZSBlbnRpdHkgaXMgbWFya2VkIGVuY3J5cHRlZFxuXHRcdGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChHcm91cFR5cGVSZWYsIHBvc3RHcm91cERhdGEuZ3JvdXApXG5cdFx0YXdhaXQgdGhpcy5jYWNoZU1hbmFnZW1lbnRGYWNhZGUucmVsb2FkVXNlcigpXG5cblx0XHRyZXR1cm4gZ3JvdXBcblx0fVxuXG5cdGFzeW5jIGRlbGV0ZUNvbnRhY3RMaXN0R3JvdXAoZ3JvdXBSb290OiBDb250YWN0TGlzdEdyb3VwUm9vdCkge1xuXHRcdGNvbnN0IHNlcnZpY2VEYXRhID0gY3JlYXRlVXNlckFyZWFHcm91cERlbGV0ZURhdGEoe1xuXHRcdFx0Z3JvdXA6IGdyb3VwUm9vdC5faWQsXG5cdFx0fSlcblx0XHRhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5kZWxldGUoQ29udGFjdExpc3RHcm91cFNlcnZpY2UsIHNlcnZpY2VEYXRhKVxuXHR9XG5cblx0LyoqXG5cdCAqIEFzc2VtYmxlIHRoZSBkYXRhIHRyYW5zZmVyIHR5cGUgdG8gY3JlYXRlIGEgbmV3IGludGVybmFsIGdyb3VwIG9uIHRoZSBzZXJ2ZXIuXG5cdCAqIFRoZSBncm91cCBrZXkgdmVyc2lvbiBpcyBub3QgbmVlZGVkIGJlY2F1c2UgaXQgaXMgYWx3YXlzIHplcm8uXG5cdCAqL1xuXHRnZW5lcmF0ZUludGVybmFsR3JvdXBEYXRhKFxuXHRcdGtleVBhaXI6IFBRS2V5UGFpcnMsXG5cdFx0Z3JvdXBLZXk6IEFlc0tleSxcblx0XHRncm91cEluZm9TZXNzaW9uS2V5OiBBZXNLZXksXG5cdFx0YWRtaW5Hcm91cElkOiBJZCB8IG51bGwsXG5cdFx0YWRtaW5Hcm91cEtleTogVmVyc2lvbmVkS2V5LFxuXHRcdG93bmVyR3JvdXBLZXk6IFZlcnNpb25lZEtleSxcblx0KTogSW50ZXJuYWxHcm91cERhdGEge1xuXHRcdGNvbnN0IGFkbWluRW5jR3JvdXBLZXkgPSBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleShhZG1pbkdyb3VwS2V5LCBncm91cEtleSlcblx0XHRjb25zdCBvd25lckVuY0dyb3VwSW5mb1Nlc3Npb25LZXkgPSBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleShvd25lckdyb3VwS2V5LCBncm91cEluZm9TZXNzaW9uS2V5KVxuXG5cdFx0cmV0dXJuIGNyZWF0ZUludGVybmFsR3JvdXBEYXRhKHtcblx0XHRcdHB1YlJzYUtleTogbnVsbCxcblx0XHRcdGdyb3VwRW5jUHJpdlJzYUtleTogbnVsbCxcblx0XHRcdHB1YkVjY0tleToga2V5UGFpci5lY2NLZXlQYWlyLnB1YmxpY0tleSxcblx0XHRcdGdyb3VwRW5jUHJpdkVjY0tleTogdGhpcy5jcnlwdG9XcmFwcGVyLmVuY3J5cHRFY2NLZXkoZ3JvdXBLZXksIGtleVBhaXIuZWNjS2V5UGFpci5wcml2YXRlS2V5KSxcblx0XHRcdHB1Ykt5YmVyS2V5OiB0aGlzLmNyeXB0b1dyYXBwZXIua3liZXJQdWJsaWNLZXlUb0J5dGVzKGtleVBhaXIua3liZXJLZXlQYWlyLnB1YmxpY0tleSksXG5cdFx0XHRncm91cEVuY1ByaXZLeWJlcktleTogdGhpcy5jcnlwdG9XcmFwcGVyLmVuY3J5cHRLeWJlcktleShncm91cEtleSwga2V5UGFpci5reWJlcktleVBhaXIucHJpdmF0ZUtleSksXG5cdFx0XHRhZG1pbkdyb3VwOiBhZG1pbkdyb3VwSWQsXG5cdFx0XHRhZG1pbkVuY0dyb3VwS2V5OiBhZG1pbkVuY0dyb3VwS2V5LmtleSxcblx0XHRcdG93bmVyRW5jR3JvdXBJbmZvU2Vzc2lvbktleTogb3duZXJFbmNHcm91cEluZm9TZXNzaW9uS2V5LmtleSxcblx0XHRcdGFkbWluS2V5VmVyc2lvbjogYWRtaW5FbmNHcm91cEtleS5lbmNyeXB0aW5nS2V5VmVyc2lvbi50b1N0cmluZygpLFxuXHRcdFx0b3duZXJLZXlWZXJzaW9uOiBvd25lckVuY0dyb3VwSW5mb1Nlc3Npb25LZXkuZW5jcnlwdGluZ0tleVZlcnNpb24udG9TdHJpbmcoKSxcblx0XHR9KVxuXHR9XG5cblx0YXN5bmMgYWRkVXNlclRvR3JvdXAodXNlcjogVXNlciwgZ3JvdXBJZDogSWQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCB1c2VyR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRHcm91cEtleVZpYUFkbWluRW5jR0tleSh1c2VyLnVzZXJHcm91cC5ncm91cClcblx0XHRjb25zdCBncm91cEtleSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5KGdyb3VwSWQpXG5cdFx0Y29uc3Qgc3ltRW5jR0tleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KHVzZXJHcm91cEtleSwgZ3JvdXBLZXkub2JqZWN0KVxuXHRcdGNvbnN0IGRhdGEgPSBjcmVhdGVNZW1iZXJzaGlwQWRkRGF0YSh7XG5cdFx0XHR1c2VyOiB1c2VyLl9pZCxcblx0XHRcdGdyb3VwOiBncm91cElkLFxuXHRcdFx0c3ltRW5jR0tleTogc3ltRW5jR0tleS5rZXksXG5cdFx0XHRncm91cEtleVZlcnNpb246IFN0cmluZyhncm91cEtleS52ZXJzaW9uKSxcblx0XHRcdHN5bUtleVZlcnNpb246IHN5bUVuY0dLZXkuZW5jcnlwdGluZ0tleVZlcnNpb24udG9TdHJpbmcoKSxcblx0XHR9KVxuXHRcdGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoTWVtYmVyc2hpcFNlcnZpY2UsIGRhdGEpXG5cdH1cblxuXHRhc3luYyByZW1vdmVVc2VyRnJvbUdyb3VwKHVzZXJJZDogSWQsIGdyb3VwSWQ6IElkKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgZGF0YSA9IGNyZWF0ZU1lbWJlcnNoaXBSZW1vdmVEYXRhKHtcblx0XHRcdHVzZXI6IHVzZXJJZCxcblx0XHRcdGdyb3VwOiBncm91cElkLFxuXHRcdH0pXG5cdFx0YXdhaXQgdGhpcy5zZXJ2aWNlRXhlY3V0b3IuZGVsZXRlKE1lbWJlcnNoaXBTZXJ2aWNlLCBkYXRhKVxuXHR9XG5cblx0YXN5bmMgZGVhY3RpdmF0ZUdyb3VwKGdyb3VwOiBHcm91cCwgcmVzdG9yZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGRhdGEgPSBjcmVhdGVEZWxldGVHcm91cERhdGEoe1xuXHRcdFx0Z3JvdXA6IGdyb3VwLl9pZCxcblx0XHRcdHJlc3RvcmUsXG5cdFx0fSlcblxuXHRcdGlmIChncm91cC50eXBlID09PSBHcm91cFR5cGUuTWFpbCkge1xuXHRcdFx0YXdhaXQgdGhpcy5zZXJ2aWNlRXhlY3V0b3IuZGVsZXRlKE1haWxHcm91cFNlcnZpY2UsIGRhdGEpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZ3JvdXAgdHlwZSBmb3IgZGVhY3RpdmF0aW9uXCIpXG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgZ2V0R3JvdXBLZXlWaWFVc2VyKGdyb3VwSWQ6IElkLCB2ZXJzaW9uOiBudW1iZXIsIHZpYVVzZXI6IElkKTogUHJvbWlzZTxBZXNLZXk+IHtcblx0XHRjb25zdCBjdXJyZW50R3JvdXBLZXkgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRHcm91cEtleVZpYVVzZXIoZ3JvdXBJZCwgdmlhVXNlcilcblx0XHRyZXR1cm4gdGhpcy5rZXlMb2FkZXJGYWNhZGUubG9hZFN5bUdyb3VwS2V5KGdyb3VwSWQsIHZlcnNpb24sIGN1cnJlbnRHcm91cEtleSlcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYSBncm91cCBrZXkgZm9yIGFueSBncm91cCB3ZSBhcmUgYWRtaW4gYW5kIGtub3cgc29tZSBtZW1iZXIgb2YuXG5cdCAqXG5cdCAqIFVubGlrZSB7QGxpbmsgZ2V0Q3VycmVudEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5fSB0aGlzIHNob3VsZCB3b3JrIGZvciBhbnkgZ3JvdXAgYmVjYXVzZSB3ZSB3aWxsIGFjdHVhbGx5IGdvIGEgXCJsb25nXCIgcm91dGUgb2YgZGVjcnlwdGluZyB1c2VyR3JvdXBLZXkgb2YgdGhlXG5cdCAqIG1lbWJlciBhbmQgZGVjcnlwdGluZyBncm91cCBrZXkgd2l0aCB0aGF0LlxuXHQgKi9cblx0YXN5bmMgZ2V0Q3VycmVudEdyb3VwS2V5VmlhVXNlcihncm91cElkOiBJZCwgdmlhVXNlcjogSWQpOiBQcm9taXNlPFZlcnNpb25lZEtleT4ge1xuXHRcdGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKFVzZXJUeXBlUmVmLCB2aWFVc2VyKVxuXHRcdGNvbnN0IG1lbWJlcnNoaXAgPSB1c2VyLm1lbWJlcnNoaXBzLmZpbmQoKG0pID0+IG0uZ3JvdXAgPT09IGdyb3VwSWQpXG5cdFx0aWYgKG1lbWJlcnNoaXAgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVc2VyIGRvZXNuJ3QgaGF2ZSB0aGlzIGdyb3VwIG1lbWJlcnNoaXAhIFVzZXI6ICR7dmlhVXNlcn0gZ3JvdXBJZDogJHtncm91cElkfWApXG5cdFx0fVxuXHRcdGNvbnN0IHJlcXVpcmVkVXNlckdyb3VwS2V5VmVyc2lvbiA9IG1lbWJlcnNoaXAuc3ltS2V5VmVyc2lvblxuXHRcdGNvbnN0IHJlcXVpcmVkVXNlckdyb3VwS2V5ID0gYXdhaXQgdGhpcy5nZXRHcm91cEtleVZpYUFkbWluRW5jR0tleSh1c2VyLnVzZXJHcm91cC5ncm91cCwgTnVtYmVyKHJlcXVpcmVkVXNlckdyb3VwS2V5VmVyc2lvbikpXG5cblx0XHRjb25zdCBrZXkgPSB0aGlzLmNyeXB0b1dyYXBwZXIuZGVjcnlwdEtleShyZXF1aXJlZFVzZXJHcm91cEtleSwgbWVtYmVyc2hpcC5zeW1FbmNHS2V5KVxuXHRcdGNvbnN0IHZlcnNpb24gPSBOdW1iZXIobWVtYmVyc2hpcC5ncm91cEtleVZlcnNpb24pXG5cblx0XHRyZXR1cm4geyBvYmplY3Q6IGtleSwgdmVyc2lvbiB9XG5cdH1cblxuXHRhc3luYyBnZXRHcm91cEtleVZpYUFkbWluRW5jR0tleShncm91cElkOiBJZCwgdmVyc2lvbjogbnVtYmVyKTogUHJvbWlzZTxBZXNLZXk+IHtcblx0XHRpZiAodGhpcy51c2VyRmFjYWRlLmhhc0dyb3VwKGdyb3VwSWQpKSB7XG5cdFx0XHQvLyBlLmcuIEkgYW0gYSBnbG9iYWwgYWRtaW4gYW5kIHdhbnQgdG8gYWRkIGFub3RoZXIgdXNlciB0byB0aGUgZ2xvYmFsIGFkbWluIGdyb3VwXG5cdFx0XHRyZXR1cm4gdGhpcy5rZXlMb2FkZXJGYWNhZGUubG9hZFN5bUdyb3VwS2V5KGdyb3VwSWQsIHZlcnNpb24pXG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGN1cnJlbnRHcm91cEtleSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5KGdyb3VwSWQpXG5cdFx0XHRyZXR1cm4gdGhpcy5rZXlMb2FkZXJGYWNhZGUubG9hZFN5bUdyb3VwS2V5KGdyb3VwSWQsIHZlcnNpb24sIGN1cnJlbnRHcm91cEtleSlcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZ3JvdXAgY3VycmVudGx5IGhhcyBhbiBhZG1pbkVuY0dLZXkuIFRoaXMgbWF5IGJlIGFuIGFzeW1tZXRyaWNhbGx5IGVuY3J5cHRlZCBvbmUuXG5cdCAqL1xuXHRoYXNBZG1pbkVuY0dLZXkoZ3JvdXA6IEdyb3VwKSB7XG5cdFx0cmV0dXJuIChncm91cC5hZG1pbkdyb3VwRW5jR0tleSAhPSBudWxsICYmIGdyb3VwLmFkbWluR3JvdXBFbmNHS2V5Lmxlbmd0aCAhPT0gMCkgfHwgZ3JvdXAucHViQWRtaW5Hcm91cEVuY0dLZXkgIT0gbnVsbFxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhIGdyb3VwIGtleSBmb3IgY2VydGFpbiBncm91cCB0eXBlcy5cblx0ICpcblx0ICogU29tZSBncm91cHMgKGUuZy4gdXNlciBncm91cHMgb3Igc2hhcmVkIG1haWxib3hlcykgaGF2ZSBhZG1pbkdyb3VwRW5jR0tleSBzZXQgb24gY3JlYXRpb24uIEZvciB0aG9zZSBncm91cHMgd2UgY2FuIGZhaXJseSBlYXNpbHkgZ2V0IGEgZ3JvdXAga2V5IHdpdGhvdXRcblx0ICogZGVjcnlwdGluZyB1c2VyR3JvdXBLZXkgb2Ygc29tZSBtZW1iZXIgb2YgdGhhdCBncm91cC5cblx0ICovXG5cdGFzeW5jIGdldEN1cnJlbnRHcm91cEtleVZpYUFkbWluRW5jR0tleShncm91cElkOiBJZCk6IFByb21pc2U8VmVyc2lvbmVkS2V5PiB7XG5cdFx0aWYgKHRoaXMudXNlckZhY2FkZS5oYXNHcm91cChncm91cElkKSkge1xuXHRcdFx0Ly8gZS5nLiBJIGFtIGEgZ2xvYmFsIGFkbWluIGFuZCB3YW50IHRvIGFkZCBhbm90aGVyIHVzZXIgdG8gdGhlIGdsb2JhbCBhZG1pbiBncm91cFxuXHRcdFx0Ly8gb3IgSSBhbSBhbiBhZG1pbiBhbmQgSSBhbSBhIG1lbWJlciBvZiB0aGUgdGFyZ2V0IGdyb3VwIChlZzogc2hhcmVkIG1haWxib3hlcylcblx0XHRcdHJldHVybiB0aGlzLmtleUxvYWRlckZhY2FkZS5nZXRDdXJyZW50U3ltR3JvdXBLZXkoZ3JvdXBJZClcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlbWVudEZhY2FkZS5yZWxvYWRHcm91cChncm91cElkKVxuXHRcdFx0aWYgKCF0aGlzLmhhc0FkbWluRW5jR0tleShncm91cCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFByb2dyYW1taW5nRXJyb3IoXCJHcm91cCBkb2Vzbid0IGhhdmUgYWRtaW5Hcm91cEVuY0dLZXksIHlvdSBjYW4ndCBnZXQgZ3JvdXAga2V5IHRoaXMgd2F5XCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoIShncm91cC5hZG1pbiAmJiB0aGlzLnVzZXJGYWNhZGUuaGFzR3JvdXAoZ3JvdXAuYWRtaW4pKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSB1c2VyIGlzIG5vdCBhIG1lbWJlciBvZiB0aGUgYWRtaW4gZ3JvdXAgJHtncm91cC5hZG1pbn0gd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSBncm91cCBrZXkgZm9yIGdyb3VwICR7Z3JvdXBJZH1gKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlLmcuIEkgYW0gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIHRoYXQgYWRtaW5pc3RyYXRlcyBncm91cCBHIGFuZCB3YW50IHRvIGFkZCBhIG5ldyBtZW1iZXIgdG8gR1xuXHRcdFx0Y29uc3QgcmVxdWlyZWRBZG1pbktleVZlcnNpb24gPSBOdW1iZXIoZ3JvdXAuYWRtaW5Hcm91cEtleVZlcnNpb24gPz8gMClcblx0XHRcdGlmIChncm91cC5hZG1pbkdyb3VwRW5jR0tleSAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLmRlY3J5cHRWaWFTeW1tZXRyaWNBZG1pbkdLZXkoZ3JvdXAsIHJlcXVpcmVkQWRtaW5LZXlWZXJzaW9uKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMuZGVjcnlwdFZpYUFzeW1tZXRyaWNBZG1pbkdLZXkoZ3JvdXAsIHJlcXVpcmVkQWRtaW5LZXlWZXJzaW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZGVjcnlwdFZpYVN5bW1ldHJpY0FkbWluR0tleShncm91cDogR3JvdXAsIHJlcXVpcmVkQWRtaW5LZXlWZXJzaW9uOiBudW1iZXIpOiBQcm9taXNlPFZlcnNpb25lZEtleT4ge1xuXHRcdGNvbnN0IHJlcXVpcmVkQWRtaW5Hcm91cEtleSA9IGF3YWl0IHRoaXMua2V5TG9hZGVyRmFjYWRlLmxvYWRTeW1Hcm91cEtleShhc3NlcnROb3ROdWxsKGdyb3VwLmFkbWluKSwgcmVxdWlyZWRBZG1pbktleVZlcnNpb24pXG5cdFx0Y29uc3QgZGVjcnlwdGVkS2V5ID0gdGhpcy5jcnlwdG9XcmFwcGVyLmRlY3J5cHRLZXkocmVxdWlyZWRBZG1pbkdyb3VwS2V5LCBhc3NlcnROb3ROdWxsKGdyb3VwLmFkbWluR3JvdXBFbmNHS2V5KSlcblx0XHRyZXR1cm4geyBvYmplY3Q6IGRlY3J5cHRlZEtleSwgdmVyc2lvbjogTnVtYmVyKGdyb3VwLmdyb3VwS2V5VmVyc2lvbikgfVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBkZWNyeXB0VmlhQXN5bW1ldHJpY0FkbWluR0tleShncm91cDogR3JvdXAsIHJlcXVpcmVkQWRtaW5LZXlWZXJzaW9uOiBudW1iZXIpOiBQcm9taXNlPFZlcnNpb25lZEtleT4ge1xuXHRcdGNvbnN0IHJlcXVpcmVkQWRtaW5Hcm91cEtleVBhaXIgPSBhd2FpdCB0aGlzLmtleUxvYWRlckZhY2FkZS5sb2FkS2V5cGFpcihhc3NlcnROb3ROdWxsKGdyb3VwLmFkbWluKSwgcmVxdWlyZWRBZG1pbktleVZlcnNpb24pXG5cdFx0Y29uc3QgcHViRW5jS2V5RGF0YSA9IGFzc2VydE5vdE51bGwoZ3JvdXAucHViQWRtaW5Hcm91cEVuY0dLZXkpXG5cdFx0Y29uc3QgZGVjcnlwdGVkS2V5ID0gYXdhaXQgdGhpcy5hc3ltbWV0cmljQ3J5cHRvRmFjYWRlLmRlY3J5cHRTeW1LZXlXaXRoS2V5UGFpckFuZEF1dGhlbnRpY2F0ZShyZXF1aXJlZEFkbWluR3JvdXBLZXlQYWlyLCBwdWJFbmNLZXlEYXRhLCB7XG5cdFx0XHRpZGVudGlmaWVyOiBncm91cC5faWQsXG5cdFx0XHRpZGVudGlmaWVyVHlwZTogUHVibGljS2V5SWRlbnRpZmllclR5cGUuR1JPVVBfSUQsXG5cdFx0fSlcblx0XHRyZXR1cm4geyBvYmplY3Q6IGRlY3J5cHRlZEtleS5kZWNyeXB0ZWRBZXNLZXksIHZlcnNpb246IE51bWJlcihncm91cC5ncm91cEtleVZlcnNpb24pIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb250ZXh0OiByZW1vdmFsIG9mIGxvY2FsIGFkbWluc1xuXHQgKiBQcm9ibGVtOiBsb2NhbCBhZG1pbnMgZW5jcnlwdGVkIHRoZSB1c2VyIGdyb3VwIGtleSBvZiB0aGVpciB1c2VycyB3aXRoIHRoZWlyIGFkbWluIGdyb3VwIGtleSBidXQgZ2xvYmFsIGFkbWluIGNhbid0XG5cdCAqIGRlY3J5cHQgdGhlc2Ugd2l0aCB0aGVpciBhZG1pbiBncm91cCBrZXkuXG5cdCAqIFdlIHdhbnQgdGhlIGdsb2JhbCBhZG1pbiB0byBzdGlsbCBiZSBhYmxlIHRvIGRlY3J5cHQgdXNlciBkYXRhLlxuXHQgKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZGVjcnlwdCB0aGUgdXNlciBncm91cCBrZXkgd2l0aCB0aGUgbG9jYWwgYWRtaW4gZ3JvdXAga2V5IGFuZCB0aGVuIGVuY3J5cHQgaXQgd2l0aCB0aGUgZ2xvYmFsIGFkbWluIGdyb3VwIGtleVxuXHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgZnJlZSBvZiBzaWRlIGVmZmVjdHMsIGl0IG9ubHkgcmV0dXJucyBhIG5ldyByZWZlcmVuY2Ugb2YgdGhlIG5ld2x5IG1vZGlmaWVkIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0gZ2xvYmFsQWRtaW5Hcm91cEtleSB0aGUga2V5IG9mIHRoZSBnbG9iYWwgYWRtaW4gdGhhdCB3aWxsIGVuY3J5cHQgdGhlIHVzZXIgZ3JvdXAga2V5XG5cdCAqIEBwYXJhbSBsb2NhbEFkbWluR3JvdXBLZXkgdGhlIGtleSBvZiB0aGUgbG9jYWwgYWRtaW4gdGhhdCB3YXMgdXNlZCB0byBlbmNyeXB0IHRoZSB1c2VyIGdyb3VwIGtleSBhbmQgd2lsbCBiZSB1c2VkIHRvIGRlY3J5cHQgdGhlIHVzZXIgZ3JvdXAga2V5XG5cdCAqIEBwYXJhbSB1c2VyR3JvdXAgdGhlIHVzZXIgZ3JvdXAgdGhhdCBuZWVkcyBpdHMgYWRtaW5FbmNHcm91cEtleSB0byBiZSByZXBsYWNlZFxuXHQgKi9cblx0YXN5bmMgcmVwbGFjZUxvY2FsQWRtaW5FbmNHcm91cEtleVdpdGhHbG9iYWxBZG1pbkVuY0dyb3VwS2V5KFxuXHRcdGdsb2JhbEFkbWluR3JvdXBLZXk6IFZlcnNpb25lZEtleSxcblx0XHRsb2NhbEFkbWluR3JvdXBLZXk6IEFlc0tleSxcblx0XHR1c2VyR3JvdXA6IEdyb3VwLFxuXHQpOiBQcm9taXNlPExvY2FsQWRtaW5Hcm91cFJlcGxhY2VtZW50RGF0YT4ge1xuXHRcdGNvbnN0IGxvY2FsQWRtaW5FbmNVc2VyR3JvdXBLZXkgPSBhc3NlcnROb3ROdWxsKHVzZXJHcm91cC5hZG1pbkdyb3VwRW5jR0tleSlcblx0XHRjb25zdCBkZWNyeXB0ZWRVc2VyR3JvdXBLZXkgPSB0aGlzLmNyeXB0b1dyYXBwZXIuZGVjcnlwdEtleShsb2NhbEFkbWluR3JvdXBLZXksIGxvY2FsQWRtaW5FbmNVc2VyR3JvdXBLZXkpXG5cblx0XHRjb25zdCBnbG9iYWxBZG1pbkVuY1VzZXJHcm91cEtleSA9IHRoaXMuY3J5cHRvV3JhcHBlci5lbmNyeXB0S2V5KGdsb2JhbEFkbWluR3JvdXBLZXkub2JqZWN0LCBkZWNyeXB0ZWRVc2VyR3JvdXBLZXkpXG5cblx0XHRjb25zdCBncm91cFVwZGF0ZSA9IGNyZWF0ZUxvY2FsQWRtaW5Hcm91cFJlcGxhY2VtZW50RGF0YSh7XG5cdFx0XHRhZG1pbkdyb3VwS2V5VmVyc2lvbjogU3RyaW5nKGdsb2JhbEFkbWluR3JvdXBLZXkudmVyc2lvbiksXG5cdFx0XHRhZG1pbkdyb3VwRW5jR0tleTogZ2xvYmFsQWRtaW5FbmNVc2VyR3JvdXBLZXksXG5cdFx0XHRncm91cElkOiB1c2VyR3JvdXAuX2lkLFxuXHRcdFx0Z3JvdXBLZXlWZXJzaW9uOiB1c2VyR3JvdXAuZ3JvdXBLZXlWZXJzaW9uLFxuXHRcdH0pXG5cdFx0cmV0dXJuIGdyb3VwVXBkYXRlXG5cdH1cblxuXHQvKipcblx0ICogU2luY2UgbG9jYWwgYWRtaW5zIHdvbid0IGJlIHN1cHBvcnRlZCBhbnltb3JlIGFuZCB3aWxsIGJlIHJlbW92ZWQgd2UgbmVlZCB0byBsZXQgdGhlXG5cdCAqIGdsb2JhbCBhZG1pbiBhY2Nlc3MgdGhlIGxvY2FsbHkgYWRtaW5pc3RyYXRlZCBncm91cCBkYXRhLlxuXHQgKiBBcyBpdHMgbmFtZSBzdWdnZXN0IHRoaXMgZnVuY3Rpb24gbWlncmF0ZSB0aGUgdXNlcnMgYWRtaW5pc3RyYXRlZCBieSB0aGUgbG9jYWwgYWRtaW5zXG5cdCAqIHRvIHRoZSBnbG9iYWwgYWRtaW4gb2YgdGhlIGN1c3RvbWVyIHNvIHRoYXQgdGhlIGdsb2JhbCBhZG1pbiBjYW4gaGF2ZSBkaXJlY3Rcblx0ICogZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiBvZiBpdHMgdXNlcnMgZ3JvdXAga2V5cy5cblx0ICovXG5cdGFzeW5jIG1pZ3JhdGVMb2NhbEFkbWluc1RvR2xvYmFsQWRtaW5zKCkge1xuXHRcdGNvbnN0IHVzZXIgPSB0aGlzLnVzZXJGYWNhZGUuZ2V0TG9nZ2VkSW5Vc2VyKClcblx0XHRpZiAoIWlzR2xvYmFsQWRtaW4odXNlcikpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGNvbnN0IGN1c3RvbWVyID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChDdXN0b21lclR5cGVSZWYsIGFzc2VydE5vdE51bGwodXNlci5jdXN0b21lcikpXG5cdFx0Y29uc3QgdGVhbUdyb3VwSW5mb3MgPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkQWxsKEdyb3VwSW5mb1R5cGVSZWYsIGN1c3RvbWVyLnRlYW1Hcm91cHMpXG5cdFx0Y29uc3QgbG9jYWxBZG1pbkdyb3VwSW5mb3MgPSB0ZWFtR3JvdXBJbmZvcy5maWx0ZXIoKGdyb3VwKSA9PiBncm91cC5ncm91cFR5cGUgPT09IEdyb3VwVHlwZS5Mb2NhbEFkbWluKVxuXHRcdGNvbnN0IGFkbWluR3JvdXBJZDogSWQgPSBjdXN0b21lci5hZG1pbkdyb3VwXG5cdFx0Y29uc3QgYWRtaW5Hcm91cEtleSA9IGF3YWl0IHRoaXMua2V5TG9hZGVyRmFjYWRlLmdldEN1cnJlbnRTeW1Hcm91cEtleShhZG1pbkdyb3VwSWQpXG5cdFx0Y29uc3QgcG9zdEluID0gY3JlYXRlTG9jYWxBZG1pblJlbW92YWxQb3N0SW4oeyBncm91cFVwZGF0ZXM6IFtdIH0pXG5cblx0XHRmb3IgKGxldCBsb2NhbEFkbWluR3JvdXBJbmZvIG9mIGxvY2FsQWRtaW5Hcm91cEluZm9zKSB7XG5cdFx0XHRjb25zdCBsb2NhbEFkbWluR3JvdXAgPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKEdyb3VwVHlwZVJlZiwgbG9jYWxBZG1pbkdyb3VwSW5mby5ncm91cClcblx0XHRcdGNvbnN0IGFkbWluaXN0cmF0ZWRHcm91cHNMaXN0SWQgPSBsb2NhbEFkbWluR3JvdXAuYWRtaW5pc3RyYXRlZEdyb3Vwcz8uaXRlbXNcblx0XHRcdGlmIChhZG1pbmlzdHJhdGVkR3JvdXBzTGlzdElkID09IG51bGwpIHJldHVybiBudWxsXG5cdFx0XHRjb25zdCBhZG1pbmlzdHJhdGVkR3JvdXBzOiBBcnJheTxBZG1pbmlzdHJhdGVkR3JvdXA+ID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZEFsbChBZG1pbmlzdHJhdGVkR3JvdXBUeXBlUmVmLCBhZG1pbmlzdHJhdGVkR3JvdXBzTGlzdElkKVxuXG5cdFx0XHQvLyB3ZSBhc3N1bWUgbG9jYWwgYWRtaW5zIG5ldmVyIGhhZCB0aGVpciBrZXkgcm90YXRpb24gZG9uZSBhbmQgc28gdGhlaXIgc3ltIGtleSB2ZXJzaW9uIChyZXF1ZXN0ZWRWZXJzaW9uKSBpcyBzdHVjayB0byAwIGJ5IGRlZmF1bHRcblx0XHRcdGNvbnN0IHRoaXNMb2NhbEFkbWluR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRHcm91cEtleVZpYUFkbWluRW5jR0tleShsb2NhbEFkbWluR3JvdXAuX2lkKVxuXHRcdFx0Zm9yIChsZXQgYWcgb2YgYWRtaW5pc3RyYXRlZEdyb3Vwcykge1xuXHRcdFx0XHRjb25zdCB0aGlzUmVsYXRlZEdyb3VwSW5mbyA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoR3JvdXBJbmZvVHlwZVJlZiwgYWcuZ3JvdXBJbmZvKVxuXHRcdFx0XHRjb25zdCB0aGlzUmVsYXRlZEdyb3VwID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChHcm91cFR5cGVSZWYsIHRoaXNSZWxhdGVkR3JvdXBJbmZvLmdyb3VwKVxuXG5cdFx0XHRcdGNvbnN0IGdyb3VwVXBkYXRlID0gYXdhaXQgdGhpcy5yZXBsYWNlTG9jYWxBZG1pbkVuY0dyb3VwS2V5V2l0aEdsb2JhbEFkbWluRW5jR3JvdXBLZXkoXG5cdFx0XHRcdFx0YWRtaW5Hcm91cEtleSxcblx0XHRcdFx0XHR0aGlzTG9jYWxBZG1pbkdyb3VwS2V5Lm9iamVjdCxcblx0XHRcdFx0XHR0aGlzUmVsYXRlZEdyb3VwLFxuXHRcdFx0XHQpXG5cdFx0XHRcdHBvc3RJbi5ncm91cFVwZGF0ZXMucHVzaChncm91cFVwZGF0ZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGlzTm90RW1wdHkocG9zdEluLmdyb3VwVXBkYXRlcykpIHtcblx0XHRcdGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoTG9jYWxBZG1pblJlbW92YWxTZXJ2aWNlLCBwb3N0SW4pXG5cdFx0fVxuXHR9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQSxvQkFBb0I7SUFFUCx3QkFBTixNQUE0QjtDQUNsQyxZQUNrQkEsWUFDQUMsVUFDQUMsY0FDQUMsaUJBQ0FDLFVBQ0FDLGlCQUNBQyx1QkFDQUMsd0JBQ0FDLGVBQ2hCO0VBb1dGLEtBN1drQjtFQTZXakIsS0E1V2lCO0VBNFdoQixLQTNXZ0I7RUEyV2YsS0ExV2U7RUEwV2QsS0F6V2M7RUF5V2IsS0F4V2E7RUF3V1osS0F2V1k7RUF1V1gsS0F0V1c7RUFzV1YsS0FyV1U7Q0FDZDtDQUVKLE1BQU0sK0JBQStCQyxPQUErQjtBQUNuRSxTQUFPLEtBQUssU0FBUyxpQkFBaUIsWUFBWSxtQkFBbUIsVUFBVSxNQUFNLFNBQVMsRUFBRSxNQUFNLElBQUk7Q0FDMUc7Q0FFRCxNQUFNLGdCQUFnQkMsTUFBY0MsYUFBb0M7RUFDdkUsTUFBTSxnQkFBZ0IsS0FBSyxXQUFXLFlBQVksVUFBVSxNQUFNO0VBQ2xFLE1BQU0sZUFBZSxnQkFB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