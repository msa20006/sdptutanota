import { TutanotaError } from "./dist-chunk.js";
import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { assertWorkerOrNode } from "./Env-chunk.js";
import { assertNotNull, freshVersioned, getFirstOrThrow, neverNull } from "./dist2-chunk.js";
import { CounterType, GroupType, PublicKeyIdentifierType } from "./TutanotaConstants-chunk.js";
import "./EntityUtils-chunk.js";
import "./TypeModels-chunk.js";
import { createCreateMailGroupData, createDeleteGroupData, createInternalGroupData, createUserAreaGroupData, createUserAreaGroupDeleteData, createUserAreaGroupPostData } from "./TypeRefs-chunk.js";
import "./TypeModels2-chunk.js";
import { GroupTypeRef, UserTypeRef, createMembershipAddData, createMembershipRemoveData } from "./TypeRefs2-chunk.js";
import "./RestError-chunk.js";
import "./CryptoError-chunk.js";
import "./error-chunk.js";
import "./dist3-chunk.js";
import { parseKeyVersion } from "./KeyLoaderFacade-chunk.js";
import { MembershipService } from "./Services-chunk.js";
import { encryptKeyWithVersionedKey, encryptString } from "./CryptoWrapper-chunk.js";
import { CalendarService, ContactListGroupService, MailGroupService, TemplateGroupService } from "./Services2-chunk.js";
import { brandKeyMac } from "./KeyAuthenticationFacade-chunk.js";

//#region src/common/api/worker/facades/lazy/GroupManagementFacade.ts
assertWorkerOrNode();
var GroupManagementFacade = class {
	constructor(userFacade, counters, entityClient, serviceExecutor, pqFacade, keyLoaderFacade, cacheManagementFacade, asymmetricCryptoFacade, cryptoWrapper, keyAuthenticationFacade) {
		this.userFacade = userFacade;
		this.counters = counters;
		this.entityClient = entityClient;
		this.serviceExecutor = serviceExecutor;
		this.pqFacade = pqFacade;
		this.keyLoaderFacade = keyLoaderFacade;
		this.cacheManagementFacade = cacheManagementFacade;
		this.asymmetricCryptoFacade = asymmetricCryptoFacade;
		this.cryptoWrapper = cryptoWrapper;
		this.keyAuthenticationFacade = keyAuthenticationFacade;
	}
	async readUsedSharedMailGroupStorage(group) {
		return this.counters.readCounterValue(CounterType.UserStorageLegacy, neverNull(group.customer), group._id);
	}
	async createMailGroup(name, mailAddress) {
		const adminGroupIds = this.userFacade.getGroupIds(GroupType.Admin);
		const adminGroupId = getFirstOrThrow(adminGroupIds);
		let adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		let customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(this.userFacade.getGroupId(GroupType.Customer));
		let mailGroupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey());
		let mailGroupInfoSessionKey = this.cryptoWrapper.aes256RandomKey();
		let mailboxSessionKey = this.cryptoWrapper.aes256RandomKey();
		const keyPair = await this.pqFacade.generateKeyPairs();
		const mailGroupData = this.generateInternalGroupData(keyPair, mailGroupKey.object, mailGroupInfoSessionKey, adminGroupId, adminGroupKey, customerGroupKey);
		const mailEncMailboxSessionKey = encryptKeyWithVersionedKey(mailGroupKey, mailboxSessionKey);
		const data = createCreateMailGroupData({
			mailAddress,
			encryptedName: encryptString(mailGroupInfoSessionKey, name),
			mailEncMailboxSessionKey: mailEncMailboxSessionKey.key,
			groupData: mailGroupData
		});
		await this.serviceExecutor.post(MailGroupService, data);
	}
	/**
	* Generates keys for the new group and prepares the group data object to create the group.
	*
	* @param name Name of the group
	*/
	async generateUserAreaGroupData(name) {
		const userGroup = await this.entityClient.load(GroupTypeRef, this.userFacade.getUserGroupId());
		const adminGroupId = neverNull(userGroup.admin);
		let adminGroupKey = null;
		if (this.userFacade.getAllGroupIds().indexOf(adminGroupId) !== -1) adminGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		const customerGroupId = this.userFacade.getGroupId(GroupType.Customer);
		const customerGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(customerGroupId);
		const userGroupKey = this.userFacade.getCurrentUserGroupKey();
		const groupKey = freshVersioned(this.cryptoWrapper.aes256RandomKey());
		const groupRootSessionKey = this.cryptoWrapper.aes256RandomKey();
		const groupInfoSessionKey = this.cryptoWrapper.aes256RandomKey();
		const userEncGroupKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object);
		const adminEncGroupKey = adminGroupKey ? encryptKeyWithVersionedKey(adminGroupKey, groupKey.object) : null;
		const customerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(customerGroupKey, groupInfoSessionKey);
		const groupEncGroupRootSessionKey = encryptKeyWithVersionedKey(groupKey, groupRootSessionKey);
		return createUserAreaGroupData({
			groupEncGroupRootSessionKey: groupEncGroupRootSessionKey.key,
			customerEncGroupInfoSessionKey: customerEncGroupInfoSessionKey.key,
			userEncGroupKey: userEncGroupKey.key,
			groupInfoEncName: encryptString(groupInfoSessionKey, name),
			adminEncGroupKey: adminEncGroupKey?.key ?? null,
			adminGroup: adminGroupId,
			customerKeyVersion: customerEncGroupInfoSessionKey.encryptingKeyVersion.toString(),
			userKeyVersion: userGroupKey.version.toString(),
			adminKeyVersion: adminEncGroupKey?.encryptingKeyVersion.toString() ?? null
		});
	}
	async createCalendar(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const postData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(CalendarService, postData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		const group = await this.entityClient.load(GroupTypeRef, postGroupData.group);
		const user = await this.cacheManagementFacade.reloadUser();
		return {
			user,
			group
		};
	}
	async createTemplateGroup(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const serviceData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(TemplateGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		await this.cacheManagementFacade.reloadUser();
		return postGroupData.group;
	}
	async createContactListGroup(name) {
		const groupData = await this.generateUserAreaGroupData(name);
		const serviceData = createUserAreaGroupPostData({ groupData });
		const postGroupData = await this.serviceExecutor.post(ContactListGroupService, serviceData, { sessionKey: this.cryptoWrapper.aes256RandomKey() });
		const group = await this.entityClient.load(GroupTypeRef, postGroupData.group);
		await this.cacheManagementFacade.reloadUser();
		return group;
	}
	async deleteContactListGroup(groupRoot) {
		const serviceData = createUserAreaGroupDeleteData({ group: groupRoot._id });
		await this.serviceExecutor.delete(ContactListGroupService, serviceData);
	}
	/**
	* Assemble the data transfer type to create a new internal group on the server.
	* The group key version is not needed because it is always zero.
	*/
	generateInternalGroupData(keyPair, groupKey, groupInfoSessionKey, adminGroupId, adminGroupKey, ownerGroupKey) {
		const adminEncGroupKey = encryptKeyWithVersionedKey(adminGroupKey, groupKey);
		const ownerEncGroupInfoSessionKey = encryptKeyWithVersionedKey(ownerGroupKey, groupInfoSessionKey);
		return createInternalGroupData({
			pubRsaKey: null,
			groupEncPrivRsaKey: null,
			pubEccKey: keyPair.eccKeyPair.publicKey,
			groupEncPrivEccKey: this.cryptoWrapper.encryptEccKey(groupKey, keyPair.eccKeyPair.privateKey),
			pubKyberKey: this.cryptoWrapper.kyberPublicKeyToBytes(keyPair.kyberKeyPair.publicKey),
			groupEncPrivKyberKey: this.cryptoWrapper.encryptKyberKey(groupKey, keyPair.kyberKeyPair.privateKey),
			adminGroup: adminGroupId,
			adminEncGroupKey: adminEncGroupKey.key,
			ownerEncGroupInfoSessionKey: ownerEncGroupInfoSessionKey.key,
			adminKeyVersion: adminEncGroupKey.encryptingKeyVersion.toString(),
			ownerKeyVersion: ownerEncGroupInfoSessionKey.encryptingKeyVersion.toString()
		});
	}
	async addUserToGroup(user, groupId) {
		const userGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(user.userGroup.group);
		const groupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId);
		const symEncGKey = encryptKeyWithVersionedKey(userGroupKey, groupKey.object);
		const data = createMembershipAddData({
			user: user._id,
			group: groupId,
			symEncGKey: symEncGKey.key,
			groupKeyVersion: String(groupKey.version),
			symKeyVersion: symEncGKey.encryptingKeyVersion.toString()
		});
		await this.serviceExecutor.post(MembershipService, data);
	}
	async removeUserFromGroup(userId, groupId) {
		const data = createMembershipRemoveData({
			user: userId,
			group: groupId
		});
		await this.serviceExecutor.delete(MembershipService, data);
	}
	async deactivateGroup(group, restore) {
		const data = createDeleteGroupData({
			group: group._id,
			restore
		});
		if (group.type === GroupType.Mail) await this.serviceExecutor.delete(MailGroupService, data);
else throw new Error("invalid group type for deactivation");
	}
	async getGroupKeyViaUser(groupId, version, viaUser) {
		const currentGroupKey = await this.getCurrentGroupKeyViaUser(groupId, viaUser);
		return this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey);
	}
	/**
	* Get a group key for any group we are admin and know some member of.
	*
	* Unlike {@link getCurrentGroupKeyViaAdminEncGKey} this should work for any group because we will actually go a "long" route of decrypting userGroupKey of the
	* member and decrypting group key with that.
	*/
	async getCurrentGroupKeyViaUser(groupId, viaUser) {
		const user = await this.entityClient.load(UserTypeRef, viaUser);
		const membership = user.memberships.find((m) => m.group === groupId);
		if (membership == null) throw new Error(`User doesn't have this group membership! User: ${viaUser} groupId: ${groupId}`);
		const requiredUserGroupKeyVersion = membership.symKeyVersion;
		const requiredUserGroupKey = await this.getGroupKeyViaAdminEncGKey(user.userGroup.group, parseKeyVersion(requiredUserGroupKeyVersion));
		const key = this.cryptoWrapper.decryptKey(requiredUserGroupKey, membership.symEncGKey);
		const version = parseKeyVersion(membership.groupKeyVersion);
		return {
			object: key,
			version
		};
	}
	async getGroupKeyViaAdminEncGKey(groupId, version) {
		if (this.userFacade.hasGroup(groupId)) return this.keyLoaderFacade.loadSymGroupKey(groupId, version);
else {
			const currentGroupKey = await this.getCurrentGroupKeyViaAdminEncGKey(groupId);
			return this.keyLoaderFacade.loadSymGroupKey(groupId, version, currentGroupKey);
		}
	}
	/**
	* @returns true if the group currently has an adminEncGKey. This may be an asymmetrically encrypted one.
	*/
	hasAdminEncGKey(group) {
		return group.adminGroupEncGKey != null && group.adminGroupEncGKey.length !== 0 || group.pubAdminGroupEncGKey != null;
	}
	/**
	* Get a group key for certain group types.
	*
	* Some groups (e.g. user groups or shared mailboxes) have adminGroupEncGKey set on creation. For those groups we can fairly easily get a group key without
	* decrypting userGroupKey of some member of that group.
	*/
	async getCurrentGroupKeyViaAdminEncGKey(groupId) {
		if (this.userFacade.hasGroup(groupId)) return this.keyLoaderFacade.getCurrentSymGroupKey(groupId);
else {
			const group = await this.cacheManagementFacade.reloadGroup(groupId);
			if (!this.hasAdminEncGKey(group)) throw new ProgrammingError("Group doesn't have adminGroupEncGKey, you can't get group key this way");
			if (!(group.admin && this.userFacade.hasGroup(group.admin))) throw new Error(`The user is not a member of the admin group ${group.admin} when trying to get the group key for group ${groupId}`);
			const requiredAdminKeyVersion = parseKeyVersion(group.adminGroupKeyVersion ?? "0");
			if (group.adminGroupEncGKey != null) return await this.decryptViaSymmetricAdminGKey(group, {
				key: group.adminGroupEncGKey,
				encryptingKeyVersion: requiredAdminKeyVersion
			}, parseKeyVersion(group.groupKeyVersion));
else return await this.decryptViaAsymmetricAdminGKey(group, assertNotNull(group.pubAdminGroupEncGKey));
		}
	}
	async decryptViaSymmetricAdminGKey(group, encryptedGroupKey, encryptedKeyVersion) {
		const requiredAdminGroupKey = await this.keyLoaderFacade.loadSymGroupKey(assertNotNull(group.admin), encryptedGroupKey.encryptingKeyVersion);
		const decryptedKey = this.cryptoWrapper.decryptKey(requiredAdminGroupKey, encryptedGroupKey.key);
		return {
			object: decryptedKey,
			version: encryptedKeyVersion
		};
	}
	/**
	* @param userGroup the group for which we are trying to get the key
	* @param pubAdminEncUserKeyData some version of the group key encrypted with some version of the public admin group key. This can be the current one from the group or one of the former group keys.
	* @private
	*/
	async decryptViaAsymmetricAdminGKey(userGroup, pubAdminEncUserKeyData) {
		const requiredAdminGroupKeyPair = await this.keyLoaderFacade.loadKeypair(assertNotNull(userGroup.admin), parseKeyVersion(pubAdminEncUserKeyData.recipientKeyVersion));
		const decryptedUserGroupKey = (await this.asymmetricCryptoFacade.decryptSymKeyWithKeyPairAndAuthenticate(requiredAdminGroupKeyPair, pubAdminEncUserKeyData, {
			identifier: userGroup._id,
			identifierType: PublicKeyIdentifierType.GROUP_ID
		})).decryptedAesKey;
		const versionedDecryptedUserGroupKey = {
			object: decryptedUserGroupKey,
			version: parseKeyVersion(assertNotNull(pubAdminEncUserKeyData.symKeyMac).taggedKeyVersion)
		};
		await this.verifyUserGroupKeyMac(pubAdminEncUserKeyData, userGroup, versionedDecryptedUserGroupKey);
		return versionedDecryptedUserGroupKey;
	}
	async verifyUserGroupKeyMac(pubEncKeyData, userGroup, receivedUserGroupKey) {
		const givenUserGroupKeyMac = brandKeyMac(assertNotNull(pubEncKeyData.symKeyMac));
		const previousUserGroupKeyVersion = parseKeyVersion(givenUserGroupKeyMac.taggingKeyVersion);
		const recipientAdminGroupKeyVersion = parseKeyVersion(pubEncKeyData.recipientKeyVersion);
		const formerGroupKey = await this.keyLoaderFacade.loadFormerGroupKeyInstance(userGroup, previousUserGroupKeyVersion);
		let previousUserGroupKey;
		if (formerGroupKey.adminGroupEncGKey != null) previousUserGroupKey = await this.decryptViaSymmetricAdminGKey(userGroup, {
			key: formerGroupKey.adminGroupEncGKey,
			encryptingKeyVersion: parseKeyVersion(assertNotNull(formerGroupKey.adminGroupKeyVersion))
		}, previousUserGroupKeyVersion);
else if (formerGroupKey.pubAdminGroupEncGKey != null) {
			const userGroupKeyMac = assertNotNull(formerGroupKey.pubAdminGroupEncGKey.symKeyMac);
			if (userGroupKeyMac.taggedKeyVersion === "0") throw new TutanotaError("UserGroupKeyNotTrustedError", "cannot establish trust on the user group key");
			previousUserGroupKey = await this.decryptViaAsymmetricAdminGKey(userGroup, formerGroupKey.pubAdminGroupEncGKey);
		} else throw new TutanotaError("MissingAdminEncGroupKeyError", "cannot verify user group key");
		this.keyAuthenticationFacade.verifyTag({
			tagType: "USER_GROUP_KEY_TAG",
			sourceOfTrust: { currentUserGroupKey: previousUserGroupKey.object },
			untrustedKey: { newUserGroupKey: receivedUserGroupKey.object },
			bindingData: {
				userGroupId: userGroup._id,
				adminGroupId: assertNotNull(userGroup.admin),
				currentUserGroupKeyVersion: previousUserGroupKey.version,
				newUserGroupKeyVersion: receivedUserGroupKey.version,
				newAdminGroupKeyVersion: recipientAdminGroupKeyVersion
			}
		}, givenUserGroupKeyMac.tag);
	}
};

//#endregion
export { GroupManagementFacade };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JvdXBNYW5hZ2VtZW50RmFjYWRlLWNodW5rLmpzIiwibmFtZXMiOlsidXNlckZhY2FkZTogVXNlckZhY2FkZSIsImNvdW50ZXJzOiBDb3VudGVyRmFjYWRlIiwiZW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQiLCJzZXJ2aWNlRXhlY3V0b3I6IElTZXJ2aWNlRXhlY3V0b3IiLCJwcUZhY2FkZTogUFFGYWNhZGUiLCJrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSIsImNhY2hlTWFuYWdlbWVudEZhY2FkZTogQ2FjaGVNYW5hZ2VtZW50RmFjYWRlIiwiYXN5bW1ldHJpY0NyeXB0b0ZhY2FkZTogQXN5bW1ldHJpY0NyeXB0b0ZhY2FkZSIsImNyeXB0b1dyYXBwZXI6IENyeXB0b1dyYXBwZXIiLCJrZXlBdXRoZW50aWNhdGlvbkZhY2FkZTogS2V5QXV0aGVudGljYXRpb25GYWNhZGUiLCJncm91cDogR3JvdXAiLCJuYW1lOiBzdHJpbmciLCJtYWlsQWRkcmVzczogc3RyaW5nIiwiYWRtaW5Hcm91cEtleTogVmVyc2lvbmVkS2V5IHwgbnVsbCIsImdyb3VwUm9vdDogQ29udGFjdExpc3RHcm91cFJvb3QiLCJrZXlQYWlyOiBQUUtleVBhaXJzIiwiZ3JvdXBLZXk6IEFlc0tleSIsImdyb3VwSW5mb1Nlc3Npb25LZXk6IEFlc0tleSIsImFkbWluR3JvdXBJZDogSWQgfCBudWxsIiwiYWRtaW5Hcm91cEtleTogVmVyc2lvbmVkS2V5Iiwib3duZXJHcm91cEtleTogVmVyc2lvbmVkS2V5IiwidXNlcjogVXNlciIsImdyb3VwSWQ6IElkIiwidXNlcklkOiBJZCIsInJlc3RvcmU6IGJvb2xlYW4iLCJ2ZXJzaW9uOiBLZXlWZXJzaW9uIiwidmlhVXNlcjogSWQiLCJlbmNyeXB0ZWRHcm91cEtleTogVmVyc2lvbmVkRW5jcnlwdGVkS2V5IiwiZW5jcnlwdGVkS2V5VmVyc2lvbjogS2V5VmVyc2lvbiIsInVzZXJHcm91cDogR3JvdXAiLCJwdWJBZG1pbkVuY1VzZXJLZXlEYXRhOiBQdWJFbmNLZXlEYXRhIiwicHViRW5jS2V5RGF0YTogUHViRW5jS2V5RGF0YSIsInJlY2VpdmVkVXNlckdyb3VwS2V5OiBWZXJzaW9uZWRLZXkiLCJwcmV2aW91c1VzZXJHcm91cEtleTogVmVyc2lvbmVkS2V5Il0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9hcGkvd29ya2VyL2ZhY2FkZXMvbGF6eS9Hcm91cE1hbmFnZW1lbnRGYWNhZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ291bnRlclR5cGUsIEdyb3VwVHlwZSwgUHVibGljS2V5SWRlbnRpZmllclR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL1R1dGFub3RhQ29uc3RhbnRzLmpzXCJcbmltcG9ydCB0eXBlIHsgQ29udGFjdExpc3RHcm91cFJvb3QsIEludGVybmFsR3JvdXBEYXRhLCBVc2VyQXJlYUdyb3VwRGF0YSB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy90dXRhbm90YS9UeXBlUmVmcy5qc1wiXG5pbXBvcnQge1xuXHRjcmVhdGVDcmVhdGVNYWlsR3JvdXBEYXRhLFxuXHRjcmVhdGVEZWxldGVHcm91cERhdGEsXG5cdGNyZWF0ZUludGVybmFsR3JvdXBEYXRhLFxuXHRjcmVhdGVVc2VyQXJlYUdyb3VwRGF0YSxcblx0Y3JlYXRlVXNlckFyZWFHcm91cERlbGV0ZURhdGEsXG5cdGNyZWF0ZVVzZXJBcmVhR3JvdXBQb3N0RGF0YSxcbn0gZnJvbSBcIi4uLy4uLy4uL2VudGl0aWVzL3R1dGFub3RhL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IGFzc2VydE5vdE51bGwsIGZyZXNoVmVyc2lvbmVkLCBnZXRGaXJzdE9yVGhyb3csIG5ldmVyTnVsbCB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgY3JlYXRlTWVtYmVyc2hpcEFkZERhdGEsIGNyZWF0ZU1lbWJlcnNoaXBSZW1vdmVEYXRhLCBHcm91cCwgR3JvdXBUeXBlUmVmLCBQdWJFbmNLZXlEYXRhLCBVc2VyLCBVc2VyVHlwZVJlZiB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgQ291bnRlckZhY2FkZSB9IGZyb20gXCIuL0NvdW50ZXJGYWNhZGUuanNcIlxuaW1wb3J0IHsgRW50aXR5Q2xpZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9FbnRpdHlDbGllbnQuanNcIlxuaW1wb3J0IHsgYXNzZXJ0V29ya2VyT3JOb2RlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9FbnYuanNcIlxuaW1wb3J0IHsgSVNlcnZpY2VFeGVjdXRvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vU2VydmljZVJlcXVlc3QuanNcIlxuaW1wb3J0IHsgQ2FsZW5kYXJTZXJ2aWNlLCBDb250YWN0TGlzdEdyb3VwU2VydmljZSwgTWFpbEdyb3VwU2VydmljZSwgVGVtcGxhdGVHcm91cFNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvdHV0YW5vdGEvU2VydmljZXMuanNcIlxuaW1wb3J0IHsgTWVtYmVyc2hpcFNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvc3lzL1NlcnZpY2VzLmpzXCJcbmltcG9ydCB7IFVzZXJGYWNhZGUgfSBmcm9tIFwiLi4vVXNlckZhY2FkZS5qc1wiXG5pbXBvcnQgeyBQcm9ncmFtbWluZ0Vycm9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9lcnJvci9Qcm9ncmFtbWluZ0Vycm9yLmpzXCJcbmltcG9ydCB7IFBRRmFjYWRlIH0gZnJvbSBcIi4uL1BRRmFjYWRlLmpzXCJcbmltcG9ydCB7IEtleUxvYWRlckZhY2FkZSwgcGFyc2VLZXlWZXJzaW9uIH0gZnJvbSBcIi4uL0tleUxvYWRlckZhY2FkZS5qc1wiXG5pbXBvcnQgeyBDYWNoZU1hbmFnZW1lbnRGYWNhZGUgfSBmcm9tIFwiLi9DYWNoZU1hbmFnZW1lbnRGYWNhZGUuanNcIlxuaW1wb3J0IHsgQ3J5cHRvV3JhcHBlciwgZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXksIGVuY3J5cHRTdHJpbmcsIFZlcnNpb25lZEVuY3J5cHRlZEtleSwgVmVyc2lvbmVkS2V5IH0gZnJvbSBcIi4uLy4uL2NyeXB0by9DcnlwdG9XcmFwcGVyLmpzXCJcbmltcG9ydCB7IEFzeW1tZXRyaWNDcnlwdG9GYWNhZGUgfSBmcm9tIFwiLi4vLi4vY3J5cHRvL0FzeW1tZXRyaWNDcnlwdG9GYWNhZGUuanNcIlxuaW1wb3J0IHsgQWVzS2V5LCBQUUtleVBhaXJzIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS1jcnlwdG9cIlxuaW1wb3J0IHsgYnJhbmRLZXlNYWMsIEtleUF1dGhlbnRpY2F0aW9uRmFjYWRlIH0gZnJvbSBcIi4uL0tleUF1dGhlbnRpY2F0aW9uRmFjYWRlLmpzXCJcbmltcG9ydCB7IFR1dGFub3RhRXJyb3IgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLWVycm9yXCJcbmltcG9ydCB7IEtleVZlcnNpb24gfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzL2Rpc3QvVXRpbHMuanNcIlxuXG5hc3NlcnRXb3JrZXJPck5vZGUoKVxuXG5leHBvcnQgY2xhc3MgR3JvdXBNYW5hZ2VtZW50RmFjYWRlIHtcblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1c2VyRmFjYWRlOiBVc2VyRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgY291bnRlcnM6IENvdW50ZXJGYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBlbnRpdHlDbGllbnQ6IEVudGl0eUNsaWVudCxcblx0XHRwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2VFeGVjdXRvcjogSVNlcnZpY2VFeGVjdXRvcixcblx0XHRwcml2YXRlIHJlYWRvbmx5IHBxRmFjYWRlOiBQUUZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGtleUxvYWRlckZhY2FkZTogS2V5TG9hZGVyRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgY2FjaGVNYW5hZ2VtZW50RmFjYWRlOiBDYWNoZU1hbmFnZW1lbnRGYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBhc3ltbWV0cmljQ3J5cHRvRmFjYWRlOiBBc3ltbWV0cmljQ3J5cHRvRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgY3J5cHRvV3JhcHBlcjogQ3J5cHRvV3JhcHBlcixcblx0XHRwcml2YXRlIHJlYWRvbmx5IGtleUF1dGhlbnRpY2F0aW9uRmFjYWRlOiBLZXlBdXRoZW50aWNhdGlvbkZhY2FkZSxcblx0KSB7fVxuXG5cdGFzeW5jIHJlYWRVc2VkU2hhcmVkTWFpbEdyb3VwU3RvcmFnZShncm91cDogR3JvdXApOiBQcm9taXNlPG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLmNvdW50ZXJzLnJlYWRDb3VudGVyVmFsdWUoQ291bnRlclR5cGUuVXNlclN0b3JhZ2VMZWdhY3ksIG5ldmVyTnVsbChncm91cC5jdXN0b21lciksIGdyb3VwLl9pZClcblx0fVxuXG5cdGFzeW5jIGNyZWF0ZU1haWxHcm91cChuYW1lOiBzdHJpbmcsIG1haWxBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBhZG1pbkdyb3VwSWRzID0gdGhpcy51c2VyRmFjYWRlLmdldEdyb3VwSWRzKEdyb3VwVHlwZS5BZG1pbilcblx0XHRjb25zdCBhZG1pbkdyb3VwSWQgPSBnZXRGaXJzdE9yVGhyb3coYWRtaW5Hcm91cElkcylcblxuXHRcdGxldCBhZG1pbkdyb3VwS2V5ID0gYXdhaXQgdGhpcy5rZXlMb2FkZXJGYWNhZGUuZ2V0Q3VycmVudFN5bUdyb3VwS2V5KGFkbWluR3JvdXBJZClcblx0XHRsZXQgY3VzdG9tZXJHcm91cEtleSA9IGF3YWl0IHRoaXMua2V5TG9hZGVyRmFjYWRlLmdldEN1cnJlbnRTeW1Hcm91cEtleSh0aGlzLnVzZXJGYWNhZGUuZ2V0R3JvdXBJZChHcm91cFR5cGUuQ3VzdG9tZXIpKVxuXHRcdGxldCBtYWlsR3JvdXBLZXkgPSBmcmVzaFZlcnNpb25lZCh0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KCkpXG5cblx0XHRsZXQgbWFpbEdyb3VwSW5mb1Nlc3Npb25LZXkgPSB0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KClcblx0XHRsZXQgbWFpbGJveFNlc3Npb25LZXkgPSB0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KClcblx0XHRjb25zdCBrZXlQYWlyID0gYXdhaXQgdGhpcy5wcUZhY2FkZS5nZW5lcmF0ZUtleVBhaXJzKClcblx0XHRjb25zdCBtYWlsR3JvdXBEYXRhID0gdGhpcy5nZW5lcmF0ZUludGVybmFsR3JvdXBEYXRhKFxuXHRcdFx0a2V5UGFpcixcblx0XHRcdG1haWxHcm91cEtleS5vYmplY3QsXG5cdFx0XHRtYWlsR3JvdXBJbmZvU2Vzc2lvbktleSxcblx0XHRcdGFkbWluR3JvdXBJZCxcblx0XHRcdGFkbWluR3JvdXBLZXksXG5cdFx0XHRjdXN0b21lckdyb3VwS2V5LFxuXHRcdClcblxuXHRcdGNvbnN0IG1haWxFbmNNYWlsYm94U2Vzc2lvbktleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KG1haWxHcm91cEtleSwgbWFpbGJveFNlc3Npb25LZXkpXG5cblx0XHRjb25zdCBkYXRhID0gY3JlYXRlQ3JlYXRlTWFpbEdyb3VwRGF0YSh7XG5cdFx0XHRtYWlsQWRkcmVzcyxcblx0XHRcdGVuY3J5cHRlZE5hbWU6IGVuY3J5cHRTdHJpbmcobWFpbEdyb3VwSW5mb1Nlc3Npb25LZXksIG5hbWUpLFxuXHRcdFx0bWFpbEVuY01haWxib3hTZXNzaW9uS2V5OiBtYWlsRW5jTWFpbGJveFNlc3Npb25LZXkua2V5LFxuXHRcdFx0Z3JvdXBEYXRhOiBtYWlsR3JvdXBEYXRhLFxuXHRcdH0pXG5cdFx0YXdhaXQgdGhpcy5zZXJ2aWNlRXhlY3V0b3IucG9zdChNYWlsR3JvdXBTZXJ2aWNlLCBkYXRhKVxuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBrZXlzIGZvciB0aGUgbmV3IGdyb3VwIGFuZCBwcmVwYXJlcyB0aGUgZ3JvdXAgZGF0YSBvYmplY3QgdG8gY3JlYXRlIHRoZSBncm91cC5cblx0ICpcblx0ICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZ3JvdXBcblx0ICovXG5cdGFzeW5jIGdlbmVyYXRlVXNlckFyZWFHcm91cERhdGEobmFtZTogc3RyaW5nKTogUHJvbWlzZTxVc2VyQXJlYUdyb3VwRGF0YT4ge1xuXHRcdC8vIGFkbWluR3JvdXAgSXMgbm90IHNldCB3aGVuIGdlbmVyYXRpbmcgbmV3IGN1c3RvbWVyLCB0aGVuIHRoZSBhZG1pbiBncm91cCB3aWxsIGJlIHRoZSBhZG1pbiBvZiB0aGUgY3VzdG9tZXJcblx0XHQvLyBhZG1pbkdyb3VwS2V5IElzIG5vdCBzZXQgd2hlbiBnZW5lcmF0aW5nIGNhbGVuZGFyIGFzIG5vcm1hbCB1c2VyXG5cdFx0Y29uc3QgdXNlckdyb3VwID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChHcm91cFR5cGVSZWYsIHRoaXMudXNlckZhY2FkZS5nZXRVc2VyR3JvdXBJZCgpKVxuXHRcdGNvbnN0IGFkbWluR3JvdXBJZCA9IG5ldmVyTnVsbCh1c2VyR3JvdXAuYWRtaW4pIC8vIHVzZXIgZ3JvdXAgaGFzIGFsd2F5cyBhZG1pbiBncm91cFxuXG5cdFx0bGV0IGFkbWluR3JvdXBLZXk6IFZlcnNpb25lZEtleSB8IG51bGwgPSBudWxsXG5cblx0XHRpZiAodGhpcy51c2VyRmFjYWRlLmdldEFsbEdyb3VwSWRzKCkuaW5kZXhPZihhZG1pbkdyb3VwSWQpICE9PSAtMSkge1xuXHRcdFx0Ly8gZ2V0R3JvdXBLZXkgdGhyb3dzIGFuIGVycm9yIGlmIHVzZXIgaXMgbm90IG1lbWJlciBvZiB0aGF0IGdyb3VwIC0gc28gY2hlY2sgZmlyc3Rcblx0XHRcdGFkbWluR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmtleUxvYWRlckZhY2FkZS5nZXRDdXJyZW50U3ltR3JvdXBLZXkoYWRtaW5Hcm91cElkKVxuXHRcdH1cblxuXHRcdGNvbnN0IGN1c3RvbWVyR3JvdXBJZCA9IHRoaXMudXNlckZhY2FkZS5nZXRHcm91cElkKEdyb3VwVHlwZS5DdXN0b21lcilcblx0XHRjb25zdCBjdXN0b21lckdyb3VwS2V5ID0gYXdhaXQgdGhpcy5rZXlMb2FkZXJGYWNhZGUuZ2V0Q3VycmVudFN5bUdyb3VwS2V5KGN1c3RvbWVyR3JvdXBJZClcblx0XHRjb25zdCB1c2VyR3JvdXBLZXkgPSB0aGlzLnVzZXJGYWNhZGUuZ2V0Q3VycmVudFVzZXJHcm91cEtleSgpXG5cdFx0Y29uc3QgZ3JvdXBLZXkgPSBmcmVzaFZlcnNpb25lZCh0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KCkpXG5cblx0XHRjb25zdCBncm91cFJvb3RTZXNzaW9uS2V5ID0gdGhpcy5jcnlwdG9XcmFwcGVyLmFlczI1NlJhbmRvbUtleSgpXG5cdFx0Y29uc3QgZ3JvdXBJbmZvU2Vzc2lvbktleSA9IHRoaXMuY3J5cHRvV3JhcHBlci5hZXMyNTZSYW5kb21LZXkoKVxuXG5cdFx0Y29uc3QgdXNlckVuY0dyb3VwS2V5ID0gZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXkodXNlckdyb3VwS2V5LCBncm91cEtleS5vYmplY3QpXG5cdFx0Y29uc3QgYWRtaW5FbmNHcm91cEtleSA9IGFkbWluR3JvdXBLZXkgPyBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleShhZG1pbkdyb3VwS2V5LCBncm91cEtleS5vYmplY3QpIDogbnVsbFxuXHRcdGNvbnN0IGN1c3RvbWVyRW5jR3JvdXBJbmZvU2Vzc2lvbktleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KGN1c3RvbWVyR3JvdXBLZXksIGdyb3VwSW5mb1Nlc3Npb25LZXkpXG5cdFx0Y29uc3QgZ3JvdXBFbmNHcm91cFJvb3RTZXNzaW9uS2V5ID0gZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXkoZ3JvdXBLZXksIGdyb3VwUm9vdFNlc3Npb25LZXkpXG5cblx0XHRyZXR1cm4gY3JlYXRlVXNlckFyZWFHcm91cERhdGEoe1xuXHRcdFx0Z3JvdXBFbmNHcm91cFJvb3RTZXNzaW9uS2V5OiBncm91cEVuY0dyb3VwUm9vdFNlc3Npb25LZXkua2V5LFxuXHRcdFx0Y3VzdG9tZXJFbmNHcm91cEluZm9TZXNzaW9uS2V5OiBjdXN0b21lckVuY0dyb3VwSW5mb1Nlc3Npb25LZXkua2V5LFxuXHRcdFx0dXNlckVuY0dyb3VwS2V5OiB1c2VyRW5jR3JvdXBLZXkua2V5LFxuXHRcdFx0Z3JvdXBJbmZvRW5jTmFtZTogZW5jcnlwdFN0cmluZyhncm91cEluZm9TZXNzaW9uS2V5LCBuYW1lKSxcblx0XHRcdGFkbWluRW5jR3JvdXBLZXk6IGFkbWluRW5jR3JvdXBLZXk/LmtleSA/PyBudWxsLFxuXHRcdFx0YWRtaW5Hcm91cDogYWRtaW5Hcm91cElkLFxuXHRcdFx0Y3VzdG9tZXJLZXlWZXJzaW9uOiBjdXN0b21lckVuY0dyb3VwSW5mb1Nlc3Npb25LZXkuZW5jcnlwdGluZ0tleVZlcnNpb24udG9TdHJpbmcoKSxcblx0XHRcdHVzZXJLZXlWZXJzaW9uOiB1c2VyR3JvdXBLZXkudmVyc2lvbi50b1N0cmluZygpLFxuXHRcdFx0YWRtaW5LZXlWZXJzaW9uOiBhZG1pbkVuY0dyb3VwS2V5Py5lbmNyeXB0aW5nS2V5VmVyc2lvbi50b1N0cmluZygpID8/IG51bGwsXG5cdFx0fSlcblx0fVxuXG5cdGFzeW5jIGNyZWF0ZUNhbGVuZGFyKG5hbWU6IHN0cmluZyk6IFByb21pc2U8eyB1c2VyOiBVc2VyOyBncm91cDogR3JvdXAgfT4ge1xuXHRcdGNvbnN0IGdyb3VwRGF0YSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVVc2VyQXJlYUdyb3VwRGF0YShuYW1lKVxuXHRcdGNvbnN0IHBvc3REYXRhID0gY3JlYXRlVXNlckFyZWFHcm91cFBvc3REYXRhKHtcblx0XHRcdGdyb3VwRGF0YSxcblx0XHR9KVxuXHRcdGNvbnN0IHBvc3RHcm91cERhdGEgPSBhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5wb3N0KENhbGVuZGFyU2VydmljZSwgcG9zdERhdGEsIHsgc2Vzc2lvbktleTogdGhpcy5jcnlwdG9XcmFwcGVyLmFlczI1NlJhbmRvbUtleSgpIH0pIC8vIHdlIGV4cGVjdCBhIHNlc3Npb24ga2V5IHRvIGJlIGRlZmluZWQgYXMgdGhlIGVudGl0eSBpcyBtYXJrZWQgZW5jcnlwdGVkXG5cdFx0Y29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKEdyb3VwVHlwZVJlZiwgcG9zdEdyb3VwRGF0YS5ncm91cClcblx0XHRjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5jYWNoZU1hbmFnZW1lbnRGYWNhZGUucmVsb2FkVXNlcigpXG5cblx0XHRyZXR1cm4geyB1c2VyLCBncm91cCB9XG5cdH1cblxuXHRhc3luYyBjcmVhdGVUZW1wbGF0ZUdyb3VwKG5hbWU6IHN0cmluZyk6IFByb21pc2U8SWQ+IHtcblx0XHRjb25zdCBncm91cERhdGEgPSBhd2FpdCB0aGlzLmdlbmVyYXRlVXNlckFyZWFHcm91cERhdGEobmFtZSlcblx0XHRjb25zdCBzZXJ2aWNlRGF0YSA9IGNyZWF0ZVVzZXJBcmVhR3JvdXBQb3N0RGF0YSh7XG5cdFx0XHRncm91cERhdGEsXG5cdFx0fSlcblxuXHRcdGNvbnN0IHBvc3RHcm91cERhdGEgPSBhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5wb3N0KFRlbXBsYXRlR3JvdXBTZXJ2aWNlLCBzZXJ2aWNlRGF0YSwgeyBzZXNzaW9uS2V5OiB0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KCkgfSkgLy8gd2UgZXhwZWN0IGEgc2Vzc2lvbiBrZXkgdG8gYmUgZGVmaW5lZCBhcyB0aGUgZW50aXR5IGlzIG1hcmtlZCBlbmNyeXB0ZWRcblxuXHRcdGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VtZW50RmFjYWRlLnJlbG9hZFVzZXIoKVxuXG5cdFx0cmV0dXJuIHBvc3RHcm91cERhdGEuZ3JvdXBcblx0fVxuXG5cdGFzeW5jIGNyZWF0ZUNvbnRhY3RMaXN0R3JvdXAobmFtZTogc3RyaW5nKTogUHJvbWlzZTxHcm91cD4ge1xuXHRcdGNvbnN0IGdyb3VwRGF0YSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVVc2VyQXJlYUdyb3VwRGF0YShuYW1lKVxuXHRcdGNvbnN0IHNlcnZpY2VEYXRhID0gY3JlYXRlVXNlckFyZWFHcm91cFBvc3REYXRhKHtcblx0XHRcdGdyb3VwRGF0YSxcblx0XHR9KVxuXHRcdGNvbnN0IHBvc3RHcm91cERhdGEgPSBhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5wb3N0KENvbnRhY3RMaXN0R3JvdXBTZXJ2aWNlLCBzZXJ2aWNlRGF0YSwgeyBzZXNzaW9uS2V5OiB0aGlzLmNyeXB0b1dyYXBwZXIuYWVzMjU2UmFuZG9tS2V5KCkgfSkgLy8gd2UgZXhwZWN0IGEgc2Vzc2lvbiBrZXkgdG8gYmUgZGVmaW5lZCBhcyB0aGUgZW50aXR5IGlzIG1hcmtlZCBlbmNyeXB0ZWRcblx0XHRjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoR3JvdXBUeXBlUmVmLCBwb3N0R3JvdXBEYXRhLmdyb3VwKVxuXHRcdGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VtZW50RmFjYWRlLnJlbG9hZFVzZXIoKVxuXG5cdFx0cmV0dXJuIGdyb3VwXG5cdH1cblxuXHRhc3luYyBkZWxldGVDb250YWN0TGlzdEdyb3VwKGdyb3VwUm9vdDogQ29udGFjdExpc3RHcm91cFJvb3QpIHtcblx0XHRjb25zdCBzZXJ2aWNlRGF0YSA9IGNyZWF0ZVVzZXJBcmVhR3JvdXBEZWxldGVEYXRhKHtcblx0XHRcdGdyb3VwOiBncm91cFJvb3QuX2lkLFxuXHRcdH0pXG5cdFx0YXdhaXQgdGhpcy5zZXJ2aWNlRXhlY3V0b3IuZGVsZXRlKENvbnRhY3RMaXN0R3JvdXBTZXJ2aWNlLCBzZXJ2aWNlRGF0YSlcblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NlbWJsZSB0aGUgZGF0YSB0cmFuc2ZlciB0eXBlIHRvIGNyZWF0ZSBhIG5ldyBpbnRlcm5hbCBncm91cCBvbiB0aGUgc2VydmVyLlxuXHQgKiBUaGUgZ3JvdXAga2V5IHZlcnNpb24gaXMgbm90IG5lZWRlZCBiZWNhdXNlIGl0IGlzIGFsd2F5cyB6ZXJvLlxuXHQgKi9cblx0Z2VuZXJhdGVJbnRlcm5hbEdyb3VwRGF0YShcblx0XHRrZXlQYWlyOiBQUUtleVBhaXJzLFxuXHRcdGdyb3VwS2V5OiBBZXNLZXksXG5cdFx0Z3JvdXBJbmZvU2Vzc2lvbktleTogQWVzS2V5LFxuXHRcdGFkbWluR3JvdXBJZDogSWQgfCBudWxsLFxuXHRcdGFkbWluR3JvdXBLZXk6IFZlcnNpb25lZEtleSxcblx0XHRvd25lckdyb3VwS2V5OiBWZXJzaW9uZWRLZXksXG5cdCk6IEludGVybmFsR3JvdXBEYXRhIHtcblx0XHRjb25zdCBhZG1pbkVuY0dyb3VwS2V5ID0gZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXkoYWRtaW5Hcm91cEtleSwgZ3JvdXBLZXkpXG5cdFx0Y29uc3Qgb3duZXJFbmNHcm91cEluZm9TZXNzaW9uS2V5ID0gZW5jcnlwdEtleVdpdGhWZXJzaW9uZWRLZXkob3duZXJHcm91cEtleSwgZ3JvdXBJbmZvU2Vzc2lvbktleSlcblxuXHRcdHJldHVybiBjcmVhdGVJbnRlcm5hbEdyb3VwRGF0YSh7XG5cdFx0XHRwdWJSc2FLZXk6IG51bGwsXG5cdFx0XHRncm91cEVuY1ByaXZSc2FLZXk6IG51bGwsXG5cdFx0XHRwdWJFY2NLZXk6IGtleVBhaXIuZWNjS2V5UGFpci5wdWJsaWNLZXksXG5cdFx0XHRncm91cEVuY1ByaXZFY2NLZXk6IHRoaXMuY3J5cHRvV3JhcHBlci5lbmNyeXB0RWNjS2V5KGdyb3VwS2V5LCBrZXlQYWlyLmVjY0tleVBhaXIucHJpdmF0ZUtleSksXG5cdFx0XHRwdWJLeWJlcktleTogdGhpcy5jcnlwdG9XcmFwcGVyLmt5YmVyUHVibGljS2V5VG9CeXRlcyhrZXlQYWlyLmt5YmVyS2V5UGFpci5wdWJsaWNLZXkpLFxuXHRcdFx0Z3JvdXBFbmNQcml2S3liZXJLZXk6IHRoaXMuY3J5cHRvV3JhcHBlci5lbmNyeXB0S3liZXJLZXkoZ3JvdXBLZXksIGtleVBhaXIua3liZXJLZXlQYWlyLnByaXZhdGVLZXkpLFxuXHRcdFx0YWRtaW5Hcm91cDogYWRtaW5Hcm91cElkLFxuXHRcdFx0YWRtaW5FbmNHcm91cEtleTogYWRtaW5FbmNHcm91cEtleS5rZXksXG5cdFx0XHRvd25lckVuY0dyb3VwSW5mb1Nlc3Npb25LZXk6IG93bmVyRW5jR3JvdXBJbmZvU2Vzc2lvbktleS5rZXksXG5cdFx0XHRhZG1pbktleVZlcnNpb246IGFkbWluRW5jR3JvdXBLZXkuZW5jcnlwdGluZ0tleVZlcnNpb24udG9TdHJpbmcoKSxcblx0XHRcdG93bmVyS2V5VmVyc2lvbjogb3duZXJFbmNHcm91cEluZm9TZXNzaW9uS2V5LmVuY3J5cHRpbmdLZXlWZXJzaW9uLnRvU3RyaW5nKCksXG5cdFx0fSlcblx0fVxuXG5cdGFzeW5jIGFkZFVzZXJUb0dyb3VwKHVzZXI6IFVzZXIsIGdyb3VwSWQ6IElkKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgdXNlckdyb3VwS2V5ID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50R3JvdXBLZXlWaWFBZG1pbkVuY0dLZXkodXNlci51c2VyR3JvdXAuZ3JvdXApXG5cdFx0Y29uc3QgZ3JvdXBLZXkgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRHcm91cEtleVZpYUFkbWluRW5jR0tleShncm91cElkKVxuXHRcdGNvbnN0IHN5bUVuY0dLZXkgPSBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleSh1c2VyR3JvdXBLZXksIGdyb3VwS2V5Lm9iamVjdClcblx0XHRjb25zdCBkYXRhID0gY3JlYXRlTWVtYmVyc2hpcEFkZERhdGEoe1xuXHRcdFx0dXNlcjogdXNlci5faWQsXG5cdFx0XHRncm91cDogZ3JvdXBJZCxcblx0XHRcdHN5bUVuY0dLZXk6IHN5bUVuY0dLZXkua2V5LFxuXHRcdFx0Z3JvdXBLZXlWZXJzaW9uOiBTdHJpbmcoZ3JvdXBLZXkudmVyc2lvbiksXG5cdFx0XHRzeW1LZXlWZXJzaW9uOiBzeW1FbmNHS2V5LmVuY3J5cHRpbmdLZXlWZXJzaW9uLnRvU3RyaW5nKCksXG5cdFx0fSlcblx0XHRhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5wb3N0KE1lbWJlcnNoaXBTZXJ2aWNlLCBkYXRhKVxuXHR9XG5cblx0YXN5bmMgcmVtb3ZlVXNlckZyb21Hcm91cCh1c2VySWQ6IElkLCBncm91cElkOiBJZCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGRhdGEgPSBjcmVhdGVNZW1iZXJzaGlwUmVtb3ZlRGF0YSh7XG5cdFx0XHR1c2VyOiB1c2VySWQsXG5cdFx0XHRncm91cDogZ3JvdXBJZCxcblx0XHR9KVxuXHRcdGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLmRlbGV0ZShNZW1iZXJzaGlwU2VydmljZSwgZGF0YSlcblx0fVxuXG5cdGFzeW5jIGRlYWN0aXZhdGVHcm91cChncm91cDogR3JvdXAsIHJlc3RvcmU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBkYXRhID0gY3JlYXRlRGVsZXRlR3JvdXBEYXRhKHtcblx0XHRcdGdyb3VwOiBncm91cC5faWQsXG5cdFx0XHRyZXN0b3JlLFxuXHRcdH0pXG5cblx0XHRpZiAoZ3JvdXAudHlwZSA9PT0gR3JvdXBUeXBlLk1haWwpIHtcblx0XHRcdGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLmRlbGV0ZShNYWlsR3JvdXBTZXJ2aWNlLCBkYXRhKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGdyb3VwIHR5cGUgZm9yIGRlYWN0aXZhdGlvblwiKVxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGdldEdyb3VwS2V5VmlhVXNlcihncm91cElkOiBJZCwgdmVyc2lvbjogS2V5VmVyc2lvbiwgdmlhVXNlcjogSWQpOiBQcm9taXNlPEFlc0tleT4ge1xuXHRcdGNvbnN0IGN1cnJlbnRHcm91cEtleSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudEdyb3VwS2V5VmlhVXNlcihncm91cElkLCB2aWFVc2VyKVxuXHRcdHJldHVybiB0aGlzLmtleUxvYWRlckZhY2FkZS5sb2FkU3ltR3JvdXBLZXkoZ3JvdXBJZCwgdmVyc2lvbiwgY3VycmVudEdyb3VwS2V5KVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhIGdyb3VwIGtleSBmb3IgYW55IGdyb3VwIHdlIGFyZSBhZG1pbiBhbmQga25vdyBzb21lIG1lbWJlciBvZi5cblx0ICpcblx0ICogVW5saWtlIHtAbGluayBnZXRDdXJyZW50R3JvdXBLZXlWaWFBZG1pbkVuY0dLZXl9IHRoaXMgc2hvdWxkIHdvcmsgZm9yIGFueSBncm91cCBiZWNhdXNlIHdlIHdpbGwgYWN0dWFsbHkgZ28gYSBcImxvbmdcIiByb3V0ZSBvZiBkZWNyeXB0aW5nIHVzZXJHcm91cEtleSBvZiB0aGVcblx0ICogbWVtYmVyIGFuZCBkZWNyeXB0aW5nIGdyb3VwIGtleSB3aXRoIHRoYXQuXG5cdCAqL1xuXHRhc3luYyBnZXRDdXJyZW50R3JvdXBLZXlWaWFVc2VyKGdyb3VwSWQ6IElkLCB2aWFVc2VyOiBJZCk6IFByb21pc2U8VmVyc2lvbmVkS2V5PiB7XG5cdFx0Y29uc3QgdXNlciA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoVXNlclR5cGVSZWYsIHZpYVVzZXIpXG5cdFx0Y29uc3QgbWVtYmVyc2hpcCA9IHVzZXIubWVtYmVyc2hpcHMuZmluZCgobSkgPT4gbS5ncm91cCA9PT0gZ3JvdXBJZClcblx0XHRpZiAobWVtYmVyc2hpcCA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVzZXIgZG9lc24ndCBoYXZlIHRoaXMgZ3JvdXAgbWVtYmVyc2hpcCEgVXNlcjogJHt2aWFVc2VyfSBncm91cElkOiAke2dyb3VwSWR9YClcblx0XHR9XG5cdFx0Y29uc3QgcmVxdWlyZWRVc2VyR3JvdXBLZXlWZXJzaW9uID0gbWVtYmVyc2hpcC5zeW1LZXlWZXJzaW9uXG5cdFx0Y29uc3QgcmVxdWlyZWRVc2VyR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmdldEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5KHVzZXIudXNlckdyb3VwLmdyb3VwLCBwYXJzZUtleVZlcnNpb24ocmVxdWlyZWRVc2VyR3JvdXBLZXlWZXJzaW9uKSlcblxuXHRcdGNvbnN0IGtleSA9IHRoaXMuY3J5cHRvV3JhcHBlci5kZWNyeXB0S2V5KHJlcXVpcmVkVXNlckdyb3VwS2V5LCBtZW1iZXJzaGlwLnN5bUVuY0dLZXkpXG5cdFx0Y29uc3QgdmVyc2lvbiA9IHBhcnNlS2V5VmVyc2lvbihtZW1iZXJzaGlwLmdyb3VwS2V5VmVyc2lvbilcblxuXHRcdHJldHVybiB7IG9iamVjdDoga2V5LCB2ZXJzaW9uIH1cblx0fVxuXG5cdGFzeW5jIGdldEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5KGdyb3VwSWQ6IElkLCB2ZXJzaW9uOiBLZXlWZXJzaW9uKTogUHJvbWlzZTxBZXNLZXk+IHtcblx0XHRpZiAodGhpcy51c2VyRmFjYWRlLmhhc0dyb3VwKGdyb3VwSWQpKSB7XG5cdFx0XHQvLyBlLmcuIEkgYW0gYSBnbG9iYWwgYWRtaW4gYW5kIHdhbnQgdG8gYWRkIGFub3RoZXIgdXNlciB0byB0aGUgZ2xvYmFsIGFkbWluIGdyb3VwXG5cdFx0XHRyZXR1cm4gdGhpcy5rZXlMb2FkZXJGYWNhZGUubG9hZFN5bUdyb3VwS2V5KGdyb3VwSWQsIHZlcnNpb24pXG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGN1cnJlbnRHcm91cEtleSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5KGdyb3VwSWQpXG5cdFx0XHRyZXR1cm4gdGhpcy5rZXlMb2FkZXJGYWNhZGUubG9hZFN5bUdyb3VwS2V5KGdyb3VwSWQsIHZlcnNpb24sIGN1cnJlbnRHcm91cEtleSlcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZ3JvdXAgY3VycmVudGx5IGhhcyBhbiBhZG1pbkVuY0dLZXkuIFRoaXMgbWF5IGJlIGFuIGFzeW1tZXRyaWNhbGx5IGVuY3J5cHRlZCBvbmUuXG5cdCAqL1xuXHRoYXNBZG1pbkVuY0dLZXkoZ3JvdXA6IEdyb3VwKSB7XG5cdFx0cmV0dXJuIChncm91cC5hZG1pbkdyb3VwRW5jR0tleSAhPSBudWxsICYmIGdyb3VwLmFkbWluR3JvdXBFbmNHS2V5Lmxlbmd0aCAhPT0gMCkgfHwgZ3JvdXAucHViQWRtaW5Hcm91cEVuY0dLZXkgIT0gbnVsbFxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhIGdyb3VwIGtleSBmb3IgY2VydGFpbiBncm91cCB0eXBlcy5cblx0ICpcblx0ICogU29tZSBncm91cHMgKGUuZy4gdXNlciBncm91cHMgb3Igc2hhcmVkIG1haWxib3hlcykgaGF2ZSBhZG1pbkdyb3VwRW5jR0tleSBzZXQgb24gY3JlYXRpb24uIEZvciB0aG9zZSBncm91cHMgd2UgY2FuIGZhaXJseSBlYXNpbHkgZ2V0IGEgZ3JvdXAga2V5IHdpdGhvdXRcblx0ICogZGVjcnlwdGluZyB1c2VyR3JvdXBLZXkgb2Ygc29tZSBtZW1iZXIgb2YgdGhhdCBncm91cC5cblx0ICovXG5cdGFzeW5jIGdldEN1cnJlbnRHcm91cEtleVZpYUFkbWluRW5jR0tleShncm91cElkOiBJZCk6IFByb21pc2U8VmVyc2lvbmVkS2V5PiB7XG5cdFx0aWYgKHRoaXMudXNlckZhY2FkZS5oYXNHcm91cChncm91cElkKSkge1xuXHRcdFx0Ly8gZS5nLiBJIGFtIGEgZ2xvYmFsIGFkbWluIGFuZCB3YW50IHRvIGFkZCBhbm90aGVyIHVzZXIgdG8gdGhlIGdsb2JhbCBhZG1pbiBncm91cFxuXHRcdFx0Ly8gb3IgSSBhbSBhbiBhZG1pbiBhbmQgSSBhbSBhIG1lbWJlciBvZiB0aGUgdGFyZ2V0IGdyb3VwIChlZzogc2hhcmVkIG1haWxib3hlcylcblx0XHRcdHJldHVybiB0aGlzLmtleUxvYWRlckZhY2FkZS5nZXRDdXJyZW50U3ltR3JvdXBLZXkoZ3JvdXBJZClcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlbWVudEZhY2FkZS5yZWxvYWRHcm91cChncm91cElkKVxuXHRcdFx0aWYgKCF0aGlzLmhhc0FkbWluRW5jR0tleShncm91cCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFByb2dyYW1taW5nRXJyb3IoXCJHcm91cCBkb2Vzbid0IGhhdmUgYWRtaW5Hcm91cEVuY0dLZXksIHlvdSBjYW4ndCBnZXQgZ3JvdXAga2V5IHRoaXMgd2F5XCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoIShncm91cC5hZG1pbiAmJiB0aGlzLnVzZXJGYWNhZGUuaGFzR3JvdXAoZ3JvdXAuYWRtaW4pKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSB1c2VyIGlzIG5vdCBhIG1lbWJlciBvZiB0aGUgYWRtaW4gZ3JvdXAgJHtncm91cC5hZG1pbn0gd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSBncm91cCBrZXkgZm9yIGdyb3VwICR7Z3JvdXBJZH1gKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlLmcuIEkgYW0gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIHRoYXQgYWRtaW5pc3RyYXRlcyBncm91cCBHIGFuZCB3YW50IHRvIGFkZCBhIG5ldyBtZW1iZXIgdG8gR1xuXHRcdFx0Y29uc3QgcmVxdWlyZWRBZG1pbktleVZlcnNpb24gPSBwYXJzZUtleVZlcnNpb24oZ3JvdXAuYWRtaW5Hcm91cEtleVZlcnNpb24gPz8gXCIwXCIpXG5cdFx0XHRpZiAoZ3JvdXAuYWRtaW5Hcm91cEVuY0dLZXkgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5kZWNyeXB0VmlhU3ltbWV0cmljQWRtaW5HS2V5KFxuXHRcdFx0XHRcdGdyb3VwLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGtleTogZ3JvdXAuYWRtaW5Hcm91cEVuY0dLZXksXG5cdFx0XHRcdFx0XHRlbmNyeXB0aW5nS2V5VmVyc2lvbjogcmVxdWlyZWRBZG1pbktleVZlcnNpb24sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRwYXJzZUtleVZlcnNpb24oZ3JvdXAuZ3JvdXBLZXlWZXJzaW9uKSxcblx0XHRcdFx0KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYXNzdW1lIHRoYXQgdGhlIGdyb3VwIGlzIGEgdXNlckdyb3VwLiBvdGhlcndpc2UgcHViQWRtaW5Hcm91cEVuY0dLZXkgY2Fubm90IGJlIHNldFxuXHRcdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5kZWNyeXB0VmlhQXN5bW1ldHJpY0FkbWluR0tleShncm91cCwgYXNzZXJ0Tm90TnVsbChncm91cC5wdWJBZG1pbkdyb3VwRW5jR0tleSkpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBkZWNyeXB0VmlhU3ltbWV0cmljQWRtaW5HS2V5KGdyb3VwOiBHcm91cCwgZW5jcnlwdGVkR3JvdXBLZXk6IFZlcnNpb25lZEVuY3J5cHRlZEtleSwgZW5jcnlwdGVkS2V5VmVyc2lvbjogS2V5VmVyc2lvbik6IFByb21pc2U8VmVyc2lvbmVkS2V5PiB7XG5cdFx0Y29uc3QgcmVxdWlyZWRBZG1pbkdyb3VwS2V5ID0gYXdhaXQgdGhpcy5rZXlMb2FkZXJGYWNhZGUubG9hZFN5bUdyb3VwS2V5KGFzc2VydE5vdE51bGwoZ3JvdXAuYWRtaW4pLCBlbmNyeXB0ZWRHcm91cEtleS5lbmNyeXB0aW5nS2V5VmVyc2lvbilcblx0XHRjb25zdCBkZWNyeXB0ZWRLZXkgPSB0aGlzLmNyeXB0b1dyYXBwZXIuZGVjcnlwdEtleShyZXF1aXJlZEFkbWluR3JvdXBLZXksIGVuY3J5cHRlZEdyb3VwS2V5LmtleSlcblx0XHRyZXR1cm4geyBvYmplY3Q6IGRlY3J5cHRlZEtleSwgdmVyc2lvbjogZW5jcnlwdGVkS2V5VmVyc2lvbiB9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHVzZXJHcm91cCB0aGUgZ3JvdXAgZm9yIHdoaWNoIHdlIGFyZSB0cnlpbmcgdG8gZ2V0IHRoZSBrZXlcblx0ICogQHBhcmFtIHB1YkFkbWluRW5jVXNlcktleURhdGEgc29tZSB2ZXJzaW9uIG9mIHRoZSBncm91cCBrZXkgZW5jcnlwdGVkIHdpdGggc29tZSB2ZXJzaW9uIG9mIHRoZSBwdWJsaWMgYWRtaW4gZ3JvdXAga2V5LiBUaGlzIGNhbiBiZSB0aGUgY3VycmVudCBvbmUgZnJvbSB0aGUgZ3JvdXAgb3Igb25lIG9mIHRoZSBmb3JtZXIgZ3JvdXAga2V5cy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgZGVjcnlwdFZpYUFzeW1tZXRyaWNBZG1pbkdLZXkodXNlckdyb3VwOiBHcm91cCwgcHViQWRtaW5FbmNVc2VyS2V5RGF0YTogUHViRW5jS2V5RGF0YSk6IFByb21pc2U8VmVyc2lvbmVkS2V5PiB7XG5cdFx0Y29uc3QgcmVxdWlyZWRBZG1pbkdyb3VwS2V5UGFpciA9IGF3YWl0IHRoaXMua2V5TG9hZGVyRmFjYWRlLmxvYWRLZXlwYWlyKFxuXHRcdFx0YXNzZXJ0Tm90TnVsbCh1c2VyR3JvdXAuYWRtaW4pLFxuXHRcdFx0cGFyc2VLZXlWZXJzaW9uKHB1YkFkbWluRW5jVXNlcktleURhdGEucmVjaXBpZW50S2V5VmVyc2lvbiksXG5cdFx0KVxuXHRcdGNvbnN0IGRlY3J5cHRlZFVzZXJHcm91cEtleSA9IChcblx0XHRcdGF3YWl0IHRoaXMuYXN5bW1ldHJpY0NyeXB0b0ZhY2FkZS5kZWNyeXB0U3ltS2V5V2l0aEtleVBhaXJBbmRBdXRoZW50aWNhdGUocmVxdWlyZWRBZG1pbkdyb3VwS2V5UGFpciwgcHViQWRtaW5FbmNVc2VyS2V5RGF0YSwge1xuXHRcdFx0XHRpZGVudGlmaWVyOiB1c2VyR3JvdXAuX2lkLFxuXHRcdFx0XHRpZGVudGlmaWVyVHlwZTogUHVibGljS2V5SWRlbnRpZmllclR5cGUuR1JPVVBfSUQsXG5cdFx0XHR9KVxuXHRcdCkuZGVjcnlwdGVkQWVzS2V5XG5cblx0XHQvLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCByZWN1cnNpdmVseS4gdGhlcmVmb3JlIHdlIG11c3Qgbm90IHJldHVybiB0aGUgZ3JvdXAga2V5IHZlcnNpb24gZnJvbSB0aGUgZ3JvdXAgYnV0IGZyb20gdGhlIHB1YkFkbWluRW5jVXNlcktleURhdGFcblx0XHRjb25zdCB2ZXJzaW9uZWREZWNyeXB0ZWRVc2VyR3JvdXBLZXkgPSB7XG5cdFx0XHRvYmplY3Q6IGRlY3J5cHRlZFVzZXJHcm91cEtleSxcblx0XHRcdHZlcnNpb246IHBhcnNlS2V5VmVyc2lvbihhc3NlcnROb3ROdWxsKHB1YkFkbWluRW5jVXNlcktleURhdGEuc3ltS2V5TWFjKS50YWdnZWRLZXlWZXJzaW9uKSxcblx0XHR9XG5cblx0XHRhd2FpdCB0aGlzLnZlcmlmeVVzZXJHcm91cEtleU1hYyhwdWJBZG1pbkVuY1VzZXJLZXlEYXRhLCB1c2VyR3JvdXAsIHZlcnNpb25lZERlY3J5cHRlZFVzZXJHcm91cEtleSlcblxuXHRcdHJldHVybiB2ZXJzaW9uZWREZWNyeXB0ZWRVc2VyR3JvdXBLZXlcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgdmVyaWZ5VXNlckdyb3VwS2V5TWFjKHB1YkVuY0tleURhdGE6IFB1YkVuY0tleURhdGEsIHVzZXJHcm91cDogR3JvdXAsIHJlY2VpdmVkVXNlckdyb3VwS2V5OiBWZXJzaW9uZWRLZXkpIHtcblx0XHRjb25zdCBnaXZlblVzZXJHcm91cEtleU1hYyA9IGJyYW5kS2V5TWFjKGFzc2VydE5vdE51bGwocHViRW5jS2V5RGF0YS5zeW1LZXlNYWMpKVxuXG5cdFx0Ly8gVGhlIGdpdmVuIG1hYyBpcyBhdXRoZW50aWNhdGVkIGJ5IHRoZSBwcmV2aW91cyB1c2VyIGdyb3VwIGtleSwgc28gd2UgY2FuIGdldCB0aGUgdmVyc2lvbiBmcm9tIHRoZXJlLlxuXHRcdGNvbnN0IHByZXZpb3VzVXNlckdyb3VwS2V5VmVyc2lvbiA9IHBhcnNlS2V5VmVyc2lvbihnaXZlblVzZXJHcm91cEtleU1hYy50YWdnaW5nS2V5VmVyc2lvbilcblx0XHRjb25zdCByZWNpcGllbnRBZG1pbkdyb3VwS2V5VmVyc2lvbiA9IHBhcnNlS2V5VmVyc2lvbihwdWJFbmNLZXlEYXRhLnJlY2lwaWVudEtleVZlcnNpb24pXG5cblx0XHQvLyBnZXQgcHJldmlvdXMgdXNlciBncm91cCBrZXk6IGFnMSAtPiBhZzAgLT4gdWcwXG5cdFx0Y29uc3QgZm9ybWVyR3JvdXBLZXkgPSBhd2FpdCB0aGlzLmtleUxvYWRlckZhY2FkZS5sb2FkRm9ybWVyR3JvdXBLZXlJbnN0YW5jZSh1c2VyR3JvdXAsIHByZXZpb3VzVXNlckdyb3VwS2V5VmVyc2lvbilcblx0XHRsZXQgcHJldmlvdXNVc2VyR3JvdXBLZXk6IFZlcnNpb25lZEtleVxuXHRcdGlmIChmb3JtZXJHcm91cEtleS5hZG1pbkdyb3VwRW5jR0tleSAhPSBudWxsKSB7XG5cdFx0XHRwcmV2aW91c1VzZXJHcm91cEtleSA9IGF3YWl0IHRoaXMuZGVjcnlwdFZpYVN5bW1ldHJpY0FkbWluR0tleShcblx0XHRcdFx0dXNlckdyb3VwLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0a2V5OiBmb3JtZXJHcm91cEtleS5hZG1pbkdyb3VwRW5jR0tleSxcblx0XHRcdFx0XHRlbmNyeXB0aW5nS2V5VmVyc2lvbjogcGFyc2VLZXlWZXJzaW9uKGFzc2VydE5vdE51bGwoZm9ybWVyR3JvdXBLZXkuYWRtaW5Hcm91cEtleVZlcnNpb24pKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0cHJldmlvdXNVc2VyR3JvdXBLZXlWZXJzaW9uLFxuXHRcdFx0KVxuXHRcdH0gZWxzZSBpZiAoZm9ybWVyR3JvdXBLZXkucHViQWRtaW5Hcm91cEVuY0dLZXkgIT0gbnVsbCkge1xuXHRcdFx0Y29uc3QgdXNlckdyb3VwS2V5TWFjID0gYXNzZXJ0Tm90TnVsbChmb3JtZXJHcm91cEtleS5wdWJBZG1pbkdyb3VwRW5jR0tleS5zeW1LZXlNYWMpXG5cdFx0XHQvLyByZWN1cnNlLCBidXQgZXhwZWN0IHRvIGhpdCB0aGUgZW5kIF9iZWZvcmVfIHZlcnNpb24gMCwgd2hpY2ggc2hvdWxkIGFsd2F5cyBiZSBzeW1tZXRyaWNhbGx5IGVuY3J5cHRlZFxuXHRcdFx0aWYgKHVzZXJHcm91cEtleU1hYy50YWdnZWRLZXlWZXJzaW9uID09PSBcIjBcIikge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHV0YW5vdGFFcnJvcihcIlVzZXJHcm91cEtleU5vdFRydXN0ZWRFcnJvclwiLCBcImNhbm5vdCBlc3RhYmxpc2ggdHJ1c3Qgb24gdGhlIHVzZXIgZ3JvdXAga2V5XCIpXG5cdFx0XHR9XG5cdFx0XHRwcmV2aW91c1VzZXJHcm91cEtleSA9IGF3YWl0IHRoaXMuZGVjcnlwdFZpYUFzeW1tZXRyaWNBZG1pbkdLZXkodXNlckdyb3VwLCBmb3JtZXJHcm91cEtleS5wdWJBZG1pbkdyb3VwRW5jR0tleSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IFR1dGFub3RhRXJyb3IoXCJNaXNzaW5nQWRtaW5FbmNHcm91cEtleUVycm9yXCIsIFwiY2Fubm90IHZlcmlmeSB1c2VyIGdyb3VwIGtleVwiKVxuXHRcdH1cblxuXHRcdHRoaXMua2V5QXV0aGVudGljYXRpb25GYWNhZGUudmVyaWZ5VGFnKFxuXHRcdFx0e1xuXHRcdFx0XHR0YWdUeXBlOiBcIlVTRVJfR1JPVVBfS0VZX1RBR1wiLFxuXHRcdFx0XHRzb3VyY2VPZlRydXN0OiB7IGN1cnJlbnRVc2VyR3JvdXBLZXk6IHByZXZpb3VzVXNlckdyb3VwS2V5Lm9iamVjdCB9LFxuXHRcdFx0XHR1bnRydXN0ZWRLZXk6IHsgbmV3VXNlckdyb3VwS2V5OiByZWNlaXZlZFVzZXJHcm91cEtleS5vYmplY3QgfSxcblx0XHRcdFx0YmluZGluZ0RhdGE6IHtcblx0XHRcdFx0XHR1c2VyR3JvdXBJZDogdXNlckdyb3VwLl9pZCxcblx0XHRcdFx0XHRhZG1pbkdyb3VwSWQ6IGFzc2VydE5vdE51bGwodXNlckdyb3VwLmFkbWluKSxcblx0XHRcdFx0XHRjdXJyZW50VXNlckdyb3VwS2V5VmVyc2lvbjogcHJldmlvdXNVc2VyR3JvdXBLZXkudmVyc2lvbixcblx0XHRcdFx0XHRuZXdVc2VyR3JvdXBLZXlWZXJzaW9uOiByZWNlaXZlZFVzZXJHcm91cEtleS52ZXJzaW9uLFxuXHRcdFx0XHRcdG5ld0FkbWluR3JvdXBLZXlWZXJzaW9uOiByZWNpcGllbnRBZG1pbkdyb3VwS2V5VmVyc2lvbixcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0XHRnaXZlblVzZXJHcm91cEtleU1hYy50YWcsXG5cdFx0KVxuXHR9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7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