import { BoundedExecutor, LazyLoaded } from "./dist2-chunk.js";
import { ContactTypeRef } from "./TypeRefs-chunk.js";
import { cleanMailAddress } from "./CommonCalendarUtils-chunk.js";
import { createNewContact, isTutaMailAddress } from "./SharedMailUtils-chunk.js";
import { RecipientType } from "./Recipient-chunk.js";
import { getContactDisplayName } from "./ContactUtils-chunk.js";

//#region src/common/api/main/RecipientsModel.ts
let ResolveMode = function(ResolveMode$1) {
	ResolveMode$1[ResolveMode$1["Lazy"] = 0] = "Lazy";
	ResolveMode$1[ResolveMode$1["Eager"] = 1] = "Eager";
	return ResolveMode$1;
}({});
var RecipientsModel = class {
	executor = new BoundedExecutor(5);
	constructor(contactModel, loginController, mailFacade, entityClient) {
		this.contactModel = contactModel;
		this.loginController = loginController;
		this.mailFacade = mailFacade;
		this.entityClient = entityClient;
	}
	/**
	* Start resolving a recipient
	* If resolveLazily === true, Then resolution will not be initiated (i.e. no server calls will be made) until the first call to `resolved`
	*/
	resolve(recipient, resolveMode) {
		return new ResolvableRecipientImpl(recipient, this.contactModel, this.loginController, (mailAddress) => this.executor.run(this.resolveRecipientType(mailAddress)), this.entityClient, resolveMode);
	}
	resolveRecipientType = (mailAddress) => async () => {
		const keyData = await this.mailFacade.getRecipientKeyData(mailAddress);
		return keyData == null ? RecipientType.EXTERNAL : RecipientType.INTERNAL;
	};
};
var ResolvableRecipientImpl = class {
	_address;
	_name;
	lazyType;
	lazyContact;
	initialType = RecipientType.UNKNOWN;
	initialContact = null;
	overrideContact = null;
	get address() {
		return this._address;
	}
	get name() {
		return this._name ?? "";
	}
	get type() {
		return this.lazyType.getSync() ?? this.initialType;
	}
	get contact() {
		return this.lazyContact.getSync() ?? this.initialContact;
	}
	constructor(arg, contactModel, loginController, typeResolver, entityClient, resolveMode) {
		this.contactModel = contactModel;
		this.loginController = loginController;
		this.typeResolver = typeResolver;
		this.entityClient = entityClient;
		if (isTutaMailAddress(arg.address) || arg.type === RecipientType.INTERNAL) {
			this.initialType = RecipientType.INTERNAL;
			this._address = cleanMailAddress(arg.address);
		} else if (arg.type) {
			this.initialType = arg.type;
			this._address = arg.address;
		} else this._address = arg.address;
		this._name = arg.name ?? null;
		if (!(arg.contact instanceof Array)) this.initialContact = arg.contact ?? null;
		this.lazyType = new LazyLoaded(() => this.resolveType());
		this.lazyContact = new LazyLoaded(async () => {
			const contact = await this.resolveContact(arg.contact);
			if (contact != null && (this._name == null || this._name === "")) this._name = getContactDisplayName(contact);
			return contact;
		});
		if (resolveMode === ResolveMode.Eager) {
			this.lazyType.load();
			this.lazyContact.load();
		}
	}
	setName(newName) {
		this._name = newName;
	}
	setContact(newContact) {
		this.overrideContact = newContact;
		this.lazyContact.reload();
	}
	async resolved() {
		await Promise.all([this.lazyType.getAsync(), this.lazyContact.getAsync()]);
		return {
			address: this.address,
			name: this.name,
			type: this.type,
			contact: this.contact
		};
	}
	isResolved() {
		return this.lazyType.isLoaded() && this.lazyContact.isLoaded();
	}
	whenResolved(handler) {
		this.resolved().then(handler);
		return this;
	}
	/**
	* Determine whether recipient is INTERNAL or EXTERNAL based on the existence of key data (external recipients don't have any)
	*/
	async resolveType() {
		if (this.initialType === RecipientType.UNKNOWN) {
			const cleanedAddress = cleanMailAddress(this.address);
			const recipientType = await this.typeResolver(cleanedAddress);
			if (recipientType === RecipientType.INTERNAL) this._address = cleanedAddress;
			return recipientType;
		} else return this.initialType;
	}
	/**
	* Resolve the recipients contact.
	* If {@param contact} is an Id, the contact will be loaded directly
	* Otherwise, the contact will be searched for in the ContactModel
	*/
	async resolveContact(contact) {
		try {
			if (this.overrideContact) return this.overrideContact;
else if (await this.contactModel.getContactListId() == null) {
				console.log("can't resolve contacts for users with no contact list id");
				return null;
			} else if (contact instanceof Array) return await this.entityClient.load(ContactTypeRef, contact);
else if (contact == null) {
				const foundContact = await this.contactModel.searchForContact(this.address);
				if (foundContact) return foundContact;
else {
					await this.lazyType;
					return createNewContact(this.loginController.getUserController().user, this.address, this.name);
				}
			} else return contact;
		} catch (e) {
			console.log("error resolving contact", e);
			return null;
		}
	}
};

//#endregion
export { RecipientsModel, ResolveMode };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVjaXBpZW50c01vZGVsLWNodW5rLmpzIiwibmFtZXMiOlsiY29udGFjdE1vZGVsOiBDb250YWN0TW9kZWwiLCJsb2dpbkNvbnRyb2xsZXI6IExvZ2luQ29udHJvbGxlciIsIm1haWxGYWNhZGU6IE1haWxGYWNhZGUiLCJlbnRpdHlDbGllbnQ6IEVudGl0eUNsaWVudCIsInJlY2lwaWVudDogUGFydGlhbFJlY2lwaWVudCIsInJlc29sdmVNb2RlOiBSZXNvbHZlTW9kZSIsIm1haWxBZGRyZXNzOiBzdHJpbmciLCJhcmc6IFBhcnRpYWxSZWNpcGllbnQiLCJ0eXBlUmVzb2x2ZXI6IChtYWlsQWRkcmVzczogc3RyaW5nKSA9PiBQcm9taXNlPFJlY2lwaWVudFR5cGU+IiwibmV3TmFtZTogc3RyaW5nIiwibmV3Q29udGFjdDogQ29udGFjdCIsImhhbmRsZXI6IChyZXNvbHZlZFJlY2lwaWVudDogUmVjaXBpZW50KSA9PiB2b2lkIiwiY29udGFjdDogQ29udGFjdCB8IElkVHVwbGUgfCBOb25lIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9hcGkvbWFpbi9SZWNpcGllbnRzTW9kZWwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDb250YWN0TW9kZWwgfSBmcm9tIFwiLi4vLi4vY29udGFjdHNGdW5jdGlvbmFsaXR5L0NvbnRhY3RNb2RlbC5qc1wiXG5pbXBvcnQgdHlwZSB7IExvZ2luQ29udHJvbGxlciB9IGZyb20gXCIuL0xvZ2luQ29udHJvbGxlci5qc1wiXG5pbXBvcnQgdHlwZSB7IE1haWxGYWNhZGUgfSBmcm9tIFwiLi4vd29ya2VyL2ZhY2FkZXMvbGF6eS9NYWlsRmFjYWRlLmpzXCJcbmltcG9ydCB0eXBlIHsgRW50aXR5Q2xpZW50IH0gZnJvbSBcIi4uL2NvbW1vbi9FbnRpdHlDbGllbnQuanNcIlxuaW1wb3J0IHsgZ2V0Q29udGFjdERpc3BsYXlOYW1lIH0gZnJvbSBcIi4uLy4uL2NvbnRhY3RzRnVuY3Rpb25hbGl0eS9Db250YWN0VXRpbHMuanNcIlxuaW1wb3J0IHsgUGFydGlhbFJlY2lwaWVudCwgUmVjaXBpZW50LCBSZWNpcGllbnRUeXBlIH0gZnJvbSBcIi4uL2NvbW1vbi9yZWNpcGllbnRzL1JlY2lwaWVudC5qc1wiXG5pbXBvcnQgeyBCb3VuZGVkRXhlY3V0b3IsIExhenlMb2FkZWQgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzXCJcbmltcG9ydCB7IENvbnRhY3QsIENvbnRhY3RUeXBlUmVmIH0gZnJvbSBcIi4uL2VudGl0aWVzL3R1dGFub3RhL1R5cGVSZWZzXCJcbmltcG9ydCB7IGNsZWFuTWFpbEFkZHJlc3MgfSBmcm9tIFwiLi4vY29tbW9uL3V0aWxzL0NvbW1vbkNhbGVuZGFyVXRpbHMuanNcIlxuaW1wb3J0IHsgY3JlYXRlTmV3Q29udGFjdCwgaXNUdXRhTWFpbEFkZHJlc3MgfSBmcm9tIFwiLi4vLi4vbWFpbEZ1bmN0aW9uYWxpdHkvU2hhcmVkTWFpbFV0aWxzLmpzXCJcblxuLyoqXG4gKiBBIHJlY2lwaWVudCB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBvYnRhaW4gY29udGFjdCBhbmQgcmVjaXBpZW50IHR5cGVcbiAqIEl0IGlzIGRlZmluZWQgYXMgYW4gaW50ZXJmYWNlLCBiZWNhdXNlIGl0IHNob3VsZCBvbmx5IGJlIGNyZWF0ZWQgdXNpbmcgUmVjaXBpZW50c01vZGVsLnJlc29sdmVcbiAqIHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbnN0cnVjdGluZyBvbmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZhYmxlUmVjaXBpZW50IGV4dGVuZHMgUmVjaXBpZW50IHtcblx0LyoqIGdldCB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIHJlY2lwaWVudCwgd2hlbiBpdCdzIHJlYWR5ICovXG5cdHJlc29sdmVkKCk6IFByb21pc2U8UmVjaXBpZW50PlxuXG5cdC8qKiBjaGVjayBpZiByZXNvbHV0aW9uIGlzIGNvbXBsZXRlICovXG5cdGlzUmVzb2x2ZWQoKTogYm9vbGVhblxuXG5cdC8qKiBwcm92aWRlIGEgaGFuZGxlciB0byBydW4gd2hlbiByZXNvbHV0aW9uIGlzIGRvbmUsIGhhbmR5IGZvciBjaGFpbmluZyAqL1xuXHR3aGVuUmVzb2x2ZWQob25SZXNvbHZlZDogKHJlc29sdmVkUmVjaXBpZW50OiBSZWNpcGllbnQpID0+IHZvaWQpOiB0aGlzXG5cblx0LyoqIHVwZGF0ZSB0aGUgY29udGFjdC4gd2lsbCBvdmVycmlkZSB3aGF0ZXZlciBjb250YWN0IGdldHMgcmVzb2x2ZWQgKi9cblx0c2V0Q29udGFjdChjb250YWN0OiBDb250YWN0KTogdm9pZFxuXG5cdC8qKiB1cGRhdGUgdGhlIG5hbWUuIHdpbGwgb3ZlcnJpZGUgd2hhdGV2ZXIgdGhlIG5hbWUgaGFzIHJlc29sdmVkIHRvICovXG5cdHNldE5hbWUobmFtZTogc3RyaW5nKTogdm9pZFxufVxuXG5leHBvcnQgZW51bSBSZXNvbHZlTW9kZSB7XG5cdExhenksXG5cdEVhZ2VyLFxufVxuXG5leHBvcnQgY2xhc3MgUmVjaXBpZW50c01vZGVsIHtcblx0cHJpdmF0ZSBleGVjdXRvciA9IG5ldyBCb3VuZGVkRXhlY3V0b3IoNSlcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIHJlYWRvbmx5IGNvbnRhY3RNb2RlbDogQ29udGFjdE1vZGVsLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgbG9naW5Db250cm9sbGVyOiBMb2dpbkNvbnRyb2xsZXIsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBtYWlsRmFjYWRlOiBNYWlsRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgZW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQsXG5cdCkge31cblxuXHQvKipcblx0ICogU3RhcnQgcmVzb2x2aW5nIGEgcmVjaXBpZW50XG5cdCAqIElmIHJlc29sdmVMYXppbHkgPT09IHRydWUsIFRoZW4gcmVzb2x1dGlvbiB3aWxsIG5vdCBiZSBpbml0aWF0ZWQgKGkuZS4gbm8gc2VydmVyIGNhbGxzIHdpbGwgYmUgbWFkZSkgdW50aWwgdGhlIGZpcnN0IGNhbGwgdG8gYHJlc29sdmVkYFxuXHQgKi9cblx0cmVzb2x2ZShyZWNpcGllbnQ6IFBhcnRpYWxSZWNpcGllbnQsIHJlc29sdmVNb2RlOiBSZXNvbHZlTW9kZSk6IFJlc29sdmFibGVSZWNpcGllbnQge1xuXHRcdHJldHVybiBuZXcgUmVzb2x2YWJsZVJlY2lwaWVudEltcGwoXG5cdFx0XHRyZWNpcGllbnQsXG5cdFx0XHR0aGlzLmNvbnRhY3RNb2RlbCxcblx0XHRcdHRoaXMubG9naW5Db250cm9sbGVyLFxuXHRcdFx0KG1haWxBZGRyZXNzKSA9PiB0aGlzLmV4ZWN1dG9yLnJ1bih0aGlzLnJlc29sdmVSZWNpcGllbnRUeXBlKG1haWxBZGRyZXNzKSksXG5cdFx0XHR0aGlzLmVudGl0eUNsaWVudCxcblx0XHRcdHJlc29sdmVNb2RlLFxuXHRcdClcblx0fVxuXG5cdHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZVJlY2lwaWVudFR5cGUgPSAobWFpbEFkZHJlc3M6IHN0cmluZykgPT4gYXN5bmMgKCkgPT4ge1xuXHRcdGNvbnN0IGtleURhdGEgPSBhd2FpdCB0aGlzLm1haWxGYWNhZGUuZ2V0UmVjaXBpZW50S2V5RGF0YShtYWlsQWRkcmVzcylcblx0XHRyZXR1cm4ga2V5RGF0YSA9PSBudWxsID8gUmVjaXBpZW50VHlwZS5FWFRFUk5BTCA6IFJlY2lwaWVudFR5cGUuSU5URVJOQUxcblx0fVxufVxuXG5jbGFzcyBSZXNvbHZhYmxlUmVjaXBpZW50SW1wbCBpbXBsZW1lbnRzIFJlc29sdmFibGVSZWNpcGllbnQge1xuXHRwcml2YXRlIF9hZGRyZXNzOiBzdHJpbmdcblx0cHJpdmF0ZSBfbmFtZTogc3RyaW5nIHwgbnVsbFxuXHRwcml2YXRlIHJlYWRvbmx5IGxhenlUeXBlOiBMYXp5TG9hZGVkPFJlY2lwaWVudFR5cGU+XG5cdHByaXZhdGUgcmVhZG9ubHkgbGF6eUNvbnRhY3Q6IExhenlMb2FkZWQ8Q29udGFjdCB8IG51bGw+XG5cblx0cHJpdmF0ZSByZWFkb25seSBpbml0aWFsVHlwZTogUmVjaXBpZW50VHlwZSA9IFJlY2lwaWVudFR5cGUuVU5LTk9XTlxuXHRwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxDb250YWN0OiBDb250YWN0IHwgbnVsbCA9IG51bGxcblxuXHRwcml2YXRlIG92ZXJyaWRlQ29udGFjdDogQ29udGFjdCB8IG51bGwgPSBudWxsXG5cblx0Z2V0IGFkZHJlc3MoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkcmVzc1xuXHR9XG5cblx0Z2V0IG5hbWUoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZSA/PyBcIlwiXG5cdH1cblxuXHRnZXQgdHlwZSgpOiBSZWNpcGllbnRUeXBlIHtcblx0XHRyZXR1cm4gdGhpcy5sYXp5VHlwZS5nZXRTeW5jKCkgPz8gdGhpcy5pbml0aWFsVHlwZVxuXHR9XG5cblx0Z2V0IGNvbnRhY3QoKTogQ29udGFjdCB8IG51bGwge1xuXHRcdHJldHVybiB0aGlzLmxhenlDb250YWN0LmdldFN5bmMoKSA/PyB0aGlzLmluaXRpYWxDb250YWN0XG5cdH1cblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRhcmc6IFBhcnRpYWxSZWNpcGllbnQsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjb250YWN0TW9kZWw6IENvbnRhY3RNb2RlbCxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGxvZ2luQ29udHJvbGxlcjogTG9naW5Db250cm9sbGVyLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgdHlwZVJlc29sdmVyOiAobWFpbEFkZHJlc3M6IHN0cmluZykgPT4gUHJvbWlzZTxSZWNpcGllbnRUeXBlPixcblx0XHRwcml2YXRlIHJlYWRvbmx5IGVudGl0eUNsaWVudDogRW50aXR5Q2xpZW50LFxuXHRcdHJlc29sdmVNb2RlOiBSZXNvbHZlTW9kZSxcblx0KSB7XG5cdFx0aWYgKGlzVHV0YU1haWxBZGRyZXNzKGFyZy5hZGRyZXNzKSB8fCBhcmcudHlwZSA9PT0gUmVjaXBpZW50VHlwZS5JTlRFUk5BTCkge1xuXHRcdFx0dGhpcy5pbml0aWFsVHlwZSA9IFJlY2lwaWVudFR5cGUuSU5URVJOQUxcblx0XHRcdHRoaXMuX2FkZHJlc3MgPSBjbGVhbk1haWxBZGRyZXNzKGFyZy5hZGRyZXNzKVxuXHRcdH0gZWxzZSBpZiAoYXJnLnR5cGUpIHtcblx0XHRcdHRoaXMuaW5pdGlhbFR5cGUgPSBhcmcudHlwZVxuXHRcdFx0dGhpcy5fYWRkcmVzcyA9IGFyZy5hZGRyZXNzXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FkZHJlc3MgPSBhcmcuYWRkcmVzc1xuXHRcdH1cblxuXHRcdHRoaXMuX25hbWUgPSBhcmcubmFtZSA/PyBudWxsXG5cblx0XHRpZiAoIShhcmcuY29udGFjdCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0dGhpcy5pbml0aWFsQ29udGFjdCA9IGFyZy5jb250YWN0ID8/IG51bGxcblx0XHR9XG5cblx0XHR0aGlzLmxhenlUeXBlID0gbmV3IExhenlMb2FkZWQoKCkgPT4gdGhpcy5yZXNvbHZlVHlwZSgpKVxuXHRcdHRoaXMubGF6eUNvbnRhY3QgPSBuZXcgTGF6eUxvYWRlZChhc3luYyAoKSA9PiB7XG5cdFx0XHRjb25zdCBjb250YWN0ID0gYXdhaXQgdGhpcy5yZXNvbHZlQ29udGFjdChhcmcuY29udGFjdClcblx0XHRcdC8vIHNvbWV0aW1lcyB3ZSBjcmVhdGUgcmVzb2x2YWJsZSBjb250YWN0IGFuZCB0aGVuIGRpc3NlY3QgaXQgaW50byBwYXJ0cyBhbmQgcmVzb2x2ZSBpdCBhZ2FpbiBpbiB3aGljaCBjYXNlIHdlIHdpbGwgZGVmYXVsdCB0byBhbiBlbXB0eSBuYW1lXG5cdFx0XHQvLyAoc2VlIHRoZSBnZXR0ZXIpIGJ1dCB3ZSBhY3R1YWxseSB3YW50IHRoZSBuYW1lIGZyb20gY29udGFjdC5cblx0XHRcdGlmIChjb250YWN0ICE9IG51bGwgJiYgKHRoaXMuX25hbWUgPT0gbnVsbCB8fCB0aGlzLl9uYW1lID09PSBcIlwiKSkge1xuXHRcdFx0XHR0aGlzLl9uYW1lID0gZ2V0Q29udGFjdERpc3BsYXlOYW1lKGNvbnRhY3QpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29udGFjdFxuXHRcdH0pXG5cblx0XHRpZiAocmVzb2x2ZU1vZGUgPT09IFJlc29sdmVNb2RlLkVhZ2VyKSB7XG5cdFx0XHR0aGlzLmxhenlUeXBlLmxvYWQoKVxuXHRcdFx0dGhpcy5sYXp5Q29udGFjdC5sb2FkKClcblx0XHR9XG5cdH1cblxuXHRzZXROYW1lKG5ld05hbWU6IHN0cmluZykge1xuXHRcdHRoaXMuX25hbWUgPSBuZXdOYW1lXG5cdH1cblxuXHRzZXRDb250YWN0KG5ld0NvbnRhY3Q6IENvbnRhY3QpIHtcblx0XHR0aGlzLm92ZXJyaWRlQ29udGFjdCA9IG5ld0NvbnRhY3Rcblx0XHR0aGlzLmxhenlDb250YWN0LnJlbG9hZCgpXG5cdH1cblxuXHRhc3luYyByZXNvbHZlZCgpOiBQcm9taXNlPFJlY2lwaWVudD4ge1xuXHRcdGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmxhenlUeXBlLmdldEFzeW5jKCksIHRoaXMubGF6eUNvbnRhY3QuZ2V0QXN5bmMoKV0pXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdGNvbnRhY3Q6IHRoaXMuY29udGFjdCxcblx0XHR9XG5cdH1cblxuXHRpc1Jlc29sdmVkKCk6IGJvb2xlYW4ge1xuXHRcdC8vIFdlIGFyZSBvbmx5IHJlc29sdmVkIHdoZW4gYm90aCB0eXBlIGFuZCBjb250YWN0IGFyZSBub24tbnVsbCBhbmQgZmluaXNoZWRcblx0XHRyZXR1cm4gdGhpcy5sYXp5VHlwZS5pc0xvYWRlZCgpICYmIHRoaXMubGF6eUNvbnRhY3QuaXNMb2FkZWQoKVxuXHR9XG5cblx0d2hlblJlc29sdmVkKGhhbmRsZXI6IChyZXNvbHZlZFJlY2lwaWVudDogUmVjaXBpZW50KSA9PiB2b2lkKTogdGhpcyB7XG5cdFx0dGhpcy5yZXNvbHZlZCgpLnRoZW4oaGFuZGxlcilcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB3aGV0aGVyIHJlY2lwaWVudCBpcyBJTlRFUk5BTCBvciBFWFRFUk5BTCBiYXNlZCBvbiB0aGUgZXhpc3RlbmNlIG9mIGtleSBkYXRhIChleHRlcm5hbCByZWNpcGllbnRzIGRvbid0IGhhdmUgYW55KVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyByZXNvbHZlVHlwZSgpOiBQcm9taXNlPFJlY2lwaWVudFR5cGU+IHtcblx0XHRpZiAodGhpcy5pbml0aWFsVHlwZSA9PT0gUmVjaXBpZW50VHlwZS5VTktOT1dOKSB7XG5cdFx0XHRjb25zdCBjbGVhbmVkQWRkcmVzcyA9IGNsZWFuTWFpbEFkZHJlc3ModGhpcy5hZGRyZXNzKVxuXHRcdFx0Y29uc3QgcmVjaXBpZW50VHlwZSA9IGF3YWl0IHRoaXMudHlwZVJlc29sdmVyKGNsZWFuZWRBZGRyZXNzKVxuXHRcdFx0aWYgKHJlY2lwaWVudFR5cGUgPT09IFJlY2lwaWVudFR5cGUuSU5URVJOQUwpIHtcblx0XHRcdFx0Ly8gd2Uga25vdyB0aGlzIGlzIG9uZSBvZiBvdXJzLCBzbyBpdCdzIHNhZmUgdG8gY2xlYW4gaXQgdXBcblx0XHRcdFx0dGhpcy5fYWRkcmVzcyA9IGNsZWFuZWRBZGRyZXNzXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVjaXBpZW50VHlwZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbml0aWFsVHlwZVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlIHRoZSByZWNpcGllbnRzIGNvbnRhY3QuXG5cdCAqIElmIHtAcGFyYW0gY29udGFjdH0gaXMgYW4gSWQsIHRoZSBjb250YWN0IHdpbGwgYmUgbG9hZGVkIGRpcmVjdGx5XG5cdCAqIE90aGVyd2lzZSwgdGhlIGNvbnRhY3Qgd2lsbCBiZSBzZWFyY2hlZCBmb3IgaW4gdGhlIENvbnRhY3RNb2RlbFxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyByZXNvbHZlQ29udGFjdChjb250YWN0OiBDb250YWN0IHwgSWRUdXBsZSB8IE5vbmUpOiBQcm9taXNlPENvbnRhY3QgfCBudWxsPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLm92ZXJyaWRlQ29udGFjdCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vdmVycmlkZUNvbnRhY3Rcblx0XHRcdH0gZWxzZSBpZiAoKGF3YWl0IHRoaXMuY29udGFjdE1vZGVsLmdldENvbnRhY3RMaXN0SWQoKSkgPT0gbnVsbCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcImNhbid0IHJlc29sdmUgY29udGFjdHMgZm9yIHVzZXJzIHdpdGggbm8gY29udGFjdCBsaXN0IGlkXCIpXG5cdFx0XHRcdHJldHVybiBudWxsXG5cdFx0XHR9IGVsc2UgaWYgKGNvbnRhY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChDb250YWN0VHlwZVJlZiwgY29udGFjdClcblx0XHRcdH0gZWxzZSBpZiAoY29udGFjdCA9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IGZvdW5kQ29udGFjdCA9IGF3YWl0IHRoaXMuY29udGFjdE1vZGVsLnNlYXJjaEZvckNvbnRhY3QodGhpcy5hZGRyZXNzKVxuXHRcdFx0XHRpZiAoZm91bmRDb250YWN0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZvdW5kQ29udGFjdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHdlIGRvbid0IHdhbnQgdG8gY3JlYXRlIGEgbWl4ZWQtY2FzZSBjb250YWN0IGlmIHRoZSBhZGRyZXNzIGlzIGFuIGludGVybmFsIG9uZS5cblx0XHRcdFx0XHQvLyBhZnRlciBsYXp5VHlwZSBpcyBsb2FkZWQsIGlmIGl0IHJlc29sdmVzIHRvIFJlY2lwaWVudFR5cGUuSU5URVJOQUwsIHdlIGhhdmUgdGhlXG5cdFx0XHRcdFx0Ly8gY2xlYW5lZCBhZGRyZXNzIGluIHRoaXMuYWRkcmVzcy5cblx0XHRcdFx0XHRhd2FpdCB0aGlzLmxhenlUeXBlXG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZU5ld0NvbnRhY3QodGhpcy5sb2dpbkNvbnRyb2xsZXIuZ2V0VXNlckNvbnRyb2xsZXIoKS51c2VyLCB0aGlzLmFkZHJlc3MsIHRoaXMubmFtZSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRhY3Rcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcImVycm9yIHJlc29sdmluZyBjb250YWN0XCIsIGUpXG5cdFx0XHRyZXR1cm4gbnVsbFxuXHRcdH1cblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztJQWlDWSxzQ0FBTDtBQUNOO0FBQ0E7O0FBQ0E7SUFFWSxrQkFBTixNQUFzQjtDQUM1QixBQUFRLFdBQVcsSUFBSSxnQkFBZ0I7Q0FFdkMsWUFDa0JBLGNBQ0FDLGlCQUNBQyxZQUNBQyxjQUNoQjtFQTJLRixLQS9La0I7RUErS2pCLEtBOUtpQjtFQThLaEIsS0E3S2dCO0VBNktmLEtBNUtlO0NBQ2Q7Ozs7O0NBTUosUUFBUUMsV0FBNkJDLGFBQStDO0FBQ25GLFNBQU8sSUFBSSx3QkFDVixXQUNBLEtBQUssY0FDTCxLQUFLLGlCQUNMLENBQUMsZ0JBQWdCLEtBQUssU0FBUyxJQUFJLEtBQUsscUJBQXFCLFlBQVksQ0FBQyxFQUMxRSxLQUFLLGNBQ0w7Q0FFRDtDQUVELEFBQWlCLHVCQUF1QixDQUFDQyxnQkFBd0IsWUFBWTtFQUM1RSxNQUFNLFVBQVUsTUFBTSxLQUFLLFdBQVcsb0JBQW9CLFlBQVk7QUFDdEUsU0FBTyxXQUFXLE9BQU8sY0FBYyxXQUFXLGNBQWM7Q0FDaEU7QUFDRDtJQUVLLDBCQUFOLE1BQTZEO0NBQzVELEFBQVE7Q0FDUixBQUFRO0NBQ1IsQUFBaUI7Q0FDakIsQUFBaUI7Q0FFakIsQUFBaUIsY0FBNkIsY0FBYztDQUM1RCxBQUFpQixpQkFBaUM7Q0FFbEQsQUFBUSxrQkFBa0M7Q0FFMUMsSUFBSSxVQUFrQjtBQUNyQixTQUFPLEtBQUs7Q0FDWjtDQUVELElBQUksT0FBZTtBQUNsQixTQUFPLEtBQUss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