import "./dist-chunk.js";
import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { assertWorkerOrNode } from "./Env-chunk.js";
import { assertNotNull, findAndRemove, getFirstOrThrow, ofClass } from "./dist2-chunk.js";
import "./TutanotaConstants-chunk.js";
import "./EntityUtils-chunk.js";
import "./TypeModels-chunk.js";
import { MailboxGroupRootTypeRef, MailboxPropertiesTypeRef, createMailAddressProperties, createMailboxProperties } from "./TypeRefs-chunk.js";
import "./TypeModels2-chunk.js";
import { GroupInfoTypeRef, GroupTypeRef, UserTypeRef, createDomainMailAddressAvailabilityData, createMailAddressAliasGetIn, createMailAddressAliasServiceData, createMailAddressAliasServiceDataDelete, createMultipleMailAddressAvailabilityData, createStringWrapper } from "./TypeRefs2-chunk.js";
import { PreconditionFailedError } from "./RestError-chunk.js";
import { DomainMailAddressAvailabilityService, MailAddressAliasService, MultipleMailAddressAvailabilityService } from "./Services-chunk.js";
import { getEnabledMailAddressesForGroupInfo } from "./GroupUtils-chunk.js";

//#region src/common/api/worker/facades/lazy/MailAddressFacade.ts
assertWorkerOrNode();
var MailAddressFacade = class {
	constructor(userFacade, groupManagement, serviceExecutor, nonCachingEntityClient) {
		this.userFacade = userFacade;
		this.groupManagement = groupManagement;
		this.serviceExecutor = serviceExecutor;
		this.nonCachingEntityClient = nonCachingEntityClient;
	}
	/**
	* For legacy accounts the given userGroupId is ignored since the alias counters are for the customer
	*/
	getAliasCounters(userGroupId) {
		const data = createMailAddressAliasGetIn({ targetGroup: userGroupId });
		return this.serviceExecutor.get(MailAddressAliasService, data);
	}
	isMailAddressAvailable(mailAddress) {
		if (this.userFacade.isFullyLoggedIn()) {
			const data = createDomainMailAddressAvailabilityData({ mailAddress });
			return this.serviceExecutor.get(DomainMailAddressAvailabilityService, data).then((result) => result.available);
		} else return this.areMailAddressesAvailable([mailAddress]).then((result) => getFirstOrThrow(result).available);
	}
	async areMailAddressesAvailable(mailAddresses) {
		const data = createMultipleMailAddressAvailabilityData({ mailAddresses: mailAddresses.map((mailAddress) => createStringWrapper({ value: mailAddress })) });
		const result = await this.serviceExecutor.get(MultipleMailAddressAvailabilityService, data);
		return result.availabilities;
	}
	/**
	* Add an {@param alias} to {@param targetGroupId}.
	* {@param targetGroupId} is *not* a Mail group, it is currently only a user group.
	*
	* Can only be done by an admin.
	*/
	async addMailAlias(targetGroupId, alias) {
		const data = createMailAddressAliasServiceData({
			group: targetGroupId,
			mailAddress: alias
		});
		await this.serviceExecutor.post(MailAddressAliasService, data);
	}
	/**
	* Enable/disable an {@param alias} on {@param targetGroupId}.
	* {@param targetGroupId} is *not* a Mail group, it is currently only a user group.
	*
	* {@param restore} means whether the alias will be enabled or disabled.
	*
	* Can only be done by an admin.
	*/
	async setMailAliasStatus(targetGroupId, alias, restore) {
		const deleteData = createMailAddressAliasServiceDataDelete({
			mailAddress: alias,
			restore,
			group: targetGroupId
		});
		await this.serviceExecutor.delete(MailAddressAliasService, deleteData);
	}
	/**
	* Get mailAddress to senderName mappings for mail group that the specified user is a member of.
	* if no user is given, the operation is attempted as an admin of the given group.
	* */
	async getSenderNames(mailGroupId, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		return this.collectSenderNames(mailboxProperties);
	}
	/**
	* Set mailAddress to senderName mapping for mail group that the specified user is a member of.
	* if no user is specified, the operation will be attempted as an admin of the given group.
	* */
	async setSenderName(mailGroupId, mailAddress, senderName, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		let mailAddressProperty = mailboxProperties.mailAddressProperties.find((p) => p.mailAddress === mailAddress);
		if (mailAddressProperty == null) {
			mailAddressProperty = createMailAddressProperties({
				mailAddress,
				senderName: ""
			});
			mailboxProperties.mailAddressProperties.push(mailAddressProperty);
		}
		mailAddressProperty.senderName = senderName;
		const updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser);
		return this.collectSenderNames(updatedProperties);
	}
	/**
	* remove the sender name of the given mail address.
	* If no user is given, the operation will be attempted as an admin of the group.
	*/
	async removeSenderName(mailGroupId, mailAddress, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		findAndRemove(mailboxProperties.mailAddressProperties, (p) => p.mailAddress === mailAddress);
		const updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser);
		return this.collectSenderNames(updatedProperties);
	}
	async getOrCreateMailboxProperties(mailGroupId, viaUser) {
		const mailboxGroupRoot = await this.nonCachingEntityClient.load(MailboxGroupRootTypeRef, mailGroupId);
		if (mailboxGroupRoot.mailboxProperties == null) {
			const currentGroupKey = viaUser ? await this.groupManagement.getCurrentGroupKeyViaUser(mailGroupId, viaUser) : await this.groupManagement.getCurrentGroupKeyViaAdminEncGKey(mailGroupId);
			mailboxGroupRoot.mailboxProperties = await this.createMailboxProperties(mailboxGroupRoot, currentGroupKey);
		}
		const groupKeyProvider = async (version) => viaUser ? await this.groupManagement.getGroupKeyViaUser(mailGroupId, version, viaUser) : await this.groupManagement.getGroupKeyViaAdminEncGKey(mailGroupId, version);
		const mailboxProperties = await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxGroupRoot.mailboxProperties, { ownerKeyProvider: groupKeyProvider });
		return mailboxProperties.mailAddressProperties.length === 0 ? this.mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) : mailboxProperties;
	}
	/**
	* set the legacy sender name (groupInfo.name) of the group on all assigned mail addresses.
	* if no user is given, the operation will be attempted as an admin of the group of the given mailboxProperties.
	* */
	async mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) {
		const groupInfo = viaUser ? await this.loadUserGroupInfo(viaUser) : await this.loadMailGroupInfo(mailboxProperties._ownerGroup);
		const legacySenderName = groupInfo.name;
		const mailAddresses = getEnabledMailAddressesForGroupInfo(groupInfo);
		for (const mailAddress of mailAddresses) mailboxProperties.mailAddressProperties.push(createMailAddressProperties({
			mailAddress,
			senderName: legacySenderName
		}));
		return this.updateMailboxProperties(mailboxProperties, viaUser);
	}
	async loadUserGroupInfo(userId) {
		const user = await this.nonCachingEntityClient.load(UserTypeRef, userId);
		return await this.nonCachingEntityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo);
	}
	async loadMailGroupInfo(groupId) {
		const group = await this.nonCachingEntityClient.load(GroupTypeRef, groupId);
		return await this.nonCachingEntityClient.load(GroupInfoTypeRef, group.groupInfo);
	}
	async createMailboxProperties(mailboxGroupRoot, groupKey) {
		const _ownerGroup = mailboxGroupRoot._ownerGroup;
		const mailboxProperties = createMailboxProperties({
			..._ownerGroup != null ? { _ownerGroup } : null,
			reportMovedMails: "",
			mailAddressProperties: []
		});
		return this.nonCachingEntityClient.setup(null, mailboxProperties, undefined, { ownerKey: groupKey }).catch(ofClass(PreconditionFailedError, (e) => {
			if (e.data && e.data.startsWith("exists:")) {
				const existingId = e.data.substring("exists:".length);
				console.log("mailboxProperties already exists", existingId);
				return existingId;
			} else throw new ProgrammingError(`Could not create mailboxProperties, precondition: ${e.data}`);
		}));
	}
	async updateMailboxProperties(mailboxProperties, viaUser) {
		const groupKeyProvider = async (version) => viaUser ? await this.groupManagement.getGroupKeyViaUser(assertNotNull(mailboxProperties._ownerGroup), version, viaUser) : await this.groupManagement.getGroupKeyViaAdminEncGKey(assertNotNull(mailboxProperties._ownerGroup), version);
		await this.nonCachingEntityClient.update(mailboxProperties, { ownerKeyProvider: groupKeyProvider });
		return await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxProperties._id, { ownerKeyProvider: groupKeyProvider });
	}
	async collectSenderNames(mailboxProperties) {
		const result = new Map();
		for (const data of mailboxProperties.mailAddressProperties) result.set(data.mailAddress, data.senderName);
		return result;
	}
};

//#endregion
export { MailAddressFacade };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFpbEFkZHJlc3NGYWNhZGUtY2h1bmsuanMiLCJuYW1lcyI6WyJ1c2VyRmFjYWRlOiBVc2VyRmFjYWRlIiwiZ3JvdXBNYW5hZ2VtZW50OiBHcm91cE1hbmFnZW1lbnRGYWNhZGUiLCJzZXJ2aWNlRXhlY3V0b3I6IElTZXJ2aWNlRXhlY3V0b3IiLCJub25DYWNoaW5nRW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQiLCJ1c2VyR3JvdXBJZDogSWQiLCJtYWlsQWRkcmVzczogc3RyaW5nIiwibWFpbEFkZHJlc3Nlczogc3RyaW5nW10iLCJ0YXJnZXRHcm91cElkOiBJZCIsImFsaWFzOiBzdHJpbmciLCJyZXN0b3JlOiBib29sZWFuIiwibWFpbEdyb3VwSWQ6IElkIiwidmlhVXNlcj86IElkIiwic2VuZGVyTmFtZTogc3RyaW5nIiwidmlhVXNlcjogSWQiLCJ2ZXJzaW9uOiBudW1iZXIiLCJtYWlsYm94UHJvcGVydGllczogTWFpbGJveFByb3BlcnRpZXMiLCJ1c2VySWQ6IElkIiwiZ3JvdXBJZDogSWQiLCJtYWlsYm94R3JvdXBSb290OiBNYWlsYm94R3JvdXBSb290IiwiZ3JvdXBLZXk6IFZlcnNpb25lZEtleSJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vYXBpL3dvcmtlci9mYWNhZGVzL2xhenkvTWFpbEFkZHJlc3NGYWNhZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBHcm91cEluZm8sIE1haWxBZGRyZXNzQWxpYXNTZXJ2aWNlUmV0dXJuLCBNYWlsQWRkcmVzc0F2YWlsYWJpbGl0eSB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHtcblx0Y3JlYXRlRG9tYWluTWFpbEFkZHJlc3NBdmFpbGFiaWxpdHlEYXRhLFxuXHRjcmVhdGVNYWlsQWRkcmVzc0FsaWFzR2V0SW4sXG5cdGNyZWF0ZU1haWxBZGRyZXNzQWxpYXNTZXJ2aWNlRGF0YSxcblx0Y3JlYXRlTWFpbEFkZHJlc3NBbGlhc1NlcnZpY2VEYXRhRGVsZXRlLFxuXHRjcmVhdGVNdWx0aXBsZU1haWxBZGRyZXNzQXZhaWxhYmlsaXR5RGF0YSxcblx0Y3JlYXRlU3RyaW5nV3JhcHBlcixcblx0R3JvdXBJbmZvVHlwZVJlZixcblx0R3JvdXBUeXBlUmVmLFxuXHRVc2VyVHlwZVJlZixcbn0gZnJvbSBcIi4uLy4uLy4uL2VudGl0aWVzL3N5cy9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBEb21haW5NYWlsQWRkcmVzc0F2YWlsYWJpbGl0eVNlcnZpY2UsIE1haWxBZGRyZXNzQWxpYXNTZXJ2aWNlLCBNdWx0aXBsZU1haWxBZGRyZXNzQXZhaWxhYmlsaXR5U2VydmljZSB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvU2VydmljZXMuanNcIlxuaW1wb3J0IHsgYXNzZXJ0V29ya2VyT3JOb2RlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9FbnYuanNcIlxuaW1wb3J0IHsgSVNlcnZpY2VFeGVjdXRvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vU2VydmljZVJlcXVlc3QuanNcIlxuaW1wb3J0IHsgVXNlckZhY2FkZSB9IGZyb20gXCIuLi9Vc2VyRmFjYWRlLmpzXCJcbmltcG9ydCB7IEVudGl0eUNsaWVudCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vRW50aXR5Q2xpZW50LmpzXCJcbmltcG9ydCB7XG5cdGNyZWF0ZU1haWxBZGRyZXNzUHJvcGVydGllcyxcblx0Y3JlYXRlTWFpbGJveFByb3BlcnRpZXMsXG5cdE1haWxib3hHcm91cFJvb3QsXG5cdE1haWxib3hHcm91cFJvb3RUeXBlUmVmLFxuXHRNYWlsYm94UHJvcGVydGllcyxcblx0TWFpbGJveFByb3BlcnRpZXNUeXBlUmVmLFxufSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvdHV0YW5vdGEvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgYXNzZXJ0Tm90TnVsbCwgZmluZEFuZFJlbW92ZSwgZ2V0Rmlyc3RPclRocm93LCBvZkNsYXNzIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBnZXRFbmFibGVkTWFpbEFkZHJlc3Nlc0Zvckdyb3VwSW5mbyB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vdXRpbHMvR3JvdXBVdGlscy5qc1wiXG5pbXBvcnQgeyBQcmVjb25kaXRpb25GYWlsZWRFcnJvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vZXJyb3IvUmVzdEVycm9yLmpzXCJcbmltcG9ydCB7IFByb2dyYW1taW5nRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2Vycm9yL1Byb2dyYW1taW5nRXJyb3IuanNcIlxuaW1wb3J0IHsgR3JvdXBNYW5hZ2VtZW50RmFjYWRlIH0gZnJvbSBcIi4vR3JvdXBNYW5hZ2VtZW50RmFjYWRlLmpzXCJcblxuaW1wb3J0IHsgVmVyc2lvbmVkS2V5IH0gZnJvbSBcIi4uLy4uL2NyeXB0by9DcnlwdG9XcmFwcGVyLmpzXCJcblxuYXNzZXJ0V29ya2VyT3JOb2RlKClcblxuZXhwb3J0IGNsYXNzIE1haWxBZGRyZXNzRmFjYWRlIHtcblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1c2VyRmFjYWRlOiBVc2VyRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgZ3JvdXBNYW5hZ2VtZW50OiBHcm91cE1hbmFnZW1lbnRGYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlRXhlY3V0b3I6IElTZXJ2aWNlRXhlY3V0b3IsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBub25DYWNoaW5nRW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQsXG5cdCkge31cblxuXHQvKipcblx0ICogRm9yIGxlZ2FjeSBhY2NvdW50cyB0aGUgZ2l2ZW4gdXNlckdyb3VwSWQgaXMgaWdub3JlZCBzaW5jZSB0aGUgYWxpYXMgY291bnRlcnMgYXJlIGZvciB0aGUgY3VzdG9tZXJcblx0ICovXG5cdGdldEFsaWFzQ291bnRlcnModXNlckdyb3VwSWQ6IElkKTogUHJvbWlzZTxNYWlsQWRkcmVzc0FsaWFzU2VydmljZVJldHVybj4ge1xuXHRcdGNvbnN0IGRhdGEgPSBjcmVhdGVNYWlsQWRkcmVzc0FsaWFzR2V0SW4oeyB0YXJnZXRHcm91cDogdXNlckdyb3VwSWQgfSlcblx0XHRyZXR1cm4gdGhpcy5zZXJ2aWNlRXhlY3V0b3IuZ2V0KE1haWxBZGRyZXNzQWxpYXNTZXJ2aWNlLCBkYXRhKVxuXHR9XG5cblx0aXNNYWlsQWRkcmVzc0F2YWlsYWJsZShtYWlsQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0aWYgKHRoaXMudXNlckZhY2FkZS5pc0Z1bGx5TG9nZ2VkSW4oKSkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGNyZWF0ZURvbWFpbk1haWxBZGRyZXNzQXZhaWxhYmlsaXR5RGF0YSh7IG1haWxBZGRyZXNzIH0pXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXJ2aWNlRXhlY3V0b3IuZ2V0KERvbWFpbk1haWxBZGRyZXNzQXZhaWxhYmlsaXR5U2VydmljZSwgZGF0YSkudGhlbigocmVzdWx0KSA9PiByZXN1bHQuYXZhaWxhYmxlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcmVNYWlsQWRkcmVzc2VzQXZhaWxhYmxlKFttYWlsQWRkcmVzc10pLnRoZW4oKHJlc3VsdCkgPT4gZ2V0Rmlyc3RPclRocm93KHJlc3VsdCkuYXZhaWxhYmxlKVxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGFyZU1haWxBZGRyZXNzZXNBdmFpbGFibGUobWFpbEFkZHJlc3Nlczogc3RyaW5nW10pOiBQcm9taXNlPE1haWxBZGRyZXNzQXZhaWxhYmlsaXR5W10+IHtcblx0XHRjb25zdCBkYXRhID0gY3JlYXRlTXVsdGlwbGVNYWlsQWRkcmVzc0F2YWlsYWJpbGl0eURhdGEoe1xuXHRcdFx0bWFpbEFkZHJlc3NlczogbWFpbEFkZHJlc3Nlcy5tYXAoKG1haWxBZGRyZXNzKSA9PiBjcmVhdGVTdHJpbmdXcmFwcGVyKHsgdmFsdWU6IG1haWxBZGRyZXNzIH0pKSxcblx0XHR9KVxuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLmdldChNdWx0aXBsZU1haWxBZGRyZXNzQXZhaWxhYmlsaXR5U2VydmljZSwgZGF0YSlcblx0XHRyZXR1cm4gcmVzdWx0LmF2YWlsYWJpbGl0aWVzXG5cdH1cblxuXHQvKipcblx0ICogQWRkIGFuIHtAcGFyYW0gYWxpYXN9IHRvIHtAcGFyYW0gdGFyZ2V0R3JvdXBJZH0uXG5cdCAqIHtAcGFyYW0gdGFyZ2V0R3JvdXBJZH0gaXMgKm5vdCogYSBNYWlsIGdyb3VwLCBpdCBpcyBjdXJyZW50bHkgb25seSBhIHVzZXIgZ3JvdXAuXG5cdCAqXG5cdCAqIENhbiBvbmx5IGJlIGRvbmUgYnkgYW4gYWRtaW4uXG5cdCAqL1xuXHRhc3luYyBhZGRNYWlsQWxpYXModGFyZ2V0R3JvdXBJZDogSWQsIGFsaWFzOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBkYXRhID0gY3JlYXRlTWFpbEFkZHJlc3NBbGlhc1NlcnZpY2VEYXRhKHtcblx0XHRcdGdyb3VwOiB0YXJnZXRHcm91cElkLFxuXHRcdFx0bWFpbEFkZHJlc3M6IGFsaWFzLFxuXHRcdH0pXG5cdFx0YXdhaXQgdGhpcy5zZXJ2aWNlRXhlY3V0b3IucG9zdChNYWlsQWRkcmVzc0FsaWFzU2VydmljZSwgZGF0YSlcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGUvZGlzYWJsZSBhbiB7QHBhcmFtIGFsaWFzfSBvbiB7QHBhcmFtIHRhcmdldEdyb3VwSWR9LlxuXHQgKiB7QHBhcmFtIHRhcmdldEdyb3VwSWR9IGlzICpub3QqIGEgTWFpbCBncm91cCwgaXQgaXMgY3VycmVudGx5IG9ubHkgYSB1c2VyIGdyb3VwLlxuXHQgKlxuXHQgKiB7QHBhcmFtIHJlc3RvcmV9IG1lYW5zIHdoZXRoZXIgdGhlIGFsaWFzIHdpbGwgYmUgZW5hYmxlZCBvciBkaXNhYmxlZC5cblx0ICpcblx0ICogQ2FuIG9ubHkgYmUgZG9uZSBieSBhbiBhZG1pbi5cblx0ICovXG5cdGFzeW5jIHNldE1haWxBbGlhc1N0YXR1cyh0YXJnZXRHcm91cElkOiBJZCwgYWxpYXM6IHN0cmluZywgcmVzdG9yZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGRlbGV0ZURhdGEgPSBjcmVhdGVNYWlsQWRkcmVzc0FsaWFzU2VydmljZURhdGFEZWxldGUoe1xuXHRcdFx0bWFpbEFkZHJlc3M6IGFsaWFzLFxuXHRcdFx0cmVzdG9yZSxcblx0XHRcdGdyb3VwOiB0YXJnZXRHcm91cElkLFxuXHRcdH0pXG5cdFx0YXdhaXQgdGhpcy5zZXJ2aWNlRXhlY3V0b3IuZGVsZXRlKE1haWxBZGRyZXNzQWxpYXNTZXJ2aWNlLCBkZWxldGVEYXRhKVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBtYWlsQWRkcmVzcyB0byBzZW5kZXJOYW1lIG1hcHBpbmdzIGZvciBtYWlsIGdyb3VwIHRoYXQgdGhlIHNwZWNpZmllZCB1c2VyIGlzIGEgbWVtYmVyIG9mLlxuXHQgKiBpZiBubyB1c2VyIGlzIGdpdmVuLCB0aGUgb3BlcmF0aW9uIGlzIGF0dGVtcHRlZCBhcyBhbiBhZG1pbiBvZiB0aGUgZ2l2ZW4gZ3JvdXAuXG5cdCAqICovXG5cdGFzeW5jIGdldFNlbmRlck5hbWVzKG1haWxHcm91cElkOiBJZCwgdmlhVXNlcj86IElkKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBzdHJpbmc+PiB7XG5cdFx0Y29uc3QgbWFpbGJveFByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbEdyb3VwSWQsIHZpYVVzZXIpXG5cdFx0cmV0dXJuIHRoaXMuY29sbGVjdFNlbmRlck5hbWVzKG1haWxib3hQcm9wZXJ0aWVzKVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBtYWlsQWRkcmVzcyB0byBzZW5kZXJOYW1lIG1hcHBpbmcgZm9yIG1haWwgZ3JvdXAgdGhhdCB0aGUgc3BlY2lmaWVkIHVzZXIgaXMgYSBtZW1iZXIgb2YuXG5cdCAqIGlmIG5vIHVzZXIgaXMgc3BlY2lmaWVkLCB0aGUgb3BlcmF0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkIGFzIGFuIGFkbWluIG9mIHRoZSBnaXZlbiBncm91cC5cblx0ICogKi9cblx0YXN5bmMgc2V0U2VuZGVyTmFtZShtYWlsR3JvdXBJZDogSWQsIG1haWxBZGRyZXNzOiBzdHJpbmcsIHNlbmRlck5hbWU6IHN0cmluZywgdmlhVXNlcj86IElkKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBzdHJpbmc+PiB7XG5cdFx0Y29uc3QgbWFpbGJveFByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbEdyb3VwSWQsIHZpYVVzZXIpXG5cdFx0bGV0IG1haWxBZGRyZXNzUHJvcGVydHkgPSBtYWlsYm94UHJvcGVydGllcy5tYWlsQWRkcmVzc1Byb3BlcnRpZXMuZmluZCgocCkgPT4gcC5tYWlsQWRkcmVzcyA9PT0gbWFpbEFkZHJlc3MpXG5cdFx0aWYgKG1haWxBZGRyZXNzUHJvcGVydHkgPT0gbnVsbCkge1xuXHRcdFx0bWFpbEFkZHJlc3NQcm9wZXJ0eSA9IGNyZWF0ZU1haWxBZGRyZXNzUHJvcGVydGllcyh7XG5cdFx0XHRcdG1haWxBZGRyZXNzLFxuXHRcdFx0XHRzZW5kZXJOYW1lOiBcIlwiLFxuXHRcdFx0fSlcblx0XHRcdG1haWxib3hQcm9wZXJ0aWVzLm1haWxBZGRyZXNzUHJvcGVydGllcy5wdXNoKG1haWxBZGRyZXNzUHJvcGVydHkpXG5cdFx0fVxuXHRcdG1haWxBZGRyZXNzUHJvcGVydHkuc2VuZGVyTmFtZSA9IHNlbmRlck5hbWVcblx0XHRjb25zdCB1cGRhdGVkUHJvcGVydGllcyA9IGF3YWl0IHRoaXMudXBkYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbGJveFByb3BlcnRpZXMsIHZpYVVzZXIpXG5cdFx0cmV0dXJuIHRoaXMuY29sbGVjdFNlbmRlck5hbWVzKHVwZGF0ZWRQcm9wZXJ0aWVzKVxuXHR9XG5cblx0LyoqXG5cdCAqIHJlbW92ZSB0aGUgc2VuZGVyIG5hbWUgb2YgdGhlIGdpdmVuIG1haWwgYWRkcmVzcy5cblx0ICogSWYgbm8gdXNlciBpcyBnaXZlbiwgdGhlIG9wZXJhdGlvbiB3aWxsIGJlIGF0dGVtcHRlZCBhcyBhbiBhZG1pbiBvZiB0aGUgZ3JvdXAuXG5cdCAqL1xuXHRhc3luYyByZW1vdmVTZW5kZXJOYW1lKG1haWxHcm91cElkOiBJZCwgbWFpbEFkZHJlc3M6IHN0cmluZywgdmlhVXNlcjogSWQpOiBQcm9taXNlPE1hcDxzdHJpbmcsIHN0cmluZz4+IHtcblx0XHRjb25zdCBtYWlsYm94UHJvcGVydGllcyA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVNYWlsYm94UHJvcGVydGllcyhtYWlsR3JvdXBJZCwgdmlhVXNlcilcblx0XHRmaW5kQW5kUmVtb3ZlKG1haWxib3hQcm9wZXJ0aWVzLm1haWxBZGRyZXNzUHJvcGVydGllcywgKHApID0+IHAubWFpbEFkZHJlc3MgPT09IG1haWxBZGRyZXNzKVxuXHRcdGNvbnN0IHVwZGF0ZWRQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy51cGRhdGVNYWlsYm94UHJvcGVydGllcyhtYWlsYm94UHJvcGVydGllcywgdmlhVXNlcilcblx0XHRyZXR1cm4gdGhpcy5jb2xsZWN0U2VuZGVyTmFtZXModXBkYXRlZFByb3BlcnRpZXMpXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGdldE9yQ3JlYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbEdyb3VwSWQ6IElkLCB2aWFVc2VyPzogSWQpOiBQcm9taXNlPE1haWxib3hQcm9wZXJ0aWVzPiB7XG5cdFx0Ly8gVXNpbmcgbm9uLWNhY2hpbmcgZW50aXR5Q2xpZW50IGJlY2F1c2Ugd2UgYXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgdXNlcidzIG1haWwgZ3JvdXAsIGFuZCB3ZSB3b24ndCByZWNlaXZlIHVwZGF0ZXMgZm9yIGl0XG5cdFx0Y29uc3QgbWFpbGJveEdyb3VwUm9vdCA9IGF3YWl0IHRoaXMubm9uQ2FjaGluZ0VudGl0eUNsaWVudC5sb2FkKE1haWxib3hHcm91cFJvb3RUeXBlUmVmLCBtYWlsR3JvdXBJZClcblxuXHRcdGlmIChtYWlsYm94R3JvdXBSb290Lm1haWxib3hQcm9wZXJ0aWVzID09IG51bGwpIHtcblx0XHRcdGNvbnN0IGN1cnJlbnRHcm91cEtleSA9IHZpYVVzZXJcblx0XHRcdFx0PyBhd2FpdCB0aGlzLmdyb3VwTWFuYWdlbWVudC5nZXRDdXJyZW50R3JvdXBLZXlWaWFVc2VyKG1haWxHcm91cElkLCB2aWFVc2VyKVxuXHRcdFx0XHQ6IGF3YWl0IHRoaXMuZ3JvdXBNYW5hZ2VtZW50LmdldEN1cnJlbnRHcm91cEtleVZpYUFkbWluRW5jR0tleShtYWlsR3JvdXBJZClcblx0XHRcdG1haWxib3hHcm91cFJvb3QubWFpbGJveFByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLmNyZWF0ZU1haWxib3hQcm9wZXJ0aWVzKG1haWxib3hHcm91cFJvb3QsIGN1cnJlbnRHcm91cEtleSlcblx0XHR9XG5cblx0XHRjb25zdCBncm91cEtleVByb3ZpZGVyID0gYXN5bmMgKHZlcnNpb246IG51bWJlcikgPT5cblx0XHRcdHZpYVVzZXJcblx0XHRcdFx0PyBhd2FpdCB0aGlzLmdyb3VwTWFuYWdlbWVudC5nZXRHcm91cEtleVZpYVVzZXIobWFpbEdyb3VwSWQsIHZlcnNpb24sIHZpYVVzZXIpXG5cdFx0XHRcdDogYXdhaXQgdGhpcy5ncm91cE1hbmFnZW1lbnQuZ2V0R3JvdXBLZXlWaWFBZG1pbkVuY0dLZXkobWFpbEdyb3VwSWQsIHZlcnNpb24pXG5cdFx0Y29uc3QgbWFpbGJveFByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQubG9hZChNYWlsYm94UHJvcGVydGllc1R5cGVSZWYsIG1haWxib3hHcm91cFJvb3QubWFpbGJveFByb3BlcnRpZXMsIHtcblx0XHRcdG93bmVyS2V5UHJvdmlkZXI6IGdyb3VwS2V5UHJvdmlkZXIsXG5cdFx0fSlcblxuXHRcdHJldHVybiBtYWlsYm94UHJvcGVydGllcy5tYWlsQWRkcmVzc1Byb3BlcnRpZXMubGVuZ3RoID09PSAwID8gdGhpcy5tYWlsYm94UHJvcGVydGllc1dpdGhMZWdhY3lTZW5kZXJOYW1lKG1haWxib3hQcm9wZXJ0aWVzLCB2aWFVc2VyKSA6IG1haWxib3hQcm9wZXJ0aWVzXG5cdH1cblxuXHQvKipcblx0ICogc2V0IHRoZSBsZWdhY3kgc2VuZGVyIG5hbWUgKGdyb3VwSW5mby5uYW1lKSBvZiB0aGUgZ3JvdXAgb24gYWxsIGFzc2lnbmVkIG1haWwgYWRkcmVzc2VzLlxuXHQgKiBpZiBubyB1c2VyIGlzIGdpdmVuLCB0aGUgb3BlcmF0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkIGFzIGFuIGFkbWluIG9mIHRoZSBncm91cCBvZiB0aGUgZ2l2ZW4gbWFpbGJveFByb3BlcnRpZXMuXG5cdCAqICovXG5cdHByaXZhdGUgYXN5bmMgbWFpbGJveFByb3BlcnRpZXNXaXRoTGVnYWN5U2VuZGVyTmFtZShtYWlsYm94UHJvcGVydGllczogTWFpbGJveFByb3BlcnRpZXMsIHZpYVVzZXI/OiBJZCk6IFByb21pc2U8TWFpbGJveFByb3BlcnRpZXM+IHtcblx0XHRjb25zdCBncm91cEluZm8gPSB2aWFVc2VyID8gYXdhaXQgdGhpcy5sb2FkVXNlckdyb3VwSW5mbyh2aWFVc2VyKSA6IGF3YWl0IHRoaXMubG9hZE1haWxHcm91cEluZm8obWFpbGJveFByb3BlcnRpZXMuX293bmVyR3JvdXAhKVxuXHRcdGNvbnN0IGxlZ2FjeVNlbmRlck5hbWUgPSBncm91cEluZm8ubmFtZVxuXHRcdGNvbnN0IG1haWxBZGRyZXNzZXMgPSBnZXRFbmFibGVkTWFpbEFkZHJlc3Nlc0Zvckdyb3VwSW5mbyhncm91cEluZm8pXG5cdFx0Zm9yIChjb25zdCBtYWlsQWRkcmVzcyBvZiBtYWlsQWRkcmVzc2VzKSB7XG5cdFx0XHRtYWlsYm94UHJvcGVydGllcy5tYWlsQWRkcmVzc1Byb3BlcnRpZXMucHVzaChcblx0XHRcdFx0Y3JlYXRlTWFpbEFkZHJlc3NQcm9wZXJ0aWVzKHtcblx0XHRcdFx0XHRtYWlsQWRkcmVzcyxcblx0XHRcdFx0XHRzZW5kZXJOYW1lOiBsZWdhY3lTZW5kZXJOYW1lLFxuXHRcdFx0XHR9KSxcblx0XHRcdClcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbGJveFByb3BlcnRpZXMsIHZpYVVzZXIpXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGxvYWRVc2VyR3JvdXBJbmZvKHVzZXJJZDogSWQpOiBQcm9taXNlPEdyb3VwSW5mbz4ge1xuXHRcdGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQubG9hZChVc2VyVHlwZVJlZiwgdXNlcklkKVxuXHRcdHJldHVybiBhd2FpdCB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQubG9hZChHcm91cEluZm9UeXBlUmVmLCB1c2VyLnVzZXJHcm91cC5ncm91cEluZm8pXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGxvYWRNYWlsR3JvdXBJbmZvKGdyb3VwSWQ6IElkKTogUHJvbWlzZTxHcm91cEluZm8+IHtcblx0XHRjb25zdCBncm91cCA9IGF3YWl0IHRoaXMubm9uQ2FjaGluZ0VudGl0eUNsaWVudC5sb2FkKEdyb3VwVHlwZVJlZiwgZ3JvdXBJZClcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5ub25DYWNoaW5nRW50aXR5Q2xpZW50LmxvYWQoR3JvdXBJbmZvVHlwZVJlZiwgZ3JvdXAuZ3JvdXBJbmZvKVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBjcmVhdGVNYWlsYm94UHJvcGVydGllcyhtYWlsYm94R3JvdXBSb290OiBNYWlsYm94R3JvdXBSb290LCBncm91cEtleTogVmVyc2lvbmVkS2V5KTogUHJvbWlzZTxJZD4ge1xuXHRcdGNvbnN0IF9vd25lckdyb3VwID0gbWFpbGJveEdyb3VwUm9vdC5fb3duZXJHcm91cFxuXHRcdGNvbnN0IG1haWxib3hQcm9wZXJ0aWVzID0gY3JlYXRlTWFpbGJveFByb3BlcnRpZXMoe1xuXHRcdFx0Li4uKF9vd25lckdyb3VwICE9IG51bGwgPyB7IF9vd25lckdyb3VwIH0gOiBudWxsKSwgLy8gb25seSBzZXQgaXQgaWYgaXQgaXMgbm90IG51bGxcblx0XHRcdHJlcG9ydE1vdmVkTWFpbHM6IFwiXCIsXG5cdFx0XHRtYWlsQWRkcmVzc1Byb3BlcnRpZXM6IFtdLFxuXHRcdH0pXG5cdFx0Ly8gVXNpbmcgbm9uLWNhY2hpbmcgZW50aXR5Q2xpZW50IGJlY2F1c2Ugd2UgYXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgdXNlcidzIG1haWwgZ3JvdXAgYW5kIHdlIHdvbid0IHJlY2VpdmUgdXBkYXRlcyBmb3IgaXRcblx0XHRyZXR1cm4gdGhpcy5ub25DYWNoaW5nRW50aXR5Q2xpZW50LnNldHVwKG51bGwsIG1haWxib3hQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIHsgb3duZXJLZXk6IGdyb3VwS2V5IH0pLmNhdGNoKFxuXHRcdFx0b2ZDbGFzcyhQcmVjb25kaXRpb25GYWlsZWRFcnJvciwgKGUpID0+IHtcblx0XHRcdFx0Ly8gaW4gYWRtaW4gY2FzZSBpdCBpcyBtdWNoIGhhcmRlciB0byBydW4gaW50byBpdCBiZWNhdXNlIHdlIHVzZSBub24tY2FjaGluZyBlbnRpdHlDbGllbnQgYnV0IGl0IGlzIHN0aWxsIHBvc3NpYmxlXG5cdFx0XHRcdGlmIChlLmRhdGEgJiYgZS5kYXRhLnN0YXJ0c1dpdGgoXCJleGlzdHM6XCIpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdJZCA9IGUuZGF0YS5zdWJzdHJpbmcoXCJleGlzdHM6XCIubGVuZ3RoKVxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwibWFpbGJveFByb3BlcnRpZXMgYWxyZWFkeSBleGlzdHNcIiwgZXhpc3RpbmdJZClcblx0XHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdJZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBQcm9ncmFtbWluZ0Vycm9yKGBDb3VsZCBub3QgY3JlYXRlIG1haWxib3hQcm9wZXJ0aWVzLCBwcmVjb25kaXRpb246ICR7ZS5kYXRhfWApXG5cdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdClcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgdXBkYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbGJveFByb3BlcnRpZXM6IE1haWxib3hQcm9wZXJ0aWVzLCB2aWFVc2VyPzogSWQpOiBQcm9taXNlPE1haWxib3hQcm9wZXJ0aWVzPiB7XG5cdFx0Y29uc3QgZ3JvdXBLZXlQcm92aWRlciA9IGFzeW5jICh2ZXJzaW9uOiBudW1iZXIpID0+XG5cdFx0XHR2aWFVc2VyXG5cdFx0XHRcdD8gYXdhaXQgdGhpcy5ncm91cE1hbmFnZW1lbnQuZ2V0R3JvdXBLZXlWaWFVc2VyKGFzc2VydE5vdE51bGwobWFpbGJveFByb3BlcnRpZXMuX293bmVyR3JvdXApLCB2ZXJzaW9uLCB2aWFVc2VyKVxuXHRcdFx0XHQ6IGF3YWl0IHRoaXMuZ3JvdXBNYW5hZ2VtZW50LmdldEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5KGFzc2VydE5vdE51bGwobWFpbGJveFByb3BlcnRpZXMuX293bmVyR3JvdXApLCB2ZXJzaW9uKVxuXHRcdGF3YWl0IHRoaXMubm9uQ2FjaGluZ0VudGl0eUNsaWVudC51cGRhdGUobWFpbGJveFByb3BlcnRpZXMsIHsgb3duZXJLZXlQcm92aWRlcjogZ3JvdXBLZXlQcm92aWRlciB9KVxuXHRcdHJldHVybiBhd2FpdCB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQubG9hZChNYWlsYm94UHJvcGVydGllc1R5cGVSZWYsIG1haWxib3hQcm9wZXJ0aWVzLl9pZCwgeyBvd25lcktleVByb3ZpZGVyOiBncm91cEtleVByb3ZpZGVyIH0pXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNvbGxlY3RTZW5kZXJOYW1lcyhtYWlsYm94UHJvcGVydGllczogTWFpbGJveFByb3BlcnRpZXMpOiBQcm9taXNlPE1hcDxzdHJpbmcsIHN0cmluZz4+IHtcblx0XHRjb25zdCByZXN1bHQgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG5cdFx0Zm9yIChjb25zdCBkYXRhIG9mIG1haWxib3hQcm9wZXJ0aWVzLm1haWxBZGRyZXNzUHJvcGVydGllcykge1xuXHRcdFx0cmVzdWx0LnNldChkYXRhLm1haWxBZGRyZXNzLCBkYXRhLnNlbmRlck5hbWUpXG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHRcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFpQ0Esb0JBQW9CO0lBRVAsb0JBQU4sTUFBd0I7Q0FDOUIsWUFDa0JBLFlBQ0FDLGlCQUNBQyxpQkFDQUMsd0JBQ2hCO0VBMkxGLEtBL0xrQjtFQStMakIsS0E5TGlCO0VBOExoQixLQTdMZ0I7RUE2TGYsS0E1TGU7Q0FDZDs7OztDQUtKLGlCQUFpQkMsYUFBeUQ7RUFDekUsTUFBTSxPQUFPLDRCQUE0QixFQUFFLGFBQWEsWUFBYSxFQUFDO0FBQ3RFLFNBQU8sS0FBSyxnQkFBZ0IsSUFBSSx5QkFBeUIsS0FBSztDQUM5RDtDQUVELHVCQUF1QkMsYUFBdUM7QUFDN0QsTUFBSSxLQUFLLFdBQVcsaUJBQWlCLEVBQUU7R0FDdEMsTUFBTSxPQUFPLHdDQUF3QyxFQUFFLFlBQWEsRUFBQztBQUNyRSxVQUFPLEtBQUssZ0JBQWdCLElBQUksc0NBQXNDLEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxPQUFPLFVBQVU7RUFDOUcsTUFDQSxRQUFPLEtBQUssMEJBQTBCLENBQUMsV0FBWSxFQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsZ0JBQWdCLE9BQU8sQ0FBQyxVQUFVO0NBRXpHO0NBRUQsTUFBTSwwQkFBMEJDLGVBQTZEO0VBQzVGLE1BQU0sT0FBTywwQ0FBMEMsRUFDdEQsZUFBZSxjQUFjLElBQUksQ0FBQyxnQkFBZ0Isb0JBQW9CLEVBQUUsT0FBTyxZQUFhLEVBQUMsQ0FBQyxDQUM5RixFQUFDO0VBQ0YsTUFBTSxTQUFTLE1BQU0sS0FBSyxnQkFBZ0IsSUFBSSx3Q0FBd0MsS0FBSztBQUMzRixTQUFPLE9BQU87Q0FDZDs7Ozs7OztDQVFELE1BQU0sYUFBYUMsZUFBbUJDLE9BQThCO0VBQ25FLE1BQU0sT0FBTyxrQ0FBa0M7R0FDOUMsT0FBTztHQUNQLGFBQWE7RUFDYixFQUFDO0FBQ0YsUUFBTSxLQUFLLGdCQUFnQixLQUFLLHlCQUF5QixLQUFLO0NBQzlEOzs7Ozs7Ozs7Q0FVRCxNQUFNLG1CQUFtQkQsZUFBbUJDLE9BQWVDLFNBQWlDO0VBQzNGLE1BQU0sYUFBYSx3Q0FBd0M7R0FDMUQsYUFBYTtHQUNiO0dBQ0EsT0FBTztFQUNQLEVBQUM7QUFDRixRQUFNLEtBQUssZ0JBQWdCLE9BQU8seUJBQXlCLFdBQVc7Q0FDdEU7Ozs7O0NBTUQsTUFBTSxlQUFlQyxhQUFpQkMsU0FBNEM7RUFDakYsTUFBTSxvQkFBb0IsTUFBTSxLQUFLLDZCQUE2QixhQUFhLFFBQVE7QUFDdkYsU0FBTyxLQUFLLG1CQUFtQixrQkFBa0I7Q0FDakQ7Ozs7O0NBTUQsTUFBTSxjQUFjRCxhQUFpQkwsYUFBcUJPLFlBQW9CRCxTQUE0QztFQUN6SCxNQUFNLG9CQUFvQixNQUFNLEtBQUssNkJBQTZCLGFBQWEsUUFBUTtFQUN2RixJQUFJLHNCQUFzQixrQkFBa0Isc0JBQXNCLEtBQUssQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLFlBQVk7QUFDNUcsTUFBSSx1QkFBdUIsTUFBTTtBQUNoQyx5QkFBc0IsNEJBQTRCO0lBQ2pEO0lBQ0EsWUFBWTtHQUNaLEVBQUM7QUFDRixxQkFBa0Isc0JBQXNCLEtBQUssb0JBQW9CO0VBQ2pFO0FBQ0Qsc0JBQW9CLGFBQWE7RUFDakMsTUFBTSxvQkFBb0IsTUFBTSxLQUFLLHdCQUF3QixtQkFBbUIsUUFBUTtBQUN4RixTQUFPLEtBQUssbUJBQW1CLGtCQUFrQjtDQUNqRDs7Ozs7Q0FNRCxNQUFNLGlCQUFpQkQsYUFBaUJMLGFBQXFCUSxTQUEyQztFQUN2RyxNQUFNLG9CQUFvQixNQUFNLEtBQUssNkJBQTZCLGFBQWEsUUFBUTtBQUN2RixnQkFBYyxrQkFBa0IsdUJBQXVCLENBQUMsTUFBTSxFQUFFLGdCQUFnQixZQUFZO0VBQzVGLE1BQU0sb0JBQW9CLE1BQU0sS0FBSyx3QkFBd0IsbUJBQW1CLFFBQVE7QUFDeEYsU0FBTyxLQUFLLG1CQUFtQixrQkFBa0I7Q0FDakQ7Q0FFRCxNQUFjLDZCQUE2QkgsYUFBaUJDLFNBQTBDO0VBRXJHLE1BQU0sbUJBQW1CLE1BQU0sS0FBSyx1QkFBdUIsS0FBSyx5QkFBeUIsWUFBWTtBQUVyRyxNQUFJLGlCQUFpQixxQkFBcUIsTUFBTTtHQUMvQyxNQUFNLGtCQUFrQixVQUNyQixNQUFNLEtBQUssZ0JBQWdCLDBCQUEwQixhQUFhLFFBQVEsR0FDMUUsTUFBTSxLQUFLLGdCQUFnQixrQ0FBa0MsWUFBWTtBQUM1RSxvQkFBaUIsb0JBQW9CLE1BQU0sS0FBSyx3QkFBd0Isa0JBQWtCLGdCQUFnQjtFQUMxRztFQUVELE1BQU0sbUJBQW1CLE9BQU9HLFlBQy9CLFVBQ0csTUFBTSxLQUFLLGdCQUFnQixtQkFBbUIsYUFBYSxTQUFTLFFBQVEsR0FDNUUsTUFBTSxLQUFLLGdCQUFnQiwyQkFBMkIsYUFBYSxRQUFRO0VBQy9FLE1BQU0sb0JBQW9CLE1BQU0sS0FBSyx1QkFBdUIsS0FBSywwQkFBMEIsaUJBQWlCLG1CQUFtQixFQUM5SCxrQkFBa0IsaUJBQ2xCLEVBQUM7QUFFRixTQUFPLGtCQUFrQixzQkFBc0IsV0FBVyxJQUFJLEtBQUssc0NBQXNDLG1CQUFtQixRQUFRLEdBQUc7Q0FDdkk7Ozs7O0NBTUQsTUFBYyxzQ0FBc0NDLG1CQUFzQ0osU0FBMEM7RUFDbkksTUFBTSxZQUFZLFVBQVUsTUFBTSxLQUFLLGtCQUFrQixRQUFRLEdBQUcsTUFBTSxLQUFLLGtCQUFrQixrQkFBa0IsWUFBYTtFQUNoSSxNQUFNLG1CQUFtQixVQUFVO0VBQ25DLE1BQU0sZ0JBQWdCLG9DQUFvQyxVQUFVO0FBQ3BFLE9BQUssTUFBTSxlQUFlLGNBQ3pCLG1CQUFrQixzQkFBc0IsS0FDdkMsNEJBQTRCO0dBQzNCO0dBQ0EsWUFBWTtFQUNaLEVBQUMsQ0FDRjtBQUVGLFNBQU8sS0FBSyx3QkFBd0IsbUJBQW1CLFFBQVE7Q0FDL0Q7Q0FFRCxNQUFjLGtCQUFrQkssUUFBZ0M7RUFDL0QsTUFBTSxPQUFPLE1BQU0sS0FBSyx1QkFBdUIsS0FBSyxhQUFhLE9BQU87QUFDeEUsU0FBTyxNQUFNLEtBQUssdUJBQXVCLEtBQUssa0JBQWtCLEtBQUssVUFBVSxVQUFVO0NBQ3pGO0NBRUQsTUFBYyxrQkFBa0JDLFNBQWlDO0VBQ2hFLE1BQU0sUUFBUSxNQUFNLEtBQUssdUJBQXVCLEtBQUssY0FBYyxRQUFRO0FBQzNFLFNBQU8sTUFBTSxLQUFLLHVCQUF1QixLQUFLLGtCQUFrQixNQUFNLFVBQVU7Q0FDaEY7Q0FFRCxNQUFjLHdCQUF3QkMsa0JBQW9DQyxVQUFxQztFQUM5RyxNQUFNLGNBQWMsaUJBQWlCO0VBQ3JDLE1BQU0sb0JBQW9CLHdCQUF3QjtHQUNqRCxHQUFJLGVBQWUsT0FBTyxFQUFFLFlBQWEsSUFBRztHQUM1QyxrQkFBa0I7R0FDbEIsdUJBQXVCLENBQUU7RUFDekIsRUFBQztBQUVGLFNBQU8sS0FBSyx1QkFBdUIsTUFBTSxNQUFNLG1CQUFtQixXQUFXLEVBQUUsVUFBVSxTQUFVLEVBQUMsQ0FBQyxNQUNwRyxRQUFRLHlCQUF5QixDQUFDLE1BQU07QUFFdkMsT0FBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLFdBQVcsVUFBVSxFQUFFO0lBQzNDLE1BQU0sYUFBYSxFQUFFLEtBQUssVUFBVSxVQUFVLE9BQU87QUFDckQsWUFBUSxJQUFJLG9DQUFvQyxXQUFXO0FBQzNELFdBQU87R0FDUCxNQUNBLE9BQU0sSUFBSSxrQkFBa0Isb0RBQW9ELEVBQUUsS0FBSztFQUV4RixFQUFDLENBQ0Y7Q0FDRDtDQUVELE1BQWMsd0JBQXdCSixtQkFBc0NKLFNBQTBDO0VBQ3JILE1BQU0sbUJBQW1CLE9BQU9HLFlBQy9CLFVBQ0csTUFBTSxLQUFLLGdCQUFnQixtQkFBbUIsY0FBYyxrQkFBa0IsWUFBWSxFQUFFLFNBQVMsUUFBUSxHQUM3RyxNQUFNLEtBQUssZ0JBQWdCLDJCQUEyQixjQUFjLGtCQUFrQixZQUFZLEVBQUUsUUFBUTtBQUNoSCxRQUFNLEtBQUssdUJBQXVCLE9BQU8sbUJBQW1CLEVBQUUsa0JBQWtCLGlCQUFrQixFQUFDO0FBQ25HLFNBQU8sTUFBTSxLQUFLLHVCQUF1QixLQUFLLDBCQUEwQixrQkFBa0IsS0FBSyxFQUFFLGtCQUFrQixpQkFBa0IsRUFBQztDQUN0STtDQUVELE1BQWMsbUJBQW1CQyxtQkFBb0U7RUFDcEcsTUFBTSxTQUFTLElBQUk7QUFDbkIsT0FBSyxNQUFNLFFBQVEsa0JBQWtCLHNCQUNwQyxRQUFPLElBQUksS0FBSyxhQUFhLEtBQUssV0FBVztBQUU5QyxTQUFPO0NBQ1A7QUFDRCJ9