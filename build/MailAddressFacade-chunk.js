import "./dist-chunk.js";
import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { assertWorkerOrNode } from "./Env-chunk.js";
import { assertNotNull, findAndRemove, getFirstOrThrow, ofClass } from "./dist2-chunk.js";
import "./TutanotaConstants-chunk.js";
import "./EntityUtils-chunk.js";
import "./TypeModels-chunk.js";
import { MailboxGroupRootTypeRef, MailboxPropertiesTypeRef, createMailAddressProperties, createMailboxProperties } from "./TypeRefs-chunk.js";
import "./TypeModels2-chunk.js";
import { GroupInfoTypeRef, GroupTypeRef, UserTypeRef, createDomainMailAddressAvailabilityData, createMailAddressAliasGetIn, createMailAddressAliasServiceData, createMailAddressAliasServiceDataDelete, createMultipleMailAddressAvailabilityData, createStringWrapper } from "./TypeRefs2-chunk.js";
import { PreconditionFailedError } from "./RestError-chunk.js";
import { DomainMailAddressAvailabilityService, MailAddressAliasService, MultipleMailAddressAvailabilityService } from "./Services-chunk.js";
import { getEnabledMailAddressesForGroupInfo } from "./GroupUtils-chunk.js";

//#region src/common/api/worker/facades/lazy/MailAddressFacade.ts
assertWorkerOrNode();
var MailAddressFacade = class {
	constructor(userFacade, groupManagement, serviceExecutor, nonCachingEntityClient) {
		this.userFacade = userFacade;
		this.groupManagement = groupManagement;
		this.serviceExecutor = serviceExecutor;
		this.nonCachingEntityClient = nonCachingEntityClient;
	}
	/**
	* For legacy accounts the given userGroupId is ignored since the alias counters are for the customer
	*/
	getAliasCounters(userGroupId) {
		const data = createMailAddressAliasGetIn({ targetGroup: userGroupId });
		return this.serviceExecutor.get(MailAddressAliasService, data);
	}
	isMailAddressAvailable(mailAddress) {
		if (this.userFacade.isFullyLoggedIn()) {
			const data = createDomainMailAddressAvailabilityData({ mailAddress });
			return this.serviceExecutor.get(DomainMailAddressAvailabilityService, data).then((result) => result.available);
		} else return this.areMailAddressesAvailable([mailAddress]).then((result) => getFirstOrThrow(result).available);
	}
	async areMailAddressesAvailable(mailAddresses) {
		const data = createMultipleMailAddressAvailabilityData({ mailAddresses: mailAddresses.map((mailAddress) => createStringWrapper({ value: mailAddress })) });
		const result = await this.serviceExecutor.get(MultipleMailAddressAvailabilityService, data);
		return result.availabilities;
	}
	/**
	* Add an {@param alias} to {@param targetGroupId}.
	* {@param targetGroupId} is *not* a Mail group, it is currently only a user group.
	*
	* Can only be done by an admin.
	*/
	async addMailAlias(targetGroupId, alias) {
		const data = createMailAddressAliasServiceData({
			group: targetGroupId,
			mailAddress: alias
		});
		await this.serviceExecutor.post(MailAddressAliasService, data);
	}
	/**
	* Enable/disable an {@param alias} on {@param targetGroupId}.
	* {@param targetGroupId} is *not* a Mail group, it is currently only a user group.
	*
	* {@param restore} means whether the alias will be enabled or disabled.
	*
	* Can only be done by an admin.
	*/
	async setMailAliasStatus(targetGroupId, alias, restore) {
		const deleteData = createMailAddressAliasServiceDataDelete({
			mailAddress: alias,
			restore,
			group: targetGroupId
		});
		await this.serviceExecutor.delete(MailAddressAliasService, deleteData);
	}
	/**
	* Get mailAddress to senderName mappings for mail group that the specified user is a member of.
	* if no user is given, the operation is attempted as an admin of the given group.
	* */
	async getSenderNames(mailGroupId, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		return this.collectSenderNames(mailboxProperties);
	}
	/**
	* Set mailAddress to senderName mapping for mail group that the specified user is a member of.
	* if no user is specified, the operation will be attempted as an admin of the given group.
	* */
	async setSenderName(mailGroupId, mailAddress, senderName, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		let mailAddressProperty = mailboxProperties.mailAddressProperties.find((p) => p.mailAddress === mailAddress);
		if (mailAddressProperty == null) {
			mailAddressProperty = createMailAddressProperties({
				mailAddress,
				senderName: ""
			});
			mailboxProperties.mailAddressProperties.push(mailAddressProperty);
		}
		mailAddressProperty.senderName = senderName;
		const updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser);
		return this.collectSenderNames(updatedProperties);
	}
	/**
	* remove the sender name of the given mail address.
	* If no user is given, the operation will be attempted as an admin of the group.
	*/
	async removeSenderName(mailGroupId, mailAddress, viaUser) {
		const mailboxProperties = await this.getOrCreateMailboxProperties(mailGroupId, viaUser);
		findAndRemove(mailboxProperties.mailAddressProperties, (p) => p.mailAddress === mailAddress);
		const updatedProperties = await this.updateMailboxProperties(mailboxProperties, viaUser);
		return this.collectSenderNames(updatedProperties);
	}
	async getOrCreateMailboxProperties(mailGroupId, viaUser) {
		const mailboxGroupRoot = await this.nonCachingEntityClient.load(MailboxGroupRootTypeRef, mailGroupId);
		if (mailboxGroupRoot.mailboxProperties == null) {
			const currentGroupKey = viaUser ? await this.groupManagement.getCurrentGroupKeyViaUser(mailGroupId, viaUser) : await this.groupManagement.getCurrentGroupKeyViaAdminEncGKey(mailGroupId);
			mailboxGroupRoot.mailboxProperties = await this.createMailboxProperties(mailboxGroupRoot, currentGroupKey);
		}
		const groupKeyProvider = async (version) => viaUser ? await this.groupManagement.getGroupKeyViaUser(mailGroupId, version, viaUser) : await this.groupManagement.getGroupKeyViaAdminEncGKey(mailGroupId, version);
		const mailboxProperties = await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxGroupRoot.mailboxProperties, { ownerKeyProvider: groupKeyProvider });
		return mailboxProperties.mailAddressProperties.length === 0 ? this.mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) : mailboxProperties;
	}
	/**
	* set the legacy sender name (groupInfo.name) of the group on all assigned mail addresses.
	* if no user is given, the operation will be attempted as an admin of the group of the given mailboxProperties.
	* */
	async mailboxPropertiesWithLegacySenderName(mailboxProperties, viaUser) {
		const groupInfo = viaUser ? await this.loadUserGroupInfo(viaUser) : await this.loadMailGroupInfo(mailboxProperties._ownerGroup);
		const legacySenderName = groupInfo.name;
		const mailAddresses = getEnabledMailAddressesForGroupInfo(groupInfo);
		for (const mailAddress of mailAddresses) mailboxProperties.mailAddressProperties.push(createMailAddressProperties({
			mailAddress,
			senderName: legacySenderName
		}));
		return this.updateMailboxProperties(mailboxProperties, viaUser);
	}
	async loadUserGroupInfo(userId) {
		const user = await this.nonCachingEntityClient.load(UserTypeRef, userId);
		return await this.nonCachingEntityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo);
	}
	async loadMailGroupInfo(groupId) {
		const group = await this.nonCachingEntityClient.load(GroupTypeRef, groupId);
		return await this.nonCachingEntityClient.load(GroupInfoTypeRef, group.groupInfo);
	}
	async createMailboxProperties(mailboxGroupRoot, groupKey) {
		const _ownerGroup = mailboxGroupRoot._ownerGroup;
		const mailboxProperties = createMailboxProperties({
			..._ownerGroup != null ? { _ownerGroup } : null,
			reportMovedMails: "",
			mailAddressProperties: []
		});
		return this.nonCachingEntityClient.setup(null, mailboxProperties, undefined, { ownerKey: groupKey }).catch(ofClass(PreconditionFailedError, (e) => {
			if (e.data && e.data.startsWith("exists:")) {
				const existingId = e.data.substring("exists:".length);
				console.log("mailboxProperties already exists", existingId);
				return existingId;
			} else throw new ProgrammingError(`Could not create mailboxProperties, precondition: ${e.data}`);
		}));
	}
	async updateMailboxProperties(mailboxProperties, viaUser) {
		const groupKeyProvider = async (version) => viaUser ? await this.groupManagement.getGroupKeyViaUser(assertNotNull(mailboxProperties._ownerGroup), version, viaUser) : await this.groupManagement.getGroupKeyViaAdminEncGKey(assertNotNull(mailboxProperties._ownerGroup), version);
		await this.nonCachingEntityClient.update(mailboxProperties, { ownerKeyProvider: groupKeyProvider });
		return await this.nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxProperties._id, { ownerKeyProvider: groupKeyProvider });
	}
	async collectSenderNames(mailboxProperties) {
		const result = new Map();
		for (const data of mailboxProperties.mailAddressProperties) result.set(data.mailAddress, data.senderName);
		return result;
	}
};

//#endregion
export { MailAddressFacade };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFpbEFkZHJlc3NGYWNhZGUtY2h1bmsuanMiLCJuYW1lcyI6WyJ1c2VyRmFjYWRlOiBVc2VyRmFjYWRlIiwiZ3JvdXBNYW5hZ2VtZW50OiBHcm91cE1hbmFnZW1lbnRGYWNhZGUiLCJzZXJ2aWNlRXhlY3V0b3I6IElTZXJ2aWNlRXhlY3V0b3IiLCJub25DYWNoaW5nRW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQiLCJ1c2VyR3JvdXBJZDogSWQiLCJtYWlsQWRkcmVzczogc3RyaW5nIiwibWFpbEFkZHJlc3Nlczogc3RyaW5nW10iLCJ0YXJnZXRHcm91cElkOiBJZCIsImFsaWFzOiBzdHJpbmciLCJyZXN0b3JlOiBib29sZWFuIiwibWFpbEdyb3VwSWQ6IElkIiwidmlhVXNlcj86IElkIiwic2VuZGVyTmFtZTogc3RyaW5nIiwidmlhVXNlcjogSWQiLCJ2ZXJzaW9uOiBLZXlWZXJzaW9uIiwibWFpbGJveFByb3BlcnRpZXM6IE1haWxib3hQcm9wZXJ0aWVzIiwidXNlcklkOiBJZCIsImdyb3VwSWQ6IElkIiwibWFpbGJveEdyb3VwUm9vdDogTWFpbGJveEdyb3VwUm9vdCIsImdyb3VwS2V5OiBWZXJzaW9uZWRLZXkiXSwic291cmNlcyI6WyIuLi9zcmMvY29tbW9uL2FwaS93b3JrZXIvZmFjYWRlcy9sYXp5L01haWxBZGRyZXNzRmFjYWRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgR3JvdXBJbmZvLCBNYWlsQWRkcmVzc0FsaWFzU2VydmljZVJldHVybiwgTWFpbEFkZHJlc3NBdmFpbGFiaWxpdHkgfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvc3lzL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7XG5cdGNyZWF0ZURvbWFpbk1haWxBZGRyZXNzQXZhaWxhYmlsaXR5RGF0YSxcblx0Y3JlYXRlTWFpbEFkZHJlc3NBbGlhc0dldEluLFxuXHRjcmVhdGVNYWlsQWRkcmVzc0FsaWFzU2VydmljZURhdGEsXG5cdGNyZWF0ZU1haWxBZGRyZXNzQWxpYXNTZXJ2aWNlRGF0YURlbGV0ZSxcblx0Y3JlYXRlTXVsdGlwbGVNYWlsQWRkcmVzc0F2YWlsYWJpbGl0eURhdGEsXG5cdGNyZWF0ZVN0cmluZ1dyYXBwZXIsXG5cdEdyb3VwSW5mb1R5cGVSZWYsXG5cdEdyb3VwVHlwZVJlZixcblx0VXNlclR5cGVSZWYsXG59IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgRG9tYWluTWFpbEFkZHJlc3NBdmFpbGFiaWxpdHlTZXJ2aWNlLCBNYWlsQWRkcmVzc0FsaWFzU2VydmljZSwgTXVsdGlwbGVNYWlsQWRkcmVzc0F2YWlsYWJpbGl0eVNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvc3lzL1NlcnZpY2VzLmpzXCJcbmltcG9ydCB7IGFzc2VydFdvcmtlck9yTm9kZSB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vRW52LmpzXCJcbmltcG9ydCB7IElTZXJ2aWNlRXhlY3V0b3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL1NlcnZpY2VSZXF1ZXN0LmpzXCJcbmltcG9ydCB7IFVzZXJGYWNhZGUgfSBmcm9tIFwiLi4vVXNlckZhY2FkZS5qc1wiXG5pbXBvcnQgeyBFbnRpdHlDbGllbnQgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL0VudGl0eUNsaWVudC5qc1wiXG5pbXBvcnQge1xuXHRjcmVhdGVNYWlsQWRkcmVzc1Byb3BlcnRpZXMsXG5cdGNyZWF0ZU1haWxib3hQcm9wZXJ0aWVzLFxuXHRNYWlsYm94R3JvdXBSb290LFxuXHRNYWlsYm94R3JvdXBSb290VHlwZVJlZixcblx0TWFpbGJveFByb3BlcnRpZXMsXG5cdE1haWxib3hQcm9wZXJ0aWVzVHlwZVJlZixcbn0gZnJvbSBcIi4uLy4uLy4uL2VudGl0aWVzL3R1dGFub3RhL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IGFzc2VydE5vdE51bGwsIGZpbmRBbmRSZW1vdmUsIGdldEZpcnN0T3JUaHJvdywgS2V5VmVyc2lvbiwgb2ZDbGFzcyB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgZ2V0RW5hYmxlZE1haWxBZGRyZXNzZXNGb3JHcm91cEluZm8gfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3V0aWxzL0dyb3VwVXRpbHMuanNcIlxuaW1wb3J0IHsgUHJlY29uZGl0aW9uRmFpbGVkRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2Vycm9yL1Jlc3RFcnJvci5qc1wiXG5pbXBvcnQgeyBQcm9ncmFtbWluZ0Vycm9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9lcnJvci9Qcm9ncmFtbWluZ0Vycm9yLmpzXCJcbmltcG9ydCB7IEdyb3VwTWFuYWdlbWVudEZhY2FkZSB9IGZyb20gXCIuL0dyb3VwTWFuYWdlbWVudEZhY2FkZS5qc1wiXG5cbmltcG9ydCB7IFZlcnNpb25lZEtleSB9IGZyb20gXCIuLi8uLi9jcnlwdG8vQ3J5cHRvV3JhcHBlci5qc1wiXG5cbmFzc2VydFdvcmtlck9yTm9kZSgpXG5cbmV4cG9ydCBjbGFzcyBNYWlsQWRkcmVzc0ZhY2FkZSB7XG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgdXNlckZhY2FkZTogVXNlckZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGdyb3VwTWFuYWdlbWVudDogR3JvdXBNYW5hZ2VtZW50RmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgc2VydmljZUV4ZWN1dG9yOiBJU2VydmljZUV4ZWN1dG9yLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgbm9uQ2FjaGluZ0VudGl0eUNsaWVudDogRW50aXR5Q2xpZW50LFxuXHQpIHt9XG5cblx0LyoqXG5cdCAqIEZvciBsZWdhY3kgYWNjb3VudHMgdGhlIGdpdmVuIHVzZXJHcm91cElkIGlzIGlnbm9yZWQgc2luY2UgdGhlIGFsaWFzIGNvdW50ZXJzIGFyZSBmb3IgdGhlIGN1c3RvbWVyXG5cdCAqL1xuXHRnZXRBbGlhc0NvdW50ZXJzKHVzZXJHcm91cElkOiBJZCk6IFByb21pc2U8TWFpbEFkZHJlc3NBbGlhc1NlcnZpY2VSZXR1cm4+IHtcblx0XHRjb25zdCBkYXRhID0gY3JlYXRlTWFpbEFkZHJlc3NBbGlhc0dldEluKHsgdGFyZ2V0R3JvdXA6IHVzZXJHcm91cElkIH0pXG5cdFx0cmV0dXJuIHRoaXMuc2VydmljZUV4ZWN1dG9yLmdldChNYWlsQWRkcmVzc0FsaWFzU2VydmljZSwgZGF0YSlcblx0fVxuXG5cdGlzTWFpbEFkZHJlc3NBdmFpbGFibGUobWFpbEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGlmICh0aGlzLnVzZXJGYWNhZGUuaXNGdWxseUxvZ2dlZEluKCkpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBjcmVhdGVEb21haW5NYWlsQWRkcmVzc0F2YWlsYWJpbGl0eURhdGEoeyBtYWlsQWRkcmVzcyB9KVxuXHRcdFx0cmV0dXJuIHRoaXMuc2VydmljZUV4ZWN1dG9yLmdldChEb21haW5NYWlsQWRkcmVzc0F2YWlsYWJpbGl0eVNlcnZpY2UsIGRhdGEpLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0LmF2YWlsYWJsZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJlTWFpbEFkZHJlc3Nlc0F2YWlsYWJsZShbbWFpbEFkZHJlc3NdKS50aGVuKChyZXN1bHQpID0+IGdldEZpcnN0T3JUaHJvdyhyZXN1bHQpLmF2YWlsYWJsZSlcblx0XHR9XG5cdH1cblxuXHRhc3luYyBhcmVNYWlsQWRkcmVzc2VzQXZhaWxhYmxlKG1haWxBZGRyZXNzZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxNYWlsQWRkcmVzc0F2YWlsYWJpbGl0eVtdPiB7XG5cdFx0Y29uc3QgZGF0YSA9IGNyZWF0ZU11bHRpcGxlTWFpbEFkZHJlc3NBdmFpbGFiaWxpdHlEYXRhKHtcblx0XHRcdG1haWxBZGRyZXNzZXM6IG1haWxBZGRyZXNzZXMubWFwKChtYWlsQWRkcmVzcykgPT4gY3JlYXRlU3RyaW5nV3JhcHBlcih7IHZhbHVlOiBtYWlsQWRkcmVzcyB9KSksXG5cdFx0fSlcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5nZXQoTXVsdGlwbGVNYWlsQWRkcmVzc0F2YWlsYWJpbGl0eVNlcnZpY2UsIGRhdGEpXG5cdFx0cmV0dXJuIHJlc3VsdC5hdmFpbGFiaWxpdGllc1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhbiB7QHBhcmFtIGFsaWFzfSB0byB7QHBhcmFtIHRhcmdldEdyb3VwSWR9LlxuXHQgKiB7QHBhcmFtIHRhcmdldEdyb3VwSWR9IGlzICpub3QqIGEgTWFpbCBncm91cCwgaXQgaXMgY3VycmVudGx5IG9ubHkgYSB1c2VyIGdyb3VwLlxuXHQgKlxuXHQgKiBDYW4gb25seSBiZSBkb25lIGJ5IGFuIGFkbWluLlxuXHQgKi9cblx0YXN5bmMgYWRkTWFpbEFsaWFzKHRhcmdldEdyb3VwSWQ6IElkLCBhbGlhczogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgZGF0YSA9IGNyZWF0ZU1haWxBZGRyZXNzQWxpYXNTZXJ2aWNlRGF0YSh7XG5cdFx0XHRncm91cDogdGFyZ2V0R3JvdXBJZCxcblx0XHRcdG1haWxBZGRyZXNzOiBhbGlhcyxcblx0XHR9KVxuXHRcdGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoTWFpbEFkZHJlc3NBbGlhc1NlcnZpY2UsIGRhdGEpXG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlL2Rpc2FibGUgYW4ge0BwYXJhbSBhbGlhc30gb24ge0BwYXJhbSB0YXJnZXRHcm91cElkfS5cblx0ICoge0BwYXJhbSB0YXJnZXRHcm91cElkfSBpcyAqbm90KiBhIE1haWwgZ3JvdXAsIGl0IGlzIGN1cnJlbnRseSBvbmx5IGEgdXNlciBncm91cC5cblx0ICpcblx0ICoge0BwYXJhbSByZXN0b3JlfSBtZWFucyB3aGV0aGVyIHRoZSBhbGlhcyB3aWxsIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG5cdCAqXG5cdCAqIENhbiBvbmx5IGJlIGRvbmUgYnkgYW4gYWRtaW4uXG5cdCAqL1xuXHRhc3luYyBzZXRNYWlsQWxpYXNTdGF0dXModGFyZ2V0R3JvdXBJZDogSWQsIGFsaWFzOiBzdHJpbmcsIHJlc3RvcmU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBkZWxldGVEYXRhID0gY3JlYXRlTWFpbEFkZHJlc3NBbGlhc1NlcnZpY2VEYXRhRGVsZXRlKHtcblx0XHRcdG1haWxBZGRyZXNzOiBhbGlhcyxcblx0XHRcdHJlc3RvcmUsXG5cdFx0XHRncm91cDogdGFyZ2V0R3JvdXBJZCxcblx0XHR9KVxuXHRcdGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLmRlbGV0ZShNYWlsQWRkcmVzc0FsaWFzU2VydmljZSwgZGVsZXRlRGF0YSlcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgbWFpbEFkZHJlc3MgdG8gc2VuZGVyTmFtZSBtYXBwaW5ncyBmb3IgbWFpbCBncm91cCB0aGF0IHRoZSBzcGVjaWZpZWQgdXNlciBpcyBhIG1lbWJlciBvZi5cblx0ICogaWYgbm8gdXNlciBpcyBnaXZlbiwgdGhlIG9wZXJhdGlvbiBpcyBhdHRlbXB0ZWQgYXMgYW4gYWRtaW4gb2YgdGhlIGdpdmVuIGdyb3VwLlxuXHQgKiAqL1xuXHRhc3luYyBnZXRTZW5kZXJOYW1lcyhtYWlsR3JvdXBJZDogSWQsIHZpYVVzZXI/OiBJZCk6IFByb21pc2U8TWFwPHN0cmluZywgc3RyaW5nPj4ge1xuXHRcdGNvbnN0IG1haWxib3hQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy5nZXRPckNyZWF0ZU1haWxib3hQcm9wZXJ0aWVzKG1haWxHcm91cElkLCB2aWFVc2VyKVxuXHRcdHJldHVybiB0aGlzLmNvbGxlY3RTZW5kZXJOYW1lcyhtYWlsYm94UHJvcGVydGllcylcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgbWFpbEFkZHJlc3MgdG8gc2VuZGVyTmFtZSBtYXBwaW5nIGZvciBtYWlsIGdyb3VwIHRoYXQgdGhlIHNwZWNpZmllZCB1c2VyIGlzIGEgbWVtYmVyIG9mLlxuXHQgKiBpZiBubyB1c2VyIGlzIHNwZWNpZmllZCwgdGhlIG9wZXJhdGlvbiB3aWxsIGJlIGF0dGVtcHRlZCBhcyBhbiBhZG1pbiBvZiB0aGUgZ2l2ZW4gZ3JvdXAuXG5cdCAqICovXG5cdGFzeW5jIHNldFNlbmRlck5hbWUobWFpbEdyb3VwSWQ6IElkLCBtYWlsQWRkcmVzczogc3RyaW5nLCBzZW5kZXJOYW1lOiBzdHJpbmcsIHZpYVVzZXI/OiBJZCk6IFByb21pc2U8TWFwPHN0cmluZywgc3RyaW5nPj4ge1xuXHRcdGNvbnN0IG1haWxib3hQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy5nZXRPckNyZWF0ZU1haWxib3hQcm9wZXJ0aWVzKG1haWxHcm91cElkLCB2aWFVc2VyKVxuXHRcdGxldCBtYWlsQWRkcmVzc1Byb3BlcnR5ID0gbWFpbGJveFByb3BlcnRpZXMubWFpbEFkZHJlc3NQcm9wZXJ0aWVzLmZpbmQoKHApID0+IHAubWFpbEFkZHJlc3MgPT09IG1haWxBZGRyZXNzKVxuXHRcdGlmIChtYWlsQWRkcmVzc1Byb3BlcnR5ID09IG51bGwpIHtcblx0XHRcdG1haWxBZGRyZXNzUHJvcGVydHkgPSBjcmVhdGVNYWlsQWRkcmVzc1Byb3BlcnRpZXMoe1xuXHRcdFx0XHRtYWlsQWRkcmVzcyxcblx0XHRcdFx0c2VuZGVyTmFtZTogXCJcIixcblx0XHRcdH0pXG5cdFx0XHRtYWlsYm94UHJvcGVydGllcy5tYWlsQWRkcmVzc1Byb3BlcnRpZXMucHVzaChtYWlsQWRkcmVzc1Byb3BlcnR5KVxuXHRcdH1cblx0XHRtYWlsQWRkcmVzc1Byb3BlcnR5LnNlbmRlck5hbWUgPSBzZW5kZXJOYW1lXG5cdFx0Y29uc3QgdXBkYXRlZFByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLnVwZGF0ZU1haWxib3hQcm9wZXJ0aWVzKG1haWxib3hQcm9wZXJ0aWVzLCB2aWFVc2VyKVxuXHRcdHJldHVybiB0aGlzLmNvbGxlY3RTZW5kZXJOYW1lcyh1cGRhdGVkUHJvcGVydGllcylcblx0fVxuXG5cdC8qKlxuXHQgKiByZW1vdmUgdGhlIHNlbmRlciBuYW1lIG9mIHRoZSBnaXZlbiBtYWlsIGFkZHJlc3MuXG5cdCAqIElmIG5vIHVzZXIgaXMgZ2l2ZW4sIHRoZSBvcGVyYXRpb24gd2lsbCBiZSBhdHRlbXB0ZWQgYXMgYW4gYWRtaW4gb2YgdGhlIGdyb3VwLlxuXHQgKi9cblx0YXN5bmMgcmVtb3ZlU2VuZGVyTmFtZShtYWlsR3JvdXBJZDogSWQsIG1haWxBZGRyZXNzOiBzdHJpbmcsIHZpYVVzZXI6IElkKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBzdHJpbmc+PiB7XG5cdFx0Y29uc3QgbWFpbGJveFByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbEdyb3VwSWQsIHZpYVVzZXIpXG5cdFx0ZmluZEFuZFJlbW92ZShtYWlsYm94UHJvcGVydGllcy5tYWlsQWRkcmVzc1Byb3BlcnRpZXMsIChwKSA9PiBwLm1haWxBZGRyZXNzID09PSBtYWlsQWRkcmVzcylcblx0XHRjb25zdCB1cGRhdGVkUHJvcGVydGllcyA9IGF3YWl0IHRoaXMudXBkYXRlTWFpbGJveFByb3BlcnRpZXMobWFpbGJveFByb3BlcnRpZXMsIHZpYVVzZXIpXG5cdFx0cmV0dXJuIHRoaXMuY29sbGVjdFNlbmRlck5hbWVzKHVwZGF0ZWRQcm9wZXJ0aWVzKVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBnZXRPckNyZWF0ZU1haWxib3hQcm9wZXJ0aWVzKG1haWxHcm91cElkOiBJZCwgdmlhVXNlcj86IElkKTogUHJvbWlzZTxNYWlsYm94UHJvcGVydGllcz4ge1xuXHRcdC8vIFVzaW5nIG5vbi1jYWNoaW5nIGVudGl0eUNsaWVudCBiZWNhdXNlIHdlIGFyZSBub3QgYSBtZW1iZXIgb2YgdGhlIHVzZXIncyBtYWlsIGdyb3VwLCBhbmQgd2Ugd29uJ3QgcmVjZWl2ZSB1cGRhdGVzIGZvciBpdFxuXHRcdGNvbnN0IG1haWxib3hHcm91cFJvb3QgPSBhd2FpdCB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQubG9hZChNYWlsYm94R3JvdXBSb290VHlwZVJlZiwgbWFpbEdyb3VwSWQpXG5cblx0XHRpZiAobWFpbGJveEdyb3VwUm9vdC5tYWlsYm94UHJvcGVydGllcyA9PSBudWxsKSB7XG5cdFx0XHRjb25zdCBjdXJyZW50R3JvdXBLZXkgPSB2aWFVc2VyXG5cdFx0XHRcdD8gYXdhaXQgdGhpcy5ncm91cE1hbmFnZW1lbnQuZ2V0Q3VycmVudEdyb3VwS2V5VmlhVXNlcihtYWlsR3JvdXBJZCwgdmlhVXNlcilcblx0XHRcdFx0OiBhd2FpdCB0aGlzLmdyb3VwTWFuYWdlbWVudC5nZXRDdXJyZW50R3JvdXBLZXlWaWFBZG1pbkVuY0dLZXkobWFpbEdyb3VwSWQpXG5cdFx0XHRtYWlsYm94R3JvdXBSb290Lm1haWxib3hQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy5jcmVhdGVNYWlsYm94UHJvcGVydGllcyhtYWlsYm94R3JvdXBSb290LCBjdXJyZW50R3JvdXBLZXkpXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ3JvdXBLZXlQcm92aWRlciA9IGFzeW5jICh2ZXJzaW9uOiBLZXlWZXJzaW9uKSA9PlxuXHRcdFx0dmlhVXNlclxuXHRcdFx0XHQ/IGF3YWl0IHRoaXMuZ3JvdXBNYW5hZ2VtZW50LmdldEdyb3VwS2V5VmlhVXNlcihtYWlsR3JvdXBJZCwgdmVyc2lvbiwgdmlhVXNlcilcblx0XHRcdFx0OiBhd2FpdCB0aGlzLmdyb3VwTWFuYWdlbWVudC5nZXRHcm91cEtleVZpYUFkbWluRW5jR0tleShtYWlsR3JvdXBJZCwgdmVyc2lvbilcblx0XHRjb25zdCBtYWlsYm94UHJvcGVydGllcyA9IGF3YWl0IHRoaXMubm9uQ2FjaGluZ0VudGl0eUNsaWVudC5sb2FkKE1haWxib3hQcm9wZXJ0aWVzVHlwZVJlZiwgbWFpbGJveEdyb3VwUm9vdC5tYWlsYm94UHJvcGVydGllcywge1xuXHRcdFx0b3duZXJLZXlQcm92aWRlcjogZ3JvdXBLZXlQcm92aWRlcixcblx0XHR9KVxuXG5cdFx0cmV0dXJuIG1haWxib3hQcm9wZXJ0aWVzLm1haWxBZGRyZXNzUHJvcGVydGllcy5sZW5ndGggPT09IDAgPyB0aGlzLm1haWxib3hQcm9wZXJ0aWVzV2l0aExlZ2FjeVNlbmRlck5hbWUobWFpbGJveFByb3BlcnRpZXMsIHZpYVVzZXIpIDogbWFpbGJveFByb3BlcnRpZXNcblx0fVxuXG5cdC8qKlxuXHQgKiBzZXQgdGhlIGxlZ2FjeSBzZW5kZXIgbmFtZSAoZ3JvdXBJbmZvLm5hbWUpIG9mIHRoZSBncm91cCBvbiBhbGwgYXNzaWduZWQgbWFpbCBhZGRyZXNzZXMuXG5cdCAqIGlmIG5vIHVzZXIgaXMgZ2l2ZW4sIHRoZSBvcGVyYXRpb24gd2lsbCBiZSBhdHRlbXB0ZWQgYXMgYW4gYWRtaW4gb2YgdGhlIGdyb3VwIG9mIHRoZSBnaXZlbiBtYWlsYm94UHJvcGVydGllcy5cblx0ICogKi9cblx0cHJpdmF0ZSBhc3luYyBtYWlsYm94UHJvcGVydGllc1dpdGhMZWdhY3lTZW5kZXJOYW1lKG1haWxib3hQcm9wZXJ0aWVzOiBNYWlsYm94UHJvcGVydGllcywgdmlhVXNlcj86IElkKTogUHJvbWlzZTxNYWlsYm94UHJvcGVydGllcz4ge1xuXHRcdGNvbnN0IGdyb3VwSW5mbyA9IHZpYVVzZXIgPyBhd2FpdCB0aGlzLmxvYWRVc2VyR3JvdXBJbmZvKHZpYVVzZXIpIDogYXdhaXQgdGhpcy5sb2FkTWFpbEdyb3VwSW5mbyhtYWlsYm94UHJvcGVydGllcy5fb3duZXJHcm91cCEpXG5cdFx0Y29uc3QgbGVnYWN5U2VuZGVyTmFtZSA9IGdyb3VwSW5mby5uYW1lXG5cdFx0Y29uc3QgbWFpbEFkZHJlc3NlcyA9IGdldEVuYWJsZWRNYWlsQWRkcmVzc2VzRm9yR3JvdXBJbmZvKGdyb3VwSW5mbylcblx0XHRmb3IgKGNvbnN0IG1haWxBZGRyZXNzIG9mIG1haWxBZGRyZXNzZXMpIHtcblx0XHRcdG1haWxib3hQcm9wZXJ0aWVzLm1haWxBZGRyZXNzUHJvcGVydGllcy5wdXNoKFxuXHRcdFx0XHRjcmVhdGVNYWlsQWRkcmVzc1Byb3BlcnRpZXMoe1xuXHRcdFx0XHRcdG1haWxBZGRyZXNzLFxuXHRcdFx0XHRcdHNlbmRlck5hbWU6IGxlZ2FjeVNlbmRlck5hbWUsXG5cdFx0XHRcdH0pLFxuXHRcdFx0KVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy51cGRhdGVNYWlsYm94UHJvcGVydGllcyhtYWlsYm94UHJvcGVydGllcywgdmlhVXNlcilcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgbG9hZFVzZXJHcm91cEluZm8odXNlcklkOiBJZCk6IFByb21pc2U8R3JvdXBJbmZvPiB7XG5cdFx0Y29uc3QgdXNlciA9IGF3YWl0IHRoaXMubm9uQ2FjaGluZ0VudGl0eUNsaWVudC5sb2FkKFVzZXJUeXBlUmVmLCB1c2VySWQpXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMubm9uQ2FjaGluZ0VudGl0eUNsaWVudC5sb2FkKEdyb3VwSW5mb1R5cGVSZWYsIHVzZXIudXNlckdyb3VwLmdyb3VwSW5mbylcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgbG9hZE1haWxHcm91cEluZm8oZ3JvdXBJZDogSWQpOiBQcm9taXNlPEdyb3VwSW5mbz4ge1xuXHRcdGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5ub25DYWNoaW5nRW50aXR5Q2xpZW50LmxvYWQoR3JvdXBUeXBlUmVmLCBncm91cElkKVxuXHRcdHJldHVybiBhd2FpdCB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQubG9hZChHcm91cEluZm9UeXBlUmVmLCBncm91cC5ncm91cEluZm8pXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNyZWF0ZU1haWxib3hQcm9wZXJ0aWVzKG1haWxib3hHcm91cFJvb3Q6IE1haWxib3hHcm91cFJvb3QsIGdyb3VwS2V5OiBWZXJzaW9uZWRLZXkpOiBQcm9taXNlPElkPiB7XG5cdFx0Y29uc3QgX293bmVyR3JvdXAgPSBtYWlsYm94R3JvdXBSb290Ll9vd25lckdyb3VwXG5cdFx0Y29uc3QgbWFpbGJveFByb3BlcnRpZXMgPSBjcmVhdGVNYWlsYm94UHJvcGVydGllcyh7XG5cdFx0XHQuLi4oX293bmVyR3JvdXAgIT0gbnVsbCA/IHsgX293bmVyR3JvdXAgfSA6IG51bGwpLCAvLyBvbmx5IHNldCBpdCBpZiBpdCBpcyBub3QgbnVsbFxuXHRcdFx0cmVwb3J0TW92ZWRNYWlsczogXCJcIixcblx0XHRcdG1haWxBZGRyZXNzUHJvcGVydGllczogW10sXG5cdFx0fSlcblx0XHQvLyBVc2luZyBub24tY2FjaGluZyBlbnRpdHlDbGllbnQgYmVjYXVzZSB3ZSBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSB1c2VyJ3MgbWFpbCBncm91cCBhbmQgd2Ugd29uJ3QgcmVjZWl2ZSB1cGRhdGVzIGZvciBpdFxuXHRcdHJldHVybiB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQuc2V0dXAobnVsbCwgbWFpbGJveFByb3BlcnRpZXMsIHVuZGVmaW5lZCwgeyBvd25lcktleTogZ3JvdXBLZXkgfSkuY2F0Y2goXG5cdFx0XHRvZkNsYXNzKFByZWNvbmRpdGlvbkZhaWxlZEVycm9yLCAoZSkgPT4ge1xuXHRcdFx0XHQvLyBpbiBhZG1pbiBjYXNlIGl0IGlzIG11Y2ggaGFyZGVyIHRvIHJ1biBpbnRvIGl0IGJlY2F1c2Ugd2UgdXNlIG5vbi1jYWNoaW5nIGVudGl0eUNsaWVudCBidXQgaXQgaXMgc3RpbGwgcG9zc2libGVcblx0XHRcdFx0aWYgKGUuZGF0YSAmJiBlLmRhdGEuc3RhcnRzV2l0aChcImV4aXN0czpcIikpIHtcblx0XHRcdFx0XHRjb25zdCBleGlzdGluZ0lkID0gZS5kYXRhLnN1YnN0cmluZyhcImV4aXN0czpcIi5sZW5ndGgpXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJtYWlsYm94UHJvcGVydGllcyBhbHJlYWR5IGV4aXN0c1wiLCBleGlzdGluZ0lkKVxuXHRcdFx0XHRcdHJldHVybiBleGlzdGluZ0lkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFByb2dyYW1taW5nRXJyb3IoYENvdWxkIG5vdCBjcmVhdGUgbWFpbGJveFByb3BlcnRpZXMsIHByZWNvbmRpdGlvbjogJHtlLmRhdGF9YClcblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0KVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyB1cGRhdGVNYWlsYm94UHJvcGVydGllcyhtYWlsYm94UHJvcGVydGllczogTWFpbGJveFByb3BlcnRpZXMsIHZpYVVzZXI/OiBJZCk6IFByb21pc2U8TWFpbGJveFByb3BlcnRpZXM+IHtcblx0XHRjb25zdCBncm91cEtleVByb3ZpZGVyID0gYXN5bmMgKHZlcnNpb246IEtleVZlcnNpb24pID0+XG5cdFx0XHR2aWFVc2VyXG5cdFx0XHRcdD8gYXdhaXQgdGhpcy5ncm91cE1hbmFnZW1lbnQuZ2V0R3JvdXBLZXlWaWFVc2VyKGFzc2VydE5vdE51bGwobWFpbGJveFByb3BlcnRpZXMuX293bmVyR3JvdXApLCB2ZXJzaW9uLCB2aWFVc2VyKVxuXHRcdFx0XHQ6IGF3YWl0IHRoaXMuZ3JvdXBNYW5hZ2VtZW50LmdldEdyb3VwS2V5VmlhQWRtaW5FbmNHS2V5KGFzc2VydE5vdE51bGwobWFpbGJveFByb3BlcnRpZXMuX293bmVyR3JvdXApLCB2ZXJzaW9uKVxuXHRcdGF3YWl0IHRoaXMubm9uQ2FjaGluZ0VudGl0eUNsaWVudC51cGRhdGUobWFpbGJveFByb3BlcnRpZXMsIHsgb3duZXJLZXlQcm92aWRlcjogZ3JvdXBLZXlQcm92aWRlciB9KVxuXHRcdHJldHVybiBhd2FpdCB0aGlzLm5vbkNhY2hpbmdFbnRpdHlDbGllbnQubG9hZChNYWlsYm94UHJvcGVydGllc1R5cGVSZWYsIG1haWxib3hQcm9wZXJ0aWVzLl9pZCwgeyBvd25lcktleVByb3ZpZGVyOiBncm91cEtleVByb3ZpZGVyIH0pXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNvbGxlY3RTZW5kZXJOYW1lcyhtYWlsYm94UHJvcGVydGllczogTWFpbGJveFByb3BlcnRpZXMpOiBQcm9taXNlPE1hcDxzdHJpbmcsIHN0cmluZz4+IHtcblx0XHRjb25zdCByZXN1bHQgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG5cdFx0Zm9yIChjb25zdCBkYXRhIG9mIG1haWxib3hQcm9wZXJ0aWVzLm1haWxBZGRyZXNzUHJvcGVydGllcykge1xuXHRcdFx0cmVzdWx0LnNldChkYXRhLm1haWxBZGRyZXNzLCBkYXRhLnNlbmRlck5hbWUpXG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHRcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFpQ0Esb0JBQW9CO0lBRVAsb0JBQU4sTUFBd0I7Q0FDOUIsWUFDa0JBLFlBQ0FDLGlCQUNBQyxpQkFDQUMsd0JBQ2hCO0VBMkxGLEtBL0xrQjtFQStMakIsS0E5TGlCO0VBOExoQixLQTdMZ0I7RUE2TGYsS0E1TGU7Q0FDZDs7OztDQUtKLGlCQUFpQkMsYUFBeUQ7RUFDekUsTUFBTSxPQUFPLDRCQUE0QixFQUFFLGFBQWEsWUFBYSxFQUFDO0FBQ3RFLFNBQU8sS0FBSyxnQkFBZ0IsSUFBSSx5QkFBeUIsS0FBSztDQUM5RDtDQUVELHVCQUF1QkMsYUFBdUM7QUFDN0QsTUFBSSxLQUFLLFdBQVcsaUJBQWlCLEVBQUU7R0FDdEMsTUFBTSxPQUFPLHdDQUF3QyxFQUFFLFlBQWEsRUFBQztBQUNyRSxVQUFPLEtBQUssZ0JBQWdCLElBQUksc0NBQXNDLEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxPQUFPLFVBQVU7RUFDOUcsTUFDQSxRQUFPLEtBQUssMEJBQTBCLENBQUMsV0FBWSxFQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsZ0JBQWdCLE9BQU8sQ0FBQyxVQUFVO0NBRXpHO0NBRUQsTUFBTSwwQkFBMEJDLGVBQTZEO0VBQzVGLE1BQU0sT0FBTywwQ0FBMEMsRUFDdEQsZUFBZSxjQUFjLElBQUksQ0FBQyxnQkFBZ0Isb0JBQW9CLEVBQUUsT0FBTyxZQUFhLEVBQUMsQ0FBQyxDQUM5RixFQUFDO0VBQ0YsTUFBTSxTQUFTLE1BQU0sS0FBSyxnQkFBZ0IsSUFBSSx3Q0FBd0MsS0FBSztBQUMzRixTQUFPLE9BQU87Q0FDZDs7Ozs7OztDQVFELE1BQU0sYUFBYUMsZUFBbUJDLE9BQThCO0VBQ25FLE1BQU0sT0FBTyxrQ0FBa0M7R0FDOUMsT0FBTztHQUNQLGFBQWE7RUFDYixF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