import { assertWorkerOrNode } from "./Env-chunk.js";
import { assertNotNull, concat } from "./dist2-chunk.js";
import { KeyPairType, bitArrayToUint8Array } from "./dist3-chunk.js";

//#region src/common/api/worker/facades/KeyAuthenticationFacade.ts
assertWorkerOrNode();
/**
* Purpose: prove to admins that the new User Group Key is authentic.
* By deriving this key from the current User Group Key, the admin knows that it was created by someone who had access to this key,
* that is, either the user or another admin.
*/
const userGroupKeyAuthenticationSystem = {
	deriveKey({ bindingData: { userGroupId, adminGroupId, newAdminGroupKeyVersion, newUserGroupKeyVersion, currentUserGroupKeyVersion }, sourceOfTrust }, cryptoWrapper) {
		return cryptoWrapper.deriveKeyWithHkdf({
			salt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentUserGroupKeyVersion}, newAdminGroupKeyVersion: ${newAdminGroupKeyVersion}, newUserGroupKeyVersion: ${newUserGroupKeyVersion}`,
			key: sourceOfTrust.currentUserGroupKey,
			context: "newUserGroupKeyAuthKeyForRotationAsNonAdminUser"
		});
	},
	generateAuthenticationData({ untrustedKey: { newUserGroupKey } }) {
		return bitArrayToUint8Array(newUserGroupKey);
	}
};
/**
* Purpose: prove to users that the new Admin Group Public Key is authentic.
* By deriving this key from the current User Group Key, the user knows that it was created either by someone who had access to this key,
* that is, either themselves or an admin.
*/
const newAdminPubKeyAuthenticationSystem = {
	deriveKey({ bindingData: { userGroupId, adminGroupId, newAdminGroupKeyVersion, currentReceivingUserGroupKeyVersion }, sourceOfTrust }, cryptoWrapper) {
		return cryptoWrapper.deriveKeyWithHkdf({
			salt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentReceivingUserGroupKeyVersion}, newAdminGroupKeyVersion: ${newAdminGroupKeyVersion}`,
			key: sourceOfTrust.receivingUserGroupKey,
			context: "newAdminPubKeyAuthKeyForUserGroupKeyRotation"
		});
	},
	generateAuthenticationData({ untrustedKey: { newAdminPubKey: { eccPublicKey, kyberPublicKey } } }) {
		return concat(eccPublicKey, kyberPublicKey.raw);
	}
};
/**
* Purpose: prove to other admins that the Distribution Public Key is authentic.
* By deriving this key from the current Admin Group Key, the admin knows that it was created by someone who had access to this key,
* that is, either themselves or another admin.
*/
const pubDistKeyAuthenticationSystem = {
	deriveKey({ bindingData: { adminGroupId, userGroupId, currentUserGroupKeyVersion, currentAdminGroupKeyVersion }, sourceOfTrust }, cryptoWrapper) {
		return cryptoWrapper.deriveKeyWithHkdf({
			salt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentUserGroupKeyVersion}, currentAdminGroupKeyVersion: ${currentAdminGroupKeyVersion}`,
			key: sourceOfTrust.currentAdminGroupKey,
			context: "adminGroupDistKeyPairAuthKeyForMultiAdminRotation"
		});
	},
	generateAuthenticationData({ untrustedKey: { distPubKey: { eccPublicKey, kyberPublicKey } } }) {
		return concat(eccPublicKey, kyberPublicKey.raw);
	}
};
/**
* Purpose: prove to other admins that the new Admin Group Symmetric Key is authentic.
* By deriving this key from the current User Group Key, the admin user knows that it was created either by someone who had access to this key,
* that is, either themselves or another admin.
*/
const adminSymKeyAuthenticationSystem = {
	deriveKey({ bindingData: { adminGroupId, userGroupId, newAdminGroupKeyVersion, currentReceivingUserGroupKeyVersion }, sourceOfTrust }, cryptoWrapper) {
		return cryptoWrapper.deriveKeyWithHkdf({
			salt: `adminGroup: ${adminGroupId}, userGroup: ${userGroupId}, currentUserGroupKeyVersion: ${currentReceivingUserGroupKeyVersion}, newAdminGroupKeyVersion: ${newAdminGroupKeyVersion}`,
			key: sourceOfTrust.currentReceivingUserGroupKey,
			context: "newAdminSymKeyAuthKeyForMultiAdminRotationAsUser"
		});
	},
	generateAuthenticationData({ untrustedKey: { newAdminGroupKey } }) {
		return bitArrayToUint8Array(newAdminGroupKey);
	}
};
const systemMap = {
	USER_GROUP_KEY_TAG: userGroupKeyAuthenticationSystem,
	NEW_ADMIN_PUB_KEY_TAG: newAdminPubKeyAuthenticationSystem,
	PUB_DIST_KEY_TAG: pubDistKeyAuthenticationSystem,
	ADMIN_SYM_KEY_TAG: adminSymKeyAuthenticationSystem
};
var KeyAuthenticationFacade = class {
	constructor(cryptoWrapper) {
		this.cryptoWrapper = cryptoWrapper;
	}
	/**
	* Computes a MAC tag using an existing key authentication system.
	* @param keyAuthenticationParams Parameters for the chosen key authentication system, containing trusted key, key to be verified, and binding data
	*/
	computeTag(keyAuthenticationParams) {
		const keyAuthenticationSystem = systemMap[keyAuthenticationParams.tagType];
		const authKey = keyAuthenticationSystem.deriveKey(keyAuthenticationParams, this.cryptoWrapper);
		const authData = keyAuthenticationSystem.generateAuthenticationData(keyAuthenticationParams);
		return this.cryptoWrapper.hmacSha256(authKey, authData);
	}
	/**
	* Verifies a MAC tag using an existing key authentication system.
	* @param keyAuthenticationParams Parameters for the chosen key authentication system, containing trusted key, key to be verified, and binding data
	* @param tag The MAC tag to be verified. Must be a branded MacTag, which you can get with brandKeyMac() in most cases
	*/
	verifyTag(keyAuthenticationParams, tag) {
		const keyAuthenticationSystem = systemMap[keyAuthenticationParams.tagType];
		const authKey = keyAuthenticationSystem.deriveKey(keyAuthenticationParams, this.cryptoWrapper);
		const authData = keyAuthenticationSystem.generateAuthenticationData(keyAuthenticationParams);
		this.cryptoWrapper.verifyHmacSha256(authKey, authData, tag);
	}
};
function brandKeyMac(keyMac) {
	return keyMac;
}
function asPQPublicKeys(kp) {
	return {
		keyPairType: KeyPairType.TUTA_CRYPT,
		eccPublicKey: assertNotNull(kp.pubEccKey),
		kyberPublicKey: { raw: assertNotNull(kp.pubKyberKey) }
	};
}

//#endregion
export { KeyAuthenticationFacade, asPQPublicKeys, brandKeyMac };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiS2V5QXV0aGVudGljYXRpb25GYWNhZGUtY2h1bmsuanMiLCJuYW1lcyI6WyJ1c2VyR3JvdXBLZXlBdXRoZW50aWNhdGlvblN5c3RlbTogS2V5QXV0aGVudGljYXRpb25TeXN0ZW08VXNlckdyb3VwS2V5QXV0aGVudGljYXRpb25QYXJhbXM+IiwibmV3QWRtaW5QdWJLZXlBdXRoZW50aWNhdGlvblN5c3RlbTogS2V5QXV0aGVudGljYXRpb25TeXN0ZW08TmV3QWRtaW5QdWJLZXlBdXRoZW50aWNhdGlvblBhcmFtcz4iLCJwdWJEaXN0S2V5QXV0aGVudGljYXRpb25TeXN0ZW06IEtleUF1dGhlbnRpY2F0aW9uU3lzdGVtPFB1YkRpc3RLZXlBdXRoZW50aWNhdGlvblBhcmFtcz4iLCJhZG1pblN5bUtleUF1dGhlbnRpY2F0aW9uU3lzdGVtOiBLZXlBdXRoZW50aWNhdGlvblN5c3RlbTxBZG1pblN5bUtleUF1dGhlbnRpY2F0aW9uUGFyYW1zPiIsImNyeXB0b1dyYXBwZXI6IENyeXB0b1dyYXBwZXIiLCJrZXlBdXRoZW50aWNhdGlvblBhcmFtczogS2V5QXV0aGVudGljYXRpb25QYXJhbXMiLCJrZXlBdXRoZW50aWNhdGlvblN5c3RlbTogS2V5QXV0aGVudGljYXRpb25TeXN0ZW08S2V5QXV0aGVudGljYXRpb25QYXJhbXM+IiwidGFnOiBNYWNUYWciLCJrZXlNYWM6IEtleU1hYyIsImtwOiBFbmNyeXB0ZWRQcUtleVBhaXJzIHwgUHViRGlzdHJpYnV0aW9uS2V5IHwgUHVibGljS2V5cyJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vYXBpL3dvcmtlci9mYWNhZGVzL0tleUF1dGhlbnRpY2F0aW9uRmFjYWRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENyeXB0b1dyYXBwZXIgfSBmcm9tIFwiLi4vY3J5cHRvL0NyeXB0b1dyYXBwZXIuanNcIlxuaW1wb3J0IHsgYXNzZXJ0Tm90TnVsbCwgY29uY2F0LCBLZXlWZXJzaW9uIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBBZXMyNTZLZXksIEFlc0tleSwgYml0QXJyYXlUb1VpbnQ4QXJyYXksIEVuY3J5cHRlZFBxS2V5UGFpcnMsIEtleVBhaXJUeXBlLCBNYWNUYWcsIFBRUHVibGljS2V5cyB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtY3J5cHRvXCJcbmltcG9ydCB7IGFzc2VydFdvcmtlck9yTm9kZSB9IGZyb20gXCIuLi8uLi9jb21tb24vRW52LmpzXCJcbmltcG9ydCB7IEtleU1hYywgUHViRGlzdHJpYnV0aW9uS2V5IH0gZnJvbSBcIi4uLy4uL2VudGl0aWVzL3N5cy9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBQdWJsaWNLZXlzIH0gZnJvbSBcIi4vUHVibGljS2V5UHJvdmlkZXIuanNcIlxuXG5hc3NlcnRXb3JrZXJPck5vZGUoKVxuXG50eXBlIEF1dGhlbnRpY2F0aW9uQmluZGluZ0RhdGEgPSB7XG5cdHVzZXJHcm91cElkOiBJZFxuXHRhZG1pbkdyb3VwSWQ6IElkXG59XG5cbnR5cGUgQmFzZUtleUF1dGhlbnRpY2F0aW9uUGFyYW1zID0ge1xuXHR0YWdUeXBlOiBrZXlvZiB0eXBlb2Ygc3lzdGVtTWFwXG5cdHNvdXJjZU9mVHJ1c3Q6IHsgW25hbWU6IHN0cmluZ106IEFlc0tleSB9XG5cdC8vIHRoaXMgY2FuIGJlIGEgdXNlciBncm91cCBrZXksIGFuIGFkbWluIGdyb3VwIGtleSwgYW4gYWRtaW4gZ3JvdXAgcHVibGljIGtleSBvciBhIGRpc3RyaWJ1dGlvbiBwdWJsaWMga2V5XG5cdHVudHJ1c3RlZEtleTogeyBbbmFtZTogc3RyaW5nXTogQWVzS2V5IHwgUFFQdWJsaWNLZXlzIH1cblx0YmluZGluZ0RhdGE6IEF1dGhlbnRpY2F0aW9uQmluZGluZ0RhdGFcbn1cblxuZXhwb3J0IHR5cGUgVXNlckdyb3VwS2V5QXV0aGVudGljYXRpb25QYXJhbXMgPSBCYXNlS2V5QXV0aGVudGljYXRpb25QYXJhbXMgJiB7XG5cdHRhZ1R5cGU6IFwiVVNFUl9HUk9VUF9LRVlfVEFHXCJcblx0dW50cnVzdGVkS2V5OiB7IG5ld1VzZXJHcm91cEtleTogQWVzMjU2S2V5IH1cblx0c291cmNlT2ZUcnVzdDogeyBjdXJyZW50VXNlckdyb3VwS2V5OiBBZXNLZXkgfVxuXHRiaW5kaW5nRGF0YTogQXV0aGVudGljYXRpb25CaW5kaW5nRGF0YSAmIHtcblx0XHRjdXJyZW50VXNlckdyb3VwS2V5VmVyc2lvbjogS2V5VmVyc2lvblxuXHRcdG5ld1VzZXJHcm91cEtleVZlcnNpb246IEtleVZlcnNpb25cblx0XHRuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbjogS2V5VmVyc2lvblxuXHR9XG59XG5cbi8qKlxuICogQSBzeXN0ZW0gdG8gYXV0aGVudGljYXRlIHNvbWUga2V5LlxuICovXG50eXBlIEtleUF1dGhlbnRpY2F0aW9uU3lzdGVtPFQgZXh0ZW5kcyBLZXlBdXRoZW50aWNhdGlvblBhcmFtcz4gPSB7XG5cdC8qKlxuXHQgKiBDYW5vbmljYWxpemVzIHRoZSBkYXRhIHdlIHdhbnQgdG8gYXV0aGVudGljYXRlLCBpLmUuLCB0aGUgbmV3IGtleSBhbmQgc29tZSBiaW5kaW5nIGRhdGEsIGludG8gYSBieXRlIGFycmF5LlxuXHQgKiBAcGFyYW0gcGFyYW1zXG5cdCAqL1xuXHRnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uRGF0YShwYXJhbXM6IFQpOiBVaW50OEFycmF5XG5cdC8qKlxuXHQgKiBEZXJpdmVzIHRoZSBhdXRoZW50aWNhdGlvbiBrZXkgZnJvbSBhIHRydXN0ZWQga2V5IGFuZCBzb21lIGFkZGl0aW9uYWwgYmluZGluZyBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0gcGFyYW1zXG5cdCAqIEBwYXJhbSBjcnlwdG9XcmFwcGVyXG5cdCAqL1xuXHRkZXJpdmVLZXkocGFyYW1zOiBULCBjcnlwdG9XcmFwcGVyOiBDcnlwdG9XcmFwcGVyKTogQWVzMjU2S2V5XG59XG5cbi8qKlxuICogUHVycG9zZTogcHJvdmUgdG8gYWRtaW5zIHRoYXQgdGhlIG5ldyBVc2VyIEdyb3VwIEtleSBpcyBhdXRoZW50aWMuXG4gKiBCeSBkZXJpdmluZyB0aGlzIGtleSBmcm9tIHRoZSBjdXJyZW50IFVzZXIgR3JvdXAgS2V5LCB0aGUgYWRtaW4ga25vd3MgdGhhdCBpdCB3YXMgY3JlYXRlZCBieSBzb21lb25lIHdobyBoYWQgYWNjZXNzIHRvIHRoaXMga2V5LFxuICogdGhhdCBpcywgZWl0aGVyIHRoZSB1c2VyIG9yIGFub3RoZXIgYWRtaW4uXG4gKi9cbmNvbnN0IHVzZXJHcm91cEtleUF1dGhlbnRpY2F0aW9uU3lzdGVtOiBLZXlBdXRoZW50aWNhdGlvblN5c3RlbTxVc2VyR3JvdXBLZXlBdXRoZW50aWNhdGlvblBhcmFtcz4gPSB7XG5cdGRlcml2ZUtleShcblx0XHR7IGJpbmRpbmdEYXRhOiB7IHVzZXJHcm91cElkLCBhZG1pbkdyb3VwSWQsIG5ld0FkbWluR3JvdXBLZXlWZXJzaW9uLCBuZXdVc2VyR3JvdXBLZXlWZXJzaW9uLCBjdXJyZW50VXNlckdyb3VwS2V5VmVyc2lvbiB9LCBzb3VyY2VPZlRydXN0IH0sXG5cdFx0Y3J5cHRvV3JhcHBlcixcblx0KSB7XG5cdFx0cmV0dXJuIGNyeXB0b1dyYXBwZXIuZGVyaXZlS2V5V2l0aEhrZGYoe1xuXHRcdFx0c2FsdDogYGFkbWluR3JvdXA6ICR7YWRtaW5Hcm91cElkfSwgdXNlckdyb3VwOiAke3VzZXJHcm91cElkfSwgY3VycmVudFVzZXJHcm91cEtleVZlcnNpb246ICR7Y3VycmVudFVzZXJHcm91cEtleVZlcnNpb259LCBuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbjogJHtuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbn0sIG5ld1VzZXJHcm91cEtleVZlcnNpb246ICR7bmV3VXNlckdyb3VwS2V5VmVyc2lvbn1gLFxuXHRcdFx0a2V5OiBzb3VyY2VPZlRydXN0LmN1cnJlbnRVc2VyR3JvdXBLZXksXG5cdFx0XHRjb250ZXh0OiBcIm5ld1VzZXJHcm91cEtleUF1dGhLZXlGb3JSb3RhdGlvbkFzTm9uQWRtaW5Vc2VyXCIsXG5cdFx0fSlcblx0fSxcblx0Z2VuZXJhdGVBdXRoZW50aWNhdGlvbkRhdGEoeyB1bnRydXN0ZWRLZXk6IHsgbmV3VXNlckdyb3VwS2V5IH0gfSkge1xuXHRcdHJldHVybiBiaXRBcnJheVRvVWludDhBcnJheShuZXdVc2VyR3JvdXBLZXkpXG5cdH0sXG59XG5cbmV4cG9ydCB0eXBlIE5ld0FkbWluUHViS2V5QXV0aGVudGljYXRpb25QYXJhbXMgPSBCYXNlS2V5QXV0aGVudGljYXRpb25QYXJhbXMgJiB7XG5cdHRhZ1R5cGU6IFwiTkVXX0FETUlOX1BVQl9LRVlfVEFHXCJcblx0dW50cnVzdGVkS2V5OiB7IG5ld0FkbWluUHViS2V5OiBQUVB1YmxpY0tleXMgfVxuXHRzb3VyY2VPZlRydXN0OiB7IHJlY2VpdmluZ1VzZXJHcm91cEtleTogQWVzS2V5IH0gLy8gdGhpcyByZWNlaXZpbmcgdXNlciBpcyBhbiBhZG1pbiByZWNlaXZpbmcgdGhlIG5ldyBhZG1pbiBncm91cCBwdWIga2V5c1xuXHRiaW5kaW5nRGF0YTogQXV0aGVudGljYXRpb25CaW5kaW5nRGF0YSAmIHtcblx0XHRuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbjogS2V5VmVyc2lvblxuXHRcdGN1cnJlbnRSZWNlaXZpbmdVc2VyR3JvdXBLZXlWZXJzaW9uOiBLZXlWZXJzaW9uXG5cdH1cbn1cblxuLyoqXG4gKiBQdXJwb3NlOiBwcm92ZSB0byB1c2VycyB0aGF0IHRoZSBuZXcgQWRtaW4gR3JvdXAgUHVibGljIEtleSBpcyBhdXRoZW50aWMuXG4gKiBCeSBkZXJpdmluZyB0aGlzIGtleSBmcm9tIHRoZSBjdXJyZW50IFVzZXIgR3JvdXAgS2V5LCB0aGUgdXNlciBrbm93cyB0aGF0IGl0IHdhcyBjcmVhdGVkIGVpdGhlciBieSBzb21lb25lIHdobyBoYWQgYWNjZXNzIHRvIHRoaXMga2V5LFxuICogdGhhdCBpcywgZWl0aGVyIHRoZW1zZWx2ZXMgb3IgYW4gYWRtaW4uXG4gKi9cbmNvbnN0IG5ld0FkbWluUHViS2V5QXV0aGVudGljYXRpb25TeXN0ZW06IEtleUF1dGhlbnRpY2F0aW9uU3lzdGVtPE5ld0FkbWluUHViS2V5QXV0aGVudGljYXRpb25QYXJhbXM+ID0ge1xuXHRkZXJpdmVLZXkoeyBiaW5kaW5nRGF0YTogeyB1c2VyR3JvdXBJZCwgYWRtaW5Hcm91cElkLCBuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbiwgY3VycmVudFJlY2VpdmluZ1VzZXJHcm91cEtleVZlcnNpb24gfSwgc291cmNlT2ZUcnVzdCB9LCBjcnlwdG9XcmFwcGVyKSB7XG5cdFx0cmV0dXJuIGNyeXB0b1dyYXBwZXIuZGVyaXZlS2V5V2l0aEhrZGYoe1xuXHRcdFx0c2FsdDogYGFkbWluR3JvdXA6ICR7YWRtaW5Hcm91cElkfSwgdXNlckdyb3VwOiAke3VzZXJHcm91cElkfSwgY3VycmVudFVzZXJHcm91cEtleVZlcnNpb246ICR7Y3VycmVudFJlY2VpdmluZ1VzZXJHcm91cEtleVZlcnNpb259LCBuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbjogJHtuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbn1gLFxuXHRcdFx0a2V5OiBzb3VyY2VPZlRydXN0LnJlY2VpdmluZ1VzZXJHcm91cEtleSxcblx0XHRcdGNvbnRleHQ6IFwibmV3QWRtaW5QdWJLZXlBdXRoS2V5Rm9yVXNlckdyb3VwS2V5Um90YXRpb25cIixcblx0XHR9KVxuXHR9LFxuXHRnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uRGF0YSh7XG5cdFx0dW50cnVzdGVkS2V5OiB7XG5cdFx0XHRuZXdBZG1pblB1YktleTogeyBlY2NQdWJsaWNLZXksIGt5YmVyUHVibGljS2V5IH0sXG5cdFx0fSxcblx0fSkge1xuXHRcdHJldHVybiBjb25jYXQoZWNjUHVibGljS2V5LCBreWJlclB1YmxpY0tleS5yYXcpXG5cdH0sXG59XG5cbmV4cG9ydCB0eXBlIFB1YkRpc3RLZXlBdXRoZW50aWNhdGlvblBhcmFtcyA9IEJhc2VLZXlBdXRoZW50aWNhdGlvblBhcmFtcyAmIHtcblx0dGFnVHlwZTogXCJQVUJfRElTVF9LRVlfVEFHXCJcblx0dW50cnVzdGVkS2V5OiB7IGRpc3RQdWJLZXk6IFBRUHVibGljS2V5cyB9XG5cdHNvdXJjZU9mVHJ1c3Q6IHsgY3VycmVudEFkbWluR3JvdXBLZXk6IEFlc0tleSB9XG5cdGJpbmRpbmdEYXRhOiBBdXRoZW50aWNhdGlvbkJpbmRpbmdEYXRhICYge1xuXHRcdGN1cnJlbnRVc2VyR3JvdXBLZXlWZXJzaW9uOiBLZXlWZXJzaW9uXG5cdFx0Y3VycmVudEFkbWluR3JvdXBLZXlWZXJzaW9uOiBLZXlWZXJzaW9uXG5cdH1cbn1cblxuLyoqXG4gKiBQdXJwb3NlOiBwcm92ZSB0byBvdGhlciBhZG1pbnMgdGhhdCB0aGUgRGlzdHJpYnV0aW9uIFB1YmxpYyBLZXkgaXMgYXV0aGVudGljLlxuICogQnkgZGVyaXZpbmcgdGhpcyBrZXkgZnJvbSB0aGUgY3VycmVudCBBZG1pbiBHcm91cCBLZXksIHRoZSBhZG1pbiBrbm93cyB0aGF0IGl0IHdhcyBjcmVhdGVkIGJ5IHNvbWVvbmUgd2hvIGhhZCBhY2Nlc3MgdG8gdGhpcyBrZXksXG4gKiB0aGF0IGlzLCBlaXRoZXIgdGhlbXNlbHZlcyBvciBhbm90aGVyIGFkbWluLlxuICovXG5jb25zdCBwdWJEaXN0S2V5QXV0aGVudGljYXRpb25TeXN0ZW06IEtleUF1dGhlbnRpY2F0aW9uU3lzdGVtPFB1YkRpc3RLZXlBdXRoZW50aWNhdGlvblBhcmFtcz4gPSB7XG5cdGRlcml2ZUtleSh7IGJpbmRpbmdEYXRhOiB7IGFkbWluR3JvdXBJZCwgdXNlckdyb3VwSWQsIGN1cnJlbnRVc2VyR3JvdXBLZXlWZXJzaW9uLCBjdXJyZW50QWRtaW5Hcm91cEtleVZlcnNpb24gfSwgc291cmNlT2ZUcnVzdCB9LCBjcnlwdG9XcmFwcGVyKSB7XG5cdFx0cmV0dXJuIGNyeXB0b1dyYXBwZXIuZGVyaXZlS2V5V2l0aEhrZGYoe1xuXHRcdFx0c2FsdDogYGFkbWluR3JvdXA6ICR7YWRtaW5Hcm91cElkfSwgdXNlckdyb3VwOiAke3VzZXJHcm91cElkfSwgY3VycmVudFVzZXJHcm91cEtleVZlcnNpb246ICR7Y3VycmVudFVzZXJHcm91cEtleVZlcnNpb259LCBjdXJyZW50QWRtaW5Hcm91cEtleVZlcnNpb246ICR7Y3VycmVudEFkbWluR3JvdXBLZXlWZXJzaW9ufWAsXG5cdFx0XHRrZXk6IHNvdXJjZU9mVHJ1c3QuY3VycmVudEFkbWluR3JvdXBLZXksXG5cdFx0XHRjb250ZXh0OiBcImFkbWluR3JvdXBEaXN0S2V5UGFpckF1dGhLZXlGb3JNdWx0aUFkbWluUm90YXRpb25cIixcblx0XHR9KVxuXHR9LFxuXHRnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uRGF0YSh7XG5cdFx0dW50cnVzdGVkS2V5OiB7XG5cdFx0XHRkaXN0UHViS2V5OiB7IGVjY1B1YmxpY0tleSwga3liZXJQdWJsaWNLZXkgfSxcblx0XHR9LFxuXHR9KSB7XG5cdFx0cmV0dXJuIGNvbmNhdChlY2NQdWJsaWNLZXksIGt5YmVyUHVibGljS2V5LnJhdylcblx0fSxcbn1cblxuZXhwb3J0IHR5cGUgQWRtaW5TeW1LZXlBdXRoZW50aWNhdGlvblBhcmFtcyA9IEJhc2VLZXlBdXRoZW50aWNhdGlvblBhcmFtcyAmIHtcblx0dGFnVHlwZTogXCJBRE1JTl9TWU1fS0VZX1RBR1wiXG5cdHVudHJ1c3RlZEtleTogeyBuZXdBZG1pbkdyb3VwS2V5OiBBZXMyNTZLZXkgfVxuXHRzb3VyY2VPZlRydXN0OiB7IGN1cnJlbnRSZWNlaXZpbmdVc2VyR3JvdXBLZXk6IEFlc0tleSB9IC8vIHRoaXMgcmVjZWl2aW5nIHVzZXIgaXMgYW4gYWRtaW4gcmVjZWl2aW5nIHRoZSBuZXcgYWRtaW4gZ3JvdXAgc3ltIGtleVxuXHRiaW5kaW5nRGF0YTogQXV0aGVudGljYXRpb25CaW5kaW5nRGF0YSAmIHtcblx0XHRuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbjogS2V5VmVyc2lvblxuXHRcdGN1cnJlbnRSZWNlaXZpbmdVc2VyR3JvdXBLZXlWZXJzaW9uOiBLZXlWZXJzaW9uXG5cdH1cbn1cblxuLyoqXG4gKiBQdXJwb3NlOiBwcm92ZSB0byBvdGhlciBhZG1pbnMgdGhhdCB0aGUgbmV3IEFkbWluIEdyb3VwIFN5bW1ldHJpYyBLZXkgaXMgYXV0aGVudGljLlxuICogQnkgZGVyaXZpbmcgdGhpcyBrZXkgZnJvbSB0aGUgY3VycmVudCBVc2VyIEdyb3VwIEtleSwgdGhlIGFkbWluIHVzZXIga25vd3MgdGhhdCBpdCB3YXMgY3JlYXRlZCBlaXRoZXIgYnkgc29tZW9uZSB3aG8gaGFkIGFjY2VzcyB0byB0aGlzIGtleSxcbiAqIHRoYXQgaXMsIGVpdGhlciB0aGVtc2VsdmVzIG9yIGFub3RoZXIgYWRtaW4uXG4gKi9cbmNvbnN0IGFkbWluU3ltS2V5QXV0aGVudGljYXRpb25TeXN0ZW06IEtleUF1dGhlbnRpY2F0aW9uU3lzdGVtPEFkbWluU3ltS2V5QXV0aGVudGljYXRpb25QYXJhbXM+ID0ge1xuXHRkZXJpdmVLZXkoeyBiaW5kaW5nRGF0YTogeyBhZG1pbkdyb3VwSWQsIHVzZXJHcm91cElkLCBuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbiwgY3VycmVudFJlY2VpdmluZ1VzZXJHcm91cEtleVZlcnNpb24gfSwgc291cmNlT2ZUcnVzdCB9LCBjcnlwdG9XcmFwcGVyKSB7XG5cdFx0cmV0dXJuIGNyeXB0b1dyYXBwZXIuZGVyaXZlS2V5V2l0aEhrZGYoe1xuXHRcdFx0c2FsdDogYGFkbWluR3JvdXA6ICR7YWRtaW5Hcm91cElkfSwgdXNlckdyb3VwOiAke3VzZXJHcm91cElkfSwgY3VycmVudFVzZXJHcm91cEtleVZlcnNpb246ICR7Y3VycmVudFJlY2VpdmluZ1VzZXJHcm91cEtleVZlcnNpb259LCBuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbjogJHtuZXdBZG1pbkdyb3VwS2V5VmVyc2lvbn1gLFxuXHRcdFx0a2V5OiBzb3VyY2VPZlRydXN0LmN1cnJlbnRSZWNlaXZpbmdVc2VyR3JvdXBLZXksXG5cdFx0XHRjb250ZXh0OiBcIm5ld0FkbWluU3ltS2V5QXV0aEtleUZvck11bHRpQWRtaW5Sb3RhdGlvbkFzVXNlclwiLFxuXHRcdH0pXG5cdH0sXG5cdGdlbmVyYXRlQXV0aGVudGljYXRpb25EYXRhKHsgdW50cnVzdGVkS2V5OiB7IG5ld0FkbWluR3JvdXBLZXkgfSB9KSB7XG5cdFx0cmV0dXJuIGJpdEFycmF5VG9VaW50OEFycmF5KG5ld0FkbWluR3JvdXBLZXkpXG5cdH0sXG59XG5cbmV4cG9ydCB0eXBlIEtleUF1dGhlbnRpY2F0aW9uUGFyYW1zID1cblx0fCBVc2VyR3JvdXBLZXlBdXRoZW50aWNhdGlvblBhcmFtc1xuXHR8IE5ld0FkbWluUHViS2V5QXV0aGVudGljYXRpb25QYXJhbXNcblx0fCBQdWJEaXN0S2V5QXV0aGVudGljYXRpb25QYXJhbXNcblx0fCBBZG1pblN5bUtleUF1dGhlbnRpY2F0aW9uUGFyYW1zXG5cbmNvbnN0IHN5c3RlbU1hcCA9IHtcblx0VVNFUl9HUk9VUF9LRVlfVEFHOiB1c2VyR3JvdXBLZXlBdXRoZW50aWNhdGlvblN5c3RlbSxcblx0TkVXX0FETUlOX1BVQl9LRVlfVEFHOiBuZXdBZG1pblB1YktleUF1dGhlbnRpY2F0aW9uU3lzdGVtLFxuXHRQVUJfRElTVF9LRVlfVEFHOiBwdWJEaXN0S2V5QXV0aGVudGljYXRpb25TeXN0ZW0sXG5cdEFETUlOX1NZTV9LRVlfVEFHOiBhZG1pblN5bUtleUF1dGhlbnRpY2F0aW9uU3lzdGVtLFxufVxuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZXMga2V5cyBieSBkZXJpdmluZyB0cnVzdCBpbiBhbm90aGVyIGtleSB1c2luZyBhIE1lc3NhZ2UgQXV0aGVudGljYXRpb24gQ29kZSAoTUFDIHRhZykuXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlBdXRoZW50aWNhdGlvbkZhY2FkZSB7XG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY3J5cHRvV3JhcHBlcjogQ3J5cHRvV3JhcHBlcikge31cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgYSBNQUMgdGFnIHVzaW5nIGFuIGV4aXN0aW5nIGtleSBhdXRoZW50aWNhdGlvbiBzeXN0ZW0uXG5cdCAqIEBwYXJhbSBrZXlBdXRoZW50aWNhdGlvblBhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgY2hvc2VuIGtleSBhdXRoZW50aWNhdGlvbiBzeXN0ZW0sIGNvbnRhaW5pbmcgdHJ1c3RlZCBrZXksIGtleSB0byBiZSB2ZXJpZmllZCwgYW5kIGJpbmRpbmcgZGF0YVxuXHQgKi9cblx0cHVibGljIGNvbXB1dGVUYWcoa2V5QXV0aGVudGljYXRpb25QYXJhbXM6IEtleUF1dGhlbnRpY2F0aW9uUGFyYW1zKTogTWFjVGFnIHtcblx0XHRjb25zdCBrZXlBdXRoZW50aWNhdGlvblN5c3RlbTogS2V5QXV0aGVudGljYXRpb25TeXN0ZW08S2V5QXV0aGVudGljYXRpb25QYXJhbXM+ID0gc3lzdGVtTWFwW2tleUF1dGhlbnRpY2F0aW9uUGFyYW1zLnRhZ1R5cGVdXG5cdFx0Y29uc3QgYXV0aEtleSA9IGtleUF1dGhlbnRpY2F0aW9uU3lzdGVtLmRlcml2ZUtleShrZXlBdXRoZW50aWNhdGlvblBhcmFtcywgdGhpcy5jcnlwdG9XcmFwcGVyKVxuXHRcdGNvbnN0IGF1dGhEYXRhID0ga2V5QXV0aGVudGljYXRpb25TeXN0ZW0uZ2VuZXJhdGVBdXRoZW50aWNhdGlvbkRhdGEoa2V5QXV0aGVudGljYXRpb25QYXJhbXMpXG5cdFx0cmV0dXJuIHRoaXMuY3J5cHRvV3JhcHBlci5obWFjU2hhMjU2KGF1dGhLZXksIGF1dGhEYXRhKVxuXHR9XG5cblx0LyoqXG5cdCAqIFZlcmlmaWVzIGEgTUFDIHRhZyB1c2luZyBhbiBleGlzdGluZyBrZXkgYXV0aGVudGljYXRpb24gc3lzdGVtLlxuXHQgKiBAcGFyYW0ga2V5QXV0aGVudGljYXRpb25QYXJhbXMgUGFyYW1ldGVycyBmb3IgdGhlIGNob3NlbiBrZXkgYXV0aGVudGljYXRpb24gc3lzdGVtLCBjb250YWluaW5nIHRydXN0ZWQga2V5LCBrZXkgdG8gYmUgdmVyaWZpZWQsIGFuZCBiaW5kaW5nIGRhdGFcblx0ICogQHBhcmFtIHRhZyBUaGUgTUFDIHRhZyB0byBiZSB2ZXJpZmllZC4gTXVzdCBiZSBhIGJyYW5kZWQgTWFjVGFnLCB3aGljaCB5b3UgY2FuIGdldCB3aXRoIGJyYW5kS2V5TWFjKCkgaW4gbW9zdCBjYXNlc1xuXHQgKi9cblx0cHVibGljIHZlcmlmeVRhZyhrZXlBdXRoZW50aWNhdGlvblBhcmFtczogS2V5QXV0aGVudGljYXRpb25QYXJhbXMsIHRhZzogTWFjVGFnKTogdm9pZCB7XG5cdFx0Y29uc3Qga2V5QXV0aGVudGljYXRpb25TeXN0ZW06IEtleUF1dGhlbnRpY2F0aW9uU3lzdGVtPEtleUF1dGhlbnRpY2F0aW9uUGFyYW1zPiA9IHN5c3RlbU1hcFtrZXlBdXRoZW50aWNhdGlvblBhcmFtcy50YWdUeXBlXVxuXHRcdGNvbnN0IGF1dGhLZXkgPSBrZXlBdXRoZW50aWNhdGlvblN5c3RlbS5kZXJpdmVLZXkoa2V5QXV0aGVudGljYXRpb25QYXJhbXMsIHRoaXMuY3J5cHRvV3JhcHBlcilcblx0XHRjb25zdCBhdXRoRGF0YSA9IGtleUF1dGhlbnRpY2F0aW9uU3lzdGVtLmdlbmVyYXRlQXV0aGVudGljYXRpb25EYXRhKGtleUF1dGhlbnRpY2F0aW9uUGFyYW1zKVxuXHRcdHRoaXMuY3J5cHRvV3JhcHBlci52ZXJpZnlIbWFjU2hhMjU2KGF1dGhLZXksIGF1dGhEYXRhLCB0YWcpXG5cdH1cbn1cblxudHlwZSBCcmFuZGVkS2V5TWFjID0gT21pdDxLZXlNYWMsIFwibWFjXCI+ICYgeyB0YWc6IE1hY1RhZyB9XG5cbi8qKlxuICogQnJhbmRzIGEgS2V5TWFjIHNvIHRoYXQgaXQgaGFzIGEgYnJhbmRlZCBNYWNUYWcsIHdoaWNoIGNhbiBiZSB1c2VkIGluIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicmFuZEtleU1hYyhrZXlNYWM6IEtleU1hYyk6IEJyYW5kZWRLZXlNYWMge1xuXHRyZXR1cm4ga2V5TWFjIGFzIEJyYW5kZWRLZXlNYWNcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBzb21lIGZvcm0gb2YgcHVibGljIFBRIGtleXMgdG8gdGhlIFBRUHVibGljS2V5cyB0eXBlLiBBc3N1bWVzIHB1YkVjY0tleSBhbmQgcHViS3liZXJLZXkgZXhpc3QuXG4gKiBAcGFyYW0ga3BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzUFFQdWJsaWNLZXlzKGtwOiBFbmNyeXB0ZWRQcUtleVBhaXJzIHwgUHViRGlzdHJpYnV0aW9uS2V5IHwgUHVibGljS2V5cyk6IFBRUHVibGljS2V5cyB7XG5cdHJldHVybiB7XG5cdFx0a2V5UGFpclR5cGU6IEtleVBhaXJUeXBlLlRVVEFfQ1JZUFQsXG5cdFx0ZWNjUHVibGljS2V5OiBhc3NlcnROb3ROdWxsKGtwLnB1YkVjY0tleSksXG5cdFx0a3liZXJQdWJsaWNLZXk6IHtcblx0XHRcdHJhdzogYXNzZXJ0Tm90TnVsbChrcC5wdWJLeWJlcktleSksXG5cdFx0fSxcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7OztBQU9BLG9CQUFvQjs7Ozs7O0FBZ0RwQixNQUFNQSxtQ0FBOEY7Q0FDbkcsVUFDQyxFQUFFLGFBQWEsRUFBRSxhQUFhLGNBQWMseUJBQXlCLHdCQUF3Qiw0QkFBNEIsRUFBRSxlQUFlLEVBQzFJLGVBQ0M7QUFDRCxTQUFPLGNBQWMsa0JBQWtCO0dBQ3RDLE9BQU8sY0FBYyxhQUFhLGVBQWUsWUFBWSxnQ0FBZ0MsMkJBQTJCLDZCQUE2Qix3QkFBd0IsNEJBQTRCLHVCQUF1QjtHQUNoTyxLQUFLLGNBQWM7R0FDbkIsU0FBUztFQUNULEVBQUM7Q0FDRjtDQUNELDJCQUEyQixFQUFFLGNBQWMsRUFBRSxpQkFBaUIsRUFBRSxFQUFFO0FBQ2pFLFNBQU8scUJBQXFCLGdCQUFnQjtDQUM1QztBQUNEOzs7Ozs7QUFpQkQsTUFBTUMscUNBQWtHO0NBQ3ZHLFVBQVUsRUFBRSxhQUFhLEVBQUUsYUFBYSxjQUFjLHlCQUF5QixxQ0FBcUMsRUFBRSxlQUFlLEVBQUUsZUFBZTtBQUNySixTQUFPLGNBQWMsa0JBQWtCO0dBQ3RDLE9BQU8sY0FBYyxhQUFhLGVBQWUsWUFBWSxnQ0FBZ0Msb0NBQW9DLDZCQUE2Qix3QkFBd0I7R0FDdEwsS0FBSyxjQUFjO0dBQ25CLFNBQVM7RUFDVCxFQUFDO0NBQ0Y7Q0FDRCwyQkFBMkIsRUFDMUIsY0FBYyxFQUNiLGdCQUFnQixFQUFFLGNBQWMsZ0JBQWdCLEVBQ2hELEVBQ0QsRUFBRTtBQUNGLFNBQU8sT0FBTyxjQUFjLGVBQWUsSUFBSTtDQUMvQztBQUNEOzs7Ozs7QUFpQkQsTUFBTUMsaUNBQTBGO0NBQy9GLFVBQVUsRUFBRSxhQUFhLEVBQUUsY0FBYyxhQUFhLDRCQUE0Qiw2QkFBNkIsRUFBRSxlQUFlLEVBQUUsZUFBZTtBQUNoSixTQUFPLGNBQWMsa0JBQWtCO0dBQ3RDLE9BQU8sY0FBYyxhQUFhLGVBQWUsWUFBWSxnQ0FBZ0MsMkJBQTJCLGlDQUFpQyw0QkFBNEI7R0FDckwsS0FBSyxjQUFjO0dBQ25CLFNBQVM7RUFDVCxFQUFDO0NBQ0Y7Q0FDRCwyQkFBMkIsRUFDMUIsY0FBYyxFQUNiLFlBQVksRUFBRSxjQUFjLGdCQUFnQixFQUM1QyxFQUNELEVBQUU7QUFDRixTQUFPLE9BQU8sY0FBYyxlQUFlLElBQUk7Q0FDL0M7QUFDRDs7Ozs7O0FBaUJELE1BQU1DLGtDQUE0RjtDQUNqRyxVQUFVLEVBQUUsYUFBYSxFQUFFLGNBQWMsYUFBYSx5QkFBeUIscUNBQXFDLEVBQUUsZUFBZSxFQUFFLGVBQWU7QUFDckosU0FBTyxjQUFjLGtCQUFrQjtHQUN0QyxPQUFPLGNBQWMsYUFBYSxlQUFlLFlBQVksZ0NBQWdDLG9DQUFvQyw2QkFBNkIsd0JBQXdCO0dBQ3RMLEtBQUssY0FBYztHQUNuQixTQUFTO0VBQ1QsRUFBQztDQUNGO0NBQ0QsMkJBQTJCLEVBQUUsY0FBYyxFQUFFLGtCQUFrQixFQUFFLEVBQUU7QUFDbEUsU0FBTyxxQkFBcUIsaUJBQWlCO0NBQzdDO0FBQ0Q7QUFRRCxNQUFNLFlBQVk7Q0FDakIsb0JBQW9CO0NBQ3BCLHVCQUF1QjtDQUN2QixrQkFBa0I7Q0FDbEIsbUJBQW1CO0FBQ25CO0lBS1ksMEJBQU4sTUFBOEI7Q0FDcEMsWUFBNkJDLGVBQThCO0VBZ0QzRCxLQWhENkI7Q0FBZ0M7Ozs7O0NBTTdELEFBQU8sV0FBV0MseUJBQTBEO0VBQzNFLE1BQU1DLDBCQUE0RSxVQUFVLHdCQUF3QjtFQUNwSCxNQUFNLFVBQVUsd0JBQXdCLFVBQVUseUJBQXlCLEtBQUssY0FBYztFQUM5RixNQUFNLFdBQVcsd0JBQXdCLDJCQUEyQix3QkFBd0I7QUFDNUYsU0FBTyxLQUFLLGNBQWMsV0FBVyxTQUFTLFNBQVM7Q0FDdkQ7Ozs7OztDQU9ELEFBQU8sVUFBVUQseUJBQWtERSxLQUFtQjtFQUNyRixNQUFNRCwwQkFBNEUsVUFBVSx3QkFBd0I7RUFDcEgsTUFBTSxVQUFVLHdCQUF3QixVQUFVLHlCQUF5QixLQUFLLGNBQWM7RUFDOUYsTUFBTSxXQUFXLHdCQUF3QiwyQkFBMkIsd0JBQXdCO0FBQzVGLE9BQUssY0FBYyxpQkFBaUIsU0FBUyxVQUFVLElBQUk7Q0FDM0Q7QUFDRDtBQU9NLFNBQVMsWUFBWUUsUUFBK0I7QUFDMUQsUUFBTztBQUNQO0FBTU0sU0FBUyxlQUFlQyxJQUF5RTtBQUN2RyxRQUFPO0VBQ04sYUFBYSxZQUFZO0VBQ3pCLGNBQWMsY0FBYyxHQUFHLFVBQVU7RUFDekMsZ0JBQWdCLEVBQ2YsS0FBSyxjQUFjLEdBQUcsWUFBWSxDQUNsQztDQUNEO0FBQ0QifQ==