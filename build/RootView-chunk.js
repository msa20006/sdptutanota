import { assertMainOrNodeBoot, isApp } from "./Env-chunk.js";
import { mithril_default } from "./mithril-chunk.js";
import { insideRect, makeSingleUse, remove } from "./dist2-chunk.js";
import { AlphaEnum, alpha, animations, styles } from "./styles-chunk.js";
import { theme } from "./theme-chunk.js";
import { Keys } from "./TutanotaConstants-chunk.js";
import { isKeyPressed, keyManager } from "./KeyManager-chunk.js";
import { windowFacade } from "./WindowFacade-chunk.js";
import { px, size } from "./size-chunk.js";
import { getSafeAreaInsetBottom } from "./HtmlUtils-chunk.js";

//#region src/common/gui/base/Modal.ts
assertMainOrNodeBoot();
var Modal = class {
	components;
	uniqueComponent;
	view;
	visible;
	currentKey;
	closingComponents;
	historyEventListener = (e) => this.popState(e);
	constructor() {
		this.currentKey = 0;
		this.components = [];
		this.visible = false;
		this.uniqueComponent = null;
		this.closingComponents = [];
		this.view = () => {
			return mithril_default("#modal.fill-absolute", {
				oncreate: (_) => {},
				style: {
					"z-index": LayerType.Modal,
					display: this.visible ? "" : "none"
				}
			}, this.components.map((wrapper, i, array) => {
				return mithril_default(".fill-absolute", {
					key: wrapper.key,
					oncreate: (vnode) => {
						this.visible = true;
						mithril_default.redraw();
						if (wrapper.needsBg) this.addAnimation(vnode.dom, true);
					},
					onclick: (event) => {
						const element = event.currentTarget;
						const child = element.firstElementChild;
						if (child) {
							const childRect = child.getBoundingClientRect();
							if (!insideRect(event, childRect)) wrapper.component.backgroundClick(event);
						}
					},
					style: { zIndex: LayerType.Modal + 1 + i },
					onbeforeremove: (vnode) => {
						if (wrapper.needsBg) {
							this.closingComponents.push(wrapper.component);
							return Promise.all([this.addAnimation(vnode.dom, false).then(() => {
								remove(this.closingComponents, wrapper.component);
								if (this.components.length === 0 && this.closingComponents.length === 0) this.visible = false;
							}), wrapper.component.hideAnimation()]).then(() => {
								mithril_default.redraw();
							});
						} else {
							if (this.components.length === 0 && this.closingComponents.length === 0) this.visible = false;
							return wrapper.component.hideAnimation().then(() => mithril_default.redraw());
						}
					}
				}, mithril_default(wrapper.component));
			}));
		};
	}
	display(component, needsBg = true) {
		windowFacade.removeHistoryEventListener(this.historyEventListener);
		windowFacade.addHistoryEventListener(this.historyEventListener);
		if (this.components.length > 0) keyManager.unregisterModalShortcuts(this.components[this.components.length - 1].component.shortcuts());
		const existingIndex = this.components.findIndex((shownComponent) => shownComponent.component === component);
		if (existingIndex !== -1) {
			console.warn("Attempting to display the same modal component multiple times!");
			this.components.splice(existingIndex, 1);
		}
		this.components.push({
			key: this.currentKey++,
			component,
			needsBg
		});
		mithril_default.redraw();
		keyManager.registerModalShortcuts(component.shortcuts());
	}
	/**
	* notify components that a history state was popped. The Component Stack is notified from the top and the first
	* Component to return false will stop underlying components from receiving the notification.
	* Components that return true are expected to remove themselves from the Modal stack, eg dropdowns.
	* @param e: the DOM Event
	* @private
	*/
	popState(e) {
		console.log("modal popstate");
		const len = this.components.length;
		if (len === 0) {
			console.log("no modals to close");
			return true;
		}
		const keys = this.components.map((c) => c.key);
		for (let i = len - 1; i >= 0; i--) {
			const component = this.getComponentByKey(keys[i]);
			if (!component) {
				console.log("component went AWOL, continuing");
				continue;
			}
			if (!component.popState(e)) {
				console.log("component handled popstate");
				return false;
			}
		}
		return true;
	}
	/**
	* used for modal components that should only be opened once
	* multiple calls will be ignored if the first component is still visible
	* @param component
	*/
	displayUnique(component, needsBg = true) {
		if (this.uniqueComponent) {
			console.log("tried to open unique component while another was open!");
			return;
		}
		this.display(component, needsBg);
		this.uniqueComponent = component;
	}
	getComponentByKey(key$1) {
		const entry = this.components.find((c) => c.key === key$1);
		return entry?.component ?? null;
	}
	remove(component) {
		const componentIndex = this.components.findIndex((wrapper) => wrapper.component === component);
		if (componentIndex === -1) {
			console.log("can't remove non existing component from modal");
			return;
		}
		const componentIsTopmostComponent = componentIndex === this.components.length - 1;
		if (componentIsTopmostComponent) {
			console.log("removed topmost modal component");
			keyManager.unregisterModalShortcuts(component.shortcuts());
		}
		this.components.splice(componentIndex, 1);
		if (this.uniqueComponent === component) this.uniqueComponent = null;
		mithril_default.redraw();
		if (this.components.length > 0 && componentIsTopmostComponent) keyManager.registerModalShortcuts(this.components[this.components.length - 1].component.shortcuts());
		component.callingElement()?.focus();
	}
	/**
	* adds an animation to the topmost component
	*/
	addAnimation(domLayer, fadein) {
		const start = 0;
		const end = .5;
		return animations.add(domLayer, alpha(AlphaEnum.BackgroundColor, theme.modal_bg, fadein ? start : end, fadein ? end : start));
	}
};
const modal = new Modal();

//#endregion
//#region src/common/gui/base/Overlay.ts
assertMainOrNodeBoot();
const overlays = new Map();
let key = 0;
function displayOverlay(position, component, createAnimation, closeAnimation, shadowClass = "dropdown-shadow") {
	if (createAnimation != null && closeAnimation == null) closeAnimation = `${createAnimation} animation-reverse`;
	const overlayKey = key++;
	const pair = {
		position,
		component,
		createAnimation,
		closeAnimation,
		shadowClass
	};
	overlays.set(overlayKey, pair);
	return makeSingleUse(() => {
		if (!overlays.delete(overlayKey)) console.warn(`Missing overlay with key:${overlayKey}!`);
	});
}
const overlay = { view: () => mithril_default(
	// we want the overlays to position relative to the overlay parent
	// the overlay parent also should fill the root
	"#overlay.fill-absolute.noprint",
	{
		style: {
			display: overlays.size > 0 ? "" : "none",
			"margin-top": "env(safe-area-inset-top)",
			"margin-bottom": styles.isUsingBottomNavigation() ? px(size.bottom_nav_bar + getSafeAreaInsetBottom()) : "unset",
			"margin-left": "env(safe-area-inset-left)",
			"margin-right": "env(safe-area-inset-right)"
		},
		"aria-hidden": overlays.size === 0
	},
	Array.from(overlays.entries()).map((overlay$1) => {
		const [key$1, attrs] = overlay$1;
		const position = attrs.position();
		const baseClasses = "abs elevated-bg " + attrs.shadowClass;
		const classes = attrs.createAnimation == null ? baseClasses : baseClasses + " " + attrs.createAnimation;
		return mithril_default("", {
			key: key$1,
			class: classes,
			style: {
				width: position.width,
				top: position.top,
				bottom: position.bottom,
				right: position.right,
				left: position.left,
				height: position.height,
				"z-index": position.zIndex != null ? position.zIndex : LayerType.Overlay
			},
			onbeforeremove: (vnode) => {
				if (attrs.closeAnimation != null) {
					const dom = vnode.dom;
					dom.className = baseClasses;
					void dom.offsetWidth;
					dom.className = baseClasses + " " + attrs.closeAnimation;
					return new Promise(function(resolve) {
						dom.addEventListener("animationend", resolve);
					});
				}
			}
		}, mithril_default(attrs.component));
	})
) };

//#endregion
//#region src/RootView.ts
assertMainOrNodeBoot();
let LayerType = function(LayerType$1) {
	LayerType$1[LayerType$1["View"] = 0] = "View";
	LayerType$1[LayerType$1["LowPriorityOverlay"] = 100] = "LowPriorityOverlay";
	LayerType$1[LayerType$1["LowPriorityNotification"] = 150] = "LowPriorityNotification";
	LayerType$1[LayerType$1["ForegroundMenu"] = 200] = "ForegroundMenu";
	LayerType$1[LayerType$1["Modal"] = 300] = "Modal";
	LayerType$1[LayerType$1["Overlay"] = 400] = "Overlay";
	return LayerType$1;
}({});
let PrimaryNavigationType = function(PrimaryNavigationType$1) {
	PrimaryNavigationType$1[PrimaryNavigationType$1["Keyboard"] = 0] = "Keyboard";
	PrimaryNavigationType$1[PrimaryNavigationType$1["Touch"] = 1] = "Touch";
	PrimaryNavigationType$1[PrimaryNavigationType$1["Mouse"] = 2] = "Mouse";
	return PrimaryNavigationType$1;
}({});
let currentNavigationType = isApp() ? PrimaryNavigationType.Touch : PrimaryNavigationType.Mouse;
var RootView = class {
	dom = null;
	constructor() {
		this.view = this.view.bind(this);
	}
	view(vnode) {
		return mithril_default("#root" + (styles.isUsingBottomNavigation() ? ".mobile" : ""), {
			oncreate: (vnode$1) => {
				this.dom = vnode$1.dom;
			},
			onpointerup: (e) => {
				if (e.pointerType === "mouse") this.switchNavType(PrimaryNavigationType.Mouse);
else this.switchNavType(PrimaryNavigationType.Touch);
				e.redraw = false;
			},
			onkeyup: (e) => {
				if (isKeyPressed(e.key, Keys.TAB, Keys.UP, Keys.DOWN, Keys.J, Keys.K)) this.switchNavType(PrimaryNavigationType.Keyboard);
				e.redraw = false;
			},
			class: this.classForType(),
			style: { height: "100%" }
		}, [
			mithril_default(overlay),
			mithril_default(modal),
			vnode.children
		]);
	}
	switchNavType(newType) {
		if (currentNavigationType === newType) return;
		this.dom?.classList.remove(this.classForType());
		currentNavigationType = newType;
		this.dom?.classList.add(this.classForType());
	}
	classForType() {
		switch (currentNavigationType) {
			case PrimaryNavigationType.Keyboard: return "keyboard-nav";
			case PrimaryNavigationType.Mouse: return "mouse-nav";
			case PrimaryNavigationType.Touch: return "touch-nav";
		}
	}
};
const root = new RootView();

//#endregion
export { LayerType, PrimaryNavigationType, currentNavigationType, displayOverlay, modal, root };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm9vdFZpZXctY2h1bmsuanMiLCJuYW1lcyI6WyJlOiBFdmVudCIsImV2ZW50OiBNb3VzZUV2ZW50IiwiY29tcG9uZW50OiBNb2RhbENvbXBvbmVudCIsIm5lZWRzQmc6IGJvb2xlYW4iLCJrZXk6IG51bWJlciIsImtleSIsImRvbUxheWVyOiBIVE1MRWxlbWVudCIsImZhZGVpbjogYm9vbGVhbiIsIm1vZGFsOiBNb2RhbCIsIm92ZXJsYXlzOiBNYXA8bnVtYmVyLCBPdmVybGF5QXR0cnM+IiwicG9zaXRpb246IGxhenk8UG9zaXRpb25SZWN0PiIsImNvbXBvbmVudDogQ29tcG9uZW50IiwiY3JlYXRlQW5pbWF0aW9uPzogc3RyaW5nIiwiY2xvc2VBbmltYXRpb24/OiBzdHJpbmciLCJzaGFkb3dDbGFzczogc3RyaW5nIiwib3ZlcmxheTogQ29tcG9uZW50Iiwib3ZlcmxheSIsImtleSIsInZub2RlOiBWbm9kZURPTSIsImN1cnJlbnROYXZpZ2F0aW9uVHlwZTogUHJpbWFyeU5hdmlnYXRpb25UeXBlIiwidm5vZGU6IFZub2RlIiwidm5vZGUiLCJlOiBFdmVudFJlZHJhdzxQb2ludGVyRXZlbnQ+IiwiZTogRXZlbnRSZWRyYXc8S2V5Ym9hcmRFdmVudD4iLCJuZXdUeXBlOiBQcmltYXJ5TmF2aWdhdGlvblR5cGUiLCJyb290OiBSb290VmlldyJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vZ3VpL2Jhc2UvTW9kYWwudHMiLCIuLi9zcmMvY29tbW9uL2d1aS9iYXNlL092ZXJsYXkudHMiLCIuLi9zcmMvUm9vdFZpZXcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0sIHsgQ2hpbGRyZW4sIENvbXBvbmVudCB9IGZyb20gXCJtaXRocmlsXCJcbmltcG9ydCB7IGFscGhhLCBBbHBoYUVudW0sIGFuaW1hdGlvbnMgfSBmcm9tIFwiLi8uLi9hbmltYXRpb24vQW5pbWF0aW9uc1wiXG5pbXBvcnQgeyB0aGVtZSB9IGZyb20gXCIuLi90aGVtZVwiXG5pbXBvcnQgdHlwZSB7IFNob3J0Y3V0IH0gZnJvbSBcIi4uLy4uL21pc2MvS2V5TWFuYWdlclwiXG5pbXBvcnQgeyBrZXlNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uL21pc2MvS2V5TWFuYWdlclwiXG5pbXBvcnQgeyB3aW5kb3dGYWNhZGUgfSBmcm9tIFwiLi4vLi4vbWlzYy9XaW5kb3dGYWNhZGVcIlxuaW1wb3J0IHsgaW5zaWRlUmVjdCwgcmVtb3ZlIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBMYXllclR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vUm9vdFZpZXdcIlxuaW1wb3J0IHsgYXNzZXJ0TWFpbk9yTm9kZUJvb3QgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi9FbnZcIlxuXG5hc3NlcnRNYWluT3JOb2RlQm9vdCgpXG5cbnR5cGUgTW9kYWxDb21wb25lbnRXcmFwcGVyID0ge1xuXHRrZXk6IG51bWJlclxuXHRjb21wb25lbnQ6IE1vZGFsQ29tcG9uZW50XG5cdG5lZWRzQmc6IGJvb2xlYW5cbn1cblxuY2xhc3MgTW9kYWwgaW1wbGVtZW50cyBDb21wb25lbnQge1xuXHRjb21wb25lbnRzOiBBcnJheTxNb2RhbENvbXBvbmVudFdyYXBwZXI+XG5cdHByaXZhdGUgdW5pcXVlQ29tcG9uZW50OiBNb2RhbENvbXBvbmVudCB8IG51bGxcblx0dmlldzogQ29tcG9uZW50W1widmlld1wiXVxuXHR2aXNpYmxlOiBib29sZWFuXG5cdGN1cnJlbnRLZXk6IG51bWJlclxuXHRwcml2YXRlIGNsb3NpbmdDb21wb25lbnRzOiBBcnJheTxNb2RhbENvbXBvbmVudD5cblx0cHJpdmF0ZSByZWFkb25seSBoaXN0b3J5RXZlbnRMaXN0ZW5lciA9IChlOiBFdmVudCkgPT4gdGhpcy5wb3BTdGF0ZShlKVxuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuY3VycmVudEtleSA9IDBcblx0XHR0aGlzLmNvbXBvbmVudHMgPSBbXVxuXHRcdHRoaXMudmlzaWJsZSA9IGZhbHNlXG5cdFx0dGhpcy51bmlxdWVDb21wb25lbnQgPSBudWxsXG5cdFx0dGhpcy5jbG9zaW5nQ29tcG9uZW50cyA9IFtdXG5cblx0XHR0aGlzLnZpZXcgPSAoKTogQ2hpbGRyZW4gPT4ge1xuXHRcdFx0cmV0dXJuIG0oXG5cdFx0XHRcdFwiI21vZGFsLmZpbGwtYWJzb2x1dGVcIixcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG9uY3JlYXRlOiAoXykgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gY29uc3QgbGFzdENvbXBvbmVudCA9IGxhc3QodGhpcy5jb21wb25lbnRzKVxuXHRcdFx0XHRcdFx0Ly8gaWYgKGxhc3RDb21wb25lbnQpIHtcblx0XHRcdFx0XHRcdC8vIFx0bGFzdENvbXBvbmVudC5jb21wb25lbnQuYmFja2dyb3VuZENsaWNrKGUpXG5cdFx0XHRcdFx0XHQvLyB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0XCJ6LWluZGV4XCI6IExheWVyVHlwZS5Nb2RhbCxcblx0XHRcdFx0XHRcdGRpc3BsYXk6IHRoaXMudmlzaWJsZSA/IFwiXCIgOiBcIm5vbmVcIixcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGlzLmNvbXBvbmVudHMubWFwKCh3cmFwcGVyLCBpLCBhcnJheSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBtKFxuXHRcdFx0XHRcdFx0XCIuZmlsbC1hYnNvbHV0ZVwiLFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRrZXk6IHdyYXBwZXIua2V5LFxuXHRcdFx0XHRcdFx0XHRvbmNyZWF0ZTogKHZub2RlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG8gbm90IHNldCB2aXNpYmxlPXRydWUgYWxyZWFkeSBpbiBkaXNwbGF5KCkgYmVjYXVzZSBpdCBsZWFkcyB0byBtb2RhbCBzdGF5aW5nIG9wZW4gaW4gYSBzZWNvbmQgd2luZG93IGluIENocm9tZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGJlY2F1c2Ugb25iZWZvcmVyZW1vdmUgaXMgbm90IGNhbGxlZCBpbiB0aGF0IGNhc2UgdG8gc2V0IHZpc2libGU9ZmFsc2UuIHRoaXMgaXMgcHJvYmFibHkgYW4gb3B0aW1pemF0aW9uIGluIENocm9tZSB0byByZWR1Y2Vcblx0XHRcdFx0XHRcdFx0XHQvLyBVSSB1cGRhdGVzIGlmIHRoZSB3aW5kb3cgaXMgbm90IHZpc2libGUuIHNldHRpbmcgdmlzaWJsZT10cnVlIGhlcmUgaXMgZmluZSBiZWNhdXNlIHRoaXMgY29kZSBpcyBub3QgZXZlbiBjYWxsZWQgdGhlblxuXHRcdFx0XHRcdFx0XHRcdHRoaXMudmlzaWJsZSA9IHRydWVcblx0XHRcdFx0XHRcdFx0XHRtLnJlZHJhdygpXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdyYXBwZXIubmVlZHNCZykgdGhpcy5hZGRBbmltYXRpb24odm5vZGUuZG9tIGFzIEhUTUxFbGVtZW50LCB0cnVlKVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmNsaWNrOiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoaXMgbGF5ZXIgZGl2IGhhcyBhIHNpbmdsZSBjaGlsZCwgdGhlIG1vZGFsIGNvbXBvbmVudFxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGNoaWxkID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY2hpbGQgc2hvdWxkbid0IGJlIG51bGwgYnV0IG1heWJlIHRoZSB1c2VyIGNsaWNrIGZhc3QgaWRrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNoaWxkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWluc2lkZVJlY3QoZXZlbnQsIGNoaWxkUmVjdCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0d3JhcHBlci5jb21wb25lbnQuYmFja2dyb3VuZENsaWNrKGV2ZW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdFx0XHR6SW5kZXg6IExheWVyVHlwZS5Nb2RhbCArIDEgKyBpLFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmJlZm9yZXJlbW92ZTogKHZub2RlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdyYXBwZXIubmVlZHNCZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5jbG9zaW5nQ29tcG9uZW50cy5wdXNoKHdyYXBwZXIuY29tcG9uZW50KVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmFkZEFuaW1hdGlvbih2bm9kZS5kb20gYXMgSFRNTEVsZW1lbnQsIGZhbHNlKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmUodGhpcy5jbG9zaW5nQ29tcG9uZW50cywgd3JhcHBlci5jb21wb25lbnQpXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmNsb3NpbmdDb21wb25lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR3cmFwcGVyLmNvbXBvbmVudC5oaWRlQW5pbWF0aW9uKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRdKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bS5yZWRyYXcoKVxuXHRcdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuY29tcG9uZW50cy5sZW5ndGggPT09IDAgJiYgdGhpcy5jbG9zaW5nQ29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHdyYXBwZXIuY29tcG9uZW50LmhpZGVBbmltYXRpb24oKS50aGVuKCgpID0+IG0ucmVkcmF3KCkpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG0od3JhcHBlci5jb21wb25lbnQpLFxuXHRcdFx0XHRcdClcblx0XHRcdFx0fSksXG5cdFx0XHQpXG5cdFx0fVxuXHR9XG5cblx0ZGlzcGxheShjb21wb25lbnQ6IE1vZGFsQ29tcG9uZW50LCBuZWVkc0JnOiBib29sZWFuID0gdHJ1ZSkge1xuXHRcdC8vIG1vdmUgdGhlIGhhbmRsZXIgdG8gdGhlIHRvcCBvZiB0aGUgaGFuZGxlciBzdGFja1xuXHRcdHdpbmRvd0ZhY2FkZS5yZW1vdmVIaXN0b3J5RXZlbnRMaXN0ZW5lcih0aGlzLmhpc3RvcnlFdmVudExpc3RlbmVyKVxuXHRcdHdpbmRvd0ZhY2FkZS5hZGRIaXN0b3J5RXZlbnRMaXN0ZW5lcih0aGlzLmhpc3RvcnlFdmVudExpc3RlbmVyKVxuXHRcdGlmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0a2V5TWFuYWdlci51bnJlZ2lzdGVyTW9kYWxTaG9ydGN1dHModGhpcy5jb21wb25lbnRzW3RoaXMuY29tcG9uZW50cy5sZW5ndGggLSAxXS5jb21wb25lbnQuc2hvcnRjdXRzKCkpXG5cdFx0fVxuXG5cdFx0Y29uc3QgZXhpc3RpbmdJbmRleCA9IHRoaXMuY29tcG9uZW50cy5maW5kSW5kZXgoKHNob3duQ29tcG9uZW50KSA9PiBzaG93bkNvbXBvbmVudC5jb21wb25lbnQgPT09IGNvbXBvbmVudClcblxuXHRcdGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiQXR0ZW1wdGluZyB0byBkaXNwbGF5IHRoZSBzYW1lIG1vZGFsIGNvbXBvbmVudCBtdWx0aXBsZSB0aW1lcyFcIilcblx0XHRcdHRoaXMuY29tcG9uZW50cy5zcGxpY2UoZXhpc3RpbmdJbmRleCwgMSlcblx0XHR9XG5cblx0XHR0aGlzLmNvbXBvbmVudHMucHVzaCh7XG5cdFx0XHRrZXk6IHRoaXMuY3VycmVudEtleSsrLFxuXHRcdFx0Y29tcG9uZW50OiBjb21wb25lbnQsXG5cdFx0XHRuZWVkc0JnLFxuXHRcdH0pXG5cdFx0bS5yZWRyYXcoKVxuXHRcdGtleU1hbmFnZXIucmVnaXN0ZXJNb2RhbFNob3J0Y3V0cyhjb21wb25lbnQuc2hvcnRjdXRzKCkpXG5cdH1cblxuXHQvKipcblx0ICogbm90aWZ5IGNvbXBvbmVudHMgdGhhdCBhIGhpc3Rvcnkgc3RhdGUgd2FzIHBvcHBlZC4gVGhlIENvbXBvbmVudCBTdGFjayBpcyBub3RpZmllZCBmcm9tIHRoZSB0b3AgYW5kIHRoZSBmaXJzdFxuXHQgKiBDb21wb25lbnQgdG8gcmV0dXJuIGZhbHNlIHdpbGwgc3RvcCB1bmRlcmx5aW5nIGNvbXBvbmVudHMgZnJvbSByZWNlaXZpbmcgdGhlIG5vdGlmaWNhdGlvbi5cblx0ICogQ29tcG9uZW50cyB0aGF0IHJldHVybiB0cnVlIGFyZSBleHBlY3RlZCB0byByZW1vdmUgdGhlbXNlbHZlcyBmcm9tIHRoZSBNb2RhbCBzdGFjaywgZWcgZHJvcGRvd25zLlxuXHQgKiBAcGFyYW0gZTogdGhlIERPTSBFdmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cHJpdmF0ZSBwb3BTdGF0ZShlOiBFdmVudCk6IGJvb2xlYW4ge1xuXHRcdGNvbnNvbGUubG9nKFwibW9kYWwgcG9wc3RhdGVcIilcblx0XHRjb25zdCBsZW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoXG5cblx0XHRpZiAobGVuID09PSAwKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIm5vIG1vZGFscyB0byBjbG9zZVwiKVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cblx0XHQvLyBnZXQgdGhlIGtleXMgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byBtb2RpZnkgdGhlIGNvbXBvbmVudCBzdGFjayBkdXJpbmcgaXRlcmF0aW9uXG5cdFx0Y29uc3Qga2V5cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGMua2V5KVxuXG5cdFx0Zm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudEJ5S2V5KGtleXNbaV0pXG5cblx0XHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiY29tcG9uZW50IHdlbnQgQVdPTCwgY29udGludWluZ1wiKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWNvbXBvbmVudC5wb3BTdGF0ZShlKSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcImNvbXBvbmVudCBoYW5kbGVkIHBvcHN0YXRlXCIpXG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHQvKipcblx0ICogdXNlZCBmb3IgbW9kYWwgY29tcG9uZW50cyB0aGF0IHNob3VsZCBvbmx5IGJlIG9wZW5lZCBvbmNlXG5cdCAqIG11bHRpcGxlIGNhbGxzIHdpbGwgYmUgaWdub3JlZCBpZiB0aGUgZmlyc3QgY29tcG9uZW50IGlzIHN0aWxsIHZpc2libGVcblx0ICogQHBhcmFtIGNvbXBvbmVudFxuXHQgKi9cblx0ZGlzcGxheVVuaXF1ZShjb21wb25lbnQ6IE1vZGFsQ29tcG9uZW50LCBuZWVkc0JnOiBib29sZWFuID0gdHJ1ZSkge1xuXHRcdGlmICh0aGlzLnVuaXF1ZUNvbXBvbmVudCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJ0cmllZCB0byBvcGVuIHVuaXF1ZSBjb21wb25lbnQgd2hpbGUgYW5vdGhlciB3YXMgb3BlbiFcIilcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHRoaXMuZGlzcGxheShjb21wb25lbnQsIG5lZWRzQmcpXG5cdFx0dGhpcy51bmlxdWVDb21wb25lbnQgPSBjb21wb25lbnRcblx0fVxuXG5cdHByaXZhdGUgZ2V0Q29tcG9uZW50QnlLZXkoa2V5OiBudW1iZXIpOiBNb2RhbENvbXBvbmVudCB8IG51bGwge1xuXHRcdGNvbnN0IGVudHJ5ID0gdGhpcy5jb21wb25lbnRzLmZpbmQoKGMpID0+IGMua2V5ID09PSBrZXkpXG5cdFx0cmV0dXJuIGVudHJ5Py5jb21wb25lbnQgPz8gbnVsbFxuXHR9XG5cblx0cmVtb3ZlKGNvbXBvbmVudDogTW9kYWxDb21wb25lbnQpOiB2b2lkIHtcblx0XHRjb25zdCBjb21wb25lbnRJbmRleCA9IHRoaXMuY29tcG9uZW50cy5maW5kSW5kZXgoKHdyYXBwZXIpID0+IHdyYXBwZXIuY29tcG9uZW50ID09PSBjb21wb25lbnQpXG5cblx0XHRpZiAoY29tcG9uZW50SW5kZXggPT09IC0xKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcImNhbid0IHJlbW92ZSBub24gZXhpc3RpbmcgY29tcG9uZW50IGZyb20gbW9kYWxcIilcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGNvbnN0IGNvbXBvbmVudElzVG9wbW9zdENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ID09PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoIC0gMVxuXG5cdFx0aWYgKGNvbXBvbmVudElzVG9wbW9zdENvbXBvbmVudCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJyZW1vdmVkIHRvcG1vc3QgbW9kYWwgY29tcG9uZW50XCIpXG5cdFx0XHRrZXlNYW5hZ2VyLnVucmVnaXN0ZXJNb2RhbFNob3J0Y3V0cyhjb21wb25lbnQuc2hvcnRjdXRzKCkpXG5cdFx0fVxuXG5cdFx0dGhpcy5jb21wb25lbnRzLnNwbGljZShjb21wb25lbnRJbmRleCwgMSlcblxuXHRcdGlmICh0aGlzLnVuaXF1ZUNvbXBvbmVudCA9PT0gY29tcG9uZW50KSB7XG5cdFx0XHR0aGlzLnVuaXF1ZUNvbXBvbmVudCA9IG51bGxcblx0XHR9XG5cblx0XHRtLnJlZHJhdygpXG5cblx0XHRpZiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCA+IDAgJiYgY29tcG9uZW50SXNUb3Btb3N0Q29tcG9uZW50KSB7XG5cdFx0XHQvLyB0aGUgcmVtb3ZlZCBjb21wb25lbnQgd2FzIHRoZSBsYXN0IGNvbXBvbmVudCwgc28gd2UgY2FuIG5vdyByZWdpc3RlciB0aGUgc2hvcnRjdXRzIG9mIHRoZSBub3cgbGFzdCBjb21wb25lbnRcblx0XHRcdGtleU1hbmFnZXIucmVnaXN0ZXJNb2RhbFNob3J0Y3V0cyh0aGlzLmNvbXBvbmVudHNbdGhpcy5jb21wb25lbnRzLmxlbmd0aCAtIDFdLmNvbXBvbmVudC5zaG9ydGN1dHMoKSlcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGZvY3VzIGJhY2sgdG8gaXQncyBjYWxsaW5nIGVsZW1lbnQuXG5cdFx0Y29tcG9uZW50LmNhbGxpbmdFbGVtZW50KCk/LmZvY3VzKClcblx0fVxuXG5cdC8qKlxuXHQgKiBhZGRzIGFuIGFuaW1hdGlvbiB0byB0aGUgdG9wbW9zdCBjb21wb25lbnRcblx0ICovXG5cdGFkZEFuaW1hdGlvbihkb21MYXllcjogSFRNTEVsZW1lbnQsIGZhZGVpbjogYm9vbGVhbik6IFByb21pc2U8dW5rbm93bj4ge1xuXHRcdGNvbnN0IHN0YXJ0ID0gMFxuXHRcdGNvbnN0IGVuZCA9IDAuNVxuXHRcdHJldHVybiBhbmltYXRpb25zLmFkZChkb21MYXllciwgYWxwaGEoQWxwaGFFbnVtLkJhY2tncm91bmRDb2xvciwgdGhlbWUubW9kYWxfYmcsIGZhZGVpbiA/IHN0YXJ0IDogZW5kLCBmYWRlaW4gPyBlbmQgOiBzdGFydCkpXG5cdH1cbn1cblxuZXhwb3J0IGNvbnN0IG1vZGFsOiBNb2RhbCA9IG5ldyBNb2RhbCgpXG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kYWxDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRoaWRlQW5pbWF0aW9uKCk6IFByb21pc2U8dm9pZD5cblxuXHRvbkNsb3NlKCk6IHZvaWRcblxuXHRzaG9ydGN1dHMoKTogU2hvcnRjdXRbXVxuXG5cdGJhY2tncm91bmRDbGljayhlOiBNb3VzZUV2ZW50KTogdm9pZFxuXG5cdC8qKlxuXHQgKiB3aWxsIGJlIGNhbGxlZCBieSB0aGUgbWFpbiBtb2RhbCBpZiBubyBvdGhlciBjb21wb25lbnQgYWJvdmUgdGhpcyBvbmUgYmxvY2tlZCB0aGUgZXZlbnQgKHByZXZpb3VzIGNvbXBvbmVudHMgcmV0dXJuZWQgdHJ1ZSlcblx0ICogcmV0dXJuIGZhbHNlIGlmIHRoZSBldmVudCB3YXMgaGFuZGxlZCBhbmQgbG93ZXIgY29tcG9uZW50cyBzaG91bGRuJ3QgYmUgbm90aWZpZWQsIHRydWUgb3RoZXJ3aXNlXG5cdCAqIEBwYXJhbSBlXG5cdCAqL1xuXHRwb3BTdGF0ZShlOiBFdmVudCk6IGJvb2xlYW5cblxuXHQvLyBUaGUgZWxlbWVudCB0aGF0IHdhcyBpbnRlcmFjdGVkIHdpdGggdG8gc2hvdyB0aGUgbW9kYWwuXG5cdGNhbGxpbmdFbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbFxufVxuIiwiaW1wb3J0IG0sIHsgQ2hpbGRyZW4sIENvbXBvbmVudCwgVm5vZGVET00gfSBmcm9tIFwibWl0aHJpbFwiXG5pbXBvcnQgeyBMYXllclR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vUm9vdFZpZXdcIlxuaW1wb3J0IHsgbGF6eSwgbWFrZVNpbmdsZVVzZSB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgYXNzZXJ0TWFpbk9yTm9kZUJvb3QgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi9FbnZcIlxuaW1wb3J0IHsgcHgsIHNpemUgfSBmcm9tIFwiLi4vc2l6ZS5qc1wiXG5pbXBvcnQgeyBzdHlsZXMgfSBmcm9tIFwiLi4vc3R5bGVzLmpzXCJcbmltcG9ydCB7IGdldFNhZmVBcmVhSW5zZXRCb3R0b20gfSBmcm9tIFwiLi4vSHRtbFV0aWxzLmpzXCJcblxuYXNzZXJ0TWFpbk9yTm9kZUJvb3QoKVxuZXhwb3J0IHR5cGUgUG9zaXRpb25SZWN0ID0ge1xuXHR0b3A/OiBzdHJpbmcgfCBudWxsXG5cdGxlZnQ/OiBzdHJpbmcgfCBudWxsXG5cdHJpZ2h0Pzogc3RyaW5nIHwgbnVsbFxuXHR3aWR0aD86IHN0cmluZyB8IG51bGxcblx0Ym90dG9tPzogc3RyaW5nIHwgbnVsbFxuXHRoZWlnaHQ/OiBzdHJpbmcgfCBudWxsXG5cdHpJbmRleD86IExheWVyVHlwZVxufVxudHlwZSBPdmVybGF5QXR0cnMgPSB7XG5cdGNvbXBvbmVudDogQ29tcG9uZW50XG5cdHBvc2l0aW9uOiBsYXp5PFBvc2l0aW9uUmVjdD5cblx0Y3JlYXRlQW5pbWF0aW9uPzogc3RyaW5nXG5cdGNsb3NlQW5pbWF0aW9uPzogc3RyaW5nXG5cdHNoYWRvd0NsYXNzOiBzdHJpbmdcbn1cblxuY29uc3Qgb3ZlcmxheXM6IE1hcDxudW1iZXIsIE92ZXJsYXlBdHRycz4gPSBuZXcgTWFwKClcbmxldCBrZXkgPSAwXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5T3ZlcmxheShcblx0cG9zaXRpb246IGxhenk8UG9zaXRpb25SZWN0Pixcblx0Y29tcG9uZW50OiBDb21wb25lbnQsXG5cdGNyZWF0ZUFuaW1hdGlvbj86IHN0cmluZyxcblx0Y2xvc2VBbmltYXRpb24/OiBzdHJpbmcsXG5cdHNoYWRvd0NsYXNzOiBzdHJpbmcgPSBcImRyb3Bkb3duLXNoYWRvd1wiLFxuKTogKCkgPT4gdm9pZCB7XG5cdC8vIFVzZSB0aGUgaW52ZXJzZSBvZiB0aGUgc2hvdyBhbmltYXRpb24gYXMgdGhlIGNsb3NlIGFuaW1hdGlvbiBpZiBpdCBpcyBub3QgZ2l2ZW5cblx0aWYgKGNyZWF0ZUFuaW1hdGlvbiAhPSBudWxsICYmIGNsb3NlQW5pbWF0aW9uID09IG51bGwpIGNsb3NlQW5pbWF0aW9uID0gYCR7Y3JlYXRlQW5pbWF0aW9ufSBhbmltYXRpb24tcmV2ZXJzZWBcblxuXHRjb25zdCBvdmVybGF5S2V5ID0ga2V5Kytcblx0Y29uc3QgcGFpciA9IHtcblx0XHRwb3NpdGlvbixcblx0XHRjb21wb25lbnQsXG5cdFx0Y3JlYXRlQW5pbWF0aW9uLFxuXHRcdGNsb3NlQW5pbWF0aW9uLFxuXHRcdHNoYWRvd0NsYXNzLFxuXHR9IGFzIE92ZXJsYXlBdHRyc1xuXHQvLyBBZGQgdGhlIG5ldyBvdmVybGF5IGludG8gdGhlIG92ZXJsYXkgY29udGFpbmVyXG5cdG92ZXJsYXlzLnNldChvdmVybGF5S2V5LCBwYWlyKVxuXG5cdC8vIE1ha2Ugc2luZ2xlIHNvIGZhc3QgdGFwcyBkb2Vzbid0IHRyeSB0byByZW1vdmVcblx0Ly8gdGhlIHNhbWUgb3ZlcmxheSB0d2ljZVxuXHRyZXR1cm4gbWFrZVNpbmdsZVVzZSgoKSA9PiB7XG5cdFx0Ly8gUmVtb3ZlIHRoZSBvdmVybGF5ICYgZXJyb3IgaWYgdW5zdWNjZXNzZnVsXG5cdFx0aWYgKCFvdmVybGF5cy5kZWxldGUob3ZlcmxheUtleSkpIHtcblx0XHRcdGNvbnNvbGUud2FybihgTWlzc2luZyBvdmVybGF5IHdpdGgga2V5OiR7b3ZlcmxheUtleX0hYClcblx0XHR9XG5cdH0pIGFzICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNvbnN0IG92ZXJsYXk6IENvbXBvbmVudCA9IHtcblx0dmlldzogKCk6IENoaWxkcmVuID0+XG5cdFx0bShcblx0XHRcdC8vIHdlIHdhbnQgdGhlIG92ZXJsYXlzIHRvIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvdmVybGF5IHBhcmVudFxuXHRcdFx0Ly8gdGhlIG92ZXJsYXkgcGFyZW50IGFsc28gc2hvdWxkIGZpbGwgdGhlIHJvb3Rcblx0XHRcdFwiI292ZXJsYXkuZmlsbC1hYnNvbHV0ZS5ub3ByaW50XCIsXG5cdFx0XHR7XG5cdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0ZGlzcGxheTogb3ZlcmxheXMuc2l6ZSA+IDAgPyBcIlwiIDogXCJub25lXCIsXG5cdFx0XHRcdFx0XCJtYXJnaW4tdG9wXCI6IFwiZW52KHNhZmUtYXJlYS1pbnNldC10b3ApXCIsIC8vIGluc2V0cyBmb3IgaVBob25lIFhcblx0XHRcdFx0XHQvLyBrZWVwIHRoZSBib3R0b20gbmF2IGJhciBjbGVhciAmIGluc2V0IGZvciBpT1Ncblx0XHRcdFx0XHRcIm1hcmdpbi1ib3R0b21cIjogc3R5bGVzLmlzVXNpbmdCb3R0b21OYXZpZ2F0aW9uKCkgPyBweChzaXplLmJvdHRvbV9uYXZfYmFyICsgZ2V0U2FmZUFyZWFJbnNldEJvdHRvbSgpKSA6IFwidW5zZXRcIixcblx0XHRcdFx0XHQvLyB3ZSB3b3VsZCBuZWVkIHRvIGNoYW5nZSB0aGlzIGlmIHdlIHdhbnRlZCBzb21ldGhpbmcgdG8gYXBwZWFyIGZyb20gdGhlIHNpZGVcblx0XHRcdFx0XHRcIm1hcmdpbi1sZWZ0XCI6IFwiZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0KVwiLFxuXHRcdFx0XHRcdFwibWFyZ2luLXJpZ2h0XCI6IFwiZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodClcIixcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBvdmVybGF5cy5zaXplID09PSAwLFxuXHRcdFx0fSxcblx0XHRcdEFycmF5LmZyb20ob3ZlcmxheXMuZW50cmllcygpKS5tYXAoKG92ZXJsYXkpID0+IHtcblx0XHRcdFx0Y29uc3QgW2tleSwgYXR0cnNdID0gb3ZlcmxheVxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGF0dHJzLnBvc2l0aW9uKClcblxuXHRcdFx0XHRjb25zdCBiYXNlQ2xhc3NlcyA9IFwiYWJzIGVsZXZhdGVkLWJnIFwiICsgYXR0cnMuc2hhZG93Q2xhc3Ncblx0XHRcdFx0Y29uc3QgY2xhc3NlcyA9IGF0dHJzLmNyZWF0ZUFuaW1hdGlvbiA9PSBudWxsID8gYmFzZUNsYXNzZXMgOiBiYXNlQ2xhc3NlcyArIFwiIFwiICsgYXR0cnMuY3JlYXRlQW5pbWF0aW9uXG5cblx0XHRcdFx0cmV0dXJuIG0oXG5cdFx0XHRcdFx0XCJcIixcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRjbGFzczogY2xhc3Nlcyxcblx0XHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBwb3NpdGlvbi53aWR0aCxcblx0XHRcdFx0XHRcdFx0dG9wOiBwb3NpdGlvbi50b3AsXG5cdFx0XHRcdFx0XHRcdGJvdHRvbTogcG9zaXRpb24uYm90dG9tLFxuXHRcdFx0XHRcdFx0XHRyaWdodDogcG9zaXRpb24ucmlnaHQsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogcG9zaXRpb24uaGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRcInotaW5kZXhcIjogcG9zaXRpb24uekluZGV4ICE9IG51bGwgPyBwb3NpdGlvbi56SW5kZXggOiBMYXllclR5cGUuT3ZlcmxheSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRvbmJlZm9yZXJlbW92ZTogKHZub2RlOiBWbm9kZURPTSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cnMuY2xvc2VBbmltYXRpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRvbSA9IHZub2RlLmRvbSBhcyBIVE1MRWxlbWVudFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRm9yY2UgdGhlIGVudmlyb25tZW50IHRvIHJlc3RhcnQgdGhlIGFuaW1hdGlvbnMgdmlhIGEgcmVmbG93XG5cdFx0XHRcdFx0XHRcdFx0ZG9tLmNsYXNzTmFtZSA9IGJhc2VDbGFzc2VzXG5cdFx0XHRcdFx0XHRcdFx0dm9pZCBkb20ub2Zmc2V0V2lkdGhcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFBsYXkgdGhlIGNsb3NpbmcgYW5pbWF0aW9uXG5cdFx0XHRcdFx0XHRcdFx0ZG9tLmNsYXNzTmFtZSA9IGJhc2VDbGFzc2VzICsgXCIgXCIgKyBhdHRycy5jbG9zZUFuaW1hdGlvblxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2FpdCBmb3IgdGhlIGNsb3NlIGFuaW1hdGlvbiB0byBjb21wbGV0ZVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgcmVzb2x2ZSlcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bShhdHRycy5jb21wb25lbnQpLFxuXHRcdFx0XHQpXG5cdFx0XHR9KSxcblx0XHQpLFxufVxuIiwiaW1wb3J0IG0sIHsgQ2hpbGRyZW4sIENsYXNzQ29tcG9uZW50LCBWbm9kZSB9IGZyb20gXCJtaXRocmlsXCJcbmltcG9ydCB7IG1vZGFsIH0gZnJvbSBcIi4vY29tbW9uL2d1aS9iYXNlL01vZGFsXCJcbmltcG9ydCB7IG92ZXJsYXkgfSBmcm9tIFwiLi9jb21tb24vZ3VpL2Jhc2UvT3ZlcmxheVwiXG5pbXBvcnQgeyBzdHlsZXMgfSBmcm9tIFwiLi9jb21tb24vZ3VpL3N0eWxlc1wiXG5pbXBvcnQgeyBhc3NlcnRNYWluT3JOb2RlQm9vdCwgaXNBcHAgfSBmcm9tIFwiLi9jb21tb24vYXBpL2NvbW1vbi9FbnZcIlxuaW1wb3J0IHsgS2V5cyB9IGZyb20gXCIuL2NvbW1vbi9hcGkvY29tbW9uL1R1dGFub3RhQ29uc3RhbnRzLmpzXCJcbmltcG9ydCB7IGlzS2V5UHJlc3NlZCB9IGZyb20gXCIuL2NvbW1vbi9taXNjL0tleU1hbmFnZXIuanNcIlxuXG5hc3NlcnRNYWluT3JOb2RlQm9vdCgpXG5cbmV4cG9ydCBjb25zdCBlbnVtIExheWVyVHlwZSB7XG5cdC8vIE1pbmltaXplZCBlZGl0b3JzLCBTZWFyY2hCYXJPdmVybGF5XG5cdFZpZXcgPSAwLFxuXHQvLyBub3RpZmljYXRpb25zIHRoYXQgcmVxdWlyZSBubyB1c2VyIGludGVyYWN0aW9uXG5cdExvd1ByaW9yaXR5T3ZlcmxheSA9IDEwMCxcblx0Ly8gRm9yZWdyb3VuZCBtZW51IGluIG1vYmlsZSBsYXlvdXRcblx0TG93UHJpb3JpdHlOb3RpZmljYXRpb24gPSAxNTAsXG5cdC8vIEVkaXRvcnMsIERpYWxvZ3Ncblx0Rm9yZWdyb3VuZE1lbnUgPSAyMDAsXG5cdC8vIEVycm9yIG1lc3NhZ2UgZGlhbG9ncywgTm90aWZpY2F0aW9uc1xuXHRNb2RhbCA9IDMwMCxcblx0T3ZlcmxheSA9IDQwMCxcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gUHJpbWFyeU5hdmlnYXRpb25UeXBlIHtcblx0S2V5Ym9hcmQsXG5cdFRvdWNoLFxuXHRNb3VzZSxcblx0Ly8gdGhlb3JldGljYWxseSBwZW4gaXMgYWxzbyBhbiBvcHRpb25cbn1cblxuLy8gZ2xvYmFsLCBpbiBjYXNlIHdlIGhhdmUgbXVsdGlwbGUgaW5zdGFuY2VzIGZvciBzb21lIHJlYXNvblxuLyoqIFdoYXQgd2UgaW5mZXIgdG8gYmUgdGhlIHVzZXIncyBwcmVmZXJyZWQgbmF2aWdhdGlvbiB0eXBlLiAqL1xuZXhwb3J0IGxldCBjdXJyZW50TmF2aWdhdGlvblR5cGU6IFByaW1hcnlOYXZpZ2F0aW9uVHlwZSA9IGlzQXBwKCkgPyBQcmltYXJ5TmF2aWdhdGlvblR5cGUuVG91Y2ggOiBQcmltYXJ5TmF2aWdhdGlvblR5cGUuTW91c2VcblxuLyoqXG4gKiBWaWV3IHdoaWNoIHdyYXBzIGFueXRoaW5nIHRoYXQgd2UgcmVuZGVyLlxuICogSXQgaGFzIG92ZXJsYXksIG1vZGFsIGFuZCB0aGUgbWFpbiBsYXllcnMuIEl0IGFsc28gZGVmaW5lcyBzb21lIGdsb2JhbCBoYW5kbGVycyBmb3IgYmV0dGVyIHZpc3VhbCBpbmRpY2F0aW9uIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBSb290VmlldyBpbXBsZW1lbnRzIENsYXNzQ29tcG9uZW50IHtcblx0cHJpdmF0ZSBkb206IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGxcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvLyBzdGlsbCBcIm9sZC1zdHlsZVwiIGNvbXBvbmVudCwgd2UgZG9uJ3Qgd2FudCB0byBsb3NlIFwidGhpc1wiIHJlZmVyZW5jZVxuXHRcdHRoaXMudmlldyA9IHRoaXMudmlldy5iaW5kKHRoaXMpXG5cdH1cblxuXHR2aWV3KHZub2RlOiBWbm9kZSk6IENoaWxkcmVuIHtcblx0XHRyZXR1cm4gbShcblx0XHRcdFwiI3Jvb3RcIiArIChzdHlsZXMuaXNVc2luZ0JvdHRvbU5hdmlnYXRpb24oKSA/IFwiLm1vYmlsZVwiIDogXCJcIiksXG5cdFx0XHR7XG5cdFx0XHRcdG9uY3JlYXRlOiAodm5vZGUpID0+IHtcblx0XHRcdFx0XHR0aGlzLmRvbSA9IHZub2RlLmRvbSBhcyBIVE1MRWxlbWVudFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyB1c2UgcG9pbnRlciBldmVudHMgaW5zdGVhZCBvZiBtb3VzZWRvd24vdG91Y2hkb3duIGJlY2F1c2UgbW91c2UgZXZlbnRzIGFyZSBzdGlsbCBmaXJlZCBmb3IgdG91Y2ggb24gbW9iaWxlXG5cdFx0XHRcdG9ucG9pbnRlcnVwOiAoZTogRXZlbnRSZWRyYXc8UG9pbnRlckV2ZW50PikgPT4ge1xuXHRcdFx0XHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3dpdGNoTmF2VHlwZShQcmltYXJ5TmF2aWdhdGlvblR5cGUuTW91c2UpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGNhbiBiZSBcInRvdWNoXCIgb3IgXCJwZW5cIiwgdHJlYXQgdGhlbSB0aGUgc2FtZSBmb3Igbm93XG5cdFx0XHRcdFx0XHR0aGlzLnN3aXRjaE5hdlR5cGUoUHJpbWFyeU5hdmlnYXRpb25UeXBlLlRvdWNoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9ua2V5dXA6IChlOiBFdmVudFJlZHJhdzxLZXlib2FyZEV2ZW50PikgPT4ge1xuXHRcdFx0XHRcdC8vIHRhYiBrZXkgY2FuIGJlIHByZXNzZWQgaW4gc29tZSBvdGhlciBzaXR1YXRpb25zIGUuZy4gZWRpdG9yIGJ1dCBpdCB3b3VsZCBiZSBzd2l0Y2hlZCBiYWNrIHF1aWNrbHkgYWdhaW4gaWYgbmVlZGVkLlxuXHRcdFx0XHRcdGlmIChpc0tleVByZXNzZWQoZS5rZXksIEtleXMuVEFCLCBLZXlzLlVQLCBLZXlzLkRPV04sIEtleXMuSiwgS2V5cy5LKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zd2l0Y2hOYXZUeXBlKFByaW1hcnlOYXZpZ2F0aW9uVHlwZS5LZXlib2FyZClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBTZWUgc3R5bGVzIGZvciB1c2FnZXMgb2YgdGhlc2UgY2xhc3Nlcy5cblx0XHRcdFx0Ly8gV2UgYmFzaWNhbGx5IHVzZSB0aGVtIGluIGNzcyBjb21iaW5hdG9ycyBhcyBhIHF1ZXJ5IGZvciB3aGVuIHRvIHNob3cgY2VydGFpbiBpbnRlcmFjdGlvbiBpbmRpY2F0b3JzLlxuXHRcdFx0XHRjbGFzczogdGhpcy5jbGFzc0ZvclR5cGUoKSxcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRoZWlnaHQ6IFwiMTAwJVwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHRcdFttKG92ZXJsYXkpLCBtKG1vZGFsKSwgdm5vZGUuY2hpbGRyZW5dLFxuXHRcdClcblx0fVxuXG5cdHByaXZhdGUgc3dpdGNoTmF2VHlwZShuZXdUeXBlOiBQcmltYXJ5TmF2aWdhdGlvblR5cGUpIHtcblx0XHRpZiAoY3VycmVudE5hdmlnYXRpb25UeXBlID09PSBuZXdUeXBlKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dGhpcy5kb20/LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc0ZvclR5cGUoKSlcblx0XHRjdXJyZW50TmF2aWdhdGlvblR5cGUgPSBuZXdUeXBlXG5cdFx0dGhpcy5kb20/LmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc0ZvclR5cGUoKSlcblx0fVxuXG5cdHByaXZhdGUgY2xhc3NGb3JUeXBlKCkge1xuXHRcdHN3aXRjaCAoY3VycmVudE5hdmlnYXRpb25UeXBlKSB7XG5cdFx0XHRjYXNlIFByaW1hcnlOYXZpZ2F0aW9uVHlwZS5LZXlib2FyZDpcblx0XHRcdFx0cmV0dXJuIFwia2V5Ym9hcmQtbmF2XCJcblx0XHRcdGNhc2UgUHJpbWFyeU5hdmlnYXRpb25UeXBlLk1vdXNlOlxuXHRcdFx0XHRyZXR1cm4gXCJtb3VzZS1uYXZcIlxuXHRcdFx0Y2FzZSBQcmltYXJ5TmF2aWdhdGlvblR5cGUuVG91Y2g6XG5cdFx0XHRcdHJldHVybiBcInRvdWNoLW5hdlwiXG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBjb25zdCByb290OiBSb290VmlldyA9IG5ldyBSb290VmlldygpXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVVBLHNCQUFzQjtJQVFoQixRQUFOLE1BQWlDO0NBQ2hDO0NBQ0EsQUFBUTtDQUNSO0NBQ0E7Q0FDQTtDQUNBLEFBQVE7Q0FDUixBQUFpQix1QkFBdUIsQ0FBQ0EsTUFBYSxLQUFLLFNBQVMsRUFBRTtDQUV0RSxjQUFjO0FBQ2IsT0FBSyxhQUFhO0FBQ2xCLE9BQUssYUFBYSxDQUFFO0FBQ3BCLE9BQUssVUFBVTtBQUNmLE9BQUssa0JBQWtCO0FBQ3ZCLE9BQUssb0JBQW9CLENBQUU7QUFFM0IsT0FBSyxPQUFPLE1BQWdCO0FBQzNCLFVBQU8sZ0JBQ04sd0JBQ0E7SUFDQyxVQUFVLENBQUMsTUFBTSxDQUtoQjtJQUNELE9BQU87S0FDTixXQUFXLFVBQVU7S0FDckIsU0FBUyxLQUFLLFVBQVUsS0FBSztJQUM3QjtHQUNELEdBQ0QsS0FBSyxXQUFXLElBQUksQ0FBQyxTQUFTLEdBQUcsVUFBVTtBQUMxQyxXQUFPLGdCQUNOLGtCQUNBO0tBQ0MsS0FBSyxRQUFRO0tBQ2IsVUFBVSxDQUFDLFVBQVU7QUFJcEIsV0FBSyxVQUFV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