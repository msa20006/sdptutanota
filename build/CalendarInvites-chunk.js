import { assert, assertNotNull, clone, filterInt, noOp } from "./dist2-chunk.js";
import { lang } from "./LanguageViewModel-chunk.js";
import { CalendarAttendeeStatus, CalendarMethod, ConversationType, FeatureType, getAsEnumValue } from "./TutanotaConstants-chunk.js";
import { findAttendeeInAddresses } from "./CommonCalendarUtils-chunk.js";
import { findFirstPrivateCalendar } from "./CalendarUtils-chunk.js";
import { Dialog } from "./Dialog-chunk.js";
import { locator } from "./CommonLocator-chunk.js";
import { UserError } from "./UserError-chunk.js";
import { RecipientField } from "./SharedMailUtils-chunk.js";
import { ResolveMode } from "./RecipientsModel-chunk.js";
import { CalendarNotificationModel, EventType, getEventType } from "./CalendarGuiUtils-chunk.js";
import { parseCalendarFile } from "./CalendarImporter-chunk.js";
import { isCustomizationEnabledForCustomer } from "./CustomerUtils-chunk.js";

//#region src/calendar-app/calendar/view/CalendarInvites.ts
async function getParsedEvent(fileData) {
	try {
		const { contents, method } = await parseCalendarFile(fileData);
		const uid = contents[0].event.uid;
		if (uid == null) return null;
		assert(!contents.some((c) => c.event.uid !== uid), "received invite with multiple events, but mismatched UIDs");
		return {
			events: contents.map((c) => c.event),
			uid,
			method: getAsEnumValue(CalendarMethod, method) || CalendarMethod.PUBLISH
		};
	} catch (e) {
		console.log(e);
		return null;
	}
}
async function showEventDetails(event, eventBubbleRect, mail) {
	const [latestEvent, { CalendarEventPopup }, { CalendarEventPreviewViewModel }, { htmlSanitizer }] = await Promise.all([
		getLatestEvent(event),
		import("./CalendarEventPopup2-chunk.js"),
		import("./CalendarEventPreviewViewModel-chunk.js"),
		import("./HtmlSanitizer2-chunk.js")
	]);
	let eventType;
	let editModelsFactory;
	let hasBusinessFeature;
	let ownAttendee = null;
	const lazyIndexEntry = async () => latestEvent.uid != null ? locator.calendarFacade.getEventsByUid(latestEvent.uid) : null;
	if (!locator.logins.getUserController().isInternalUser()) {
		eventType = EventType.EXTERNAL;
		editModelsFactory = () => new Promise(noOp);
		hasBusinessFeature = false;
	} else {
		const [calendarInfos, mailboxDetails, customer] = await Promise.all([
			(await locator.calendarModel()).getCalendarInfos(),
			locator.mailboxModel.getUserMailboxDetails(),
			locator.logins.getUserController().loadCustomer()
		]);
		const mailboxProperties = await locator.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot);
		const ownMailAddresses = mailboxProperties.mailAddressProperties.map(({ mailAddress }) => mailAddress);
		ownAttendee = findAttendeeInAddresses(latestEvent.attendees, ownMailAddresses);
		eventType = getEventType(latestEvent, calendarInfos, ownMailAddresses, locator.logins.getUserController());
		editModelsFactory = (mode) => locator.calendarEventModel(mode, latestEvent, mailboxDetails, mailboxProperties, mail);
		hasBusinessFeature = isCustomizationEnabledForCustomer(customer, FeatureType.BusinessFeatureEnabled) || await locator.logins.getUserController().isNewPaidPlan();
	}
	const viewModel = new CalendarEventPreviewViewModel(latestEvent, await locator.calendarModel(), eventType, hasBusinessFeature, ownAttendee, lazyIndexEntry, editModelsFactory);
	new CalendarEventPopup(viewModel, eventBubbleRect, htmlSanitizer).show();
}
async function getEventsFromFile(file, invitedConfidentially) {
	const dataFile = await locator.fileController.getAsDataFile(file);
	const contents = await getParsedEvent(dataFile);
	for (const event of contents?.events ?? []) event.invitedConfidentially = invitedConfidentially;
	return contents;
}
async function getLatestEvent(event) {
	const uid = event.uid;
	if (uid == null) return event;
	const existingEvents = await locator.calendarFacade.getEventsByUid(uid);
	const existingEvent = event.recurrenceId == null ? existingEvents?.progenitor : existingEvents?.alteredInstances.find((e) => e.recurrenceId === event.recurrenceId);
	if (existingEvent == null) return event;
	if (filterInt(existingEvent.sequence) < filterInt(event.sequence)) {
		const calendarModel = await locator.calendarModel();
		return await calendarModel.updateEventWithExternal(existingEvent, event);
	} else return existingEvent;
}
let ReplyResult = function(ReplyResult$1) {
	ReplyResult$1[ReplyResult$1["ReplyNotSent"] = 0] = "ReplyNotSent";
	ReplyResult$1[ReplyResult$1["ReplySent"] = 1] = "ReplySent";
	return ReplyResult$1;
}({});
var CalendarInviteHandler = class {
	constructor(mailboxModel, calendarModel, logins, calendarNotificationSender, sendMailModelFactory) {
		this.mailboxModel = mailboxModel;
		this.calendarModel = calendarModel;
		this.logins = logins;
		this.calendarNotificationSender = calendarNotificationSender;
		this.sendMailModelFactory = sendMailModelFactory;
	}
	/**
	* Sends a quick reply for the given event and saves the event to the first private calendar.
	* @param event the CalendarEvent to respond to, will be serialized and sent back with updated status, then saved.
	* @param attendee the attendee that should respond to the mail
	* @param decision the new status of the attendee
	* @param previousMail the mail to respond to
	*/
	async replyToEventInvitation(event, attendee, decision, previousMail, mailboxDetails) {
		const eventClone = clone(event);
		const foundAttendee = assertNotNull(findAttendeeInAddresses(eventClone.attendees, [attendee.address.address]), "attendee was not found in event clone");
		foundAttendee.status = decision;
		const notificationModel = new CalendarNotificationModel(this.calendarNotificationSender, this.logins);
		const responseModel = await this.getResponseModelForMail(previousMail, mailboxDetails, attendee.address.address);
		try {
			await notificationModel.send(eventClone, [], {
				responseModel,
				inviteModel: null,
				cancelModel: null,
				updateModel: null
			});
		} catch (e) {
			if (e instanceof UserError) {
				await Dialog.message(lang.makeTranslation("confirm_msg", e.message));
				return ReplyResult.ReplyNotSent;
			} else throw e;
		}
		const calendars = await this.calendarModel.getCalendarInfos();
		const type = getEventType(event, calendars, [attendee.address.address], this.logins.getUserController());
		if (type === EventType.SHARED_RO || type === EventType.LOCKED) return ReplyResult.ReplySent;
		const calendar = findFirstPrivateCalendar(calendars);
		if (calendar == null) return ReplyResult.ReplyNotSent;
		if (decision !== CalendarAttendeeStatus.DECLINED && eventClone.uid != null) {
			const dbEvents = await this.calendarModel.getEventsByUid(eventClone.uid);
			await this.calendarModel.processCalendarEventMessage(previousMail.sender.address, CalendarMethod.REQUEST, eventClone, [], dbEvents ?? {
				ownerGroup: calendar.group._id,
				progenitor: null,
				alteredInstances: []
			});
		}
		return ReplyResult.ReplySent;
	}
	async getResponseModelForMail(previousMail, mailboxDetails, responder) {
		const mailboxProperties = await this.mailboxModel.getMailboxProperties(mailboxDetails.mailboxGroupRoot);
		const model = await this.sendMailModelFactory(mailboxDetails, mailboxProperties);
		await model.initAsResponse({
			previousMail,
			conversationType: ConversationType.REPLY,
			senderMailAddress: responder,
			recipients: [],
			attachments: [],
			subject: "",
			bodyText: "",
			replyTos: []
		}, new Map());
		await model.addRecipient(RecipientField.TO, previousMail.sender, ResolveMode.Eager);
		model.setConfidential(previousMail.confidential);
		return model;
	}
};

//#endregion
export { CalendarInviteHandler, ReplyResult, getEventsFromFile, getLatestEvent, showEventDetails };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJJbnZpdGVzLWNodW5rLmpzIiwibmFtZXMiOlsiZmlsZURhdGE6IERhdGFGaWxlIiwiZXZlbnQ6IENhbGVuZGFyRXZlbnQiLCJldmVudEJ1YmJsZVJlY3Q6IENsaWVudFJlY3QiLCJtYWlsOiBNYWlsIHwgbnVsbCIsImV2ZW50VHlwZTogRXZlbnRUeXBlIiwiZWRpdE1vZGVsc0ZhY3Rvcnk6IChtb2RlOiBDYWxlbmRhck9wZXJhdGlvbikgPT4gUHJvbWlzZTxDYWxlbmRhckV2ZW50TW9kZWwgfCBudWxsPiIsImhhc0J1c2luZXNzRmVhdHVyZTogYm9vbGVhbiIsIm93bkF0dGVuZGVlOiBDYWxlbmRhckV2ZW50QXR0ZW5kZWUgfCBudWxsIiwibW9kZTogQ2FsZW5kYXJPcGVyYXRpb24iLCJmaWxlOiBUdXRhbm90YUZpbGUiLCJpbnZpdGVkQ29uZmlkZW50aWFsbHk6IGJvb2xlYW4iLCJtYWlsYm94TW9kZWw6IE1haWxib3hNb2RlbCIsImNhbGVuZGFyTW9kZWw6IENhbGVuZGFyTW9kZWwiLCJsb2dpbnM6IExvZ2luQ29udHJvbGxlciIsImNhbGVuZGFyTm90aWZpY2F0aW9uU2VuZGVyOiBDYWxlbmRhck5vdGlmaWNhdGlvblNlbmRlciIsInNlbmRNYWlsTW9kZWxGYWN0b3J5OiAobWFpbGJveERldGFpbHM6IE1haWxib3hEZXRhaWwsIG1haWxib3hQcm9wZXJ0aWVzOiBNYWlsYm94UHJvcGVydGllcykgPT4gUHJvbWlzZTxTZW5kTWFpbE1vZGVsPiIsImF0dGVuZGVlOiBDYWxlbmRhckV2ZW50QXR0ZW5kZWUiLCJkZWNpc2lvbjogQ2FsZW5kYXJBdHRlbmRlZVN0YXR1cyIsInByZXZpb3VzTWFpbDogTWFpbCIsIm1haWxib3hEZXRhaWxzOiBNYWlsYm94RGV0YWlsIiwicmVzcG9uZGVyOiBzdHJpbmciXSwic291cmNlcyI6WyIuLi9zcmMvY2FsZW5kYXItYXBwL2NhbGVuZGFyL3ZpZXcvQ2FsZW5kYXJJbnZpdGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlQ2FsZW5kYXJGaWxlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9jYWxlbmRhci9pbXBvcnQvQ2FsZW5kYXJJbXBvcnRlci5qc1wiXG5pbXBvcnQgdHlwZSB7IENhbGVuZGFyRXZlbnQsIENhbGVuZGFyRXZlbnRBdHRlbmRlZSwgRmlsZSBhcyBUdXRhbm90YUZpbGUsIE1haWwsIE1haWxib3hQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvZW50aXRpZXMvdHV0YW5vdGEvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgbG9jYXRvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL21haW4vQ29tbW9uTG9jYXRvci5qc1wiXG5pbXBvcnQgeyBDYWxlbmRhckF0dGVuZGVlU3RhdHVzLCBDYWxlbmRhck1ldGhvZCwgQ29udmVyc2F0aW9uVHlwZSwgRmVhdHVyZVR5cGUsIGdldEFzRW51bVZhbHVlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL1R1dGFub3RhQ29uc3RhbnRzLmpzXCJcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0Tm90TnVsbCwgY2xvbmUsIGZpbHRlckludCwgbm9PcCwgUmVxdWlyZSB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgZmluZEZpcnN0UHJpdmF0ZUNhbGVuZGFyIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9jYWxlbmRhci9kYXRlL0NhbGVuZGFyVXRpbHMuanNcIlxuaW1wb3J0IHsgQ2FsZW5kYXJOb3RpZmljYXRpb25TZW5kZXIgfSBmcm9tIFwiLi9DYWxlbmRhck5vdGlmaWNhdGlvblNlbmRlci5qc1wiXG5pbXBvcnQgeyBEaWFsb2cgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2d1aS9iYXNlL0RpYWxvZy5qc1wiXG5pbXBvcnQgeyBVc2VyRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9tYWluL1VzZXJFcnJvci5qc1wiXG5pbXBvcnQgeyBEYXRhRmlsZSB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL2NvbW1vbi9EYXRhRmlsZS5qc1wiXG5pbXBvcnQgeyBmaW5kQXR0ZW5kZWVJbkFkZHJlc3NlcyB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL2NvbW1vbi91dGlscy9Db21tb25DYWxlbmRhclV0aWxzLmpzXCJcbmltcG9ydCB7IFJlY2lwaWVudCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL2NvbW1vbi9yZWNpcGllbnRzL1JlY2lwaWVudC5qc1wiXG5pbXBvcnQgeyBDYWxlbmRhckV2ZW50TW9kZWwsIENhbGVuZGFyT3BlcmF0aW9uLCBFdmVudFR5cGUgfSBmcm9tIFwiLi4vZ3VpL2V2ZW50ZWRpdG9yLW1vZGVsL0NhbGVuZGFyRXZlbnRNb2RlbC5qc1wiXG5pbXBvcnQgeyBDYWxlbmRhck5vdGlmaWNhdGlvbk1vZGVsIH0gZnJvbSBcIi4uL2d1aS9ldmVudGVkaXRvci1tb2RlbC9DYWxlbmRhck5vdGlmaWNhdGlvbk1vZGVsLmpzXCJcbmltcG9ydCB7IFJlc29sdmVNb2RlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvbWFpbi9SZWNpcGllbnRzTW9kZWwuanNcIlxuaW1wb3J0IHsgaXNDdXN0b21pemF0aW9uRW5hYmxlZEZvckN1c3RvbWVyIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL3V0aWxzL0N1c3RvbWVyVXRpbHMuanNcIlxuaW1wb3J0IHsgZ2V0RXZlbnRUeXBlIH0gZnJvbSBcIi4uL2d1aS9DYWxlbmRhckd1aVV0aWxzLmpzXCJcbmltcG9ydCB7IENhbGVuZGFyTW9kZWwgfSBmcm9tIFwiLi4vbW9kZWwvQ2FsZW5kYXJNb2RlbC5qc1wiXG5pbXBvcnQgeyBMb2dpbkNvbnRyb2xsZXIgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9tYWluL0xvZ2luQ29udHJvbGxlci5qc1wiXG5pbXBvcnQgdHlwZSB7IE1haWxib3hEZXRhaWwsIE1haWxib3hNb2RlbCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vbWFpbEZ1bmN0aW9uYWxpdHkvTWFpbGJveE1vZGVsLmpzXCJcbmltcG9ydCB7IFNlbmRNYWlsTW9kZWwgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL21haWxGdW5jdGlvbmFsaXR5L1NlbmRNYWlsTW9kZWwuanNcIlxuaW1wb3J0IHsgUmVjaXBpZW50RmllbGQgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL21haWxGdW5jdGlvbmFsaXR5L1NoYXJlZE1haWxVdGlscy5qc1wiXG5pbXBvcnQgeyBsYW5nIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9taXNjL0xhbmd1YWdlVmlld01vZGVsLmpzXCJcblxuLy8gbm90IHBpY2tpbmcgdGhlIHN0YXR1cyBkaXJlY3RseSBmcm9tIENhbGVuZGFyRXZlbnRBdHRlbmRlZSBiZWNhdXNlIGl0J3MgYSBOdW1iZXJTdHJpbmdcbmV4cG9ydCB0eXBlIEd1ZXN0ID0gUmVjaXBpZW50ICYgeyBzdGF0dXM6IENhbGVuZGFyQXR0ZW5kZWVTdGF0dXMgfVxuXG5leHBvcnQgdHlwZSBQYXJzZWRJY2FsRmlsZUNvbnRlbnQgPVxuXHR8IHtcblx0XHRcdG1ldGhvZDogQ2FsZW5kYXJNZXRob2Rcblx0XHRcdGV2ZW50czogQXJyYXk8Q2FsZW5kYXJFdmVudD5cblx0XHRcdHVpZDogc3RyaW5nXG5cdCAgfVxuXHR8IE5vbmVcblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGFyc2VkRXZlbnQoZmlsZURhdGE6IERhdGFGaWxlKTogUHJvbWlzZTxQYXJzZWRJY2FsRmlsZUNvbnRlbnQ+IHtcblx0dHJ5IHtcblx0XHRjb25zdCB7IGNvbnRlbnRzLCBtZXRob2QgfSA9IGF3YWl0IHBhcnNlQ2FsZW5kYXJGaWxlKGZpbGVEYXRhKVxuXHRcdGNvbnN0IHVpZCA9IGNvbnRlbnRzWzBdLmV2ZW50LnVpZFxuXHRcdGlmICh1aWQgPT0gbnVsbCkgcmV0dXJuIG51bGxcblx0XHRhc3NlcnQoIWNvbnRlbnRzLnNvbWUoKGMpID0+IGMuZXZlbnQudWlkICE9PSB1aWQpLCBcInJlY2VpdmVkIGludml0ZSB3aXRoIG11bHRpcGxlIGV2ZW50cywgYnV0IG1pc21hdGNoZWQgVUlEc1wiKVxuXHRcdHJldHVybiB7XG5cdFx0XHRldmVudHM6IGNvbnRlbnRzLm1hcCgoYykgPT4gYy5ldmVudCksXG5cdFx0XHR1aWQsXG5cdFx0XHRtZXRob2Q6IGdldEFzRW51bVZhbHVlKENhbGVuZGFyTWV0aG9kLCBtZXRob2QpIHx8IENhbGVuZGFyTWV0aG9kLlBVQkxJU0gsXG5cdFx0fVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0Y29uc29sZS5sb2coZSlcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaG93RXZlbnREZXRhaWxzKGV2ZW50OiBDYWxlbmRhckV2ZW50LCBldmVudEJ1YmJsZVJlY3Q6IENsaWVudFJlY3QsIG1haWw6IE1haWwgfCBudWxsKTogUHJvbWlzZTx2b2lkPiB7XG5cdGNvbnN0IFtsYXRlc3RFdmVudCwgeyBDYWxlbmRhckV2ZW50UG9wdXAgfSwgeyBDYWxlbmRhckV2ZW50UHJldmlld1ZpZXdNb2RlbCB9LCB7IGh0bWxTYW5pdGl6ZXIgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG5cdFx0Z2V0TGF0ZXN0RXZlbnQoZXZlbnQpLFxuXHRcdGltcG9ydChcIi4uL2d1aS9ldmVudHBvcHVwL0NhbGVuZGFyRXZlbnRQb3B1cC5qc1wiKSxcblx0XHRpbXBvcnQoXCIuLi9ndWkvZXZlbnRwb3B1cC9DYWxlbmRhckV2ZW50UHJldmlld1ZpZXdNb2RlbC5qc1wiKSxcblx0XHRpbXBvcnQoXCIuLi8uLi8uLi9jb21tb24vbWlzYy9IdG1sU2FuaXRpemVyLmpzXCIpLFxuXHRdKVxuXG5cdGxldCBldmVudFR5cGU6IEV2ZW50VHlwZVxuXHRsZXQgZWRpdE1vZGVsc0ZhY3Rvcnk6IChtb2RlOiBDYWxlbmRhck9wZXJhdGlvbikgPT4gUHJvbWlzZTxDYWxlbmRhckV2ZW50TW9kZWwgfCBudWxsPlxuXHRsZXQgaGFzQnVzaW5lc3NGZWF0dXJlOiBib29sZWFuXG5cdGxldCBvd25BdHRlbmRlZTogQ2FsZW5kYXJFdmVudEF0dGVuZGVlIHwgbnVsbCA9IG51bGxcblx0Y29uc3QgbGF6eUluZGV4RW50cnkgPSBhc3luYyAoKSA9PiAobGF0ZXN0RXZlbnQudWlkICE9IG51bGwgPyBsb2NhdG9yLmNhbGVuZGFyRmFjYWRlLmdldEV2ZW50c0J5VWlkKGxhdGVzdEV2ZW50LnVpZCkgOiBudWxsKVxuXHRpZiAoIWxvY2F0b3IubG9naW5zLmdldFVzZXJDb250cm9sbGVyKCkuaXNJbnRlcm5hbFVzZXIoKSkge1xuXHRcdC8vIGV4dGVybmFsIHVzZXJzIGNhbm5vdCBkZWxldGUvZWRpdCBldmVudHMgYXMgdGhleSBoYXZlIG5vIGNhbGVuZGFyLlxuXHRcdGV2ZW50VHlwZSA9IEV2ZW50VHlwZS5FWFRFUk5BTFxuXHRcdGVkaXRNb2RlbHNGYWN0b3J5ID0gKCkgPT4gbmV3IFByb21pc2Uobm9PcClcblx0XHRoYXNCdXNpbmVzc0ZlYXR1cmUgPSBmYWxzZVxuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IFtjYWxlbmRhckluZm9zLCBtYWlsYm94RGV0YWlscywgY3VzdG9tZXJdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuXHRcdFx0KGF3YWl0IGxvY2F0b3IuY2FsZW5kYXJNb2RlbCgpKS5nZXRDYWxlbmRhckluZm9zKCksXG5cdFx0XHRsb2NhdG9yLm1haWxib3hNb2RlbC5nZXRVc2VyTWFpbGJveERldGFpbHMoKSxcblx0XHRcdGxvY2F0b3IubG9naW5zLmdldFVzZXJDb250cm9sbGVyKCkubG9hZEN1c3RvbWVyKCksXG5cdFx0XSlcblx0XHRjb25zdCBtYWlsYm94UHJvcGVydGllcyA9IGF3YWl0IGxvY2F0b3IubWFpbGJveE1vZGVsLmdldE1haWxib3hQcm9wZXJ0aWVzKG1haWxib3hEZXRhaWxzLm1haWxib3hHcm91cFJvb3QpXG5cdFx0Y29uc3Qgb3duTWFpbEFkZHJlc3NlcyA9IG1haWxib3hQcm9wZXJ0aWVzLm1haWxBZGRyZXNzUHJvcGVydGllcy5tYXAoKHsgbWFpbEFkZHJlc3MgfSkgPT4gbWFpbEFkZHJlc3MpXG5cdFx0b3duQXR0ZW5kZWUgPSBmaW5kQXR0ZW5kZWVJbkFkZHJlc3NlcyhsYXRlc3RFdmVudC5hdHRlbmRlZXMsIG93bk1haWxBZGRyZXNzZXMpXG5cdFx0ZXZlbnRUeXBlID0gZ2V0RXZlbnRUeXBlKGxhdGVzdEV2ZW50LCBjYWxlbmRhckluZm9zLCBvd25NYWlsQWRkcmVzc2VzLCBsb2NhdG9yLmxvZ2lucy5nZXRVc2VyQ29udHJvbGxlcigpKVxuXHRcdGVkaXRNb2RlbHNGYWN0b3J5ID0gKG1vZGU6IENhbGVuZGFyT3BlcmF0aW9uKSA9PiBsb2NhdG9yLmNhbGVuZGFyRXZlbnRNb2RlbChtb2RlLCBsYXRlc3RFdmVudCwgbWFpbGJveERldGFpbHMsIG1haWxib3hQcm9wZXJ0aWVzLCBtYWlsKVxuXHRcdGhhc0J1c2luZXNzRmVhdHVyZSA9XG5cdFx0XHRpc0N1c3RvbWl6YXRpb25FbmFibGVkRm9yQ3VzdG9tZXIoY3VzdG9tZXIsIEZlYXR1cmVUeXBlLkJ1c2luZXNzRmVhdHVyZUVuYWJsZWQpIHx8IChhd2FpdCBsb2NhdG9yLmxvZ2lucy5nZXRVc2VyQ29udHJvbGxlcigpLmlzTmV3UGFpZFBsYW4oKSlcblx0fVxuXG5cdGNvbnN0IHZpZXdNb2RlbCA9IG5ldyBDYWxlbmRhckV2ZW50UHJldmlld1ZpZXdNb2RlbChcblx0XHRsYXRlc3RFdmVudCxcblx0XHRhd2FpdCBsb2NhdG9yLmNhbGVuZGFyTW9kZWwoKSxcblx0XHRldmVudFR5cGUsXG5cdFx0aGFzQnVzaW5lc3NGZWF0dXJlLFxuXHRcdG93bkF0dGVuZGVlLFxuXHRcdGxhenlJbmRleEVudHJ5LFxuXHRcdGVkaXRNb2RlbHNGYWN0b3J5LFxuXHQpXG5cdG5ldyBDYWxlbmRhckV2ZW50UG9wdXAodmlld01vZGVsLCBldmVudEJ1YmJsZVJlY3QsIGh0bWxTYW5pdGl6ZXIpLnNob3coKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRzRnJvbUZpbGUoZmlsZTogVHV0YW5vdGFGaWxlLCBpbnZpdGVkQ29uZmlkZW50aWFsbHk6IGJvb2xlYW4pOiBQcm9taXNlPFBhcnNlZEljYWxGaWxlQ29udGVudD4ge1xuXHRjb25zdCBkYXRhRmlsZSA9IGF3YWl0IGxvY2F0b3IuZmlsZUNvbnRyb2xsZXIuZ2V0QXNEYXRhRmlsZShmaWxlKVxuXHRjb25zdCBjb250ZW50cyA9IGF3YWl0IGdldFBhcnNlZEV2ZW50KGRhdGFGaWxlKVxuXHRmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRlbnRzPy5ldmVudHMgPz8gW10pIHtcblx0XHRldmVudC5pbnZpdGVkQ29uZmlkZW50aWFsbHkgPSBpbnZpdGVkQ29uZmlkZW50aWFsbHlcblx0fVxuXHRyZXR1cm4gY29udGVudHNcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXRlc3QgdmVyc2lvbiBmb3IgdGhlIGdpdmVuIGV2ZW50IGJ5IHVpZCBhbmQgcmVjdXJyZW5jZUlkLiBJZiB0aGUgZXZlbnQgaXMgbm90IGluXG4gKiBhbnkgY2FsZW5kYXIgKGJlY2F1c2UgaXQgaGFzIG5vdCBiZWVuIHN0b3JlZCB5ZXQsIGUuZy4gaW4gY2FzZSBvZiBpbnZpdGUpXG4gKiB0aGUgZ2l2ZW4gZXZlbnQgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMYXRlc3RFdmVudChldmVudDogQ2FsZW5kYXJFdmVudCk6IFByb21pc2U8Q2FsZW5kYXJFdmVudD4ge1xuXHRjb25zdCB1aWQgPSBldmVudC51aWRcblx0aWYgKHVpZCA9PSBudWxsKSByZXR1cm4gZXZlbnRcblx0Y29uc3QgZXhpc3RpbmdFdmVudHMgPSBhd2FpdCBsb2NhdG9yLmNhbGVuZGFyRmFjYWRlLmdldEV2ZW50c0J5VWlkKHVpZClcblxuXHQvLyBJZiB0aGUgZmlsZSB3ZSBhcmUgb3BlbmluZyBpcyBuZXdlciB0aGFuIHRoZSBvbmUgd2hpY2ggd2UgaGF2ZSBvbiB0aGUgc2VydmVyLCB1cGRhdGUgc2VydmVyIHZlcnNpb24uXG5cdC8vIFNob3VsZCBub3QgaGFwcGVuIG5vcm1hbGx5IGJ1dCBjYW4gaGFwcGVuIHdoZW4gZS5nLiByZXBseSBhbmQgdXBkYXRlIHdlcmUgc2VudCBvbmUgYWZ0ZXIgYW5vdGhlciBiZWZvcmUgd2UgYWNjZXB0ZWRcblx0Ly8gdGhlIGludml0ZS4gVGhlbiBhY2NlcHRpbmcgZmlyc3QgaW52aXRlIGFuZCB0aGVuIG9wZW5pbmcgdXBkYXRlIHNob3VsZCBnaXZlIHVzIHVwZGF0ZWQgdmVyc2lvbi5cblx0Y29uc3QgZXhpc3RpbmdFdmVudCA9XG5cdFx0ZXZlbnQucmVjdXJyZW5jZUlkID09IG51bGxcblx0XHRcdD8gZXhpc3RpbmdFdmVudHM/LnByb2dlbml0b3IgLy8gdGhlIHByb2dlbml0b3IgZG9lcyBub3QgaGF2ZSBhIHJlY3VycmVuY2UgaWQgYW5kIGlzIGFsd2F5cyBmaXJzdCBpbiB1aWQgaW5kZXhcblx0XHRcdDogZXhpc3RpbmdFdmVudHM/LmFsdGVyZWRJbnN0YW5jZXMuZmluZCgoZSkgPT4gZS5yZWN1cnJlbmNlSWQgPT09IGV2ZW50LnJlY3VycmVuY2VJZClcblxuXHRpZiAoZXhpc3RpbmdFdmVudCA9PSBudWxsKSByZXR1cm4gZXZlbnRcblxuXHRpZiAoZmlsdGVySW50KGV4aXN0aW5nRXZlbnQuc2VxdWVuY2UpIDwgZmlsdGVySW50KGV2ZW50LnNlcXVlbmNlKSkge1xuXHRcdGNvbnN0IGNhbGVuZGFyTW9kZWwgPSBhd2FpdCBsb2NhdG9yLmNhbGVuZGFyTW9kZWwoKVxuXHRcdHJldHVybiBhd2FpdCBjYWxlbmRhck1vZGVsLnVwZGF0ZUV2ZW50V2l0aEV4dGVybmFsKGV4aXN0aW5nRXZlbnQsIGV2ZW50KVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBleGlzdGluZ0V2ZW50XG5cdH1cbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gUmVwbHlSZXN1bHQge1xuXHRSZXBseU5vdFNlbnQsXG5cdFJlcGx5U2VudCxcbn1cblxuZXhwb3J0IGNsYXNzIENhbGVuZGFySW52aXRlSGFuZGxlciB7XG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgbWFpbGJveE1vZGVsOiBNYWlsYm94TW9kZWwsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjYWxlbmRhck1vZGVsOiBDYWxlbmRhck1vZGVsLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgbG9naW5zOiBMb2dpbkNvbnRyb2xsZXIsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjYWxlbmRhck5vdGlmaWNhdGlvblNlbmRlcjogQ2FsZW5kYXJOb3RpZmljYXRpb25TZW5kZXIsXG5cdFx0cHJpdmF0ZSBzZW5kTWFpbE1vZGVsRmFjdG9yeTogKG1haWxib3hEZXRhaWxzOiBNYWlsYm94RGV0YWlsLCBtYWlsYm94UHJvcGVydGllczogTWFpbGJveFByb3BlcnRpZXMpID0+IFByb21pc2U8U2VuZE1haWxNb2RlbD4sXG5cdCkge31cblxuXHQvKipcblx0ICogU2VuZHMgYSBxdWljayByZXBseSBmb3IgdGhlIGdpdmVuIGV2ZW50IGFuZCBzYXZlcyB0aGUgZXZlbnQgdG8gdGhlIGZpcnN0IHByaXZhdGUgY2FsZW5kYXIuXG5cdCAqIEBwYXJhbSBldmVudCB0aGUgQ2FsZW5kYXJFdmVudCB0byByZXNwb25kIHRvLCB3aWxsIGJlIHNlcmlhbGl6ZWQgYW5kIHNlbnQgYmFjayB3aXRoIHVwZGF0ZWQgc3RhdHVzLCB0aGVuIHNhdmVkLlxuXHQgKiBAcGFyYW0gYXR0ZW5kZWUgdGhlIGF0dGVuZGVlIHRoYXQgc2hvdWxkIHJlc3BvbmQgdG8gdGhlIG1haWxcblx0ICogQHBhcmFtIGRlY2lzaW9uIHRoZSBuZXcgc3RhdHVzIG9mIHRoZSBhdHRlbmRlZVxuXHQgKiBAcGFyYW0gcHJldmlvdXNNYWlsIHRoZSBtYWlsIHRvIHJlc3BvbmQgdG9cblx0ICovXG5cdGFzeW5jIHJlcGx5VG9FdmVudEludml0YXRpb24oXG5cdFx0ZXZlbnQ6IENhbGVuZGFyRXZlbnQsXG5cdFx0YXR0ZW5kZWU6IENhbGVuZGFyRXZlbnRBdHRlbmRlZSxcblx0XHRkZWNpc2lvbjogQ2FsZW5kYXJBdHRlbmRlZVN0YXR1cyxcblx0XHRwcmV2aW91c01haWw6IE1haWwsXG5cdFx0bWFpbGJveERldGFpbHM6IE1haWxib3hEZXRhaWwsXG5cdCk6IFByb21pc2U8UmVwbHlSZXN1bHQ+IHtcblx0XHRjb25zdCBldmVudENsb25lID0gY2xvbmUoZXZlbnQpXG5cdFx0Y29uc3QgZm91bmRBdHRlbmRlZSA9IGFzc2VydE5vdE51bGwoZmluZEF0dGVuZGVlSW5BZGRyZXNzZXMoZXZlbnRDbG9uZS5hdHRlbmRlZXMsIFthdHRlbmRlZS5hZGRyZXNzLmFkZHJlc3NdKSwgXCJhdHRlbmRlZSB3YXMgbm90IGZvdW5kIGluIGV2ZW50IGNsb25lXCIpXG5cdFx0Zm91bmRBdHRlbmRlZS5zdGF0dXMgPSBkZWNpc2lvblxuXG5cdFx0Y29uc3Qgbm90aWZpY2F0aW9uTW9kZWwgPSBuZXcgQ2FsZW5kYXJOb3RpZmljYXRpb25Nb2RlbCh0aGlzLmNhbGVuZGFyTm90aWZpY2F0aW9uU2VuZGVyLCB0aGlzLmxvZ2lucylcblx0XHQvL05PVEU6IG1haWxEZXRhaWxzIGFyZSBnZXR0aW5nIHBhc3NlZCB0aHJvdWdoIGJlY2F1c2UgdGhlIGNhbGVuZGFyIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIHRoZSBtYWlsIGZvbGRlciBzdHJ1Y3R1cmVcblx0XHQvL1x0d2hpY2ggaXMgbmVlZGVkIHRvIGZpbmQgbWFpbGJveGRldGFpbHMgYnkgbWFpbC4gVGhpcyBtYXkgYmUgZml4ZWQgYnkgc3RhdGljIG1haWwgaWRzIHdoaWNoIGFyZSBiZWluZyB3b3JrZWQgb24gY3VycmVudGx5LlxuXHRcdC8vICBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGJ5IEV2ZW50QmFubmVyIGZyb20gdGhlIG1haWwgYXBwIHNvIHRoaXMgc2hvdWxkIGJlIG9rYXkuXG5cdFx0Y29uc3QgcmVzcG9uc2VNb2RlbCA9IGF3YWl0IHRoaXMuZ2V0UmVzcG9uc2VNb2RlbEZvck1haWwocHJldmlvdXNNYWlsLCBtYWlsYm94RGV0YWlscywgYXR0ZW5kZWUuYWRkcmVzcy5hZGRyZXNzKVxuXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IG5vdGlmaWNhdGlvbk1vZGVsLnNlbmQoZXZlbnRDbG9uZSwgW10sIHsgcmVzcG9uc2VNb2RlbCwgaW52aXRlTW9kZWw6IG51bGwsIGNhbmNlbE1vZGVsOiBudWxsLCB1cGRhdGVNb2RlbDogbnVsbCB9KVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlIGluc3RhbmNlb2YgVXNlckVycm9yKSB7XG5cdFx0XHRcdGF3YWl0IERpYWxvZy5tZXNzYWdlKGxhbmcubWFrZVRyYW5zbGF0aW9uKFwiY29uZmlybV9tc2dcIiwgZS5tZXNzYWdlKSlcblx0XHRcdFx0cmV0dXJuIFJlcGx5UmVzdWx0LlJlcGx5Tm90U2VudFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBjYWxlbmRhcnMgPSBhd2FpdCB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0Q2FsZW5kYXJJbmZvcygpXG5cdFx0Y29uc3QgdHlwZSA9IGdldEV2ZW50VHlwZShldmVudCwgY2FsZW5kYXJzLCBbYXR0ZW5kZWUuYWRkcmVzcy5hZGRyZXNzXSwgdGhpcy5sb2dpbnMuZ2V0VXNlckNvbnRyb2xsZXIoKSlcblx0XHRpZiAodHlwZSA9PT0gRXZlbnRUeXBlLlNIQVJFRF9STyB8fCB0eXBlID09PSBFdmVudFR5cGUuTE9DS0VEKSB7XG5cdFx0XHQvLyBpZiB0aGUgRXZlbnQgdHlwZSBpcyBzaGFyZWQgcmVhZCBvbmx5LCB0aGUgZXZlbnQgd2lsbCBiZSB1cGRhdGVkIGJ5IHRoZSByZXNwb25zZSwgdHJ5aW5nIHRvIHVwZGF0ZSB0aGUgY2FsZW5kYXIgaGVyZSB3aWxsIHJlc3VsdCBpbiBlcnJvclxuXHRcdFx0Ly8gc2luY2UgdGhlcmUgaXMgbm8gd3JpdGUgcGVybWlzc2lvbi4gKFNhbWUgaXNzdWUgY2FuIGhhcHBlbiB3aXRoIGxvY2tlZCwgbm8gd3JpdGUgcGVybWlzc2lvbilcblx0XHRcdHJldHVybiBSZXBseVJlc3VsdC5SZXBseVNlbnRcblx0XHR9XG5cdFx0Y29uc3QgY2FsZW5kYXIgPSBmaW5kRmlyc3RQcml2YXRlQ2FsZW5kYXIoY2FsZW5kYXJzKVxuXHRcdGlmIChjYWxlbmRhciA9PSBudWxsKSByZXR1cm4gUmVwbHlSZXN1bHQuUmVwbHlOb3RTZW50XG5cdFx0aWYgKGRlY2lzaW9uICE9PSBDYWxlbmRhckF0dGVuZGVlU3RhdHVzLkRFQ0xJTkVEICYmIGV2ZW50Q2xvbmUudWlkICE9IG51bGwpIHtcblx0XHRcdGNvbnN0IGRiRXZlbnRzID0gYXdhaXQgdGhpcy5jYWxlbmRhck1vZGVsLmdldEV2ZW50c0J5VWlkKGV2ZW50Q2xvbmUudWlkKVxuXHRcdFx0YXdhaXQgdGhpcy5jYWxlbmRhck1vZGVsLnByb2Nlc3NDYWxlbmRhckV2ZW50TWVzc2FnZShcblx0XHRcdFx0cHJldmlvdXNNYWlsLnNlbmRlci5hZGRyZXNzLFxuXHRcdFx0XHRDYWxlbmRhck1ldGhvZC5SRVFVRVNULFxuXHRcdFx0XHRldmVudENsb25lIGFzIFJlcXVpcmU8XCJ1aWRcIiwgQ2FsZW5kYXJFdmVudD4sXG5cdFx0XHRcdFtdLFxuXHRcdFx0XHRkYkV2ZW50cyA/PyB7IG93bmVyR3JvdXA6IGNhbGVuZGFyLmdyb3VwLl9pZCwgcHJvZ2VuaXRvcjogbnVsbCwgYWx0ZXJlZEluc3RhbmNlczogW10gfSxcblx0XHRcdClcblx0XHR9XG5cdFx0cmV0dXJuIFJlcGx5UmVzdWx0LlJlcGx5U2VudFxuXHR9XG5cblx0YXN5bmMgZ2V0UmVzcG9uc2VNb2RlbEZvck1haWwocHJldmlvdXNNYWlsOiBNYWlsLCBtYWlsYm94RGV0YWlsczogTWFpbGJveERldGFpbCwgcmVzcG9uZGVyOiBzdHJpbmcpOiBQcm9taXNlPFNlbmRNYWlsTW9kZWwgfCBudWxsPiB7XG5cdFx0Ly9OT1RFOiBtYWlsRGV0YWlscyBhcmUgZ2V0dGluZyBwYXNzZWQgdGhyb3VnaCBiZWNhdXNlIHRoZSBjYWxlbmRhciBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byB0aGUgbWFpbCBmb2xkZXIgc3RydWN0dXJlXG5cdFx0Ly9cdHdoaWNoIGlzIG5lZWRlZCB0byBmaW5kIG1haWxib3hkZXRhaWxzIGJ5IG1haWwuIFRoaXMgbWF5IGJlIGZpeGVkIGJ5IHN0YXRpYyBtYWlsIGlkcyB3aGljaCBhcmUgYmVpbmcgd29ya2VkIG9uIGN1cnJlbnRseVxuXHRcdGNvbnN0IG1haWxib3hQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy5tYWlsYm94TW9kZWwuZ2V0TWFpbGJveFByb3BlcnRpZXMobWFpbGJveERldGFpbHMubWFpbGJveEdyb3VwUm9vdClcblx0XHRjb25zdCBtb2RlbCA9IGF3YWl0IHRoaXMuc2VuZE1haWxNb2RlbEZhY3RvcnkobWFpbGJveERldGFpbHMsIG1haWxib3hQcm9wZXJ0aWVzKVxuXHRcdGF3YWl0IG1vZGVsLmluaXRBc1Jlc3BvbnNlKFxuXHRcdFx0e1xuXHRcdFx0XHRwcmV2aW91c01haWwsXG5cdFx0XHRcdGNvbnZlcnNhdGlvblR5cGU6IENvbnZlcnNhdGlvblR5cGUuUkVQTFksXG5cdFx0XHRcdHNlbmRlck1haWxBZGRyZXNzOiByZXNwb25kZXIsXG5cdFx0XHRcdHJlY2lwaWVudHM6IFtdLFxuXHRcdFx0XHRhdHRhY2htZW50czogW10sXG5cdFx0XHRcdHN1YmplY3Q6IFwiXCIsXG5cdFx0XHRcdGJvZHlUZXh0OiBcIlwiLFxuXHRcdFx0XHRyZXBseVRvczogW10sXG5cdFx0XHR9LFxuXHRcdFx0bmV3IE1hcCgpLFxuXHRcdClcblx0XHRhd2FpdCBtb2RlbC5hZGRSZWNpcGllbnQoUmVjaXBpZW50RmllbGQuVE8sIHByZXZpb3VzTWFpbC5zZW5kZXIsIFJlc29sdmVNb2RlLkVhZ2VyKVxuXHRcdC8vIFNlbmQgY29uZmlkZW50aWFsIHJlcGx5IHRvIGNvbmZpZGVudGlhbCBtYWlscyBhbmQgdGhlIG90aGVyIHdheSBhcm91bmQuXG5cdFx0Ly8gSWYgdGhlIGNvbnRhY3QgaXMgcmVtb3ZlZCBvciB0aGUgcGFzc3dvcmQgaXMgbm90IHRoZXJlIHRoZSB1c2VyIHdvdWxkIHNlZSBhbiBlcnJvciBidXQgdGhleSB3b3VsZG4ndCBiZVxuXHRcdC8vIGFibGUgdG8gcmVwbHkgYW55d2F5ICh1bmxlc3MgdGhleSBmaXggaXQpLlxuXHRcdG1vZGVsLnNldENvbmZpZGVudGlhbChwcmV2aW91c01haWwuY29uZmlkZW50aWFsKVxuXHRcdHJldHVybiBtb2RlbFxuXHR9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQW1DQSxlQUFlLGVBQWVBLFVBQW9EO0FBQ2pGLEtBQUk7RUFDSCxNQUFNLEVBQUUsVUFBVSxRQUFRLEdBQUcsTUFBTSxrQkFBa0IsU0FBUztFQUM5RCxNQUFNLE1BQU0sU0FBUyxHQUFHLE1BQU07QUFDOUIsTUFBSSxPQUFPLEtBQU0sUUFBTztBQUN4QixVQUFRLFNBQVMsS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLFFBQVEsSUFBSSxFQUFFLDREQUE0RDtBQUMvRyxTQUFPO0dBQ04sUUFBUSxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTTtHQUNwQztHQUNBLFFBQVEsZUFBZSxnQkFBZ0IsT0FBTyxJQUFJLGVBQWU7RUFDakU7Q0FDRCxTQUFRLEdBQUc7QUFDWCxVQUFRLElBQUksRUFBRTtBQUNkLFNBQU87Q0FDUDtBQUNEO0FBRU0sZUFBZSxpQkFBaUJDLE9BQXNCQyxpQkFBNkJDLE1BQWtDO0NBQzNILE1BQU0sQ0FBQyxhQUFhLEVBQUUsb0JBQW9CLEVBQUUsRUFBRSwrQkFBK0IsRUFBRSxFQUFFLGVBQWUsQ0FBQyxHQUFHLE1BQU0sUUFBUSxJQUFJO0VBQ3JILGVBQWUsTUFBTTtFQUNyQixPQUFPO0VBQ1AsT0FBTztFQUNQLE9BQU87Q0FDUCxFQUFDO0NBRUYsSUFBSUM7Q0FDSixJQUFJQztDQUNKLElBQUlDO0NBQ0osSUFBSUMsY0FBNEM7Q0FDaEQsTUFBTSxpQkFBaUIsWUFBYSxZQUFZLE9BQU8sT0FBTyxRQUFRLGVBQWUsZUFBZSxZQUFZLElBQUksR0FBRztBQUN2SCxNQUFLLFFBQVEsT0FBTyxtQkFBbUIsQ0FBQyxnQkFBZ0IsRUFBRTtBQUV6RCxjQUFZLFVBQVU7QUFDdEIsc0JBQW9CLE1BQU0sSUFBSSxRQUFRO0FBQ3RDLHVCQUFxQjtDQUNyQixPQUFNO0VBQ04sTUFBTSxDQUFDLGVBQWUsZ0JBQWdCLFNBQVMsR0FBRyxNQUFNLFFBQVEsSUFBSTtHQUNuRSxDQUFDLE1BQU0sUUFBUSxlQUFlLEVBQUUsa0JBQWtCO0dBQ2xELFFBQVEsYUFBYSx1QkFBdUI7R0FDNUMsUUFBUSxPQUFPLG1CQUFtQixDQUFDLGNBQWM7RUFDakQsRUFBQztFQUNGLE1BQU0sb0JBQW9CLE1BQU0sUUFBUSxhQUFhLHFCQUFxQixlQUFlLGlCQUFpQjtFQUMxRyxNQUFNLG1CQUFtQixrQkFBa0Isc0JBQXNCLElBQUksQ0FBQyxFQUFFLGFBQWEsS0FBSyxZQUFZO0FBQ3RHLGdCQUFjLHdCQUF3QixZQUFZLFdBQVcsaUJBQWlCO0FBQzlFLGNBQVksYUFBYSxhQUFhLGVBQWUsa0JBQWtCLFFBQVEsT0FBTyxtQkFBbUIsQ0FBQztBQUMxRyxzQkFBb0IsQ0FBQ0MsU0FBNEIsUUFBUSxtQkFBbUIsTUFBTSxhQUFhLGdCQUFnQixtQkFBbUIsS0FBSztBQUN2SSx1QkFDQyxrQ0FBa0MsVUFBVSxZQUFZLHVCQUF1QixJQUFLLE1BQU0sUUFBUSxPQUFPLG1CQUFtQixDQUFDLGVBQWU7Q0FDN0k7Q0FFRCxNQUFNLFlBQVksSUFBSSw4QkFDckIsYUFDQSxNQUFNLFFBQVEsZUFBZSxFQUM3QixXQUNBLG9CQUNBLGFBQ0EsZ0JBQ0E7QUFFRCxLQUFJLG1CQUFtQixXQUFXLGlCQUFpQixlQUFlLE1BQU07QUFDeEU7QUFFTSxlQUFlLGtCQUFrQkMsTUFBb0JDLHVCQUFnRTtDQUMzSCxNQUFNLFdBQVcsTUFBTSxRQUFRLGVBQWUsY0FBYyxLQUFLO0NBQ2pFLE1BQU0sV0FBVyxNQUFNLGVBQWUsU0FBUztBQUMvQyxNQUFLLE1BQU0sU0FBUyxVQUFVLFVBQVUsQ0FBRSxFQUN6QyxPQUFNLHdCQUF3QjtBQUUvQixRQUFPO0FBQ1A7QUFPTSxlQUFlLGVBQWVULE9BQThDO0NBQ2xGLE1BQU0sTUFBTSxNQUFNO0FBQ2xCLEtBQUksT0FBTyxLQUFNLFFBQU87Q0FDeEIsTUFBTSxpQkFBaUIsTUFBTSxRQUFRLGVBQWUsZUFBZSxJQUFJO0NBS3ZFLE1BQU0sZ0JBQ0wsTUFBTSxnQkFBZ0IsT0FDbkIsZ0JBQWdCLGFBQ2hCLGdCQUFnQixpQkFBaUIsS0FBSyxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsTUFBTSxhQUFhO0FBRXZGLEtBQUksaUJBQWlCLEtBQU0sUUFBTztBQUVsQyxLQUFJLFVBQVUsY0FBYyxTQUFTLEdBQUcsVUFBVSxNQUFNLFNBQVMsRUFBRTtFQUNsRSxNQUFNLGdCQUFnQixNQUFNLFFBQVEsZUFBZTtBQUNuRCxTQUFPLE1BQU0sY0FBYyx3QkFBd0IsZUFBZSxNQUFNO0NBQ3hFLE1BQ0EsUUFBTztBQUVSO0lBRWlCLHNDQUFYO0FBQ047QUFDQTs7QUFDQTtJQUVZLHdCQUFOLE1BQTRCO0NBQ2xDLFlBQ2tCVSxjQUNBQyxlQUNBQyxRQUNBQyw0QkFDVEMsc0JBQ1A7RUFvRkYsS0F6RmtCO0VBeUZqQixLQXhGaUI7RUF3RmhCLEtBdkZnQjtFQXVGZixLQXRGZTtFQXNGZCxLQXJGSztDQUNMOzs7Ozs7OztDQVNKLE1BQU0sdUJBQ0xkLE9BQ0FlLFVBQ0FDLFVBQ0FDLGNBQ0FDLGdCQUN1QjtFQUN2QixNQUFNLGFBQWEsTUFBTSxNQUFNO0VBQy9CLE1BQU0sZ0JBQWdCLGNBQWMsd0JBQXdCLFdBQVcsV0FBVyxDQUFDLFNBQVMsUUFBUSxPQUFRLEVBQUMsRUFBRSx3Q0FBd0M7QUFDdkosZ0JBQWMsU0FBUztFQUV2QixNQUFNLG9CQUFvQixJQUFJLDBCQUEwQixLQUFLLDRCQUE0QixLQUFLO0VBSTlGLE1BQU0sZ0JBQWdCLE1BQU0sS0FBSyx3QkFBd0IsY0FBYyxnQkFBZ0IsU0FBUyxRQUFRLFFBQVE7QUFFaEgsTUFBSTtBQUNILFNBQU0sa0JBQWtCLEtBQUssWUFBWSxDQUFFLEdBQUU7SUFBRTtJQUFlLGFBQWE7SUFBTSxhQUFhO0lBQU0sYUFBYTtHQUFNLEVBQUM7RUFDeEgsU0FBUSxHQUFHO0FBQ1gsT0FBSSxhQUFhLFdBQVc7QUFDM0IsVUFBTSxPQUFPLFFBQVEsS0FBSyxnQkFBZ0IsZUFBZSxFQUFFLFFBQVEsQ0FBQztBQUNwRSxXQUFPLFlBQVk7R0FDbkIsTUFDQSxPQUFNO0VBRVA7RUFDRCxNQUFNLFlBQVksTUFBTSxLQUFLLGNBQWMsa0JBQWtCO0VBQzdELE1BQU0sT0FBTyxhQUFhLE9BQU8sV0FBVyxDQUFDLFNBQVMsUUFBUSxPQUFRLEdBQUUsS0FBSyxPQUFPLG1CQUFtQixDQUFDO0FBQ3hHLE1BQUksU0FBUyxVQUFVLGFBQWEsU0FBUyxVQUFVLE9BR3RELFFBQU8sWUFBWTtFQUVwQixNQUFNLFdBQVcseUJBQXlCLFVBQVU7QUFDcEQsTUFBSSxZQUFZLEtBQU0sUUFBTyxZQUFZO0FBQ3pDLE1BQUksYUFBYSx1QkFBdUIsWUFBWSxXQUFXLE9BQU8sTUFBTTtHQUMzRSxNQUFNLFdBQVcsTUFBTSxLQUFLLGNBQWMsZUFBZSxXQUFXLElBQUk7QUFDeEUsU0FBTSxLQUFLLGNBQWMsNEJBQ3hCLGFBQWEsT0FBTyxTQUNwQixlQUFlLFNBQ2YsWUFDQSxDQUFFLEdBQ0YsWUFBWTtJQUFFLFlBQVksU0FBUyxNQUFNO0lBQUssWUFBWTtJQUFNLGtCQUFrQixDQUFFO0dBQUUsRUFDdEY7RUFDRDtBQUNELFNBQU8sWUFBWTtDQUNuQjtDQUVELE1BQU0sd0JBQXdCRCxjQUFvQkMsZ0JBQStCQyxXQUFrRDtFQUdsSSxNQUFNLG9CQUFvQixNQUFNLEtBQUssYUFBYSxxQkFBcUIsZUFBZSxpQkFBaUI7RUFDdkcsTUFBTSxRQUFRLE1BQU0sS0FBSyxxQkFBcUIsZ0JBQWdCLGtCQUFrQjtBQUNoRixRQUFNLE1BQU0sZUFDWDtHQUNDO0dBQ0Esa0JBQWtCLGlCQUFpQjtHQUNuQyxtQkFBbUI7R0FDbkIsWUFBWSxDQUFFO0dBQ2QsYUFBYSxDQUFFO0dBQ2YsU0FBUztHQUNULFVBQVU7R0FDVixVQUFVLENBQUU7RUFDWixHQUNELElBQUksTUFDSjtBQUNELFFBQU0sTUFBTSxhQUFhLGVBQWUsSUFBSSxhQUFhLFFBQVEsWUFBWSxNQUFNO0FBSW5GLFFBQU0sZ0JBQWdCLGFBQWEsYUFBYTtBQUNoRCxTQUFPO0NBQ1A7QUFDRCJ9