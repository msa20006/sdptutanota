import { assertWorkerOrNode, getApiBaseUrl, isAdminClient, isAndroidApp, isWebClient, isWorker } from "./Env-chunk.js";
import { assertNotNull, typedEntries, uint8ArrayToArrayBuffer } from "./dist2-chunk.js";
import { REQUEST_SIZE_LIMIT_DEFAULT, REQUEST_SIZE_LIMIT_MAP } from "./TutanotaConstants-chunk.js";
import { HttpMethod, MediaType } from "./EntityFunctions-chunk.js";
import { ConnectionError, PayloadTooLargeError, ServiceUnavailableError, TooManyRequestsError, handleRestError } from "./RestError-chunk.js";
import { SuspensionError } from "./SuspensionError-chunk.js";

//#region src/common/api/worker/rest/RestClient.ts
assertWorkerOrNode();
const TAG = "[RestClient]";
let SuspensionBehavior = function(SuspensionBehavior$1) {
	SuspensionBehavior$1[SuspensionBehavior$1["Suspend"] = 0] = "Suspend";
	SuspensionBehavior$1[SuspensionBehavior$1["Throw"] = 1] = "Throw";
	return SuspensionBehavior$1;
}({});
var RestClient = class {
	id;
	serverTimeOffsetMs = null;
	constructor(suspensionHandler, domainConfig) {
		this.suspensionHandler = suspensionHandler;
		this.domainConfig = domainConfig;
		this.id = 0;
	}
	request(path, method, options = {}) {
		const debug = typeof self !== "undefined" && self.debug;
		const verbose = isWorker() && debug;
		this.checkRequestSizeLimit(path, method, options.body ?? null);
		if (this.suspensionHandler.isSuspended()) return this.suspensionHandler.deferRequest(() => this.request(path, method, options));
else return new Promise((resolve, reject) => {
			this.id++;
			const queryParams = options.queryParams ?? {};
			if (method === HttpMethod.GET && typeof options.body === "string") queryParams["_body"] = options.body;
			if (options.noCORS) queryParams["cv"] = env.versionNumber;
			const origin = options.baseUrl ?? getApiBaseUrl(this.domainConfig);
			const resourceURL = new URL(origin);
			resourceURL.pathname = path;
			const url = addParamsToUrl(resourceURL, queryParams);
			const xhr = new XMLHttpRequest();
			xhr.open(method, url.toString());
			this.setHeaders(xhr, options);
			xhr.responseType = options.responseType === MediaType.Json || options.responseType === MediaType.Text ? "text" : "arraybuffer";
			const abortAfterTimeout = () => {
				const res = {
					timeoutId: 0,
					abortFunction: () => {
						if (this.usingTimeoutAbort()) {
							console.log(TAG, `${this.id}: ${String(new Date())} aborting ` + String(res.timeoutId));
							xhr.abort();
						}
					}
				};
				return res;
			};
			const t = abortAfterTimeout();
			let timeout = setTimeout(t.abortFunction, env.timeout);
			t.timeoutId = timeout;
			if (verbose) console.log(TAG, `${this.id}: set initial timeout ${String(timeout)} of ${env.timeout}`);
			xhr.onload = () => {
				if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} finished request. Clearing Timeout ${String(timeout)}.`);
				clearTimeout(timeout);
				this.saveServerTimeOffsetFromRequest(xhr);
				if (xhr.status === 200 || method === HttpMethod.POST && xhr.status === 201) if (options.responseType === MediaType.Json || options.responseType === MediaType.Text) resolve(xhr.response);
else if (options.responseType === MediaType.Binary) resolve(new Uint8Array(xhr.response));
else resolve(null);
else {
					const suspensionTime = xhr.getResponseHeader("Retry-After") || xhr.getResponseHeader("Suspension-Time");
					if (isSuspensionResponse(xhr.status, suspensionTime) && options.suspensionBehavior === SuspensionBehavior.Throw) reject(new SuspensionError(`blocked for ${suspensionTime}, not suspending (${xhr.status})`, suspensionTime && (parseInt(suspensionTime) * 1e3).toString()));
else if (isSuspensionResponse(xhr.status, suspensionTime)) {
						this.suspensionHandler.activateSuspensionIfInactive(Number(suspensionTime), resourceURL);
						resolve(this.suspensionHandler.deferRequest(() => this.request(path, method, options)));
					} else {
						logFailedRequest(method, url, xhr, options);
						reject(handleRestError(xhr.status, `| ${method} ${path}`, xhr.getResponseHeader("Error-Id"), xhr.getResponseHeader("Precondition")));
					}
				}
			};
			xhr.onerror = function() {
				clearTimeout(timeout);
				logFailedRequest(method, url, xhr, options);
				reject(handleRestError(xhr.status, ` | ${method} ${path}`, xhr.getResponseHeader("Error-Id"), xhr.getResponseHeader("Precondition")));
			};
			if (!options.noCORS) {
				xhr.upload.onprogress = (pe) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload progress. Clearing Timeout ${String(timeout)}`, pe);
					clearTimeout(timeout);
					const t$1 = abortAfterTimeout();
					timeout = setTimeout(t$1.abortFunction, env.timeout);
					t$1.timeoutId = timeout;
					if (verbose) console.log(TAG, `${this.id}: set new timeout ${String(timeout)} of ${env.timeout}`);
					if (options.progressListener != null && pe.lengthComputable) options.progressListener.upload(1 / pe.total * pe.loaded);
				};
				xhr.upload.ontimeout = (e) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload timeout. calling error handler.`, e);
					xhr.onerror?.(e);
				};
				xhr.upload.onerror = (e) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload error. calling error handler.`, e);
					xhr.onerror?.(e);
				};
				xhr.upload.onabort = (e) => {
					if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} upload aborted. calling error handler.`, e);
					xhr.onerror?.(e);
				};
			}
			xhr.onprogress = (pe) => {
				if (verbose) console.log(TAG, `${this.id}: ${String(new Date())} download progress. Clearing Timeout ${String(timeout)}`, pe);
				clearTimeout(timeout);
				let t$1 = abortAfterTimeout();
				timeout = setTimeout(t$1.abortFunction, env.timeout);
				t$1.timeoutId = timeout;
				if (verbose) console.log(TAG, `${this.id}: set new timeout ${String(timeout)} of ${env.timeout}`);
				if (options.progressListener != null && pe.lengthComputable) options.progressListener.download(1 / pe.total * pe.loaded);
			};
			xhr.onabort = () => {
				clearTimeout(timeout);
				reject(new ConnectionError(`Reached timeout of ${env.timeout}ms ${xhr.statusText} | ${method} ${path}`));
			};
			if (options.body instanceof Uint8Array) xhr.send(uint8ArrayToArrayBuffer(options.body));
else xhr.send(options.body);
		});
	}
	/** We only need to track timeout directly here on some platforms. Other platforms do it inside their network driver. */
	usingTimeoutAbort() {
		return isWebClient() || isAndroidApp();
	}
	saveServerTimeOffsetFromRequest(xhr) {
		const serverTimestamp = xhr.getResponseHeader("Date");
		if (serverTimestamp != null) {
			const serverTime = new Date(serverTimestamp).getTime();
			if (!isNaN(serverTime)) {
				const now = Date.now();
				this.serverTimeOffsetMs = serverTime - now;
			}
		}
	}
	/**
	* Get the time on the server based on the client time + the server time offset
	* The server time offset is calculated based on the date field in the header returned from REST requests.
	* will throw an error if offline or no rest requests have been made yet
	*/
	getServerTimestampMs() {
		const timeOffset = assertNotNull(this.serverTimeOffsetMs, "You can't get server time if no rest requests were made");
		return Date.now() + timeOffset;
	}
	/**
	* Checks if the request body is too large.
	* Ignores the method because GET requests etc. should not exceed the limits neither.
	* This is done to avoid making the request, because the server will return a PayloadTooLargeError anyway.
	* */
	checkRequestSizeLimit(path, method, body) {
		if (isAdminClient()) return;
		const limit = REQUEST_SIZE_LIMIT_MAP.get(path) ?? REQUEST_SIZE_LIMIT_DEFAULT;
		if (body && body.length > limit) throw new PayloadTooLargeError(`request body is too large. Path: ${path}, Method: ${method}, Body length: ${body.length}`);
	}
	setHeaders(xhr, options) {
		if (options.headers == null) options.headers = {};
		const { headers, body, responseType } = options;
		if (!options.noCORS) {
			headers["cv"] = env.versionNumber;
			if (body instanceof Uint8Array) headers["Content-Type"] = MediaType.Binary;
else if (typeof body === "string") headers["Content-Type"] = MediaType.Json;
		}
		if (responseType) headers["Accept"] = responseType;
		for (const i in headers) xhr.setRequestHeader(i, headers[i]);
	}
};
function addParamsToUrl(url, urlParams) {
	if (urlParams) {
		for (const [key, value] of typedEntries(urlParams)) if (value !== undefined) url.searchParams.set(key, value);
	}
	return url;
}
function isSuspensionResponse(statusCode, suspensionTimeNumberString) {
	return Number(suspensionTimeNumberString) > 0 && (statusCode === TooManyRequestsError.CODE || statusCode === ServiceUnavailableError.CODE);
}
function logFailedRequest(method, url, xhr, options) {
	const args = [
		TAG,
		"failed request",
		method,
		url.toString(),
		xhr.status,
		xhr.statusText
	];
	if (options.headers != null) args.push(Object.keys(options.headers));
	if (options.body != null) {
		const logBody = "string" === typeof options.body ? `[${options.body.length} characters]` : `[${options.body.length} bytes]`;
		args.push(logBody);
	} else args.push("no body");
	console.log(...args);
}

//#endregion
export { RestClient, SuspensionBehavior, addParamsToUrl, isSuspensionResponse };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVzdENsaWVudC1jaHVuay5qcyIsIm5hbWVzIjpbInN1c3BlbnNpb25IYW5kbGVyOiBTdXNwZW5zaW9uSGFuZGxlciIsImRvbWFpbkNvbmZpZzogRG9tYWluQ29uZmlnIiwicGF0aDogc3RyaW5nIiwibWV0aG9kOiBIdHRwTWV0aG9kIiwib3B0aW9uczogUmVzdENsaWVudE9wdGlvbnMiLCJxdWVyeVBhcmFtczogRGljdCIsInBlOiBQcm9ncmVzc0V2ZW50IiwidCIsInhocjogWE1MSHR0cFJlcXVlc3QiLCJib2R5OiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCIsInVybDogVVJMIiwidXJsUGFyYW1zOiBEaWN0Iiwic3RhdHVzQ29kZTogbnVtYmVyIiwic3VzcGVuc2lvblRpbWVOdW1iZXJTdHJpbmc6IHN0cmluZyB8IG51bGwiLCJhcmdzOiBBcnJheTx1bmtub3duPiJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vYXBpL3dvcmtlci9yZXN0L1Jlc3RDbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0V29ya2VyT3JOb2RlLCBnZXRBcGlCYXNlVXJsLCBpc0FkbWluQ2xpZW50LCBpc0FuZHJvaWRBcHAsIGlzV2ViQ2xpZW50LCBpc1dvcmtlciB9IGZyb20gXCIuLi8uLi9jb21tb24vRW52XCJcbmltcG9ydCB7IENvbm5lY3Rpb25FcnJvciwgaGFuZGxlUmVzdEVycm9yLCBQYXlsb2FkVG9vTGFyZ2VFcnJvciwgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IsIFRvb01hbnlSZXF1ZXN0c0Vycm9yIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9lcnJvci9SZXN0RXJyb3JcIlxuaW1wb3J0IHsgSHR0cE1ldGhvZCwgTWVkaWFUeXBlIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9FbnRpdHlGdW5jdGlvbnNcIlxuaW1wb3J0IHsgYXNzZXJ0Tm90TnVsbCwgdHlwZWRFbnRyaWVzLCB1aW50OEFycmF5VG9BcnJheUJ1ZmZlciB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgU3VzcGVuc2lvbkhhbmRsZXIgfSBmcm9tIFwiLi4vU3VzcGVuc2lvbkhhbmRsZXJcIlxuaW1wb3J0IHsgUkVRVUVTVF9TSVpFX0xJTUlUX0RFRkFVTFQsIFJFUVVFU1RfU0laRV9MSU1JVF9NQVAgfSBmcm9tIFwiLi4vLi4vY29tbW9uL1R1dGFub3RhQ29uc3RhbnRzXCJcbmltcG9ydCB7IFN1c3BlbnNpb25FcnJvciB9IGZyb20gXCIuLi8uLi9jb21tb24vZXJyb3IvU3VzcGVuc2lvbkVycm9yLmpzXCJcblxuYXNzZXJ0V29ya2VyT3JOb2RlKClcblxuY29uc3QgVEFHID0gXCJbUmVzdENsaWVudF1cIlxuXG5pbnRlcmZhY2UgUHJvZ3Jlc3NMaXN0ZW5lciB7XG5cdHVwbG9hZChwZXJjZW50OiBudW1iZXIpOiB2b2lkXG5cblx0ZG93bmxvYWQocGVyY2VudDogbnVtYmVyKTogdm9pZFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBTdXNwZW5zaW9uQmVoYXZpb3Ige1xuXHRTdXNwZW5kLFxuXHRUaHJvdyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXN0Q2xpZW50T3B0aW9ucyB7XG5cdGJvZHk/OiBzdHJpbmcgfCBVaW50OEFycmF5XG5cdHJlc3BvbnNlVHlwZT86IE1lZGlhVHlwZVxuXHRwcm9ncmVzc0xpc3RlbmVyPzogUHJvZ3Jlc3NMaXN0ZW5lclxuXHRiYXNlVXJsPzogc3RyaW5nXG5cdGhlYWRlcnM/OiBEaWN0XG5cdHF1ZXJ5UGFyYW1zPzogRGljdFxuXHRub0NPUlM/OiBib29sZWFuXG5cdC8qKiBEZWZhdWx0IGlzIHRvIHN1c3BlbmQgYWxsIHJlcXVlc3RzIG9uIHJhdGUgbGltaXQuICovXG5cdHN1c3BlbnNpb25CZWhhdmlvcj86IFN1c3BlbnNpb25CZWhhdmlvclxufVxuXG4vKipcbiAqIEFsbG93cyBSRVNUIGNvbW11bmljYXRpb24gd2l0aCB0aGUgc2VydmVyLlxuICogVGhlIFJlc3RDbGllbnQgb2JzZXJ2ZXMgdXBsb2FkL2Rvd25sb2FkIHByb2dyZXNzIGFuZCB0aW1lc1xuICogb3V0IGluIGNhc2Ugbm8gZGF0YSBpcyBzZW50IG9yIHJlY2VpdmVkIGZvciBhIGNlcnRhaW4gdGltZS5cbiAqXG4gKiBVc2VzIFhtbEh0dHBSZXF1ZXN0IGFzIHRoZXJlIGlzIHN0aWxsIG5vIHN1cHBvcnQgZm9yIHRyYWNraW5nXG4gKiB1cGxvYWQgcHJvZ3Jlc3Mgd2l0aCBmZXRjaCAoc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTQwMDYzMilcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc3RDbGllbnQge1xuXHRwcml2YXRlIGlkOiBudW1iZXJcblx0Ly8gYWNjdXJhdGUgdG8gd2l0aGluIGEgZmV3IHNlY29uZHMsIGRlcGVuZGluZyBvbiBuZXR3b3JrIHNwZWVkXG5cdHByaXZhdGUgc2VydmVyVGltZU9mZnNldE1zOiBudW1iZXIgfCBudWxsID0gbnVsbFxuXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3VzcGVuc2lvbkhhbmRsZXI6IFN1c3BlbnNpb25IYW5kbGVyLCBwcml2YXRlIHJlYWRvbmx5IGRvbWFpbkNvbmZpZzogRG9tYWluQ29uZmlnKSB7XG5cdFx0dGhpcy5pZCA9IDBcblx0fVxuXG5cdHJlcXVlc3QocGF0aDogc3RyaW5nLCBtZXRob2Q6IEh0dHBNZXRob2QsIG9wdGlvbnM6IFJlc3RDbGllbnRPcHRpb25zID0ge30pOiBQcm9taXNlPGFueSB8IG51bGw+IHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0Y29uc3QgZGVidWcgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmRlYnVnXG5cdFx0Y29uc3QgdmVyYm9zZSA9IGlzV29ya2VyKCkgJiYgZGVidWdcblxuXHRcdHRoaXMuY2hlY2tSZXF1ZXN0U2l6ZUxpbWl0KHBhdGgsIG1ldGhvZCwgb3B0aW9ucy5ib2R5ID8/IG51bGwpXG5cblx0XHRpZiAodGhpcy5zdXNwZW5zaW9uSGFuZGxlci5pc1N1c3BlbmRlZCgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdXNwZW5zaW9uSGFuZGxlci5kZWZlclJlcXVlc3QoKCkgPT4gdGhpcy5yZXF1ZXN0KHBhdGgsIG1ldGhvZCwgb3B0aW9ucykpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRcdHRoaXMuaWQrK1xuXG5cdFx0XHRcdGNvbnN0IHF1ZXJ5UGFyYW1zOiBEaWN0ID0gb3B0aW9ucy5xdWVyeVBhcmFtcyA/PyB7fVxuXG5cdFx0XHRcdGlmIChtZXRob2QgPT09IEh0dHBNZXRob2QuR0VUICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRxdWVyeVBhcmFtc1tcIl9ib2R5XCJdID0gb3B0aW9ucy5ib2R5IC8vIGdldCByZXF1ZXN0cyBhcmUgbm90IGFsbG93ZWQgdG8gc2VuZCBhIGJvZHkuIFRoZXJlZm9yZSwgd2UgY29udmVydCBvdXIgYm9keSB0byBhIHBhcmFtZXRlclxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMubm9DT1JTKSB7XG5cdFx0XHRcdFx0cXVlcnlQYXJhbXNbXCJjdlwiXSA9IGVudi52ZXJzaW9uTnVtYmVyXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBvcmlnaW4gPSBvcHRpb25zLmJhc2VVcmwgPz8gZ2V0QXBpQmFzZVVybCh0aGlzLmRvbWFpbkNvbmZpZylcblx0XHRcdFx0Y29uc3QgcmVzb3VyY2VVUkwgPSBuZXcgVVJMKG9yaWdpbilcblx0XHRcdFx0cmVzb3VyY2VVUkwucGF0aG5hbWUgPSBwYXRoXG5cdFx0XHRcdGNvbnN0IHVybCA9IGFkZFBhcmFtc1RvVXJsKHJlc291cmNlVVJMLCBxdWVyeVBhcmFtcylcblx0XHRcdFx0Y29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblx0XHRcdFx0eGhyLm9wZW4obWV0aG9kLCB1cmwudG9TdHJpbmcoKSlcblxuXHRcdFx0XHR0aGlzLnNldEhlYWRlcnMoeGhyLCBvcHRpb25zKVxuXG5cdFx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZSA9PT0gTWVkaWFUeXBlLkpzb24gfHwgb3B0aW9ucy5yZXNwb25zZVR5cGUgPT09IE1lZGlhVHlwZS5UZXh0ID8gXCJ0ZXh0XCIgOiBcImFycmF5YnVmZmVyXCJcblxuXHRcdFx0XHRjb25zdCBhYm9ydEFmdGVyVGltZW91dCA9ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCByZXMgPSB7XG5cdFx0XHRcdFx0XHR0aW1lb3V0SWQ6IDAgYXMgVGltZW91dElELFxuXHRcdFx0XHRcdFx0YWJvcnRGdW5jdGlvbjogKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy51c2luZ1RpbWVvdXRBYm9ydCgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coVEFHLCBgJHt0aGlzLmlkfTogJHtTdHJpbmcobmV3IERhdGUoKSl9IGFib3J0aW5nIGAgKyBTdHJpbmcocmVzLnRpbWVvdXRJZCkpXG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJlc1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdCA9IGFib3J0QWZ0ZXJUaW1lb3V0KClcblx0XHRcdFx0bGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KHQuYWJvcnRGdW5jdGlvbiwgZW52LnRpbWVvdXQpXG5cdFx0XHRcdHQudGltZW91dElkID0gdGltZW91dFxuXG5cdFx0XHRcdGlmICh2ZXJib3NlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coVEFHLCBgJHt0aGlzLmlkfTogc2V0IGluaXRpYWwgdGltZW91dCAke1N0cmluZyh0aW1lb3V0KX0gb2YgJHtlbnYudGltZW91dH1gKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eGhyLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdFx0XHQvLyBYTUxIdHRwUmVxdWVzdFByb2dyZXNzRXZlbnQsIGJ1dCBub3QgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKHZlcmJvc2UpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgYCR7dGhpcy5pZH06ICR7U3RyaW5nKG5ldyBEYXRlKCkpfSBmaW5pc2hlZCByZXF1ZXN0LiBDbGVhcmluZyBUaW1lb3V0ICR7U3RyaW5nKHRpbWVvdXQpfS5gKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KVxuXG5cdFx0XHRcdFx0dGhpcy5zYXZlU2VydmVyVGltZU9mZnNldEZyb21SZXF1ZXN0KHhocilcblxuXHRcdFx0XHRcdGlmICh4aHIuc3RhdHVzID09PSAyMDAgfHwgKG1ldGhvZCA9PT0gSHR0cE1ldGhvZC5QT1NUICYmIHhoci5zdGF0dXMgPT09IDIwMSkpIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSA9PT0gTWVkaWFUeXBlLkpzb24gfHwgb3B0aW9ucy5yZXNwb25zZVR5cGUgPT09IE1lZGlhVHlwZS5UZXh0KSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoeGhyLnJlc3BvbnNlKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSA9PT0gTWVkaWFUeXBlLkJpbmFyeSkge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSkpXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKG51bGwpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHN1c3BlbnNpb25UaW1lID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiUmV0cnktQWZ0ZXJcIikgfHwgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiU3VzcGVuc2lvbi1UaW1lXCIpXG5cblx0XHRcdFx0XHRcdGlmIChpc1N1c3BlbnNpb25SZXNwb25zZSh4aHIuc3RhdHVzLCBzdXNwZW5zaW9uVGltZSkgJiYgb3B0aW9ucy5zdXNwZW5zaW9uQmVoYXZpb3IgPT09IFN1c3BlbnNpb25CZWhhdmlvci5UaHJvdykge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QoXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFN1c3BlbnNpb25FcnJvcihcblx0XHRcdFx0XHRcdFx0XHRcdGBibG9ja2VkIGZvciAke3N1c3BlbnNpb25UaW1lfSwgbm90IHN1c3BlbmRpbmcgKCR7eGhyLnN0YXR1c30pYCxcblx0XHRcdFx0XHRcdFx0XHRcdHN1c3BlbnNpb25UaW1lICYmIChwYXJzZUludChzdXNwZW5zaW9uVGltZSkgKiAxMDAwKS50b1N0cmluZygpLFxuXHRcdFx0XHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNTdXNwZW5zaW9uUmVzcG9uc2UoeGhyLnN0YXR1cywgc3VzcGVuc2lvblRpbWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3VzcGVuc2lvbkhhbmRsZXIuYWN0aXZhdGVTdXNwZW5zaW9uSWZJbmFjdGl2ZShOdW1iZXIoc3VzcGVuc2lvblRpbWUpLCByZXNvdXJjZVVSTClcblxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKHRoaXMuc3VzcGVuc2lvbkhhbmRsZXIuZGVmZXJSZXF1ZXN0KCgpID0+IHRoaXMucmVxdWVzdChwYXRoLCBtZXRob2QsIG9wdGlvbnMpKSlcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxvZ0ZhaWxlZFJlcXVlc3QobWV0aG9kLCB1cmwsIHhociwgb3B0aW9ucylcblx0XHRcdFx0XHRcdFx0cmVqZWN0KGhhbmRsZVJlc3RFcnJvcih4aHIuc3RhdHVzLCBgfCAke21ldGhvZH0gJHtwYXRofWAsIHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkVycm9yLUlkXCIpLCB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJQcmVjb25kaXRpb25cIikpKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KVxuXHRcdFx0XHRcdGxvZ0ZhaWxlZFJlcXVlc3QobWV0aG9kLCB1cmwsIHhociwgb3B0aW9ucylcblx0XHRcdFx0XHRyZWplY3QoaGFuZGxlUmVzdEVycm9yKHhoci5zdGF0dXMsIGAgfCAke21ldGhvZH0gJHtwYXRofWAsIHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkVycm9yLUlkXCIpLCB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJQcmVjb25kaXRpb25cIikpKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZG9uJ3QgYWRkIGFuIEV2ZW50TGlzdGVuZXIgZm9yIG5vbi1DT1JTIHJlcXVlc3RzLCBvdGhlcndpc2UgaXQgd291bGQgbm90IG1lZXQgdGhlICdDT1JTLVByZWZsaWdodCBzaW1wbGUgcmVxdWVzdCcgcmVxdWlyZW1lbnRzXG5cdFx0XHRcdGlmICghb3B0aW9ucy5ub0NPUlMpIHtcblx0XHRcdFx0XHR4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAocGU6IFByb2dyZXNzRXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdGlmICh2ZXJib3NlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgYCR7dGhpcy5pZH06ICR7U3RyaW5nKG5ldyBEYXRlKCkpfSB1cGxvYWQgcHJvZ3Jlc3MuIENsZWFyaW5nIFRpbWVvdXQgJHtTdHJpbmcodGltZW91dCl9YCwgcGUpXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KVxuXHRcdFx0XHRcdFx0Y29uc3QgdCA9IGFib3J0QWZ0ZXJUaW1lb3V0KClcblx0XHRcdFx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KHQuYWJvcnRGdW5jdGlvbiwgZW52LnRpbWVvdXQpXG5cdFx0XHRcdFx0XHR0LnRpbWVvdXRJZCA9IHRpbWVvdXRcblxuXHRcdFx0XHRcdFx0aWYgKHZlcmJvc2UpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coVEFHLCBgJHt0aGlzLmlkfTogc2V0IG5ldyB0aW1lb3V0ICR7U3RyaW5nKHRpbWVvdXQpfSBvZiAke2Vudi50aW1lb3V0fWApXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChvcHRpb25zLnByb2dyZXNzTGlzdGVuZXIgIT0gbnVsbCAmJiBwZS5sZW5ndGhDb21wdXRhYmxlKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHJvZ3Jlc3NFdmVudFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnByb2dyZXNzTGlzdGVuZXIudXBsb2FkKCgxIC8gcGUudG90YWwpICogcGUubG9hZGVkKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHhoci51cGxvYWQub250aW1lb3V0ID0gKGUpID0+IHtcblx0XHRcdFx0XHRcdGlmICh2ZXJib3NlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgYCR7dGhpcy5pZH06ICR7U3RyaW5nKG5ldyBEYXRlKCkpfSB1cGxvYWQgdGltZW91dC4gY2FsbGluZyBlcnJvciBoYW5kbGVyLmAsIGUpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR4aHIub25lcnJvcj8uKGUpXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eGhyLnVwbG9hZC5vbmVycm9yID0gKGUpID0+IHtcblx0XHRcdFx0XHRcdGlmICh2ZXJib3NlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgYCR7dGhpcy5pZH06ICR7U3RyaW5nKG5ldyBEYXRlKCkpfSB1cGxvYWQgZXJyb3IuIGNhbGxpbmcgZXJyb3IgaGFuZGxlci5gLCBlKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0eGhyLm9uZXJyb3I/LihlKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHhoci51cGxvYWQub25hYm9ydCA9IChlKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAodmVyYm9zZSkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhUQUcsIGAke3RoaXMuaWR9OiAke1N0cmluZyhuZXcgRGF0ZSgpKX0gdXBsb2FkIGFib3J0ZWQuIGNhbGxpbmcgZXJyb3IgaGFuZGxlci5gLCBlKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0eGhyLm9uZXJyb3I/LihlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHhoci5vbnByb2dyZXNzID0gKHBlOiBQcm9ncmVzc0V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0aWYgKHZlcmJvc2UpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgYCR7dGhpcy5pZH06ICR7U3RyaW5nKG5ldyBEYXRlKCkpfSBkb3dubG9hZCBwcm9ncmVzcy4gQ2xlYXJpbmcgVGltZW91dCAke1N0cmluZyh0aW1lb3V0KX1gLCBwZSlcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dClcblx0XHRcdFx0XHRsZXQgdCA9IGFib3J0QWZ0ZXJUaW1lb3V0KClcblx0XHRcdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCh0LmFib3J0RnVuY3Rpb24sIGVudi50aW1lb3V0KVxuXHRcdFx0XHRcdHQudGltZW91dElkID0gdGltZW91dFxuXG5cdFx0XHRcdFx0aWYgKHZlcmJvc2UpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFRBRywgYCR7dGhpcy5pZH06IHNldCBuZXcgdGltZW91dCAke1N0cmluZyh0aW1lb3V0KX0gb2YgJHtlbnYudGltZW91dH1gKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChvcHRpb25zLnByb2dyZXNzTGlzdGVuZXIgIT0gbnVsbCAmJiBwZS5sZW5ndGhDb21wdXRhYmxlKSB7XG5cdFx0XHRcdFx0XHQvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Byb2dyZXNzRXZlbnRcblx0XHRcdFx0XHRcdG9wdGlvbnMucHJvZ3Jlc3NMaXN0ZW5lci5kb3dubG9hZCgoMSAvIHBlLnRvdGFsKSAqIHBlLmxvYWRlZClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR4aHIub25hYm9ydCA9ICgpID0+IHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dClcblx0XHRcdFx0XHRyZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihgUmVhY2hlZCB0aW1lb3V0IG9mICR7ZW52LnRpbWVvdXR9bXMgJHt4aHIuc3RhdHVzVGV4dH0gfCAke21ldGhvZH0gJHtwYXRofWApKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHRcdFx0XHR4aHIuc2VuZCh1aW50OEFycmF5VG9BcnJheUJ1ZmZlcihvcHRpb25zLmJvZHkpKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5zZW5kKG9wdGlvbnMuYm9keSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHQvKiogV2Ugb25seSBuZWVkIHRvIHRyYWNrIHRpbWVvdXQgZGlyZWN0bHkgaGVyZSBvbiBzb21lIHBsYXRmb3Jtcy4gT3RoZXIgcGxhdGZvcm1zIGRvIGl0IGluc2lkZSB0aGVpciBuZXR3b3JrIGRyaXZlci4gKi9cblx0cHJpdmF0ZSB1c2luZ1RpbWVvdXRBYm9ydCgpIHtcblx0XHRyZXR1cm4gaXNXZWJDbGllbnQoKSB8fCBpc0FuZHJvaWRBcHAoKVxuXHR9XG5cblx0cHJpdmF0ZSBzYXZlU2VydmVyVGltZU9mZnNldEZyb21SZXF1ZXN0KHhocjogWE1MSHR0cFJlcXVlc3QpIHtcblx0XHQvLyBEYXRlcyBzZW50IGluIHRoZSBgRGF0ZWAgZmllbGQgb2YgSFRUUCBoZWFkZXJzIGZvbGxvdyB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSByZmM3MjMxXG5cdFx0Ly8gSmF2YVNjcmlwdCdzIERhdGUgZXhwZWN0cyBkYXRlcyBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSByZmMyODIyXG5cdFx0Ly8gcmZjNzIzMSBwcm92aWRlcyB0aHJlZSBvcHRpb25zIG9mIGZvcm1hdHMsIHRoZSBwcmVmZXJyZWQgb25lIGJlaW5nIElNRi1maXhkYXRlLiBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5XG5cdFx0Ly8gcGFyc2VhYmxlIGJ5IGFueSByZmMyODIyIGNvbXBhdGlibGUgcGFyc2VyLCBzaW5jZSBpdCBpcyBhIHN0cmljdCBzdWJzZXQgKHdpdGggbm8gZm9sZGluZyB3aGl0ZSBzcGFjZSkgb2YgdGhlXG5cdFx0Ly8gZm9ybWF0IG9mIHJmYzUzMjIsIHdoaWNoIGlzIHRoZSBzYW1lIGFzIHJmYzI4MjIgYWNjZXB0aW5nIG1vcmUgZm9sZGluZyB3aGl0ZSBzcGFjZXMuXG5cdFx0Ly8gRnVydGhlcm1vcmUsIHRoZXJlIGlzIG5vIHJlYXNvbiB0byBleHBlY3QgdGhlIHNlcnZlciB0byByZXR1cm4gYW55IG9mIHRoZSBvdGhlciB0d28gYWNjZXB0ZWQgZm9ybWF0cywgd2hpY2hcblx0XHQvLyBhcmUgb2Jzb2xldGUgYW5kIGFjY2VwdGVkIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdGNvbnN0IHNlcnZlclRpbWVzdGFtcCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkRhdGVcIilcblxuXHRcdGlmIChzZXJ2ZXJUaW1lc3RhbXAgIT0gbnVsbCkge1xuXHRcdFx0Ly8gY2hlY2sgdGhhdCBzZXJ2ZXJUaW1lc3RhbXAgaGFzIGJlZW4gcmV0dXJuZWRcblx0XHRcdGNvbnN0IHNlcnZlclRpbWUgPSBuZXcgRGF0ZShzZXJ2ZXJUaW1lc3RhbXApLmdldFRpbWUoKVxuXG5cdFx0XHRpZiAoIWlzTmFOKHNlcnZlclRpbWUpKSB7XG5cdFx0XHRcdGNvbnN0IG5vdyA9IERhdGUubm93KClcblx0XHRcdFx0dGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0TXMgPSBzZXJ2ZXJUaW1lIC0gbm93XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdGltZSBvbiB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZSBjbGllbnQgdGltZSArIHRoZSBzZXJ2ZXIgdGltZSBvZmZzZXRcblx0ICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkYXRlIGZpZWxkIGluIHRoZSBoZWFkZXIgcmV0dXJuZWQgZnJvbSBSRVNUIHJlcXVlc3RzLlxuXHQgKiB3aWxsIHRocm93IGFuIGVycm9yIGlmIG9mZmxpbmUgb3Igbm8gcmVzdCByZXF1ZXN0cyBoYXZlIGJlZW4gbWFkZSB5ZXRcblx0ICovXG5cdGdldFNlcnZlclRpbWVzdGFtcE1zKCk6IG51bWJlciB7XG5cdFx0Y29uc3QgdGltZU9mZnNldCA9IGFzc2VydE5vdE51bGwodGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0TXMsIFwiWW91IGNhbid0IGdldCBzZXJ2ZXIgdGltZSBpZiBubyByZXN0IHJlcXVlc3RzIHdlcmUgbWFkZVwiKVxuXHRcdHJldHVybiBEYXRlLm5vdygpICsgdGltZU9mZnNldFxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcmVxdWVzdCBib2R5IGlzIHRvbyBsYXJnZS5cblx0ICogSWdub3JlcyB0aGUgbWV0aG9kIGJlY2F1c2UgR0VUIHJlcXVlc3RzIGV0Yy4gc2hvdWxkIG5vdCBleGNlZWQgdGhlIGxpbWl0cyBuZWl0aGVyLlxuXHQgKiBUaGlzIGlzIGRvbmUgdG8gYXZvaWQgbWFraW5nIHRoZSByZXF1ZXN0LCBiZWNhdXNlIHRoZSBzZXJ2ZXIgd2lsbCByZXR1cm4gYSBQYXlsb2FkVG9vTGFyZ2VFcnJvciBhbnl3YXkuXG5cdCAqICovXG5cdHByaXZhdGUgY2hlY2tSZXF1ZXN0U2l6ZUxpbWl0KHBhdGg6IHN0cmluZywgbWV0aG9kOiBIdHRwTWV0aG9kLCBib2R5OiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCkge1xuXHRcdGlmIChpc0FkbWluQ2xpZW50KCkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGNvbnN0IGxpbWl0ID0gUkVRVUVTVF9TSVpFX0xJTUlUX01BUC5nZXQocGF0aCkgPz8gUkVRVUVTVF9TSVpFX0xJTUlUX0RFRkFVTFRcblxuXHRcdGlmIChib2R5ICYmIGJvZHkubGVuZ3RoID4gbGltaXQpIHtcblx0XHRcdHRocm93IG5ldyBQYXlsb2FkVG9vTGFyZ2VFcnJvcihgcmVxdWVzdCBib2R5IGlzIHRvbyBsYXJnZS4gUGF0aDogJHtwYXRofSwgTWV0aG9kOiAke21ldGhvZH0sIEJvZHkgbGVuZ3RoOiAke2JvZHkubGVuZ3RofWApXG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBzZXRIZWFkZXJzKHhocjogWE1MSHR0cFJlcXVlc3QsIG9wdGlvbnM6IFJlc3RDbGllbnRPcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuaGVhZGVycyA9PSBudWxsKSB7XG5cdFx0XHRvcHRpb25zLmhlYWRlcnMgPSB7fVxuXHRcdH1cblx0XHRjb25zdCB7IGhlYWRlcnMsIGJvZHksIHJlc3BvbnNlVHlwZSB9ID0gb3B0aW9uc1xuXG5cdFx0Ly8gZG9uJ3QgYWRkIGN1c3RvbSBhbmQgY29udGVudC10eXBlIGhlYWRlcnMgZm9yIG5vbi1DT1JTIHJlcXVlc3RzLCBvdGhlcndpc2UgaXQgd291bGQgbm90IG1lZXQgdGhlICdDT1JTLVByZWZsaWdodCBzaW1wbGUgcmVxdWVzdCcgcmVxdWlyZW1lbnRzXG5cdFx0aWYgKCFvcHRpb25zLm5vQ09SUykge1xuXHRcdFx0aGVhZGVyc1tcImN2XCJdID0gZW52LnZlcnNpb25OdW1iZXJcblx0XHRcdGlmIChib2R5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdFx0XHRoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gTWVkaWFUeXBlLkJpbmFyeVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gTWVkaWFUeXBlLkpzb25cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRoZWFkZXJzW1wiQWNjZXB0XCJdID0gcmVzcG9uc2VUeXBlXG5cdFx0fVxuXHRcdGZvciAoY29uc3QgaSBpbiBoZWFkZXJzKSB7XG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCBoZWFkZXJzW2ldKVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUGFyYW1zVG9VcmwodXJsOiBVUkwsIHVybFBhcmFtczogRGljdCk6IFVSTCB7XG5cdGlmICh1cmxQYXJhbXMpIHtcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0eXBlZEVudHJpZXModXJsUGFyYW1zKSkge1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdXJsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N1c3BlbnNpb25SZXNwb25zZShzdGF0dXNDb2RlOiBudW1iZXIsIHN1c3BlbnNpb25UaW1lTnVtYmVyU3RyaW5nOiBzdHJpbmcgfCBudWxsKTogYm9vbGVhbiB7XG5cdHJldHVybiBOdW1iZXIoc3VzcGVuc2lvblRpbWVOdW1iZXJTdHJpbmcpID4gMCAmJiAoc3RhdHVzQ29kZSA9PT0gVG9vTWFueVJlcXVlc3RzRXJyb3IuQ09ERSB8fCBzdGF0dXNDb2RlID09PSBTZXJ2aWNlVW5hdmFpbGFibGVFcnJvci5DT0RFKVxufVxuXG5mdW5jdGlvbiBsb2dGYWlsZWRSZXF1ZXN0KG1ldGhvZDogSHR0cE1ldGhvZCwgdXJsOiBVUkwsIHhocjogWE1MSHR0cFJlcXVlc3QsIG9wdGlvbnM6IFJlc3RDbGllbnRPcHRpb25zKTogdm9pZCB7XG5cdGNvbnN0IGFyZ3M6IEFycmF5PHVua25vd24+ID0gW1RBRywgXCJmYWlsZWQgcmVxdWVzdFwiLCBtZXRob2QsIHVybC50b1N0cmluZygpLCB4aHIuc3RhdHVzLCB4aHIuc3RhdHVzVGV4dF1cblx0aWYgKG9wdGlvbnMuaGVhZGVycyAhPSBudWxsKSB7XG5cdFx0YXJncy5wdXNoKE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycykpXG5cdH1cblx0aWYgKG9wdGlvbnMuYm9keSAhPSBudWxsKSB7XG5cdFx0Y29uc3QgbG9nQm9keSA9IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmJvZHkgPyBgWyR7b3B0aW9ucy5ib2R5Lmxlbmd0aH0gY2hhcmFjdGVyc11gIDogYFske29wdGlvbnMuYm9keS5sZW5ndGh9IGJ5dGVzXWBcblx0XHRhcmdzLnB1c2gobG9nQm9keSlcblx0fSBlbHNlIHtcblx0XHRhcmdzLnB1c2goXCJubyBib2R5XCIpXG5cdH1cblx0Y29uc29sZS5sb2coLi4uYXJncylcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFRQSxvQkFBb0I7QUFFcEIsTUFBTSxNQUFNO0lBUU0sb0RBQVg7QUFDTjtBQUNBOztBQUNBO0lBc0JZLGFBQU4sTUFBaUI7Q0FDdkIsQUFBUTtDQUVSLEFBQVEscUJBQW9DO0NBRTVDLFlBQTZCQSxtQkFBdURDLGNBQTRCO0VBaVNoSCxLQWpTNkI7RUFpUzVCLEtBalNtRjtBQUNuRixPQUFLLEtBQUs7Q0FDVjtDQUVELFFBQVFDLE1BQWNDLFFBQW9CQyxVQUE2QixDQUFFLEdBQXVCO0VBRS9GLE1BQU0sZUFBZSxTQUFTLGVBQWUsS0FBSztFQUNsRCxNQUFNLFVBQVUsVUFBVSxJQUFJO0FBRTlCLE9BQUssc0JBQXNCLE1BQU0sUUFBUSxRQUFRLFFBQVEsS0FBSztBQUU5RCxNQUFJLEtBQUssa0JBQWtCLGFBQWEsQ0FDdkMsUUFBTyxLQUFLLGtCQUFrQixhQUFhLE1BQU0sS0FBSyxRQUFRLE1BQU0sUUFBUSxRQUFRLENBQUM7SUFFckYsUUFBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDdkMsUUFBSztHQUVMLE1BQU1DLGNBQW9CLFFBQVEsZUFBZSxDQUFFO0FBRW5ELE9BQUksV0FBVyxXQUFXLGNBQWMsUUFBUSxTQUFTLFNBQ3hELGFBQVksV0FB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