import { __toESM } from "./chunk-chunk.js";
import "./dist-chunk.js";
import "./ProgrammingError-chunk.js";
import "./Env-chunk.js";
import { findAllAndRemove, incrementDate, stringToBase64 } from "./dist2-chunk.js";
import { CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID, OperationType, RepeatPeriod } from "./TutanotaConstants-chunk.js";
import { DateTime } from "./luxon-chunk.js";
import { getListId, isSameId, listIdPart } from "./EntityUtils-chunk.js";
import "./TypeModels-chunk.js";
import { CalendarEventTypeRef, ContactTypeRef, createCalendarEvent } from "./TypeRefs-chunk.js";
import { generateLocalEventElementId, getAllDayDateUTC } from "./CommonCalendarUtils-chunk.js";
import "./TypeModels2-chunk.js";
import "./TypeRefs2-chunk.js";
import "./ParserCombinator-chunk.js";
import { addDaysForRecurringEvent, calculateContactsAge, createRepeatRuleWithValues, extractYearFromBirthday, generateUid, getEventEnd, getEventStart, getMonthRange, isBirthdayEvent, isClientOnlyCalendar } from "./CalendarUtils-chunk.js";
import { require_stream } from "./stream-chunk.js";
import { NotAuthorizedError, NotFoundError } from "./RestError-chunk.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-chunk.js";
import { isoDateToBirthday } from "./BirthdayUtils-chunk.js";

//#region src/common/calendar/date/CalendarEventsRepository.ts
var import_stream = __toESM(require_stream(), 1);
const LIMIT_PAST_EVENTS_YEARS = 100;
const TAG = "[CalendarEventRepository]";
var CalendarEventsRepository = class {
	/** timestamps of the beginning of months that we already loaded */
	loadedMonths = new Set();
	daysToEvents = (0, import_stream.default)(new Map());
	pendingLoadRequest = Promise.resolve();
	clientOnlyEvents = new Map();
	constructor(calendarModel, calendarFacade, zone, entityClient, eventController, contactModel, logins) {
		this.calendarModel = calendarModel;
		this.calendarFacade = calendarFacade;
		this.zone = zone;
		this.entityClient = entityClient;
		this.eventController = eventController;
		this.contactModel = contactModel;
		this.logins = logins;
		eventController.addEntityListener((updates, eventOwnerGroupId) => this.entityEventsReceived(updates, eventOwnerGroupId));
		this.calendarModel.getCalendarInfosStream().map((infos) => {
			if (infos.size === 0) {
				this.loadedMonths.clear();
				this.daysToEvents(new Map());
			}
		});
	}
	getEventsForMonths() {
		return this.daysToEvents;
	}
	getBirthdayEvents() {
		return this.clientOnlyEvents;
	}
	async canLoadBirthdaysCalendar() {
		return await this.logins.getUserController().isNewPaidPlan();
	}
	async loadMonthsIfNeeded(daysInMonths, progressMonitor, canceled) {
		const promiseForThisLoadRequest = this.pendingLoadRequest.then(async () => {
			for (const dayInMonth of daysInMonths) {
				if (canceled()) return;
				const monthRange = getMonthRange(dayInMonth, this.zone);
				if (!this.loadedMonths.has(monthRange.start)) {
					this.loadedMonths.add(monthRange.start);
					try {
						const calendarInfos = await this.calendarModel.getCalendarInfos();
						const eventsMap = await this.calendarFacade.updateEventMap(monthRange, calendarInfos, this.daysToEvents(), this.zone);
						this.replaceEvents(eventsMap);
						this.addBirthdaysEventsIfNeeded(dayInMonth, monthRange);
					} catch (e) {
						this.loadedMonths.delete(monthRange.start);
						throw e;
					}
				}
				progressMonitor.workDone(1);
			}
		});
		this.pendingLoadRequest = promiseForThisLoadRequest;
		await promiseForThisLoadRequest;
	}
	async addOrUpdateEvent(calendarInfo, event) {
		if (calendarInfo == null) return;
		const eventListId = getListId(event);
		if (isSameId(calendarInfo.groupRoot.shortEvents, eventListId)) {
			const eventStartMonth = getMonthRange(getEventStart(event, this.zone), this.zone);
			const eventEndMonth = getMonthRange(getEventEnd(event, this.zone), this.zone);
			if (this.loadedMonths.has(eventStartMonth.start)) await this.addDaysForEvent(event, eventStartMonth);
			if (eventEndMonth.start != eventStartMonth.start && this.loadedMonths.has(eventEndMonth.start)) await this.addDaysForEvent(event, eventEndMonth);
		} else if (isSameId(calendarInfo.groupRoot.longEvents, eventListId)) {
			this.removeExistingEvent(event);
			for (const firstDayTimestamp of this.loadedMonths) {
				const loadedMonth = getMonthRange(new Date(firstDayTimestamp), this.zone);
				if (event.repeatRule != null) await this.addDaysForRecurringEvent(event, loadedMonth);
else await this.addDaysForEvent(event, loadedMonth);
			}
		}
	}
	replaceEvents(newMap) {
		this.daysToEvents(newMap);
	}
	cloneEvents() {
		return new Map(Array.from(this.daysToEvents().entries()).map(([day, events]) => [day, events.slice()]));
	}
	addDaysForRecurringEvent(event, month) {
		if (!isClientOnlyCalendar(listIdPart(event._id)) && -DateTime.fromJSDate(event.startTime).diffNow("year").years > LIMIT_PAST_EVENTS_YEARS) {
			console.log("repeating event is too far into the past", event);
			return;
		}
		const newMap = this.cloneEvents();
		addDaysForRecurringEvent(newMap, event, month, this.zone);
		this.replaceEvents(newMap);
	}
	removeDaysForEvent(id) {
		const newMap = this.cloneEvents();
		for (const dayEvents of newMap.values()) findAllAndRemove(dayEvents, (e) => isSameId(e._id, id));
		this.replaceEvents(newMap);
	}
	/**
	* Removes {@param eventToRemove} from {@param events} using isSameEvent()
	*/
	removeExistingEvent(eventToRemove) {
		const newMap = this.cloneEvents();
		for (const dayEvents of newMap.values()) findAllAndRemove(dayEvents, (e) => isSameId(e._id, eventToRemove._id));
		this.replaceEvents(newMap);
	}
	async addDaysForEvent(event, month) {
		const { addDaysForEventInstance } = await import("./CalendarUtils2-chunk.js");
		const newMap = this.cloneEvents();
		addDaysForEventInstance(newMap, event, month, this.zone);
		this.replaceEvents(newMap);
	}
	async entityEventsReceived(updates, eventOwnerGroupId) {
		const calendarInfos = await this.calendarModel.getCalendarInfos();
		for (const update of updates) if (isUpdateForTypeRef(CalendarEventTypeRef, update)) {
			if (update.operation === OperationType.CREATE || update.operation === OperationType.UPDATE) try {
				const event = await this.entityClient.load(CalendarEventTypeRef, [update.instanceListId, update.instanceId]);
				await this.addOrUpdateEvent(calendarInfos.get(eventOwnerGroupId) ?? null, event);
			} catch (e) {
				if (e instanceof NotFoundError || e instanceof NotAuthorizedError) console.log(TAG, e.name, "updated event is not accessible anymore");
				throw e;
			}
else if (update.operation === OperationType.DELETE) this.removeDaysForEvent([update.instanceListId, update.instanceId]);
		}
	}
	pushClientOnlyEvent(month, newEvent, baseYear) {
		let clientOnlyEventsOfThisMonth = this.clientOnlyEvents.get(month) ?? [];
		clientOnlyEventsOfThisMonth.push({
			baseYear,
			event: newEvent
		});
		this.clientOnlyEvents.set(month, clientOnlyEventsOfThisMonth);
	}
	createClientOnlyBirthdayEvent(contact, userId) {
		const encodedContactId = stringToBase64(contact._id.join("/"));
		const calendarId = `${userId}#${CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID}`;
		const uid = generateUid(calendarId, Date.now());
		const eventTitle = this.calendarModel.getBirthdayEventTitle(contact.firstName);
		let fullDateIso = contact.birthdayIso;
		if (contact.birthdayIso?.startsWith("--")) fullDateIso = contact.birthdayIso.replace("-", "1970");
		const birthday = new Date(fullDateIso);
		const startDate = getAllDayDateUTC(new Date(birthday));
		const endDate = getAllDayDateUTC(incrementDate(new Date(startDate), 1));
		const newEvent = createCalendarEvent({
			sequence: "0",
			recurrenceId: null,
			hashedUid: null,
			summary: eventTitle,
			startTime: startDate,
			endTime: endDate,
			location: "",
			description: "",
			alarmInfos: [],
			organizer: null,
			attendees: [],
			invitedConfidentially: null,
			repeatRule: createRepeatRuleWithValues(RepeatPeriod.ANNUALLY, 1),
			uid
		});
		newEvent._id = [calendarId, `${generateLocalEventElementId(newEvent.startTime.getTime(), contact._id.join("/"))}#${encodedContactId}`];
		newEvent._ownerGroup = calendarId;
		return newEvent;
	}
	async loadContactsBirthdays(forceReload = false) {
		if (this.clientOnlyEvents.size > 0 && !forceReload) return;
		this.clientOnlyEvents.clear();
		const listId = await this.contactModel.getContactListId();
		if (listId == null) return [];
		const contacts = await this.entityClient.loadAll(ContactTypeRef, listId);
		const filteredContacts = contacts.filter((contact) => contact.birthdayIso).sort((a, b) => {
			const birthdayContactA = isoDateToBirthday(a.birthdayIso);
			const birthdayContactB = isoDateToBirthday(b.birthdayIso);
			return new Date(`${birthdayContactA.month}/${birthdayContactA.day}`).getTime() - new Date(`${birthdayContactB.month}/${birthdayContactB.day}`).getTime();
		});
		for (const contact of filteredContacts) {
			const newEvent = this.createClientOnlyBirthdayEvent(contact, this.logins.getUserController().userId);
			this.pushClientOnlyEvent(newEvent.startTime.getMonth(), newEvent, extractYearFromBirthday(contact.birthdayIso));
		}
		return filteredContacts;
	}
	refreshBirthdayCalendar(date) {
		const month = getMonthRange(date, this.zone);
		this.addBirthdaysEventsIfNeeded(date, month, true);
	}
	addBirthdaysEventsIfNeeded(selectedDate, monthRangeForRecurrence, removeEventOccurrences = false) {
		const clientOnlyEventsThisMonth = this.clientOnlyEvents.get(selectedDate.getMonth());
		const birthdaysOfThisMonth = clientOnlyEventsThisMonth?.filter((birthdayEvent) => isBirthdayEvent(birthdayEvent.event.uid));
		if (birthdaysOfThisMonth) for (const calendarEvent of birthdaysOfThisMonth) {
			const age = calculateContactsAge(calendarEvent.baseYear, selectedDate.getFullYear());
			const ageString = age ? `(${this.calendarModel.getAgeString(age)})` : "";
			if (removeEventOccurrences) this.removeDaysForEvent(calendarEvent.event._id);
			this.addDaysForRecurringEvent({
				...calendarEvent.event,
				summary: `${calendarEvent.event.summary} ${ageString}`
			}, monthRangeForRecurrence);
		}
	}
};

//#endregion
export { CalendarEventsRepository };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJFdmVudHNSZXBvc2l0b3J5LWNodW5rLmpzIiwibmFtZXMiOlsiY2FsZW5kYXJNb2RlbDogQ2FsZW5kYXJNb2RlbCIsImNhbGVuZGFyRmFjYWRlOiBDYWxlbmRhckZhY2FkZSIsInpvbmU6IHN0cmluZyIsImVudGl0eUNsaWVudDogRW50aXR5Q2xpZW50IiwiZXZlbnRDb250cm9sbGVyOiBFdmVudENvbnRyb2xsZXIiLCJjb250YWN0TW9kZWw6IENvbnRhY3RNb2RlbCIsImxvZ2luczogTG9naW5Db250cm9sbGVyIiwiZGF5c0luTW9udGhzOiBBcnJheTxEYXRlPiIsInByb2dyZXNzTW9uaXRvcjogSVByb2dyZXNzTW9uaXRvciIsImNhbmNlbGVkOiBTdHJlYW08Ym9vbGVhbj4iLCJjYWxlbmRhckluZm86IENhbGVuZGFySW5mbyB8IG51bGwiLCJldmVudDogQ2FsZW5kYXJFdmVudCIsIm5ld01hcDogRGF5c1RvRXZlbnRzIiwibW9udGg6IENhbGVuZGFyVGltZVJhbmdlIiwiaWQ6IElkVHVwbGUiLCJldmVudFRvUmVtb3ZlOiBDYWxlbmRhckV2ZW50IiwidXBkYXRlczogUmVhZG9ubHlBcnJheTxFbnRpdHlVcGRhdGVEYXRhPiIsImV2ZW50T3duZXJHcm91cElkOiBzdHJpbmciLCJtb250aDogbnVtYmVyIiwibmV3RXZlbnQ6IENhbGVuZGFyRXZlbnQiLCJiYXNlWWVhcjogbnVtYmVyIHwgbnVsbCIsImNvbnRhY3Q6IENvbnRhY3QiLCJ1c2VySWQ6IElkIiwiZm9yY2VSZWxvYWQ6IGJvb2xlYW4iLCJkYXRlOiBEYXRlIiwic2VsZWN0ZWREYXRlOiBEYXRlIiwibW9udGhSYW5nZUZvclJlY3VycmVuY2U6IENhbGVuZGFyVGltZVJhbmdlIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9jYWxlbmRhci9kYXRlL0NhbGVuZGFyRXZlbnRzUmVwb3NpdG9yeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3RyZWFtIGZyb20gXCJtaXRocmlsL3N0cmVhbVwiXG5pbXBvcnQgc3RyZWFtIGZyb20gXCJtaXRocmlsL3N0cmVhbVwiXG5pbXBvcnQgeyBDYWxlbmRhckluZm8sIENhbGVuZGFyTW9kZWwgfSBmcm9tIFwiLi4vLi4vLi4vY2FsZW5kYXItYXBwL2NhbGVuZGFyL21vZGVsL0NhbGVuZGFyTW9kZWwuanNcIlxuaW1wb3J0IHsgSVByb2dyZXNzTW9uaXRvciB9IGZyb20gXCIuLi8uLi9hcGkvY29tbW9uL3V0aWxzL1Byb2dyZXNzTW9uaXRvci5qc1wiXG5pbXBvcnQge1xuXHRhZGREYXlzRm9yUmVjdXJyaW5nRXZlbnQsXG5cdGNhbGN1bGF0ZUNvbnRhY3RzQWdlLFxuXHRDYWxlbmRhclRpbWVSYW5nZSxcblx0Y3JlYXRlUmVwZWF0UnVsZVdpdGhWYWx1ZXMsXG5cdGV4dHJhY3RZZWFyRnJvbUJpcnRoZGF5LFxuXHRnZW5lcmF0ZVVpZCxcblx0Z2V0RXZlbnRFbmQsXG5cdGdldEV2ZW50U3RhcnQsXG5cdGdldE1vbnRoUmFuZ2UsXG5cdGlzQmlydGhkYXlFdmVudCxcblx0aXNDbGllbnRPbmx5Q2FsZW5kYXIsXG59IGZyb20gXCIuL0NhbGVuZGFyVXRpbHMuanNcIlxuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudCwgQ2FsZW5kYXJFdmVudFR5cGVSZWYsIENvbnRhY3QsIENvbnRhY3RUeXBlUmVmLCBjcmVhdGVDYWxlbmRhckV2ZW50IH0gZnJvbSBcIi4uLy4uL2FwaS9lbnRpdGllcy90dXRhbm90YS9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBnZXRMaXN0SWQsIGlzU2FtZUlkLCBsaXN0SWRQYXJ0IH0gZnJvbSBcIi4uLy4uL2FwaS9jb21tb24vdXRpbHMvRW50aXR5VXRpbHMuanNcIlxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tIFwibHV4b25cIlxuaW1wb3J0IHsgQ2FsZW5kYXJGYWNhZGUgfSBmcm9tIFwiLi4vLi4vYXBpL3dvcmtlci9mYWNhZGVzL2xhenkvQ2FsZW5kYXJGYWNhZGUuanNcIlxuaW1wb3J0IHsgRW50aXR5Q2xpZW50IH0gZnJvbSBcIi4uLy4uL2FwaS9jb21tb24vRW50aXR5Q2xpZW50LmpzXCJcbmltcG9ydCB7IGZpbmRBbGxBbmRSZW1vdmUsIGluY3JlbWVudERhdGUsIGlzTm90TnVsbCwgc3RyaW5nVG9CYXNlNjQgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzXCJcbmltcG9ydCB7IENMSUVOVF9PTkxZX0NBTEVOREFSX0JJUlRIREFZU19CQVNFX0lELCBPcGVyYXRpb25UeXBlLCBSZXBlYXRQZXJpb2QgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi9UdXRhbm90YUNvbnN0YW50cy5qc1wiXG5pbXBvcnQgeyBOb3RBdXRob3JpemVkRXJyb3IsIE5vdEZvdW5kRXJyb3IgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi9lcnJvci9SZXN0RXJyb3IuanNcIlxuaW1wb3J0IHsgRXZlbnRDb250cm9sbGVyIH0gZnJvbSBcIi4uLy4uL2FwaS9tYWluL0V2ZW50Q29udHJvbGxlci5qc1wiXG5pbXBvcnQgeyBFbnRpdHlVcGRhdGVEYXRhLCBpc1VwZGF0ZUZvclR5cGVSZWYgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi91dGlscy9FbnRpdHlVcGRhdGVVdGlscy5qc1wiXG5pbXBvcnQgeyBnZW5lcmF0ZUxvY2FsRXZlbnRFbGVtZW50SWQsIGdldEFsbERheURhdGVVVEMgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi91dGlscy9Db21tb25DYWxlbmRhclV0aWxzLmpzXCJcbmltcG9ydCB7IENvbnRhY3RNb2RlbCB9IGZyb20gXCIuLi8uLi9jb250YWN0c0Z1bmN0aW9uYWxpdHkvQ29udGFjdE1vZGVsLmpzXCJcbmltcG9ydCB7IExvZ2luQ29udHJvbGxlciB9IGZyb20gXCIuLi8uLi9hcGkvbWFpbi9Mb2dpbkNvbnRyb2xsZXIuanNcIlxuaW1wb3J0IHsgaXNvRGF0ZVRvQmlydGhkYXkgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi91dGlscy9CaXJ0aGRheVV0aWxzLmpzXCJcblxuY29uc3QgTElNSVRfUEFTVF9FVkVOVFNfWUVBUlMgPSAxMDBcblxuY29uc3QgVEFHID0gXCJbQ2FsZW5kYXJFdmVudFJlcG9zaXRvcnldXCJcblxuLyoqIE1hcCBmcm9tIHRpbWVzdGFtcCBvZiBiZWdpbm5pbmdzIG9mIGRheXMgdG8gZXZlbnRzIHRoYXQgb2NjdXIgb24gdGhvc2UgZGF5cy4gKi9cbmV4cG9ydCB0eXBlIERheXNUb0V2ZW50cyA9IFJlYWRvbmx5TWFwPG51bWJlciwgUmVhZG9ubHlBcnJheTxDYWxlbmRhckV2ZW50Pj5cblxuLyoqIE9iamVjdCBob2xkaW5nIHRoZSB5ZWFyIG9mIGJpcnRoIGlmIGF2YWlsYWJsZSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQgKi9cbmV4cG9ydCB0eXBlIEJpcnRoZGF5RXZlbnRSZWdpc3RyeSA9IHtcblx0YmFzZVllYXI6IG51bWJlciB8IG51bGxcblx0ZXZlbnQ6IENhbGVuZGFyRXZlbnRcbn1cblxuLyoqXG4gKiBMb2FkcyBhbmQga2VlcHMgY2FsZW5kYXIgZXZlbnRzIHVwIHRvIGRhdGUuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gbG9hZCBjYWxlbmRhciBldmVudHMgdGhlcmUncyBhIGdvb2QgY2hhbmNlIHlvdSBzaG91bGQganVzdCB1c2UgdGhpc1xuICovXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJFdmVudHNSZXBvc2l0b3J5IHtcblx0LyoqIHRpbWVzdGFtcHMgb2YgdGhlIGJlZ2lubmluZyBvZiBtb250aHMgdGhhdCB3ZSBhbHJlYWR5IGxvYWRlZCAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IGxvYWRlZE1vbnRocyA9IG5ldyBTZXQ8bnVtYmVyPigpXG5cdHByaXZhdGUgZGF5c1RvRXZlbnRzOiBTdHJlYW08RGF5c1RvRXZlbnRzPiA9IHN0cmVhbShuZXcgTWFwKCkpXG5cdHByaXZhdGUgcGVuZGluZ0xvYWRSZXF1ZXN0OiBQcm9taXNlPHZvaWQ+ID0gUHJvbWlzZS5yZXNvbHZlKClcblxuXHRwcml2YXRlIGNsaWVudE9ubHlFdmVudHM6IE1hcDxudW1iZXIsIEJpcnRoZGF5RXZlbnRSZWdpc3RyeVtdPiA9IG5ldyBNYXAoKVxuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgY2FsZW5kYXJNb2RlbDogQ2FsZW5kYXJNb2RlbCxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGNhbGVuZGFyRmFjYWRlOiBDYWxlbmRhckZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IHpvbmU6IHN0cmluZyxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGVudGl0eUNsaWVudDogRW50aXR5Q2xpZW50LFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgZXZlbnRDb250cm9sbGVyOiBFdmVudENvbnRyb2xsZXIsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjb250YWN0TW9kZWw6IENvbnRhY3RNb2RlbCxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGxvZ2luczogTG9naW5Db250cm9sbGVyLFxuXHQpIHtcblx0XHRldmVudENvbnRyb2xsZXIuYWRkRW50aXR5TGlzdGVuZXIoKHVwZGF0ZXMsIGV2ZW50T3duZXJHcm91cElkKSA9PiB0aGlzLmVudGl0eUV2ZW50c1JlY2VpdmVkKHVwZGF0ZXMsIGV2ZW50T3duZXJHcm91cElkKSlcblxuXHRcdC8vIERldGVjdCB3aGVuIGdyb3VwIGluZm9zIGhhcyBiZWVuIHJlc2V0IGFuZCByZXNldCBvdXIgZGF0YSBpbiB0dXJuLlxuXHRcdC8vIFRoZXJlIGlzIHByb2JhYmx5IGFub3RoZXIgd2F5LCB3ZSBjb3VsZCByZWR1Y2UgYW5kIGFsc28gY29tcHV0ZSBzeW1tZXRyaWMgZGlmZmVyZW5jZS5cblx0XHQvLyBUaGlzIG1pZ2h0IGZpcmUgcmlnaHQgYXdheSBidXQgaXQgc2hvdWxkIGJlIGhhcm1sZXNzIHRoZW4uXG5cdFx0dGhpcy5jYWxlbmRhck1vZGVsLmdldENhbGVuZGFySW5mb3NTdHJlYW0oKS5tYXAoKGluZm9zKSA9PiB7XG5cdFx0XHRpZiAoaW5mb3Muc2l6ZSA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLmxvYWRlZE1vbnRocy5jbGVhcigpXG5cdFx0XHRcdHRoaXMuZGF5c1RvRXZlbnRzKG5ldyBNYXAoKSlcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cblx0Z2V0RXZlbnRzRm9yTW9udGhzKCk6IFN0cmVhbTxEYXlzVG9FdmVudHM+IHtcblx0XHRyZXR1cm4gdGhpcy5kYXlzVG9FdmVudHNcblx0fVxuXG5cdGdldEJpcnRoZGF5RXZlbnRzKCk6IE1hcDxudW1iZXIsIEJpcnRoZGF5RXZlbnRSZWdpc3RyeVtdPiB7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50T25seUV2ZW50c1xuXHR9XG5cblx0YXN5bmMgY2FuTG9hZEJpcnRoZGF5c0NhbGVuZGFyKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHJldHVybiBhd2FpdCB0aGlzLmxvZ2lucy5nZXRVc2VyQ29udHJvbGxlcigpLmlzTmV3UGFpZFBsYW4oKVxuXHR9XG5cblx0YXN5bmMgbG9hZE1vbnRoc0lmTmVlZGVkKGRheXNJbk1vbnRoczogQXJyYXk8RGF0ZT4sIHByb2dyZXNzTW9uaXRvcjogSVByb2dyZXNzTW9uaXRvciwgY2FuY2VsZWQ6IFN0cmVhbTxib29sZWFuPik6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHByb21pc2VGb3JUaGlzTG9hZFJlcXVlc3QgPSB0aGlzLnBlbmRpbmdMb2FkUmVxdWVzdC50aGVuKGFzeW5jICgpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZGF5SW5Nb250aCBvZiBkYXlzSW5Nb250aHMpIHtcblx0XHRcdFx0aWYgKGNhbmNlbGVkKCkpIHJldHVyblxuXG5cdFx0XHRcdGNvbnN0IG1vbnRoUmFuZ2UgPSBnZXRNb250aFJhbmdlKGRheUluTW9udGgsIHRoaXMuem9uZSlcblxuXHRcdFx0XHRpZiAoIXRoaXMubG9hZGVkTW9udGhzLmhhcyhtb250aFJhbmdlLnN0YXJ0KSkge1xuXHRcdFx0XHRcdHRoaXMubG9hZGVkTW9udGhzLmFkZChtb250aFJhbmdlLnN0YXJ0KVxuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnN0IGNhbGVuZGFySW5mb3MgPSBhd2FpdCB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0Q2FsZW5kYXJJbmZvcygpXG5cdFx0XHRcdFx0XHRjb25zdCBldmVudHNNYXAgPSBhd2FpdCB0aGlzLmNhbGVuZGFyRmFjYWRlLnVwZGF0ZUV2ZW50TWFwKG1vbnRoUmFuZ2UsIGNhbGVuZGFySW5mb3MsIHRoaXMuZGF5c1RvRXZlbnRzKCksIHRoaXMuem9uZSlcblx0XHRcdFx0XHRcdHRoaXMucmVwbGFjZUV2ZW50cyhldmVudHNNYXApXG5cdFx0XHRcdFx0XHR0aGlzLmFkZEJpcnRoZGF5c0V2ZW50c0lmTmVlZGVkKGRheUluTW9udGgsIG1vbnRoUmFuZ2UpXG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5sb2FkZWRNb250aHMuZGVsZXRlKG1vbnRoUmFuZ2Uuc3RhcnQpXG5cdFx0XHRcdFx0XHR0aHJvdyBlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHByb2dyZXNzTW9uaXRvci53b3JrRG9uZSgxKVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0dGhpcy5wZW5kaW5nTG9hZFJlcXVlc3QgPSBwcm9taXNlRm9yVGhpc0xvYWRSZXF1ZXN0XG5cdFx0YXdhaXQgcHJvbWlzZUZvclRoaXNMb2FkUmVxdWVzdFxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBhZGRPclVwZGF0ZUV2ZW50KGNhbGVuZGFySW5mbzogQ2FsZW5kYXJJbmZvIHwgbnVsbCwgZXZlbnQ6IENhbGVuZGFyRXZlbnQpIHtcblx0XHRpZiAoY2FsZW5kYXJJbmZvID09IG51bGwpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRjb25zdCBldmVudExpc3RJZCA9IGdldExpc3RJZChldmVudClcblx0XHRpZiAoaXNTYW1lSWQoY2FsZW5kYXJJbmZvLmdyb3VwUm9vdC5zaG9ydEV2ZW50cywgZXZlbnRMaXN0SWQpKSB7XG5cdFx0XHQvLyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IGNodXJuLCB3ZSBvbmx5IGFkZCB0aGUgZXZlbnQgaWYgd2UgaGF2ZSB0aGUgbW9udGhzIGl0IGNvdmVycyBsb2FkZWQuXG5cdFx0XHRjb25zdCBldmVudFN0YXJ0TW9udGggPSBnZXRNb250aFJhbmdlKGdldEV2ZW50U3RhcnQoZXZlbnQsIHRoaXMuem9uZSksIHRoaXMuem9uZSlcblx0XHRcdGNvbnN0IGV2ZW50RW5kTW9udGggPSBnZXRNb250aFJhbmdlKGdldEV2ZW50RW5kKGV2ZW50LCB0aGlzLnpvbmUpLCB0aGlzLnpvbmUpXG5cdFx0XHRpZiAodGhpcy5sb2FkZWRNb250aHMuaGFzKGV2ZW50U3RhcnRNb250aC5zdGFydCkpIGF3YWl0IHRoaXMuYWRkRGF5c0ZvckV2ZW50KGV2ZW50LCBldmVudFN0YXJ0TW9udGgpXG5cdFx0XHQvLyBubyBzaG9ydCBldmVudCBjb3ZlcnMgbW9yZSB0aGFuIHR3byBtb250aHMsIHNvIHRoaXMgc2hvdWxkIGNvdmVyIGV2ZXJ5dGhpbmcuXG5cdFx0XHRpZiAoZXZlbnRFbmRNb250aC5zdGFydCAhPSBldmVudFN0YXJ0TW9udGguc3RhcnQgJiYgdGhpcy5sb2FkZWRNb250aHMuaGFzKGV2ZW50RW5kTW9udGguc3RhcnQpKSBhd2FpdCB0aGlzLmFkZERheXNGb3JFdmVudChldmVudCwgZXZlbnRFbmRNb250aClcblx0XHR9IGVsc2UgaWYgKGlzU2FtZUlkKGNhbGVuZGFySW5mby5ncm91cFJvb3QubG9uZ0V2ZW50cywgZXZlbnRMaXN0SWQpKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUV4aXN0aW5nRXZlbnQoZXZlbnQpXG5cblx0XHRcdGZvciAoY29uc3QgZmlyc3REYXlUaW1lc3RhbXAgb2YgdGhpcy5sb2FkZWRNb250aHMpIHtcblx0XHRcdFx0Y29uc3QgbG9hZGVkTW9udGggPSBnZXRNb250aFJhbmdlKG5ldyBEYXRlKGZpcnN0RGF5VGltZXN0YW1wKSwgdGhpcy56b25lKVxuXG5cdFx0XHRcdGlmIChldmVudC5yZXBlYXRSdWxlICE9IG51bGwpIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmFkZERheXNGb3JSZWN1cnJpbmdFdmVudChldmVudCwgbG9hZGVkTW9udGgpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5hZGREYXlzRm9yRXZlbnQoZXZlbnQsIGxvYWRlZE1vbnRoKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSByZXBsYWNlRXZlbnRzKG5ld01hcDogRGF5c1RvRXZlbnRzKTogdm9pZCB7XG5cdFx0Ly8gV2UgcmVseSBvbiB0eXBlc2NyaXB0IFJlYWRvbmx5TWFwIHR5cGUgYmVjYXVzZSBmcmVlemluZ1xuXHRcdC8vIHRoaXMgbWFwIHRocm93cyBcIlRoZSBvYmplY3QgY2FuIG5vdCBiZSBjbG9uZWRcIiBvbiBpT1Ncblx0XHQvLyB3aGVuIHRoZSBzb3VyY2Ugb2YgbmV3TWFwIGlzIHVwZGF0ZUV2ZW50TWFwXG5cdFx0dGhpcy5kYXlzVG9FdmVudHMobmV3TWFwKVxuXHR9XG5cblx0cHJpdmF0ZSBjbG9uZUV2ZW50cygpOiBNYXA8bnVtYmVyLCBBcnJheTxDYWxlbmRhckV2ZW50Pj4ge1xuXHRcdHJldHVybiBuZXcgTWFwKEFycmF5LmZyb20odGhpcy5kYXlzVG9FdmVudHMoKS5lbnRyaWVzKCkpLm1hcCgoW2RheSwgZXZlbnRzXSkgPT4gW2RheSwgZXZlbnRzLnNsaWNlKCldKSlcblx0fVxuXG5cdHByaXZhdGUgYWRkRGF5c0ZvclJlY3VycmluZ0V2ZW50KGV2ZW50OiBDYWxlbmRhckV2ZW50LCBtb250aDogQ2FsZW5kYXJUaW1lUmFuZ2UpOiB2b2lkIHtcblx0XHRpZiAoIWlzQ2xpZW50T25seUNhbGVuZGFyKGxpc3RJZFBhcnQoZXZlbnQuX2lkKSkgJiYgLURhdGVUaW1lLmZyb21KU0RhdGUoZXZlbnQuc3RhcnRUaW1lKS5kaWZmTm93KFwieWVhclwiKS55ZWFycyA+IExJTUlUX1BBU1RfRVZFTlRTX1lFQVJTKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcInJlcGVhdGluZyBldmVudCBpcyB0b28gZmFyIGludG8gdGhlIHBhc3RcIiwgZXZlbnQpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRjb25zdCBuZXdNYXAgPSB0aGlzLmNsb25lRXZlbnRzKClcblxuXHRcdGFkZERheXNGb3JSZWN1cnJpbmdFdmVudChuZXdNYXAsIGV2ZW50LCBtb250aCwgdGhpcy56b25lKVxuXG5cdFx0dGhpcy5yZXBsYWNlRXZlbnRzKG5ld01hcClcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlRGF5c0ZvckV2ZW50KGlkOiBJZFR1cGxlKTogdm9pZCB7XG5cdFx0Y29uc3QgbmV3TWFwID0gdGhpcy5jbG9uZUV2ZW50cygpXG5cblx0XHRmb3IgKGNvbnN0IGRheUV2ZW50cyBvZiBuZXdNYXAudmFsdWVzKCkpIHtcblx0XHRcdGZpbmRBbGxBbmRSZW1vdmUoZGF5RXZlbnRzLCAoZSkgPT4gaXNTYW1lSWQoZS5faWQsIGlkKSlcblx0XHR9XG5cblx0XHR0aGlzLnJlcGxhY2VFdmVudHMobmV3TWFwKVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMge0BwYXJhbSBldmVudFRvUmVtb3ZlfSBmcm9tIHtAcGFyYW0gZXZlbnRzfSB1c2luZyBpc1NhbWVFdmVudCgpXG5cdCAqL1xuXHRwcml2YXRlIHJlbW92ZUV4aXN0aW5nRXZlbnQoZXZlbnRUb1JlbW92ZTogQ2FsZW5kYXJFdmVudCkge1xuXHRcdGNvbnN0IG5ld01hcCA9IHRoaXMuY2xvbmVFdmVudHMoKVxuXG5cdFx0Zm9yIChjb25zdCBkYXlFdmVudHMgb2YgbmV3TWFwLnZhbHVlcygpKSB7XG5cdFx0XHRmaW5kQWxsQW5kUmVtb3ZlKGRheUV2ZW50cywgKGUpID0+IGlzU2FtZUlkKGUuX2lkLCBldmVudFRvUmVtb3ZlLl9pZCkpXG5cdFx0fVxuXG5cdFx0dGhpcy5yZXBsYWNlRXZlbnRzKG5ld01hcClcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgYWRkRGF5c0ZvckV2ZW50KGV2ZW50OiBDYWxlbmRhckV2ZW50LCBtb250aDogQ2FsZW5kYXJUaW1lUmFuZ2UpIHtcblx0XHRjb25zdCB7IGFkZERheXNGb3JFdmVudEluc3RhbmNlIH0gPSBhd2FpdCBpbXBvcnQoXCIuL0NhbGVuZGFyVXRpbHMuanNcIilcblx0XHRjb25zdCBuZXdNYXAgPSB0aGlzLmNsb25lRXZlbnRzKClcblx0XHRhZGREYXlzRm9yRXZlbnRJbnN0YW5jZShuZXdNYXAsIGV2ZW50LCBtb250aCwgdGhpcy56b25lKVxuXHRcdHRoaXMucmVwbGFjZUV2ZW50cyhuZXdNYXApXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGVudGl0eUV2ZW50c1JlY2VpdmVkKHVwZGF0ZXM6IFJlYWRvbmx5QXJyYXk8RW50aXR5VXBkYXRlRGF0YT4sIGV2ZW50T3duZXJHcm91cElkOiBzdHJpbmcpIHtcblx0XHRjb25zdCBjYWxlbmRhckluZm9zID0gYXdhaXQgdGhpcy5jYWxlbmRhck1vZGVsLmdldENhbGVuZGFySW5mb3MoKVxuXHRcdGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcblx0XHRcdGlmIChpc1VwZGF0ZUZvclR5cGVSZWYoQ2FsZW5kYXJFdmVudFR5cGVSZWYsIHVwZGF0ZSkpIHtcblx0XHRcdFx0aWYgKHVwZGF0ZS5vcGVyYXRpb24gPT09IE9wZXJhdGlvblR5cGUuQ1JFQVRFIHx8IHVwZGF0ZS5vcGVyYXRpb24gPT09IE9wZXJhdGlvblR5cGUuVVBEQVRFKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChDYWxlbmRhckV2ZW50VHlwZVJlZiwgW3VwZGF0ZS5pbnN0YW5jZUxpc3RJZCwgdXBkYXRlLmluc3RhbmNlSWRdKVxuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hZGRPclVwZGF0ZUV2ZW50KGNhbGVuZGFySW5mb3MuZ2V0KGV2ZW50T3duZXJHcm91cElkKSA/PyBudWxsLCBldmVudClcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IgfHwgZSBpbnN0YW5jZW9mIE5vdEF1dGhvcml6ZWRFcnJvcikge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhUQUcsIGUubmFtZSwgXCJ1cGRhdGVkIGV2ZW50IGlzIG5vdCBhY2Nlc3NpYmxlIGFueW1vcmVcIilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRocm93IGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodXBkYXRlLm9wZXJhdGlvbiA9PT0gT3BlcmF0aW9uVHlwZS5ERUxFVEUpIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZURheXNGb3JFdmVudChbdXBkYXRlLmluc3RhbmNlTGlzdElkLCB1cGRhdGUuaW5zdGFuY2VJZF0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgcHVzaENsaWVudE9ubHlFdmVudChtb250aDogbnVtYmVyLCBuZXdFdmVudDogQ2FsZW5kYXJFdmVudCwgYmFzZVllYXI6IG51bWJlciB8IG51bGwpIHtcblx0XHRsZXQgY2xpZW50T25seUV2ZW50c09mVGhpc01vbnRoID0gdGhpcy5jbGllbnRPbmx5RXZlbnRzLmdldChtb250aCkgPz8gW11cblx0XHRjbGllbnRPbmx5RXZlbnRzT2ZUaGlzTW9udGgucHVzaCh7IGJhc2VZZWFyLCBldmVudDogbmV3RXZlbnQgfSlcblx0XHR0aGlzLmNsaWVudE9ubHlFdmVudHMuc2V0KG1vbnRoLCBjbGllbnRPbmx5RXZlbnRzT2ZUaGlzTW9udGgpXG5cdH1cblxuXHRwcml2YXRlIGNyZWF0ZUNsaWVudE9ubHlCaXJ0aGRheUV2ZW50KGNvbnRhY3Q6IENvbnRhY3QsIHVzZXJJZDogSWQpIHtcblx0XHRjb25zdCBlbmNvZGVkQ29udGFjdElkID0gc3RyaW5nVG9CYXNlNjQoY29udGFjdC5faWQuam9pbihcIi9cIikpXG5cdFx0Y29uc3QgY2FsZW5kYXJJZCA9IGAke3VzZXJJZH0jJHtDTElFTlRfT05MWV9DQUxFTkRBUl9CSVJUSERBWVNfQkFTRV9JRH1gXG5cdFx0Y29uc3QgdWlkID0gZ2VuZXJhdGVVaWQoY2FsZW5kYXJJZCwgRGF0ZS5ub3coKSlcblxuXHRcdGNvbnN0IGV2ZW50VGl0bGUgPSB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0QmlydGhkYXlFdmVudFRpdGxlKGNvbnRhY3QuZmlyc3ROYW1lKVxuXG5cdFx0bGV0IGZ1bGxEYXRlSXNvID0gY29udGFjdC5iaXJ0aGRheUlzbyFcblx0XHQvLyBTZXQgdGhlIHllYXIgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBiaXJ0aGRheXMgd2l0aG91dCB5ZWFyXG5cdFx0aWYgKGNvbnRhY3QuYmlydGhkYXlJc28/LnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuXHRcdFx0ZnVsbERhdGVJc28gPSBjb250YWN0LmJpcnRoZGF5SXNvLnJlcGxhY2UoXCItXCIsIFwiMTk3MFwiKVxuXHRcdH1cblxuXHRcdGNvbnN0IGJpcnRoZGF5ID0gbmV3IERhdGUoZnVsbERhdGVJc28hKVxuXG5cdFx0Ly8gU2V0IHVwIHN0YXJ0IGFuZCBlbmQgZGF0ZSBiYXNlIG9uIFVUQy5cblx0XHQvLyBBbHNvIGluY3JlbWVudHMgYSBjb3B5IG9mIHN0YXJ0RGF0ZSBieSBvbmUgZGF5IGFuZCBzZXQgaXQgYXMgZW5kRGF0ZVxuXHRcdGNvbnN0IHN0YXJ0RGF0ZSA9IGdldEFsbERheURhdGVVVEMobmV3IERhdGUoYmlydGhkYXkpKVxuXHRcdGNvbnN0IGVuZERhdGUgPSBnZXRBbGxEYXlEYXRlVVRDKGluY3JlbWVudERhdGUobmV3IERhdGUoc3RhcnREYXRlKSwgMSkpXG5cblx0XHRjb25zdCBuZXdFdmVudCA9IGNyZWF0ZUNhbGVuZGFyRXZlbnQoe1xuXHRcdFx0c2VxdWVuY2U6IFwiMFwiLFxuXHRcdFx0cmVjdXJyZW5jZUlkOiBudWxsLFxuXHRcdFx0aGFzaGVkVWlkOiBudWxsLFxuXHRcdFx0c3VtbWFyeTogZXZlbnRUaXRsZSxcblx0XHRcdHN0YXJ0VGltZTogc3RhcnREYXRlLFxuXHRcdFx0ZW5kVGltZTogZW5kRGF0ZSxcblx0XHRcdGxvY2F0aW9uOiBcIlwiLFxuXHRcdFx0ZGVzY3JpcHRpb246IFwiXCIsIC8vIFRoZSBvbmx5IHZpc2libGUgcGFydCBvZiB0aGUgZXZlbnQgd2lsbCBiZSB0aGUgdGl0bGVcblx0XHRcdGFsYXJtSW5mb3M6IFtdLFxuXHRcdFx0b3JnYW5pemVyOiBudWxsLFxuXHRcdFx0YXR0ZW5kZWVzOiBbXSxcblx0XHRcdGludml0ZWRDb25maWRlbnRpYWxseTogbnVsbCxcblx0XHRcdHJlcGVhdFJ1bGU6IGNyZWF0ZVJlcGVhdFJ1bGVXaXRoVmFsdWVzKFJlcGVhdFBlcmlvZC5BTk5VQUxMWSwgMSksXG5cdFx0XHR1aWQsXG5cdFx0fSlcblxuXHRcdG5ld0V2ZW50Ll9pZCA9IFtjYWxlbmRhcklkLCBgJHtnZW5lcmF0ZUxvY2FsRXZlbnRFbGVtZW50SWQobmV3RXZlbnQuc3RhcnRUaW1lLmdldFRpbWUoKSwgY29udGFjdC5faWQuam9pbihcIi9cIikpfSMke2VuY29kZWRDb250YWN0SWR9YF1cblx0XHRuZXdFdmVudC5fb3duZXJHcm91cCA9IGNhbGVuZGFySWRcblx0XHRyZXR1cm4gbmV3RXZlbnRcblx0fVxuXG5cdGFzeW5jIGxvYWRDb250YWN0c0JpcnRoZGF5cyhmb3JjZVJlbG9hZDogYm9vbGVhbiA9IGZhbHNlKSB7XG5cdFx0Ly8gRG8gbm90IHJlbG9hZCBiaXJ0aGRheXNcblx0XHRpZiAodGhpcy5jbGllbnRPbmx5RXZlbnRzLnNpemUgPiAwICYmICFmb3JjZVJlbG9hZCkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHdvcmsgd2l0aCBhbiBlbXB0eSBtYXAgb2YgYmlydGhkYXlzXG5cdFx0dGhpcy5jbGllbnRPbmx5RXZlbnRzLmNsZWFyKClcblxuXHRcdGNvbnN0IGxpc3RJZCA9IGF3YWl0IHRoaXMuY29udGFjdE1vZGVsLmdldENvbnRhY3RMaXN0SWQoKVxuXHRcdGlmIChsaXN0SWQgPT0gbnVsbCkgcmV0dXJuIFtdXG5cblx0XHRjb25zdCBjb250YWN0cyA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWRBbGwoQ29udGFjdFR5cGVSZWYsIGxpc3RJZClcblx0XHRjb25zdCBmaWx0ZXJlZENvbnRhY3RzID0gY29udGFjdHNcblx0XHRcdC5maWx0ZXIoKGNvbnRhY3QpID0+IGNvbnRhY3QuYmlydGhkYXlJc28pXG5cdFx0XHQuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRjb25zdCBiaXJ0aGRheUNvbnRhY3RBID0gaXNvRGF0ZVRvQmlydGhkYXkoYS5iaXJ0aGRheUlzbyEpXG5cdFx0XHRcdGNvbnN0IGJpcnRoZGF5Q29udGFjdEIgPSBpc29EYXRlVG9CaXJ0aGRheShiLmJpcnRoZGF5SXNvISlcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRuZXcgRGF0ZShgJHtiaXJ0aGRheUNvbnRhY3RBLm1vbnRofS8ke2JpcnRoZGF5Q29udGFjdEEuZGF5fWApLmdldFRpbWUoKSAtXG5cdFx0XHRcdFx0bmV3IERhdGUoYCR7YmlydGhkYXlDb250YWN0Qi5tb250aH0vJHtiaXJ0aGRheUNvbnRhY3RCLmRheX1gKS5nZXRUaW1lKClcblx0XHRcdFx0KVxuXHRcdFx0fSlcblxuXHRcdGZvciAoY29uc3QgY29udGFjdCBvZiBmaWx0ZXJlZENvbnRhY3RzKSB7XG5cdFx0XHRjb25zdCBuZXdFdmVudCA9IHRoaXMuY3JlYXRlQ2xpZW50T25seUJpcnRoZGF5RXZlbnQoY29udGFjdCwgdGhpcy5sb2dpbnMuZ2V0VXNlckNvbnRyb2xsZXIoKS51c2VySWQpXG5cdFx0XHR0aGlzLnB1c2hDbGllbnRPbmx5RXZlbnQobmV3RXZlbnQuc3RhcnRUaW1lLmdldE1vbnRoKCksIG5ld0V2ZW50LCBleHRyYWN0WWVhckZyb21CaXJ0aGRheShjb250YWN0LmJpcnRoZGF5SXNvKSlcblx0XHR9XG5cblx0XHRyZXR1cm4gZmlsdGVyZWRDb250YWN0c1xuXHR9XG5cblx0cmVmcmVzaEJpcnRoZGF5Q2FsZW5kYXIoZGF0ZTogRGF0ZSkge1xuXHRcdGNvbnN0IG1vbnRoID0gZ2V0TW9udGhSYW5nZShkYXRlLCB0aGlzLnpvbmUpXG5cdFx0dGhpcy5hZGRCaXJ0aGRheXNFdmVudHNJZk5lZWRlZChkYXRlLCBtb250aCwgdHJ1ZSlcblx0fVxuXG5cdGFkZEJpcnRoZGF5c0V2ZW50c0lmTmVlZGVkKHNlbGVjdGVkRGF0ZTogRGF0ZSwgbW9udGhSYW5nZUZvclJlY3VycmVuY2U6IENhbGVuZGFyVGltZVJhbmdlLCByZW1vdmVFdmVudE9jY3VycmVuY2VzID0gZmFsc2UpIHtcblx0XHRjb25zdCBjbGllbnRPbmx5RXZlbnRzVGhpc01vbnRoID0gdGhpcy5jbGllbnRPbmx5RXZlbnRzLmdldChzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSlcblx0XHRjb25zdCBiaXJ0aGRheXNPZlRoaXNNb250aCA9IGNsaWVudE9ubHlFdmVudHNUaGlzTW9udGg/LmZpbHRlcigoYmlydGhkYXlFdmVudCkgPT4gaXNCaXJ0aGRheUV2ZW50KGJpcnRoZGF5RXZlbnQuZXZlbnQudWlkKSlcblx0XHRpZiAoYmlydGhkYXlzT2ZUaGlzTW9udGgpIHtcblx0XHRcdGZvciAoY29uc3QgY2FsZW5kYXJFdmVudCBvZiBiaXJ0aGRheXNPZlRoaXNNb250aCkge1xuXHRcdFx0XHRjb25zdCBhZ2UgPSBjYWxjdWxhdGVDb250YWN0c0FnZShjYWxlbmRhckV2ZW50LmJhc2VZZWFyLCBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKSlcblx0XHRcdFx0Y29uc3QgYWdlU3RyaW5nID0gYWdlID8gYCgke3RoaXMuY2FsZW5kYXJNb2RlbC5nZXRBZ2VTdHJpbmcoYWdlKX0pYCA6IFwiXCJcblxuXHRcdFx0XHRpZiAocmVtb3ZlRXZlbnRPY2N1cnJlbmNlcykge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRGF5c0ZvckV2ZW50KGNhbGVuZGFyRXZlbnQuZXZlbnQuX2lkKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYWRkRGF5c0ZvclJlY3VycmluZ0V2ZW50KFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC4uLmNhbGVuZGFyRXZlbnQuZXZlbnQsXG5cdFx0XHRcdFx0XHRzdW1tYXJ5OiBgJHtjYWxlbmRhckV2ZW50LmV2ZW50LnN1bW1hcnl9ICR7YWdlU3RyaW5nfWAsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRtb250aFJhbmdlRm9yUmVjdXJyZW5jZSxcblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBLE1BQU0sMEJBQTBCO0FBRWhDLE1BQU0sTUFBTTtJQWdCQywyQkFBTixNQUErQjs7Q0FFckMsQUFBaUIsZUFBZSxJQUFJO0NBQ3BDLEFBQVEsZUFBcUMsMkJBQU8sSUFBSSxNQUFNO0NBQzlELEFBQVEscUJBQW9DLFFBQVEsU0FBUztDQUU3RCxBQUFRLG1CQUF5RCxJQUFJO0NBRXJFLFlBQ2tCQSxlQUNBQyxnQkFDQUMsTUFDQUMsY0FDQUMsaUJBQ0FDLGNBQ0FDLFFBQ2hCO0VBc1FGLEtBN1FrQjtFQTZRakIsS0E1UWlCO0VBNFFoQixLQTNRZ0I7RUEyUWYsS0ExUWU7RUEwUWQsS0F6UWM7RUF5UWIsS0F4UWE7RUF3UVosS0F2UVk7QUFFakIsa0JBQWdCLGtCQUFrQixDQUFDLFNBQVMsc0JBQXNCLEtBQUsscUJBQXFCLFNBQVMsa0JBQWtCLENBQUM7QUFLeEgsT0FBSyxjQUFjLHdCQUF3QixDQUFDLElBQUksQ0FBQyxVQUFVO0FBQzFELE9BQUksTUFBTSxTQUFTLEdBQUc7QUFDckIsU0FBSyxhQUFhLE9BQU87QUFDekIsU0FBSyxhQUFhLElBQUksTUFBTTtHQUM1QjtFQUNELEVBQUM7Q0FDRjtDQUVELHFCQUEyQztBQUMxQyxTQUFPLEtBQUs7Q0FDWjtDQUVELG9CQUEwRDtBQUN6RCxTQUFPLEtBQUs7Q0FDWjtDQUVELE1BQU0sMkJBQTZDO0FBQ2xELFNBQU8sTUFBTSxLQUFLLE9BQU8sbUJBQW1CLENBQUMsZUFBZTtDQUM1RDtDQUVELE1BQU0sbUJBQW1CQyxjQUEyQkMsaUJBQW1DQyxVQUEwQztFQUNoSSxNQUFNLDRCQUE0QixLQUFLLG1CQUFtQixLQUFLLFlBQVk7QUFDMUUsUUFBSyxNQUFNLGNBQWMsY0FBYztBQUN0QyxRQUFJ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