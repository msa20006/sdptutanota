import { LazyLoaded, assertNotNull, concat, downcast, isSameTypeRefByAttr, stringToUtf8Uint8Array, utf8Uint8ArrayToString } from "./dist2-chunk.js";
import { ExternalImageRule, OperationType } from "./TutanotaConstants-chunk.js";
import { UserTypeRef } from "./TypeRefs2-chunk.js";
import { DbError } from "./DbError-chunk.js";
import { IV_BYTE_LENGTH, aes256RandomKey, aesEncrypt, decryptKey, random, unauthenticatedAesDecrypt } from "./dist3-chunk.js";
import { encryptKeyWithVersionedKey } from "./CryptoWrapper-chunk.js";
import { DbFacade, Metadata, b64UserIdHash } from "./IndexTables-chunk.js";

//#region src/common/api/worker/facades/lazy/ConfigurationDatabase.ts
const VERSION = 2;
const DB_KEY_PREFIX = "ConfigStorage";
const ExternalImageListOS = "ExternalAllowListOS";
const ConfigurationMetaDataOS = "MetaDataOS";
async function encryptItem(item, key, iv) {
	return aesEncrypt(key, stringToUtf8Uint8Array(item), iv, true);
}
async function decryptLegacyItem(encryptedAddress, key, iv) {
	return utf8Uint8ArrayToString(unauthenticatedAesDecrypt(key, concat(iv, encryptedAddress)));
}
var ConfigurationDatabase = class {
	db;
	constructor(keyLoaderFacade, userFacade, dbLoadFn = (user, keyLoaderFacade$1) => this.loadConfigDb(user, keyLoaderFacade$1)) {
		this.keyLoaderFacade = keyLoaderFacade;
		this.db = new LazyLoaded(() => {
			const user = assertNotNull(userFacade.getLoggedInUser());
			return dbLoadFn(user, keyLoaderFacade);
		});
	}
	async addExternalImageRule(address, rule) {
		const { db, metaData } = await this.db.getAsync();
		if (!db.indexingSupported) return;
		const encryptedAddress = await encryptItem(address, metaData.key, metaData.iv);
		return addAddressToImageList(db, encryptedAddress, rule);
	}
	async getExternalImageRule(address) {
		const { db, metaData } = await this.db.getAsync();
		if (!db.indexingSupported) return ExternalImageRule.None;
		const encryptedAddress = await encryptItem(address, metaData.key, metaData.iv);
		const transaction = await db.createTransaction(true, [ExternalImageListOS]);
		const entry = await transaction.get(ExternalImageListOS, encryptedAddress);
		let rule = ExternalImageRule.None;
		if (entry != null) if (entry.rule != null) rule = entry.rule;
else {
			await addAddressToImageList(db, encryptedAddress, ExternalImageRule.Allow);
			rule = ExternalImageRule.Allow;
		}
		return rule;
	}
	async loadConfigDb(user, keyLoaderFacade) {
		const id = this.getDbId(user._id);
		const db = new DbFacade(VERSION, async (event, db$1, dbFacade) => {
			if (event.oldVersion === 0) {
				db$1.createObjectStore(ConfigurationMetaDataOS);
				db$1.createObjectStore(ExternalImageListOS, { keyPath: "address" });
			}
			const metaData$1 = await loadEncryptionMetadata(dbFacade, id, keyLoaderFacade, ConfigurationMetaDataOS) || await initializeDb(dbFacade, id, keyLoaderFacade, ConfigurationMetaDataOS);
			if (event.oldVersion === 1) {
				const transaction = await dbFacade.createTransaction(true, [ExternalImageListOS]);
				const entries = await transaction.getAll(ExternalImageListOS);
				const { key, iv } = metaData$1;
				for (const entry of entries) {
					const address = await decryptLegacyItem(new Uint8Array(downcast(entry.key)), key, iv);
					await this.addExternalImageRule(address, entry.value.rule);
					const deleteTransaction = await dbFacade.createTransaction(false, [ExternalImageListOS]);
					await deleteTransaction.delete(ExternalImageListOS, entry.key);
				}
			}
		});
		const metaData = await loadEncryptionMetadata(db, id, keyLoaderFacade, ConfigurationMetaDataOS) || await initializeDb(db, id, keyLoaderFacade, ConfigurationMetaDataOS);
		return {
			db,
			metaData
		};
	}
	async onEntityEventsReceived(batch) {
		const { events, groupId, batchId } = batch;
		for (const event of events) {
			if (!(event.operation === OperationType.UPDATE && isSameTypeRefByAttr(UserTypeRef, event.application, event.type))) continue;
			const configDb = await this.db.getAsync();
			if (configDb.db.isSameDbId(this.getDbId(event.instanceId))) return updateEncryptionMetadata(configDb.db, this.keyLoaderFacade, ConfigurationMetaDataOS);
		}
	}
	async delete(userId) {
		const dbId = this.getDbId(userId);
		if (this.db.isLoadedOrLoading()) {
			const { db } = await this.db.getAsync();
			await db.deleteDatabase(dbId);
		} else await DbFacade.deleteDb(dbId);
	}
	getDbId(userId) {
		return `${DB_KEY_PREFIX}_${b64UserIdHash(userId)}`;
	}
};
async function decryptMetaData(keyLoaderFacade, metaData) {
	const userGroupKey = await keyLoaderFacade.loadSymUserGroupKey(metaData.userGroupKeyVersion);
	const key = decryptKey(userGroupKey, metaData.userEncDbKey);
	const iv = unauthenticatedAesDecrypt(key, metaData.encDbIv);
	return {
		key,
		iv
	};
}
async function loadEncryptionMetadata(db, id, keyLoaderFacade, objectStoreName) {
	await db.open(id);
	const metaData = await getMetaData(db, objectStoreName);
	if (metaData != null) return await decryptMetaData(keyLoaderFacade, metaData);
else return null;
}
async function updateEncryptionMetadata(db, keyLoaderFacade, objectStoreName) {
	const metaData = await getMetaData(db, objectStoreName);
	const currentUserGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey();
	if (metaData == null || currentUserGroupKey.version === metaData.userGroupKeyVersion) return;
	const encryptionMetadata = await decryptMetaData(keyLoaderFacade, metaData);
	if (encryptionMetadata == null) return;
	const { key, iv } = encryptionMetadata;
	await encryptAndSaveDbKey(currentUserGroupKey, key, iv, db, objectStoreName);
}
async function getMetaData(db, objectStoreName) {
	const transaction = await db.createTransaction(true, [objectStoreName]);
	const userEncDbKey = await transaction.get(objectStoreName, Metadata.userEncDbKey);
	const encDbIv = await transaction.get(objectStoreName, Metadata.encDbIv);
	const userGroupKeyVersion = await transaction.get(objectStoreName, Metadata.userGroupKeyVersion) ?? 0;
	if (userEncDbKey == null || encDbIv == null) return null;
else return {
		userEncDbKey,
		encDbIv,
		userGroupKeyVersion
	};
}
async function getIndexerMetaData(db, objectStoreName) {
	const transaction = await db.createTransaction(true, [objectStoreName]);
	const userEncDbKey = await transaction.get(objectStoreName, Metadata.userEncDbKey);
	const encDbIv = await transaction.get(objectStoreName, Metadata.encDbIv);
	const userGroupKeyVersion = await transaction.get(objectStoreName, Metadata.userGroupKeyVersion) ?? 0;
	const mailIndexingEnabled = await transaction.get(objectStoreName, Metadata.mailIndexingEnabled);
	const excludedListIds = await transaction.get(objectStoreName, Metadata.excludedListIds);
	const lastEventIndexTimeMs = await transaction.get(objectStoreName, Metadata.lastEventIndexTimeMs);
	if (userEncDbKey == null || encDbIv == null) return null;
else return {
		userEncDbKey,
		encDbIv,
		userGroupKeyVersion,
		mailIndexingEnabled,
		excludedListIds,
		lastEventIndexTimeMs
	};
}
async function encryptAndSaveDbKey(userGroupKey, dbKey, dbIv, db, objectStoreName) {
	const transaction = await db.createTransaction(false, [objectStoreName]);
	const groupEncSessionKey = encryptKeyWithVersionedKey(userGroupKey, dbKey);
	await transaction.put(objectStoreName, Metadata.userEncDbKey, groupEncSessionKey.key);
	await transaction.put(objectStoreName, Metadata.userGroupKeyVersion, groupEncSessionKey.encryptingKeyVersion);
	await transaction.put(objectStoreName, Metadata.encDbIv, aesEncrypt(dbKey, dbIv));
}
async function initializeDb(db, id, keyLoaderFacade, objectStoreName) {
	await db.deleteDatabase(id).then(() => db.open(id));
	const key = aes256RandomKey();
	const iv = random.generateRandomData(IV_BYTE_LENGTH);
	const userGroupKey = keyLoaderFacade.getCurrentSymUserGroupKey();
	await encryptAndSaveDbKey(userGroupKey, key, iv, db, objectStoreName);
	return {
		key,
		iv
	};
}
async function addAddressToImageList(db, encryptedAddress, rule) {
	try {
		const transaction = await db.createTransaction(false, [ExternalImageListOS]);
		await transaction.put(ExternalImageListOS, null, {
			address: encryptedAddress,
			rule
		});
	} catch (e) {
		if (e instanceof DbError) {
			console.error("failed to add address to image list:", e.message);
			return;
		}
		throw e;
	}
}

//#endregion
export { ConfigurationDatabase, ConfigurationMetaDataOS, decryptLegacyItem, encryptItem, getIndexerMetaData, getMetaData, initializeDb, loadEncryptionMetadata, updateEncryptionMetadata };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29uZmlndXJhdGlvbkRhdGFiYXNlLWNodW5rLmpzIiwibmFtZXMiOlsiVkVSU0lPTjogbnVtYmVyIiwiREJfS0VZX1BSRUZJWDogc3RyaW5nIiwiRXh0ZXJuYWxJbWFnZUxpc3RPUzogT2JqZWN0U3RvcmVOYW1lIiwiQ29uZmlndXJhdGlvbk1ldGFEYXRhT1M6IE9iamVjdFN0b3JlTmFtZSIsIml0ZW06IHN0cmluZyIsImtleTogQWVzMjU2S2V5IiwiaXY6IFVpbnQ4QXJyYXkiLCJlbmNyeXB0ZWRBZGRyZXNzOiBVaW50OEFycmF5Iiwia2V5TG9hZGVyRmFjYWRlOiBLZXlMb2FkZXJGYWNhZGUiLCJ1c2VyRmFjYWRlOiBVc2VyRmFjYWRlIiwiZGJMb2FkRm46IChhcmcwOiBVc2VyLCBhcmcxOiBLZXlMb2FkZXJGYWNhZGUpID0+IFByb21pc2U8Q29uZmlnRGI+IiwidXNlcjogVXNlciIsImtleUxvYWRlckZhY2FkZSIsImFkZHJlc3M6IHN0cmluZyIsInJ1bGU6IEV4dGVybmFsSW1hZ2VSdWxlIiwiZGIiLCJtZXRhRGF0YSIsImJhdGNoOiBRdWV1ZWRCYXRjaCIsInVzZXJJZDogSWQiLCJtZXRhRGF0YTogRW5jcnlwdGVkRGJLZXlCYXNlTWV0YURhdGEiLCJkYjogRGJGYWNhZGUiLCJpZDogc3RyaW5nIiwib2JqZWN0U3RvcmVOYW1lOiBPYmplY3RTdG9yZU5hbWUiLCJ1c2VyR3JvdXBLZXk6IFZlcnNpb25lZEtleSIsImRiS2V5OiBBZXNLZXkiLCJkYkl2OiBVaW50OEFycmF5Iiwib2JqZWN0U3RvcmVOYW1lOiBzdHJpbmciXSwic291cmNlcyI6WyIuLi9zcmMvY29tbW9uL2FwaS93b3JrZXIvZmFjYWRlcy9sYXp5L0NvbmZpZ3VyYXRpb25EYXRhYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiNjRVc2VySWRIYXNoLCBEYkZhY2FkZSB9IGZyb20gXCIuLi8uLi9zZWFyY2gvRGJGYWNhZGUuanNcIlxuaW1wb3J0IHsgYXNzZXJ0Tm90TnVsbCwgY29uY2F0LCBkb3duY2FzdCwgaXNTYW1lVHlwZVJlZkJ5QXR0ciwgTGF6eUxvYWRlZCwgc3RyaW5nVG9VdGY4VWludDhBcnJheSwgdXRmOFVpbnQ4QXJyYXlUb1N0cmluZyB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgVXNlciwgVXNlclR5cGVSZWYgfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvc3lzL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IEV4dGVybmFsSW1hZ2VSdWxlLCBPcGVyYXRpb25UeXBlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9UdXRhbm90YUNvbnN0YW50cy5qc1wiXG5pbXBvcnQge1xuXHRBZXMxMjhLZXksXG5cdEFlczI1NktleSxcblx0YWVzMjU2UmFuZG9tS2V5LFxuXHRhZXNFbmNyeXB0LFxuXHRBZXNLZXksXG5cdGRlY3J5cHRLZXksXG5cdElWX0JZVEVfTEVOR1RILFxuXHRyYW5kb20sXG5cdHVuYXV0aGVudGljYXRlZEFlc0RlY3J5cHQsXG59IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtY3J5cHRvXCJcbmltcG9ydCB7IFVzZXJGYWNhZGUgfSBmcm9tIFwiLi4vVXNlckZhY2FkZS5qc1wiXG5pbXBvcnQgeyBFbmNyeXB0ZWREYktleUJhc2VNZXRhRGF0YSwgRW5jcnlwdGVkSW5kZXhlck1ldGFEYXRhLCBNZXRhZGF0YSwgT2JqZWN0U3RvcmVOYW1lIH0gZnJvbSBcIi4uLy4uL3NlYXJjaC9JbmRleFRhYmxlcy5qc1wiXG5pbXBvcnQgeyBEYkVycm9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9lcnJvci9EYkVycm9yLmpzXCJcbmltcG9ydCB7IEtleUxvYWRlckZhY2FkZSB9IGZyb20gXCIuLi9LZXlMb2FkZXJGYWNhZGUuanNcIlxuaW1wb3J0IHR5cGUgeyBRdWV1ZWRCYXRjaCB9IGZyb20gXCIuLi8uLi9FdmVudFF1ZXVlLmpzXCJcbmltcG9ydCB7IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5LCBWZXJzaW9uZWRLZXkgfSBmcm9tIFwiLi4vLi4vY3J5cHRvL0NyeXB0b1dyYXBwZXIuanNcIlxuXG5jb25zdCBWRVJTSU9OOiBudW1iZXIgPSAyXG5jb25zdCBEQl9LRVlfUFJFRklYOiBzdHJpbmcgPSBcIkNvbmZpZ1N0b3JhZ2VcIlxuY29uc3QgRXh0ZXJuYWxJbWFnZUxpc3RPUzogT2JqZWN0U3RvcmVOYW1lID0gXCJFeHRlcm5hbEFsbG93TGlzdE9TXCJcbmV4cG9ydCBjb25zdCBDb25maWd1cmF0aW9uTWV0YURhdGFPUzogT2JqZWN0U3RvcmVOYW1lID0gXCJNZXRhRGF0YU9TXCJcbnR5cGUgRW5jcnlwdGlvbk1ldGFkYXRhID0ge1xuXHRyZWFkb25seSBrZXk6IEFlczEyOEtleVxuXHRyZWFkb25seSBpdjogVWludDhBcnJheVxufVxudHlwZSBDb25maWdEYiA9IHtcblx0cmVhZG9ubHkgZGI6IERiRmFjYWRlXG5cdHJlYWRvbmx5IG1ldGFEYXRhOiBFbmNyeXB0aW9uTWV0YWRhdGFcbn1cblxuLyoqIEBQdWJsaWNGb3JUZXN0aW5nICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEl0ZW0oaXRlbTogc3RyaW5nLCBrZXk6IEFlczI1NktleSwgaXY6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcblx0cmV0dXJuIGFlc0VuY3J5cHQoa2V5LCBzdHJpbmdUb1V0ZjhVaW50OEFycmF5KGl0ZW0pLCBpdiwgdHJ1ZSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRMZWdhY3lJdGVtKGVuY3J5cHRlZEFkZHJlc3M6IFVpbnQ4QXJyYXksIGtleTogQWVzMjU2S2V5LCBpdjogVWludDhBcnJheSk6IFByb21pc2U8c3RyaW5nPiB7XG5cdHJldHVybiB1dGY4VWludDhBcnJheVRvU3RyaW5nKHVuYXV0aGVudGljYXRlZEFlc0RlY3J5cHQoa2V5LCBjb25jYXQoaXYsIGVuY3J5cHRlZEFkZHJlc3MpKSlcbn1cblxuLyoqXG4gKiBBIGxvY2FsIGNvbmZpZ3VyYXRpb24gZGF0YWJhc2UgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBEZXZpY2VDb25maWc6XG4gKiBJZGVhbCBmb3IgY2FzZXMgd2hlcmUgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWVzIHNob3VsZCBiZSBzdG9yZWQgZW5jcnlwdGVkLFxuICogT3Igd2hlbiB0aGUgY29uZmlndXJhdGlvbiBpcyBhIGdyb3dpbmcgbGlzdCBvciBvYmplY3QsIHdoaWNoIHdvdWxkIGJlIHVuc3VpdGFibGUgZm9yIGxvY2FsU3RvcmFnZVxuICogT3Igd2hlbiB0aGUgY29uZmlndXJhdGlvbiBpcyBvbmx5IHJlcXVpcmVkIGluIHRoZSBXb3JrZXJcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYXRpb25EYXRhYmFzZSB7XG5cdC8vIHZpc2libGUgZm9yIHRlc3Rpbmdcblx0cmVhZG9ubHkgZGI6IExhenlMb2FkZWQ8Q29uZmlnRGI+XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSByZWFkb25seSBrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSxcblx0XHR1c2VyRmFjYWRlOiBVc2VyRmFjYWRlLFxuXHRcdGRiTG9hZEZuOiAoYXJnMDogVXNlciwgYXJnMTogS2V5TG9hZGVyRmFjYWRlKSA9PiBQcm9taXNlPENvbmZpZ0RiPiA9ICh1c2VyOiBVc2VyLCBrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSkgPT5cblx0XHRcdHRoaXMubG9hZENvbmZpZ0RiKHVzZXIsIGtleUxvYWRlckZhY2FkZSksXG5cdCkge1xuXHRcdHRoaXMuZGIgPSBuZXcgTGF6eUxvYWRlZCgoKSA9PiB7XG5cdFx0XHRjb25zdCB1c2VyID0gYXNzZXJ0Tm90TnVsbCh1c2VyRmFjYWRlLmdldExvZ2dlZEluVXNlcigpKVxuXHRcdFx0cmV0dXJuIGRiTG9hZEZuKHVzZXIsIGtleUxvYWRlckZhY2FkZSlcblx0XHR9KVxuXHR9XG5cblx0YXN5bmMgYWRkRXh0ZXJuYWxJbWFnZVJ1bGUoYWRkcmVzczogc3RyaW5nLCBydWxlOiBFeHRlcm5hbEltYWdlUnVsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHsgZGIsIG1ldGFEYXRhIH0gPSBhd2FpdCB0aGlzLmRiLmdldEFzeW5jKClcblx0XHRpZiAoIWRiLmluZGV4aW5nU3VwcG9ydGVkKSByZXR1cm5cblx0XHRjb25zdCBlbmNyeXB0ZWRBZGRyZXNzID0gYXdhaXQgZW5jcnlwdEl0ZW0oYWRkcmVzcywgbWV0YURhdGEua2V5LCBtZXRhRGF0YS5pdilcblx0XHRyZXR1cm4gYWRkQWRkcmVzc1RvSW1hZ2VMaXN0KGRiLCBlbmNyeXB0ZWRBZGRyZXNzLCBydWxlKVxuXHR9XG5cblx0YXN5bmMgZ2V0RXh0ZXJuYWxJbWFnZVJ1bGUoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxFeHRlcm5hbEltYWdlUnVsZT4ge1xuXHRcdGNvbnN0IHsgZGIsIG1ldGFEYXRhIH0gPSBhd2FpdCB0aGlzLmRiLmdldEFzeW5jKClcblx0XHRpZiAoIWRiLmluZGV4aW5nU3VwcG9ydGVkKSByZXR1cm4gRXh0ZXJuYWxJbWFnZVJ1bGUuTm9uZVxuXHRcdGNvbnN0IGVuY3J5cHRlZEFkZHJlc3MgPSBhd2FpdCBlbmNyeXB0SXRlbShhZGRyZXNzLCBtZXRhRGF0YS5rZXksIG1ldGFEYXRhLml2KVxuXHRcdGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgZGIuY3JlYXRlVHJhbnNhY3Rpb24odHJ1ZSwgW0V4dGVybmFsSW1hZ2VMaXN0T1NdKVxuXHRcdGNvbnN0IGVudHJ5ID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KEV4dGVybmFsSW1hZ2VMaXN0T1MsIGVuY3J5cHRlZEFkZHJlc3MpXG5cdFx0bGV0IHJ1bGUgPSBFeHRlcm5hbEltYWdlUnVsZS5Ob25lXG5cblx0XHRpZiAoZW50cnkgIT0gbnVsbCkge1xuXHRcdFx0aWYgKGVudHJ5LnJ1bGUgIT0gbnVsbCkge1xuXHRcdFx0XHRydWxlID0gZW50cnkucnVsZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTm8gcnVsZSBzZXQgZnJvbSBlYXJsaWVyIHZlcnNpb24gbWVhbnMgQWxsb3dcblx0XHRcdFx0YXdhaXQgYWRkQWRkcmVzc1RvSW1hZ2VMaXN0KGRiLCBlbmNyeXB0ZWRBZGRyZXNzLCBFeHRlcm5hbEltYWdlUnVsZS5BbGxvdylcblx0XHRcdFx0cnVsZSA9IEV4dGVybmFsSW1hZ2VSdWxlLkFsbG93XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJ1bGVcblx0fVxuXG5cdGFzeW5jIGxvYWRDb25maWdEYih1c2VyOiBVc2VyLCBrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSk6IFByb21pc2U8Q29uZmlnRGI+IHtcblx0XHRjb25zdCBpZCA9IHRoaXMuZ2V0RGJJZCh1c2VyLl9pZClcblx0XHRjb25zdCBkYiA9IG5ldyBEYkZhY2FkZShWRVJTSU9OLCBhc3luYyAoZXZlbnQsIGRiLCBkYkZhY2FkZSkgPT4ge1xuXHRcdFx0aWYgKGV2ZW50Lm9sZFZlcnNpb24gPT09IDApIHtcblx0XHRcdFx0ZGIuY3JlYXRlT2JqZWN0U3RvcmUoQ29uZmlndXJhdGlvbk1ldGFEYXRhT1MpXG5cdFx0XHRcdGRiLmNyZWF0ZU9iamVjdFN0b3JlKEV4dGVybmFsSW1hZ2VMaXN0T1MsIHtcblx0XHRcdFx0XHRrZXlQYXRoOiBcImFkZHJlc3NcIixcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdGNvbnN0IG1ldGFEYXRhID1cblx0XHRcdFx0KGF3YWl0IGxvYWRFbmNyeXB0aW9uTWV0YWRhdGEoZGJGYWNhZGUsIGlkLCBrZXlMb2FkZXJGYWNhZGUsIENvbmZpZ3VyYXRpb25NZXRhRGF0YU9TKSkgfHxcblx0XHRcdFx0KGF3YWl0IGluaXRpYWxpemVEYihkYkZhY2FkZSwgaWQsIGtleUxvYWRlckZhY2FkZSwgQ29uZmlndXJhdGlvbk1ldGFEYXRhT1MpKVxuXG5cdFx0XHRpZiAoZXZlbnQub2xkVmVyc2lvbiA9PT0gMSkge1xuXHRcdFx0XHQvLyBtaWdyYXRlIGZyb20gcGxhaW4sIG1hYy1hbmQtc3RhdGljLWl2IGFlczI1NiB0byBhZXMyNTYgd2l0aCBtYWNcblx0XHRcdFx0Y29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBkYkZhY2FkZS5jcmVhdGVUcmFuc2FjdGlvbih0cnVlLCBbRXh0ZXJuYWxJbWFnZUxpc3RPU10pXG5cdFx0XHRcdGNvbnN0IGVudHJpZXMgPSBhd2FpdCB0cmFuc2FjdGlvbi5nZXRBbGwoRXh0ZXJuYWxJbWFnZUxpc3RPUylcblx0XHRcdFx0Y29uc3QgeyBrZXksIGl2IH0gPSBtZXRhRGF0YVxuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRjb25zdCBhZGRyZXNzID0gYXdhaXQgZGVjcnlwdExlZ2FjeUl0ZW0obmV3IFVpbnQ4QXJyYXkoZG93bmNhc3QoZW50cnkua2V5KSksIGtleSwgaXYpXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5hZGRFeHRlcm5hbEltYWdlUnVsZShhZGRyZXNzLCBlbnRyeS52YWx1ZS5ydWxlKVxuXHRcdFx0XHRcdGNvbnN0IGRlbGV0ZVRyYW5zYWN0aW9uID0gYXdhaXQgZGJGYWNhZGUuY3JlYXRlVHJhbnNhY3Rpb24oZmFsc2UsIFtFeHRlcm5hbEltYWdlTGlzdE9TXSlcblx0XHRcdFx0XHRhd2FpdCBkZWxldGVUcmFuc2FjdGlvbi5kZWxldGUoRXh0ZXJuYWxJbWFnZUxpc3RPUywgZW50cnkua2V5KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0XHRjb25zdCBtZXRhRGF0YSA9XG5cdFx0XHQoYXdhaXQgbG9hZEVuY3J5cHRpb25NZXRhZGF0YShkYiwgaWQsIGtleUxvYWRlckZhY2FkZSwgQ29uZmlndXJhdGlvbk1ldGFEYXRhT1MpKSB8fFxuXHRcdFx0KGF3YWl0IGluaXRpYWxpemVEYihkYiwgaWQsIGtleUxvYWRlckZhY2FkZSwgQ29uZmlndXJhdGlvbk1ldGFEYXRhT1MpKVxuXHRcdHJldHVybiB7XG5cdFx0XHRkYixcblx0XHRcdG1ldGFEYXRhLFxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIG9uRW50aXR5RXZlbnRzUmVjZWl2ZWQoYmF0Y2g6IFF1ZXVlZEJhdGNoKTogUHJvbWlzZTxhbnk+IHtcblx0XHRjb25zdCB7IGV2ZW50cywgZ3JvdXBJZCwgYmF0Y2hJZCB9ID0gYmF0Y2hcblx0XHRmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuXHRcdFx0aWYgKCEoZXZlbnQub3BlcmF0aW9uID09PSBPcGVyYXRpb25UeXBlLlVQREFURSAmJiBpc1NhbWVUeXBlUmVmQnlBdHRyKFVzZXJUeXBlUmVmLCBldmVudC5hcHBsaWNhdGlvbiwgZXZlbnQudHlwZSkpKSB7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjb25maWdEYiA9IGF3YWl0IHRoaXMuZGIuZ2V0QXN5bmMoKVxuXHRcdFx0aWYgKGNvbmZpZ0RiLmRiLmlzU2FtZURiSWQodGhpcy5nZXREYklkKGV2ZW50Lmluc3RhbmNlSWQpKSkge1xuXHRcdFx0XHRyZXR1cm4gdXBkYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGNvbmZpZ0RiLmRiLCB0aGlzLmtleUxvYWRlckZhY2FkZSwgQ29uZmlndXJhdGlvbk1ldGFEYXRhT1MpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgZGVsZXRlKHVzZXJJZDogSWQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBkYklkID0gdGhpcy5nZXREYklkKHVzZXJJZClcblx0XHRpZiAodGhpcy5kYi5pc0xvYWRlZE9yTG9hZGluZygpKSB7XG5cdFx0XHRjb25zdCB7IGRiIH0gPSBhd2FpdCB0aGlzLmRiLmdldEFzeW5jKClcblx0XHRcdGF3YWl0IGRiLmRlbGV0ZURhdGFiYXNlKGRiSWQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGF3YWl0IERiRmFjYWRlLmRlbGV0ZURiKGRiSWQpXG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBnZXREYklkKHVzZXJJZDogSWQpOiBzdHJpbmcge1xuXHRcdHJldHVybiBgJHtEQl9LRVlfUFJFRklYfV8ke2I2NFVzZXJJZEhhc2godXNlcklkKX1gXG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdE1ldGFEYXRhKGtleUxvYWRlckZhY2FkZTogS2V5TG9hZGVyRmFjYWRlLCBtZXRhRGF0YTogRW5jcnlwdGVkRGJLZXlCYXNlTWV0YURhdGEpOiBQcm9taXNlPEVuY3J5cHRpb25NZXRhZGF0YT4ge1xuXHRjb25zdCB1c2VyR3JvdXBLZXkgPSBhd2FpdCBrZXlMb2FkZXJGYWNhZGUubG9hZFN5bVVzZXJHcm91cEtleShtZXRhRGF0YS51c2VyR3JvdXBLZXlWZXJzaW9uKVxuXHRjb25zdCBrZXkgPSBkZWNyeXB0S2V5KHVzZXJHcm91cEtleSwgbWV0YURhdGEudXNlckVuY0RiS2V5KVxuXHRjb25zdCBpdiA9IHVuYXV0aGVudGljYXRlZEFlc0RlY3J5cHQoa2V5LCBtZXRhRGF0YS5lbmNEYkl2KVxuXHRyZXR1cm4ge1xuXHRcdGtleSxcblx0XHRpdixcblx0fVxufVxuXG4vKipcbiAqIExvYWQgdGhlIGVuY3J5cHRpb24ga2V5IGFuZCBpdiBmcm9tIHRoZSBkYlxuICogQHJldHVybiB7IGtleSwgaXYgfSBvciBudWxsIGlmIG9uZSBvciBib3RoIGRvbid0IGV4aXN0XG4gKiBAVmlzaWJsZUZvclRlc3RpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRFbmNyeXB0aW9uTWV0YWRhdGEoXG5cdGRiOiBEYkZhY2FkZSxcblx0aWQ6IHN0cmluZyxcblx0a2V5TG9hZGVyRmFjYWRlOiBLZXlMb2FkZXJGYWNhZGUsXG5cdG9iamVjdFN0b3JlTmFtZTogT2JqZWN0U3RvcmVOYW1lLFxuKTogUHJvbWlzZTxFbmNyeXB0aW9uTWV0YWRhdGEgfCBudWxsPiB7XG5cdGF3YWl0IGRiLm9wZW4oaWQpXG5cdGNvbnN0IG1ldGFEYXRhID0gYXdhaXQgZ2V0TWV0YURhdGEoZGIsIG9iamVjdFN0b3JlTmFtZSlcblx0aWYgKG1ldGFEYXRhICE9IG51bGwpIHtcblx0XHRyZXR1cm4gYXdhaXQgZGVjcnlwdE1ldGFEYXRhKGtleUxvYWRlckZhY2FkZSwgbWV0YURhdGEpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG51bGxcblx0fVxufVxuXG4vKipcbiAqIFJlZW5jcnlwdCB0aGUgREIga2V5IGFuZCBJViBpZiB0aGVyZSBpcyBhIG5ldyB1c2VyR3JvdXBLZXlcbiAqIEBWaXNpYmxlRm9yVGVzdGluZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGRiOiBEYkZhY2FkZSwga2V5TG9hZGVyRmFjYWRlOiBLZXlMb2FkZXJGYWNhZGUsIG9iamVjdFN0b3JlTmFtZTogT2JqZWN0U3RvcmVOYW1lKTogUHJvbWlzZTx2b2lkPiB7XG5cdGNvbnN0IG1ldGFEYXRhID0gYXdhaXQgZ2V0TWV0YURhdGEoZGIsIG9iamVjdFN0b3JlTmFtZSlcblx0Y29uc3QgY3VycmVudFVzZXJHcm91cEtleSA9IGtleUxvYWRlckZhY2FkZS5nZXRDdXJyZW50U3ltVXNlckdyb3VwS2V5KClcblxuXHRpZiAobWV0YURhdGEgPT0gbnVsbCB8fCBjdXJyZW50VXNlckdyb3VwS2V5LnZlcnNpb24gPT09IG1ldGFEYXRhLnVzZXJHcm91cEtleVZlcnNpb24pIHJldHVyblxuXG5cdGNvbnN0IGVuY3J5cHRpb25NZXRhZGF0YSA9IGF3YWl0IGRlY3J5cHRNZXRhRGF0YShrZXlMb2FkZXJGYWNhZGUsIG1ldGFEYXRhKVxuXHRpZiAoZW5jcnlwdGlvbk1ldGFkYXRhID09IG51bGwpIHJldHVyblxuXHRjb25zdCB7IGtleSwgaXYgfSA9IGVuY3J5cHRpb25NZXRhZGF0YVxuXHRhd2FpdCBlbmNyeXB0QW5kU2F2ZURiS2V5KGN1cnJlbnRVc2VyR3JvdXBLZXksIGtleSwgaXYsIGRiLCBvYmplY3RTdG9yZU5hbWUpXG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgZ3JvdXAga2V5IHZlcnNpb24gZm9yIHRoZSBncm91cCBrZXkgdGhhdCB3YXMgdXNlZCB0byBlbmNyeXB0IHRoZSBkYiBrZXkuIEluIGNhc2UgdGhlIHZlcnNpb24gaGFzIG5vdCBiZWVuIHdyaXR0ZW4gdG8gdGhlIGRiIHdlIGFzc3VtZSAwLlxuICogQHBhcmFtIGRiIHRoZSBkYkZhY2FkZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBvYmplY3Qgc3RvcmVcbiAqIEBwYXJhbSBvYmplY3RTdG9yZU5hbWUgdGhlIG9iamVjdFN0b3JlIHRvIGdldCB0aGUgbWV0YWRhdGEgZnJvbVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWV0YURhdGEoZGI6IERiRmFjYWRlLCBvYmplY3RTdG9yZU5hbWU6IE9iamVjdFN0b3JlTmFtZSk6IFByb21pc2U8RW5jcnlwdGVkRGJLZXlCYXNlTWV0YURhdGEgfCBudWxsPiB7XG5cdGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgZGIuY3JlYXRlVHJhbnNhY3Rpb24odHJ1ZSwgW29iamVjdFN0b3JlTmFtZV0pXG5cdGNvbnN0IHVzZXJFbmNEYktleSA9IChhd2FpdCB0cmFuc2FjdGlvbi5nZXQob2JqZWN0U3RvcmVOYW1lLCBNZXRhZGF0YS51c2VyRW5jRGJLZXkpKSBhcyBVaW50OEFycmF5XG5cdGNvbnN0IGVuY0RiSXYgPSAoYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KG9iamVjdFN0b3JlTmFtZSwgTWV0YWRhdGEuZW5jRGJJdikpIGFzIFVpbnQ4QXJyYXlcblx0Y29uc3QgdXNlckdyb3VwS2V5VmVyc2lvbiA9IChhd2FpdCB0cmFuc2FjdGlvbi5nZXQ8bnVtYmVyPihvYmplY3RTdG9yZU5hbWUsIE1ldGFkYXRhLnVzZXJHcm91cEtleVZlcnNpb24pKSA/PyAwIC8vIHdhcyBub3Qgd3JpdHRlbiBmb3Igb2xkIGRic1xuXHRpZiAodXNlckVuY0RiS2V5ID09IG51bGwgfHwgZW5jRGJJdiA9PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGxcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dXNlckVuY0RiS2V5LFxuXHRcdFx0ZW5jRGJJdixcblx0XHRcdHVzZXJHcm91cEtleVZlcnNpb24sXG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgZ3JvdXAga2V5IHZlcnNpb24gZm9yIHRoZSBncm91cCBrZXkgdGhhdCB3YXMgdXNlZCB0byBlbmNyeXB0IHRoZSBkYiBrZXkuIEluIGNhc2UgdGhlIHZlcnNpb24gaGFzIG5vdCBiZWVuIHdyaXR0ZW4gdG8gdGhlIGRiIHdlIGFzc3VtZSAwLlxuICogQHBhcmFtIGRiIHRoZSBkYkZhY2FkZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBvYmplY3Qgc3RvcmVcbiAqIEBwYXJhbSBvYmplY3RTdG9yZU5hbWUgdGhlIG9iamVjdFN0b3JlIHRvIGdldCB0aGUgbWV0YWRhdGEgZnJvbVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SW5kZXhlck1ldGFEYXRhKGRiOiBEYkZhY2FkZSwgb2JqZWN0U3RvcmVOYW1lOiBPYmplY3RTdG9yZU5hbWUpOiBQcm9taXNlPEVuY3J5cHRlZEluZGV4ZXJNZXRhRGF0YSB8IG51bGw+IHtcblx0Y29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBkYi5jcmVhdGVUcmFuc2FjdGlvbih0cnVlLCBbb2JqZWN0U3RvcmVOYW1lXSlcblx0Y29uc3QgdXNlckVuY0RiS2V5ID0gKGF3YWl0IHRyYW5zYWN0aW9uLmdldChvYmplY3RTdG9yZU5hbWUsIE1ldGFkYXRhLnVzZXJFbmNEYktleSkpIGFzIFVpbnQ4QXJyYXlcblx0Y29uc3QgZW5jRGJJdiA9IChhd2FpdCB0cmFuc2FjdGlvbi5nZXQob2JqZWN0U3RvcmVOYW1lLCBNZXRhZGF0YS5lbmNEYkl2KSkgYXMgVWludDhBcnJheVxuXHRjb25zdCB1c2VyR3JvdXBLZXlWZXJzaW9uID0gKGF3YWl0IHRyYW5zYWN0aW9uLmdldDxudW1iZXI+KG9iamVjdFN0b3JlTmFtZSwgTWV0YWRhdGEudXNlckdyb3VwS2V5VmVyc2lvbikpID8/IDAgLy8gd2FzIG5vdCB3cml0dGVuIGZvciBvbGQgZGJzXG5cdGNvbnN0IG1haWxJbmRleGluZ0VuYWJsZWQgPSAoYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KG9iamVjdFN0b3JlTmFtZSwgTWV0YWRhdGEubWFpbEluZGV4aW5nRW5hYmxlZCkpIGFzIGJvb2xlYW5cblx0Y29uc3QgZXhjbHVkZWRMaXN0SWRzID0gKGF3YWl0IHRyYW5zYWN0aW9uLmdldChvYmplY3RTdG9yZU5hbWUsIE1ldGFkYXRhLmV4Y2x1ZGVkTGlzdElkcykpIGFzIElkW11cblx0Y29uc3QgbGFzdEV2ZW50SW5kZXhUaW1lTXMgPSAoYXdhaXQgdHJhbnNhY3Rpb24uZ2V0KG9iamVjdFN0b3JlTmFtZSwgTWV0YWRhdGEubGFzdEV2ZW50SW5kZXhUaW1lTXMpKSBhcyBudW1iZXJcblx0aWYgKHVzZXJFbmNEYktleSA9PSBudWxsIHx8IGVuY0RiSXYgPT0gbnVsbCkge1xuXHRcdHJldHVybiBudWxsXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHVzZXJFbmNEYktleSxcblx0XHRcdGVuY0RiSXYsXG5cdFx0XHR1c2VyR3JvdXBLZXlWZXJzaW9uLFxuXHRcdFx0bWFpbEluZGV4aW5nRW5hYmxlZCxcblx0XHRcdGV4Y2x1ZGVkTGlzdElkcyxcblx0XHRcdGxhc3RFdmVudEluZGV4VGltZU1zLFxuXHRcdH1cblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0QW5kU2F2ZURiS2V5KHVzZXJHcm91cEtleTogVmVyc2lvbmVkS2V5LCBkYktleTogQWVzS2V5LCBkYkl2OiBVaW50OEFycmF5LCBkYjogRGJGYWNhZGUsIG9iamVjdFN0b3JlTmFtZTogc3RyaW5nKSB7XG5cdGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgZGIuY3JlYXRlVHJhbnNhY3Rpb24oZmFsc2UsIFtvYmplY3RTdG9yZU5hbWVdKSAvLyBjcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gdG8gYXZvaWQgdGltZW91dHMgYW5kIGZvciB3cml0aW5nXG5cdGNvbnN0IGdyb3VwRW5jU2Vzc2lvbktleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KHVzZXJHcm91cEtleSwgZGJLZXkpXG5cdGF3YWl0IHRyYW5zYWN0aW9uLnB1dChvYmplY3RTdG9yZU5hbWUsIE1ldGFkYXRhLnVzZXJFbmNEYktleSwgZ3JvdXBFbmNTZXNzaW9uS2V5LmtleSlcblx0YXdhaXQgdHJhbnNhY3Rpb24ucHV0KG9iamVjdFN0b3JlTmFtZSwgTWV0YWRhdGEudXNlckdyb3VwS2V5VmVyc2lvbiwgZ3JvdXBFbmNTZXNzaW9uS2V5LmVuY3J5cHRpbmdLZXlWZXJzaW9uKVxuXHRhd2FpdCB0cmFuc2FjdGlvbi5wdXQob2JqZWN0U3RvcmVOYW1lLCBNZXRhZGF0YS5lbmNEYkl2LCBhZXNFbmNyeXB0KGRiS2V5LCBkYkl2KSlcbn1cblxuLyoqXG4gKiBAY2F1dGlvbiBUaGlzIHdpbGwgY2xlYXIgYW55IGV4aXN0aW5nIGRhdGEgaW4gdGhlIGRhdGFiYXNlLCBiZWNhdXNlIHRoZXkga2V5IGFuZCBJViB3aWxsIGJlIHJlZ2VuZXJhdGVkXG4gKiBAcmV0dXJuIHRoZSBuZXdseSBnZW5lcmF0ZWQga2V5IGFuZCBpdiBmb3IgdGhlIGRhdGFiYXNlIGNvbnRlbnRzXG4gKiBAVmlzaWJsZUZvclRlc3RpbmdcbiAqXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplRGIoZGI6IERiRmFjYWRlLCBpZDogc3RyaW5nLCBrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSwgb2JqZWN0U3RvcmVOYW1lOiBPYmplY3RTdG9yZU5hbWUpOiBQcm9taXNlPEVuY3J5cHRpb25NZXRhZGF0YT4ge1xuXHRhd2FpdCBkYi5kZWxldGVEYXRhYmFzZShpZCkudGhlbigoKSA9PiBkYi5vcGVuKGlkKSlcblx0Y29uc3Qga2V5ID0gYWVzMjU2UmFuZG9tS2V5KClcblx0Y29uc3QgaXYgPSByYW5kb20uZ2VuZXJhdGVSYW5kb21EYXRhKElWX0JZVEVfTEVOR1RIKVxuXHRjb25zdCB1c2VyR3JvdXBLZXkgPSBrZXlMb2FkZXJGYWNhZGUuZ2V0Q3VycmVudFN5bVVzZXJHcm91cEtleSgpXG5cdGF3YWl0IGVuY3J5cHRBbmRTYXZlRGJLZXkodXNlckdyb3VwS2V5LCBrZXksIGl2LCBkYiwgb2JqZWN0U3RvcmVOYW1lKVxuXHRyZXR1cm4ge1xuXHRcdGtleSxcblx0XHRpdixcblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBhZGRBZGRyZXNzVG9JbWFnZUxpc3QoZGI6IERiRmFjYWRlLCBlbmNyeXB0ZWRBZGRyZXNzOiBVaW50OEFycmF5LCBydWxlOiBFeHRlcm5hbEltYWdlUnVsZSk6IFByb21pc2U8dm9pZD4ge1xuXHR0cnkge1xuXHRcdGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgZGIuY3JlYXRlVHJhbnNhY3Rpb24oZmFsc2UsIFtFeHRlcm5hbEltYWdlTGlzdE9TXSlcblx0XHRhd2FpdCB0cmFuc2FjdGlvbi5wdXQoRXh0ZXJuYWxJbWFnZUxpc3RPUywgbnVsbCwge1xuXHRcdFx0YWRkcmVzczogZW5jcnlwdGVkQWRkcmVzcyxcblx0XHRcdHJ1bGU6IHJ1bGUsXG5cdFx0fSlcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmIChlIGluc3RhbmNlb2YgRGJFcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcImZhaWxlZCB0byBhZGQgYWRkcmVzcyB0byBpbWFnZSBsaXN0OlwiLCBlLm1lc3NhZ2UpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dGhyb3cgZVxuXHR9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQXNCQSxNQUFNQSxVQUFrQjtBQUN4QixNQUFNQyxnQkFBd0I7QUFDOUIsTUFBTUMsc0JBQXVDO01BQ2hDQywwQkFBMkM7QUFXakQsZUFBZSxZQUFZQyxNQUFjQyxLQUFnQkMsSUFBcUM7QUFDcEcsUUFBTyxXQUFXLEtBQUssdUJBQXVCLEtBQUssRUFBRSxJQUFJLEtBQUs7QUFDOUQ7QUFFTSxlQUFlLGtCQUFrQkMsa0JBQThCRixLQUFnQkMsSUFBaUM7QUFDdEgsUUFBTyx1QkFBdUIsMEJBQTBCLEtBQUssT0FBTyxJQUFJLGlCQUFpQixDQUFDLENBQUM7QUFDM0Y7SUFRWSx3QkFBTixNQUE0QjtDQUVsQyxBQUFTO0NBRVQsWUFDa0JFLGlCQUNqQkMs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