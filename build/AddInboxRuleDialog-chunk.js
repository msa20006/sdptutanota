import { __toESM } from "./chunk-chunk.js";
import { assertMainOrNode } from "./Env-chunk.js";
import { mithril_default } from "./mithril-chunk.js";
import { neverNull } from "./dist2-chunk.js";
import { lang } from "./LanguageViewModel-chunk.js";
import { InboxRuleType, MailSetKind } from "./TutanotaConstants-chunk.js";
import { elementIdPart, isSameId } from "./EntityUtils-chunk.js";
import { createInboxRule } from "./TypeRefs-chunk.js";
import { isDomainName, isMailAddress, isRegularExpression } from "./FormatValidator-chunk.js";
import { require_stream } from "./stream-chunk.js";
import { isOfflineError } from "./ErrorUtils-chunk.js";
import { LockedError } from "./RestError-chunk.js";
import { Autocapitalize, Dialog, DropDownSelector, TextField } from "./Dialog-chunk.js";
import { locator } from "./CommonLocator-chunk.js";
import { showNotAvailableForFreeDialog } from "./SubscriptionDialogs-chunk.js";
import { getInboxRuleTypeNameMapping, mailLocator } from "./mailLocator-chunk.js";
import { assertSystemFolderOfType, getExistingRuleForType, getFolderName, getIndentedFolderNameForDropdown, getPathToFolderString } from "./MailUtils-chunk.js";

//#region src/mail-app/settings/AddInboxRuleDialog.ts
var import_stream = __toESM(require_stream(), 1);
assertMainOrNode();
async function show(mailBoxDetail, ruleOrTemplate) {
	if (locator.logins.getUserController().isFreeAccount()) showNotAvailableForFreeDialog();
else if (mailBoxDetail && mailBoxDetail.mailbox.folders) {
		const folders = await mailLocator.mailModel.getMailboxFoldersForId(mailBoxDetail.mailbox.folders._id);
		let targetFolders = folders.getIndentedList().map((folderInfo) => {
			return {
				name: getIndentedFolderNameForDropdown(folderInfo),
				value: folderInfo.folder
			};
		});
		const inboxRuleType = (0, import_stream.default)(ruleOrTemplate.type);
		const inboxRuleValue = (0, import_stream.default)(ruleOrTemplate.value);
		const selectedFolder = ruleOrTemplate.targetFolder == null ? null : folders.getFolderById(elementIdPart(ruleOrTemplate.targetFolder));
		const inboxRuleTarget = (0, import_stream.default)(selectedFolder ?? assertSystemFolderOfType(folders, MailSetKind.ARCHIVE));
		let form = () => [
			mithril_default(DropDownSelector, {
				items: getInboxRuleTypeNameMapping(),
				label: "inboxRuleField_label",
				selectedValue: inboxRuleType(),
				selectionChangedHandler: inboxRuleType
			}),
			mithril_default(TextField, {
				label: "inboxRuleValue_label",
				autocapitalize: Autocapitalize.none,
				value: inboxRuleValue(),
				oninput: inboxRuleValue,
				helpLabel: () => inboxRuleType() !== InboxRuleType.SUBJECT_CONTAINS && inboxRuleType() !== InboxRuleType.MAIL_HEADER_CONTAINS ? lang.get("emailSenderPlaceholder_label") : lang.get("emptyString_msg")
			}),
			mithril_default(DropDownSelector, {
				label: "inboxRuleTargetFolder_label",
				items: targetFolders,
				selectedValue: inboxRuleTarget(),
				selectedValueDisplay: getFolderName(inboxRuleTarget()),
				selectionChangedHandler: inboxRuleTarget,
				helpLabel: () => getPathToFolderString(folders, inboxRuleTarget(), true)
			})
		];
		const addInboxRuleOkAction = (dialog) => {
			let rule = createInboxRule({
				type: inboxRuleType(),
				value: getCleanedValue(inboxRuleType(), inboxRuleValue()),
				targetFolder: inboxRuleTarget()._id
			});
			const props = locator.logins.getUserController().props;
			const inboxRules = props.inboxRules;
			const ruleId = ruleOrTemplate._id;
			props.inboxRules = ruleId == null ? [...inboxRules, rule] : inboxRules.map((inboxRule) => isSameId(inboxRule._id, ruleId) ? rule : inboxRule);
			locator.entityClient.update(props).then(() => {
				dialog.close();
			}).catch((error) => {
				if (isOfflineError(error)) {
					props.inboxRules = inboxRules;
					throw error;
				} else if (error instanceof LockedError) dialog.close();
else {
					props.inboxRules = inboxRules;
					dialog.close();
					throw error;
				}
			});
		};
		Dialog.showActionDialog({
			title: "addInboxRule_action",
			child: form,
			validator: () => validateInboxRuleInput(inboxRuleType(), inboxRuleValue(), ruleOrTemplate._id),
			allowOkWithReturn: true,
			okAction: addInboxRuleOkAction
		});
	}
}
function createInboxRuleTemplate(ruleType, value) {
	return {
		type: ruleType ?? InboxRuleType.FROM_EQUALS,
		value: getCleanedValue(neverNull(ruleType), value || "")
	};
}
function validateInboxRuleInput(type, value, ruleId) {
	let currentCleanedValue = getCleanedValue(type, value);
	if (currentCleanedValue === "") return "inboxRuleEnterValue_msg";
else if (isInvalidRegex(currentCleanedValue)) return "invalidRegexSyntax_msg";
else if (type !== InboxRuleType.SUBJECT_CONTAINS && type !== InboxRuleType.MAIL_HEADER_CONTAINS && !isRegularExpression(currentCleanedValue) && !isDomainName(currentCleanedValue) && !isMailAddress(currentCleanedValue, false)) return "inboxRuleInvalidEmailAddress_msg";
else {
		let existingRule = getExistingRuleForType(locator.logins.getUserController().props, currentCleanedValue, type);
		if (existingRule && (!ruleId || ruleId && !isSameId(existingRule._id, ruleId))) return "inboxRuleAlreadyExists_msg";
	}
	return null;
}
function getCleanedValue(type, value) {
	if (type === InboxRuleType.SUBJECT_CONTAINS || type === InboxRuleType.MAIL_HEADER_CONTAINS) return value;
else return value.trim().toLowerCase();
}
/**
* @param value
* @returns true if provided string is a regex and it's unparseable by RegExp, else false
* @private
*/
function isInvalidRegex(value) {
	if (!isRegularExpression(value)) return false;
	try {
		let regExp = new RegExp(value.substring(1, value.length - 1));
	} catch (e) {
		return true;
	}
	return false;
}

//#endregion
export { createInboxRuleTemplate, show as show$2 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWRkSW5ib3hSdWxlRGlhbG9nLWNodW5rLmpzIiwibmFtZXMiOlsibWFpbEJveERldGFpbDogTWFpbGJveERldGFpbCIsInJ1bGVPclRlbXBsYXRlOiBJbmJveFJ1bGVUZW1wbGF0ZSIsImZvbGRlckluZm86IEluZGVudGVkRm9sZGVyIiwiZGlhbG9nOiBEaWFsb2ciLCJydWxlVHlwZTogc3RyaW5nIHwgbnVsbCIsInZhbHVlOiBzdHJpbmcgfCBudWxsIiwidHlwZTogc3RyaW5nIiwidmFsdWU6IHN0cmluZyIsInJ1bGVJZDogSWQgfCB1bmRlZmluZWQiXSwic291cmNlcyI6WyIuLi9zcmMvbWFpbC1hcHAvc2V0dGluZ3MvQWRkSW5ib3hSdWxlRGlhbG9nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gXCJtaXRocmlsXCJcbmltcG9ydCB7IERpYWxvZyB9IGZyb20gXCIuLi8uLi9jb21tb24vZ3VpL2Jhc2UvRGlhbG9nXCJcbmltcG9ydCB7IGxhbmcsIFRyYW5zbGF0aW9uS2V5IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9taXNjL0xhbmd1YWdlVmlld01vZGVsXCJcbmltcG9ydCB7IEluYm94UnVsZVR5cGUsIE1haWxTZXRLaW5kIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL1R1dGFub3RhQ29uc3RhbnRzXCJcbmltcG9ydCB7IGlzRG9tYWluTmFtZSwgaXNNYWlsQWRkcmVzcywgaXNSZWd1bGFyRXhwcmVzc2lvbiB9IGZyb20gXCIuLi8uLi9jb21tb24vbWlzYy9Gb3JtYXRWYWxpZGF0b3JcIlxuaW1wb3J0IHsgZ2V0SW5ib3hSdWxlVHlwZU5hbWVNYXBwaW5nIH0gZnJvbSBcIi4uL21haWwvbW9kZWwvSW5ib3hSdWxlSGFuZGxlclwiXG5pbXBvcnQgdHlwZSB7IEluYm94UnVsZSB9IGZyb20gXCIuLi8uLi9jb21tb24vYXBpL2VudGl0aWVzL3R1dGFub3RhL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IGNyZWF0ZUluYm94UnVsZSB9IGZyb20gXCIuLi8uLi9jb21tb24vYXBpL2VudGl0aWVzL3R1dGFub3RhL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB0eXBlIHsgTWFpbGJveERldGFpbCB9IGZyb20gXCIuLi8uLi9jb21tb24vbWFpbEZ1bmN0aW9uYWxpdHkvTWFpbGJveE1vZGVsLmpzXCJcbmltcG9ydCBzdHJlYW0gZnJvbSBcIm1pdGhyaWwvc3RyZWFtXCJcbmltcG9ydCB7IERyb3BEb3duU2VsZWN0b3IgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2d1aS9iYXNlL0Ryb3BEb3duU2VsZWN0b3IuanNcIlxuaW1wb3J0IHsgQXV0b2NhcGl0YWxpemUsIFRleHRGaWVsZCB9IGZyb20gXCIuLi8uLi9jb21tb24vZ3VpL2Jhc2UvVGV4dEZpZWxkLmpzXCJcbmltcG9ydCB7IG5ldmVyTnVsbCB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgTG9ja2VkRXJyb3IgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2FwaS9jb21tb24vZXJyb3IvUmVzdEVycm9yXCJcbmltcG9ydCB7IHNob3dOb3RBdmFpbGFibGVGb3JGcmVlRGlhbG9nIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9taXNjL1N1YnNjcmlwdGlvbkRpYWxvZ3NcIlxuaW1wb3J0IHsgZWxlbWVudElkUGFydCwgaXNTYW1lSWQgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2FwaS9jb21tb24vdXRpbHMvRW50aXR5VXRpbHNcIlxuaW1wb3J0IHsgYXNzZXJ0TWFpbk9yTm9kZSB9IGZyb20gXCIuLi8uLi9jb21tb24vYXBpL2NvbW1vbi9FbnZcIlxuaW1wb3J0IHsgbG9jYXRvciB9IGZyb20gXCIuLi8uLi9jb21tb24vYXBpL21haW4vQ29tbW9uTG9jYXRvclwiXG5pbXBvcnQgeyBpc09mZmxpbmVFcnJvciB9IGZyb20gXCIuLi8uLi9jb21tb24vYXBpL2NvbW1vbi91dGlscy9FcnJvclV0aWxzLmpzXCJcbmltcG9ydCB7IG1haWxMb2NhdG9yIH0gZnJvbSBcIi4uL21haWxMb2NhdG9yLmpzXCJcbmltcG9ydCB7XG5cdGFzc2VydFN5c3RlbUZvbGRlck9mVHlwZSxcblx0Z2V0RXhpc3RpbmdSdWxlRm9yVHlwZSxcblx0Z2V0Rm9sZGVyTmFtZSxcblx0Z2V0SW5kZW50ZWRGb2xkZXJOYW1lRm9yRHJvcGRvd24sXG5cdGdldFBhdGhUb0ZvbGRlclN0cmluZyxcbn0gZnJvbSBcIi4uL21haWwvbW9kZWwvTWFpbFV0aWxzLmpzXCJcbmltcG9ydCB0eXBlIHsgSW5kZW50ZWRGb2xkZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2FwaS9jb21tb24vbWFpbC9Gb2xkZXJTeXN0ZW0uanNcIlxuXG5hc3NlcnRNYWluT3JOb2RlKClcblxuZXhwb3J0IHR5cGUgSW5ib3hSdWxlVGVtcGxhdGUgPSBQaWNrPEluYm94UnVsZSwgXCJ0eXBlXCIgfCBcInZhbHVlXCI+ICYge1xuXHRfaWQ/OiBJbmJveFJ1bGVbXCJfaWRcIl1cblx0dGFyZ2V0Rm9sZGVyPzogSW5ib3hSdWxlW1widGFyZ2V0Rm9sZGVyXCJdXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaG93KG1haWxCb3hEZXRhaWw6IE1haWxib3hEZXRhaWwsIHJ1bGVPclRlbXBsYXRlOiBJbmJveFJ1bGVUZW1wbGF0ZSkge1xuXHRpZiAobG9jYXRvci5sb2dpbnMuZ2V0VXNlckNvbnRyb2xsZXIoKS5pc0ZyZWVBY2NvdW50KCkpIHtcblx0XHRzaG93Tm90QXZhaWxhYmxlRm9yRnJlZURpYWxvZygpXG5cdH0gZWxzZSBpZiAobWFpbEJveERldGFpbCAmJiBtYWlsQm94RGV0YWlsLm1haWxib3guZm9sZGVycykge1xuXHRcdGNvbnN0IGZvbGRlcnMgPSBhd2FpdCBtYWlsTG9jYXRvci5tYWlsTW9kZWwuZ2V0TWFpbGJveEZvbGRlcnNGb3JJZChtYWlsQm94RGV0YWlsLm1haWxib3guZm9sZGVycy5faWQpXG5cdFx0bGV0IHRhcmdldEZvbGRlcnMgPSBmb2xkZXJzLmdldEluZGVudGVkTGlzdCgpLm1hcCgoZm9sZGVySW5mbzogSW5kZW50ZWRGb2xkZXIpID0+IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG5hbWU6IGdldEluZGVudGVkRm9sZGVyTmFtZUZvckRyb3Bkb3duKGZvbGRlckluZm8pLFxuXHRcdFx0XHR2YWx1ZTogZm9sZGVySW5mby5mb2xkZXIsXG5cdFx0XHR9XG5cdFx0fSlcblx0XHRjb25zdCBpbmJveFJ1bGVUeXBlID0gc3RyZWFtKHJ1bGVPclRlbXBsYXRlLnR5cGUpXG5cdFx0Y29uc3QgaW5ib3hSdWxlVmFsdWUgPSBzdHJlYW0ocnVsZU9yVGVtcGxhdGUudmFsdWUpXG5cdFx0Y29uc3Qgc2VsZWN0ZWRGb2xkZXIgPSBydWxlT3JUZW1wbGF0ZS50YXJnZXRGb2xkZXIgPT0gbnVsbCA/IG51bGwgOiBmb2xkZXJzLmdldEZvbGRlckJ5SWQoZWxlbWVudElkUGFydChydWxlT3JUZW1wbGF0ZS50YXJnZXRGb2xkZXIpKVxuXHRcdGNvbnN0IGluYm94UnVsZVRhcmdldCA9IHN0cmVhbShzZWxlY3RlZEZvbGRlciA/PyBhc3NlcnRTeXN0ZW1Gb2xkZXJPZlR5cGUoZm9sZGVycywgTWFpbFNldEtpbmQuQVJDSElWRSkpXG5cblx0XHRsZXQgZm9ybSA9ICgpID0+IFtcblx0XHRcdG0oRHJvcERvd25TZWxlY3Rvciwge1xuXHRcdFx0XHRpdGVtczogZ2V0SW5ib3hSdWxlVHlwZU5hbWVNYXBwaW5nKCksXG5cdFx0XHRcdGxhYmVsOiBcImluYm94UnVsZUZpZWxkX2xhYmVsXCIsXG5cdFx0XHRcdHNlbGVjdGVkVmFsdWU6IGluYm94UnVsZVR5cGUoKSxcblx0XHRcdFx0c2VsZWN0aW9uQ2hhbmdlZEhhbmRsZXI6IGluYm94UnVsZVR5cGUsXG5cdFx0XHR9KSxcblx0XHRcdG0oVGV4dEZpZWxkLCB7XG5cdFx0XHRcdGxhYmVsOiBcImluYm94UnVsZVZhbHVlX2xhYmVsXCIsXG5cdFx0XHRcdGF1dG9jYXBpdGFsaXplOiBBdXRvY2FwaXRhbGl6ZS5ub25lLFxuXHRcdFx0XHR2YWx1ZTogaW5ib3hSdWxlVmFsdWUoKSxcblx0XHRcdFx0b25pbnB1dDogaW5ib3hSdWxlVmFsdWUsXG5cdFx0XHRcdGhlbHBMYWJlbDogKCkgPT5cblx0XHRcdFx0XHRpbmJveFJ1bGVUeXBlKCkgIT09IEluYm94UnVsZVR5cGUuU1VCSkVDVF9DT05UQUlOUyAmJiBpbmJveFJ1bGVUeXBlKCkgIT09IEluYm94UnVsZVR5cGUuTUFJTF9IRUFERVJfQ09OVEFJTlNcblx0XHRcdFx0XHRcdD8gbGFuZy5nZXQoXCJlbWFpbFNlbmRlclBsYWNlaG9sZGVyX2xhYmVsXCIpXG5cdFx0XHRcdFx0XHQ6IGxhbmcuZ2V0KFwiZW1wdHlTdHJpbmdfbXNnXCIpLFxuXHRcdFx0fSksXG5cdFx0XHRtKERyb3BEb3duU2VsZWN0b3IsIHtcblx0XHRcdFx0bGFiZWw6IFwiaW5ib3hSdWxlVGFyZ2V0Rm9sZGVyX2xhYmVsXCIsXG5cdFx0XHRcdGl0ZW1zOiB0YXJnZXRGb2xkZXJzLFxuXHRcdFx0XHRzZWxlY3RlZFZhbHVlOiBpbmJveFJ1bGVUYXJnZXQoKSxcblx0XHRcdFx0c2VsZWN0ZWRWYWx1ZURpc3BsYXk6IGdldEZvbGRlck5hbWUoaW5ib3hSdWxlVGFyZ2V0KCkpLFxuXHRcdFx0XHRzZWxlY3Rpb25DaGFuZ2VkSGFuZGxlcjogaW5ib3hSdWxlVGFyZ2V0LFxuXHRcdFx0XHRoZWxwTGFiZWw6ICgpID0+IGdldFBhdGhUb0ZvbGRlclN0cmluZyhmb2xkZXJzLCBpbmJveFJ1bGVUYXJnZXQoKSwgdHJ1ZSksXG5cdFx0XHR9KSxcblx0XHRdXG5cblx0XHRjb25zdCBhZGRJbmJveFJ1bGVPa0FjdGlvbiA9IChkaWFsb2c6IERpYWxvZykgPT4ge1xuXHRcdFx0bGV0IHJ1bGUgPSBjcmVhdGVJbmJveFJ1bGUoe1xuXHRcdFx0XHR0eXBlOiBpbmJveFJ1bGVUeXBlKCksXG5cdFx0XHRcdHZhbHVlOiBnZXRDbGVhbmVkVmFsdWUoaW5ib3hSdWxlVHlwZSgpLCBpbmJveFJ1bGVWYWx1ZSgpKSxcblx0XHRcdFx0dGFyZ2V0Rm9sZGVyOiBpbmJveFJ1bGVUYXJnZXQoKS5faWQsXG5cdFx0XHR9KVxuXHRcdFx0Y29uc3QgcHJvcHMgPSBsb2NhdG9yLmxvZ2lucy5nZXRVc2VyQ29udHJvbGxlcigpLnByb3BzXG5cdFx0XHRjb25zdCBpbmJveFJ1bGVzID0gcHJvcHMuaW5ib3hSdWxlc1xuXHRcdFx0Y29uc3QgcnVsZUlkID0gcnVsZU9yVGVtcGxhdGUuX2lkXG5cdFx0XHRwcm9wcy5pbmJveFJ1bGVzID0gcnVsZUlkID09IG51bGwgPyBbLi4uaW5ib3hSdWxlcywgcnVsZV0gOiBpbmJveFJ1bGVzLm1hcCgoaW5ib3hSdWxlKSA9PiAoaXNTYW1lSWQoaW5ib3hSdWxlLl9pZCwgcnVsZUlkKSA/IHJ1bGUgOiBpbmJveFJ1bGUpKVxuXG5cdFx0XHRsb2NhdG9yLmVudGl0eUNsaWVudFxuXHRcdFx0XHQudXBkYXRlKHByb3BzKVxuXHRcdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0ZGlhbG9nLmNsb3NlKClcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0XHRcdGlmIChpc09mZmxpbmVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRcdHByb3BzLmluYm94UnVsZXMgPSBpbmJveFJ1bGVzXG5cdFx0XHRcdFx0XHQvL2RvIG5vdCBjbG9zZVxuXHRcdFx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgTG9ja2VkRXJyb3IpIHtcblx0XHRcdFx0XHRcdGRpYWxvZy5jbG9zZSgpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHByb3BzLmluYm94UnVsZXMgPSBpbmJveFJ1bGVzXG5cdFx0XHRcdFx0XHRkaWFsb2cuY2xvc2UoKVxuXHRcdFx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0RGlhbG9nLnNob3dBY3Rpb25EaWFsb2coe1xuXHRcdFx0dGl0bGU6IFwiYWRkSW5ib3hSdWxlX2FjdGlvblwiLFxuXHRcdFx0Y2hpbGQ6IGZvcm0sXG5cdFx0XHR2YWxpZGF0b3I6ICgpID0+IHZhbGlkYXRlSW5ib3hSdWxlSW5wdXQoaW5ib3hSdWxlVHlwZSgpLCBpbmJveFJ1bGVWYWx1ZSgpLCBydWxlT3JUZW1wbGF0ZS5faWQpLFxuXHRcdFx0YWxsb3dPa1dpdGhSZXR1cm46IHRydWUsXG5cdFx0XHRva0FjdGlvbjogYWRkSW5ib3hSdWxlT2tBY3Rpb24sXG5cdFx0fSlcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5ib3hSdWxlVGVtcGxhdGUocnVsZVR5cGU6IHN0cmluZyB8IG51bGwsIHZhbHVlOiBzdHJpbmcgfCBudWxsKTogSW5ib3hSdWxlVGVtcGxhdGUge1xuXHRyZXR1cm4ge1xuXHRcdHR5cGU6IHJ1bGVUeXBlID8/IEluYm94UnVsZVR5cGUuRlJPTV9FUVVBTFMsXG5cdFx0dmFsdWU6IGdldENsZWFuZWRWYWx1ZShuZXZlck51bGwocnVsZVR5cGUpLCB2YWx1ZSB8fCBcIlwiKSxcblx0fVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUluYm94UnVsZUlucHV0KHR5cGU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgcnVsZUlkOiBJZCB8IHVuZGVmaW5lZCk6IFRyYW5zbGF0aW9uS2V5IHwgbnVsbCB7XG5cdGxldCBjdXJyZW50Q2xlYW5lZFZhbHVlID0gZ2V0Q2xlYW5lZFZhbHVlKHR5cGUsIHZhbHVlKVxuXG5cdGlmIChjdXJyZW50Q2xlYW5lZFZhbHVlID09PSBcIlwiKSB7XG5cdFx0cmV0dXJuIFwiaW5ib3hSdWxlRW50ZXJWYWx1ZV9tc2dcIlxuXHR9IGVsc2UgaWYgKGlzSW52YWxpZFJlZ2V4KGN1cnJlbnRDbGVhbmVkVmFsdWUpKSB7XG5cdFx0cmV0dXJuIFwiaW52YWxpZFJlZ2V4U3ludGF4X21zZ1wiXG5cdH0gZWxzZSBpZiAoXG5cdFx0dHlwZSAhPT0gSW5ib3hSdWxlVHlwZS5TVUJKRUNUX0NPTlRBSU5TICYmXG5cdFx0dHlwZSAhPT0gSW5ib3hSdWxlVHlwZS5NQUlMX0hFQURFUl9DT05UQUlOUyAmJlxuXHRcdCFpc1JlZ3VsYXJFeHByZXNzaW9uKGN1cnJlbnRDbGVhbmVkVmFsdWUpICYmXG5cdFx0IWlzRG9tYWluTmFtZShjdXJyZW50Q2xlYW5lZFZhbHVlKSAmJlxuXHRcdCFpc01haWxBZGRyZXNzKGN1cnJlbnRDbGVhbmVkVmFsdWUsIGZhbHNlKVxuXHQpIHtcblx0XHRyZXR1cm4gXCJpbmJveFJ1bGVJbnZhbGlkRW1haWxBZGRyZXNzX21zZ1wiXG5cdH0gZWxzZSB7XG5cdFx0bGV0IGV4aXN0aW5nUnVsZSA9IGdldEV4aXN0aW5nUnVsZUZvclR5cGUobG9jYXRvci5sb2dpbnMuZ2V0VXNlckNvbnRyb2xsZXIoKS5wcm9wcywgY3VycmVudENsZWFuZWRWYWx1ZSwgdHlwZSlcblxuXHRcdGlmIChleGlzdGluZ1J1bGUgJiYgKCFydWxlSWQgfHwgKHJ1bGVJZCAmJiAhaXNTYW1lSWQoZXhpc3RpbmdSdWxlLl9pZCwgcnVsZUlkKSkpKSB7XG5cdFx0XHRyZXR1cm4gXCJpbmJveFJ1bGVBbHJlYWR5RXhpc3RzX21zZ1wiXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gZ2V0Q2xlYW5lZFZhbHVlKHR5cGU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuXHRpZiAodHlwZSA9PT0gSW5ib3hSdWxlVHlwZS5TVUJKRUNUX0NPTlRBSU5TIHx8IHR5cGUgPT09IEluYm94UnVsZVR5cGUuTUFJTF9IRUFERVJfQ09OVEFJTlMpIHtcblx0XHRyZXR1cm4gdmFsdWVcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKClcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCBzdHJpbmcgaXMgYSByZWdleCBhbmQgaXQncyB1bnBhcnNlYWJsZSBieSBSZWdFeHAsIGVsc2UgZmFsc2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzSW52YWxpZFJlZ2V4KHZhbHVlOiBzdHJpbmcpIHtcblx0aWYgKCFpc1JlZ3VsYXJFeHByZXNzaW9uKHZhbHVlKSkgcmV0dXJuIGZhbHNlIC8vIG5vdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBub3QgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25cblxuXHR0cnkge1xuXHRcdC8vIFJlZ0V4cCBjdG9yIHRocm93cyBhIFBhcnNlRXJyb3IgaWYgaW52YWxpZCByZWdleFxuXHRcdGxldCByZWdFeHAgPSBuZXcgUmVnRXhwKHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKSlcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHRyZXR1cm4gZmFsc2Vcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkEsa0JBQWtCO0FBT1gsZUFBZSxLQUFLQSxlQUE4QkMsZ0JBQW1DO0FBQzNGLEtBQUksUUFBUSxPQUFPLG1CQUFtQixDQUFDLGVBQWUsQ0FDckQsZ0NBQStCO1NBQ3JCLGlCQUFpQixjQUFjLFFBQVEsU0FBUztFQUMxRCxNQUFNLFVBQVUsTUFBTSxZQUFZLFVBQVUsdUJBQXVCLGNBQWMsUUFBUSxRQUFRLElBQUk7RUFDckcsSUFBSSxnQkFBZ0IsUUFBUSxpQkFBaUIsQ0FBQyxJQUFJLENBQUNDLGVBQStCO0FBQ2pGLFVBQU87SUFDTixNQUFNLGlDQUFpQyxXQUFXO0lBQ2xELE9BQU8sV0FBVztHQUNsQjtFQUNELEVBQUM7RUFDRixNQUFNLGdCQUFnQiwyQkFBTyxlQUFlLEtBQUs7RUFDakQsTUFBTSxpQkFBaUIsMkJBQU8sZUFBZSxNQUFNO0VBQ25ELE1BQU0saUJBQWlCLGVBQWUsZ0JBQWdCLE9BQU8sT0FBTyxRQUFRLGNBQWMsY0FBYyxlQUFlLGFBQWEsQ0FBQztFQUNySSxNQUFNLGtCQUFrQiwyQkFBTyxrQkFBa0IseUJBQXlCLFNBQVMsWUFBWSxRQUFRLENBQUM7RUFFeEcsSUFBSSxPQUFPLE1BQU07R0FDaEIsZ0JBQUUsa0JBQWtCO0lBQ25CLE9BQU8sNkJBQTZCO0lB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