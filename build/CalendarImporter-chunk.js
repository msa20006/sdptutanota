import { isApp } from "./Env-chunk.js";
import { mithril_default } from "./mithril-chunk.js";
import { ofClass, pMap, stringToUtf8Uint8Array, utf8Uint8ArrayToString } from "./dist2-chunk.js";
import { lang } from "./LanguageViewModel-chunk.js";
import { ShareCapability } from "./TutanotaConstants-chunk.js";
import { size } from "./size-chunk.js";
import { elementIdPart, isSameId, listIdPart } from "./EntityUtils-chunk.js";
import { CalendarEventTypeRef, createFile } from "./TypeRefs-chunk.js";
import { UserAlarmInfoTypeRef } from "./TypeRefs2-chunk.js";
import { ParserError } from "./ParserCombinator-chunk.js";
import { CalendarType, getTimeZone, isExternalCalendarType } from "./CalendarUtils-chunk.js";
import { EventImportRejectionReason, parseCalendarStringData, sortOutParsedEvents } from "./ImportExportUtils-chunk.js";
import { ImportError } from "./ImportError-chunk.js";
import { ButtonType } from "./Button-chunk.js";
import { DialogHeaderBar } from "./DialogHeaderBar-chunk.js";
import { Dialog, DialogType, DropDownSelector } from "./Dialog-chunk.js";
import { BootIcons } from "./Icon-chunk.js";
import { getSharedGroupName, hasCapabilityOnGroup } from "./GroupUtils2-chunk.js";
import { locator } from "./CommonLocator-chunk.js";
import { convertToDataFile } from "./BlobUtils-chunk.js";
import { showProgressDialog } from "./ProgressDialog-chunk.js";
import { CALENDAR_MIME_TYPE, showFileChooser, showNativeFilePicker } from "./SharedMailUtils-chunk.js";
import { renderCalendarColor } from "./CalendarGuiUtils-chunk.js";
import { List, ListLoadingState, MultiselectMode } from "./List-chunk.js";
import { KindaCalendarRow } from "./CalendarRow-chunk.js";
import { serializeCalendar } from "./CalendarExporter-chunk.js";

//#region src/common/calendar/import/CalendarImporterDialog.ts
/**
* show an error dialog detailing the reason and amount for events that failed to import
*/
async function partialImportConfirmation(skippedEvents, confirmationText, total) {
	return skippedEvents.length === 0 || await Dialog.confirm(lang.makeTranslation("confirm_msg", lang.get(confirmationText, {
		"{amount}": skippedEvents.length + "",
		"{total}": total + ""
	})));
}
async function handleCalendarImport(calendarGroupRoot, importedParsedEvents = null, calendarType = CalendarType.NORMAL) {
	const parsedEvents = importedParsedEvents ?? await showProgressDialog("loading_msg", selectAndParseIcalFile());
	if (parsedEvents.length === 0) return;
	const zone = getTimeZone();
	const existingEvents = await showProgressDialog("loading_msg", loadAllEvents(calendarGroupRoot));
	const { rejectedEvents, eventsForCreation } = sortOutParsedEvents(parsedEvents, existingEvents, calendarGroupRoot, zone);
	const total = parsedEvents.length;
	if (!await partialImportConfirmation(rejectedEvents.get(EventImportRejectionReason.Duplicate) ?? [], "importEventExistingUid_msg", total)) return;
	if (!await partialImportConfirmation(rejectedEvents.get(EventImportRejectionReason.InvalidDate) ?? [], "importInvalidDatesInEvent_msg", total)) return;
	if (!await partialImportConfirmation(rejectedEvents.get(EventImportRejectionReason.Inversed) ?? [], "importEndNotAfterStartInEvent_msg", total)) return;
	if (!await partialImportConfirmation(rejectedEvents.get(EventImportRejectionReason.Pre1970) ?? [], "importPre1970StartInEvent_msg", total)) return;
	if (eventsForCreation.length > 0) if (isExternalCalendarType(calendarType)) await importEvents(eventsForCreation);
else showEventsImportDialog(eventsForCreation.map((ev) => ev.event), async (dialog) => {
		dialog.close();
		await importEvents(eventsForCreation);
	}, "importEvents_label");
}
async function selectAndParseIcalFile() {
	try {
		const allowedExtensions = [
			"ical",
			"ics",
			"ifb",
			"icalendar"
		];
		const dataFiles = isApp() ? await showNativeFilePicker(allowedExtensions, true) : await showFileChooser(true, allowedExtensions);
		const contents = dataFiles.map((file) => parseCalendarFile(file).contents);
		return contents.flat();
	} catch (e) {
		if (e instanceof ParserError) {
			console.log("Failed to parse file", e);
			Dialog.message(lang.makeTranslation("confirm_msg", lang.get("importReadFileError_msg", { "{filename}": e.filename ?? "" })));
			return [];
		} else throw e;
	}
}
async function importEvents(eventsForCreation) {
	const operation = locator.operationProgressTracker.startNewOperation();
	return showProgressDialog("importCalendar_label", locator.calendarFacade.saveImportedCalendarEvents(eventsForCreation, operation.id), operation.progress).catch(ofClass(ImportError, (e) => Dialog.message(lang.makeTranslation("confirm_msg", lang.get("importEventsError_msg", {
		"{amount}": e.numFailed + "",
		"{total}": eventsForCreation.length.toString()
	}))))).finally(() => operation.done());
}
async function exportCalendar(calendarName, groupRoot, userAlarmInfos, now, zone) {
	return await showProgressDialog("pleaseWait_msg", (async () => {
		const allEvents = await loadAllEvents(groupRoot);
		const eventsWithAlarms = await pMap(allEvents, async (event) => {
			const thisUserAlarms = event.alarmInfos.filter((alarmInfoId) => isSameId(userAlarmInfos, listIdPart(alarmInfoId)));
			if (thisUserAlarms.length === 0) return {
				event,
				alarms: []
			};
			const alarms = await locator.entityClient.loadMultiple(UserAlarmInfoTypeRef, userAlarmInfos, thisUserAlarms.map(elementIdPart));
			return {
				event,
				alarms
			};
		});
		return await exportCalendarEvents(calendarName, eventsWithAlarms, now, zone);
	})());
}
function exportCalendarEvents(calendarName, events, now, zone) {
	const stringValue = serializeCalendar(env.versionNumber, events, now, zone);
	const data = stringToUtf8Uint8Array(stringValue);
	const tmpFile = createFile({
		name: calendarName === "" ? "export.ics" : calendarName + "-export.ics",
		mimeType: CALENDAR_MIME_TYPE,
		size: String(data.byteLength),
		subFiles: null,
		parent: null,
		cid: null,
		blobs: []
	});
	return locator.fileController.saveDataFile(convertToDataFile(tmpFile, data));
}
function loadAllEvents(groupRoot) {
	return locator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.longEvents).then((longEvents) => locator.entityClient.loadAll(CalendarEventTypeRef, groupRoot.shortEvents).then((shortEvents) => {
		return shortEvents.concat(longEvents);
	}));
}

//#endregion
//#region src/common/calendar/import/CalendarImporter.ts
function parseCalendarFile(file) {
	try {
		const stringData = utf8Uint8ArrayToString(file.data);
		return parseCalendarStringData(stringData, getTimeZone());
	} catch (e) {
		if (e instanceof ParserError) throw new ParserError(e.message, file.name);
else throw e;
	}
}
function showEventsImportDialog(events, okAction, title) {
	const renderConfig = {
		itemHeight: size.list_row_height,
		multiselectionAllowed: MultiselectMode.Disabled,
		swipe: null,
		createElement: (dom) => {
			return new KindaCalendarRow(dom);
		}
	};
	const dialog = new Dialog(DialogType.EditSmall, { view: () => [mithril_default(DialogHeaderBar, {
		left: [{
			type: ButtonType.Secondary,
			label: "cancel_action",
			click: () => {
				dialog.close();
			}
		}],
		middle: title,
		right: [{
			type: ButtonType.Primary,
			label: "import_action",
			click: () => {
				okAction(dialog);
			}
		}]
	}), mithril_default(".dialog-max-height.plr-s.pb.text-break.nav-bg", [mithril_default(".flex.col.rel.mt-s", { style: { height: "80vh" } }, mithril_default(List, {
		renderConfig,
		state: {
			items: events,
			loadingStatus: ListLoadingState.Done,
			loadingAll: false,
			inMultiselect: true,
			activeIndex: null,
			selectedItems: new Set()
		},
		onLoadMore() {},
		onRangeSelectionTowards(item) {},
		onRetryLoading() {},
		onSingleSelection(item) {},
		onSingleTogglingMultiselection(item) {},
		onStopLoading() {}
	}))])] }).show();
}
async function importCalendarFile(calendarModel, userController, events) {
	const groupSettings = userController.userSettingsGroupRoot.groupSettings;
	const calendarInfos = await calendarModel.getCalendarInfos();
	const groupColors = groupSettings.reduce((acc, gc) => {
		acc.set(gc.group, gc.color);
		return acc;
	}, new Map());
	calendarSelectionDialog(Array.from(calendarInfos.values()), userController, groupColors, (dialog, selectedCalendar) => {
		dialog.close();
		handleCalendarImport(selectedCalendar.groupRoot, events);
	});
}
function calendarSelectionDialog(calendars, userController, groupColors, okAction) {
	const availableCalendars = calendars.filter((calendarInfo) => hasCapabilityOnGroup(userController.user, calendarInfo.group, ShareCapability.Write));
	let selectedCalendar = availableCalendars[0];
	const dialog = new Dialog(DialogType.EditSmall, { view: () => [mithril_default(DialogHeaderBar, {
		left: [{
			type: ButtonType.Secondary,
			label: "cancel_action",
			click: () => {
				dialog.close();
			}
		}],
		middle: "calendar_label",
		right: [{
			type: ButtonType.Primary,
			label: "pricing.select_action",
			click: () => {
				okAction(dialog, selectedCalendar);
			}
		}]
	}), mithril_default(".dialog-max-height.plr-l.pt.pb.text-break.scroll", [mithril_default(".text-break.selectable", lang.get("calendarImportSelection_label")), mithril_default(DropDownSelector, {
		label: "calendar_label",
		items: availableCalendars.map((calendarInfo) => {
			return {
				name: getSharedGroupName(calendarInfo.groupInfo, userController, calendarInfo.shared),
				value: calendarInfo
			};
		}),
		selectedValue: selectedCalendar,
		selectionChangedHandler: (v) => selectedCalendar = v,
		icon: BootIcons.Expand,
		disabled: availableCalendars.length < 2,
		helpLabel: () => renderCalendarColor(selectedCalendar, groupColors)
	})])] }).show();
}

//#endregion
export { calendarSelectionDialog, exportCalendar, handleCalendarImport, importCalendarFile, parseCalendarFile, showEventsImportDialog };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJJbXBvcnRlci1jaHVuay5qcyIsIm5hbWVzIjpbInNraXBwZWRFdmVudHM6IENhbGVuZGFyRXZlbnRbXSIsImNvbmZpcm1hdGlvblRleHQ6IFRyYW5zbGF0aW9uS2V5VHlwZSIsInRvdGFsOiBudW1iZXIiLCJjYWxlbmRhckdyb3VwUm9vdDogQ2FsZW5kYXJHcm91cFJvb3QiLCJpbXBvcnRlZFBhcnNlZEV2ZW50czogUGFyc2VkRXZlbnRbXSB8IG51bGwiLCJjYWxlbmRhclR5cGU6IENhbGVuZGFyVHlwZSIsInBhcnNlZEV2ZW50czogUGFyc2VkRXZlbnRbXSIsImV2ZW50c0ZvckNyZWF0aW9uOiBBcnJheTxFdmVudFdyYXBwZXI+IiwiY2FsZW5kYXJOYW1lOiBzdHJpbmciLCJncm91cFJvb3Q6IENhbGVuZGFyR3JvdXBSb290IiwidXNlckFsYXJtSW5mb3M6IElkIiwibm93OiBEYXRlIiwiem9uZTogc3RyaW5nIiwiZXZlbnQ6IENhbGVuZGFyRXZlbnQiLCJldmVudHM6IEFycmF5PHtcblx0XHRldmVudDogQ2FsZW5kYXJFdmVudFxuXHRcdGFsYXJtczogQXJyYXk8VXNlckFsYXJtSW5mbz5cblx0fT4iLCJmaWxlOiBEYXRhRmlsZSIsImV2ZW50czogQ2FsZW5kYXJFdmVudFtdIiwib2tBY3Rpb246IChkaWFsb2c6IERpYWxvZykgPT4gdW5rbm93biIsInRpdGxlOiBNYXliZVRyYW5zbGF0aW9uIiwicmVuZGVyQ29uZmlnOiBSZW5kZXJDb25maWc8Q2FsZW5kYXJFdmVudCwgS2luZGFDYWxlbmRhclJvdz4iLCJpdGVtOiBDYWxlbmRhckV2ZW50IiwiY2FsZW5kYXJNb2RlbDogQ2FsZW5kYXJNb2RlbCIsInVzZXJDb250cm9sbGVyOiBVc2VyQ29udHJvbGxlciIsImV2ZW50czogUGFyc2VkRXZlbnRbXSIsImdyb3VwQ29sb3JzOiBNYXA8SWQsIHN0cmluZz4iLCJjYWxlbmRhcnM6IENhbGVuZGFySW5mb1tdIiwiZ3JvdXBDb2xvcnM6IEdyb3VwQ29sb3JzIiwib2tBY3Rpb246IChkaWFsb2c6IERpYWxvZywgc2VsZWN0ZWRDYWxlbmRhcjogQ2FsZW5kYXJJbmZvKSA9PiB1bmtub3duIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9jYWxlbmRhci9pbXBvcnQvQ2FsZW5kYXJJbXBvcnRlckRpYWxvZy50cyIsIi4uL3NyYy9jb21tb24vY2FsZW5kYXIvaW1wb3J0L0NhbGVuZGFySW1wb3J0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWxlbmRhckV2ZW50LCBDYWxlbmRhckdyb3VwUm9vdCB9IGZyb20gXCIuLi8uLi9hcGkvZW50aXRpZXMvdHV0YW5vdGEvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudFR5cGVSZWYsIGNyZWF0ZUZpbGUgfSBmcm9tIFwiLi4vLi4vYXBpL2VudGl0aWVzL3R1dGFub3RhL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IENBTEVOREFSX01JTUVfVFlQRSwgc2hvd0ZpbGVDaG9vc2VyLCBzaG93TmF0aXZlRmlsZVBpY2tlciB9IGZyb20gXCIuLi8uLi9maWxlL0ZpbGVDb250cm9sbGVyLmpzXCJcbmltcG9ydCB7IHNob3dQcm9ncmVzc0RpYWxvZyB9IGZyb20gXCIuLi8uLi9ndWkvZGlhbG9ncy9Qcm9ncmVzc0RpYWxvZy5qc1wiXG5pbXBvcnQgeyBQYXJzZXJFcnJvciB9IGZyb20gXCIuLi8uLi9taXNjL3BhcnNpbmcvUGFyc2VyQ29tYmluYXRvci5qc1wiXG5pbXBvcnQgeyBEaWFsb2cgfSBmcm9tIFwiLi4vLi4vZ3VpL2Jhc2UvRGlhbG9nLmpzXCJcbmltcG9ydCB7IGxhbmcgfSBmcm9tIFwiLi4vLi4vbWlzYy9MYW5ndWFnZVZpZXdNb2RlbC5qc1wiXG5pbXBvcnQgeyBzZXJpYWxpemVDYWxlbmRhciB9IGZyb20gXCIuLi8uLi8uLi9jYWxlbmRhci1hcHAvY2FsZW5kYXIvZXhwb3J0L0NhbGVuZGFyRXhwb3J0ZXIuanNcIlxuaW1wb3J0IHsgcGFyc2VDYWxlbmRhckZpbGUsIFBhcnNlZEV2ZW50LCBzaG93RXZlbnRzSW1wb3J0RGlhbG9nIH0gZnJvbSBcIi4vQ2FsZW5kYXJJbXBvcnRlci5qc1wiXG5pbXBvcnQgeyBlbGVtZW50SWRQYXJ0LCBpc1NhbWVJZCwgbGlzdElkUGFydCB9IGZyb20gXCIuLi8uLi9hcGkvY29tbW9uL3V0aWxzL0VudGl0eVV0aWxzLmpzXCJcbmltcG9ydCB0eXBlIHsgVXNlckFsYXJtSW5mbyB9IGZyb20gXCIuLi8uLi9hcGkvZW50aXRpZXMvc3lzL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IFVzZXJBbGFybUluZm9UeXBlUmVmIH0gZnJvbSBcIi4uLy4uL2FwaS9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgY29udmVydFRvRGF0YUZpbGUgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi9EYXRhRmlsZS5qc1wiXG5pbXBvcnQgeyBsb2NhdG9yIH0gZnJvbSBcIi4uLy4uL2FwaS9tYWluL0NvbW1vbkxvY2F0b3IuanNcIlxuaW1wb3J0IHsgb2ZDbGFzcywgcHJvbWlzZU1hcCwgc3RyaW5nVG9VdGY4VWludDhBcnJheSB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgQ2FsZW5kYXJUeXBlLCBnZXRUaW1lWm9uZSwgaXNFeHRlcm5hbENhbGVuZGFyVHlwZSB9IGZyb20gXCIuLi9kYXRlL0NhbGVuZGFyVXRpbHMuanNcIlxuaW1wb3J0IHsgSW1wb3J0RXJyb3IgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi9lcnJvci9JbXBvcnRFcnJvci5qc1wiXG5pbXBvcnQgeyBUcmFuc2xhdGlvbktleVR5cGUgfSBmcm9tIFwiLi4vLi4vbWlzYy9UcmFuc2xhdGlvbktleS5qc1wiXG5pbXBvcnQgeyBpc0FwcCB9IGZyb20gXCIuLi8uLi9hcGkvY29tbW9uL0Vudi5qc1wiXG5cbmltcG9ydCB7IEV2ZW50SW1wb3J0UmVqZWN0aW9uUmVhc29uLCBFdmVudFdyYXBwZXIsIHNvcnRPdXRQYXJzZWRFdmVudHMgfSBmcm9tIFwiLi9JbXBvcnRFeHBvcnRVdGlscy5qc1wiXG5cbi8qKlxuICogc2hvdyBhbiBlcnJvciBkaWFsb2cgZGV0YWlsaW5nIHRoZSByZWFzb24gYW5kIGFtb3VudCBmb3IgZXZlbnRzIHRoYXQgZmFpbGVkIHRvIGltcG9ydFxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJ0aWFsSW1wb3J0Q29uZmlybWF0aW9uKHNraXBwZWRFdmVudHM6IENhbGVuZGFyRXZlbnRbXSwgY29uZmlybWF0aW9uVGV4dDogVHJhbnNsYXRpb25LZXlUeXBlLCB0b3RhbDogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdHJldHVybiAoXG5cdFx0c2tpcHBlZEV2ZW50cy5sZW5ndGggPT09IDAgfHxcblx0XHQoYXdhaXQgRGlhbG9nLmNvbmZpcm0oXG5cdFx0XHRsYW5nLm1ha2VUcmFuc2xhdGlvbihcblx0XHRcdFx0XCJjb25maXJtX21zZ1wiLFxuXHRcdFx0XHRsYW5nLmdldChjb25maXJtYXRpb25UZXh0LCB7XG5cdFx0XHRcdFx0XCJ7YW1vdW50fVwiOiBza2lwcGVkRXZlbnRzLmxlbmd0aCArIFwiXCIsXG5cdFx0XHRcdFx0XCJ7dG90YWx9XCI6IHRvdGFsICsgXCJcIixcblx0XHRcdFx0fSksXG5cdFx0XHQpLFxuXHRcdCkpXG5cdClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNhbGVuZGFySW1wb3J0KFxuXHRjYWxlbmRhckdyb3VwUm9vdDogQ2FsZW5kYXJHcm91cFJvb3QsXG5cdGltcG9ydGVkUGFyc2VkRXZlbnRzOiBQYXJzZWRFdmVudFtdIHwgbnVsbCA9IG51bGwsXG5cdGNhbGVuZGFyVHlwZTogQ2FsZW5kYXJUeXBlID0gQ2FsZW5kYXJUeXBlLk5PUk1BTCxcbik6IFByb21pc2U8dm9pZD4ge1xuXHRjb25zdCBwYXJzZWRFdmVudHM6IFBhcnNlZEV2ZW50W10gPSBpbXBvcnRlZFBhcnNlZEV2ZW50cyA/PyAoYXdhaXQgc2hvd1Byb2dyZXNzRGlhbG9nKFwibG9hZGluZ19tc2dcIiwgc2VsZWN0QW5kUGFyc2VJY2FsRmlsZSgpKSlcblx0aWYgKHBhcnNlZEV2ZW50cy5sZW5ndGggPT09IDApIHJldHVyblxuXHRjb25zdCB6b25lID0gZ2V0VGltZVpvbmUoKVxuXHRjb25zdCBleGlzdGluZ0V2ZW50cyA9IGF3YWl0IHNob3dQcm9ncmVzc0RpYWxvZyhcImxvYWRpbmdfbXNnXCIsIGxvYWRBbGxFdmVudHMoY2FsZW5kYXJHcm91cFJvb3QpKVxuXHRjb25zdCB7IHJlamVjdGVkRXZlbnRzLCBldmVudHNGb3JDcmVhdGlvbiB9ID0gc29ydE91dFBhcnNlZEV2ZW50cyhwYXJzZWRFdmVudHMsIGV4aXN0aW5nRXZlbnRzLCBjYWxlbmRhckdyb3VwUm9vdCwgem9uZSlcblxuXHRjb25zdCB0b3RhbCA9IHBhcnNlZEV2ZW50cy5sZW5ndGhcblx0aWYgKCEoYXdhaXQgcGFydGlhbEltcG9ydENvbmZpcm1hdGlvbihyZWplY3RlZEV2ZW50cy5nZXQoRXZlbnRJbXBvcnRSZWplY3Rpb25SZWFzb24uRHVwbGljYXRlKSA/PyBbXSwgXCJpbXBvcnRFdmVudEV4aXN0aW5nVWlkX21zZ1wiLCB0b3RhbCkpKSByZXR1cm5cblx0aWYgKCEoYXdhaXQgcGFydGlhbEltcG9ydENvbmZpcm1hdGlvbihyZWplY3RlZEV2ZW50cy5nZXQoRXZlbnRJbXBvcnRSZWplY3Rpb25SZWFzb24uSW52YWxpZERhdGUpID8/IFtdLCBcImltcG9ydEludmFsaWREYXRlc0luRXZlbnRfbXNnXCIsIHRvdGFsKSkpIHJldHVyblxuXHRpZiAoIShhd2FpdCBwYXJ0aWFsSW1wb3J0Q29uZmlybWF0aW9uKHJlamVjdGVkRXZlbnRzLmdldChFdmVudEltcG9ydFJlamVjdGlvblJlYXNvbi5JbnZlcnNlZCkgPz8gW10sIFwiaW1wb3J0RW5kTm90QWZ0ZXJTdGFydEluRXZlbnRfbXNnXCIsIHRvdGFsKSkpIHJldHVyblxuXHRpZiAoIShhd2FpdCBwYXJ0aWFsSW1wb3J0Q29uZmlybWF0aW9uKHJlamVjdGVkRXZlbnRzLmdldChFdmVudEltcG9ydFJlamVjdGlvblJlYXNvbi5QcmUxOTcwKSA/PyBbXSwgXCJpbXBvcnRQcmUxOTcwU3RhcnRJbkV2ZW50X21zZ1wiLCB0b3RhbCkpKSByZXR1cm5cblxuXHRpZiAoZXZlbnRzRm9yQ3JlYXRpb24ubGVuZ3RoID4gMCkge1xuXHRcdGlmIChpc0V4dGVybmFsQ2FsZW5kYXJUeXBlKGNhbGVuZGFyVHlwZSkpIGF3YWl0IGltcG9ydEV2ZW50cyhldmVudHNGb3JDcmVhdGlvbilcblx0XHRlbHNlXG5cdFx0XHRzaG93RXZlbnRzSW1wb3J0RGlhbG9nKFxuXHRcdFx0XHRldmVudHNGb3JDcmVhdGlvbi5tYXAoKGV2KSA9PiBldi5ldmVudCksXG5cdFx0XHRcdGFzeW5jIChkaWFsb2cpID0+IHtcblx0XHRcdFx0XHRkaWFsb2cuY2xvc2UoKVxuXHRcdFx0XHRcdGF3YWl0IGltcG9ydEV2ZW50cyhldmVudHNGb3JDcmVhdGlvbilcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJpbXBvcnRFdmVudHNfbGFiZWxcIixcblx0XHRcdClcblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBzZWxlY3RBbmRQYXJzZUljYWxGaWxlKCk6IFByb21pc2U8UGFyc2VkRXZlbnRbXT4ge1xuXHR0cnkge1xuXHRcdGNvbnN0IGFsbG93ZWRFeHRlbnNpb25zID0gW1wiaWNhbFwiLCBcImljc1wiLCBcImlmYlwiLCBcImljYWxlbmRhclwiXVxuXHRcdGNvbnN0IGRhdGFGaWxlcyA9IGlzQXBwKCkgPyBhd2FpdCBzaG93TmF0aXZlRmlsZVBpY2tlcihhbGxvd2VkRXh0ZW5zaW9ucywgdHJ1ZSkgOiBhd2FpdCBzaG93RmlsZUNob29zZXIodHJ1ZSwgYWxsb3dlZEV4dGVuc2lvbnMpXG5cdFx0Y29uc3QgY29udGVudHMgPSBkYXRhRmlsZXMubWFwKChmaWxlKSA9PiBwYXJzZUNhbGVuZGFyRmlsZShmaWxlKS5jb250ZW50cylcblx0XHRyZXR1cm4gY29udGVudHMuZmxhdCgpXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZSBpbnN0YW5jZW9mIFBhcnNlckVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBmaWxlXCIsIGUpXG5cdFx0XHREaWFsb2cubWVzc2FnZShcblx0XHRcdFx0bGFuZy5tYWtlVHJhbnNsYXRpb24oXG5cdFx0XHRcdFx0XCJjb25maXJtX21zZ1wiLFxuXHRcdFx0XHRcdGxhbmcuZ2V0KFwiaW1wb3J0UmVhZEZpbGVFcnJvcl9tc2dcIiwge1xuXHRcdFx0XHRcdFx0XCJ7ZmlsZW5hbWV9XCI6IGUuZmlsZW5hbWUgPz8gXCJcIixcblx0XHRcdFx0XHR9KSxcblx0XHRcdFx0KSxcblx0XHRcdClcblx0XHRcdHJldHVybiBbXVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBlXG5cdFx0fVxuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEV2ZW50cyhldmVudHNGb3JDcmVhdGlvbjogQXJyYXk8RXZlbnRXcmFwcGVyPik6IFByb21pc2U8dm9pZD4ge1xuXHRjb25zdCBvcGVyYXRpb24gPSBsb2NhdG9yLm9wZXJhdGlvblByb2dyZXNzVHJhY2tlci5zdGFydE5ld09wZXJhdGlvbigpXG5cdHJldHVybiBzaG93UHJvZ3Jlc3NEaWFsb2coXCJpbXBvcnRDYWxlbmRhcl9sYWJlbFwiLCBsb2NhdG9yLmNhbGVuZGFyRmFjYWRlLnNhdmVJbXBvcnRlZENhbGVuZGFyRXZlbnRzKGV2ZW50c0ZvckNyZWF0aW9uLCBvcGVyYXRpb24uaWQpLCBvcGVyYXRpb24ucHJvZ3Jlc3MpXG5cdFx0LmNhdGNoKFxuXHRcdFx0b2ZDbGFzcyhJbXBvcnRFcnJvciwgKGUpID0+XG5cdFx0XHRcdERpYWxvZy5tZXNzYWdlKFxuXHRcdFx0XHRcdGxhbmcubWFrZVRyYW5zbGF0aW9uKFxuXHRcdFx0XHRcdFx0XCJjb25maXJtX21zZ1wiLFxuXHRcdFx0XHRcdFx0bGFuZy5nZXQoXCJpbXBvcnRFdmVudHNFcnJvcl9tc2dcIiwge1xuXHRcdFx0XHRcdFx0XHRcInthbW91bnR9XCI6IGUubnVtRmFpbGVkICsgXCJcIixcblx0XHRcdFx0XHRcdFx0XCJ7dG90YWx9XCI6IGV2ZW50c0ZvckNyZWF0aW9uLmxlbmd0aC50b1N0cmluZygpLFxuXHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0KSxcblx0XHRcdCksXG5cdFx0KVxuXHRcdC5maW5hbGx5KCgpID0+IG9wZXJhdGlvbi5kb25lKCkpXG59XG5cbi8qKiBleHBvcnQgYWxsIGV2ZW50cyBmcm9tIGEgY2FsZW5kYXIsIHVzaW5nIHRoZSBhbGFybUluZm9zIHRoZSBjdXJyZW50IHVzZXIgaGFzIGFjY2VzcyB0byBhbmQgaWdub3JpbmcgdGhlIG90aGVyIG9uZXMgdGhhdCBtYXkgYmUgc2V0IG9uIHRoZSBldmVudC4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBvcnRDYWxlbmRhcihjYWxlbmRhck5hbWU6IHN0cmluZywgZ3JvdXBSb290OiBDYWxlbmRhckdyb3VwUm9vdCwgdXNlckFsYXJtSW5mb3M6IElkLCBub3c6IERhdGUsIHpvbmU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRyZXR1cm4gYXdhaXQgc2hvd1Byb2dyZXNzRGlhbG9nKFxuXHRcdFwicGxlYXNlV2FpdF9tc2dcIixcblx0XHQoYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3QgYWxsRXZlbnRzID0gYXdhaXQgbG9hZEFsbEV2ZW50cyhncm91cFJvb3QpXG5cdFx0XHRjb25zdCBldmVudHNXaXRoQWxhcm1zID0gYXdhaXQgcHJvbWlzZU1hcChhbGxFdmVudHMsIGFzeW5jIChldmVudDogQ2FsZW5kYXJFdmVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCB0aGlzVXNlckFsYXJtcyA9IGV2ZW50LmFsYXJtSW5mb3MuZmlsdGVyKChhbGFybUluZm9JZCkgPT4gaXNTYW1lSWQodXNlckFsYXJtSW5mb3MsIGxpc3RJZFBhcnQoYWxhcm1JbmZvSWQpKSlcblx0XHRcdFx0aWYgKHRoaXNVc2VyQWxhcm1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgZXZlbnQsIGFsYXJtczogW10gfVxuXHRcdFx0XHRjb25zdCBhbGFybXMgPSBhd2FpdCBsb2NhdG9yLmVudGl0eUNsaWVudC5sb2FkTXVsdGlwbGUoVXNlckFsYXJtSW5mb1R5cGVSZWYsIHVzZXJBbGFybUluZm9zLCB0aGlzVXNlckFsYXJtcy5tYXAoZWxlbWVudElkUGFydCkpXG5cdFx0XHRcdHJldHVybiB7IGV2ZW50LCBhbGFybXMgfVxuXHRcdFx0fSlcblx0XHRcdHJldHVybiBhd2FpdCBleHBvcnRDYWxlbmRhckV2ZW50cyhjYWxlbmRhck5hbWUsIGV2ZW50c1dpdGhBbGFybXMsIG5vdywgem9uZSlcblx0XHR9KSgpLFxuXHQpXG59XG5cbmZ1bmN0aW9uIGV4cG9ydENhbGVuZGFyRXZlbnRzKFxuXHRjYWxlbmRhck5hbWU6IHN0cmluZyxcblx0ZXZlbnRzOiBBcnJheTx7XG5cdFx0ZXZlbnQ6IENhbGVuZGFyRXZlbnRcblx0XHRhbGFybXM6IEFycmF5PFVzZXJBbGFybUluZm8+XG5cdH0+LFxuXHRub3c6IERhdGUsXG5cdHpvbmU6IHN0cmluZyxcbikge1xuXHRjb25zdCBzdHJpbmdWYWx1ZSA9IHNlcmlhbGl6ZUNhbGVuZGFyKGVudi52ZXJzaW9uTnVtYmVyLCBldmVudHMsIG5vdywgem9uZSlcblx0Y29uc3QgZGF0YSA9IHN0cmluZ1RvVXRmOFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUpXG5cdGNvbnN0IHRtcEZpbGUgPSBjcmVhdGVGaWxlKHtcblx0XHRuYW1lOiBjYWxlbmRhck5hbWUgPT09IFwiXCIgPyBcImV4cG9ydC5pY3NcIiA6IGNhbGVuZGFyTmFtZSArIFwiLWV4cG9ydC5pY3NcIixcblx0XHRtaW1lVHlwZTogQ0FMRU5EQVJfTUlNRV9UWVBFLFxuXHRcdHNpemU6IFN0cmluZyhkYXRhLmJ5dGVMZW5ndGgpLFxuXHRcdHN1YkZpbGVzOiBudWxsLFxuXHRcdHBhcmVudDogbnVsbCxcblx0XHRjaWQ6IG51bGwsXG5cdFx0YmxvYnM6IFtdLFxuXHR9KVxuXHRyZXR1cm4gbG9jYXRvci5maWxlQ29udHJvbGxlci5zYXZlRGF0YUZpbGUoY29udmVydFRvRGF0YUZpbGUodG1wRmlsZSwgZGF0YSkpXG59XG5cbmZ1bmN0aW9uIGxvYWRBbGxFdmVudHMoZ3JvdXBSb290OiBDYWxlbmRhckdyb3VwUm9vdCk6IFByb21pc2U8QXJyYXk8Q2FsZW5kYXJFdmVudD4+IHtcblx0cmV0dXJuIGxvY2F0b3IuZW50aXR5Q2xpZW50LmxvYWRBbGwoQ2FsZW5kYXJFdmVudFR5cGVSZWYsIGdyb3VwUm9vdC5sb25nRXZlbnRzKS50aGVuKChsb25nRXZlbnRzKSA9PlxuXHRcdGxvY2F0b3IuZW50aXR5Q2xpZW50LmxvYWRBbGwoQ2FsZW5kYXJFdmVudFR5cGVSZWYsIGdyb3VwUm9vdC5zaG9ydEV2ZW50cykudGhlbigoc2hvcnRFdmVudHMpID0+IHtcblx0XHRcdHJldHVybiBzaG9ydEV2ZW50cy5jb25jYXQobG9uZ0V2ZW50cylcblx0XHR9KSxcblx0KVxufVxuIiwiaW1wb3J0IHsgRGF0YUZpbGUgfSBmcm9tIFwiLi4vLi4vYXBpL2NvbW1vbi9EYXRhRmlsZS5qc1wiXG5pbXBvcnQgeyBSZXF1aXJlLCB1dGY4VWludDhBcnJheVRvU3RyaW5nIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBnZXRUaW1lWm9uZSB9IGZyb20gXCIuLi9kYXRlL0NhbGVuZGFyVXRpbHMuanNcIlxuaW1wb3J0IHsgUGFyc2VyRXJyb3IgfSBmcm9tIFwiLi4vLi4vbWlzYy9wYXJzaW5nL1BhcnNlckNvbWJpbmF0b3IuanNcIlxuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudCB9IGZyb20gXCIuLi8uLi9hcGkvZW50aXRpZXMvdHV0YW5vdGEvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgQWxhcm1JbmZvVGVtcGxhdGUgfSBmcm9tIFwiLi4vLi4vYXBpL3dvcmtlci9mYWNhZGVzL2xhenkvQ2FsZW5kYXJGYWNhZGUuanNcIlxuaW1wb3J0IHsgRGlhbG9nLCBEaWFsb2dUeXBlIH0gZnJvbSBcIi4uLy4uL2d1aS9iYXNlL0RpYWxvZy5qc1wiXG5pbXBvcnQgeyBsYW5nLCBNYXliZVRyYW5zbGF0aW9uIH0gZnJvbSBcIi4uLy4uL21pc2MvTGFuZ3VhZ2VWaWV3TW9kZWwuanNcIlxuaW1wb3J0IHsgTGlzdCwgTGlzdEF0dHJzLCBMaXN0TG9hZGluZ1N0YXRlLCBNdWx0aXNlbGVjdE1vZGUsIFJlbmRlckNvbmZpZyB9IGZyb20gXCIuLi8uLi9ndWkvYmFzZS9MaXN0LmpzXCJcbmltcG9ydCB7IEtpbmRhQ2FsZW5kYXJSb3cgfSBmcm9tIFwiLi4vLi4vLi4vY2FsZW5kYXItYXBwL2NhbGVuZGFyL2d1aS9DYWxlbmRhclJvdy5qc1wiXG5pbXBvcnQgeyBzaXplIH0gZnJvbSBcIi4uLy4uL2d1aS9zaXplLmpzXCJcbmltcG9ydCB7IERpYWxvZ0hlYWRlckJhciB9IGZyb20gXCIuLi8uLi9ndWkvYmFzZS9EaWFsb2dIZWFkZXJCYXIuanNcIlxuaW1wb3J0IHsgQnV0dG9uVHlwZSB9IGZyb20gXCIuLi8uLi9ndWkvYmFzZS9CdXR0b24uanNcIlxuaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxuaW1wb3J0IHsgRHJvcERvd25TZWxlY3RvciwgRHJvcERvd25TZWxlY3RvckF0dHJzIH0gZnJvbSBcIi4uLy4uL2d1aS9iYXNlL0Ryb3BEb3duU2VsZWN0b3IuanNcIlxuaW1wb3J0IHsgZ2V0U2hhcmVkR3JvdXBOYW1lLCBoYXNDYXBhYmlsaXR5T25Hcm91cCB9IGZyb20gXCIuLi8uLi9zaGFyaW5nL0dyb3VwVXRpbHMuanNcIlxuaW1wb3J0IHsgQm9vdEljb25zIH0gZnJvbSBcIi4uLy4uL2d1aS9iYXNlL2ljb25zL0Jvb3RJY29ucy5qc1wiXG5pbXBvcnQgeyBDYWxlbmRhckluZm8sIENhbGVuZGFyTW9kZWwgfSBmcm9tIFwiLi4vLi4vLi4vY2FsZW5kYXItYXBwL2NhbGVuZGFyL21vZGVsL0NhbGVuZGFyTW9kZWwuanNcIlxuaW1wb3J0IHsgVXNlckNvbnRyb2xsZXIgfSBmcm9tIFwiLi4vLi4vYXBpL21haW4vVXNlckNvbnRyb2xsZXIuanNcIlxuaW1wb3J0IHsgU2hhcmVDYXBhYmlsaXR5IH0gZnJvbSBcIi4uLy4uL2FwaS9jb21tb24vVHV0YW5vdGFDb25zdGFudHMuanNcIlxuaW1wb3J0IHsgcmVuZGVyQ2FsZW5kYXJDb2xvciB9IGZyb20gXCIuLi8uLi8uLi9jYWxlbmRhci1hcHAvY2FsZW5kYXIvZ3VpL0NhbGVuZGFyR3VpVXRpbHMuanNcIlxuaW1wb3J0IHsgR3JvdXBDb2xvcnMgfSBmcm9tIFwiLi4vLi4vLi4vY2FsZW5kYXItYXBwL2NhbGVuZGFyL3ZpZXcvQ2FsZW5kYXJWaWV3LmpzXCJcbmltcG9ydCB7IGhhbmRsZUNhbGVuZGFySW1wb3J0IH0gZnJvbSBcIi4vQ2FsZW5kYXJJbXBvcnRlckRpYWxvZy5qc1wiXG5pbXBvcnQgeyBwYXJzZUNhbGVuZGFyU3RyaW5nRGF0YSB9IGZyb20gXCIuL0ltcG9ydEV4cG9ydFV0aWxzLmpzXCJcblxuZXhwb3J0IHR5cGUgUGFyc2VkRXZlbnQgPSB7XG5cdGV2ZW50OiBSZXF1aXJlPFwidWlkXCIsIENhbGVuZGFyRXZlbnQ+XG5cdGFsYXJtczogQXJyYXk8QWxhcm1JbmZvVGVtcGxhdGU+XG59XG5leHBvcnQgdHlwZSBQYXJzZWRDYWxlbmRhckRhdGEgPSB7XG5cdG1ldGhvZDogc3RyaW5nXG5cdGNvbnRlbnRzOiBBcnJheTxQYXJzZWRFdmVudD5cbn1cblxuLyoqIGdpdmVuIGFuIGljYWwgZGF0YWZpbGUsIGdldCB0aGUgcGFyc2VkIGNhbGVuZGFyIGV2ZW50cyB3aXRoIHRoZWlyIGFsYXJtcyBhcyB3ZWxsIGFzIHRoZSBpY2FsIG1ldGhvZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2FsZW5kYXJGaWxlKGZpbGU6IERhdGFGaWxlKTogUGFyc2VkQ2FsZW5kYXJEYXRhIHtcblx0dHJ5IHtcblx0XHRjb25zdCBzdHJpbmdEYXRhID0gdXRmOFVpbnQ4QXJyYXlUb1N0cmluZyhmaWxlLmRhdGEpXG5cdFx0cmV0dXJuIHBhcnNlQ2FsZW5kYXJTdHJpbmdEYXRhKHN0cmluZ0RhdGEsIGdldFRpbWVab25lKCkpXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZSBpbnN0YW5jZW9mIFBhcnNlckVycm9yKSB7XG5cdFx0XHR0aHJvdyBuZXcgUGFyc2VyRXJyb3IoZS5tZXNzYWdlLCBmaWxlLm5hbWUpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IGVcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIGRpYWxvZyB3aXRoIGEgcHJldmlldyBvZiBhIGdpdmVuIGxpc3Qgb2YgZXZlbnRzXG4gKiBAcGFyYW0gZXZlbnRzIFRoZSBldmVudCBsaXN0IHRvIGJlIHByZXZpZXdlZFxuICogQHBhcmFtIG9rQWN0aW9uIFRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgdXNlciBwcmVzcyB0aGUgb2sgb3IgY29udGludWUgYnV0dG9uXG4gKiBAcGFyYW0gdGl0bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3dFdmVudHNJbXBvcnREaWFsb2coZXZlbnRzOiBDYWxlbmRhckV2ZW50W10sIG9rQWN0aW9uOiAoZGlhbG9nOiBEaWFsb2cpID0+IHVua25vd24sIHRpdGxlOiBNYXliZVRyYW5zbGF0aW9uKSB7XG5cdGNvbnN0IHJlbmRlckNvbmZpZzogUmVuZGVyQ29uZmlnPENhbGVuZGFyRXZlbnQsIEtpbmRhQ2FsZW5kYXJSb3c+ID0ge1xuXHRcdGl0ZW1IZWlnaHQ6IHNpemUubGlzdF9yb3dfaGVpZ2h0LFxuXHRcdG11bHRpc2VsZWN0aW9uQWxsb3dlZDogTXVsdGlzZWxlY3RNb2RlLkRpc2FibGVkLFxuXHRcdHN3aXBlOiBudWxsLFxuXHRcdGNyZWF0ZUVsZW1lbnQ6IChkb20pID0+IHtcblx0XHRcdHJldHVybiBuZXcgS2luZGFDYWxlbmRhclJvdyhkb20pXG5cdFx0fSxcblx0fVxuXG5cdGNvbnN0IGRpYWxvZyA9IG5ldyBEaWFsb2coRGlhbG9nVHlwZS5FZGl0U21hbGwsIHtcblx0XHR2aWV3OiAoKSA9PiBbXG5cdFx0XHRtKERpYWxvZ0hlYWRlckJhciwge1xuXHRcdFx0XHRsZWZ0OiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dHlwZTogQnV0dG9uVHlwZS5TZWNvbmRhcnksXG5cdFx0XHRcdFx0XHRsYWJlbDogXCJjYW5jZWxfYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRjbGljazogKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRkaWFsb2cuY2xvc2UoKVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRdLFxuXHRcdFx0XHRtaWRkbGU6IHRpdGxlLFxuXHRcdFx0XHRyaWdodDogW1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHR5cGU6IEJ1dHRvblR5cGUuUHJpbWFyeSxcblx0XHRcdFx0XHRcdGxhYmVsOiBcImltcG9ydF9hY3Rpb25cIixcblx0XHRcdFx0XHRcdGNsaWNrOiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdG9rQWN0aW9uKGRpYWxvZylcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XSxcblx0XHRcdH0pLFxuXHRcdFx0LyoqIHZhcmlhYmxlLXNpemUgY2hpbGQgY29udGFpbmVyIHRoYXQgbWF5IGJlIHNjcm9sbGFibGUuICovXG5cdFx0XHRtKFwiLmRpYWxvZy1tYXgtaGVpZ2h0LnBsci1zLnBiLnRleHQtYnJlYWsubmF2LWJnXCIsIFtcblx0XHRcdFx0bShcblx0XHRcdFx0XHRcIi5mbGV4LmNvbC5yZWwubXQtc1wiLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRcdGhlaWdodDogXCI4MHZoXCIsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bShMaXN0LCB7XG5cdFx0XHRcdFx0XHRyZW5kZXJDb25maWcsXG5cdFx0XHRcdFx0XHRzdGF0ZToge1xuXHRcdFx0XHRcdFx0XHRpdGVtczogZXZlbnRzLFxuXHRcdFx0XHRcdFx0XHRsb2FkaW5nU3RhdHVzOiBMaXN0TG9hZGluZ1N0YXRlLkRvbmUsXG5cdFx0XHRcdFx0XHRcdGxvYWRpbmdBbGw6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRpbk11bHRpc2VsZWN0OiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRhY3RpdmVJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRJdGVtczogbmV3IFNldCgpLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG9uTG9hZE1vcmUoKSB7fSxcblx0XHRcdFx0XHRcdG9uUmFuZ2VTZWxlY3Rpb25Ub3dhcmRzKGl0ZW06IENhbGVuZGFyRXZlbnQpIHt9LFxuXHRcdFx0XHRcdFx0b25SZXRyeUxvYWRpbmcoKSB7fSxcblx0XHRcdFx0XHRcdG9uU2luZ2xlU2VsZWN0aW9uKGl0ZW06IENhbGVuZGFyRXZlbnQpIHt9LFxuXHRcdFx0XHRcdFx0b25TaW5nbGVUb2dnbGluZ011bHRpc2VsZWN0aW9uKGl0ZW06IENhbGVuZGFyRXZlbnQpIHt9LFxuXHRcdFx0XHRcdFx0b25TdG9wTG9hZGluZygpIHt9LFxuXHRcdFx0XHRcdH0gc2F0aXNmaWVzIExpc3RBdHRyczxDYWxlbmRhckV2ZW50LCBLaW5kYUNhbGVuZGFyUm93PiksXG5cdFx0XHRcdCksXG5cdFx0XHRdKSxcblx0XHRdLFxuXHR9KS5zaG93KClcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlIGltcG9ydCBvZiBjYWxlbmRhciBldmVudHMgd2l0aCBwcmV2aWV3IG9mIGV2ZW50cyB0byBiZSBpbXBvcnRlZFxuICogQHBhcmFtIGNhbGVuZGFyTW9kZWxcbiAqIEBwYXJhbSB1c2VyQ29udHJvbGxlclxuICogQHBhcmFtIGV2ZW50cyBUaGUgZXZlbnQgbGlzdCB0byBiZSBwcmV2aWV3ZWQgYW5kIGltcG9ydGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRDYWxlbmRhckZpbGUoY2FsZW5kYXJNb2RlbDogQ2FsZW5kYXJNb2RlbCwgdXNlckNvbnRyb2xsZXI6IFVzZXJDb250cm9sbGVyLCBldmVudHM6IFBhcnNlZEV2ZW50W10pIHtcblx0Y29uc3QgZ3JvdXBTZXR0aW5ncyA9IHVzZXJDb250cm9sbGVyLnVzZXJTZXR0aW5nc0dyb3VwUm9vdC5ncm91cFNldHRpbmdzXG5cdGNvbnN0IGNhbGVuZGFySW5mb3MgPSBhd2FpdCBjYWxlbmRhck1vZGVsLmdldENhbGVuZGFySW5mb3MoKVxuXHRjb25zdCBncm91cENvbG9yczogTWFwPElkLCBzdHJpbmc+ID0gZ3JvdXBTZXR0aW5ncy5yZWR1Y2UoKGFjYywgZ2MpID0+IHtcblx0XHRhY2Muc2V0KGdjLmdyb3VwLCBnYy5jb2xvcilcblx0XHRyZXR1cm4gYWNjXG5cdH0sIG5ldyBNYXAoKSlcblxuXHRjYWxlbmRhclNlbGVjdGlvbkRpYWxvZyhBcnJheS5mcm9tKGNhbGVuZGFySW5mb3MudmFsdWVzKCkpLCB1c2VyQ29udHJvbGxlciwgZ3JvdXBDb2xvcnMsIChkaWFsb2csIHNlbGVjdGVkQ2FsZW5kYXIpID0+IHtcblx0XHRkaWFsb2cuY2xvc2UoKVxuXHRcdGhhbmRsZUNhbGVuZGFySW1wb3J0KHNlbGVjdGVkQ2FsZW5kYXIuZ3JvdXBSb290LCBldmVudHMpXG5cdH0pXG59XG5cbi8qKlxuICogU2hvd3MgYSBkaWFsb2cgd2l0aCB1c2VyJ3MgY2FsZW5kYXJzIHRoYXQgYXJlIGFibGUgdG8gcmVjZWl2ZSBuZXcgZXZlbnRzXG4gKiBAcGFyYW0gY2FsZW5kYXJzIExpc3Qgb2YgdXNlcidzIGNhbGVuZGFyc1xuICogQHBhcmFtIHVzZXJDb250cm9sbGVyXG4gKiBAcGFyYW0gZ3JvdXBDb2xvcnMgTGlzdCBvZiBjYWxlbmRhcidzIGNvbG9yc1xuICogQHBhcmFtIG9rQWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxlbmRhclNlbGVjdGlvbkRpYWxvZyhcblx0Y2FsZW5kYXJzOiBDYWxlbmRhckluZm9bXSxcblx0dXNlckNvbnRyb2xsZXI6IFVzZXJDb250cm9sbGVyLFxuXHRncm91cENvbG9yczogR3JvdXBDb2xvcnMsXG5cdG9rQWN0aW9uOiAoZGlhbG9nOiBEaWFsb2csIHNlbGVjdGVkQ2FsZW5kYXI6IENhbGVuZGFySW5mbykgPT4gdW5rbm93bixcbikge1xuXHRjb25zdCBhdmFpbGFibGVDYWxlbmRhcnMgPSBjYWxlbmRhcnMuZmlsdGVyKChjYWxlbmRhckluZm8pID0+IGhhc0NhcGFiaWxpdHlPbkdyb3VwKHVzZXJDb250cm9sbGVyLnVzZXIsIGNhbGVuZGFySW5mby5ncm91cCwgU2hhcmVDYXBhYmlsaXR5LldyaXRlKSlcblx0bGV0IHNlbGVjdGVkQ2FsZW5kYXIgPSBhdmFpbGFibGVDYWxlbmRhcnNbMF1cblxuXHRjb25zdCBkaWFsb2cgPSBuZXcgRGlhbG9nKERpYWxvZ1R5cGUuRWRpdFNtYWxsLCB7XG5cdFx0dmlldzogKCkgPT4gW1xuXHRcdFx0bShEaWFsb2dIZWFkZXJCYXIsIHtcblx0XHRcdFx0bGVmdDogW1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHR5cGU6IEJ1dHRvblR5cGUuU2Vjb25kYXJ5LFxuXHRcdFx0XHRcdFx0bGFiZWw6IFwiY2FuY2VsX2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0Y2xpY2s6ICgpID0+IHtcblx0XHRcdFx0XHRcdFx0ZGlhbG9nLmNsb3NlKClcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XSxcblx0XHRcdFx0bWlkZGxlOiBcImNhbGVuZGFyX2xhYmVsXCIsXG5cdFx0XHRcdHJpZ2h0OiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dHlwZTogQnV0dG9uVHlwZS5QcmltYXJ5LFxuXHRcdFx0XHRcdFx0bGFiZWw6IFwicHJpY2luZy5zZWxlY3RfYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRjbGljazogKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRva0FjdGlvbihkaWFsb2csIHNlbGVjdGVkQ2FsZW5kYXIpXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdF0sXG5cdFx0XHR9KSxcblxuXHRcdFx0bShcIi5kaWFsb2ctbWF4LWhlaWdodC5wbHItbC5wdC5wYi50ZXh0LWJyZWFrLnNjcm9sbFwiLCBbXG5cdFx0XHRcdG0oXCIudGV4dC1icmVhay5zZWxlY3RhYmxlXCIsIGxhbmcuZ2V0KFwiY2FsZW5kYXJJbXBvcnRTZWxlY3Rpb25fbGFiZWxcIikpLFxuXHRcdFx0XHRtKERyb3BEb3duU2VsZWN0b3IsIHtcblx0XHRcdFx0XHRsYWJlbDogXCJjYWxlbmRhcl9sYWJlbFwiLFxuXHRcdFx0XHRcdGl0ZW1zOiBhdmFpbGFibGVDYWxlbmRhcnMubWFwKChjYWxlbmRhckluZm8pID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IGdldFNoYXJlZEdyb3VwTmFtZShjYWxlbmRhckluZm8uZ3JvdXBJbmZvLCB1c2VyQ29udHJvbGxlciwgY2FsZW5kYXJJbmZvLnNoYXJlZCksXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBjYWxlbmRhckluZm8sXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRDYWxlbmRhcixcblx0XHRcdFx0XHRzZWxlY3Rpb25DaGFuZ2VkSGFuZGxlcjogKHYpID0+IChzZWxlY3RlZENhbGVuZGFyID0gdiksXG5cdFx0XHRcdFx0aWNvbjogQm9vdEljb25zLkV4cGFuZCxcblx0XHRcdFx0XHRkaXNhYmxlZDogYXZhaWxhYmxlQ2FsZW5kYXJzLmxlbmd0aCA8IDIsXG5cdFx0XHRcdFx0aGVscExhYmVsOiAoKSA9PiByZW5kZXJDYWxlbmRhckNvbG9yKHNlbGVjdGVkQ2FsZW5kYXIsIGdyb3VwQ29sb3JzKSxcblx0XHRcdFx0fSBzYXRpc2ZpZXMgRHJvcERvd25TZWxlY3RvckF0dHJzPENhbGVuZGFySW5mbz4pLFxuXHRcdFx0XSksXG5cdFx0XSxcblx0fSkuc2hvdygpXG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsZUFBZSwwQkFBMEJBLGVBQWdDQyxrQkFBc0NDLE9BQWlDO0FBQy9JLFFBQ0MsY0FBYyxXQUFXLEtBQ3hCLE1BQU0sT0FBTyxRQUNiLEtBQUssZ0JBQ0osZUFDQSxLQUFLLElBQUksa0JBQWtCO0VBQzFCLFlBQVksY0FBYyxTQUFTO0VBQ25DLFdBQVcsUUFBUTtDQUNuQixFQUFDLENBQ0YsQ0FDRDtBQUVGO0FBRU0sZUFBZSxxQkFDckJDLG1CQUNBQyx1QkFBNkMsTUFDN0NDLGVBQTZCLGFBQWEsUUFDMUI7Q0FDaEIsTUFBTUMsZUFBOEIsd0JBQXlCLE1BQU0sbUJBQW1CLGVBQWUsd0JBQXdCLENBQUM7QUFDOUgsS0FBSSxhQUFhLFdBQVcsRUFBRztDQUMvQixNQUFNLE9BQU8sYUFBYTtDQUMxQixNQUFNLGlCQUFpQixNQUFNLG1CQUFtQixlQUFlLGNBQWMsa0JBQWtCLENBQUM7Q0FDaEcsTUFBTSxFQUFFLGdCQUFnQixtQkFBbUIsR0FBRyxvQkFBb0IsY0FBYyxnQkFBZ0IsbUJBQW1CLEtBQUs7Q0FFeEgsTUFBTSxRQUFRLGFBQWE7QUFDM0IsTUFBTSxNQUFNLDBCQUEwQixlQUFlLElBQUksMkJBQTJCLFVBQVUsSUFBSSxDQUFFLEdBQUUsOEJBQThCLE1BQU0sQ0FBRztBQUM3SSxNQUFNLE1BQU0sMEJBQTBCLGVBQWUsSUFBSSwyQkFBMkIsWUFBWSxJQUFJLENBQUUsR0FBRSxpQ0FBaUMsTUFBTSxDQUFHO0FBQ2xKLE1BQU0sTUFBTSwwQkFBMEIsZUFBZSxJQUFJLDJCQUEyQixTQUFTLElBQUksQ0FBRSxHQUFFLHFDQUFxQyxNQUFNLENBQUc7QUFDbkosTUFBTSxNQUFNLDBCQUEwQixlQUFlLElBQUksMkJBQTJCLFFBQVEsSUFBSSxDQUFFLEdBQUUsaUNBQWlDLE1BQU0sQ0FBRztBQUU5SSxLQUFJLGtCQUFrQixTQUFTLEVBQzlCLEtBQUksdUJBQXVCLGFBQWEsQ0FBRSxPQUFNLGFBQWEsa0JBQWtCO0lBRTlFLHdCQUNDLGtCQUFrQixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sRUFDdkMsT0FBTyxXQUFXO0FBQ2pCLFNBQU8sT0FBTztBQUNkLFFBQU0sYUFBYSxrQkFBa0I7Q0FDckMsR0FDRCxxQkFDQTtBQUVIO0FBRUQsZUFBZSx5QkFBaUQ7QUFDL0QsS0FBSTtFQUNILE1BQU0sb0JBQW9CO0dBQUM7R0FBUTtHQUFPO0dBQU87RUFBWTtFQUM3RCxNQUFNLFlBQVksT0FBTyxHQUFHLE1BQU0scUJBQXFCLG1CQUFtQixLQUFLLEdBQUcsTUFBTSxnQkFBZ0IsTUFBTSxrQkFBa0I7RUFDaEksTUFBTSxXQUFXLFVBQVUsSUFBSSxDQUFDLFNBQVMsa0JBQWtCLEtBQUssQ0FBQyxTQUFTO0FBQzFFLFNBQU8sU0FBUyxNQUFNO0NBQ3RCLFNBQVEsR0FBRztBQUNYLE1BQUksYUFBYSxhQUFhO0FBQzdCLFdBQVEsSUFBSSx3QkFBd0IsRUFBRTtBQUN0QyxVQUFPLFFBQ04sS0FBSyxnQkFDSixlQUNBLEtBQUssSUFBSSwyQkFBMkIsRUFDbkMsY0FBYyxFQUFFLFlBQVksR0FDNUIsRUFBQyxDQUNGLENBQ0Q7QUFDRCxVQUFPLENBQUU7RUFDVCxNQUNBLE9BQU07Q0FFUDtBQUNEO0FBRUQsZUFBZSxhQUFhQyxtQkFBdUQ7Q0FDbEYsTUFBTSxZQUFZLFFBQVEseUJBQXlCLG1CQUFtQjtBQUN0RSxRQUFPLG1CQUFtQix3QkFBd0IsUUFBUSxlQUFlLDJCQUEyQixtQkFBbUIsVUFBVSxHQUFHLEVBQUUsVUFBVSxTQUFTLENBQ3ZKLE1BQ0EsUUFBUSxhQUFhLENBQUMsTUFDckIsT0FBTyxRQUNOLEtBQUssZ0JBQ0osZUFDQSxLQUFLLElBQUkseUJBQXlCO0VBQ2pDLFlBQVksRUFBRSxZQUFZO0VBQzFCLFdBQVcsa0JBQWtCLE9BQU8sVUFBVTtDQUM5QyxFQUFDLENBQ0YsQ0FDRCxDQUNELENBQ0QsQ0FDQSxRQUFRLE1BQU0sVUFBVSxNQUFNLENBQUM7QUFDakM7QUFHTSxlQUFlLGVBQWVDLGNBQXNCQyxXQUE4QkMsZ0JBQW9CQyxLQUFXQyxNQUE2QjtBQUNwSixRQUFPLE1BQU0sbUJBQ1osa0JBQ0EsQ0FBQyxZQUFZO0VBQ1osTUFBTSxZQUFZLE1BQU0sY0FBYyxVQUFVO0VBQ2hELE1BQU0sbUJBQW1CLE1BQU0sS0FBVyxXQUFXLE9BQU9DLFVBQXlCO0dBQ3BGLE1BQU0saUJBQWlCLE1BQU0sV0FBVyxPQUFPLENBQUMsZ0JBQWdCLFNBQVMsZ0JBQWdCLFdBQVcsWUFBWSxDQUFDLENBQUM7QUFDbEgsT0FBSSxlQUFlLFdBQVcsRUFBRyxRQUFPO0lBQUU7SUFBTyxRQUFRLENBQUU7R0FBRTtHQUM3RCxNQUFNLFNBQVMsTUFBTSxRQUFRLGFBQWEsYUFBYSxzQkFBc0IsZ0JBQWdCLGVBQWUsSUFBSSxjQUFjLENBQUM7QUFDL0gsVUFBTztJQUFFO0lBQU87R0FBUTtFQUN4QixFQUFDO0FBQ0YsU0FBTyxNQUFNLHFCQUFxQixjQUFjLGtCQUFrQixLQUFLLEtBQUs7Q0FDNUUsSUFBRyxDQUNKO0FBQ0Q7QUFFRCxTQUFTLHFCQUNSTCxjQUNBTSxRQUlBSCxLQUNBQyxNQUNDO0NBQ0QsTUFBTSxjQUFjLGtCQUFrQixJQUFJLGVBQWUsUUFBUSxLQUFLLEtBQUs7Q0FDM0UsTUFBTSxPQUFPLHVCQUF1QixZQUFZO0NBQ2hELE1BQU0sVUFBVSxXQUFXO0VBQzFCLE1BQU0saUJBQWlCLEtBQUssZUFBZSxlQUFlO0VBQzFELFVBQVU7RUFDVixNQUFNLE9BQU8sS0FBSyxXQUFXO0VBQzdCLFVBQVU7RUFDVixRQUFRO0VBQ1IsS0FBSztFQUNMLE9BQU8sQ0FBRTtDQUNULEVBQUM7QUFDRixRQUFPLFFBQVEsZUFBZSxhQUFhLGtCQUFrQixTQUFTLEtBQUssQ0FBQztBQUM1RTtBQUVELFNBQVMsY0FBY0gsV0FBNkQ7QUFDbkYsUUFBTyxRQUFRLGFBQWEsUUFBUSxzQkFBc0IsVUFBVSxXQUFXLENBQUMsS0FBSyxDQUFDLGVBQ3JGLFFBQVEsYUFBYSxRQUFRLHNCQUFzQixVQUFVLFlBQVksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCO0FBQy9GLFNBQU8sWUFBWSxPQUFPLFdBQVc7Q0FDckMsRUFBQyxDQUNGO0FBQ0Q7Ozs7QUM3SE0sU0FBUyxrQkFBa0JNLE1BQW9DO0FBQ3JFLEtBQUk7RUFDSCxNQUFNLGFBQWEsdUJBQXVCLEtBQUssS0FBSztBQUNwRCxTQUFPLHdCQUF3QixZQUFZLGFBQWEsQ0FBQztDQUN6RCxTQUFRLEdBQUc7QUFDWCxNQUFJLGFBQWEsWUFDaEIsT0FBTSxJQUFJLFlBQVksRUFBRSxTQUFTLEtBQUs7SUFFdEMsT0FBTTtDQUVQO0FBQ0Q7QUFRTSxTQUFTLHVCQUF1QkMsUUFBeUJDLFVBQXVDQyxPQUF5QjtDQUMvSCxNQUFNQyxlQUE4RDtFQUNuRSxZQUFZLEtBQUs7RUFDakIsdUJBQXVCLGdCQUFnQjtFQUN2QyxPQUFPO0VBQ1AsZUFBZSxDQUFDLFFBQVE7QUFDdkIsVUFBTyxJQUFJLGlCQUFpQjtFQUM1QjtDQUNEO0NBRUQsTUFBTSxTQUFTLElBQUksT0FBTyxXQUFXLFdBQVcsRUFDL0MsTUFBTSxNQUFNLENBQ1gsZ0JBQUUsaUJBQWlCO0VBQ2xCLE1BQU0sQ0FDTDtHQUNDLE1BQU0sV0FBVztHQUNqQixPQUFPO0dBQ1AsT0FBTyxNQUFNO0FBQ1osV0FBTyxPQUFPO0dBQ2Q7RUFDRCxDQUNEO0VBQ0QsUUFBUTtFQUNSLE9BQU8sQ0FDTjtHQUNDLE1BQU0sV0FBVztHQUNqQixPQUFPO0dBQ1AsT0FBTyxNQUFNO0FBQ1osYUFBUyxPQUFPO0dBQ2hCO0VBQ0QsQ0FDRDtDQUNELEVBQUMsRUFFRixnQkFBRSxpREFBaUQsQ0FDbEQsZ0JBQ0Msc0JBQ0EsRUFDQyxPQUFPLEVBQ04sUUFBUSxPQUNSLEVBQ0QsR0FDRCxnQkFBRSxNQUFNO0VBQ1A7RUFDQSxPQUFPO0dBQ04sT0FBTztHQUNQLGVBQWUsaUJBQWlCO0dBQ2hDLFlBQVk7R0FDWixlQUFlO0dBQ2YsYUFBYTtHQUNiLGVBQWUsSUFBSTtFQUNuQjtFQUNELGFBQWEsQ0FBRTtFQUNmLHdCQUF3QkMsTUFBcUIsQ0FBRTtFQUMvQyxpQkFBaUIsQ0FBRTtFQUNuQixrQkFBa0JBLE1BQXFCLENBQUU7RUFDekMsK0JBQStCQSxNQUFxQixDQUFFO0VBQ3RELGdCQUFnQixDQUFFO0NBQ2xCLEVBQXNELENBQ3ZELEFBQ0QsRUFBQyxBQUNGLEVBQ0QsR0FBRSxNQUFNO0FBQ1Q7QUFRTSxlQUFlLG1CQUFtQkMsZUFBOEJDLGdCQUFnQ0MsUUFBdUI7Q0FDN0gsTUFBTSxnQkFBZ0IsZUFBZSxzQkFBc0I7Q0FDM0QsTUFBTSxnQkFBZ0IsTUFBTSxjQUFjLGtCQUFrQjtDQUM1RCxNQUFNQyxjQUErQixjQUFjLE9BQU8sQ0FBQyxLQUFLLE9BQU87QUFDdEUsTUFBSSxJQUFJLEdBQUcsT0FBTyxHQUFHLE1BQU07QUFDM0IsU0FBTztDQUNQLEdBQUUsSUFBSSxNQUFNO0FBRWIseUJBQXdCLE1BQU0sS0FBSyxjQUFjLFFBQVEsQ0FBQyxFQUFFLGdCQUFnQixhQUFhLENBQUMsUUFBUSxxQkFBcUI7QUFDdEgsU0FBTyxPQUFPO0FBQ2QsdUJBQXFCLGlCQUFpQixXQUFXLE9BQU87Q0FDeEQsRUFBQztBQUNGO0FBU00sU0FBUyx3QkFDZkMsV0FDQUgsZ0JBQ0FJLGFBQ0FDLFVBQ0M7Q0FDRCxNQUFNLHFCQUFxQixVQUFVLE9BQU8sQ0FBQyxpQkFBaUIscUJBQXFCLGVBQWUsTUFBTSxhQUFhLE9BQU8sZ0JBQWdCLE1BQU0sQ0FBQztDQUNuSixJQUFJLG1CQUFtQixtQkFBbUI7Q0FFMUMsTUFBTSxTQUFTLElBQUksT0FBTyxXQUFXLFdBQVcsRUFDL0MsTUFBTSxNQUFNLENBQ1gsZ0JBQUUsaUJBQWlCO0VBQ2xCLE1BQU0sQ0FDTDtHQUNDLE1BQU0sV0FBVztHQUNqQixPQUFPO0dBQ1AsT0FBTyxNQUFNO0FBQ1osV0FBTyxPQUFPO0dBQ2Q7RUFDRCxDQUNEO0VBQ0QsUUFBUTtFQUNSLE9BQU8sQ0FDTjtHQUNDLE1BQU0sV0FBVztHQUNqQixPQUFPO0dBQ1AsT0FBTyxNQUFNO0FBQ1osYUFBUyxRQUFRLGlCQUFpQjtHQUNsQztFQUNELENBQ0Q7Q0FDRCxFQUFDLEVBRUYsZ0JBQUUsb0RBQW9ELENBQ3JELGdCQUFFLDBCQUEwQixLQUFLLElBQUksZ0NBQWdDLENBQUMsRUFDdEUsZ0JBQUUsa0JBQWtCO0VBQ25CLE9BQU87RUFDUCxPQUFPLG1CQUFtQixJQUFJLENBQUMsaUJBQWlCO0FBQy9DLFVBQU87SUFDTixNQUFNLG1CQUFtQixhQUFhLFdBQVcsZ0JBQWdCLGFBQWEsT0FBTztJQUNyRixPQUFPO0dBQ1A7RUFDRCxFQUFDO0VBQ0YsZUFBZTtFQUNmLHlCQUF5QixDQUFDLE1BQU8sbUJBQW1CO0VBQ3BELE1BQU0sVUFBVTtFQUNoQixVQUFVLG1CQUFtQixTQUFTO0VBQ3RDLFdBQVcsTUFBTSxvQkFBb0Isa0JBQWtCLFlBQVk7Q0FDbkUsRUFBK0MsQUFDaEQsRUFBQyxBQUNGLEVBQ0QsR0FBRSxNQUFNO0FBQ1QifQ==