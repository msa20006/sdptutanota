import "./dist-chunk.js";
import "./ProgrammingError-chunk.js";
import "./Env-chunk.js";
import { assertNotNull, findLastIndex, groupBy, makeSingleUse, ofClass } from "./dist2-chunk.js";
import { ConversationType, MailSetKind, MailState, OperationType } from "./TutanotaConstants-chunk.js";
import { elementIdPart, firstBiggerThanSecond, getElementId, haveSameId, isSameId, listIdPart } from "./EntityUtils-chunk.js";
import "./TypeModels-chunk.js";
import { ConversationEntryTypeRef, MailTypeRef } from "./TypeRefs-chunk.js";
import "./ParserCombinator-chunk.js";
import "./stream-chunk.js";
import "./ErrorUtils-chunk.js";
import { NotAuthorizedError, NotFoundError } from "./RestError-chunk.js";
import "./OutOfSyncError-chunk.js";
import "./CancelledError-chunk.js";
import "./SuspensionError-chunk.js";
import "./LoginIncompleteError-chunk.js";
import "./CryptoError-chunk.js";
import "./error-chunk.js";
import "./RecipientsNotFoundError-chunk.js";
import "./DbError-chunk.js";
import "./QuotaExceededError-chunk.js";
import "./DeviceStorageUnavailableError-chunk.js";
import "./MailBodyTooLargeError-chunk.js";
import "./ImportError-chunk.js";
import "./WebauthnError-chunk.js";
import "./PermissionError-chunk.js";
import { isUpdateForTypeRef } from "./EntityUpdateUtils-chunk.js";
import { isOfTypeOrSubfolderOf } from "./MailChecks-chunk.js";
import { LoadingStateTracker } from "./LoadingState-chunk.js";

//#region src/mail-app/mail/view/ConversationViewModel.ts
var ConversationViewModel = class {
	/** Primary viewModel is for the mail that was selected from the list. */
	_primaryViewModel;
	loadingState = new LoadingStateTracker();
	loadingPromise = null;
	/** Is not set until {@link loadConversation is finished. Until it is finished we display primary mail and subject. */
	conversation = null;
	constructor(options, viewModelFactory, entityClient, eventController, conversationPrefProvider, mailModel, onUiUpdate) {
		this.options = options;
		this.viewModelFactory = viewModelFactory;
		this.entityClient = entityClient;
		this.eventController = eventController;
		this.conversationPrefProvider = conversationPrefProvider;
		this.mailModel = mailModel;
		this.onUiUpdate = onUiUpdate;
		this._primaryViewModel = viewModelFactory(options);
	}
	init = makeSingleUse((delayBodyRendering) => {
		this.loadingPromise = this.loadingState.trackPromise(this.loadConversation());
		this.eventController.addEntityListener(this.onEntityEvent);
		this._primaryViewModel.expandMail(delayBodyRendering);
	});
	onEntityEvent = async (updates, eventOwnerGroupId) => {
		for (const update of updates) if (isUpdateForTypeRef(ConversationEntryTypeRef, update) && update.instanceListId === this.conversationListId()) {
			if (this.conversationPrefProvider.getConversationViewShowOnlySelectedMail()) continue;
			switch (update.operation) {
				case OperationType.CREATE:
					await this.processCreateConversationEntry(update);
					break;
				case OperationType.UPDATE:
					await this.processUpdateConversationEntry(update);
					break;
			}
		}
	};
	async processCreateConversationEntry(update) {
		const id = [update.instanceListId, update.instanceId];
		try {
			const entry = await this.entityClient.load(ConversationEntryTypeRef, id);
			if (entry.mail) {
				try {
					await this.loadingPromise;
				} catch (e) {
					return;
				}
				const conversation = assertNotNull(this.conversation);
				if (conversation.some((item) => item.type === "mail" && isSameId(item.viewModel.mail.conversationEntry, id))) return;
				const mail = await this.entityClient.load(MailTypeRef, entry.mail);
				let index = findLastIndex(conversation, (i) => firstBiggerThanSecond(getElementId(entry), elementIdPart(i.entryId)));
				if (index < 0) index = conversation.length;
else index = index + 1;
				conversation.splice(index, 0, {
					type: "mail",
					viewModel: this.viewModelFactory({
						...this.options,
						mail
					}),
					entryId: entry._id
				});
				this.onUiUpdate();
			}
		} catch (e) {
			if (e instanceof NotFoundError) {} else throw e;
		}
	}
	async processUpdateConversationEntry(update) {
		try {
			await this.loadingPromise;
		} catch (e) {
			return;
		}
		const conversation = assertNotNull(this.conversation);
		const ceId = [update.instanceListId, update.instanceId];
		let conversationEntry;
		let mail;
		try {
			conversationEntry = await this.entityClient.load(ConversationEntryTypeRef, ceId);
			mail = conversationEntry.conversationType !== ConversationType.UNKNOWN && conversationEntry.mail ? await this.entityClient.load(MailTypeRef, conversationEntry.mail).catch(ofClass(NotFoundError, () => {
				console.log(`Could not find updated mail ${JSON.stringify(conversationEntry.mail)}`);
				return null;
			})) : null;
		} catch (e) {
			if (e instanceof NotFoundError) return;
else throw e;
		}
		const oldItemIndex = conversation.findIndex((e) => e.type === "mail" && isSameId(e.viewModel.mail.conversationEntry, ceId));
		if (oldItemIndex === -1) return;
		const oldItem = conversation[oldItemIndex];
		if (mail && oldItem.type === "mail" && haveSameId(oldItem.viewModel.mail, mail)) console.log("Noop entry update?", oldItem.viewModel.mail);
else {
			if (oldItem.type === "mail") oldItem.viewModel.dispose();
			if (mail) if (mail.state === MailState.DRAFT && await this.isInTrash(mail)) conversation.splice(oldItemIndex, 1);
else conversation[oldItemIndex] = {
				type: "mail",
				viewModel: this.viewModelFactory({
					...this.options,
					mail
				}),
				entryId: conversationEntry._id
			};
else conversation.splice(oldItemIndex, 1);
			this.onUiUpdate();
		}
	}
	conversationListId() {
		return listIdPart(this._primaryViewModel.mail.conversationEntry);
	}
	async loadConversation() {
		try {
			if (this.conversationPrefProvider.getConversationViewShowOnlySelectedMail()) this.conversation = this.conversationItemsForSelectedMailOnly();
else this.conversation = await this.entityClient.loadAll(ConversationEntryTypeRef, listIdPart(this.primaryMail.conversationEntry)).then(async (entries) => {
				if (!entries.some((entry) => isSameId(entry.mail, this.primaryMail._id))) return this.conversationItemsForSelectedMailOnly();
else {
					const allMails = await this.loadMails(entries);
					return this.createConversationItems(entries, allMails);
				}
			}, async (e) => {
				if (e instanceof NotAuthorizedError) return this.conversationItemsForSelectedMailOnly();
else throw e;
			});
		} finally {
			this.onUiUpdate();
		}
	}
	createConversationItems(conversationEntries, allMails) {
		const newConversation = [];
		for (const c of conversationEntries) {
			const mail = c.mail && allMails.get(elementIdPart(c.mail));
			if (mail) newConversation.push({
				type: "mail",
				viewModel: isSameId(mail._id, this.options.mail._id) ? this._primaryViewModel : this.viewModelFactory({
					...this.options,
					mail
				}),
				entryId: c._id
			});
		}
		return newConversation;
	}
	async loadMails(conversationEntries) {
		const byList = groupBy(conversationEntries, (c) => c.mail && listIdPart(c.mail));
		const allMails = new Map();
		for (const [listId, conversations] of byList.entries()) {
			if (!listId) continue;
			const loaded = await this.entityClient.loadMultiple(MailTypeRef, listId, conversations.map((c) => elementIdPart(assertNotNull(c.mail))));
			for (const mail of loaded) if (isSameId(mail._id, this.primaryMail._id) || mail.state !== MailState.DRAFT || !await this.isInTrash(mail)) allMails.set(getElementId(mail), mail);
		}
		return allMails;
	}
	async isInTrash(mail) {
		const mailboxDetail = await this.mailModel.getMailboxDetailsForMail(mail);
		const mailFolder = this.mailModel.getMailFolderForMail(mail);
		if (mailFolder == null || mailboxDetail == null || mailboxDetail.mailbox.folders == null) return;
		const folders = await this.mailModel.getMailboxFoldersForId(mailboxDetail.mailbox.folders._id);
		return isOfTypeOrSubfolderOf(folders, mailFolder, MailSetKind.TRASH);
	}
	conversationItems() {
		return this.conversation ?? this.conversationItemsForSelectedMailOnly();
	}
	conversationItemsForSelectedMailOnly() {
		return [{
			type: "mail",
			viewModel: this._primaryViewModel,
			entryId: this._primaryViewModel.mail.conversationEntry
		}];
	}
	get primaryMail() {
		return this._primaryViewModel.mail;
	}
	primaryViewModel() {
		return this._primaryViewModel;
	}
	isFinished() {
		return this.loadingState.isIdle();
	}
	isConnectionLost() {
		return this.loadingState.isConnectionLost();
	}
	retry() {
		if (this.loadingState.isConnectionLost()) this.loadingState.trackPromise(this.loadConversation().then(async () => {
			const mails = this.conversation?.filter((e) => e.type === "mail") ?? [];
			await Promise.all(mails.map((m) => m.viewModel.loadAll(Promise.resolve())));
		}));
	}
	dispose() {
		if (this.loadingPromise != null) {
			this.eventController.removeEntityListener(this.onEntityEvent);
			for (const item of this.conversationItems()) if (item.type === "mail") item.viewModel.dispose();
		}
	}
};

//#endregion
export { ConversationViewModel };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udmVyc2F0aW9uVmlld01vZGVsLWNodW5rLmpzIiwibmFtZXMiOlsib3B0aW9uczogQ3JlYXRlTWFpbFZpZXdlck9wdGlvbnMiLCJ2aWV3TW9kZWxGYWN0b3J5OiBNYWlsVmlld2VyVmlld01vZGVsRmFjdG9yeSIsImVudGl0eUNsaWVudDogRW50aXR5Q2xpZW50IiwiZXZlbnRDb250cm9sbGVyOiBFdmVudENvbnRyb2xsZXIiLCJjb252ZXJzYXRpb25QcmVmUHJvdmlkZXI6IENvbnZlcnNhdGlvblByZWZQcm92aWRlciIsIm1haWxNb2RlbDogTWFpbE1vZGVsIiwib25VaVVwZGF0ZTogKCkgPT4gdW5rbm93biIsImRlbGF5Qm9keVJlbmRlcmluZzogUHJvbWlzZTx1bmtub3duPiIsInVwZGF0ZTogRW50aXR5VXBkYXRlRGF0YSIsImlkOiBJZFR1cGxlIiwiY2VJZDogSWRUdXBsZSIsImNvbnZlcnNhdGlvbkVudHJ5OiBDb252ZXJzYXRpb25FbnRyeSIsIm1haWw6IE1haWwgfCBudWxsIiwiY29udmVyc2F0aW9uRW50cmllczogQ29udmVyc2F0aW9uRW50cnlbXSIsImFsbE1haWxzOiBNYXA8SWQsIE1haWw+IiwibmV3Q29udmVyc2F0aW9uOiBDb252ZXJzYXRpb25JdGVtW10iLCJtYWlsOiBNYWlsIl0sInNvdXJjZXMiOlsiLi4vc3JjL21haWwtYXBwL21haWwvdmlldy9Db252ZXJzYXRpb25WaWV3TW9kZWwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udmVyc2F0aW9uRW50cnksIENvbnZlcnNhdGlvbkVudHJ5VHlwZVJlZiwgTWFpbCwgTWFpbFR5cGVSZWYgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9lbnRpdGllcy90dXRhbm90YS9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBNYWlsVmlld2VyVmlld01vZGVsIH0gZnJvbSBcIi4vTWFpbFZpZXdlclZpZXdNb2RlbC5qc1wiXG5pbXBvcnQgeyBDcmVhdGVNYWlsVmlld2VyT3B0aW9ucyB9IGZyb20gXCIuL01haWxWaWV3ZXIuanNcIlxuaW1wb3J0IHsgZWxlbWVudElkUGFydCwgZmlyc3RCaWdnZXJUaGFuU2Vjb25kLCBnZXRFbGVtZW50SWQsIGhhdmVTYW1lSWQsIGlzU2FtZUlkLCBsaXN0SWRQYXJ0IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL3V0aWxzL0VudGl0eVV0aWxzLmpzXCJcbmltcG9ydCB7IGFzc2VydE5vdE51bGwsIGZpbmRMYXN0SW5kZXgsIGdyb3VwQnksIG1ha2VTaW5nbGVVc2UsIG9mQ2xhc3MgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzXCJcbmltcG9ydCB7IEVudGl0eUNsaWVudCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL2NvbW1vbi9FbnRpdHlDbGllbnQuanNcIlxuaW1wb3J0IHsgTG9hZGluZ1N0YXRlVHJhY2tlciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vb2ZmbGluZS9Mb2FkaW5nU3RhdGUuanNcIlxuaW1wb3J0IHsgRW50aXR5RXZlbnRzTGlzdGVuZXIsIEV2ZW50Q29udHJvbGxlciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vYXBpL21haW4vRXZlbnRDb250cm9sbGVyLmpzXCJcbmltcG9ydCB7IENvbnZlcnNhdGlvblR5cGUsIE1haWxTZXRLaW5kLCBNYWlsU3RhdGUsIE9wZXJhdGlvblR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9jb21tb24vVHV0YW5vdGFDb25zdGFudHMuanNcIlxuaW1wb3J0IHsgTm90QXV0aG9yaXplZEVycm9yLCBOb3RGb3VuZEVycm9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL2Vycm9yL1Jlc3RFcnJvci5qc1wiXG5pbXBvcnQgeyBNYWlsYm94TW9kZWwgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL21haWxGdW5jdGlvbmFsaXR5L01haWxib3hNb2RlbC5qc1wiXG5pbXBvcnQgeyBFbnRpdHlVcGRhdGVEYXRhLCBpc1VwZGF0ZUZvclR5cGVSZWYgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2FwaS9jb21tb24vdXRpbHMvRW50aXR5VXBkYXRlVXRpbHMuanNcIlxuaW1wb3J0IHsgTGlzdEF1dG9TZWxlY3RCZWhhdmlvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vbWlzYy9EZXZpY2VDb25maWcuanNcIlxuXG5pbXBvcnQgeyBNYWlsTW9kZWwgfSBmcm9tIFwiLi4vbW9kZWwvTWFpbE1vZGVsLmpzXCJcblxuaW1wb3J0IHsgaXNPZlR5cGVPclN1YmZvbGRlck9mIH0gZnJvbSBcIi4uL21vZGVsL01haWxDaGVja3MuanNcIlxuXG5leHBvcnQgdHlwZSBNYWlsVmlld2VyVmlld01vZGVsRmFjdG9yeSA9IChvcHRpb25zOiBDcmVhdGVNYWlsVmlld2VyT3B0aW9ucykgPT4gTWFpbFZpZXdlclZpZXdNb2RlbFxuXG5leHBvcnQgdHlwZSBNYWlsSXRlbSA9IHsgdHlwZTogXCJtYWlsXCI7IHZpZXdNb2RlbDogTWFpbFZpZXdlclZpZXdNb2RlbDsgZW50cnlJZDogSWRUdXBsZSB9XG5leHBvcnQgdHlwZSBDb252ZXJzYXRpb25JdGVtID0gTWFpbEl0ZW1cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25QcmVmUHJvdmlkZXIge1xuXHRnZXRDb252ZXJzYXRpb25WaWV3U2hvd09ubHlTZWxlY3RlZE1haWwoKTogYm9vbGVhblxuXG5cdGdldE1haWxBdXRvU2VsZWN0QmVoYXZpb3IoKTogTGlzdEF1dG9TZWxlY3RCZWhhdmlvclxufVxuXG5leHBvcnQgdHlwZSBDb252ZXJzYXRpb25WaWV3TW9kZWxGYWN0b3J5ID0gKG9wdGlvbnM6IENyZWF0ZU1haWxWaWV3ZXJPcHRpb25zKSA9PiBDb252ZXJzYXRpb25WaWV3TW9kZWxcblxuZXhwb3J0IGNsYXNzIENvbnZlcnNhdGlvblZpZXdNb2RlbCB7XG5cdC8qKiBQcmltYXJ5IHZpZXdNb2RlbCBpcyBmb3IgdGhlIG1haWwgdGhhdCB3YXMgc2VsZWN0ZWQgZnJvbSB0aGUgbGlzdC4gKi9cblx0cHJpdmF0ZSByZWFkb25seSBfcHJpbWFyeVZpZXdNb2RlbDogTWFpbFZpZXdlclZpZXdNb2RlbFxuXHRwcml2YXRlIGxvYWRpbmdTdGF0ZSA9IG5ldyBMb2FkaW5nU3RhdGVUcmFja2VyKClcblx0cHJpdmF0ZSBsb2FkaW5nUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsXG5cdC8qKiBJcyBub3Qgc2V0IHVudGlsIHtAbGluayBsb2FkQ29udmVyc2F0aW9uIGlzIGZpbmlzaGVkLiBVbnRpbCBpdCBpcyBmaW5pc2hlZCB3ZSBkaXNwbGF5IHByaW1hcnkgbWFpbCBhbmQgc3ViamVjdC4gKi9cblx0cHJpdmF0ZSBjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbkl0ZW1bXSB8IG51bGwgPSBudWxsXG5cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSBvcHRpb25zOiBDcmVhdGVNYWlsVmlld2VyT3B0aW9ucyxcblx0XHRwcml2YXRlIHJlYWRvbmx5IHZpZXdNb2RlbEZhY3Rvcnk6IE1haWxWaWV3ZXJWaWV3TW9kZWxGYWN0b3J5LFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgZW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBldmVudENvbnRyb2xsZXI6IEV2ZW50Q29udHJvbGxlcixcblx0XHRwcml2YXRlIHJlYWRvbmx5IGNvbnZlcnNhdGlvblByZWZQcm92aWRlcjogQ29udmVyc2F0aW9uUHJlZlByb3ZpZGVyLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgbWFpbE1vZGVsOiBNYWlsTW9kZWwsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBvblVpVXBkYXRlOiAoKSA9PiB1bmtub3duLFxuXHQpIHtcblx0XHR0aGlzLl9wcmltYXJ5Vmlld01vZGVsID0gdmlld01vZGVsRmFjdG9yeShvcHRpb25zKVxuXHR9XG5cblx0cmVhZG9ubHkgaW5pdCA9IG1ha2VTaW5nbGVVc2UoKGRlbGF5Qm9keVJlbmRlcmluZzogUHJvbWlzZTx1bmtub3duPikgPT4ge1xuXHRcdHRoaXMubG9hZGluZ1Byb21pc2UgPSB0aGlzLmxvYWRpbmdTdGF0ZS50cmFja1Byb21pc2UodGhpcy5sb2FkQ29udmVyc2F0aW9uKCkpXG5cdFx0dGhpcy5ldmVudENvbnRyb2xsZXIuYWRkRW50aXR5TGlzdGVuZXIodGhpcy5vbkVudGl0eUV2ZW50KVxuXHRcdHRoaXMuX3ByaW1hcnlWaWV3TW9kZWwuZXhwYW5kTWFpbChkZWxheUJvZHlSZW5kZXJpbmcpXG5cdH0pXG5cblx0cHJpdmF0ZSByZWFkb25seSBvbkVudGl0eUV2ZW50OiBFbnRpdHlFdmVudHNMaXN0ZW5lciA9IGFzeW5jICh1cGRhdGVzLCBldmVudE93bmVyR3JvdXBJZCkgPT4ge1xuXHRcdC8vIGNvbnZlcnNhdGlvbiBlbnRyeSBjYW4gYmUgY3JlYXRlZCB3aGVuIG5ldyBlbWFpbCBhcnJpdmVzXG5cdFx0Ly8gY29udmVyc2F0aW9uIGVudHJ5IGNhbiBiZSB1cGRhdGVkIHdoZW4gZW1haWwgaXMgbW92ZWQgYXJvdW5kIG9yIGRlbGV0ZWRcblx0XHQvLyBjb252ZXJzYXRpb24gZW50cnkgaXMgZGVsZXRlZCBvbmx5IHdoZW4gZXZlcnkgZW1haWwgaW4gdGhlIGNvbnZlcnNhdGlvbiBpcyBkZWxldGVkICh0aGUgd2hvbGUgY29udmVyc2F0aW9uIGxpc3Qgd2lsbCBiZSBkZWxldGVkKVxuXHRcdGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcblx0XHRcdGlmIChpc1VwZGF0ZUZvclR5cGVSZWYoQ29udmVyc2F0aW9uRW50cnlUeXBlUmVmLCB1cGRhdGUpICYmIHVwZGF0ZS5pbnN0YW5jZUxpc3RJZCA9PT0gdGhpcy5jb252ZXJzYXRpb25MaXN0SWQoKSkge1xuXHRcdFx0XHRpZiAodGhpcy5jb252ZXJzYXRpb25QcmVmUHJvdmlkZXIuZ2V0Q29udmVyc2F0aW9uVmlld1Nob3dPbmx5U2VsZWN0ZWRNYWlsKCkpIHtcblx0XHRcdFx0XHQvLyBubyBuZWVkIHRvIGhhbmRsZSBDUkVBVEUgYmVjYXVzZSB3ZSBvbmx5IHNob3cgYSBzaW5nbGUgaXRlbSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgbmV3IG9uZXNcblx0XHRcdFx0XHQvLyBubyBuZWVkIHRvIGhhbmRsZSBVUERBVEUgYmVjYXVzZSB0aGUgb25seSB1cGRhdGUgdGhhdCBjYW4gaGFwcGVuIGlzIHdoZW4gZW1haWwgZ2V0cyBkZWxldGVkIGFuZCB0aGVuIHdlIHNob3VsZCBiZSBjbG9zZWQgZnJvbSB0aGVcblx0XHRcdFx0XHQvLyBvdXRzaWRlIGFueXdheVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoICh1cGRhdGUub3BlcmF0aW9uKSB7XG5cdFx0XHRcdFx0Y2FzZSBPcGVyYXRpb25UeXBlLkNSRUFURTpcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0NyZWF0ZUNvbnZlcnNhdGlvbkVudHJ5KHVwZGF0ZSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBPcGVyYXRpb25UeXBlLlVQREFURTpcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc1VwZGF0ZUNvbnZlcnNhdGlvbkVudHJ5KHVwZGF0ZSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0Ly8gZG9uJ3QgcHJvY2VzcyBERUxFVEUgYmVjYXVzZSB0aGUgcHJpbWFyeSBlbWFpbCAoc2VsZWN0ZWQgZnJvbSB0aGUgbWFpbCBsaXN0KSB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QgYW55d2F5XG5cdFx0XHRcdFx0Ly8gYW5kIHdlIHNob3VsZCBiZSBjbG9zZWQgd2hlbiBpdCBoYXBwZW5zXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NDcmVhdGVDb252ZXJzYXRpb25FbnRyeSh1cGRhdGU6IEVudGl0eVVwZGF0ZURhdGEpIHtcblx0XHRjb25zdCBpZDogSWRUdXBsZSA9IFt1cGRhdGUuaW5zdGFuY2VMaXN0SWQsIHVwZGF0ZS5pbnN0YW5jZUlkXVxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBlbnRyeSA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoQ29udmVyc2F0aW9uRW50cnlUeXBlUmVmLCBpZClcblx0XHRcdGlmIChlbnRyeS5tYWlsKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZmlyc3Qgd2FpdCB0aGF0IHdlIGxvYWQgdGhlIGNvbnZlcnNhdGlvbiwgb3RoZXJ3aXNlIHdlIG1pZ2h0IGFscmVhZHkgaGF2ZSB0aGUgZW1haWxcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmxvYWRpbmdQcm9taXNlXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBjb252ZXJzYXRpb24gPSBhc3NlcnROb3ROdWxsKHRoaXMuY29udmVyc2F0aW9uKVxuXHRcdFx0XHRpZiAoY29udmVyc2F0aW9uLnNvbWUoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gXCJtYWlsXCIgJiYgaXNTYW1lSWQoaXRlbS52aWV3TW9kZWwubWFpbC5jb252ZXJzYXRpb25FbnRyeSwgaWQpKSkge1xuXHRcdFx0XHRcdC8vIGFscmVhZHkgbG9hZGVkXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgbWFpbCA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoTWFpbFR5cGVSZWYsIGVudHJ5Lm1haWwpXG5cdFx0XHRcdGxldCBpbmRleCA9IGZpbmRMYXN0SW5kZXgoY29udmVyc2F0aW9uLCAoaSkgPT4gZmlyc3RCaWdnZXJUaGFuU2Vjb25kKGdldEVsZW1lbnRJZChlbnRyeSksIGVsZW1lbnRJZFBhcnQoaS5lbnRyeUlkKSkpXG5cdFx0XHRcdGlmIChpbmRleCA8IDApIHtcblx0XHRcdFx0XHRpbmRleCA9IGNvbnZlcnNhdGlvbi5sZW5ndGhcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnZlcnNhdGlvbi5zcGxpY2UoaW5kZXgsIDAsIHsgdHlwZTogXCJtYWlsXCIsIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWxGYWN0b3J5KHsgLi4udGhpcy5vcHRpb25zLCBtYWlsIH0pLCBlbnRyeUlkOiBlbnRyeS5faWQgfSlcblx0XHRcdFx0dGhpcy5vblVpVXBkYXRlKClcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcblx0XHRcdFx0Ly8gSWdub3JlLCBzb21ldGhpbmcgd2FzIGFscmVhZHkgZGVsZXRlZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc1VwZGF0ZUNvbnZlcnNhdGlvbkVudHJ5KHVwZGF0ZTogRW50aXR5VXBkYXRlRGF0YSkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBmaXJzdCB3YWl0IHRoYXQgd2UgbG9hZCB0aGUgY29udmVyc2F0aW9uLCBvdGhlcndpc2Ugd2UgbWlnaHQgYWxyZWFkeSBoYXZlIHRoZSBlbWFpbFxuXHRcdFx0YXdhaXQgdGhpcy5sb2FkaW5nUHJvbWlzZVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRjb25zdCBjb252ZXJzYXRpb24gPSBhc3NlcnROb3ROdWxsKHRoaXMuY29udmVyc2F0aW9uKVxuXHRcdGNvbnN0IGNlSWQ6IElkVHVwbGUgPSBbdXBkYXRlLmluc3RhbmNlTGlzdElkLCB1cGRhdGUuaW5zdGFuY2VJZF1cblx0XHRsZXQgY29udmVyc2F0aW9uRW50cnk6IENvbnZlcnNhdGlvbkVudHJ5XG5cdFx0bGV0IG1haWw6IE1haWwgfCBudWxsXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnZlcnNhdGlvbkVudHJ5ID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChDb252ZXJzYXRpb25FbnRyeVR5cGVSZWYsIGNlSWQpXG5cdFx0XHRtYWlsID1cblx0XHRcdFx0Ly8gaWRlYWxseSBjaGVja2luZyB0aGUgYG1haWxgIHJlZiBzaG91bGQgYmUgZW5vdWdoIGJ1dCB3ZSBzb21ldGltZXMgZ2V0IGFuIHVwZGF0ZSB3aXRoIFVOS05PV04gYW5kIG5vbi1leGlzdGluZyBlbWFpbCBidXQgc3RpbGwgd2l0aCB0aGUgcmVmXG5cdFx0XHRcdGNvbnZlcnNhdGlvbkVudHJ5LmNvbnZlcnNhdGlvblR5cGUgIT09IENvbnZlcnNhdGlvblR5cGUuVU5LTk9XTiAmJiBjb252ZXJzYXRpb25FbnRyeS5tYWlsXG5cdFx0XHRcdFx0PyBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKE1haWxUeXBlUmVmLCBjb252ZXJzYXRpb25FbnRyeS5tYWlsKS5jYXRjaChcblx0XHRcdFx0XHRcdFx0b2ZDbGFzcyhOb3RGb3VuZEVycm9yLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYENvdWxkIG5vdCBmaW5kIHVwZGF0ZWQgbWFpbCAke0pTT04uc3RyaW5naWZ5KGNvbnZlcnNhdGlvbkVudHJ5Lm1haWwpfWApXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGxcblx0XHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0ICApXG5cdFx0XHRcdFx0OiBudWxsXG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSB7XG5cdFx0XHRcdC8vIElnbm9yZSwgc29tZXRoaW5nIHdhcyBhbHJlYWR5IGRlbGV0ZWRcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBlXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3Qgb2xkSXRlbUluZGV4ID0gY29udmVyc2F0aW9uLmZpbmRJbmRleCgoZSkgPT4gZS50eXBlID09PSBcIm1haWxcIiAmJiBpc1NhbWVJZChlLnZpZXdNb2RlbC5tYWlsLmNvbnZlcnNhdGlvbkVudHJ5LCBjZUlkKSlcblx0XHRpZiAob2xkSXRlbUluZGV4ID09PSAtMSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGNvbnN0IG9sZEl0ZW0gPSBjb252ZXJzYXRpb25bb2xkSXRlbUluZGV4XVxuXHRcdGlmIChtYWlsICYmIG9sZEl0ZW0udHlwZSA9PT0gXCJtYWlsXCIgJiYgaGF2ZVNhbWVJZChvbGRJdGVtLnZpZXdNb2RlbC5tYWlsLCBtYWlsKSkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJOb29wIGVudHJ5IHVwZGF0ZT9cIiwgb2xkSXRlbS52aWV3TW9kZWwubWFpbClcblx0XHRcdC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5LCB3aHkgZG8gd2UgZ2V0IHRoaXMgdXBkYXRlIGFnYWluP1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAob2xkSXRlbS50eXBlID09PSBcIm1haWxcIikge1xuXHRcdFx0XHRvbGRJdGVtLnZpZXdNb2RlbC5kaXNwb3NlKClcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1haWwpIHtcblx0XHRcdFx0Ly8gV2UgZG8gbm90IHNob3cgdHJhc2hlZCBkcmFmdHNcblx0XHRcdFx0aWYgKG1haWwuc3RhdGUgPT09IE1haWxTdGF0ZS5EUkFGVCAmJiAoYXdhaXQgdGhpcy5pc0luVHJhc2gobWFpbCkpKSB7XG5cdFx0XHRcdFx0Y29udmVyc2F0aW9uLnNwbGljZShvbGRJdGVtSW5kZXgsIDEpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udmVyc2F0aW9uW29sZEl0ZW1JbmRleF0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcIm1haWxcIixcblx0XHRcdFx0XHRcdHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWxGYWN0b3J5KHsgLi4udGhpcy5vcHRpb25zLCBtYWlsIH0pLFxuXHRcdFx0XHRcdFx0ZW50cnlJZDogY29udmVyc2F0aW9uRW50cnkuX2lkLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2hlbiBERUxFVEVEIGNvbnZlcnNhdGlvbiBzdGF0dXMgdHlwZSBpcyBhZGRlZCwgcmVwbGFjZSBlbnRyeSB3aXRoIGRlbGV0ZWQgZW50cnkgaW5zdGVhZCBvZiBzcGxpY2luZyBvdXRcblx0XHRcdFx0Y29udmVyc2F0aW9uLnNwbGljZShvbGRJdGVtSW5kZXgsIDEpXG5cdFx0XHR9XG5cdFx0XHR0aGlzLm9uVWlVcGRhdGUoKVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgY29udmVyc2F0aW9uTGlzdElkKCkge1xuXHRcdHJldHVybiBsaXN0SWRQYXJ0KHRoaXMuX3ByaW1hcnlWaWV3TW9kZWwubWFpbC5jb252ZXJzYXRpb25FbnRyeSlcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgbG9hZENvbnZlcnNhdGlvbigpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuY29udmVyc2F0aW9uUHJlZlByb3ZpZGVyLmdldENvbnZlcnNhdGlvblZpZXdTaG93T25seVNlbGVjdGVkTWFpbCgpKSB7XG5cdFx0XHRcdHRoaXMuY29udmVyc2F0aW9uID0gdGhpcy5jb252ZXJzYXRpb25JdGVtc0ZvclNlbGVjdGVkTWFpbE9ubHkoKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQ2F0Y2ggZXJyb3JzIGJ1dCBvbmx5IGZvciBsb2FkaW5nIGNvbnZlcnNhdGlvbiBlbnRyaWVzLlxuXHRcdFx0XHQvLyBpZiBzdWNjZXNzLCBwcm9jZWVkIHdpdGggbG9hZGluZyBtYWlsc1xuXHRcdFx0XHQvLyBvdGhlcndpc2UgZG8gdGhlIGVycm9yIGhhbmRsaW5nXG5cdFx0XHRcdHRoaXMuY29udmVyc2F0aW9uID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZEFsbChDb252ZXJzYXRpb25FbnRyeVR5cGVSZWYsIGxpc3RJZFBhcnQodGhpcy5wcmltYXJ5TWFpbC5jb252ZXJzYXRpb25FbnRyeSkpLnRoZW4oXG5cdFx0XHRcdFx0YXN5bmMgKGVudHJpZXMpID0+IHtcblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBwcmltYXJ5IG1haWwgaXMgbm90IGFsb25nIGNvbnZlcnNhdGlvbiB0aGVuIG9ubHkgZGlzcGxheSB0aGUgcHJpbWFyeSBtYWlsXG5cdFx0XHRcdFx0XHRpZiAoIWVudHJpZXMuc29tZSgoZW50cnkpID0+IGlzU2FtZUlkKGVudHJ5Lm1haWwsIHRoaXMucHJpbWFyeU1haWwuX2lkKSkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29udmVyc2F0aW9uSXRlbXNGb3JTZWxlY3RlZE1haWxPbmx5KClcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGFsbE1haWxzID0gYXdhaXQgdGhpcy5sb2FkTWFpbHMoZW50cmllcylcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlQ29udmVyc2F0aW9uSXRlbXMoZW50cmllcywgYWxsTWFpbHMpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRhc3luYyAoZSkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBOb3RBdXRob3JpemVkRXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0Ly8gTW9zdCBsaWtlbHkgdGhlIGNvbnZlcnNhdGlvbiBlbnRyeSBsaXN0IGRvZXMgbm90IGV4aXN0IGFueW1vcmUuIFRoZSBzZXJ2ZXIgZG9lcyBub3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgY2FzZSB3aGVuIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBsaXN0IGRvZXMgbm90IGV4aXN0IGFuZCB3aGVuIHdlIGhhdmUgbm8gcGVybWlzc2lvbiBvbiBpdCAoYW5kIGZvciBnb29kIHJlYXNvbnMsIGl0IHByZXZlbnRzIGVudW1lcmF0aW9uKS5cblx0XHRcdFx0XHRcdFx0Ly8gTW9zdCBvZnRlbiBpdCBoYXBwZW5zIHdoZW4gd2UgYXJlIG5vdCBmdWxseSBzeW5jZWQgd2l0aCB0aGUgc2VydmVyIHlldCBhbmQgdGhlIHByaW1hcnkgbWFpbCBkb2VzIG5vdCBldmVuIGV4aXN0LlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb252ZXJzYXRpb25JdGVtc0ZvclNlbGVjdGVkTWFpbE9ubHkoKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5vblVpVXBkYXRlKClcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGNyZWF0ZUNvbnZlcnNhdGlvbkl0ZW1zKGNvbnZlcnNhdGlvbkVudHJpZXM6IENvbnZlcnNhdGlvbkVudHJ5W10sIGFsbE1haWxzOiBNYXA8SWQsIE1haWw+KSB7XG5cdFx0Y29uc3QgbmV3Q29udmVyc2F0aW9uOiBDb252ZXJzYXRpb25JdGVtW10gPSBbXVxuXHRcdGZvciAoY29uc3QgYyBvZiBjb252ZXJzYXRpb25FbnRyaWVzKSB7XG5cdFx0XHRjb25zdCBtYWlsID0gYy5tYWlsICYmIGFsbE1haWxzLmdldChlbGVtZW50SWRQYXJ0KGMubWFpbCkpXG5cblx0XHRcdGlmIChtYWlsKSB7XG5cdFx0XHRcdG5ld0NvbnZlcnNhdGlvbi5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiBcIm1haWxcIixcblx0XHRcdFx0XHR2aWV3TW9kZWw6IGlzU2FtZUlkKG1haWwuX2lkLCB0aGlzLm9wdGlvbnMubWFpbC5faWQpID8gdGhpcy5fcHJpbWFyeVZpZXdNb2RlbCA6IHRoaXMudmlld01vZGVsRmFjdG9yeSh7IC4uLnRoaXMub3B0aW9ucywgbWFpbCB9KSxcblx0XHRcdFx0XHRlbnRyeUlkOiBjLl9pZCxcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ld0NvbnZlcnNhdGlvblxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBsb2FkTWFpbHMoY29udmVyc2F0aW9uRW50cmllczogQ29udmVyc2F0aW9uRW50cnlbXSkge1xuXHRcdGNvbnN0IGJ5TGlzdCA9IGdyb3VwQnkoY29udmVyc2F0aW9uRW50cmllcywgKGMpID0+IGMubWFpbCAmJiBsaXN0SWRQYXJ0KGMubWFpbCkpXG5cdFx0Y29uc3QgYWxsTWFpbHM6IE1hcDxJZCwgTWFpbD4gPSBuZXcgTWFwKClcblx0XHRmb3IgKGNvbnN0IFtsaXN0SWQsIGNvbnZlcnNhdGlvbnNdIG9mIGJ5TGlzdC5lbnRyaWVzKCkpIHtcblx0XHRcdGlmICghbGlzdElkKSBjb250aW51ZVxuXHRcdFx0Y29uc3QgbG9hZGVkID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZE11bHRpcGxlKFxuXHRcdFx0XHRNYWlsVHlwZVJlZixcblx0XHRcdFx0bGlzdElkLFxuXHRcdFx0XHRjb252ZXJzYXRpb25zLm1hcCgoYykgPT4gZWxlbWVudElkUGFydChhc3NlcnROb3ROdWxsKGMubWFpbCkpKSxcblx0XHRcdClcblxuXHRcdFx0Zm9yIChjb25zdCBtYWlsIG9mIGxvYWRlZCkge1xuXHRcdFx0XHQvLyBJZiB0aGUgbWFpbCBpcyBhIGRyYWZ0IGFuZCBpcyB0aGUgcHJpbWFyeSBtYWlsLCB3ZSB3aWxsIHNob3cgaXQgbm8gbWF0dGVyIHdoYXRcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCBpZiBhIGRyYWZ0IGlzIGluIHRyYXNoIHdlIHdpbGwgbm90IHNob3cgaXRcblx0XHRcdFx0aWYgKGlzU2FtZUlkKG1haWwuX2lkLCB0aGlzLnByaW1hcnlNYWlsLl9pZCkgfHwgbWFpbC5zdGF0ZSAhPT0gTWFpbFN0YXRlLkRSQUZUIHx8ICEoYXdhaXQgdGhpcy5pc0luVHJhc2gobWFpbCkpKSB7XG5cdFx0XHRcdFx0YWxsTWFpbHMuc2V0KGdldEVsZW1lbnRJZChtYWlsKSwgbWFpbClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYWxsTWFpbHNcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaXNJblRyYXNoKG1haWw6IE1haWwpIHtcblx0XHRjb25zdCBtYWlsYm94RGV0YWlsID0gYXdhaXQgdGhpcy5tYWlsTW9kZWwuZ2V0TWFpbGJveERldGFpbHNGb3JNYWlsKG1haWwpXG5cdFx0Y29uc3QgbWFpbEZvbGRlciA9IHRoaXMubWFpbE1vZGVsLmdldE1haWxGb2xkZXJGb3JNYWlsKG1haWwpXG5cdFx0aWYgKG1haWxGb2xkZXIgPT0gbnVsbCB8fCBtYWlsYm94RGV0YWlsID09IG51bGwgfHwgbWFpbGJveERldGFpbC5tYWlsYm94LmZvbGRlcnMgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGNvbnN0IGZvbGRlcnMgPSBhd2FpdCB0aGlzLm1haWxNb2RlbC5nZXRNYWlsYm94Rm9sZGVyc0ZvcklkKG1haWxib3hEZXRhaWwubWFpbGJveC5mb2xkZXJzLl9pZClcblx0XHRyZXR1cm4gaXNPZlR5cGVPclN1YmZvbGRlck9mKGZvbGRlcnMsIG1haWxGb2xkZXIsIE1haWxTZXRLaW5kLlRSQVNIKVxuXHR9XG5cblx0Y29udmVyc2F0aW9uSXRlbXMoKTogUmVhZG9ubHlBcnJheTxDb252ZXJzYXRpb25JdGVtPiB7XG5cdFx0cmV0dXJuIHRoaXMuY29udmVyc2F0aW9uID8/IHRoaXMuY29udmVyc2F0aW9uSXRlbXNGb3JTZWxlY3RlZE1haWxPbmx5KClcblx0fVxuXG5cdHByaXZhdGUgY29udmVyc2F0aW9uSXRlbXNGb3JTZWxlY3RlZE1haWxPbmx5KCk6IENvbnZlcnNhdGlvbkl0ZW1bXSB7XG5cdFx0cmV0dXJuIFt7IHR5cGU6IFwibWFpbFwiLCB2aWV3TW9kZWw6IHRoaXMuX3ByaW1hcnlWaWV3TW9kZWwsIGVudHJ5SWQ6IHRoaXMuX3ByaW1hcnlWaWV3TW9kZWwubWFpbC5jb252ZXJzYXRpb25FbnRyeSB9XVxuXHR9XG5cblx0Z2V0IHByaW1hcnlNYWlsKCk6IE1haWwge1xuXHRcdHJldHVybiB0aGlzLl9wcmltYXJ5Vmlld01vZGVsLm1haWxcblx0fVxuXG5cdHByaW1hcnlWaWV3TW9kZWwoKTogTWFpbFZpZXdlclZpZXdNb2RlbCB7XG5cdFx0cmV0dXJuIHRoaXMuX3ByaW1hcnlWaWV3TW9kZWxcblx0fVxuXG5cdGlzRmluaXNoZWQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMubG9hZGluZ1N0YXRlLmlzSWRsZSgpXG5cdH1cblxuXHRpc0Nvbm5lY3Rpb25Mb3N0KCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLmxvYWRpbmdTdGF0ZS5pc0Nvbm5lY3Rpb25Mb3N0KClcblx0fVxuXG5cdHJldHJ5KCkge1xuXHRcdGlmICh0aGlzLmxvYWRpbmdTdGF0ZS5pc0Nvbm5lY3Rpb25Mb3N0KCkpIHtcblx0XHRcdHRoaXMubG9hZGluZ1N0YXRlLnRyYWNrUHJvbWlzZShcblx0XHRcdFx0dGhpcy5sb2FkQ29udmVyc2F0aW9uKCkudGhlbihhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgbWFpbHMgPSAodGhpcy5jb252ZXJzYXRpb24/LmZpbHRlcigoZSkgPT4gZS50eXBlID09PSBcIm1haWxcIikgPz8gW10pIGFzIEFycmF5PE1haWxJdGVtPlxuXHRcdFx0XHRcdGF3YWl0IFByb21pc2UuYWxsKG1haWxzLm1hcCgobSkgPT4gbS52aWV3TW9kZWwubG9hZEFsbChQcm9taXNlLnJlc29sdmUoKSkpKVxuXHRcdFx0XHR9KSxcblx0XHRcdClcblx0XHR9XG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXHRcdC8vIGhhY2s6IGluaXQgaGFzIGJlZW4gY2FsbGVkIGlmIGxvYWRpbmdQcm9taXNlIGlzIHNldFxuXHRcdGlmICh0aGlzLmxvYWRpbmdQcm9taXNlICE9IG51bGwpIHtcblx0XHRcdHRoaXMuZXZlbnRDb250cm9sbGVyLnJlbW92ZUVudGl0eUxpc3RlbmVyKHRoaXMub25FbnRpdHlFdmVudClcblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNvbnZlcnNhdGlvbkl0ZW1zKCkpIHtcblx0XHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gXCJtYWlsXCIpIHtcblx0XHRcdFx0XHRpdGVtLnZpZXdNb2RlbC5kaXNwb3NlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBK0JhLHdCQUFOLE1BQTRCOztDQUVsQyxBQUFpQjtDQUNqQixBQUFRLGVBQWUsSUFBSTtDQUMzQixBQUFRLGlCQUF1Qzs7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