
//#region packages/tutanota-error/dist/TutanotaError.js
/**
* Base class for all errors in Tutanota. Provides the handling of error stacks for chrome (captureStackTrace) and others.
* Implemented using ES5 inheritance as babel does not support extending builtin types
* @see http://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node
*
* Note that passing errors between worker and main thread requires all fields of the error to be serializable.
* Currently those are name, message, stack and data. See (errorToObj() and objToError()).
*
* In order to correctly set the class type of the error after deserialization
* (needed for e instanceof CustomError to work), the error class needs to be
* added to the ErrorNameToType map in Utils.js.
*/
const ExtendableErrorF = function ExtendableError$1(...args) {
	Error.apply(this, args);
};
ExtendableErrorF.prototype = Object.create(Error.prototype);
const ExtendableError = ExtendableErrorF;
var TutanotaError = class extends ExtendableError {
	name;
	message;
	constructor(name, message) {
		super(message);
		this.name = name;
		this.message = message;
		if (typeof Error.captureStackTrace === "function") Error.captureStackTrace(this, this.constructor);
else {
			let error = new Error();
			if (!error.stack) try {
				throw error;
			} catch (e) {}
			this.stack = this.name + ". " + this.message;
			if (error.stack) {
				let stackLines = error.stack.split("\n");
				while (stackLines[0] && !stackLines[0].match(this.name)) stackLines = stackLines.slice(1);
				if (stackLines.length === 0) this.stack = error.stack;
else this.stack += "\n" + stackLines.join("\n");
			}
		}
	}
};

//#endregion
export { TutanotaError };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlzdC1jaHVuay5qcyIsIm5hbWVzIjpbIkV4dGVuZGFibGVFcnJvciJdLCJzb3VyY2VzIjpbIi4uL3BhY2thZ2VzL3R1dGFub3RhLWVycm9yL2Rpc3QvVHV0YW5vdGFFcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBlcnJvcnMgaW4gVHV0YW5vdGEuIFByb3ZpZGVzIHRoZSBoYW5kbGluZyBvZiBlcnJvciBzdGFja3MgZm9yIGNocm9tZSAoY2FwdHVyZVN0YWNrVHJhY2UpIGFuZCBvdGhlcnMuXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBFUzUgaW5oZXJpdGFuY2UgYXMgYmFiZWwgZG9lcyBub3Qgc3VwcG9ydCBleHRlbmRpbmcgYnVpbHRpbiB0eXBlc1xuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMzODcwNjg0L3doeS1kb2VzbnQtaW5zdGFuY2VvZi13b3JrLW9uLWluc3RhbmNlcy1vZi1lcnJvci1zdWJjbGFzc2VzLXVuZGVyLWJhYmVsLW5vZGVcbiAqXG4gKiBOb3RlIHRoYXQgcGFzc2luZyBlcnJvcnMgYmV0d2VlbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkIHJlcXVpcmVzIGFsbCBmaWVsZHMgb2YgdGhlIGVycm9yIHRvIGJlIHNlcmlhbGl6YWJsZS5cbiAqIEN1cnJlbnRseSB0aG9zZSBhcmUgbmFtZSwgbWVzc2FnZSwgc3RhY2sgYW5kIGRhdGEuIFNlZSAoZXJyb3JUb09iaigpIGFuZCBvYmpUb0Vycm9yKCkpLlxuICpcbiAqIEluIG9yZGVyIHRvIGNvcnJlY3RseSBzZXQgdGhlIGNsYXNzIHR5cGUgb2YgdGhlIGVycm9yIGFmdGVyIGRlc2VyaWFsaXphdGlvblxuICogKG5lZWRlZCBmb3IgZSBpbnN0YW5jZW9mIEN1c3RvbUVycm9yIHRvIHdvcmspLCB0aGUgZXJyb3IgY2xhc3MgbmVlZHMgdG8gYmVcbiAqIGFkZGVkIHRvIHRoZSBFcnJvck5hbWVUb1R5cGUgbWFwIGluIFV0aWxzLmpzLlxuICovXG5jb25zdCBFeHRlbmRhYmxlRXJyb3JGID0gZnVuY3Rpb24gRXh0ZW5kYWJsZUVycm9yKC4uLmFyZ3MpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgRXJyb3IuYXBwbHkodGhpcywgYXJncyk7XG59O1xuLy8gV2FybmluZzogaHVnZSB0eXBlIGhhY2tcbi8vIFlvdSBjYW4ndCBpbXBvcnQgZG93bmNhc3QgaGVyZVxuRXh0ZW5kYWJsZUVycm9yRi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBFeHRlbmRhYmxlRXJyb3IgPSBFeHRlbmRhYmxlRXJyb3JGO1xuZXhwb3J0IGNsYXNzIFR1dGFub3RhRXJyb3IgZXh0ZW5kcyBFeHRlbmRhYmxlRXJyb3Ige1xuICAgIG5hbWU7XG4gICAgbWVzc2FnZTtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIWVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlsbCB0aGUgc3RhY2sgdHJhY2Ugb24gaW9zIGRldmljZXNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogZW1wdHkgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5uYW1lICsgXCIuIFwiICsgdGhpcy5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGV4aXN0aW5nIGluIElFOVxuICAgICAgICAgICAgICAgIGxldCBzdGFja0xpbmVzID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrTGluZXNbMF0gJiYgIXN0YWNrTGluZXNbMF0ubWF0Y2godGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFja0xpbmVzID0gc3RhY2tMaW5lcy5zbGljZSgxKTsgLy8gcmVtb3ZlcyBsaW5lIGZyb20gc3RhY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgKz0gXCJcXG5cIiArIHN0YWNrTGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBWUEsTUFBTSxtQkFBbUIsU0FBU0Esa0JBQWdCLEdBQUcsTUFBTTtBQUV2RCxPQUFNLE1BQU0sTUFBTSxLQUFLO0FBQzFCO0FBR0QsaUJBQWlCLFlBQVksT0FBTyxPQUFPLE1BQU0sVUFBVTtBQUUzRCxNQUFNLGtCQUFrQjtJQUNYLGdCQUFOLGNBQTRCLGdCQUFnQjtDQUMvQztDQUNBO0NBQ0EsWUFBWSxNQUFNLFNBQVM7QUFDdkIsUUFBTSxRQUFRO0FBQ2QsT0FBSyxPQUFPO0FBQ1osT0FBSyxVQUFVO0FBQ2YsYUFBVyxNQUFNLHNCQUFzQixXQUNuQyxPQUFNLGtCQUFrQixNQUFNLEtBQUssWUFBWTtLQUU5QztHQUNELElBQUksUUFBUSxJQUFJO0FBQ2hCLFFBQUssTUFBTSxNQUVQLEtBQUk7QUFDQSxVQUFNO0dBQ1QsU0FDTSxHQUFHLENBRVQ7QUFFTCxRQUFLLFFBQVEsS0FBSyxPQUFPLE9BQU8sS0FBSztBQUNyQyxPQUFJLE1BQU0sT0FBTztJQUViLElBQUksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLO0FBQ3hDLFdBQU8sV0FBVyxPQUFPLFdBQVcsR0FBRyxNQUFNLEtBQUssS0FBSyxDQUNuRCxjQUFhLFdBQVcsTUFBTSxFQUFFO0FBRXBDLFFBQUksV0FBVyxXQUFXLEVBQ3RCLE1BQUssUUFBUSxNQUFNO0lBR25CLE1BQUssU0FBUyxPQUFPLFdBQVcsS0FBSyxLQUFLO0dBRWpEO0VBQ0o7Q0FDSjtBQUNKIn0=