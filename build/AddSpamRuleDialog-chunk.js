import { __toESM } from "./chunk-chunk.js";
import { assertMainOrNode } from "./Env-chunk.js";
import { mithril_default } from "./mithril-chunk.js";
import { contains, objectEntries } from "./dist2-chunk.js";
import { lang } from "./LanguageViewModel-chunk.js";
import { SpamRuleFieldType, SpamRuleType, TUTA_MAIL_ADDRESS_DOMAINS, getSpamRuleField, getSpamRuleType } from "./TutanotaConstants-chunk.js";
import { isDomainOrTopLevelDomain, isMailAddress } from "./FormatValidator-chunk.js";
import { require_stream } from "./stream-chunk.js";
import { isOfflineError } from "./ErrorUtils-chunk.js";
import { Autocapitalize, Dialog, DropDownSelector, TextField } from "./Dialog-chunk.js";
import { locator } from "./CommonLocator-chunk.js";

//#region src/mail-app/settings/AddSpamRuleDialog.ts
var import_stream = __toESM(require_stream(), 1);
assertMainOrNode();
function showAddSpamRuleDialog(existingSpamRuleOrTemplate) {
	let loadedData = null;
	const typeItems = getSpamRuleTypeNameMapping();
	const selectedType = (0, import_stream.default)(existingSpamRuleOrTemplate && getSpamRuleType(existingSpamRuleOrTemplate) || typeItems[0].value);
	const valueFieldValue = (0, import_stream.default)(existingSpamRuleOrTemplate ? existingSpamRuleOrTemplate.value : "");
	const fieldValues = getSpamRuleFieldMapping();
	const selectedField = (0, import_stream.default)(existingSpamRuleOrTemplate ? getSpamRuleField(existingSpamRuleOrTemplate) : fieldValues[0].value);
	let form = () => [
		mithril_default(DropDownSelector, {
			items: fieldValues,
			label: "field_label",
			selectedValue: selectedField(),
			selectionChangedHandler: selectedField
		}),
		mithril_default(TextField, {
			label: "emailSenderPlaceholder_label",
			autocapitalize: Autocapitalize.none,
			value: valueFieldValue(),
			oninput: valueFieldValue,
			helpLabel: () => lang.get(validate(selectedType(), valueFieldValue(), selectedField(), loadedData, existingSpamRuleOrTemplate) ?? "emptyString_msg")
		}),
		mithril_default(DropDownSelector, {
			items: typeItems,
			label: "emailSenderRule_label",
			selectedValue: selectedType(),
			selectionChangedHandler: selectedType
		})
	];
	let addSpamRuleOkAction = async (dialog$1) => {
		try {
			if (existingSpamRuleOrTemplate && existingSpamRuleOrTemplate._id) await locator.customerFacade.editSpamRule(Object.assign({}, existingSpamRuleOrTemplate, {
				value: valueFieldValue(),
				field: selectedField(),
				type: selectedType()
			}));
else await locator.customerFacade.addSpamRule(selectedField(), selectedType(), valueFieldValue());
			dialog$1.close();
		} catch (error) {
			if (!isOfflineError(error)) dialog$1.close();
			throw error;
		}
	};
	const dialog = Dialog.showActionDialog({
		title: "addSpamRule_action",
		child: form,
		validator: () => validate(selectedType(), valueFieldValue(), selectedField(), loadedData, existingSpamRuleOrTemplate),
		allowOkWithReturn: true,
		okAction: addSpamRuleOkAction
	});
	loadData().then((loaded) => {
		loadedData = loaded;
		mithril_default.redraw();
	}, (e) => {
		dialog.close();
		throw e;
	});
}
async function loadData() {
	const customerServerProperties = await locator.customerFacade.loadCustomerServerProperties();
	const customer = await locator.logins.getUserController().loadCustomer();
	const customerInfo = await locator.logins.getUserController().loadCustomerInfo();
	const customDomains = customerInfo.domainInfos.map((d) => d.domain);
	const existingSpamRules = customerServerProperties.emailSenderList;
	return {
		customDomains,
		existingSpamRules
	};
}
/** @return translation key if validation fails or null if it succeeds */
function validate(type, value, field, loadedData, existingSpamRuleOrTemplate) {
	let currentValue = value.toLowerCase().trim();
	if (loadedData == null) return "loading_msg";
else if (currentValue === "") return "spamRuleEnterValue_msg";
else if (!isDomainOrTopLevelDomain(currentValue) && !isMailAddress(currentValue, false) && currentValue !== "*") return "invalidInputFormat_msg";
else if (isInvalidRule(type, currentValue, loadedData.customDomains)) return "emailSenderInvalidRule_msg";
else if (loadedData.existingSpamRules.some((r) => r.value === currentValue && (existingSpamRuleOrTemplate == null || r._id !== existingSpamRuleOrTemplate._id) && r.field === field)) return "emailSenderExistingRule_msg";
	return null;
}
function isInvalidRule(type, value, customDomains) {
	if (type !== SpamRuleType.WHITELIST) {
		if (isDomainOrTopLevelDomain(value)) return value === "tutao.de" || contains(TUTA_MAIL_ADDRESS_DOMAINS, value) || contains(customDomains, value);
else if (isMailAddress(value, false)) {
			let domain = value.split("@")[1];
			return domain === "tutao.de" || contains(customDomains, domain);
		}
	}
	return false;
}
function getSpamRuleFieldToName() {
	return {
		[SpamRuleFieldType.FROM]: lang.get("inboxRuleSenderEquals_action"),
		[SpamRuleFieldType.TO]: lang.get("inboxRuleToRecipientEquals_action"),
		[SpamRuleFieldType.CC]: lang.get("inboxRuleCCRecipientEquals_action"),
		[SpamRuleFieldType.BCC]: lang.get("inboxRuleBCCRecipientEquals_action")
	};
}
function getSpamRuleFieldMapping() {
	return objectEntries(getSpamRuleFieldToName()).map(([value, name]) => ({
		value,
		name
	}));
}
function getSpamRuleTypeNameMapping() {
	return [
		{
			value: SpamRuleType.WHITELIST,
			name: lang.get("emailSenderWhitelist_action")
		},
		{
			value: SpamRuleType.BLACKLIST,
			name: lang.get("emailSenderBlacklist_action")
		},
		{
			value: SpamRuleType.DISCARD,
			name: lang.get("emailSenderDiscardlist_action")
		}
	];
}

//#endregion
export { getSpamRuleFieldMapping, getSpamRuleFieldToName, getSpamRuleTypeNameMapping, showAddSpamRuleDialog };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWRkU3BhbVJ1bGVEaWFsb2ctY2h1bmsuanMiLCJuYW1lcyI6WyJleGlzdGluZ1NwYW1SdWxlT3JUZW1wbGF0ZTogRW1haWxTZW5kZXJMaXN0RWxlbWVudCB8IG51bGwiLCJsb2FkZWREYXRhOiBMb2FkZWREYXRhIHwgbnVsbCIsImRpYWxvZzogRGlhbG9nIiwidHlwZTogU3BhbVJ1bGVUeXBlIiwidmFsdWU6IHN0cmluZyIsImZpZWxkOiBTcGFtUnVsZUZpZWxkVHlwZSIsInR5cGU6IE51bWJlclN0cmluZyIsImN1c3RvbURvbWFpbnM6IHN0cmluZ1tdIl0sInNvdXJjZXMiOlsiLi4vc3JjL21haWwtYXBwL3NldHRpbmdzL0FkZFNwYW1SdWxlRGlhbG9nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gXCJtaXRocmlsXCJcbmltcG9ydCB0eXBlIHsgVHJhbnNsYXRpb25LZXkgfSBmcm9tIFwiLi4vLi4vY29tbW9uL21pc2MvTGFuZ3VhZ2VWaWV3TW9kZWxcIlxuaW1wb3J0IHsgbGFuZyB9IGZyb20gXCIuLi8uLi9jb21tb24vbWlzYy9MYW5ndWFnZVZpZXdNb2RlbFwiXG5pbXBvcnQgeyBpc0RvbWFpbk9yVG9wTGV2ZWxEb21haW4sIGlzTWFpbEFkZHJlc3MgfSBmcm9tIFwiLi4vLi4vY29tbW9uL21pc2MvRm9ybWF0VmFsaWRhdG9yXCJcbmltcG9ydCB7IGdldFNwYW1SdWxlRmllbGQsIGdldFNwYW1SdWxlVHlwZSwgU3BhbVJ1bGVGaWVsZFR5cGUsIFNwYW1SdWxlVHlwZSwgVFVUQV9NQUlMX0FERFJFU1NfRE9NQUlOUyB9IGZyb20gXCIuLi8uLi9jb21tb24vYXBpL2NvbW1vbi9UdXRhbm90YUNvbnN0YW50c1wiXG5pbXBvcnQgeyBjb250YWlucywgb2JqZWN0RW50cmllcyB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9ndWkvYmFzZS9EaWFsb2dcIlxuaW1wb3J0IHR5cGUgeyBFbWFpbFNlbmRlckxpc3RFbGVtZW50IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9hcGkvZW50aXRpZXMvc3lzL1R5cGVSZWZzLmpzXCJcbmltcG9ydCBzdHJlYW0gZnJvbSBcIm1pdGhyaWwvc3RyZWFtXCJcbmltcG9ydCB0eXBlIHsgU2VsZWN0b3JJdGVtTGlzdCB9IGZyb20gXCIuLi8uLi9jb21tb24vZ3VpL2Jhc2UvRHJvcERvd25TZWxlY3Rvci5qc1wiXG5pbXBvcnQgeyBEcm9wRG93blNlbGVjdG9yIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9ndWkvYmFzZS9Ecm9wRG93blNlbGVjdG9yLmpzXCJcbmltcG9ydCB7IEF1dG9jYXBpdGFsaXplLCBUZXh0RmllbGQgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2d1aS9iYXNlL1RleHRGaWVsZC5qc1wiXG5pbXBvcnQgeyBsb2NhdG9yIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9hcGkvbWFpbi9Db21tb25Mb2NhdG9yXCJcbmltcG9ydCB7IGFzc2VydE1haW5Pck5vZGUgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2FwaS9jb21tb24vRW52XCJcbmltcG9ydCB7IGlzT2ZmbGluZUVycm9yIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9hcGkvY29tbW9uL3V0aWxzL0Vycm9yVXRpbHMuanNcIlxuXG5hc3NlcnRNYWluT3JOb2RlKClcblxudHlwZSBMb2FkZWREYXRhID0geyBjdXN0b21Eb21haW5zOiBzdHJpbmdbXTsgZXhpc3RpbmdTcGFtUnVsZXM6IEVtYWlsU2VuZGVyTGlzdEVsZW1lbnRbXSB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93QWRkU3BhbVJ1bGVEaWFsb2coZXhpc3RpbmdTcGFtUnVsZU9yVGVtcGxhdGU6IEVtYWlsU2VuZGVyTGlzdEVsZW1lbnQgfCBudWxsKSB7XG5cdGxldCBsb2FkZWREYXRhOiBMb2FkZWREYXRhIHwgbnVsbCA9IG51bGxcblxuXHRjb25zdCB0eXBlSXRlbXMgPSBnZXRTcGFtUnVsZVR5cGVOYW1lTWFwcGluZygpXG5cdGNvbnN0IHNlbGVjdGVkVHlwZSA9IHN0cmVhbSgoZXhpc3RpbmdTcGFtUnVsZU9yVGVtcGxhdGUgJiYgZ2V0U3BhbVJ1bGVUeXBlKGV4aXN0aW5nU3BhbVJ1bGVPclRlbXBsYXRlKSkgfHwgdHlwZUl0ZW1zWzBdLnZhbHVlKVxuXHRjb25zdCB2YWx1ZUZpZWxkVmFsdWUgPSBzdHJlYW0oZXhpc3RpbmdTcGFtUnVsZU9yVGVtcGxhdGUgPyBleGlzdGluZ1NwYW1SdWxlT3JUZW1wbGF0ZS52YWx1ZSA6IFwiXCIpXG5cdGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0U3BhbVJ1bGVGaWVsZE1hcHBpbmcoKVxuXHRjb25zdCBzZWxlY3RlZEZpZWxkID0gc3RyZWFtKGV4aXN0aW5nU3BhbVJ1bGVPclRlbXBsYXRlID8gZ2V0U3BhbVJ1bGVGaWVsZChleGlzdGluZ1NwYW1SdWxlT3JUZW1wbGF0ZSkgOiBmaWVsZFZhbHVlc1swXS52YWx1ZSlcblxuXHRsZXQgZm9ybSA9ICgpID0+IFtcblx0XHRtKERyb3BEb3duU2VsZWN0b3IsIHtcblx0XHRcdGl0ZW1zOiBmaWVsZFZhbHVlcyxcblx0XHRcdGxhYmVsOiBcImZpZWxkX2xhYmVsXCIsXG5cdFx0XHRzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZEZpZWxkKCksXG5cdFx0XHRzZWxlY3Rpb25DaGFuZ2VkSGFuZGxlcjogc2VsZWN0ZWRGaWVsZCxcblx0XHR9KSxcblx0XHRtKFRleHRGaWVsZCwge1xuXHRcdFx0bGFiZWw6IFwiZW1haWxTZW5kZXJQbGFjZWhvbGRlcl9sYWJlbFwiLFxuXHRcdFx0YXV0b2NhcGl0YWxpemU6IEF1dG9jYXBpdGFsaXplLm5vbmUsXG5cdFx0XHR2YWx1ZTogdmFsdWVGaWVsZFZhbHVlKCksXG5cdFx0XHRvbmlucHV0OiB2YWx1ZUZpZWxkVmFsdWUsXG5cdFx0XHRoZWxwTGFiZWw6ICgpID0+XG5cdFx0XHRcdGxhbmcuZ2V0KHZhbGlkYXRlKHNlbGVjdGVkVHlwZSgpLCB2YWx1ZUZpZWxkVmFsdWUoKSwgc2VsZWN0ZWRGaWVsZCgpLCBsb2FkZWREYXRhLCBleGlzdGluZ1NwYW1SdWxlT3JUZW1wbGF0ZSkgPz8gXCJlbXB0eVN0cmluZ19tc2dcIiksXG5cdFx0fSksXG5cdFx0bShEcm9wRG93blNlbGVjdG9yLCB7XG5cdFx0XHRpdGVtczogdHlwZUl0ZW1zLFxuXHRcdFx0bGFiZWw6IFwiZW1haWxTZW5kZXJSdWxlX2xhYmVsXCIsXG5cdFx0XHRzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFR5cGUoKSxcblx0XHRcdHNlbGVjdGlvbkNoYW5nZWRIYW5kbGVyOiBzZWxlY3RlZFR5cGUsXG5cdFx0fSksXG5cdF1cblxuXHRsZXQgYWRkU3BhbVJ1bGVPa0FjdGlvbiA9IGFzeW5jIChkaWFsb2c6IERpYWxvZykgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoZXhpc3RpbmdTcGFtUnVsZU9yVGVtcGxhdGUgJiYgZXhpc3RpbmdTcGFtUnVsZU9yVGVtcGxhdGUuX2lkKSB7XG5cdFx0XHRcdGF3YWl0IGxvY2F0b3IuY3VzdG9tZXJGYWNhZGUuZWRpdFNwYW1SdWxlKFxuXHRcdFx0XHRcdE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nU3BhbVJ1bGVPclRlbXBsYXRlLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWVGaWVsZFZhbHVlKCksXG5cdFx0XHRcdFx0XHRmaWVsZDogc2VsZWN0ZWRGaWVsZCgpLFxuXHRcdFx0XHRcdFx0dHlwZTogc2VsZWN0ZWRUeXBlKCksXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0IGxvY2F0b3IuY3VzdG9tZXJGYWNhZGUuYWRkU3BhbVJ1bGUoc2VsZWN0ZWRGaWVsZCgpLCBzZWxlY3RlZFR5cGUoKSwgdmFsdWVGaWVsZFZhbHVlKCkpXG5cdFx0XHR9XG5cdFx0XHRkaWFsb2cuY2xvc2UoKVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoIWlzT2ZmbGluZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRkaWFsb2cuY2xvc2UoKVxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgZXJyb3Jcblx0XHR9XG5cdH1cblxuXHRjb25zdCBkaWFsb2cgPSBEaWFsb2cuc2hvd0FjdGlvbkRpYWxvZyh7XG5cdFx0dGl0bGU6IFwiYWRkU3BhbVJ1bGVfYWN0aW9uXCIsXG5cdFx0Y2hpbGQ6IGZvcm0sXG5cdFx0dmFsaWRhdG9yOiAoKSA9PiB2YWxpZGF0ZShzZWxlY3RlZFR5cGUoKSwgdmFsdWVGaWVsZFZhbHVlKCksIHNlbGVjdGVkRmllbGQoKSwgbG9hZGVkRGF0YSwgZXhpc3RpbmdTcGFtUnVsZU9yVGVtcGxhdGUpLFxuXHRcdGFsbG93T2tXaXRoUmV0dXJuOiB0cnVlLFxuXHRcdG9rQWN0aW9uOiBhZGRTcGFtUnVsZU9rQWN0aW9uLFxuXHR9KVxuXG5cdC8vIHN0YXJ0IGxvYWRpbmcgaW4gYmFja2dyb3VuZFxuXHRsb2FkRGF0YSgpLnRoZW4oXG5cdFx0KGxvYWRlZCkgPT4ge1xuXHRcdFx0bG9hZGVkRGF0YSA9IGxvYWRlZFxuXHRcdFx0bS5yZWRyYXcoKVxuXHRcdH0sXG5cdFx0KGUpID0+IHtcblx0XHRcdC8vIE1pZ2h0IGJlIGFuIG9mZmxpbmUgZXJyb3IsIGlmIHdlIGNhbid0IGxvYWQgZGF0YSB3ZSBzaG91bGQgY2xvc2UgdGhlIGRpYWxvZyByZWdhcmRsZXNzLCB0aGV5IGNhbiB0cnkgb3BlbmluZyBpdCBhZ2FpblxuXHRcdFx0ZGlhbG9nLmNsb3NlKClcblx0XHRcdHRocm93IGVcblx0XHR9LFxuXHQpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWREYXRhKCk6IFByb21pc2U8TG9hZGVkRGF0YT4ge1xuXHRjb25zdCBjdXN0b21lclNlcnZlclByb3BlcnRpZXMgPSBhd2FpdCBsb2NhdG9yLmN1c3RvbWVyRmFjYWRlLmxvYWRDdXN0b21lclNlcnZlclByb3BlcnRpZXMoKVxuXHRjb25zdCBjdXN0b21lciA9IGF3YWl0IGxvY2F0b3IubG9naW5zLmdldFVzZXJDb250cm9sbGVyKCkubG9hZEN1c3RvbWVyKClcblx0Y29uc3QgY3VzdG9tZXJJbmZvID0gYXdhaXQgbG9jYXRvci5sb2dpbnMuZ2V0VXNlckNvbnRyb2xsZXIoKS5sb2FkQ3VzdG9tZXJJbmZvKClcblxuXHRjb25zdCBjdXN0b21Eb21haW5zID0gY3VzdG9tZXJJbmZvLmRvbWFpbkluZm9zLm1hcCgoZCkgPT4gZC5kb21haW4pXG5cdGNvbnN0IGV4aXN0aW5nU3BhbVJ1bGVzID0gY3VzdG9tZXJTZXJ2ZXJQcm9wZXJ0aWVzLmVtYWlsU2VuZGVyTGlzdFxuXG5cdHJldHVybiB7IGN1c3RvbURvbWFpbnMsIGV4aXN0aW5nU3BhbVJ1bGVzIH1cbn1cblxuLyoqIEByZXR1cm4gdHJhbnNsYXRpb24ga2V5IGlmIHZhbGlkYXRpb24gZmFpbHMgb3IgbnVsbCBpZiBpdCBzdWNjZWVkcyAqL1xuZnVuY3Rpb24gdmFsaWRhdGUoXG5cdHR5cGU6IFNwYW1SdWxlVHlwZSxcblx0dmFsdWU6IHN0cmluZyxcblx0ZmllbGQ6IFNwYW1SdWxlRmllbGRUeXBlLFxuXHRsb2FkZWREYXRhOiBMb2FkZWREYXRhIHwgbnVsbCxcblx0ZXhpc3RpbmdTcGFtUnVsZU9yVGVtcGxhdGU6IEVtYWlsU2VuZGVyTGlzdEVsZW1lbnQgfCBudWxsLFxuKTogVHJhbnNsYXRpb25LZXkgfCBudWxsIHtcblx0bGV0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpXG5cblx0aWYgKGxvYWRlZERhdGEgPT0gbnVsbCkge1xuXHRcdHJldHVybiBcImxvYWRpbmdfbXNnXCJcblx0fSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPT09IFwiXCIpIHtcblx0XHRyZXR1cm4gXCJzcGFtUnVsZUVudGVyVmFsdWVfbXNnXCJcblx0fSBlbHNlIGlmICghaXNEb21haW5PclRvcExldmVsRG9tYWluKGN1cnJlbnRWYWx1ZSkgJiYgIWlzTWFpbEFkZHJlc3MoY3VycmVudFZhbHVlLCBmYWxzZSkgJiYgY3VycmVudFZhbHVlICE9PSBcIipcIikge1xuXHRcdHJldHVybiBcImludmFsaWRJbnB1dEZvcm1hdF9tc2dcIlxuXHR9IGVsc2UgaWYgKGlzSW52YWxpZFJ1bGUodHlwZSwgY3VycmVudFZhbHVlLCBsb2FkZWREYXRhLmN1c3RvbURvbWFpbnMpKSB7XG5cdFx0cmV0dXJuIFwiZW1haWxTZW5kZXJJbnZhbGlkUnVsZV9tc2dcIlxuXHR9IGVsc2UgaWYgKFxuXHRcdGxvYWRlZERhdGEuZXhpc3RpbmdTcGFtUnVsZXMuc29tZShcblx0XHRcdChyKSA9PlxuXHRcdFx0XHRyLnZhbHVlID09PSBjdXJyZW50VmFsdWUgJiYgLy8gT25seSBjb2xsaXNpb24gaWYgd2UgZG9uJ3QgZWRpdCBleGlzdGluZyBvbmUgb3IgZXhpc3Rpbmcgb25lIGhhcyBkaWZmZXJlbnQgaWRcblx0XHRcdFx0KGV4aXN0aW5nU3BhbVJ1bGVPclRlbXBsYXRlID09IG51bGwgfHwgci5faWQgIT09IGV4aXN0aW5nU3BhbVJ1bGVPclRlbXBsYXRlLl9pZCkgJiZcblx0XHRcdFx0ci5maWVsZCA9PT0gZmllbGQsXG5cdFx0KVxuXHQpIHtcblx0XHRyZXR1cm4gXCJlbWFpbFNlbmRlckV4aXN0aW5nUnVsZV9tc2dcIlxuXHR9XG5cblx0cmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gaXNJbnZhbGlkUnVsZSh0eXBlOiBOdW1iZXJTdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGN1c3RvbURvbWFpbnM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG5cdGlmICh0eXBlICE9PSBTcGFtUnVsZVR5cGUuV0hJVEVMSVNUKSB7XG5cdFx0aWYgKGlzRG9tYWluT3JUb3BMZXZlbERvbWFpbih2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gXCJ0dXRhby5kZVwiIHx8IGNvbnRhaW5zKFRVVEFfTUFJTF9BRERSRVNTX0RPTUFJTlMsIHZhbHVlKSB8fCBjb250YWlucyhjdXN0b21Eb21haW5zLCB2YWx1ZSlcblx0XHR9IGVsc2UgaWYgKGlzTWFpbEFkZHJlc3ModmFsdWUsIGZhbHNlKSkge1xuXHRcdFx0bGV0IGRvbWFpbiA9IHZhbHVlLnNwbGl0KFwiQFwiKVsxXVxuXHRcdFx0cmV0dXJuIGRvbWFpbiA9PT0gXCJ0dXRhby5kZVwiIHx8IGNvbnRhaW5zKGN1c3RvbURvbWFpbnMsIGRvbWFpbilcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNwYW1SdWxlRmllbGRUb05hbWUoKTogUmVjb3JkPFNwYW1SdWxlRmllbGRUeXBlLCBzdHJpbmc+IHtcblx0cmV0dXJuIHtcblx0XHRbU3BhbVJ1bGVGaWVsZFR5cGUuRlJPTV06IGxhbmcuZ2V0KFwiaW5ib3hSdWxlU2VuZGVyRXF1YWxzX2FjdGlvblwiKSxcblx0XHRbU3BhbVJ1bGVGaWVsZFR5cGUuVE9dOiBsYW5nLmdldChcImluYm94UnVsZVRvUmVjaXBpZW50RXF1YWxzX2FjdGlvblwiKSxcblx0XHRbU3BhbVJ1bGVGaWVsZFR5cGUuQ0NdOiBsYW5nLmdldChcImluYm94UnVsZUNDUmVjaXBpZW50RXF1YWxzX2FjdGlvblwiKSxcblx0XHRbU3BhbVJ1bGVGaWVsZFR5cGUuQkNDXTogbGFuZy5nZXQoXCJpbmJveFJ1bGVCQ0NSZWNpcGllbnRFcXVhbHNfYWN0aW9uXCIpLFxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGFtUnVsZUZpZWxkTWFwcGluZygpOiBTZWxlY3Rvckl0ZW1MaXN0PFNwYW1SdWxlRmllbGRUeXBlPiB7XG5cdHJldHVybiBvYmplY3RFbnRyaWVzKGdldFNwYW1SdWxlRmllbGRUb05hbWUoKSkubWFwKChbdmFsdWUsIG5hbWVdKSA9PiAoe1xuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdH0pKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BhbVJ1bGVUeXBlTmFtZU1hcHBpbmcoKTogU2VsZWN0b3JJdGVtTGlzdDxTcGFtUnVsZVR5cGU+IHtcblx0cmV0dXJuIFtcblx0XHR7XG5cdFx0XHR2YWx1ZTogU3BhbVJ1bGVUeXBlLldISVRFTElTVCxcblx0XHRcdG5hbWU6IGxhbmcuZ2V0KFwiZW1haWxTZW5kZXJXaGl0ZWxpc3RfYWN0aW9uXCIpLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0dmFsdWU6IFNwYW1SdWxlVHlwZS5CTEFDS0xJU1QsXG5cdFx0XHRuYW1lOiBsYW5nLmdldChcImVtYWlsU2VuZGVyQmxhY2tsaXN0X2FjdGlvblwiKSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdHZhbHVlOiBTcGFtUnVsZVR5cGUuRElTQ0FSRCxcblx0XHRcdG5hbWU6IGxhbmcuZ2V0KFwiZW1haWxTZW5kZXJEaXNjYXJkbGlzdF9hY3Rpb25cIiksXG5cdFx0fSxcblx0XVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQWdCQSxrQkFBa0I7QUFJWCxTQUFTLHNCQUFzQkEsNEJBQTJEO0NBQ2hHLElBQUlDLGFBQWdDO0NBRXBDLE1BQU0sWUFBWSw0QkFBNEI7Q0FDOUMsTUFBTSxlQUFlLDJCQUFRLDhCQUE4QixnQkFBZ0IsMkJBQTJCLElBQUssVUFBVSxHQUFHLE1BQU07Q0FDOUgsTUFBTSxrQkFBa0IsMkJBQU8sNkJBQTZCLDJCQUEyQixRQUFRLEdBQUc7Q0FDbEcsTUFBTSxjQUFjLHlCQUF5QjtDQUM3QyxNQUFNLGdCQUFnQiwyQkFBTyw2QkFBNkIsaUJBQWlCLDJCQUEyQixHQUFHLFlBQVksR0FBRyxNQUFNO0NBRTlILElBQUksT0FBTyxNQUFNO0VBQ2hCLGdCQUFFLGtCQUFrQjtHQUNuQixPQUFPO0dBQ1AsT0FBTztHQUNQLGVBQWUsZUFBZTtHQUM5Qix5QkFBeUI7RUFDekIsRUFBQztFQUNGLGdCQUFFLFdBQVc7R0FDWixPQUFPO0dBQ1AsZ0JBQWdCLGVBQWU7R0FDL0IsT0FBTyxpQkFBaUI7R0FDeEIsU0FBUztHQUNULFdBQVcsTUFDVixLQUFLLElBQUksU0FBUyxjQUFjLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLFlBQVksMkJBQTJCLElBQUksa0JBQWtCO0VBQ3BJLEVBQUM7RUFDRixnQkFBRSxrQkFBa0I7R0FDbkIsT0FBTztHQUNQLE9BQU87R0FDUCxlQUFlLGNBQWM7R0FDN0IseUJBQXlCO0VBQ3pCLEVBQUM7Q0FDRjtDQUVELElBQUks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