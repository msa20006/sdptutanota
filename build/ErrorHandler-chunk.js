import { assertMainOrNodeBoot, isTest } from "./Env-chunk.js";
import { delay } from "./dist2-chunk.js";

//#region src/common/misc/ErrorHandler.ts
assertMainOrNodeBoot();
/** Produced async function which will not try to run more often than @param ms. Does not cache the result. */
function produceThrottledFunction(ms, fn) {
	let lastTry = 0;
	return async () => {
		const previousTry = lastTry;
		lastTry = Date.now();
		const sincePreviousTry = Date.now() - previousTry;
		if (previousTry !== 0 && sincePreviousTry < ms) {
			const waitShouldEndAt = previousTry + ms;
			const timeUntilWaitEnd = waitShouldEndAt - Date.now();
			await delay(timeUntilWaitEnd);
		}
		return fn();
	};
}
/**
* Throttled error handler. We have issues with error loops when reloading the page in Firefox and this gives browser a break of event
* loop to be able to reload the page properly.
* */
const importErrorHandler = produceThrottledFunction(200, () => import("./ErrorHandlerImpl2-chunk.js"));
async function handleUncaughtError(e) {
	if (isTest()) throw e;
	try {
		console.log("error", e, e.stack);
		const { handleUncaughtErrorImpl } = await importErrorHandler();
		await handleUncaughtErrorImpl(e);
	} catch (e$1) {
		console.error("Encountered error when trying to handle errors with ErrorHandlerImpl", e$1);
	}
}
async function disableErrorHandlingDuringLogout() {
	try {
		const { disableErrorHandlingDuringLogout: disableErrorHandlingDuringLogout$1 } = await importErrorHandler();
		disableErrorHandlingDuringLogout$1();
	} catch (e) {
		console.error("Could not import ErrorHandlerImpl", e);
	}
}

//#endregion
export { disableErrorHandlingDuringLogout, handleUncaughtError };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXJyb3JIYW5kbGVyLWNodW5rLmpzIiwibmFtZXMiOlsibXM6IG51bWJlciIsImZuOiAoKSA9PiBQcm9taXNlPFI+IiwiZTogRXJyb3IiLCJlIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9taXNjL0Vycm9ySGFuZGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEhhbmRsZXIgZm9yIGFsbCB0aGUgdW5jYXVnaHQgZXJyb3JzLlxuICogRXJyb3JIYW5kbGVyIGlzIGRlY291cGxlZCBmcm9tIEVycm9ySGFuZGxlckltcGwgdG8gcmVkdWNlIGJvb3QgYnVuZGxlIHNpemUuXG4gKi9cbmltcG9ydCB7IGFzc2VydE1haW5Pck5vZGVCb290LCBpc1Rlc3QgfSBmcm9tIFwiLi4vYXBpL2NvbW1vbi9FbnZcIlxuaW1wb3J0IHsgZGVsYXkgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzXCJcblxuYXNzZXJ0TWFpbk9yTm9kZUJvb3QoKVxuXG4vKiogUHJvZHVjZWQgYXN5bmMgZnVuY3Rpb24gd2hpY2ggd2lsbCBub3QgdHJ5IHRvIHJ1biBtb3JlIG9mdGVuIHRoYW4gQHBhcmFtIG1zLiBEb2VzIG5vdCBjYWNoZSB0aGUgcmVzdWx0LiAqL1xuZnVuY3Rpb24gcHJvZHVjZVRocm90dGxlZEZ1bmN0aW9uPFI+KG1zOiBudW1iZXIsIGZuOiAoKSA9PiBQcm9taXNlPFI+KTogKCkgPT4gUHJvbWlzZTxSPiB7XG5cdGxldCBsYXN0VHJ5ID0gMFxuXHRyZXR1cm4gYXN5bmMgKCkgPT4ge1xuXHRcdGNvbnN0IHByZXZpb3VzVHJ5ID0gbGFzdFRyeVxuXHRcdGxhc3RUcnkgPSBEYXRlLm5vdygpXG5cdFx0Y29uc3Qgc2luY2VQcmV2aW91c1RyeSA9IERhdGUubm93KCkgLSBwcmV2aW91c1RyeVxuXG5cdFx0Ly8gfC0tLXwtLS0tfC0tLS0tLS0tLS0tLS0tfC0tLS0tfFxuXHRcdC8vICAgMTAwMSAgMTAwMyAgICAgICAgICAgMTAxMVxuXHRcdC8vICAgIGEgICAgIGIgICAgICAgICAgICAgIGNcblx0XHQvLyBtczogMTBcblx0XHQvLyBhOiBwcmV2aW91c1RyeVxuXHRcdC8vIGI6IERhdGUubm93KClcblx0XHQvLyBjOiBwcmV2aW91c1RyeSArIG1zXG5cdFx0Ly8gSWYgdGhlIGxhc3QgY2FsbCB3YXMgYXQgMTAwMSBhbmQgd2UgYXJlIG5vdyBjYWxsaW5nIGZuIGFnYWluIGF0IDEwMDMgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWwgMTAxMSB3aGljaCB3b3VsZCBiZSAoYSArIG1zKSAtIGIuXG5cblx0XHRpZiAocHJldmlvdXNUcnkgIT09IDAgJiYgc2luY2VQcmV2aW91c1RyeSA8IG1zKSB7XG5cdFx0XHRjb25zdCB3YWl0U2hvdWxkRW5kQXQgPSBwcmV2aW91c1RyeSArIG1zXG5cdFx0XHRjb25zdCB0aW1lVW50aWxXYWl0RW5kID0gd2FpdFNob3VsZEVuZEF0IC0gRGF0ZS5ub3coKVxuXHRcdFx0YXdhaXQgZGVsYXkodGltZVVudGlsV2FpdEVuZClcblx0XHR9XG5cblx0XHRyZXR1cm4gZm4oKVxuXHR9XG59XG5cbi8qKlxuICogVGhyb3R0bGVkIGVycm9yIGhhbmRsZXIuIFdlIGhhdmUgaXNzdWVzIHdpdGggZXJyb3IgbG9vcHMgd2hlbiByZWxvYWRpbmcgdGhlIHBhZ2UgaW4gRmlyZWZveCBhbmQgdGhpcyBnaXZlcyBicm93c2VyIGEgYnJlYWsgb2YgZXZlbnRcbiAqIGxvb3AgdG8gYmUgYWJsZSB0byByZWxvYWQgdGhlIHBhZ2UgcHJvcGVybHkuXG4gKiAqL1xuY29uc3QgaW1wb3J0RXJyb3JIYW5kbGVyID0gcHJvZHVjZVRocm90dGxlZEZ1bmN0aW9uKDIwMCwgKCkgPT4gaW1wb3J0KFwiLi9FcnJvckhhbmRsZXJJbXBsLmpzXCIpKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlVW5jYXVnaHRFcnJvcihlOiBFcnJvcikge1xuXHRpZiAoaXNUZXN0KCkpIHtcblx0XHR0aHJvdyBlXG5cdH1cblxuXHR0cnkge1xuXHRcdGNvbnNvbGUubG9nKFwiZXJyb3JcIiwgZSwgZS5zdGFjaylcblx0XHRjb25zdCB7IGhhbmRsZVVuY2F1Z2h0RXJyb3JJbXBsIH0gPSBhd2FpdCBpbXBvcnRFcnJvckhhbmRsZXIoKVxuXHRcdGF3YWl0IGhhbmRsZVVuY2F1Z2h0RXJyb3JJbXBsKGUpXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRjb25zb2xlLmVycm9yKFwiRW5jb3VudGVyZWQgZXJyb3Igd2hlbiB0cnlpbmcgdG8gaGFuZGxlIGVycm9ycyB3aXRoIEVycm9ySGFuZGxlckltcGxcIiwgZSlcblx0fVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlzYWJsZUVycm9ySGFuZGxpbmdEdXJpbmdMb2dvdXQoKSB7XG5cdHRyeSB7XG5cdFx0Y29uc3QgeyBkaXNhYmxlRXJyb3JIYW5kbGluZ0R1cmluZ0xvZ291dCB9ID0gYXdhaXQgaW1wb3J0RXJyb3JIYW5kbGVyKClcblx0XHRkaXNhYmxlRXJyb3JIYW5kbGluZ0R1cmluZ0xvZ291dCgpXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGltcG9ydCBFcnJvckhhbmRsZXJJbXBsXCIsIGUpXG5cdH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7OztBQU9BLHNCQUFzQjs7QUFHdEIsU0FBUyx5QkFBNEJBLElBQVlDLElBQXdDO0NBQ3hGLElBQUksVUFBVTtBQUNkLFFBQU8sWUFBWTtFQUNsQixNQUFNLGNBQWM7QUFDcEIsWUFBVSxLQUFLLEtBQUs7RUFDcEIsTUFBTSxtQkFBbUIsS0FBSyxLQUFLLEdBQUc7QUFXdEMsTUFBSSxnQkFBZ0IsS0FBSyxtQkFBbUIsSUFBSTtHQUMvQyxNQUFNLGtCQUFrQixjQUFjO0dBQ3RDLE1BQU0sbUJBQW1CLGtCQUFrQixLQUFLLEtBQUs7QUFDckQsU0FBTSxNQUFNLGlCQUFpQjtFQUM3QjtBQUVELFNBQU8sSUFBSTtDQUNYO0FBQ0Q7Ozs7O0FBTUQsTUFBTSxxQkFBcUIseUJBQXlCLEtBQUssTUFBTSxPQUFPLGdDQUF5QjtBQUV4RixlQUFlLG9CQUFvQkMsR0FBVTtBQUNuRCxLQUFJLFFBQVEsQ0FDWCxPQUFNO0FBR1AsS0FBSTtBQUNILFVBQVEsSUFBSSxTQUFTLEdBQUcsRUFBRSxNQUFNO0VBQ2hDLE1BQU0sRUFBRSx5QkFBeUIsR0FBRyxNQUFNLG9CQUFvQjtBQUM5RCxRQUFNLHdCQUF3QixFQUFFO0NBQ2hDLFNBQVFDLEtBQUc7QUFDWCxVQUFRLE1BQU0sd0VBQXdFQSxJQUFFO0NBQ3hGO0FBQ0Q7QUFFTSxlQUFlLG1DQUFtQztBQUN4RCxLQUFJO0VBQ0gsTUFBTSxFQUFFLHNFQUFrQyxHQUFHLE1BQU0sb0JBQW9CO0FBQ3ZFLHNDQUFrQztDQUNsQyxTQUFRLEdBQUc7QUFDWCxVQUFRLE1BQU0scUNBQXFDLEVBQUU7Q0FDckQ7QUFDRCJ9