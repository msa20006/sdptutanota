import "./dist-chunk.js";
import "./ProgrammingError-chunk.js";
import { assertWorkerOrNode } from "./Env-chunk.js";
import { isSameTypeRef, neverNull } from "./dist2-chunk.js";
import "./EntityUtils-chunk.js";
import "./TypeModels-chunk.js";
import { InternalRecipientKeyDataTypeRef, createGroupInvitationDeleteData, createGroupInvitationPostData, createGroupInvitationPutData, createSharedGroupData } from "./TypeRefs-chunk.js";
import "./TypeModels2-chunk.js";
import { GroupInfoTypeRef } from "./TypeRefs2-chunk.js";
import "./RestError-chunk.js";
import "./CryptoError-chunk.js";
import "./error-chunk.js";
import { RecipientsNotFoundError } from "./RecipientsNotFoundError-chunk.js";
import { aes256RandomKey, bitArrayToUint8Array, encryptKey, uint8ArrayToBitArray } from "./dist3-chunk.js";
import { parseKeyVersion } from "./KeyLoaderFacade-chunk.js";
import { encryptBytes, encryptKeyWithVersionedKey, encryptString } from "./CryptoWrapper-chunk.js";
import { GroupInvitationService } from "./Services2-chunk.js";

//#region src/common/api/worker/facades/lazy/ShareFacade.ts
assertWorkerOrNode();
var ShareFacade = class {
	constructor(userFacade, cryptoFacade, serviceExecutor, entityClient, keyLoaderFacade) {
		this.userFacade = userFacade;
		this.cryptoFacade = cryptoFacade;
		this.serviceExecutor = serviceExecutor;
		this.entityClient = entityClient;
		this.keyLoaderFacade = keyLoaderFacade;
	}
	async sendGroupInvitation(sharedGroupInfo, recipientMailAddresses, shareCapability) {
		const sharedGroupKey = await this.keyLoaderFacade.getCurrentSymGroupKey(sharedGroupInfo.group);
		const invitationData = await this.prepareGroupInvitation(sharedGroupKey, sharedGroupInfo, recipientMailAddresses, shareCapability);
		return this.sendGroupInvitationRequest(invitationData);
	}
	async sendGroupInvitationRequest(invitationData) {
		return this.serviceExecutor.post(GroupInvitationService, invitationData);
	}
	async prepareGroupInvitation(sharedGroupKey, sharedGroupInfo, recipientMailAddresses, shareCapability) {
		const userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, this.userFacade.getLoggedInUser().userGroup.groupInfo);
		const userGroupInfoSessionKey = await this.cryptoFacade.resolveSessionKeyForInstance(userGroupInfo);
		const sharedGroupInfoSessionKey = await this.cryptoFacade.resolveSessionKeyForInstance(sharedGroupInfo);
		const bucketKey = aes256RandomKey();
		const invitationSessionKey = aes256RandomKey();
		const sharedGroupEncInviterGroupInfoKey = encryptKeyWithVersionedKey(sharedGroupKey, neverNull(userGroupInfoSessionKey));
		const sharedGroupEncSharedGroupInfoKey = encryptKeyWithVersionedKey(sharedGroupKey, neverNull(sharedGroupInfoSessionKey));
		const sharedGroupData = createSharedGroupData({
			sessionEncInviterName: encryptString(invitationSessionKey, userGroupInfo.name),
			sessionEncSharedGroupKey: encryptBytes(invitationSessionKey, bitArrayToUint8Array(sharedGroupKey.object)),
			sessionEncSharedGroupName: encryptString(invitationSessionKey, sharedGroupInfo.name),
			bucketEncInvitationSessionKey: encryptKey(bucketKey, invitationSessionKey),
			capability: shareCapability,
			sharedGroup: sharedGroupInfo.group,
			sharedGroupEncInviterGroupInfoKey: sharedGroupEncInviterGroupInfoKey.key,
			sharedGroupEncSharedGroupInfoKey: sharedGroupEncSharedGroupInfoKey.key,
			sharedGroupKeyVersion: String(sharedGroupKey.version)
		});
		const invitationData = createGroupInvitationPostData({
			sharedGroupData,
			internalKeyData: []
		});
		const notFoundRecipients = [];
		for (let mailAddress of recipientMailAddresses) {
			const keyData = await this.cryptoFacade.encryptBucketKeyForInternalRecipient(userGroupInfo.group, bucketKey, mailAddress, notFoundRecipients);
			if (keyData && isSameTypeRef(keyData._type, InternalRecipientKeyDataTypeRef)) invitationData.internalKeyData.push(keyData);
		}
		if (notFoundRecipients.length > 0) throw new RecipientsNotFoundError(notFoundRecipients.join("\n"));
		return invitationData;
	}
	async acceptGroupInvitation(invitation) {
		const userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, this.userFacade.getLoggedInUser().userGroup.groupInfo);
		const userGroupInfoSessionKey = await this.cryptoFacade.resolveSessionKeyForInstance(userGroupInfo);
		const sharedGroupKey = {
			object: uint8ArrayToBitArray(invitation.sharedGroupKey),
			version: parseKeyVersion(invitation.sharedGroupKeyVersion)
		};
		const userGroupKey = this.userFacade.getCurrentUserGroupKey();
		const userGroupEncGroupKey = encryptKeyWithVersionedKey(userGroupKey, sharedGroupKey.object);
		const sharedGroupEncInviteeGroupInfoKey = encryptKeyWithVersionedKey(sharedGroupKey, neverNull(userGroupInfoSessionKey));
		const serviceData = createGroupInvitationPutData({
			receivedInvitation: invitation._id,
			userGroupEncGroupKey: userGroupEncGroupKey.key,
			sharedGroupEncInviteeGroupInfoKey: sharedGroupEncInviteeGroupInfoKey.key,
			userGroupKeyVersion: userGroupEncGroupKey.encryptingKeyVersion.toString(),
			sharedGroupKeyVersion: sharedGroupEncInviteeGroupInfoKey.encryptingKeyVersion.toString()
		});
		await this.serviceExecutor.put(GroupInvitationService, serviceData);
	}
	async rejectOrCancelGroupInvitation(receivedGroupInvitationId) {
		const serviceData = createGroupInvitationDeleteData({ receivedInvitation: receivedGroupInvitationId });
		await this.serviceExecutor.delete(GroupInvitationService, serviceData);
	}
};

//#endregion
export { ShareFacade };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2hhcmVGYWNhZGUtY2h1bmsuanMiLCJuYW1lcyI6WyJ1c2VyRmFjYWRlOiBVc2VyRmFjYWRlIiwiY3J5cHRvRmFjYWRlOiBDcnlwdG9GYWNhZGUiLCJzZXJ2aWNlRXhlY3V0b3I6IElTZXJ2aWNlRXhlY3V0b3IiLCJlbnRpdHlDbGllbnQ6IEVudGl0eUNsaWVudCIsImtleUxvYWRlckZhY2FkZTogS2V5TG9hZGVyRmFjYWRlIiwic2hhcmVkR3JvdXBJbmZvOiBHcm91cEluZm8iLCJyZWNpcGllbnRNYWlsQWRkcmVzc2VzOiBBcnJheTxzdHJpbmc+Iiwic2hhcmVDYXBhYmlsaXR5OiBTaGFyZUNhcGFiaWxpdHkiLCJpbnZpdGF0aW9uRGF0YTogR3JvdXBJbnZpdGF0aW9uUG9zdERhdGEiLCJzaGFyZWRHcm91cEtleTogVmVyc2lvbmVkS2V5Iiwibm90Rm91bmRSZWNpcGllbnRzOiBBcnJheTxzdHJpbmc+IiwiaW52aXRhdGlvbjogUmVjZWl2ZWRHcm91cEludml0YXRpb24iLCJyZWNlaXZlZEdyb3VwSW52aXRhdGlvbklkOiBJZFR1cGxlIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9hcGkvd29ya2VyL2ZhY2FkZXMvbGF6eS9TaGFyZUZhY2FkZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENyeXB0b0ZhY2FkZSB9IGZyb20gXCIuLi8uLi9jcnlwdG8vQ3J5cHRvRmFjYWRlLmpzXCJcbmltcG9ydCB0eXBlIHsgR3JvdXBJbmZvLCBSZWNlaXZlZEdyb3VwSW52aXRhdGlvbiB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgR3JvdXBJbmZvVHlwZVJlZiB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHR5cGUgeyBTaGFyZUNhcGFiaWxpdHkgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL1R1dGFub3RhQ29uc3RhbnRzLmpzXCJcbmltcG9ydCB0eXBlIHsgR3JvdXBJbnZpdGF0aW9uUG9zdERhdGEsIEdyb3VwSW52aXRhdGlvblBvc3RSZXR1cm4sIEludGVybmFsUmVjaXBpZW50S2V5RGF0YSB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy90dXRhbm90YS9UeXBlUmVmcy5qc1wiXG5pbXBvcnQge1xuXHRjcmVhdGVHcm91cEludml0YXRpb25EZWxldGVEYXRhLFxuXHRjcmVhdGVHcm91cEludml0YXRpb25Qb3N0RGF0YSxcblx0Y3JlYXRlR3JvdXBJbnZpdGF0aW9uUHV0RGF0YSxcblx0Y3JlYXRlU2hhcmVkR3JvdXBEYXRhLFxuXHRJbnRlcm5hbFJlY2lwaWVudEtleURhdGFUeXBlUmVmLFxufSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvdHV0YW5vdGEvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgaXNTYW1lVHlwZVJlZiwgbmV2ZXJOdWxsIH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBSZWNpcGllbnRzTm90Rm91bmRFcnJvciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vZXJyb3IvUmVjaXBpZW50c05vdEZvdW5kRXJyb3IuanNcIlxuaW1wb3J0IHsgYXNzZXJ0V29ya2VyT3JOb2RlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9FbnYuanNcIlxuaW1wb3J0IHsgYWVzMjU2UmFuZG9tS2V5LCBiaXRBcnJheVRvVWludDhBcnJheSwgZW5jcnlwdEtleSwgdWludDhBcnJheVRvQml0QXJyYXkgfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLWNyeXB0b1wiXG5pbXBvcnQgeyBJU2VydmljZUV4ZWN1dG9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9TZXJ2aWNlUmVxdWVzdC5qc1wiXG5pbXBvcnQgeyBHcm91cEludml0YXRpb25TZXJ2aWNlIH0gZnJvbSBcIi4uLy4uLy4uL2VudGl0aWVzL3R1dGFub3RhL1NlcnZpY2VzLmpzXCJcbmltcG9ydCB7IFVzZXJGYWNhZGUgfSBmcm9tIFwiLi4vVXNlckZhY2FkZS5qc1wiXG5pbXBvcnQgeyBFbnRpdHlDbGllbnQgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL0VudGl0eUNsaWVudC5qc1wiXG5pbXBvcnQgeyBLZXlMb2FkZXJGYWNhZGUsIHBhcnNlS2V5VmVyc2lvbiB9IGZyb20gXCIuLi9LZXlMb2FkZXJGYWNhZGUuanNcIlxuaW1wb3J0IHsgZW5jcnlwdEJ5dGVzLCBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleSwgZW5jcnlwdFN0cmluZywgVmVyc2lvbmVkS2V5IH0gZnJvbSBcIi4uLy4uL2NyeXB0by9DcnlwdG9XcmFwcGVyLmpzXCJcblxuYXNzZXJ0V29ya2VyT3JOb2RlKClcblxuZXhwb3J0IGNsYXNzIFNoYXJlRmFjYWRlIHtcblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1c2VyRmFjYWRlOiBVc2VyRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgY3J5cHRvRmFjYWRlOiBDcnlwdG9GYWNhZGUsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlRXhlY3V0b3I6IElTZXJ2aWNlRXhlY3V0b3IsXG5cdFx0cHJpdmF0ZSByZWFkb25seSBlbnRpdHlDbGllbnQ6IEVudGl0eUNsaWVudCxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGtleUxvYWRlckZhY2FkZTogS2V5TG9hZGVyRmFjYWRlLFxuXHQpIHt9XG5cblx0YXN5bmMgc2VuZEdyb3VwSW52aXRhdGlvbihcblx0XHRzaGFyZWRHcm91cEluZm86IEdyb3VwSW5mbyxcblx0XHRyZWNpcGllbnRNYWlsQWRkcmVzc2VzOiBBcnJheTxzdHJpbmc+LFxuXHRcdHNoYXJlQ2FwYWJpbGl0eTogU2hhcmVDYXBhYmlsaXR5LFxuXHQpOiBQcm9taXNlPEdyb3VwSW52aXRhdGlvblBvc3RSZXR1cm4+IHtcblx0XHRjb25zdCBzaGFyZWRHcm91cEtleSA9IGF3YWl0IHRoaXMua2V5TG9hZGVyRmFjYWRlLmdldEN1cnJlbnRTeW1Hcm91cEtleShzaGFyZWRHcm91cEluZm8uZ3JvdXApXG5cdFx0Y29uc3QgaW52aXRhdGlvbkRhdGEgPSBhd2FpdCB0aGlzLnByZXBhcmVHcm91cEludml0YXRpb24oc2hhcmVkR3JvdXBLZXksIHNoYXJlZEdyb3VwSW5mbywgcmVjaXBpZW50TWFpbEFkZHJlc3Nlcywgc2hhcmVDYXBhYmlsaXR5KVxuXHRcdHJldHVybiB0aGlzLnNlbmRHcm91cEludml0YXRpb25SZXF1ZXN0KGludml0YXRpb25EYXRhKVxuXHR9XG5cblx0YXN5bmMgc2VuZEdyb3VwSW52aXRhdGlvblJlcXVlc3QoaW52aXRhdGlvbkRhdGE6IEdyb3VwSW52aXRhdGlvblBvc3REYXRhKTogUHJvbWlzZTxHcm91cEludml0YXRpb25Qb3N0UmV0dXJuPiB7XG5cdFx0cmV0dXJuIHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoR3JvdXBJbnZpdGF0aW9uU2VydmljZSwgaW52aXRhdGlvbkRhdGEpXG5cdH1cblxuXHRhc3luYyBwcmVwYXJlR3JvdXBJbnZpdGF0aW9uKFxuXHRcdHNoYXJlZEdyb3VwS2V5OiBWZXJzaW9uZWRLZXksXG5cdFx0c2hhcmVkR3JvdXBJbmZvOiBHcm91cEluZm8sXG5cdFx0cmVjaXBpZW50TWFpbEFkZHJlc3NlczogQXJyYXk8c3RyaW5nPixcblx0XHRzaGFyZUNhcGFiaWxpdHk6IFNoYXJlQ2FwYWJpbGl0eSxcblx0KTogUHJvbWlzZTxHcm91cEludml0YXRpb25Qb3N0RGF0YT4ge1xuXHRcdGNvbnN0IHVzZXJHcm91cEluZm8gPSBhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5sb2FkKEdyb3VwSW5mb1R5cGVSZWYsIHRoaXMudXNlckZhY2FkZS5nZXRMb2dnZWRJblVzZXIoKS51c2VyR3JvdXAuZ3JvdXBJbmZvKVxuXHRcdGNvbnN0IHVzZXJHcm91cEluZm9TZXNzaW9uS2V5ID0gYXdhaXQgdGhpcy5jcnlwdG9GYWNhZGUucmVzb2x2ZVNlc3Npb25LZXlGb3JJbnN0YW5jZSh1c2VyR3JvdXBJbmZvKVxuXHRcdGNvbnN0IHNoYXJlZEdyb3VwSW5mb1Nlc3Npb25LZXkgPSBhd2FpdCB0aGlzLmNyeXB0b0ZhY2FkZS5yZXNvbHZlU2Vzc2lvbktleUZvckluc3RhbmNlKHNoYXJlZEdyb3VwSW5mbylcblx0XHRjb25zdCBidWNrZXRLZXkgPSBhZXMyNTZSYW5kb21LZXkoKVxuXHRcdGNvbnN0IGludml0YXRpb25TZXNzaW9uS2V5ID0gYWVzMjU2UmFuZG9tS2V5KClcblx0XHRjb25zdCBzaGFyZWRHcm91cEVuY0ludml0ZXJHcm91cEluZm9LZXkgPSBlbmNyeXB0S2V5V2l0aFZlcnNpb25lZEtleShzaGFyZWRHcm91cEtleSwgbmV2ZXJOdWxsKHVzZXJHcm91cEluZm9TZXNzaW9uS2V5KSlcblx0XHRjb25zdCBzaGFyZWRHcm91cEVuY1NoYXJlZEdyb3VwSW5mb0tleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KHNoYXJlZEdyb3VwS2V5LCBuZXZlck51bGwoc2hhcmVkR3JvdXBJbmZvU2Vzc2lvbktleSkpXG5cdFx0Y29uc3Qgc2hhcmVkR3JvdXBEYXRhID0gY3JlYXRlU2hhcmVkR3JvdXBEYXRhKHtcblx0XHRcdHNlc3Npb25FbmNJbnZpdGVyTmFtZTogZW5jcnlwdFN0cmluZyhpbnZpdGF0aW9uU2Vzc2lvbktleSwgdXNlckdyb3VwSW5mby5uYW1lKSxcblx0XHRcdHNlc3Npb25FbmNTaGFyZWRHcm91cEtleTogZW5jcnlwdEJ5dGVzKGludml0YXRpb25TZXNzaW9uS2V5LCBiaXRBcnJheVRvVWludDhBcnJheShzaGFyZWRHcm91cEtleS5vYmplY3QpKSxcblx0XHRcdHNlc3Npb25FbmNTaGFyZWRHcm91cE5hbWU6IGVuY3J5cHRTdHJpbmcoaW52aXRhdGlvblNlc3Npb25LZXksIHNoYXJlZEdyb3VwSW5mby5uYW1lKSxcblx0XHRcdGJ1Y2tldEVuY0ludml0YXRpb25TZXNzaW9uS2V5OiBlbmNyeXB0S2V5KGJ1Y2tldEtleSwgaW52aXRhdGlvblNlc3Npb25LZXkpLFxuXHRcdFx0Y2FwYWJpbGl0eTogc2hhcmVDYXBhYmlsaXR5LFxuXHRcdFx0c2hhcmVkR3JvdXA6IHNoYXJlZEdyb3VwSW5mby5ncm91cCxcblx0XHRcdHNoYXJlZEdyb3VwRW5jSW52aXRlckdyb3VwSW5mb0tleTogc2hhcmVkR3JvdXBFbmNJbnZpdGVyR3JvdXBJbmZvS2V5LmtleSxcblx0XHRcdHNoYXJlZEdyb3VwRW5jU2hhcmVkR3JvdXBJbmZvS2V5OiBzaGFyZWRHcm91cEVuY1NoYXJlZEdyb3VwSW5mb0tleS5rZXksXG5cdFx0XHRzaGFyZWRHcm91cEtleVZlcnNpb246IFN0cmluZyhzaGFyZWRHcm91cEtleS52ZXJzaW9uKSxcblx0XHR9KVxuXHRcdGNvbnN0IGludml0YXRpb25EYXRhID0gY3JlYXRlR3JvdXBJbnZpdGF0aW9uUG9zdERhdGEoe1xuXHRcdFx0c2hhcmVkR3JvdXBEYXRhLFxuXHRcdFx0aW50ZXJuYWxLZXlEYXRhOiBbXSxcblx0XHR9KVxuXHRcdGNvbnN0IG5vdEZvdW5kUmVjaXBpZW50czogQXJyYXk8c3RyaW5nPiA9IFtdXG5cblx0XHRmb3IgKGxldCBtYWlsQWRkcmVzcyBvZiByZWNpcGllbnRNYWlsQWRkcmVzc2VzKSB7XG5cdFx0XHRjb25zdCBrZXlEYXRhID0gYXdhaXQgdGhpcy5jcnlwdG9GYWNhZGUuZW5jcnlwdEJ1Y2tldEtleUZvckludGVybmFsUmVjaXBpZW50KHVzZXJHcm91cEluZm8uZ3JvdXAsIGJ1Y2tldEtleSwgbWFpbEFkZHJlc3MsIG5vdEZvdW5kUmVjaXBpZW50cylcblx0XHRcdGlmIChrZXlEYXRhICYmIGlzU2FtZVR5cGVSZWYoa2V5RGF0YS5fdHlwZSwgSW50ZXJuYWxSZWNpcGllbnRLZXlEYXRhVHlwZVJlZikpIHtcblx0XHRcdFx0aW52aXRhdGlvbkRhdGEuaW50ZXJuYWxLZXlEYXRhLnB1c2goa2V5RGF0YSBhcyBJbnRlcm5hbFJlY2lwaWVudEtleURhdGEpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5vdEZvdW5kUmVjaXBpZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgUmVjaXBpZW50c05vdEZvdW5kRXJyb3Iobm90Rm91bmRSZWNpcGllbnRzLmpvaW4oXCJcXG5cIikpXG5cdFx0fVxuXHRcdHJldHVybiBpbnZpdGF0aW9uRGF0YVxuXHR9XG5cblx0YXN5bmMgYWNjZXB0R3JvdXBJbnZpdGF0aW9uKGludml0YXRpb246IFJlY2VpdmVkR3JvdXBJbnZpdGF0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgdXNlckdyb3VwSW5mbyA9IGF3YWl0IHRoaXMuZW50aXR5Q2xpZW50LmxvYWQoR3JvdXBJbmZvVHlwZVJlZiwgdGhpcy51c2VyRmFjYWRlLmdldExvZ2dlZEluVXNlcigpLnVzZXJHcm91cC5ncm91cEluZm8pXG5cdFx0Y29uc3QgdXNlckdyb3VwSW5mb1Nlc3Npb25LZXkgPSBhd2FpdCB0aGlzLmNyeXB0b0ZhY2FkZS5yZXNvbHZlU2Vzc2lvbktleUZvckluc3RhbmNlKHVzZXJHcm91cEluZm8pXG5cdFx0Y29uc3Qgc2hhcmVkR3JvdXBLZXkgPSB7IG9iamVjdDogdWludDhBcnJheVRvQml0QXJyYXkoaW52aXRhdGlvbi5zaGFyZWRHcm91cEtleSksIHZlcnNpb246IHBhcnNlS2V5VmVyc2lvbihpbnZpdGF0aW9uLnNoYXJlZEdyb3VwS2V5VmVyc2lvbikgfVxuXHRcdGNvbnN0IHVzZXJHcm91cEtleSA9IHRoaXMudXNlckZhY2FkZS5nZXRDdXJyZW50VXNlckdyb3VwS2V5KClcblx0XHRjb25zdCB1c2VyR3JvdXBFbmNHcm91cEtleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KHVzZXJHcm91cEtleSwgc2hhcmVkR3JvdXBLZXkub2JqZWN0KVxuXHRcdGNvbnN0IHNoYXJlZEdyb3VwRW5jSW52aXRlZUdyb3VwSW5mb0tleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KHNoYXJlZEdyb3VwS2V5LCBuZXZlck51bGwodXNlckdyb3VwSW5mb1Nlc3Npb25LZXkpKVxuXHRcdGNvbnN0IHNlcnZpY2VEYXRhID0gY3JlYXRlR3JvdXBJbnZpdGF0aW9uUHV0RGF0YSh7XG5cdFx0XHRyZWNlaXZlZEludml0YXRpb246IGludml0YXRpb24uX2lkLFxuXHRcdFx0dXNlckdyb3VwRW5jR3JvdXBLZXk6IHVzZXJHcm91cEVuY0dyb3VwS2V5LmtleSxcblx0XHRcdHNoYXJlZEdyb3VwRW5jSW52aXRlZUdyb3VwSW5mb0tleTogc2hhcmVkR3JvdXBFbmNJbnZpdGVlR3JvdXBJbmZvS2V5LmtleSxcblx0XHRcdHVzZXJHcm91cEtleVZlcnNpb246IHVzZXJHcm91cEVuY0dyb3VwS2V5LmVuY3J5cHRpbmdLZXlWZXJzaW9uLnRvU3RyaW5nKCksXG5cdFx0XHRzaGFyZWRHcm91cEtleVZlcnNpb246IHNoYXJlZEdyb3VwRW5jSW52aXRlZUdyb3VwSW5mb0tleS5lbmNyeXB0aW5nS2V5VmVyc2lvbi50b1N0cmluZygpLFxuXHRcdH0pXG5cdFx0YXdhaXQgdGhpcy5zZXJ2aWNlRXhlY3V0b3IucHV0KEdyb3VwSW52aXRhdGlvblNlcnZpY2UsIHNlcnZpY2VEYXRhKVxuXHR9XG5cblx0YXN5bmMgcmVqZWN0T3JDYW5jZWxHcm91cEludml0YXRpb24ocmVjZWl2ZWRHcm91cEludml0YXRpb25JZDogSWRUdXBsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHNlcnZpY2VEYXRhID0gY3JlYXRlR3JvdXBJbnZpdGF0aW9uRGVsZXRlRGF0YSh7XG5cdFx0XHRyZWNlaXZlZEludml0YXRpb246IHJlY2VpdmVkR3JvdXBJbnZpdGF0aW9uSWQsXG5cdFx0fSlcblx0XHRhd2FpdCB0aGlzLnNlcnZpY2VFeGVjdXRvci5kZWxldGUoR3JvdXBJbnZpdGF0aW9uU2VydmljZSwgc2VydmljZURhdGEpXG5cdH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQSxvQkFBb0I7SUFFUCxjQUFOLE1BQWtCO0NBQ3hCLFlBQ2tCQSxZQUNBQyxjQUNBQyxpQkFDQUMsY0FDQUMsaUJBQ2hCO0VBbUZGLEtBeEZrQjtFQXdGakIsS0F2RmlCO0VBdUZoQixLQXRGZ0I7RUFzRmYsS0FyRmU7RUFxRmQs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