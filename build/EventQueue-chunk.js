import { ProgrammingError } from "./ProgrammingError-chunk.js";
import { findAllAndRemove } from "./dist2-chunk.js";
import { OperationType } from "./TutanotaConstants-chunk.js";
import { ConnectionError, ServiceUnavailableError } from "./RestError-chunk.js";

//#region src/common/api/worker/EventQueue.ts
let EntityModificationType = function(EntityModificationType$1) {
	EntityModificationType$1["CREATE"] = "CREATE";
	EntityModificationType$1["UPDATE"] = "UPDATE";
	EntityModificationType$1["DELETE"] = "DELETE";
	return EntityModificationType$1;
}({});
function batchMod(batchId, batch, entityUpdate) {
	for (const batchEvent of batch) if (entityUpdate.instanceId === batchEvent.instanceId && entityUpdate.instanceListId === batchEvent.instanceListId && entityUpdate.application === batchEvent.application && entityUpdate.type === batchEvent.type) switch (batchEvent.operation) {
		case OperationType.CREATE: return EntityModificationType.CREATE;
		case OperationType.UPDATE: return EntityModificationType.UPDATE;
		case OperationType.DELETE: return EntityModificationType.DELETE;
		default: throw new ProgrammingError(`Unknown operation: ${batchEvent.operation}`);
	}
	throw new ProgrammingError(`Batch does not have events for ${entityUpdate.application}/${entityUpdate.type} ${lastOperationKey(entityUpdate)}, batchId: ${batchId}`);
}
function lastOperationKey(update) {
	const typeIdentifier = `${update.application}/${update.type}`;
	if (update.instanceListId) return `${typeIdentifier}/${update.instanceListId}/${update.instanceId}`;
else return `${typeIdentifier}/${update.instanceId}`;
}
var EventQueue = class {
	/** Batches to process. Oldest first. */
	eventQueue;
	lastOperationForEntity;
	processingBatch;
	paused;
	progressMonitor;
	/**
	* @param tag identifier to make for better log messages
	* @param optimizationEnabled whether the queue should try to optimize events and remove unnecessary ones with the knowledge of newer ones
	* @param queueAction which is executed for each batch. Must *never* throw.
	*/
	constructor(tag, optimizationEnabled, queueAction) {
		this.tag = tag;
		this.optimizationEnabled = optimizationEnabled;
		this.queueAction = queueAction;
		this.eventQueue = [];
		this.lastOperationForEntity = new Map();
		this.processingBatch = null;
		this.paused = false;
		this.progressMonitor = null;
	}
	addBatches(batches) {
		for (const batch of batches) this.add(batch.batchId, batch.groupId, batch.events);
	}
	setProgressMonitor(progressMonitor) {
		this.progressMonitor?.completed();
		this.progressMonitor = progressMonitor;
	}
	/**
	* @return whether the batch was added (not optimized away)
	*/
	add(batchId, groupId, newEvents) {
		const newBatch = {
			events: [],
			groupId,
			batchId
		};
		if (!this.optimizationEnabled) newBatch.events.push(...newEvents);
else this.optimizingAddEvents(newBatch, batchId, groupId, newEvents);
		if (newBatch.events.length !== 0) {
			this.eventQueue.push(newBatch);
			for (const update of newBatch.events) this.lastOperationForEntity.set(lastOperationKey(update), newBatch);
		}
		this.start();
		return newBatch.events.length > 0;
	}
	optimizingAddEvents(newBatch, batchId, groupId, newEvents) {
		for (const newEvent of newEvents) {
			const lastOpKey = lastOperationKey(newEvent);
			const lastBatchForEntity = this.lastOperationForEntity.get(lastOpKey);
			if (lastBatchForEntity == null || this.processingBatch != null && this.processingBatch === lastBatchForEntity || groupId !== lastBatchForEntity.groupId) newBatch.events.push(newEvent);
else {
				const newEntityModification = batchMod(batchId, newEvents, newEvent);
				const lastEntityModification = batchMod(lastBatchForEntity.batchId, lastBatchForEntity.events, newEvent);
				if (newEntityModification === EntityModificationType.UPDATE) switch (lastEntityModification) {
					case EntityModificationType.CREATE: break;
					case EntityModificationType.UPDATE: break;
					case EntityModificationType.DELETE: throw new ProgrammingError(`UPDATE not allowed after DELETE. Last batch: ${lastBatchForEntity.batchId}, new batch: ${batchId}, ${newEvent.type} ${lastOpKey}`);
				}
else if (newEntityModification === EntityModificationType.DELETE) {
					this.removeEventsForInstance(lastOpKey);
					this.lastOperationForEntity.set(lastOpKey, newBatch);
					newBatch.events.push(newEvent);
				} else if (newEntityModification === EntityModificationType.CREATE) if (lastEntityModification === EntityModificationType.DELETE || lastEntityModification === EntityModificationType.CREATE) newBatch.events.push(newEvent);
else throw new ProgrammingError(`Impossible modification combination ${lastEntityModification} ${newEntityModification} ${JSON.stringify(newEvent)}`);
else throw new ProgrammingError(`Impossible modification combination ${lastEntityModification} ${newEntityModification} ${JSON.stringify(newEvent)}`);
			}
		}
	}
	removeEventsForInstance(operationKey, startIndex = 0) {
		for (let i = startIndex; i < this.eventQueue.length; i++) {
			const batchInThePast = this.eventQueue[i];
			if (this.processingBatch === batchInThePast) continue;
			findAllAndRemove(batchInThePast.events, (event) => event.operation !== OperationType.DELETE && lastOperationKey(event) === operationKey);
		}
	}
	start() {
		if (this.processingBatch) return;
		this.processNext();
	}
	queueSize() {
		return this.eventQueue.length;
	}
	processNext() {
		if (this.paused) return;
		const next = this.eventQueue[0];
		if (next) {
			this.processingBatch = next;
			this.queueAction(next).then(() => {
				this.eventQueue.shift();
				this.progressMonitor?.workDone(1);
				this.processingBatch = null;
				for (const event of next.events) {
					const concatenatedId = lastOperationKey(event);
					if (this.lastOperationForEntity.get(concatenatedId) === next) this.lastOperationForEntity.delete(concatenatedId);
				}
				this.processNext();
			}).catch((e) => {
				console.log("EventQueue", this.tag, this.optimizationEnabled, "error", next, e);
				this.processingBatch = null;
				if (!(e instanceof ServiceUnavailableError || e instanceof ConnectionError)) console.error("Uncaught EventQueue error!", e, next);
			});
		}
	}
	clear() {
		this.eventQueue.splice(0);
		this.processingBatch = null;
		for (const k of this.lastOperationForEntity.keys()) this.lastOperationForEntity.delete(k);
	}
	pause() {
		this.paused = true;
	}
	resume() {
		this.paused = false;
		this.start();
	}
	/** @private visibleForTesting */
	get __processingBatch() {
		return this.processingBatch;
	}
};

//#endregion
export { EventQueue };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXZlbnRRdWV1ZS1jaHVuay5qcyIsIm5hbWVzIjpbImJhdGNoSWQ6IElkIiwiYmF0Y2g6IFJlYWRvbmx5QXJyYXk8RW50aXR5VXBkYXRlPiIsImVudGl0eVVwZGF0ZTogRW50aXR5VXBkYXRlIiwidXBkYXRlOiBFbnRpdHlVcGRhdGUiLCJ0YWc6IHN0cmluZyIsIm9wdGltaXphdGlvbkVuYWJsZWQ6IGJvb2xlYW4iLCJxdWV1ZUFjdGlvbjogUXVldWVBY3Rpb24iLCJiYXRjaGVzOiBSZWFkb25seUFycmF5PFF1ZXVlZEJhdGNoPiIsInByb2dyZXNzTW9uaXRvcjogUHJvZ3Jlc3NNb25pdG9yRGVsZWdhdGUiLCJncm91cElkOiBJZCIsIm5ld0V2ZW50czogUmVhZG9ubHlBcnJheTxFbnRpdHlVcGRhdGU+IiwibmV3QmF0Y2g6IFF1ZXVlZEJhdGNoIiwib3BlcmF0aW9uS2V5OiBMYXN0T3BlcmF0aW9uS2V5Iiwic3RhcnRJbmRleDogbnVtYmVyIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9hcGkvd29ya2VyL0V2ZW50UXVldWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gXCIuLi9jb21tb24vVHV0YW5vdGFDb25zdGFudHMuanNcIlxuaW1wb3J0IHsgZmluZEFsbEFuZFJlbW92ZSB9IGZyb20gXCJAdHV0YW8vdHV0YW5vdGEtdXRpbHNcIlxuaW1wb3J0IHsgQ29ubmVjdGlvbkVycm9yLCBTZXJ2aWNlVW5hdmFpbGFibGVFcnJvciB9IGZyb20gXCIuLi9jb21tb24vZXJyb3IvUmVzdEVycm9yLmpzXCJcbmltcG9ydCB0eXBlIHsgRW50aXR5VXBkYXRlIH0gZnJvbSBcIi4uL2VudGl0aWVzL3N5cy9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBQcm9ncmFtbWluZ0Vycm9yIH0gZnJvbSBcIi4uL2NvbW1vbi9lcnJvci9Qcm9ncmFtbWluZ0Vycm9yLmpzXCJcbmltcG9ydCB7IFByb2dyZXNzTW9uaXRvckRlbGVnYXRlIH0gZnJvbSBcIi4vUHJvZ3Jlc3NNb25pdG9yRGVsZWdhdGUuanNcIlxuXG5leHBvcnQgdHlwZSBRdWV1ZWRCYXRjaCA9IHtcblx0ZXZlbnRzOiBFbnRpdHlVcGRhdGVbXVxuXHRncm91cElkOiBJZFxuXHRiYXRjaElkOiBJZFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBFbnRpdHlNb2RpZmljYXRpb25UeXBlIHtcblx0Q1JFQVRFID0gXCJDUkVBVEVcIixcblx0VVBEQVRFID0gXCJVUERBVEVcIixcblx0REVMRVRFID0gXCJERUxFVEVcIixcbn1cblxudHlwZSBRdWV1ZUFjdGlvbiA9IChuZXh0RWxlbWVudDogUXVldWVkQmF0Y2gpID0+IFByb21pc2U8dm9pZD5cblxuLyoqXG4gKiBDaGVja3Mgd2hpY2ggbW9kaWZpY2F0aW9uIGlzIGFwcGxpZWQgaW4gdGhlIGdpdmVuIGJhdGNoIGZvciB0aGUgZW50aXR5IGlkLlxuICogQHBhcmFtIGJhdGNoIGVudGl0eSB1cGRhdGVzIG9mIHRoZSBiYXRjaC5cbiAqIEBwcml2YXRlIHZpc2libGVGb3JUZXN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmF0Y2hNb2QoYmF0Y2hJZDogSWQsIGJhdGNoOiBSZWFkb25seUFycmF5PEVudGl0eVVwZGF0ZT4sIGVudGl0eVVwZGF0ZTogRW50aXR5VXBkYXRlKTogRW50aXR5TW9kaWZpY2F0aW9uVHlwZSB7XG5cdGZvciAoY29uc3QgYmF0Y2hFdmVudCBvZiBiYXRjaCkge1xuXHRcdGlmIChcblx0XHRcdGVudGl0eVVwZGF0ZS5pbnN0YW5jZUlkID09PSBiYXRjaEV2ZW50Lmluc3RhbmNlSWQgJiZcblx0XHRcdGVudGl0eVVwZGF0ZS5pbnN0YW5jZUxpc3RJZCA9PT0gYmF0Y2hFdmVudC5pbnN0YW5jZUxpc3RJZCAmJlxuXHRcdFx0ZW50aXR5VXBkYXRlLmFwcGxpY2F0aW9uID09PSBiYXRjaEV2ZW50LmFwcGxpY2F0aW9uICYmXG5cdFx0XHRlbnRpdHlVcGRhdGUudHlwZSA9PT0gYmF0Y2hFdmVudC50eXBlXG5cdFx0KSB7XG5cdFx0XHRzd2l0Y2ggKGJhdGNoRXZlbnQub3BlcmF0aW9uKSB7XG5cdFx0XHRcdGNhc2UgT3BlcmF0aW9uVHlwZS5DUkVBVEU6XG5cdFx0XHRcdFx0cmV0dXJuIEVudGl0eU1vZGlmaWNhdGlvblR5cGUuQ1JFQVRFXG5cblx0XHRcdFx0Y2FzZSBPcGVyYXRpb25UeXBlLlVQREFURTpcblx0XHRcdFx0XHRyZXR1cm4gRW50aXR5TW9kaWZpY2F0aW9uVHlwZS5VUERBVEVcblxuXHRcdFx0XHRjYXNlIE9wZXJhdGlvblR5cGUuREVMRVRFOlxuXHRcdFx0XHRcdHJldHVybiBFbnRpdHlNb2RpZmljYXRpb25UeXBlLkRFTEVURVxuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFByb2dyYW1taW5nRXJyb3IoYFVua25vd24gb3BlcmF0aW9uOiAke2JhdGNoRXZlbnQub3BlcmF0aW9ufWApXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgbmV3IFByb2dyYW1taW5nRXJyb3IoXG5cdFx0YEJhdGNoIGRvZXMgbm90IGhhdmUgZXZlbnRzIGZvciAke2VudGl0eVVwZGF0ZS5hcHBsaWNhdGlvbn0vJHtlbnRpdHlVcGRhdGUudHlwZX0gJHtsYXN0T3BlcmF0aW9uS2V5KGVudGl0eVVwZGF0ZSl9LCBiYXRjaElkOiAke2JhdGNoSWR9YCxcblx0KVxufVxuXG4vLyBBIGtleSBmb3IgX2xhc3RPcGVyYXRpb25Gb3JFbnRpdHkuXG4vLyBBdCBydW50aW1lIGp1c3QgYW4gZWxlbWVudCBpZCBvciBsaXN0SWQvZWxlbWVudElkLlxuLy8gQWRkaW5nIGJyYW5kIGZvciB0eXBlIHNhZmV0eS5cbnR5cGUgTGFzdE9wZXJhdGlvbktleSA9IHN0cmluZyAmIHsgX19icmFuZDogXCJsYXN0T3BlS2V5XCIgfVxuXG5mdW5jdGlvbiBsYXN0T3BlcmF0aW9uS2V5KHVwZGF0ZTogRW50aXR5VXBkYXRlKTogTGFzdE9wZXJhdGlvbktleSB7XG5cdGNvbnN0IHR5cGVJZGVudGlmaWVyID0gYCR7dXBkYXRlLmFwcGxpY2F0aW9ufS8ke3VwZGF0ZS50eXBlfWBcblx0aWYgKHVwZGF0ZS5pbnN0YW5jZUxpc3RJZCkge1xuXHRcdHJldHVybiBgJHt0eXBlSWRlbnRpZmllcn0vJHt1cGRhdGUuaW5zdGFuY2VMaXN0SWR9LyR7dXBkYXRlLmluc3RhbmNlSWR9YCBhcyBMYXN0T3BlcmF0aW9uS2V5XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGAke3R5cGVJZGVudGlmaWVyfS8ke3VwZGF0ZS5pbnN0YW5jZUlkfWAgYXMgTGFzdE9wZXJhdGlvbktleVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBFdmVudFF1ZXVlIHtcblx0LyoqIEJhdGNoZXMgdG8gcHJvY2Vzcy4gT2xkZXN0IGZpcnN0LiAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IGV2ZW50UXVldWU6IEFycmF5PFF1ZXVlZEJhdGNoPlxuXHQvLyB0aGUgbGFzdCBwcm9jZXNzZWQgb3BlcmF0aW9uIGZvciBhIGdpdmVuIGVudGl0eSBpZFxuXHRwcml2YXRlIHJlYWRvbmx5IGxhc3RPcGVyYXRpb25Gb3JFbnRpdHk6IE1hcDxMYXN0T3BlcmF0aW9uS2V5LCBRdWV1ZWRCYXRjaD5cblx0cHJpdmF0ZSBwcm9jZXNzaW5nQmF0Y2g6IFF1ZXVlZEJhdGNoIHwgbnVsbFxuXHRwcml2YXRlIHBhdXNlZDogYm9vbGVhblxuXHRwcml2YXRlIHByb2dyZXNzTW9uaXRvcjogUHJvZ3Jlc3NNb25pdG9yRGVsZWdhdGUgfCBudWxsXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB0YWcgaWRlbnRpZmllciB0byBtYWtlIGZvciBiZXR0ZXIgbG9nIG1lc3NhZ2VzXG5cdCAqIEBwYXJhbSBvcHRpbWl6YXRpb25FbmFibGVkIHdoZXRoZXIgdGhlIHF1ZXVlIHNob3VsZCB0cnkgdG8gb3B0aW1pemUgZXZlbnRzIGFuZCByZW1vdmUgdW5uZWNlc3Nhcnkgb25lcyB3aXRoIHRoZSBrbm93bGVkZ2Ugb2YgbmV3ZXIgb25lc1xuXHQgKiBAcGFyYW0gcXVldWVBY3Rpb24gd2hpY2ggaXMgZXhlY3V0ZWQgZm9yIGVhY2ggYmF0Y2guIE11c3QgKm5ldmVyKiB0aHJvdy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdGFnOiBzdHJpbmcsIHByaXZhdGUgcmVhZG9ubHkgb3B0aW1pemF0aW9uRW5hYmxlZDogYm9vbGVhbiwgcHJpdmF0ZSByZWFkb25seSBxdWV1ZUFjdGlvbjogUXVldWVBY3Rpb24pIHtcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBbXVxuXHRcdHRoaXMubGFzdE9wZXJhdGlvbkZvckVudGl0eSA9IG5ldyBNYXAoKVxuXHRcdHRoaXMucHJvY2Vzc2luZ0JhdGNoID0gbnVsbFxuXHRcdHRoaXMucGF1c2VkID0gZmFsc2Vcblx0XHR0aGlzLnByb2dyZXNzTW9uaXRvciA9IG51bGxcblx0fVxuXG5cdGFkZEJhdGNoZXMoYmF0Y2hlczogUmVhZG9ubHlBcnJheTxRdWV1ZWRCYXRjaD4pIHtcblx0XHRmb3IgKGNvbnN0IGJhdGNoIG9mIGJhdGNoZXMpIHtcblx0XHRcdHRoaXMuYWRkKGJhdGNoLmJhdGNoSWQsIGJhdGNoLmdyb3VwSWQsIGJhdGNoLmV2ZW50cylcblx0XHR9XG5cdH1cblxuXHRzZXRQcm9ncmVzc01vbml0b3IocHJvZ3Jlc3NNb25pdG9yOiBQcm9ncmVzc01vbml0b3JEZWxlZ2F0ZSkge1xuXHRcdHRoaXMucHJvZ3Jlc3NNb25pdG9yPy5jb21wbGV0ZWQoKSAvLyBtYWtlIHN1cmUgYW55IG9sZCBtb25pdG9yIGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrXG5cdFx0dGhpcy5wcm9ncmVzc01vbml0b3IgPSBwcm9ncmVzc01vbml0b3Jcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHdoZXRoZXIgdGhlIGJhdGNoIHdhcyBhZGRlZCAobm90IG9wdGltaXplZCBhd2F5KVxuXHQgKi9cblx0YWRkKGJhdGNoSWQ6IElkLCBncm91cElkOiBJZCwgbmV3RXZlbnRzOiBSZWFkb25seUFycmF5PEVudGl0eVVwZGF0ZT4pOiBib29sZWFuIHtcblx0XHRjb25zdCBuZXdCYXRjaDogUXVldWVkQmF0Y2ggPSB7XG5cdFx0XHRldmVudHM6IFtdLFxuXHRcdFx0Z3JvdXBJZCxcblx0XHRcdGJhdGNoSWQsXG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGltaXphdGlvbkVuYWJsZWQpIHtcblx0XHRcdG5ld0JhdGNoLmV2ZW50cy5wdXNoKC4uLm5ld0V2ZW50cylcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcHRpbWl6aW5nQWRkRXZlbnRzKG5ld0JhdGNoLCBiYXRjaElkLCBncm91cElkLCBuZXdFdmVudHMpXG5cdFx0fVxuXG5cdFx0aWYgKG5ld0JhdGNoLmV2ZW50cy5sZW5ndGggIT09IDApIHtcblx0XHRcdHRoaXMuZXZlbnRRdWV1ZS5wdXNoKG5ld0JhdGNoKVxuXG5cdFx0XHRmb3IgKGNvbnN0IHVwZGF0ZSBvZiBuZXdCYXRjaC5ldmVudHMpIHtcblx0XHRcdFx0dGhpcy5sYXN0T3BlcmF0aW9uRm9yRW50aXR5LnNldChsYXN0T3BlcmF0aW9uS2V5KHVwZGF0ZSksIG5ld0JhdGNoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGVuc3VyZXMgdGhhdCBldmVudHMgYXJlIHByb2Nlc3NlZCB3aGVuIG5vdCBwYXVzZWRcblx0XHR0aGlzLnN0YXJ0KClcblx0XHRyZXR1cm4gbmV3QmF0Y2guZXZlbnRzLmxlbmd0aCA+IDBcblx0fVxuXG5cdHByaXZhdGUgb3B0aW1pemluZ0FkZEV2ZW50cyhuZXdCYXRjaDogUXVldWVkQmF0Y2gsIGJhdGNoSWQ6IElkLCBncm91cElkOiBJZCwgbmV3RXZlbnRzOiBSZWFkb25seUFycmF5PEVudGl0eVVwZGF0ZT4pOiB2b2lkIHtcblx0XHRmb3IgKGNvbnN0IG5ld0V2ZW50IG9mIG5ld0V2ZW50cykge1xuXHRcdFx0Y29uc3QgbGFzdE9wS2V5ID0gbGFzdE9wZXJhdGlvbktleShuZXdFdmVudClcblx0XHRcdGNvbnN0IGxhc3RCYXRjaEZvckVudGl0eSA9IHRoaXMubGFzdE9wZXJhdGlvbkZvckVudGl0eS5nZXQobGFzdE9wS2V5KVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRsYXN0QmF0Y2hGb3JFbnRpdHkgPT0gbnVsbCB8fFxuXHRcdFx0XHQodGhpcy5wcm9jZXNzaW5nQmF0Y2ggIT0gbnVsbCAmJiB0aGlzLnByb2Nlc3NpbmdCYXRjaCA9PT0gbGFzdEJhdGNoRm9yRW50aXR5KSB8fFxuXHRcdFx0XHRncm91cElkICE9PSBsYXN0QmF0Y2hGb3JFbnRpdHkuZ3JvdXBJZFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIElmIHRoZXJlJ3Mgbm8gY3VycmVudCBvcGVyYXRpb24sIHRoZXJlJ3Mgbm90aGluZyB0byBtZXJnZSwganVzdCBhZGRcblx0XHRcdFx0Ly8gSWYgY3VycmVudCBvcGVyYXRpb24gaXMgYWxyZWFkeSBiZWluZyBwcm9jZXNzZWQsIGRvbid0IG1vZGlmeSBpdCwgd2UgY2Fubm90IG1lcmdlIGFueW1vcmUgYW5kIHNob3VsZCBqdXN0IGFwcGVuZC5cblx0XHRcdFx0bmV3QmF0Y2guZXZlbnRzLnB1c2gobmV3RXZlbnQpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBuZXdFbnRpdHlNb2RpZmljYXRpb24gPSBiYXRjaE1vZChiYXRjaElkLCBuZXdFdmVudHMsIG5ld0V2ZW50KVxuXHRcdFx0XHRjb25zdCBsYXN0RW50aXR5TW9kaWZpY2F0aW9uID0gYmF0Y2hNb2QobGFzdEJhdGNoRm9yRW50aXR5LmJhdGNoSWQsIGxhc3RCYXRjaEZvckVudGl0eS5ldmVudHMsIG5ld0V2ZW50KVxuXG5cdFx0XHRcdGlmIChuZXdFbnRpdHlNb2RpZmljYXRpb24gPT09IEVudGl0eU1vZGlmaWNhdGlvblR5cGUuVVBEQVRFKSB7XG5cdFx0XHRcdFx0c3dpdGNoIChsYXN0RW50aXR5TW9kaWZpY2F0aW9uKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEVudGl0eU1vZGlmaWNhdGlvblR5cGUuQ1JFQVRFOlxuXHRcdFx0XHRcdFx0XHQvLyBTa2lwIGNyZWF0ZSBiZWNhdXNlIHRoZSBjcmVhdGUgd2FzIG5vdCBwcm9jZXNzZWQgeWV0IGFuZCB3ZSB3aWxsIGRvd25sb2FkIHRoZSB1cGRhdGVkIHZlcnNpb24gYWxyZWFkeVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVudGl0eU1vZGlmaWNhdGlvblR5cGUuVVBEQVRFOlxuXHRcdFx0XHRcdFx0XHQvLyBTa2lwIHVwZGF0ZSBiZWNhdXNlIHRoZSBwcmV2aW91cyB1cGRhdGUgd2FzIG5vdCBwcm9jZXNzZWQgeWV0IGFuZCB3ZSB3aWxsIGRvd25sb2FkIHRoZSB1cGRhdGVkIHZlcnNpb24gYWxyZWFkeVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVudGl0eU1vZGlmaWNhdGlvblR5cGUuREVMRVRFOlxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgUHJvZ3JhbW1pbmdFcnJvcihcblx0XHRcdFx0XHRcdFx0XHRgVVBEQVRFIG5vdCBhbGxvd2VkIGFmdGVyIERFTEVURS4gTGFzdCBiYXRjaDogJHtsYXN0QmF0Y2hGb3JFbnRpdHkuYmF0Y2hJZH0sIG5ldyBiYXRjaDogJHtiYXRjaElkfSwgJHtuZXdFdmVudC50eXBlfSAke2xhc3RPcEtleX1gLFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG5ld0VudGl0eU1vZGlmaWNhdGlvbiA9PT0gRW50aXR5TW9kaWZpY2F0aW9uVHlwZS5ERUxFVEUpIHtcblx0XHRcdFx0XHQvLyBkZWxldGUgYWxsIG90aGVyIGV2ZW50cyBiZWNhdXNlIHRoZXkgZG9uJ3QgbWF0dGVyIGlmIHRoZSBlbnRpdHkgaXMgYWxyZWFkeSBnb25lXG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudHNGb3JJbnN0YW5jZShsYXN0T3BLZXkpXG5cdFx0XHRcdFx0Ly8gc2V0IGxhc3Qgb3BlcmF0aW9uIGVhcmx5IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3Mgbm90IHNvbWUgZW1wdHkgYmF0Y2ggdGhhdCBpcyB0aGUgbGFzdCBvcGVyYXRpb24sIG90aGVyd2lzZSBiYXRjaE1vZCB3aWxsIGZhaWwuXG5cdFx0XHRcdFx0Ly8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuIChiZWNhdXNlIGRlbGV0ZSArIGNyZWF0ZSBmb3IgdGhlIHNhbWUgZW50aXR5IGluIHRoZSBzYW1lIGJhdGNoIGlzIG5vdCByZWFsbHkgYSB0aGluZykgYW5kIGlzIGEgYml0IGhhY2t5LFxuXHRcdFx0XHRcdC8vIGJ1dCBpdCB3b3Jrcz9cblx0XHRcdFx0XHR0aGlzLmxhc3RPcGVyYXRpb25Gb3JFbnRpdHkuc2V0KGxhc3RPcEtleSwgbmV3QmF0Y2gpXG5cdFx0XHRcdFx0Ly8gYWRkIGRlbGV0ZSBldmVudFxuXHRcdFx0XHRcdG5ld0JhdGNoLmV2ZW50cy5wdXNoKG5ld0V2ZW50KVxuXHRcdFx0XHR9IGVsc2UgaWYgKG5ld0VudGl0eU1vZGlmaWNhdGlvbiA9PT0gRW50aXR5TW9kaWZpY2F0aW9uVHlwZS5DUkVBVEUpIHtcblx0XHRcdFx0XHRpZiAobGFzdEVudGl0eU1vZGlmaWNhdGlvbiA9PT0gRW50aXR5TW9kaWZpY2F0aW9uVHlwZS5ERUxFVEUgfHwgbGFzdEVudGl0eU1vZGlmaWNhdGlvbiA9PT0gRW50aXR5TW9kaWZpY2F0aW9uVHlwZS5DUkVBVEUpIHtcblx0XHRcdFx0XHRcdC8vIEl0IGlzIGxpa2VseSBjdXN0b20gaWQgaW5zdGFuY2Ugd2hpY2ggZ290IHJlLWNyZWF0ZWRcblx0XHRcdFx0XHRcdG5ld0JhdGNoLmV2ZW50cy5wdXNoKG5ld0V2ZW50KVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgUHJvZ3JhbW1pbmdFcnJvcihcblx0XHRcdFx0XHRcdFx0YEltcG9zc2libGUgbW9kaWZpY2F0aW9uIGNvbWJpbmF0aW9uICR7bGFzdEVudGl0eU1vZGlmaWNhdGlvbn0gJHtuZXdFbnRpdHlNb2RpZmljYXRpb259ICR7SlNPTi5zdHJpbmdpZnkobmV3RXZlbnQpfWAsXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBQcm9ncmFtbWluZ0Vycm9yKFxuXHRcdFx0XHRcdFx0YEltcG9zc2libGUgbW9kaWZpY2F0aW9uIGNvbWJpbmF0aW9uICR7bGFzdEVudGl0eU1vZGlmaWNhdGlvbn0gJHtuZXdFbnRpdHlNb2RpZmljYXRpb259ICR7SlNPTi5zdHJpbmdpZnkobmV3RXZlbnQpfWAsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVFdmVudHNGb3JJbnN0YW5jZShvcGVyYXRpb25LZXk6IExhc3RPcGVyYXRpb25LZXksIHN0YXJ0SW5kZXg6IG51bWJlciA9IDApOiB2b2lkIHtcblx0XHQvLyBXZSBrZWVwIGVtcHR5IGJhdGNoZXMgYmVjYXVzZSB3ZSBleHBlY3QgY2VydGFpbiBudW1iZXIgb2YgYmF0Y2hlcyB0byBiZSBwcm9jZXNzZWQgYW5kIGl0J3MgZWFzaWVyIHRvIGp1c3Qga2VlcCB0aGVtLlxuXHRcdGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgdGhpcy5ldmVudFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBiYXRjaEluVGhlUGFzdCA9IHRoaXMuZXZlbnRRdWV1ZVtpXVxuXHRcdFx0aWYgKHRoaXMucHJvY2Vzc2luZ0JhdGNoID09PSBiYXRjaEluVGhlUGFzdCkge1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVtb3ZlIGFsbCBldmVudHMgZm9yIHRoZSBlbGVtZW50IGlkIGZyb20gdGhlIGJhdGNoXG5cdFx0XHQvLyB3ZSBrZWVwIGRlbGV0ZSBldmVudHMgYmVjYXVzZSB0aGV5IGRvbid0IGh1cnQgZ2VuZXJhbGx5IGFuZCB3ZSBhbHNvIHdhbnQgdGhpbmdzIHRvIGJlIHRpbWVseSBkZWxldGVkXG5cdFx0XHRmaW5kQWxsQW5kUmVtb3ZlKGJhdGNoSW5UaGVQYXN0LmV2ZW50cywgKGV2ZW50KSA9PiBldmVudC5vcGVyYXRpb24gIT09IE9wZXJhdGlvblR5cGUuREVMRVRFICYmIGxhc3RPcGVyYXRpb25LZXkoZXZlbnQpID09PSBvcGVyYXRpb25LZXkpXG5cdFx0fVxuXHR9XG5cblx0c3RhcnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvY2Vzc2luZ0JhdGNoKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR0aGlzLnByb2Nlc3NOZXh0KClcblx0fVxuXG5cdHF1ZXVlU2l6ZSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmV2ZW50UXVldWUubGVuZ3RoXG5cdH1cblxuXHRwcml2YXRlIHByb2Nlc3NOZXh0KCkge1xuXHRcdGlmICh0aGlzLnBhdXNlZCkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV4dCA9IHRoaXMuZXZlbnRRdWV1ZVswXVxuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdHRoaXMucHJvY2Vzc2luZ0JhdGNoID0gbmV4dFxuXG5cdFx0XHR0aGlzLnF1ZXVlQWN0aW9uKG5leHQpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmV2ZW50UXVldWUuc2hpZnQoKVxuXHRcdFx0XHRcdHRoaXMucHJvZ3Jlc3NNb25pdG9yPy53b3JrRG9uZSgxKVxuXHRcdFx0XHRcdHRoaXMucHJvY2Vzc2luZ0JhdGNoID0gbnVsbFxuXG5cdFx0XHRcdFx0Ly8gV2hlbiB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBiYXRjaCwgd2UgZG9uJ3Qgd2FudCB0byBtZXJnZSB3aXRoIGl0IGFueW1vcmVcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGV2ZW50IG9mIG5leHQuZXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjb25jYXRlbmF0ZWRJZCA9IGxhc3RPcGVyYXRpb25LZXkoZXZlbnQpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5sYXN0T3BlcmF0aW9uRm9yRW50aXR5LmdldChjb25jYXRlbmF0ZWRJZCkgPT09IG5leHQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5sYXN0T3BlcmF0aW9uRm9yRW50aXR5LmRlbGV0ZShjb25jYXRlbmF0ZWRJZClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLnByb2Nlc3NOZXh0KClcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKChlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJFdmVudFF1ZXVlXCIsIHRoaXMudGFnLCB0aGlzLm9wdGltaXphdGlvbkVuYWJsZWQsIFwiZXJyb3JcIiwgbmV4dCwgZSlcblx0XHRcdFx0XHQvLyBwcm9jZXNzaW5nIGNvbnRpbnVlcyBpZiB0aGUgZXZlbnQgYnVzIHJlY2VpdmVzIGEgbmV3IGV2ZW50XG5cdFx0XHRcdFx0dGhpcy5wcm9jZXNzaW5nQmF0Y2ggPSBudWxsXG5cblx0XHRcdFx0XHRpZiAoIShlIGluc3RhbmNlb2YgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IgfHwgZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJVbmNhdWdodCBFdmVudFF1ZXVlIGVycm9yIVwiLCBlLCBuZXh0KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHRjbGVhcigpIHtcblx0XHR0aGlzLmV2ZW50UXVldWUuc3BsaWNlKDApXG5cblx0XHR0aGlzLnByb2Nlc3NpbmdCYXRjaCA9IG51bGxcblxuXHRcdGZvciAoY29uc3QgayBvZiB0aGlzLmxhc3RPcGVyYXRpb25Gb3JFbnRpdHkua2V5cygpKSB7XG5cdFx0XHR0aGlzLmxhc3RPcGVyYXRpb25Gb3JFbnRpdHkuZGVsZXRlKGspXG5cdFx0fVxuXHR9XG5cblx0cGF1c2UoKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlXG5cdH1cblxuXHRyZXN1bWUoKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZVxuXHRcdHRoaXMuc3RhcnQoKVxuXHR9XG5cblx0LyoqIEBwcml2YXRlIHZpc2libGVGb3JUZXN0aW5nICovXG5cdGdldCBfX3Byb2Nlc3NpbmdCYXRjaCgpOiBRdWV1ZWRCYXRjaCB8IG51bGwg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